Pull,Path,Diff_hunk,Comment
17,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -16,30 +16,15 @@
  */
 package org.apache.commons.collections4;
 
-import java.lang.reflect.Array;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.Map;
-import java.util.Set;
-
 import org.apache.commons.collections4.bag.HashBag;
-import org.apache.commons.collections4.collection.PredicatedCollection;
-import org.apache.commons.collections4.collection.SynchronizedCollection;
-import org.apache.commons.collections4.collection.TransformedCollection;
-import org.apache.commons.collections4.collection.UnmodifiableBoundedCollection;
-import org.apache.commons.collections4.collection.UnmodifiableCollection;
+import org.apache.commons.collections4.collection.*;","[{'comment': 'It is preferable to leave import each class individually.', 'commenter': 'kinow'}, {'comment': 'ok, i got it)', 'commenter': 'izebit'}]"
17,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -180,8 +165,7 @@ public void setCardinality(final O obj, final int count) {
      * undesirable. This implementation only implements Collection.
      */
     @SuppressWarnings(""rawtypes"") // we deliberately use the raw type here
-    public static final Collection EMPTY_COLLECTION =
-        UnmodifiableCollection.unmodifiableCollection(new ArrayList<Object>());
+    public static final Collection EMPTY_COLLECTION = Collections.emptyList();","[{'comment': 'Nice catch!', 'commenter': 'kinow'}, {'comment': ':))', 'commenter': 'izebit'}]"
17,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -1112,6 +1093,7 @@ public int hashCode() {
      * @return a boolean indicating whether the collection has changed or not.
      * @throws NullPointerException if the collection or iterator is null
      */
+    @SuppressWarnings(""unchecked"")","[{'comment': ""Is that necessary? I'm comparing with a local working copy of the trunk branch, looking ad the addAll method I have, it doesn't seem necessary. Perhaps it needs to be rebased and revised against last changes?"", 'commenter': 'kinow'}, {'comment': 'Of cource, it is minor. this is not necessary, but if it is applied, warnings about not correct cast will disappear. I talked about this code: `collection.addAll((Collection<? extends C>) iterable)`', 'commenter': 'izebit'}, {'comment': 'I might still be missing something here... Reviewing online, it didn\'t seem to be necessary. Just imported the code to Eclipse, and the project has 41 Warnings. This annotation being one of the warnings, being marked as ""Unnecessary @SuppressWarnings(""unchecked"")"".', 'commenter': 'kinow'}, {'comment': 'Hmm, It is very interesting. My IDE, (i use intellij idea), warns me about _unchecked cast_. Maybe,  it is a false warning. if you think that is not necessary, i will not persist :)', 'commenter': 'izebit'}, {'comment': ""Removing in NetBeans (how nostalgic it was to use it) also did not raise any warnings. However, NetBeans has a lot of other warnings and errors that do not appear in Eclipse. I thought the IDE's would all agree upon what to check or not, but searching the Internet I found some other reports from differences in Eclipse/IntelliJ regarding these suppresswarnings cases. Let's leave as is for now, and we can revisit it later. So all good to be merged I believe?\r\n\r\n![screenshot_2017-05-24_11-28-05](https://cloud.githubusercontent.com/assets/304786/26380723/67d0de64-4074-11e7-9658-e5632dbe871a.png)\r\n"", 'commenter': 'kinow'}, {'comment': 'I agree with you. You are right. I had try to compile the code by `javac` with flag `-Xlint:all` and did not see any warnings. Then Intellij Idea shows false warning or the warning are not for compiler, it is more for a programmer. \r\nYes, all good to be merged. \r\n\r\nP.S. Netbeans is in my heart, too :)', 'commenter': 'izebit'}]"
17,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -1266,9 +1248,6 @@ public static Object get(final Object object, final int index) {
         } else if (object instanceof Iterable<?>) {
             final Iterable<?> iterable = (Iterable<?>) object;
             return IterableUtils.get(iterable, i);
-        } else if (object instanceof Collection<?>) {","[{'comment': 'Is this one really safe to remove? It seems to assume that the else condition will handle with the same behaviour, but I have not tested it to confirm.\r\n\r\nMight be worth also moving that `if (object == null)` check to the top.', 'commenter': 'kinow'}, {'comment': 'Removing of this condition is safe. Moreover, this check is useless, because, any collection implements interface Iterable, and if object is Collection, then previous condition `(object instanceof Iterable<?>)` is true.\r\n', 'commenter': 'izebit'}, {'comment': 'Nice. Will check out the code to review with the IDE, plus some coffee :zzz: I think it looks good to be merged. Thanks for the quick replies @izebit ', 'commenter': 'kinow'}, {'comment': 'Oooohh, just re-read, and finally understood. Sorry, nice catch again.', 'commenter': 'kinow'}]"
70,src/main/java/org/apache/commons/collections4/set/CompositeSet.java,"@@ -18,12 +18,8 @@
 
 import java.io.Serializable;
 import java.lang.reflect.Array;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
+import java.util.*;","[{'comment': 'We do not use star imports in main code. ', 'commenter': 'garydgregory'}, {'comment': 'No * imports please.', 'commenter': 'garydgregory'}]"
70,src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java,"@@ -313,6 +315,27 @@ public boolean removeAll(final Collection<?> coll) {
         return changed;
     }
 
+    /**
+     * Removes all of the elements of this collection that satisfy the given predicate from this composite collection.
+     * <p>
+     * This implementation calls <code>removeIf</code> on each collection.
+     *","[{'comment': 'You must close tags.', 'commenter': 'garydgregory'}, {'comment': '@garydgregory Are you referring to the p tag?\r\nI thought it was a convention because there are p tags in comments of other methods.\r\nDo you want to commit and delete other p tags?', 'commenter': 'morningmemo'}, {'comment': 'Yes, starting in Java 8, Javadoc does not accept by default malformed XHTML, so you must close <p> tags with a </p> to create a paragraph. Just because the current Javadoc still has not been cleaned up does not mean we want to create _more_ defective comments ;-)', 'commenter': 'garydgregory'}]"
70,src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java,"@@ -212,6 +215,25 @@ public boolean remove(final Object object) {
         return removed;
     }
 
+    @Override
+    public boolean removeIf(final Predicate<? super C> filter) {
+        if (Objects.isNull(filter)) {
+            return false;
+        }
+        boolean changed = false;
+        final Iterator<C> it = iterator();
+        while( it.hasNext()) {","[{'comment': 'Formatting is slightly off, this should read: ""while (it."" ', 'commenter': 'garydgregory'}]"
70,src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java,"@@ -212,6 +215,25 @@ public boolean remove(final Object object) {
         return removed;
     }
 
+    @Override
+    public boolean removeIf(final Predicate<? super C> filter) {
+        if (Objects.isNull(filter)) {
+            return false;
+        }
+        boolean changed = false;
+        final Iterator<C> it = iterator();
+        while( it.hasNext()) {
+            if( filter.test(it.next())) {","[{'comment': 'Same as above.', 'commenter': 'garydgregory'}]"
70,src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java,"@@ -40,7 +41,7 @@
  * @param <E> the type of elements in this collection
  * @since 3.0
  */
-public final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDecorator<E>
+public final class UnmodifiableBoundedCollection<E> extends org.apache.commons.collections4.collection.AbstractCollectionDecorator<E>","[{'comment': 'I do not think you need the fully qualified name here.', 'commenter': 'garydgregory'}]"
70,src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java,"@@ -88,10 +89,10 @@
             if (coll instanceof BoundedCollection) {
                 break;  // normal loop exit
             }
-            if (coll instanceof AbstractCollectionDecorator) {
-                coll = ((AbstractCollectionDecorator<E>) coll).decorated();
-            } else if (coll instanceof SynchronizedCollection) {
-                coll = ((SynchronizedCollection<E>) coll).decorated();
+            if (coll instanceof org.apache.commons.collections4.collection.AbstractCollectionDecorator) {","[{'comment': 'I do not think you need the fully qualified name here.', 'commenter': 'garydgregory'}]"
70,src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java,"@@ -33,7 +34,7 @@
  * @since 3.0
  */
 public final class UnmodifiableCollection<E>
-        extends AbstractCollectionDecorator<E>
+        extends org.apache.commons.collections4.collection.AbstractCollectionDecorator<E>","[{'comment': 'I do not think you need the fully qualified name here.', 'commenter': 'garydgregory'}]"
70,src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java,"@@ -16,13 +16,8 @@
  */
 package org.apache.commons.collections4.set;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.Set;
+import java.util.*;","[{'comment': 'No * imports please.', 'commenter': 'garydgregory'}]"
70,src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java,"@@ -128,6 +129,11 @@ public boolean remove(final Object object) {
         throw new UnsupportedOperationException();
     }
 
+    @Override","[{'comment': ""I'm also thinking that all new public methods should have a `@since 4.4` Javadoc tag."", 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/package-info.java,"@@ -0,0 +1,88 @@
+/**","[{'comment': 'Please add the Apache license header as a separate but first comment. See the other `package-info.java` files.', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/Hash.java,"@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.io.Serializable;
+import java.util.BitSet;
+
+import org.apache.commons.lang3.builder.HashCodeBuilder;
+
+/**
+ * A Bloom Filter hash calculation.  This class only stores the result of an
+ * external hashs calculation.  It does not perform the calculation itself.
+ * 
+ * The hash is calculated as a 128-bit value. We store this as two 64-bit
+ * values. We can then rapidly calculate the bloom filter for any given
+ * configuration.
+ *
+ */
+public class Hash implements Comparable<Hash>, Serializable {
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = -5511398264986350484L;
+	private long h1;
+	private long h2;
+	private transient Integer hashCode;
+
+	public Hash(long h1, long h2) {
+		this.h1 = h1;
+		this.h2 = h2;
+	}
+
+	public BitSet populate(BitSet set, FilterConfig config) {
+		if (set.size() < config.getNumberOfBits()) {
+			throw new IllegalArgumentException(
+					String.format(""Bitset had %s bits, %s required"", set.size(), config.getNumberOfBits()));
+		}
+		for (int i = 0; i < config.getNumberOfHashFunctions(); i++) {
+			int j = Math.abs((int) ((h1 + (i * h2)) % config.getNumberOfBits()));
+			set.set(j, true);
+		}
+		return set;
+	}
+
+	public long h1() {
+		return h1;
+	}
+
+	public long h2() {
+		return h2;
+	}
+
+	@Override
+	public int compareTo(Hash other) {
+		int result = Long.compare(h1, other.h1);
+		if (result == 0) {
+			result = Long.compare(h2, other.h2);
+		}
+		return result;
+	}
+
+	@Override
+	public int hashCode() {
+		if (hashCode == null) {
+			hashCode = new HashCodeBuilder().append(h1).append(h2).build();","[{'comment': '`hashCode = Objects.hash(h1, h2);`', 'commenter': 'garydgregory'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/ProtoBloomFilter.java,"@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.io.Serializable;
+import java.util.BitSet;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.TreeSet;
+import org.apache.commons.lang3.builder.HashCodeBuilder;
+
+/**
+ * A prototypical bloom filter definition.
+ * 
+ * This is the information necessary to create a concrete bloom filter given a
+ * filter configuration.
+ *
+ * The construction of the ProtoBloomFilter is far more compute expensive than
+ * making the concrete bloom filter from the proto.  
+ *
+ */
+public class ProtoBloomFilter implements Comparable<ProtoBloomFilter>, Serializable {
+
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = 1293273984765868571L;
+	private Set<Hash> hashes;
+	private transient Integer hashCode;
+
+	/**
+	 * Constructor
+	 * 
+	 * @param hashes the two longs that were created by the murmur hash function.
+	 */
+	public ProtoBloomFilter(Set<Hash> hashes) {
+		this.hashes = new TreeSet<Hash>();
+		this.hashes.addAll(hashes);
+	}
+
+	/**
+	 * Create a concrete bloom filter from this proto type given the filter
+	 * configuration.
+	 * 
+	 * @param cfg The filter configuration to use.
+	 * @return the Concreate Bloom Filter.
+	 */
+	public final BloomFilter create(FilterConfig cfg) {
+		BitSet set = new BitSet(cfg.getNumberOfBits());
+		for (Hash hash : hashes) {
+			hash.populate(set, cfg);
+		}
+		return new BloomFilter(set);
+	}
+
+	/**
+	 * Get a list of the hashes that this proto bloom filter uses.
+	 * 
+	 * @return the list of hashes.
+	 */
+	public Set<Hash> getHashes() {
+		return Collections.unmodifiableSet(hashes);
+	}
+
+	@Override
+	public int hashCode() {
+		if (hashCode == null) {
+			HashCodeBuilder hb = new HashCodeBuilder();
+			for (Hash hash : hashes) {
+				hb.append(hash);
+			}
+			hashCode = hb.build();","[{'comment': '`hashCode = Objects.hash(hashes.toArray());`', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/package-info.java,"@@ -0,0 +1,105 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * Bloom Filter Overview
+ * <p>
+ * First it is important to remember that Bloom filters tell you where things
+ * are NOT. Second it is important to understand that Bloom filters can give
+ * false positives but never false negatives. Seems kind of pointless I know but
+ * consider the case where you have 10K buckets that may contain the item you
+ * are looking for. If you can reduce the number of buckets you are searching
+ * you can significantly speed up the search. In a case like this a bloom filter
+ * could be used ""in front"" of each bucket as a gatekeeper. Whenever an object
+ * goes in the bucket the object's bloom filter is added to the bucket bloom
+ * filter. If you want to search the 10K buckets for an item then you build the
+ * bloom filter for the item you are looking for and check the bloom filter on
+ * each bucket. If the filter says that the item is not in the bucket then you
+ * can skip that bucket, if the filter says it is in the bucket you search the
+ * bucket to verify that it is not a false positive. A common use for bloom
+ * filters is to determine if an expensive call should be made. For example many
+ * browsers have a bloom filter that comprises all the known bad URLs (ones that
+ * serve malware, etc). When the URL is entered in the browser it is checked
+ * against the bloom filter. If it is not there the request goes through as
+ * normal. If it is there then the browser makes the expensive lookup call to a
+ * server to determine if the URL really is in the database of bad URLs.
+ * </p><p>
+ * So a bloom filter is generally used to front a collection to determine if the
+ * collection should be searched. And as has been pointed out it doesn't make
+ * much sense to use it in front of an in-memory hash table. However,
+ * applications like Cassandra and Hadoop use bloom filters for various reasons.
+ * Other uses for bloom
+ * filters include sharding data. There is a measure of difference between
+ * filters called a hamming distance. This is the number of bits that have to be
+ * ""flipped"" to turn one filter into another, and is very similar to Hamming
+ * measures found in string and other similar comparisons. By using the hamming
+ * value it is possible to distribute data among a set of buckets by simply
+ * putting the value in the bucket that it is ""closest"" to in terms of Hamming
+ * distance. Searching takes place as noted above. However this has some
+ * interesting properties. For example you can add new buckets at any time
+ * simply by adding an empty bucket and bloom filter to the collection of
+ * buckets and the system will start filling the bucket as appropriate. In
+ * addition if a bucket/shard becomes ""full"", where ""full"" is an implementation
+ * dependent decision (e.g. the index on a DB table reaches the inflection point
+ * where performance degradation begins), you can pull a bucket out of
+ * consideration for inserts but still search it without significant stress or
+ * change to the system.
+ * </p><p>
+ * Internally Bloom filters are bit vectors. The length of the vector being
+ * determined by the number of items that are to be placed in the bucket and the
+ * acceptable hash collision rate. There is a function that will calculate the
+ * length of the vector and the number of functions to use to turn on the
+ * bits (see Bloom Filter calculator below). In general you build a bloom filter by creating a hash and using the
+ * modulus of that to determine which bit in the vector to turn on. You then
+ * generate a second hash, usually the same hash function with a different seed to
+ * determine the next bit and so on until the number of functions has been
+ * executed. Importantly, there are comments in the Cassandra code that
+ * describe a much faster way of doing this using 128-bit hashes and
+ * splitting them into a pair of longs. This method is implemented in this code.
+ * </p><p>
+ * To check membership in a bloom filter
+ * you build the bloom-filter for the target (T - the thing we are looking for)
+ * and get the filter for the candidate (C - the bucket) and evaluate T&C = T if","[{'comment': 'Hi @Claudenw \r\nJavadoc still fails:\r\nhttps://travis-ci.org/apache/commons-collections/jobs/584941278', 'commenter': 'garydgregory'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/BloomFilter.java,"@@ -39,23 +48,39 @@
 	/**
 	 * Constructor.
 	 * 
-	 * A copy of the bitSet parameter is made so that the bloom filter
-	 * is isolated from any further changes in the bitSet.
+	 * @param protoFilter the protoFilter to build this bloom filter from.
+	 * @param config the Filter configuration to use to build the bloom filter.
+	 */
+	public BloomFilter(ProtoBloomFilter protoFilter, FilterConfig config) {
+		this.bitSet = new BitSet(config.getNumberOfBits());
+		for (Hash hash : protoFilter.hashes) {
+			hash.populate(bitSet, config);
+		}		
+		this.hamming = null;
+		this.logValue = null;
+	}
+	
+	/**
+	 * Constructor.
+	 * 
+	 * A copy of the bitSet parameter is made so that the bloom filter is isolated
+	 * from any further changes in the bitSet.
 	 * 
 	 * @param bitSet The bit set that was built by the config.
 	 */
-	public BloomFilter(BitSet bitSet) {
+	protected BloomFilter(BitSet bitSet)
+	{","[{'comment': 'Please use open braces on the same line.', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'Claudenw'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/BloomFilter.java,"@@ -65,7 +90,7 @@ public boolean inverseMatch(final BloomFilter other) {
 	}
 
 	/**
-	 * Return true if this & other == this.
+	 * Return true if <code>this &amp; other == this</code>.","[{'comment': 'Get methods should start Javadocs with ""Gets ..."".', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/BloomFilter.java,"@@ -0,0 +1,258 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.util.BitSet;
+
+import org.apache.commons.collections4.bloomfilters.ProtoBloomFilter.Hash;
+
+/**
+ * A bloom filter.
+ * 
+ * Instances are immutable.
+ * 
+ * @since 4.5
+ *
+ */
+public class BloomFilter {
+	
+	/* The maximum log depth is the depth at which
+	 * the log calculation makes no difference to the double result. 
+	 */
+	private final static int MAX_LOG_DEPTH = 25;
+
+	// the bitset we are using
+	protected final BitSet bitSet;
+
+	// the hamming value once we have calculated it.
+	private transient Integer hamming;
+
+	// the base 2 log of the bloom filter considered as an integer.
+	private transient Double logValue;
+
+	/**
+	 * Constructor.
+	 * 
+	 * @param protoFilter the protoFilter to build this bloom filter from.
+	 * @param config the Filter configuration to use to build the bloom filter.
+	 */
+	public BloomFilter(ProtoBloomFilter protoFilter, FilterConfig config) {
+		this.bitSet = new BitSet(config.getNumberOfBits());
+		for (Hash hash : protoFilter.hashes) {
+			hash.populate(bitSet, config);
+		}		
+		this.hamming = null;
+		this.logValue = null;
+	}
+	
+	/**
+	 * Constructor.
+	 * 
+	 * A copy of the bitSet parameter is made so that the bloom filter is isolated
+	 * from any further changes in the bitSet.
+	 * 
+	 * @param bitSet The bit set that was built by the config.
+	 */
+	protected BloomFilter(BitSet bitSet)
+	{
+		this.bitSet = (BitSet)bitSet.clone();
+		this.hamming = null;
+		this.logValue = null;
+	}
+
+	/**
+	 * Return true if other &amp; this == other
+	 * 
+	 * This is the inverse of the match method.
+	 * 
+	 * <code>X.match(Y)</code> is the same as <code>Y.inverseMatch(X)</code>
+	 * 
+	 * @param other the other bloom filter to match.
+	 * @return true if they match.
+	 */
+	public boolean inverseMatch(final BloomFilter other) {
+		return other.match(this);
+	}
+
+	/**
+	 * Return true if <code>this &amp; other == this</code>.
+	 * 
+	 * This is the standard bloom filter match.
+	 * 
+	 * @param other the other bloom filter to match.
+	 * @return true if they match.
+	 */
+	public final boolean match(final BloomFilter other) {
+		BitSet temp = BitSet.valueOf(this.bitSet.toByteArray());
+		temp.and(other.bitSet);
+		return temp.equals(this.bitSet);
+	}
+
+	/**
+	 * Calculate the hamming distance from this bloom filter to the other. The
+	 * hamming distance is defined as this xor other and is the number of bits that
+	 * have to be flipped to convert one filter to the other.
+	 * 
+	 * @param other The other bloom filter to calculate the distance to.
+	 * @return the distance.
+	 */
+	public final int distance(final BloomFilter other) {
+		BitSet temp = BitSet.valueOf(this.bitSet.toByteArray());
+		temp.xor(other.bitSet);
+		return temp.cardinality();
+	}
+
+	/**
+	 * Get the hamming weight for this filter.
+	 * 
+	 * This is the number of bits that are on in the filter.
+	 * 
+	 * @return The hamming weight.
+	 */
+	public final int getHammingWeight() {
+		if (hamming == null) {
+			hamming = bitSet.cardinality();
+		}
+		return hamming;
+	}
+
+	/**
+	 * The the log(2) of this bloom filter. This is the base 2 logarithm of this
+	 * bloom filter if the bits in this filter were considers the bits in an
+	 * unsigned integer.
+	 * 
+	 * @return the base 2 logarithm
+	 */
+	public final double getLog() {
+		if (logValue == null) {
+			logValue = getApproximateLog( Integer.min(bitSet.length(), MAX_LOG_DEPTH));
+		}
+		return logValue;
+	}
+
+	/**
+	 * Get the approximate log for this filter. If the bloom filter is considered as
+	 * an unsigned number what is the approximate base 2 log of that value. The
+	 * depth argument indicates how many extra bits are to be considered in the log
+	 * calculation. At least one bit must be considered. If there are no bits on
+	 * then the log value is 0.
+	 * 
+	 * @see AbstractBloomFilter.getApproximateLog()
+	 * @param depth the number of bits to consider.
+	 * @return the approximate log.
+	 */
+	private final double getApproximateLog(int depth) {
+		if (depth == 0)
+		{
+			return 0;
+		}
+		int[] exp = getApproximateLogExponents(depth);
+		/*
+		 * this approximation is calculated using a derivation of
+		 * http://en.wikipedia.org/wiki/Binary_logarithm#Algorithm
+		 */
+		// the mantissa is the highest bit that is turned on.
+		if (exp[0] < 0) {
+			// there are no bits so return 0
+			return 0;
+		}
+		double result = exp[0];
+		/* now we move backwards from the highest bit until the requested depth
+		 * is achieved. */
+		double exp2;
+		for (int i = 1; i < exp.length; i++) {
+			if (exp[i] == -1) {
+				return result;
+			}
+			exp2 = exp[i] - exp[0]; // should be negative
+			result += Math.pow(2.0, exp2);
+		}
+		return result;
+	}
+
+	/**
+	 * The mantissa of the log in in position position 0. The remainder are
+	 * characteristic powers.
+	 * 
+	 * @param depth
+	 * @return An array of depth integers that are the exponents.
+	 */
+	private final int[] getApproximateLogExponents(int depth) {
+		if (depth <1)
+		{","[{'comment': 'Space after <', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/BloomFilter.java,"@@ -0,0 +1,258 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.util.BitSet;
+
+import org.apache.commons.collections4.bloomfilters.ProtoBloomFilter.Hash;
+
+/**
+ * A bloom filter.
+ * 
+ * Instances are immutable.
+ * 
+ * @since 4.5
+ *
+ */
+public class BloomFilter {
+	
+	/* The maximum log depth is the depth at which
+	 * the log calculation makes no difference to the double result. 
+	 */
+	private final static int MAX_LOG_DEPTH = 25;
+
+	// the bitset we are using
+	protected final BitSet bitSet;
+
+	// the hamming value once we have calculated it.
+	private transient Integer hamming;
+
+	// the base 2 log of the bloom filter considered as an integer.
+	private transient Double logValue;
+
+	/**
+	 * Constructor.
+	 * 
+	 * @param protoFilter the protoFilter to build this bloom filter from.
+	 * @param config the Filter configuration to use to build the bloom filter.
+	 */
+	public BloomFilter(ProtoBloomFilter protoFilter, FilterConfig config) {
+		this.bitSet = new BitSet(config.getNumberOfBits());
+		for (Hash hash : protoFilter.hashes) {
+			hash.populate(bitSet, config);
+		}		
+		this.hamming = null;
+		this.logValue = null;
+	}
+	
+	/**
+	 * Constructor.
+	 * 
+	 * A copy of the bitSet parameter is made so that the bloom filter is isolated
+	 * from any further changes in the bitSet.
+	 * 
+	 * @param bitSet The bit set that was built by the config.
+	 */
+	protected BloomFilter(BitSet bitSet)
+	{
+		this.bitSet = (BitSet)bitSet.clone();
+		this.hamming = null;
+		this.logValue = null;
+	}
+
+	/**
+	 * Return true if other &amp; this == other
+	 * 
+	 * This is the inverse of the match method.
+	 * 
+	 * <code>X.match(Y)</code> is the same as <code>Y.inverseMatch(X)</code>
+	 * 
+	 * @param other the other bloom filter to match.
+	 * @return true if they match.
+	 */
+	public boolean inverseMatch(final BloomFilter other) {
+		return other.match(this);
+	}
+
+	/**
+	 * Return true if <code>this &amp; other == this</code>.
+	 * 
+	 * This is the standard bloom filter match.
+	 * 
+	 * @param other the other bloom filter to match.
+	 * @return true if they match.
+	 */
+	public final boolean match(final BloomFilter other) {
+		BitSet temp = BitSet.valueOf(this.bitSet.toByteArray());
+		temp.and(other.bitSet);
+		return temp.equals(this.bitSet);
+	}
+
+	/**
+	 * Calculate the hamming distance from this bloom filter to the other. The
+	 * hamming distance is defined as this xor other and is the number of bits that
+	 * have to be flipped to convert one filter to the other.
+	 * 
+	 * @param other The other bloom filter to calculate the distance to.
+	 * @return the distance.
+	 */
+	public final int distance(final BloomFilter other) {
+		BitSet temp = BitSet.valueOf(this.bitSet.toByteArray());
+		temp.xor(other.bitSet);
+		return temp.cardinality();
+	}
+
+	/**
+	 * Get the hamming weight for this filter.
+	 * 
+	 * This is the number of bits that are on in the filter.
+	 * 
+	 * @return The hamming weight.
+	 */
+	public final int getHammingWeight() {
+		if (hamming == null) {
+			hamming = bitSet.cardinality();
+		}
+		return hamming;
+	}
+
+	/**
+	 * The the log(2) of this bloom filter. This is the base 2 logarithm of this
+	 * bloom filter if the bits in this filter were considers the bits in an
+	 * unsigned integer.
+	 * 
+	 * @return the base 2 logarithm
+	 */
+	public final double getLog() {
+		if (logValue == null) {
+			logValue = getApproximateLog( Integer.min(bitSet.length(), MAX_LOG_DEPTH));
+		}
+		return logValue;
+	}
+
+	/**
+	 * Get the approximate log for this filter. If the bloom filter is considered as
+	 * an unsigned number what is the approximate base 2 log of that value. The
+	 * depth argument indicates how many extra bits are to be considered in the log
+	 * calculation. At least one bit must be considered. If there are no bits on
+	 * then the log value is 0.
+	 * 
+	 * @see AbstractBloomFilter.getApproximateLog()
+	 * @param depth the number of bits to consider.
+	 * @return the approximate log.
+	 */
+	private final double getApproximateLog(int depth) {
+		if (depth == 0)
+		{
+			return 0;
+		}
+		int[] exp = getApproximateLogExponents(depth);
+		/*
+		 * this approximation is calculated using a derivation of
+		 * http://en.wikipedia.org/wiki/Binary_logarithm#Algorithm
+		 */
+		// the mantissa is the highest bit that is turned on.
+		if (exp[0] < 0) {
+			// there are no bits so return 0
+			return 0;
+		}
+		double result = exp[0];
+		/* now we move backwards from the highest bit until the requested depth
+		 * is achieved. */
+		double exp2;
+		for (int i = 1; i < exp.length; i++) {
+			if (exp[i] == -1) {
+				return result;
+			}
+			exp2 = exp[i] - exp[0]; // should be negative
+			result += Math.pow(2.0, exp2);
+		}
+		return result;
+	}
+
+	/**
+	 * The mantissa of the log in in position position 0. The remainder are
+	 * characteristic powers.
+	 * 
+	 * @param depth
+	 * @return An array of depth integers that are the exponents.
+	 */
+	private final int[] getApproximateLogExponents(int depth) {
+		if (depth <1)
+		{
+			return new int[] { -1 };
+		}
+		int[] exp = new int[depth];
+
+		exp[0] = bitSet.length() - 1;
+		if (exp[0] < 0) {
+			return exp;
+		}
+
+		for (int i = 1; i < depth; i++) {
+			exp[i] = bitSet.previousSetBit(exp[i - 1] - 1);
+			/*
+			 * 25 bits from the start make no difference in the double calculation so we can
+			 * short circuit the method here.
+			 */
+			if (exp[i] - exp[0] < -25) {
+				exp[i] = -1;
+			}
+			if (exp[i] == -1) {
+				return exp;
+			}
+		}
+		return exp;
+	}
+
+	@Override
+	public String toString() {
+		return bitSet.toString();
+	}
+
+	@Override
+	public int hashCode() {
+		return bitSet.hashCode();		
+	}
+	
+	@Override
+	public boolean equals(Object other) {
+		return (other instanceof BloomFilter) ? this.bitSet.equals(((BloomFilter) other).bitSet) : false;
+	}
+
+	/**
+	 * Merge this bloom filter with the other creating a new filter.","[{'comment': '""Merge"" -> ""Merges""', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/BloomFilter.java,"@@ -0,0 +1,258 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.util.BitSet;
+
+import org.apache.commons.collections4.bloomfilters.ProtoBloomFilter.Hash;
+
+/**
+ * A bloom filter.
+ * 
+ * Instances are immutable.
+ * 
+ * @since 4.5
+ *","[{'comment': 'No extra line after since tag.', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/BloomFilter.java,"@@ -0,0 +1,258 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.util.BitSet;
+
+import org.apache.commons.collections4.bloomfilters.ProtoBloomFilter.Hash;
+
+/**
+ * A bloom filter.
+ * 
+ * Instances are immutable.
+ * 
+ * @since 4.5
+ *
+ */
+public class BloomFilter {
+	
+	/* The maximum log depth is the depth at which
+	 * the log calculation makes no difference to the double result. 
+	 */
+	private final static int MAX_LOG_DEPTH = 25;
+
+	// the bitset we are using
+	protected final BitSet bitSet;
+
+	// the hamming value once we have calculated it.
+	private transient Integer hamming;
+
+	// the base 2 log of the bloom filter considered as an integer.
+	private transient Double logValue;
+
+	/**
+	 * Constructor.
+	 * 
+	 * @param protoFilter the protoFilter to build this bloom filter from.
+	 * @param config the Filter configuration to use to build the bloom filter.
+	 */
+	public BloomFilter(ProtoBloomFilter protoFilter, FilterConfig config) {
+		this.bitSet = new BitSet(config.getNumberOfBits());
+		for (Hash hash : protoFilter.hashes) {
+			hash.populate(bitSet, config);
+		}		
+		this.hamming = null;
+		this.logValue = null;
+	}
+	
+	/**
+	 * Constructor.","[{'comment': 'No need to say ""Constructor"".', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/BloomFilter.java,"@@ -0,0 +1,94 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.util.BitSet;
+
+/**
+ * The interface for all BloomFilter implementations. Instances of BloomFilters
+ * should be immutable.
+ */
+public interface BloomFilter {
+
+    /**
+     * Return true if other &amp; this == other","[{'comment': 'Start Javadoc comments with ""Returns"" instead of ""Return""; ""Gets"" instead of ""Get"" and so on.', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/BloomFilter.java,"@@ -0,0 +1,94 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.util.BitSet;
+
+/**
+ * The interface for all BloomFilter implementations. Instances of BloomFilters
+ * should be immutable.
+ */","[{'comment': 'Since public classes should have a `@since` tag.', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/CountingBloomFilter.java,"@@ -0,0 +1,178 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.Collections;
+import java.util.Map;
+import java.util.TreeMap;
+
+/**
+ * A counting bloom filter.
+ *
+ * <p>
+ * This bloom filter maintains a count of the number of times a bit has been
+ * turned on. This allows for removal of bloom filters from the filter.
+ * </p>
+ * <p>
+ * Instances are immutable.
+ * </p>
+ *
+ * @since 4.5
+ *","[{'comment': 'No extra empty line needed.', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/CountingBloomFilter.java,"@@ -0,0 +1,178 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.Collections;
+import java.util.Map;
+import java.util.TreeMap;
+
+/**
+ * A counting bloom filter.
+ *
+ * <p>
+ * This bloom filter maintains a count of the number of times a bit has been
+ * turned on. This allows for removal of bloom filters from the filter.
+ * </p>
+ * <p>
+ * Instances are immutable.
+ * </p>
+ *
+ * @since 4.5
+ *
+ */
+public class CountingBloomFilter extends StandardBloomFilter {
+
+    // the count of entries","[{'comment': 'Merge this // comment into the Javadoc.', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/FilterConfig.java,"@@ -0,0 +1,173 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+/**
+ * Filter configuration class.
+ * <p>
+ * This class contains the values for the filter configuration and is used to
+ * convert a ProtoBloomFilter into a BloomFilter.
+ * </p>
+ *
+ * @see <a href=""http://hur.st/bloomfilter?n=3&p=1.0E-5"">Bloom Filter
+ *      calculator</a>
+ *
+ * @since 4.5
+ */
+public final class FilterConfig implements Serializable {
+    private static final long serialVersionUID = 8857015449149940190L;
+    private static final double LOG_OF_2 = Math.log(2.0);
+
+    // ~ −0.090619058
+    private static final double DENOMINATOR = Math.log(1.0 / (Math.pow(2.0, LOG_OF_2)));
+    // number of items in the filter
+    private final int numberOfItems;
+    // probability of false positives defined as 1 in x;
+    private final int probability;
+    // number of bits in the filter;
+    private final int numberOfBits;
+    // number of hash functions
+    private final int numberOfHashFunctions;
+
+    private transient Integer hashCode;
+
+    /**
+     * Create a filter configuration with the specified number of items and
+     * probability.
+     *
+     * @param numberOfItems Number of items to be placed in the filter.
+     * @param probability   The probability of duplicates expressed as 1 in x.
+     */
+    public FilterConfig(final int numberOfItems, final int probability) {
+        if (numberOfItems < 1) {
+            throw new IllegalArgumentException(""Number of Items must be greater than 0"");
+        }
+        if (probability < 1) {
+            throw new IllegalArgumentException(""Probability must be greater than 0"");
+        }
+        this.numberOfItems = numberOfItems;
+        this.probability = probability;
+        final double dp = 1.0 / probability;
+        final Double dm = Math.ceil((numberOfItems * Math.log(dp)) / DENOMINATOR);
+        if (dm > Integer.MAX_VALUE) {
+            throw new IllegalArgumentException(""Resulting filter has more than "" + Integer.MAX_VALUE + "" bits"");
+        }
+        this.numberOfBits = dm.intValue();
+        final Long lk = Math.round((LOG_OF_2 * numberOfBits) / numberOfItems);
+        /*
+         * normally we would check that lk is <- Integer.MAX_VALUE but since
+         * numberOfBits is at most Integer.MAX_VALUE the numerator of lk is log(2) *
+         * Integer.MAX_VALUE = 646456992.9449 the value of lk can not be above
+         * Integer.MAX_VALUE.
+         */
+        numberOfHashFunctions = lk.intValue();
+    }
+
+    /**
+     * Get the number of items that are expected in the filter. AKA: {@code n }","[{'comment': '""Gets...""', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/FilterConfig.java,"@@ -0,0 +1,173 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+/**
+ * Filter configuration class.
+ * <p>
+ * This class contains the values for the filter configuration and is used to
+ * convert a ProtoBloomFilter into a BloomFilter.
+ * </p>
+ *
+ * @see <a href=""http://hur.st/bloomfilter?n=3&p=1.0E-5"">Bloom Filter
+ *      calculator</a>
+ *
+ * @since 4.5
+ */
+public final class FilterConfig implements Serializable {
+    private static final long serialVersionUID = 8857015449149940190L;
+    private static final double LOG_OF_2 = Math.log(2.0);
+
+    // ~ −0.090619058
+    private static final double DENOMINATOR = Math.log(1.0 / (Math.pow(2.0, LOG_OF_2)));
+    // number of items in the filter
+    private final int numberOfItems;
+    // probability of false positives defined as 1 in x;
+    private final int probability;
+    // number of bits in the filter;
+    private final int numberOfBits;
+    // number of hash functions
+    private final int numberOfHashFunctions;
+
+    private transient Integer hashCode;
+
+    /**
+     * Create a filter configuration with the specified number of items and
+     * probability.
+     *
+     * @param numberOfItems Number of items to be placed in the filter.
+     * @param probability   The probability of duplicates expressed as 1 in x.
+     */
+    public FilterConfig(final int numberOfItems, final int probability) {
+        if (numberOfItems < 1) {
+            throw new IllegalArgumentException(""Number of Items must be greater than 0"");
+        }
+        if (probability < 1) {
+            throw new IllegalArgumentException(""Probability must be greater than 0"");
+        }
+        this.numberOfItems = numberOfItems;
+        this.probability = probability;
+        final double dp = 1.0 / probability;
+        final Double dm = Math.ceil((numberOfItems * Math.log(dp)) / DENOMINATOR);
+        if (dm > Integer.MAX_VALUE) {
+            throw new IllegalArgumentException(""Resulting filter has more than "" + Integer.MAX_VALUE + "" bits"");
+        }
+        this.numberOfBits = dm.intValue();
+        final Long lk = Math.round((LOG_OF_2 * numberOfBits) / numberOfItems);
+        /*
+         * normally we would check that lk is <- Integer.MAX_VALUE but since
+         * numberOfBits is at most Integer.MAX_VALUE the numerator of lk is log(2) *
+         * Integer.MAX_VALUE = 646456992.9449 the value of lk can not be above
+         * Integer.MAX_VALUE.
+         */
+        numberOfHashFunctions = lk.intValue();
+    }
+
+    /**
+     * Get the number of items that are expected in the filter. AKA: {@code n }
+     *
+     * @return the number of items.
+     */
+    public int getNumberOfItems() {
+        return numberOfItems;
+    }
+
+    /**
+     * The probability of a false positive (collision) expressed as {@code 1/x }.","[{'comment': '""Gets...""', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/FilterConfig.java,"@@ -0,0 +1,173 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+/**
+ * Filter configuration class.
+ * <p>
+ * This class contains the values for the filter configuration and is used to
+ * convert a ProtoBloomFilter into a BloomFilter.
+ * </p>
+ *
+ * @see <a href=""http://hur.st/bloomfilter?n=3&p=1.0E-5"">Bloom Filter
+ *      calculator</a>
+ *
+ * @since 4.5
+ */
+public final class FilterConfig implements Serializable {
+    private static final long serialVersionUID = 8857015449149940190L;
+    private static final double LOG_OF_2 = Math.log(2.0);
+
+    // ~ −0.090619058
+    private static final double DENOMINATOR = Math.log(1.0 / (Math.pow(2.0, LOG_OF_2)));
+    // number of items in the filter
+    private final int numberOfItems;
+    // probability of false positives defined as 1 in x;
+    private final int probability;
+    // number of bits in the filter;
+    private final int numberOfBits;
+    // number of hash functions
+    private final int numberOfHashFunctions;
+
+    private transient Integer hashCode;
+
+    /**
+     * Create a filter configuration with the specified number of items and
+     * probability.
+     *
+     * @param numberOfItems Number of items to be placed in the filter.
+     * @param probability   The probability of duplicates expressed as 1 in x.
+     */
+    public FilterConfig(final int numberOfItems, final int probability) {
+        if (numberOfItems < 1) {
+            throw new IllegalArgumentException(""Number of Items must be greater than 0"");
+        }
+        if (probability < 1) {
+            throw new IllegalArgumentException(""Probability must be greater than 0"");
+        }
+        this.numberOfItems = numberOfItems;
+        this.probability = probability;
+        final double dp = 1.0 / probability;
+        final Double dm = Math.ceil((numberOfItems * Math.log(dp)) / DENOMINATOR);
+        if (dm > Integer.MAX_VALUE) {
+            throw new IllegalArgumentException(""Resulting filter has more than "" + Integer.MAX_VALUE + "" bits"");
+        }
+        this.numberOfBits = dm.intValue();
+        final Long lk = Math.round((LOG_OF_2 * numberOfBits) / numberOfItems);
+        /*
+         * normally we would check that lk is <- Integer.MAX_VALUE but since
+         * numberOfBits is at most Integer.MAX_VALUE the numerator of lk is log(2) *
+         * Integer.MAX_VALUE = 646456992.9449 the value of lk can not be above
+         * Integer.MAX_VALUE.
+         */
+        numberOfHashFunctions = lk.intValue();
+    }
+
+    /**
+     * Get the number of items that are expected in the filter. AKA: {@code n }
+     *
+     * @return the number of items.
+     */
+    public int getNumberOfItems() {
+        return numberOfItems;
+    }
+
+    /**
+     * The probability of a false positive (collision) expressed as {@code 1/x }.
+     * AKA: {@code 1/p }
+     *
+     * @return the x in 1/x.
+     */
+    public int getProbability() {
+        return probability;
+    }
+
+    /**
+     * The number of bits in the bloom filter. AKA: {@code m }","[{'comment': '""Gets...""', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/FilterConfig.java,"@@ -0,0 +1,173 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+/**
+ * Filter configuration class.
+ * <p>
+ * This class contains the values for the filter configuration and is used to
+ * convert a ProtoBloomFilter into a BloomFilter.
+ * </p>
+ *
+ * @see <a href=""http://hur.st/bloomfilter?n=3&p=1.0E-5"">Bloom Filter
+ *      calculator</a>
+ *
+ * @since 4.5
+ */
+public final class FilterConfig implements Serializable {
+    private static final long serialVersionUID = 8857015449149940190L;
+    private static final double LOG_OF_2 = Math.log(2.0);
+
+    // ~ −0.090619058
+    private static final double DENOMINATOR = Math.log(1.0 / (Math.pow(2.0, LOG_OF_2)));
+    // number of items in the filter
+    private final int numberOfItems;
+    // probability of false positives defined as 1 in x;
+    private final int probability;
+    // number of bits in the filter;
+    private final int numberOfBits;
+    // number of hash functions
+    private final int numberOfHashFunctions;
+
+    private transient Integer hashCode;
+
+    /**
+     * Create a filter configuration with the specified number of items and
+     * probability.
+     *
+     * @param numberOfItems Number of items to be placed in the filter.
+     * @param probability   The probability of duplicates expressed as 1 in x.
+     */
+    public FilterConfig(final int numberOfItems, final int probability) {
+        if (numberOfItems < 1) {
+            throw new IllegalArgumentException(""Number of Items must be greater than 0"");
+        }
+        if (probability < 1) {
+            throw new IllegalArgumentException(""Probability must be greater than 0"");
+        }
+        this.numberOfItems = numberOfItems;
+        this.probability = probability;
+        final double dp = 1.0 / probability;
+        final Double dm = Math.ceil((numberOfItems * Math.log(dp)) / DENOMINATOR);
+        if (dm > Integer.MAX_VALUE) {
+            throw new IllegalArgumentException(""Resulting filter has more than "" + Integer.MAX_VALUE + "" bits"");
+        }
+        this.numberOfBits = dm.intValue();
+        final Long lk = Math.round((LOG_OF_2 * numberOfBits) / numberOfItems);
+        /*
+         * normally we would check that lk is <- Integer.MAX_VALUE but since
+         * numberOfBits is at most Integer.MAX_VALUE the numerator of lk is log(2) *
+         * Integer.MAX_VALUE = 646456992.9449 the value of lk can not be above
+         * Integer.MAX_VALUE.
+         */
+        numberOfHashFunctions = lk.intValue();
+    }
+
+    /**
+     * Get the number of items that are expected in the filter. AKA: {@code n }
+     *
+     * @return the number of items.
+     */
+    public int getNumberOfItems() {
+        return numberOfItems;
+    }
+
+    /**
+     * The probability of a false positive (collision) expressed as {@code 1/x }.
+     * AKA: {@code 1/p }
+     *
+     * @return the x in 1/x.
+     */
+    public int getProbability() {
+        return probability;
+    }
+
+    /**
+     * The number of bits in the bloom filter. AKA: {@code m }
+     *
+     * @return the number of bits in the bloom filter.
+     */
+    public int getNumberOfBits() {
+        return numberOfBits;
+    }
+
+    /**
+     * The number of hash functions used to construct the filter. AKA: {@code k }","[{'comment': '""Gets...""', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/FilterConfig.java,"@@ -0,0 +1,173 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+/**
+ * Filter configuration class.
+ * <p>
+ * This class contains the values for the filter configuration and is used to
+ * convert a ProtoBloomFilter into a BloomFilter.
+ * </p>
+ *
+ * @see <a href=""http://hur.st/bloomfilter?n=3&p=1.0E-5"">Bloom Filter
+ *      calculator</a>
+ *
+ * @since 4.5
+ */
+public final class FilterConfig implements Serializable {
+    private static final long serialVersionUID = 8857015449149940190L;
+    private static final double LOG_OF_2 = Math.log(2.0);
+
+    // ~ −0.090619058
+    private static final double DENOMINATOR = Math.log(1.0 / (Math.pow(2.0, LOG_OF_2)));
+    // number of items in the filter
+    private final int numberOfItems;
+    // probability of false positives defined as 1 in x;
+    private final int probability;
+    // number of bits in the filter;
+    private final int numberOfBits;
+    // number of hash functions
+    private final int numberOfHashFunctions;
+
+    private transient Integer hashCode;
+
+    /**
+     * Create a filter configuration with the specified number of items and
+     * probability.
+     *
+     * @param numberOfItems Number of items to be placed in the filter.
+     * @param probability   The probability of duplicates expressed as 1 in x.
+     */
+    public FilterConfig(final int numberOfItems, final int probability) {
+        if (numberOfItems < 1) {
+            throw new IllegalArgumentException(""Number of Items must be greater than 0"");
+        }
+        if (probability < 1) {
+            throw new IllegalArgumentException(""Probability must be greater than 0"");
+        }
+        this.numberOfItems = numberOfItems;
+        this.probability = probability;
+        final double dp = 1.0 / probability;
+        final Double dm = Math.ceil((numberOfItems * Math.log(dp)) / DENOMINATOR);
+        if (dm > Integer.MAX_VALUE) {
+            throw new IllegalArgumentException(""Resulting filter has more than "" + Integer.MAX_VALUE + "" bits"");
+        }
+        this.numberOfBits = dm.intValue();
+        final Long lk = Math.round((LOG_OF_2 * numberOfBits) / numberOfItems);
+        /*
+         * normally we would check that lk is <- Integer.MAX_VALUE but since
+         * numberOfBits is at most Integer.MAX_VALUE the numerator of lk is log(2) *
+         * Integer.MAX_VALUE = 646456992.9449 the value of lk can not be above
+         * Integer.MAX_VALUE.
+         */
+        numberOfHashFunctions = lk.intValue();
+    }
+
+    /**
+     * Get the number of items that are expected in the filter. AKA: {@code n }
+     *
+     * @return the number of items.
+     */
+    public int getNumberOfItems() {
+        return numberOfItems;
+    }
+
+    /**
+     * The probability of a false positive (collision) expressed as {@code 1/x }.
+     * AKA: {@code 1/p }
+     *
+     * @return the x in 1/x.
+     */
+    public int getProbability() {
+        return probability;
+    }
+
+    /**
+     * The number of bits in the bloom filter. AKA: {@code m }
+     *
+     * @return the number of bits in the bloom filter.
+     */
+    public int getNumberOfBits() {
+        return numberOfBits;
+    }
+
+    /**
+     * The number of hash functions used to construct the filter. AKA: {@code k }
+     *
+     * @return the number of hash functions used to construct the filter.
+     */
+    public int getNumberOfHashFunctions() {
+        return numberOfHashFunctions;
+    }
+
+    /**
+     * The number of bytes in the bloom filter.","[{'comment': '""Gets...""', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/FilterConfig.java,"@@ -0,0 +1,173 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+/**
+ * Filter configuration class.
+ * <p>
+ * This class contains the values for the filter configuration and is used to
+ * convert a ProtoBloomFilter into a BloomFilter.
+ * </p>
+ *
+ * @see <a href=""http://hur.st/bloomfilter?n=3&p=1.0E-5"">Bloom Filter
+ *      calculator</a>
+ *
+ * @since 4.5
+ */
+public final class FilterConfig implements Serializable {
+    private static final long serialVersionUID = 8857015449149940190L;
+    private static final double LOG_OF_2 = Math.log(2.0);
+
+    // ~ −0.090619058
+    private static final double DENOMINATOR = Math.log(1.0 / (Math.pow(2.0, LOG_OF_2)));
+    // number of items in the filter
+    private final int numberOfItems;
+    // probability of false positives defined as 1 in x;
+    private final int probability;
+    // number of bits in the filter;
+    private final int numberOfBits;
+    // number of hash functions
+    private final int numberOfHashFunctions;
+
+    private transient Integer hashCode;
+
+    /**
+     * Create a filter configuration with the specified number of items and
+     * probability.
+     *
+     * @param numberOfItems Number of items to be placed in the filter.
+     * @param probability   The probability of duplicates expressed as 1 in x.
+     */
+    public FilterConfig(final int numberOfItems, final int probability) {
+        if (numberOfItems < 1) {
+            throw new IllegalArgumentException(""Number of Items must be greater than 0"");
+        }
+        if (probability < 1) {
+            throw new IllegalArgumentException(""Probability must be greater than 0"");
+        }
+        this.numberOfItems = numberOfItems;
+        this.probability = probability;
+        final double dp = 1.0 / probability;
+        final Double dm = Math.ceil((numberOfItems * Math.log(dp)) / DENOMINATOR);
+        if (dm > Integer.MAX_VALUE) {
+            throw new IllegalArgumentException(""Resulting filter has more than "" + Integer.MAX_VALUE + "" bits"");
+        }
+        this.numberOfBits = dm.intValue();
+        final Long lk = Math.round((LOG_OF_2 * numberOfBits) / numberOfItems);
+        /*
+         * normally we would check that lk is <- Integer.MAX_VALUE but since
+         * numberOfBits is at most Integer.MAX_VALUE the numerator of lk is log(2) *
+         * Integer.MAX_VALUE = 646456992.9449 the value of lk can not be above
+         * Integer.MAX_VALUE.
+         */
+        numberOfHashFunctions = lk.intValue();
+    }
+
+    /**
+     * Get the number of items that are expected in the filter. AKA: {@code n }
+     *
+     * @return the number of items.
+     */
+    public int getNumberOfItems() {
+        return numberOfItems;
+    }
+
+    /**
+     * The probability of a false positive (collision) expressed as {@code 1/x }.
+     * AKA: {@code 1/p }
+     *
+     * @return the x in 1/x.
+     */
+    public int getProbability() {
+        return probability;
+    }
+
+    /**
+     * The number of bits in the bloom filter. AKA: {@code m }
+     *
+     * @return the number of bits in the bloom filter.
+     */
+    public int getNumberOfBits() {
+        return numberOfBits;
+    }
+
+    /**
+     * The number of hash functions used to construct the filter. AKA: {@code k }
+     *
+     * @return the number of hash functions used to construct the filter.
+     */
+    public int getNumberOfHashFunctions() {
+        return numberOfHashFunctions;
+    }
+
+    /**
+     * The number of bytes in the bloom filter.
+     *
+     * @return the number of bytes in the bloom filter.
+     */
+    public int getNumberOfBytes() {
+        return Double.valueOf(Math.ceil(numberOfBits / 8.0)).intValue();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o instanceof FilterConfig) {
+            FilterConfig other = (FilterConfig) o;
+            return other.getNumberOfBits() == getNumberOfBits()
+                    && other.getNumberOfHashFunctions() == getNumberOfHashFunctions()
+                    && other.getNumberOfItems() == getNumberOfItems() && other.getProbability() == getProbability();
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        if (hashCode == null) {
+            hashCode = Objects.hash(numberOfBits, numberOfHashFunctions, numberOfItems, probability);
+        }
+        return hashCode.intValue();
+    }
+
+    private Object writeReplace() {
+        return new ConfigSerProxy(this);
+    }
+
+    /**
+     * A Serialization proxy for a FilterConfig.
+     *","[{'comment': 'No extra line needed.', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/ProtoBloomFilter.java,"@@ -0,0 +1,558 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.io.Serializable;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.stream.Stream;
+
+/**
+ * A prototypical bloom filter definition.
+ * <p>
+ * The ProtoBloomFilter contains the information necessary to create a concrete
+ * bloom filter with a given filter configuration. The construction of the
+ * ProtoBloomFilter is far more compute expensive than making the concrete bloom
+ * filter from the proto filter. Concrete implementations of BloomFilter are
+ * built from the ProtoBloomFilter.
+ * </p>
+ *
+ * @since 4.5
+ * @see FilterConfig
+ *
+ */
+public final class ProtoBloomFilter implements Comparable<ProtoBloomFilter> {
+
+    private final List<Hash> hashes;
+    private transient Integer hashCode;
+
+    /**
+     * An empty ProtoBloomFilter. Used to create empty BloomFilters.
+     */
+    public static final ProtoBloomFilter EMPTY = new ProtoBloomFilter(Collections.emptyList());
+
+    /**
+     * Get a builder .","[{'comment': 'Javadoc: ""Creates a new builder.""', 'commenter': 'garydgregory'}, {'comment': 'Fixed in multiple locations.', 'commenter': 'Claudenw'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/FilterConfig.java,"@@ -0,0 +1,173 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+/**
+ * Filter configuration class.
+ * <p>
+ * This class contains the values for the filter configuration and is used to
+ * convert a ProtoBloomFilter into a BloomFilter.
+ * </p>
+ *
+ * @see <a href=""http://hur.st/bloomfilter?n=3&p=1.0E-5"">Bloom Filter
+ *      calculator</a>
+ *
+ * @since 4.5
+ */
+public final class FilterConfig implements Serializable {","[{'comment': ""Seems like an odd class name, why not prefix the class name with 'Bloom'? Would this class _ever_ apply to non-bloom classes?"", 'commenter': 'garydgregory'}, {'comment': 'Changed', 'commenter': 'Claudenw'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/ProtoBloomFilter.java,"@@ -0,0 +1,558 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.io.Serializable;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.stream.Stream;
+
+/**
+ * A prototypical bloom filter definition.
+ * <p>
+ * The ProtoBloomFilter contains the information necessary to create a concrete
+ * bloom filter with a given filter configuration. The construction of the
+ * ProtoBloomFilter is far more compute expensive than making the concrete bloom
+ * filter from the proto filter. Concrete implementations of BloomFilter are
+ * built from the ProtoBloomFilter.
+ * </p>
+ *
+ * @since 4.5
+ * @see FilterConfig
+ *
+ */
+public final class ProtoBloomFilter implements Comparable<ProtoBloomFilter> {
+
+    private final List<Hash> hashes;
+    private transient Integer hashCode;
+
+    /**
+     * An empty ProtoBloomFilter. Used to create empty BloomFilters.
+     */
+    public static final ProtoBloomFilter EMPTY = new ProtoBloomFilter(Collections.emptyList());
+
+    /**
+     * Get a builder .
+     *
+     * @return a new builder.
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    /* package private for testing */
+    /**
+     * Constructor
+     *
+     * @param hashes the two longs that were created by the murmur hash function.
+     */
+    ProtoBloomFilter(Collection<Hash> hashes) {
+        this.hashes = new ArrayList<Hash>();
+        this.hashes.addAll(hashes);
+        // sort so compareTo and equals work properly
+        Collections.sort(this.hashes);
+    }
+
+    private Object writeReplace() {
+        return new ProtoSerProxy(this);
+    }
+
+    /**
+     * Get the count of hashed items included in this proto bloom filter.
+     *
+     * @return The number of unique items in this proto filter.
+     */
+    public int getItemCount() {
+        return hashes.size();
+    }
+
+    /**
+     * Get the stream of hashes included in this proto bloom filter.
+     *
+     * @return the stream of hashes.
+     */
+    public Stream<Hash> getHashes() {
+        return hashes.stream();
+    }
+
+    /**
+     * Get the count of unique hashed items included in this proto bloom filter.
+     *
+     * @return the number of unique items hashed into the proto bloom filter.
+     */
+    public int getUniqueItemCount() {
+        return (int) getUniqueHashes().count();
+    }
+
+    /**
+     * Get the stream of uniques hashes included in this proto bloom filter.
+     *
+     * @return the stream of unique hashes.
+     */
+    public Stream<Hash> getUniqueHashes() {
+        return hashes.stream().distinct();
+    }
+
+    @Override
+    public int hashCode() {
+        if (hashCode == null) {
+            hashCode = Objects.hash(hashes);
+        }
+        return hashCode.intValue();
+    }
+
+    @Override
+    public int compareTo(ProtoBloomFilter other) {
+        Iterator<Hash> otherIter = other.getHashes().iterator();
+        Iterator<Hash> iter = hashes.iterator();
+        int result;
+        while (iter.hasNext() && otherIter.hasNext()) {
+            result = iter.next().compareTo(otherIter.next());
+            if (result != 0) {
+                return result;
+            }
+        }
+        return otherIter.hasNext() ? -1 : 0;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o instanceof ProtoBloomFilter) {
+            return compareTo((ProtoBloomFilter) o) == 0;
+        }
+        return false;
+    }
+
+    @Override
+    public String toString() {
+        return String.format(""ProtoBloomFilter[ %s, %s]"", hashes.size(), hashCode());
+    }
+
+    /**
+     * A Serialization proxy for a ProtoBloomFilter.
+     *
+     */
+    private static class ProtoSerProxy implements Serializable {","[{'comment': 'No need to abbreviate the class name here, I would spell out Serializable in full.', 'commenter': 'garydgregory'}]"
83,src/main/java/org/apache/commons/collections4/bloomfilters/ProtoBloomFilter.java,"@@ -0,0 +1,558 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilters;
+
+import java.io.Serializable;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.stream.Stream;
+
+/**
+ * A prototypical bloom filter definition.
+ * <p>
+ * The ProtoBloomFilter contains the information necessary to create a concrete
+ * bloom filter with a given filter configuration. The construction of the
+ * ProtoBloomFilter is far more compute expensive than making the concrete bloom
+ * filter from the proto filter. Concrete implementations of BloomFilter are
+ * built from the ProtoBloomFilter.
+ * </p>
+ *
+ * @since 4.5
+ * @see FilterConfig
+ *
+ */
+public final class ProtoBloomFilter implements Comparable<ProtoBloomFilter> {
+
+    private final List<Hash> hashes;
+    private transient Integer hashCode;
+
+    /**
+     * An empty ProtoBloomFilter. Used to create empty BloomFilters.
+     */
+    public static final ProtoBloomFilter EMPTY = new ProtoBloomFilter(Collections.emptyList());
+
+    /**
+     * Get a builder .
+     *
+     * @return a new builder.
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    /* package private for testing */
+    /**
+     * Constructor
+     *
+     * @param hashes the two longs that were created by the murmur hash function.
+     */
+    ProtoBloomFilter(Collection<Hash> hashes) {
+        this.hashes = new ArrayList<Hash>();
+        this.hashes.addAll(hashes);
+        // sort so compareTo and equals work properly
+        Collections.sort(this.hashes);
+    }
+
+    private Object writeReplace() {
+        return new ProtoSerProxy(this);
+    }
+
+    /**
+     * Get the count of hashed items included in this proto bloom filter.
+     *
+     * @return The number of unique items in this proto filter.
+     */
+    public int getItemCount() {
+        return hashes.size();
+    }
+
+    /**
+     * Get the stream of hashes included in this proto bloom filter.
+     *
+     * @return the stream of hashes.
+     */
+    public Stream<Hash> getHashes() {
+        return hashes.stream();
+    }
+
+    /**
+     * Get the count of unique hashed items included in this proto bloom filter.
+     *
+     * @return the number of unique items hashed into the proto bloom filter.
+     */
+    public int getUniqueItemCount() {
+        return (int) getUniqueHashes().count();
+    }
+
+    /**
+     * Get the stream of uniques hashes included in this proto bloom filter.
+     *
+     * @return the stream of unique hashes.
+     */
+    public Stream<Hash> getUniqueHashes() {
+        return hashes.stream().distinct();
+    }
+
+    @Override
+    public int hashCode() {
+        if (hashCode == null) {
+            hashCode = Objects.hash(hashes);
+        }
+        return hashCode.intValue();
+    }
+
+    @Override
+    public int compareTo(ProtoBloomFilter other) {
+        Iterator<Hash> otherIter = other.getHashes().iterator();
+        Iterator<Hash> iter = hashes.iterator();
+        int result;
+        while (iter.hasNext() && otherIter.hasNext()) {
+            result = iter.next().compareTo(otherIter.next());
+            if (result != 0) {
+                return result;
+            }
+        }
+        return otherIter.hasNext() ? -1 : 0;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o instanceof ProtoBloomFilter) {
+            return compareTo((ProtoBloomFilter) o) == 0;
+        }
+        return false;
+    }
+
+    @Override
+    public String toString() {
+        return String.format(""ProtoBloomFilter[ %s, %s]"", hashes.size(), hashCode());
+    }
+
+    /**
+     * A Serialization proxy for a ProtoBloomFilter.
+     *
+     */
+    private static class ProtoSerProxy implements Serializable {
+
+        private static final long serialVersionUID = -816173373461613366L;
+
+        private Hash[] hashes;
+
+        ProtoSerProxy(ProtoBloomFilter protoFilter) {
+            this.hashes = protoFilter.hashes.toArray(new Hash[protoFilter.hashes.size()]);
+        }
+
+        private Object readResolve() {
+            return new ProtoBloomFilter(Arrays.asList(hashes));
+        }
+    }
+
+    /**
+     * A Bloom Filter hash calculation. This class only stores the result of an
+     * external hash calculation. It does not perform the calculation itself.
+     * <p>
+     * The hash is calculated as a 128-bit value. We store this as two 64-bit
+     * values. We can then rapidly calculate the bloom filter for any given
+     * configuration.
+     * </p>
+     */
+    /* package private for testing */
+    final static class Hash implements Comparable<Hash> {","[{'comment': 'Class name is too general IMO.', 'commenter': 'garydgregory'}, {'comment': 'It is akin to the Entry nested class within the Map class.  Yes it is generic but it is clear within the context of the enclosing class.', 'commenter': 'Claudenw'}]"
84,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -608,6 +608,33 @@ public static boolean isEqualCollection(final Collection<?> a, final Collection<
 
         return isEqualCollection(collect(a, transformer), collect(b, transformer));
     }
+    
+    /**
+     * Getting the hashCode of Collection through the hash method of Equator.
+     * <p>
+     * If the input collection is null return 1.
+     * </p>
+     *
+     * @param <E>  the element type
+     * @param collection  the input collection
+     * @param equator  the Equator used for generate hashCode
+     * @return the hashCode of Collection through the hash method of Equator
+     */
+    public static <E> int hashCode( final Collection<? extends E> collection,
+                                    final Equator<? super E> equator ) {
+        if ( null == equator ) {","[{'comment': 'No spaces inside parens please: `if ( foo )` -> `if (foo)`.', 'commenter': 'garydgregory'}]"
84,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -608,6 +608,33 @@ public static boolean isEqualCollection(final Collection<?> a, final Collection<
 
         return isEqualCollection(collect(a, transformer), collect(b, transformer));
     }
+    
+    /**
+     * Getting the hashCode of Collection through the hash method of Equator.
+     * <p>
+     * If the input collection is null return 1.
+     * </p>
+     *
+     * @param <E>  the element type
+     * @param collection  the input collection
+     * @param equator  the Equator used for generate hashCode
+     * @return the hashCode of Collection through the hash method of Equator
+     */
+    public static <E> int hashCode( final Collection<? extends E> collection,
+                                    final Equator<? super E> equator ) {
+        if ( null == equator ) {
+            throw new NullPointerException( ""Equator must not be null."" );
+        }
+        if ( null == collection ){","[{'comment': '`){` -> `) {`', 'commenter': 'garydgregory'}]"
84,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -608,6 +608,33 @@ public static boolean isEqualCollection(final Collection<?> a, final Collection<
 
         return isEqualCollection(collect(a, transformer), collect(b, transformer));
     }
+    
+    /**
+     * Getting the hashCode of Collection through the hash method of Equator.","[{'comment': 'Please replace `Getting the hashCode` with `Returns the hash code`.', 'commenter': 'garydgregory'}]"
84,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -608,6 +608,33 @@ public static boolean isEqualCollection(final Collection<?> a, final Collection<
 
         return isEqualCollection(collect(a, transformer), collect(b, transformer));
     }
+    
+    /**
+     * Getting the hashCode of Collection through the hash method of Equator.
+     * <p>
+     * If the input collection is null return 1.
+     * </p>
+     *
+     * @param <E>  the element type
+     * @param collection  the input collection
+     * @param equator  the Equator used for generate hashCode
+     * @return the hashCode of Collection through the hash method of Equator
+     */","[{'comment': 'Please add a `@since` tag since this a new public method.', 'commenter': 'garydgregory'}]"
84,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -608,6 +608,33 @@ public static boolean isEqualCollection(final Collection<?> a, final Collection<
 
         return isEqualCollection(collect(a, transformer), collect(b, transformer));
     }
+    
+    /**
+     * Getting the hashCode of Collection through the hash method of Equator.
+     * <p>
+     * If the input collection is null return 1.
+     * </p>
+     *
+     * @param <E>  the element type
+     * @param collection  the input collection
+     * @param equator  the Equator used for generate hashCode
+     * @return the hashCode of Collection through the hash method of Equator
+     */
+    public static <E> int hashCode(final Collection<? extends E> collection,
+                                   final Equator<? super E> equator) {
+        if (null == equator) {
+            throw new NullPointerException( ""Equator must not be null."" );
+        }
+        if (null == collection) {
+            return 1;
+        }
+        int hashCode = 1;
+        for (final E e : collection) {
+","[{'comment': 'Remove this extra blank line please.', 'commenter': 'garydgregory'}]"
84,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -608,6 +608,33 @@ public static boolean isEqualCollection(final Collection<?> a, final Collection<
 
         return isEqualCollection(collect(a, transformer), collect(b, transformer));
     }
+    
+    /**
+     * Returns the hash code of Collection through the hash method of Equator.
+     * <p>
+     * If the input collection is null return 1.
+     * </p>
+     *
+     * @param <E>  the element type
+     * @param collection  the input collection
+     * @param equator  the Equator used for generate hashCode
+     * @return the hashCode of Collection through the hash method of Equator
+     * @since 4.5
+     */
+    public static <E> int hashCode(final Collection<? extends E> collection,
+                                   final Equator<? super E> equator) {
+        if (null == equator) {
+            throw new NullPointerException( ""Equator must not be null."" );
+        }
+        if (null == collection) {
+            return 1;","[{'comment': 'This is rather odd IMO. We should return `0` for `null` like `java.util.Objects.hashCode(Object)`.', 'commenter': 'garydgregory'}]"
84,src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java,"@@ -620,6 +620,52 @@ public int hash(final Integer o) {
     public void testIsEqualCollectionNullEquator() {
         CollectionUtils.isEqualCollection(collectionA, collectionA, null);
     }
+    
+    @Test
+    public void testHashCode() {
+        final Equator<Integer> e = new Equator<Integer>() {
+            @Override
+            public boolean equate(final Integer o1, final Integer o2) {
+                if (o1 % 2 == 0 ^ o2 %2 == 0) {
+                    return false;
+                }
+                return true;
+            }
+
+            @Override
+            public int hash(final Integer o) {
+                return o == null ? 0 : o.hashCode();","[{'comment': 'Replace this with a call to `java.util.Objects.hashCode(Object)`.', 'commenter': 'garydgregory'}]"
84,src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java,"@@ -620,6 +620,52 @@ public int hash(final Integer o) {
     public void testIsEqualCollectionNullEquator() {
         CollectionUtils.isEqualCollection(collectionA, collectionA, null);
     }
+    
+    @Test
+    public void testHashCode() {
+        final Equator<Integer> e = new Equator<Integer>() {
+            @Override
+            public boolean equate(final Integer o1, final Integer o2) {
+                if (o1 % 2 == 0 ^ o2 %2 == 0) {
+                    return false;
+                }
+                return true;
+            }
+
+            @Override
+            public int hash(final Integer o) {
+                return o == null ? 0 : o.hashCode();
+            }
+        };
+
+        assertEquals(collectionA.hashCode(), CollectionUtils.hashCode(collectionA, e));
+    }
+
+    @Test
+    public void testHashCodeNullCollection() {
+        final Equator<Integer> e = new Equator<Integer>() {
+            @Override
+            public boolean equate(final Integer o1, final Integer o2) {
+                if (o1 % 2 == 0 ^ o2 % 2 == 0 ) {
+                    return false;
+                }
+                return true;
+            }
+
+            @Override
+            public int hash(final Integer o) {
+                return o == null ? 0 : o.hashCode();","[{'comment': 'java.util.Objects.hashCode(Object)', 'commenter': 'garydgregory'}]"
89,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -609,6 +609,33 @@ public static boolean isEqualCollection(final Collection<?> a, final Collection<
         return isEqualCollection(collect(a, transformer), collect(b, transformer));
     }
 
+    /**
+     * Returns the hash code of Collection through the hash method of Equator.","[{'comment': 'Maybe match the text in the `@param` docs: ""Returns the hash code the the input collection using the hash method of the equator.""?', 'commenter': 'kinow'}]"
89,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -609,6 +609,33 @@ public static boolean isEqualCollection(final Collection<?> a, final Collection<
         return isEqualCollection(collect(a, transformer), collect(b, transformer));
     }
 
+    /**
+     * Returns the hash code of Collection through the hash method of Equator.
+     * <p>
+     * If the input collection is null return 1.","[{'comment': 'I think it returns `0`? Maybe something like: ""When the collection is {@code null} it returns 0 (zero). The equator must not be {@code null}, otherwise a {@code NullPointerException} is raised."" (sorry my rusty Javadoc, I think there\'s a way to format code/numbers/classes/etc).', 'commenter': 'kinow'}]"
89,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -624,9 +624,7 @@ public static boolean isEqualCollection(final Collection<?> a, final Collection<
      */
     public static <E> int hashCode(final Collection<? extends E> collection,
                                 final Equator<? super E> equator) {
-        if (null == equator) {
-            throw new NullPointerException( ""Equator must not be null."" );
-        }
+        Objects.requireNonNull(equator, ""Equator"");","[{'comment': '""Equator"" -> ""equator""', 'commenter': 'garydgregory'}, {'comment': 'Thanks @garydgregory . I had updated Equator to equator .', 'commenter': 'dota17'}]"
91,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -909,6 +909,46 @@ public int hashCode() {
         return predicate != null && IterableUtils.matchesAll(input, predicate);
     }
 
+    /**
+     * Removes the specified number of elements from the specified location in the collection and returns them.
+     * This method would have the side-effect of modifying the input collections.
+     *
+     * @param <E>  the type of object the {@link Collection} contains
+     * @param input  the collection will be operated,can't be null
+     * @param start  the specified position to remove element,can't be less than 1
+     * @param count  the specified number to remove,can't be less than 1
+     * @return collection of elements that removed from the input collection
+     */
+    public static <E> Collection<E> drain(Collection<E> input, int start, int count) {
+		if (null == input) {
+			throw new IllegalArgumentException(""The collection can't be null."");
+		}
+		if (start < 1) {
+			throw new IllegalArgumentException(""The Start can't less than 1."");
+		}
+		if (count < 1) {","[{'comment': 'A count of 0 seems like it should be legal input, ending up removing nothing.', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -909,6 +909,46 @@ public int hashCode() {
         return predicate != null && IterableUtils.matchesAll(input, predicate);
     }
 
+    /**
+     * Removes the specified number of elements from the specified location in the collection and returns them.
+     * This method would have the side-effect of modifying the input collections.
+     *
+     * @param <E>  the type of object the {@link Collection} contains
+     * @param input  the collection will be operated,can't be null
+     * @param start  the specified position to remove element,can't be less than 1
+     * @param count  the specified number to remove,can't be less than 1
+     * @return collection of elements that removed from the input collection
+     */
+    public static <E> Collection<E> drain(Collection<E> input, int start, int count) {","[{'comment': 'We already have methods named ""remove*"" in this class and the fact that your comments starts with ""Removes"" shows to me that this method should also be prefixed with ""remove"".', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -909,6 +909,46 @@ public int hashCode() {
         return predicate != null && IterableUtils.matchesAll(input, predicate);
     }
 
+    /**
+     * Removes the specified number of elements from the specified location in the collection and returns them.
+     * This method would have the side-effect of modifying the input collections.
+     *
+     * @param <E>  the type of object the {@link Collection} contains
+     * @param input  the collection will be operated,can't be null
+     * @param start  the specified position to remove element,can't be less than 1
+     * @param count  the specified number to remove,can't be less than 1
+     * @return collection of elements that removed from the input collection
+     */
+    public static <E> Collection<E> drain(Collection<E> input, int start, int count) {
+		if (null == input) {
+			throw new IllegalArgumentException(""The collection can't be null."");
+		}
+		if (start < 1) {","[{'comment': 'This seems wrong, collections are addressed starting at index 0. I should be able to call this method and have it remove all elements in one go by passing in a start of 0 and a count equal to the collection size.', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -1791,6 +1791,63 @@ public static int maxSize(final Collection<? extends Object> coll) {
         return list;
     }
 
+    /**
+     * Removes elements whose index are between startIndex and endIndex in the collection and returns them.
+     * This method would have the side-effect of modifying the input collections.
+     *
+     * @param <E>  the type of object the {@link Collection} contains
+     * @param input  the collection will be operated,can't be null
+     * @param startIndex  the start index to remove element,can't be less than 0
+     * @param endIndex  the end index to remove,can't be less than startIndex
+     * @return collection of elements that removed from the input collection
+     */
+    public static <E> Collection<E> removeRange(Collection<E> input, int startIndex, int endIndex) {
+        if (endIndex < startIndex) {
+            throw new IllegalArgumentException(""The start index can't less than the end index."");","[{'comment': 'This message is backward.', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -1791,6 +1791,63 @@ public static int maxSize(final Collection<? extends Object> coll) {
         return list;
     }
 
+    /**
+     * Removes elements whose index are between startIndex and endIndex in the collection and returns them.
+     * This method would have the side-effect of modifying the input collections.
+     *
+     * @param <E>  the type of object the {@link Collection} contains
+     * @param input  the collection will be operated,can't be null
+     * @param startIndex  the start index to remove element,can't be less than 0","[{'comment': 'Missing space after the comma.', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -1791,6 +1791,63 @@ public static int maxSize(final Collection<? extends Object> coll) {
         return list;
     }
 
+    /**
+     * Removes elements whose index are between startIndex and endIndex in the collection and returns them.
+     * This method would have the side-effect of modifying the input collections.
+     *
+     * @param <E>  the type of object the {@link Collection} contains
+     * @param input  the collection will be operated,can't be null
+     * @param startIndex  the start index to remove element,can't be less than 0
+     * @param endIndex  the end index to remove,can't be less than startIndex
+     * @return collection of elements that removed from the input collection
+     */","[{'comment': 'Add `@since` tag.', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -1791,6 +1791,63 @@ public static int maxSize(final Collection<? extends Object> coll) {
         return list;
     }
 
+    /**
+     * Removes elements whose index are between startIndex and endIndex in the collection and returns them.
+     * This method would have the side-effect of modifying the input collections.
+     *
+     * @param <E>  the type of object the {@link Collection} contains
+     * @param input  the collection will be operated,can't be null
+     * @param startIndex  the start index to remove element,can't be less than 0
+     * @param endIndex  the end index to remove,can't be less than startIndex
+     * @return collection of elements that removed from the input collection
+     */
+    public static <E> Collection<E> removeRange(Collection<E> input, int startIndex, int endIndex) {
+        if (endIndex < startIndex) {
+            throw new IllegalArgumentException(""The start index can't less than the end index."");
+        }
+        return CollectionUtils.removeCount(input, startIndex, endIndex-startIndex);
+    }
+
+    /**
+     * Removes the specified number of elements from the start index in the collection and returns them.
+     * This method would have the side-effect of modifying the input collections.
+     *
+     * @param <E>  the type of object the {@link Collection} contains
+     * @param input  the collection will be operated,can't be null
+     * @param startIndex  the start index to remove element,can't be less than 0
+     * @param count  the specified number to remove,can't be less than 1
+     * @return collection of elements that removed from the input collection","[{'comment': 'Add `@since` tag.', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -1791,6 +1791,63 @@ public static int maxSize(final Collection<? extends Object> coll) {
         return list;
     }
 
+    /**
+     * Removes elements whose index are between startIndex and endIndex in the collection and returns them.
+     * This method would have the side-effect of modifying the input collections.
+     *
+     * @param <E>  the type of object the {@link Collection} contains
+     * @param input  the collection will be operated,can't be null
+     * @param startIndex  the start index to remove element,can't be less than 0
+     * @param endIndex  the end index to remove,can't be less than startIndex
+     * @return collection of elements that removed from the input collection
+     */
+    public static <E> Collection<E> removeRange(Collection<E> input, int startIndex, int endIndex) {
+        if (endIndex < startIndex) {
+            throw new IllegalArgumentException(""The start index can't less than the end index."");
+        }
+        return CollectionUtils.removeCount(input, startIndex, endIndex-startIndex);
+    }
+
+    /**
+     * Removes the specified number of elements from the start index in the collection and returns them.
+     * This method would have the side-effect of modifying the input collections.","[{'comment': 'Replace:\r\nThis method would have the side-effect of modifying the input collections.\r\n\r\nWith:\r\nThis method modifies the input collection.', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -1791,6 +1791,63 @@ public static int maxSize(final Collection<? extends Object> coll) {
         return list;
     }
 
+    /**
+     * Removes elements whose index are between startIndex and endIndex in the collection and returns them.
+     * This method would have the side-effect of modifying the input collections.
+     *
+     * @param <E>  the type of object the {@link Collection} contains
+     * @param input  the collection will be operated,can't be null
+     * @param startIndex  the start index to remove element,can't be less than 0
+     * @param endIndex  the end index to remove,can't be less than startIndex
+     * @return collection of elements that removed from the input collection
+     */
+    public static <E> Collection<E> removeRange(Collection<E> input, int startIndex, int endIndex) {
+        if (endIndex < startIndex) {
+            throw new IllegalArgumentException(""The start index can't less than the end index."");
+        }
+        return CollectionUtils.removeCount(input, startIndex, endIndex-startIndex);
+    }
+
+    /**
+     * Removes the specified number of elements from the start index in the collection and returns them.
+     * This method would have the side-effect of modifying the input collections.
+     *
+     * @param <E>  the type of object the {@link Collection} contains
+     * @param input  the collection will be operated,can't be null
+     * @param startIndex  the start index to remove element,can't be less than 0
+     * @param count  the specified number to remove,can't be less than 1
+     * @return collection of elements that removed from the input collection
+     */
+    public static <E> Collection<E> removeCount(Collection<E> input, int startIndex, int count) {
+        if (null == input) {
+            throw new IllegalArgumentException(""The collection can't be null."");
+        }
+        if (startIndex < 0) {
+            throw new IllegalArgumentException(""The start index can't less than 0."");
+        }
+        if (count < 0) {
+            throw new IllegalArgumentException(""The count can't less than 0."");
+        }
+        if (input.size() < startIndex + count) {
+            throw new IllegalArgumentException(
+                    ""The sum of start index and count cann't be greater than the size of collection."");
+        }
+
+        Collection<E> result = new ArrayList<E>(count);
+        Iterator<E> iterator = input.iterator();
+        while (count > 0) {
+            if(startIndex > 0) {","[{'comment': '""if("" -> ""if (""', 'commenter': 'garydgregory'}]"
91,src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java,"@@ -1472,6 +1472,101 @@ public void testRetainAll() {
         } // this is what we want
     }
 
+    @Test
+    public void testRemoveRange() {
+        List<Integer> list = new ArrayList<Integer>();","[{'comment': ""FYI: You don't need to over specify generics in Java 8 anymore, so:\r\n```\r\nList<Integer> list = new ArrayList<Integer>();\r\n```\r\ncan simply be:\r\n```\r\nList<Integer> list = new ArrayList<>();\r\n```"", 'commenter': 'garydgregory'}, {'comment': ""Also please rebase on master, then I'll take another look. TY!"", 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -1791,6 +1791,65 @@ public static int maxSize(final Collection<? extends Object> coll) {
         return list;
     }
 
+    /**
+     * Removes elements whose index are between startIndex and endIndex in the collection and returns them.
+     * This method modifies the input collections.
+     *
+     * @param <E>  the type of object the {@link Collection} contains
+     * @param input  the collection will be operated, can't be null
+     * @param startIndex  the start index to remove element, can't be less than 0
+     * @param endIndex  the end index to remove, can't be less than startIndex","[{'comment': 'The Javadoc for indexes should specify whether they are inclusive or exclusive, for example, see https://docs.oracle.com/javase/8/docs/api/java/util/List.html#subList-int-int-', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -1791,6 +1791,65 @@ public static int maxSize(final Collection<? extends Object> coll) {
         return list;
     }
 
+    /**
+     * Removes elements whose index are between startIndex and endIndex in the collection and returns them.
+     * This method modifies the input collections.
+     *
+     * @param <E>  the type of object the {@link Collection} contains
+     * @param input  the collection will be operated, can't be null
+     * @param startIndex  the start index to remove element, can't be less than 0
+     * @param endIndex  the end index to remove, can't be less than startIndex
+     * @return collection of elements that removed from the input collection
+     * @since 4.5
+     */
+    public static <E> Collection<E> removeRange(Collection<E> input, int startIndex, int endIndex) {","[{'comment': 'Please use `final` when possible; your IDE might do this for you (Eclipse can for example.)', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -1797,12 +1797,12 @@ public static int maxSize(final Collection<? extends Object> coll) {
      *
      * @param <E>  the type of object the {@link Collection} contains
      * @param input  the collection will be operated, can't be null
-     * @param startIndex  the start index to remove element, can't be less than 0
-     * @param endIndex  the end index to remove, can't be less than startIndex
+     * @param startIndex  the start index (inclusive) to remove element, can't be less than 0
+     * @param endIndex  the end index (inclusive) to remove, can't be less than startIndex","[{'comment': 'I think we should make the end index **exclusive** to avoid confusion with other APIs.\r\nNote the API I previously referred: https://docs.oracle.com/javase/8/docs/api/java/util/List.html#subList-int-int-', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -1791,6 +1791,65 @@ public static int maxSize(final Collection<? extends Object> coll) {
         return list;
     }
 
+    /**
+     * Removes elements whose index are between startIndex and endIndex in the collection and returns them.
+     * This method modifies the input collections.
+     *
+     * @param <E>  the type of object the {@link Collection} contains
+     * @param input  the collection will be operated, can't be null
+     * @param startIndex  the start index (inclusive) to remove element, can't be less than 0
+     * @param endIndex  the end index (inclusive) to remove, can't be less than startIndex
+     * @return collection of elements that removed from the input collection
+     * @since 4.5
+     */
+    public static <E> Collection<E> removeRange(final Collection<E> input, int startIndex, int endIndex) {","[{'comment': 'Use final for startIndex and endIndex.', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/collections4/CollectionUtils.java,"@@ -1825,13 +1832,13 @@ public static int maxSize(final Collection<? extends Object> coll) {
             throw new IllegalArgumentException(""The collection can't be null."");
         }
         if (startIndex < 0) {
-            throw new IllegalArgumentException(""The start index can't less than 0."");
+            throw new IndexOutOfBoundsException(""The start index can't less than 0."");","[{'comment': 'You are missing words in these exception messages:\r\n""The start index can\'t less than 0.""\r\n->\r\n""The start index can\'t **be** less than 0.""', 'commenter': 'garydgregory'}]"
101,src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java,"@@ -421,6 +421,54 @@ public void testGetIndex() {
             assertEquals(confirmed.get(i + 2), queue.get(i));
         }
     }
+	
+	public void testAddNull() {
+        final CircularFifoQueue<E> b = new CircularFifoQueue<>(2);
+        try {
+            b.add(null);
+            fail();
+        } catch (final NullPointerException ex) {
+            assertEquals(""Attempted to add null object to queue"",ex.getMessage());","[{'comment': '-1: I do not think we should test the actual text of the message, it is too brittle IMO. We should not break test when we are improving or updating exception messages later on. Testing that the exception message is not empty is OK though. Also there is a space missing after the comma.', 'commenter': 'garydgregory'}]"
101,src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java,"@@ -421,6 +421,54 @@ public void testGetIndex() {
             assertEquals(confirmed.get(i + 2), queue.get(i));
         }
     }
+	
+	public void testAddNull() {
+        final CircularFifoQueue<E> b = new CircularFifoQueue<>(2);
+        try {
+            b.add(null);
+            fail();
+        } catch (final NullPointerException ex) {
+            assertEquals(""Attempted to add null object to queue"",ex.getMessage());
+            return;
+        }
+        fail();
+    }
+
+    public void testDefaultSizeAndGetError1() {
+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<>();
+        assertEquals(32,fifo.maxSize());
+        fifo.add((E) ""1"");
+        fifo.add((E) ""2"");
+        fifo.add((E) ""3"");
+        fifo.add((E) ""4"");
+        fifo.add((E) ""5"");
+        assertEquals(5,fifo.size());
+        try {
+            fifo.get(5);
+        } catch (final NoSuchElementException ex) {
+            assertEquals(""The specified index (5) is outside the available range [0, 5)"",ex.getMessage());","[{'comment': 'Same as my previous comment. This is a place where I would want to change the message, there is no reason why the number 5 should be in parens. Also the range syntax is left to comprehend as an exercise to the reader, which is not great IMO.', 'commenter': 'garydgregory'}, {'comment': 'Ok， I got it, thanks !', 'commenter': 'dota17'}]"
101,src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java,"@@ -421,6 +421,54 @@ public void testGetIndex() {
             assertEquals(confirmed.get(i + 2), queue.get(i));
         }
     }
+	
+	public void testAddNull() {
+        final CircularFifoQueue<E> b = new CircularFifoQueue<>(2);
+        try {
+            b.add(null);
+            fail();
+        } catch (final NullPointerException ex) {
+            assertEquals(""Attempted to add null object to queue"",ex.getMessage());
+            return;
+        }
+        fail();
+    }
+
+    public void testDefaultSizeAndGetError1() {
+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<>();
+        assertEquals(32,fifo.maxSize());
+        fifo.add((E) ""1"");
+        fifo.add((E) ""2"");
+        fifo.add((E) ""3"");
+        fifo.add((E) ""4"");
+        fifo.add((E) ""5"");
+        assertEquals(5,fifo.size());
+        try {
+            fifo.get(5);
+        } catch (final NoSuchElementException ex) {
+            assertEquals(""The specified index (5) is outside the available range [0, 5)"",ex.getMessage());
+            return;
+        }
+        fail();
+    }
+
+    public void testDefaultSizeAndGetError2() {
+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<>();
+        assertEquals(32,fifo.maxSize());
+        fifo.add((E) ""1"");
+        fifo.add((E) ""2"");
+        fifo.add((E) ""3"");
+        fifo.add((E) ""4"");
+        fifo.add((E) ""5"");
+        assertEquals(5,fifo.size());
+        try {
+            fifo.get(-2);
+        } catch (final NoSuchElementException ex) {
+            assertEquals(""The specified index (-2) is outside the available range [0, 5)"",ex.getMessage());","[{'comment': 'Same comment as previous.', 'commenter': 'garydgregory'}]"
102,src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java,"@@ -16,12 +16,8 @@
  */
 package org.apache.commons.collections4.multimap;
 
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.Map;
+import java.util.*;","[{'comment': 'No `*` imports please.', 'commenter': 'garydgregory'}]"
102,src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java,"@@ -100,6 +96,68 @@ public void testAddException() {
         }
     }
 
+    public void testRemoveException() {
+        final MultiValuedMap<K, V> map = makeFullMap();
+        try {
+            map.remove((K) ""one"");
+            fail();
+        } catch (final UnsupportedOperationException e) {
+        }","[{'comment': 'Comment empty blocks so we know why we are ignoring exceptions. It helps others to understand the code more quicly IMO.', 'commenter': 'garydgregory'}]"
103,src/test/java/org/apache/commons/collections4/list/FixedSizeListTest.java,"@@ -83,4 +83,66 @@ public void testListAllowsMutationOfUnderlyingCollection() {
         Assert.assertEquals(""Modifying an the underlying list is allowed"",
                 sizeBefore + 1, fixedSizeList.size());
     }
+
+    //-----------------------------------------------------------------------","[{'comment': ""Let's not add these kinds of `//---...` lines as they appear, to me, as just noise."", 'commenter': 'garydgregory'}, {'comment': 'Ok, I have removed all the new ones, thank you for your suggestion.', 'commenter': 'dota17'}]"
106,src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMapTest.java,"@@ -16,8 +16,7 @@
  */
 package org.apache.commons.collections4.multimap;
 
-import java.util.List;
-import java.util.ListIterator;
+import java.util.*;","[{'comment': 'No `*` imports please.', 'commenter': 'garydgregory'}, {'comment': 'OK，thank you, I will pay attention to similar problems', 'commenter': 'dota17'}]"
118,src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java,"@@ -514,6 +515,8 @@ protected void addNodeAfter(final Node<E> node, final E value) {
      * @throws NullPointerException if either node is null
      */
     protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNode) {
+        Objects.requireNonNull(nodeToInsert,""The new node on insert must not be null."");","[{'comment': 'Please add a space after the comma.', 'commenter': 'garydgregory'}]"
118,src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java,"@@ -514,6 +515,8 @@ protected void addNodeAfter(final Node<E> node, final E value) {
      * @throws NullPointerException if either node is null
      */
     protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNode) {
+        Objects.requireNonNull(nodeToInsert,""The new node on insert must not be null."");
+        Objects.requireNonNull(insertBeforeNode,""The node to insert before must not be null."");","[{'comment': 'Please add a space after the comma.', 'commenter': 'garydgregory'}, {'comment': 'Thanks for your suggestions, I will fix the commit right away.', 'commenter': 'dota17'}]"
118,src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java,"@@ -529,6 +532,7 @@ protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNod
      * @throws NullPointerException if <code>node</code> is null
      */
     protected void removeNode(final Node<E> node) {
+        Objects.requireNonNull(node,""The new node to remove must not be null."");","[{'comment': 'Please add a space after the comma.', 'commenter': 'garydgregory'}, {'comment': 'Thanks for your suggestions, I will fix the commit right away.', 'commenter': 'dota17'}]"
118,src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java,"@@ -387,7 +388,7 @@ public boolean equals(final Object obj) {
         while (it1.hasNext() && it2.hasNext()) {
             final Object o1 = it1.next();
             final Object o2 = it2.next();
-            if (!(o1 == null ? o2 == null : o1.equals(o2))) {
+            if (!(Objects.equals(o1, o2))) {","[{'comment': 'How about in-lining `o1` and `o2` since they are not reused?', 'commenter': 'garydgregory'}, {'comment': 'Thanks for your suggestions, I will fix the commit right away.', 'commenter': 'dota17'}]"
118,src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java,"@@ -514,6 +513,8 @@ protected void addNodeAfter(final Node<E> node, final E value) {
      * @throws NullPointerException if either node is null
      */
     protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNode) {
+        Objects.requireNonNull(nodeToInsert, ""The new node on insert must not be null."");","[{'comment': 'I think it would be simpler to use the parameter name as the message like this:\r\n```\r\nObjects.requireNonNull(nodeToInsert, ""nodeToInsert"");\r\n```\r\nThis avoids making such simple checks too wordy and side-steps any localization issue (aside from the fact that our parameter names are in English.)', 'commenter': 'garydgregory'}, {'comment': 's/new node on insert/new node to insert? Like the `@param` in the javadoc above.', 'commenter': 'kinow'}]"
118,src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java,"@@ -514,6 +513,8 @@ protected void addNodeAfter(final Node<E> node, final E value) {
      * @throws NullPointerException if either node is null
      */
     protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNode) {
+        Objects.requireNonNull(nodeToInsert, ""The new node to insert must not be null."");","[{'comment': 'Keep it simple: `Objects.requireNonNull(nodeToInsert, ""nodeToInsert"");`\r\n', 'commenter': 'garydgregory'}]"
118,src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java,"@@ -514,6 +513,8 @@ protected void addNodeAfter(final Node<E> node, final E value) {
      * @throws NullPointerException if either node is null
      */
     protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNode) {
+        Objects.requireNonNull(nodeToInsert, ""The new node to insert must not be null."");
+        Objects.requireNonNull(insertBeforeNode, ""The node to insert before must not be null."");","[{'comment': 'Keep it simple: `Objects.requireNonNull(insertBeforeNode, ""insertBeforeNode"");`\r\n', 'commenter': 'garydgregory'}]"
118,src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java,"@@ -529,6 +530,7 @@ protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNod
      * @throws NullPointerException if {@code node} is null
      */
     protected void removeNode(final Node<E> node) {
+        Objects.requireNonNull(node, ""The new node to remove must not be null."");","[{'comment': 'Keep it simple: `Objects.requireNonNull(node, ""node"");`', 'commenter': 'garydgregory'}]"
122,src/main/java/org/apache/commons/collections4/MapUtils.java,"@@ -1186,11 +1188,12 @@ public static void debugPrint(final PrintStream out, final Object label, final M
      *
      * @param <K> the key type
      * @param <V> the value type
-     * @param map the map to invert, may not be null
+     * @param map the map to invert, must not be null
      * @return a new HashMap containing the inverted data
      * @throws NullPointerException if the map is null
      */
     public static <K, V> Map<V, K> invertMap(final Map<K, V> map) {
+        Objects.requireNonNull(map, ""The map must not be null"");","[{'comment': 'Please simply use the argument name like ""map"" or whatever the faulty argument name is.', 'commenter': 'garydgregory'}, {'comment': 'Thanks for your advice. I have updated it.', 'commenter': 'dota17'}]"
123,src/main/java/org/apache/commons/collections4/map/DefaultedMap.java,"@@ -105,7 +105,8 @@
      * @param map  the map to decorate, must not be null
      * @param factory  the factory to use to create entries, must not be null
      * @return a new defaulting map
-     * @throws NullPointerException if map or factory is null
+     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if factory is null","[{'comment': 'This is indeed a judgment of NullPointerException. It is recommended to modify IllegalArgumentException to NullPointerException, and to supplement the test cases for it.', 'commenter': 'dota17'}, {'comment': 'Agreed. I changed to NullPointerException and added test cases for it.', 'commenter': 'pengyunie'}]"
123,src/main/java/org/apache/commons/collections4/map/DefaultedMap.java,"@@ -110,7 +110,7 @@
      */
     public static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final Factory<? extends V> factory) {
         if (factory == null) {","[{'comment': 'Not quite, to go the NPE route, you should use a liner with `Objects.requireNonNull()`.', 'commenter': 'garydgregory'}, {'comment': 'Changed to use `Objects.requireNonNull` (I noticed and followed commit 513ae545ee2b333f62f8ff989e1da161d807d76d)', 'commenter': 'pengyunie'}]"
126,src/test/java/org/apache/commons/collections4/MapUtilsTest.java,"@@ -159,6 +159,17 @@ public void testInvertMap() {
         assertEquals( ""3"", out.get(""C""));
         assertEquals( ""4"", out.get(""D""));
         assertEquals( ""5"", out.get(""E""));
+","[{'comment': 'I would put this in a new method `testInvertMapNull` or something like that, this will give us better granularity in test code.', 'commenter': 'garydgregory'}, {'comment': '+1, @dota17 other than that this change looks good. If you could update it whenever you have time I think it should be ready to be merged.', 'commenter': 'kinow'}, {'comment': 'Thank you for your review. I had fixed it and resolved the conflict.\r\n', 'commenter': 'dota17'}]"
126,src/test/java/org/apache/commons/collections4/MapUtilsTest.java,"@@ -146,19 +147,36 @@ public void testInvertMap() {
         final Set<String> inKeySet = new HashSet<>(in.keySet());
         final Set<String> inValSet = new HashSet<>(in.values());
 
-        final Map<String, String> out =  MapUtils.invertMap(in);
+        final Map<String, String> out = MapUtils.invertMap(in);
 
         final Set<String> outKeySet = new HashSet<>(out.keySet());
         final Set<String> outValSet = new HashSet<>(out.values());
 
         assertEquals(inKeySet, outValSet);
         assertEquals(inValSet, outKeySet);
 
-        assertEquals( ""1"", out.get(""A""));
-        assertEquals( ""2"", out.get(""B""));
-        assertEquals( ""3"", out.get(""C""));
-        assertEquals( ""4"", out.get(""D""));
-        assertEquals( ""5"", out.get(""E""));
+        assertEquals(""1"", out.get(""A""));
+        assertEquals(""2"", out.get(""B""));
+        assertEquals(""3"", out.get(""C""));
+        assertEquals(""4"", out.get(""D""));
+        assertEquals(""5"", out.get(""E""));
+    }
+
+    @Test
+    public void testInvertEmptyMap() {
+        Map<String, String> emptyMap = new HashMap<>();
+        Map<String, String> resultMap = MapUtils.invertMap(emptyMap);
+        assertEquals(emptyMap, resultMap);
+    }
+
+    @Test
+    public void testInvertMapNull() {
+        try {
+            MapUtils.invertMap(null);
+            fail(""Expecting NullPointerException for null map"");
+        } catch (final NullPointerException ex) {
+            // expected
+        }","[{'comment': 'Now that we depend on JUnit 5, you can/should test exceptions the with JUnit 5 APIs: https://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions', 'commenter': 'garydgregory'}, {'comment': ""> Now that we depend on JUnit 5, you can/should test exceptions the with JUnit 5 APIs: https://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions\r\n\r\nIt's my pleasure to finish it."", 'commenter': 'dota17'}]"
130,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/HashFunctionIdentity.java,"@@ -58,6 +58,10 @@
 
     /**
      * Identifies the signedness of the calculations for this function.
+     * <p>
+     * When the hash function executes it generally returns an array of bytes.
+     * That array is converted into one or more numerical values.
+     * The Signedness identifies if those values are signed or unsigned.","[{'comment': 'Close HTML tags.\r\n', 'commenter': 'garydgregory'}]"
131,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasher.java,"@@ -0,0 +1,227 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+
+import org.apache.commons.collections4.bloomfilter.hasher.HashFunction;
+import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity;
+import org.apache.commons.collections4.bloomfilter.hasher.Hasher;
+import org.apache.commons.collections4.bloomfilter.hasher.Shape;
+import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType;
+
+/**
+ * An implementation of Hasher that attempts to leak as little data as possible.
+ * Each item in the hasher is represented by two (2) longs.  So this Hasher will
+ * still indicate how many items are in the hasher but will not leak the buffers
+ * that are being hashed as the @code DynamicHasher} does.
+ * <p>
+ * This hasher only accepts HashFunctions that are cyclic in nature.
+ * </p>
+ * @see DynamicHasher
+ * @see ProcessType
+ */
+public class CachingHasher implements Hasher {
+
+    /**
+     * The list of byte arrays that are to be hashed.
+     */
+    private final List<long[]> buffers;
+
+    /**
+     * The hash function identity
+     */
+    private final HashFunctionIdentity functionIdentity;
+
+    /**
+     * Constructs a CachingHasher from a list of arrays of hash values.
+     * <p>
+     * The list of hash values comprises a @code{List&lt;long[]&gt;} where each @code{long[]}
+     * is comprises two (2) values that are the result of hashing the original buffer.  Thus a
+     * CachingHasher that was built from five (5) buffers will have five arrays of two @code{longs} each.
+     *","[{'comment': 'Close HTML tags.\r\n', 'commenter': 'garydgregory'}]"
131,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasher.java,"@@ -0,0 +1,227 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+
+import org.apache.commons.collections4.bloomfilter.hasher.HashFunction;
+import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity;
+import org.apache.commons.collections4.bloomfilter.hasher.Hasher;
+import org.apache.commons.collections4.bloomfilter.hasher.Shape;
+import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType;
+
+/**
+ * An implementation of Hasher that attempts to leak as little data as possible.
+ * Each item in the hasher is represented by two (2) longs.  So this Hasher will
+ * still indicate how many items are in the hasher but will not leak the buffers
+ * that are being hashed as the @code DynamicHasher} does.
+ * <p>
+ * This hasher only accepts HashFunctions that are cyclic in nature.
+ * </p>
+ * @see DynamicHasher
+ * @see ProcessType
+ */
+public class CachingHasher implements Hasher {
+
+    /**
+     * The list of byte arrays that are to be hashed.
+     */
+    private final List<long[]> buffers;
+
+    /**
+     * The hash function identity
+     */
+    private final HashFunctionIdentity functionIdentity;
+
+    /**
+     * Constructs a CachingHasher from a list of arrays of hash values.
+     * <p>
+     * The list of hash values comprises a @code{List&lt;long[]&gt;} where each @code{long[]}
+     * is comprises two (2) values that are the result of hashing the original buffer.  Thus a
+     * CachingHasher that was built from five (5) buffers will have five arrays of two @code{longs} each.
+     *
+     * @param functionIdentity The identity of the function.
+     * @param buffers          a list of @code{long} arrays comprising two (2) values.
+     * @throws IllegalArgumentException if the name does not indicate a cyclic
+     *                                  hashing function.
+     */
+    public CachingHasher(HashFunctionIdentity functionIdentity, List<long[]> buffers) {
+        this.functionIdentity = checkIdentity(functionIdentity);
+        this.buffers = new ArrayList<long[]>(buffers);
+    }
+
+    /**
+     * Constructs a CachingHasher from an array of arrys of hash values.
+     *
+     * @param functionIdentity The identity of the function.
+     * @param buffers          an array of @code{long} arrays comprising two (2) values.
+     * @throws IllegalArgumentException if the name does not indicate a cyclic
+     *                                  hashing function.
+     */
+    public CachingHasher(HashFunctionIdentity functionIdentity, long[][] buffers) {
+        this.functionIdentity = checkIdentity(functionIdentity);
+        this.buffers = Arrays.asList(buffers);
+    }
+
+    /**
+     * Check that the name is valid for this hasher.","[{'comment': '""Check"" -> ""Checks"".', 'commenter': 'garydgregory'}, {'comment': 'fixed.', 'commenter': 'Claudenw'}]"
131,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasher.java,"@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+
+import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType;
+
+/**
+ * An implementation of Hasher that attempts to leak as little data as possible.
+ * Each item in the hasher is represented by two (2) longs.  So this Hasher will
+ * still indicate how many items are in the hasher but will not leak the buffers
+ * that are being hashed as the @code DynamicHasher} does.","[{'comment': 'Correct the {@code ...} tag', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
131,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasher.java,"@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+
+import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType;
+
+/**
+ * An implementation of Hasher that attempts to leak as little data as possible.
+ * Each item in the hasher is represented by two (2) longs.  So this Hasher will
+ * still indicate how many items are in the hasher but will not leak the buffers
+ * that are being hashed as the @code DynamicHasher} does.
+ * <p>
+ * This hasher only accepts HashFunctions that are cyclic in nature.
+ * </p>
+ * @see DynamicHasher
+ * @see ProcessType
+ */
+public class CachingHasher implements Hasher {
+
+    /**
+     * The list of byte arrays that are to be hashed.
+     */
+    private final List<long[]> buffers;
+
+    /**
+     * The hash function identity
+     */
+    private final HashFunctionIdentity functionIdentity;
+
+    /**
+     * Constructs a CachingHasher from a list of arrays of hash values.
+     * <p>
+     * The list of hash values comprises a @code{List&lt;long[]&gt;} where each @code{long[]}","[{'comment': '{@code List<long[]>} and {@code long[]}', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
131,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasher.java,"@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+
+import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType;
+
+/**
+ * An implementation of Hasher that attempts to leak as little data as possible.
+ * Each item in the hasher is represented by two (2) longs.  So this Hasher will
+ * still indicate how many items are in the hasher but will not leak the buffers
+ * that are being hashed as the @code DynamicHasher} does.
+ * <p>
+ * This hasher only accepts HashFunctions that are cyclic in nature.
+ * </p>
+ * @see DynamicHasher
+ * @see ProcessType
+ */
+public class CachingHasher implements Hasher {
+
+    /**
+     * The list of byte arrays that are to be hashed.
+     */
+    private final List<long[]> buffers;
+
+    /**
+     * The hash function identity
+     */
+    private final HashFunctionIdentity functionIdentity;
+
+    /**
+     * Constructs a CachingHasher from a list of arrays of hash values.
+     * <p>
+     * The list of hash values comprises a @code{List&lt;long[]&gt;} where each @code{long[]}
+     * is comprises two (2) values that are the result of hashing the original buffer.  Thus a
+     * CachingHasher that was built from five (5) buffers will have five arrays of two @code{longs}","[{'comment': '{@code long}s', 'commenter': 'aherbert'}]"
131,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasher.java,"@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+
+import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType;
+
+/**
+ * An implementation of Hasher that attempts to leak as little data as possible.
+ * Each item in the hasher is represented by two (2) longs.  So this Hasher will
+ * still indicate how many items are in the hasher but will not leak the buffers
+ * that are being hashed as the @code DynamicHasher} does.
+ * <p>
+ * This hasher only accepts HashFunctions that are cyclic in nature.
+ * </p>
+ * @see DynamicHasher
+ * @see ProcessType
+ */
+public class CachingHasher implements Hasher {
+
+    /**
+     * The list of byte arrays that are to be hashed.
+     */
+    private final List<long[]> buffers;
+
+    /**
+     * The hash function identity
+     */
+    private final HashFunctionIdentity functionIdentity;
+
+    /**
+     * Constructs a CachingHasher from a list of arrays of hash values.
+     * <p>
+     * The list of hash values comprises a @code{List&lt;long[]&gt;} where each @code{long[]}
+     * is comprises two (2) values that are the result of hashing the original buffer.  Thus a
+     * CachingHasher that was built from five (5) buffers will have five arrays of two @code{longs}
+     * each.
+     * </p>
+     * @param functionIdentity The identity of the function.
+     * @param buffers          a list of @code{long} arrays comprising two (2) values.
+     * @throws IllegalArgumentException if the name does not indicate a cyclic
+     *                                  hashing function.
+     */
+    public CachingHasher(HashFunctionIdentity functionIdentity, List<long[]> buffers) {
+        this.functionIdentity = checkIdentity(functionIdentity);
+        this.buffers = new ArrayList<long[]>(buffers);
+    }
+
+    /**
+     * Constructs a CachingHasher from an array of arrys of hash values.
+     *
+     * @param functionIdentity The identity of the function.
+     * @param buffers          an array of @code{long} arrays comprising two (2) values.","[{'comment': ""I don't think the (2) adds anything."", 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
131,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasher.java,"@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+
+import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType;
+
+/**
+ * An implementation of Hasher that attempts to leak as little data as possible.
+ * Each item in the hasher is represented by two (2) longs.  So this Hasher will
+ * still indicate how many items are in the hasher but will not leak the buffers
+ * that are being hashed as the @code DynamicHasher} does.
+ * <p>
+ * This hasher only accepts HashFunctions that are cyclic in nature.
+ * </p>
+ * @see DynamicHasher
+ * @see ProcessType
+ */
+public class CachingHasher implements Hasher {
+
+    /**
+     * The list of byte arrays that are to be hashed.
+     */
+    private final List<long[]> buffers;
+
+    /**
+     * The hash function identity
+     */
+    private final HashFunctionIdentity functionIdentity;
+
+    /**
+     * Constructs a CachingHasher from a list of arrays of hash values.
+     * <p>
+     * The list of hash values comprises a @code{List&lt;long[]&gt;} where each @code{long[]}
+     * is comprises two (2) values that are the result of hashing the original buffer.  Thus a
+     * CachingHasher that was built from five (5) buffers will have five arrays of two @code{longs}
+     * each.
+     * </p>
+     * @param functionIdentity The identity of the function.
+     * @param buffers          a list of @code{long} arrays comprising two (2) values.
+     * @throws IllegalArgumentException if the name does not indicate a cyclic
+     *                                  hashing function.
+     */
+    public CachingHasher(HashFunctionIdentity functionIdentity, List<long[]> buffers) {
+        this.functionIdentity = checkIdentity(functionIdentity);
+        this.buffers = new ArrayList<long[]>(buffers);
+    }
+
+    /**
+     * Constructs a CachingHasher from an array of arrys of hash values.
+     *
+     * @param functionIdentity The identity of the function.
+     * @param buffers          an array of @code{long} arrays comprising two (2) values.
+     * @throws IllegalArgumentException if the name does not indicate a cyclic
+     *                                  hashing function.
+     */
+    public CachingHasher(HashFunctionIdentity functionIdentity, long[][] buffers) {
+        this.functionIdentity = checkIdentity(functionIdentity);
+        this.buffers = Arrays.asList(buffers);
+    }
+
+    /**
+     * Checks that the name is valid for this hasher.
+     *
+     * @param functionIdentity the Function Identity to check.
+     */
+    private static HashFunctionIdentity checkIdentity(HashFunctionIdentity functionIdentity) {
+        if (functionIdentity.getProcessType() != ProcessType.CYCLIC) {
+            throw new IllegalArgumentException(""Only cyclic hash functions may be used in a caching hasher"");
+        }
+        return functionIdentity;
+    }
+
+    @Override
+    public HashFunctionIdentity getHashFunctionIdentity() {
+        return functionIdentity;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return buffers.isEmpty();
+    }
+
+
+    @Override
+    public PrimitiveIterator.OfInt getBits(Shape shape) {
+        HashFunctionValidator.checkAreEqual(getHashFunctionIdentity(),
+            shape.getHashFunctionIdentity());
+        return new IntIterator(shape);
+    }
+
+    /**
+     * Gets the long representations of the buffers.
+     * <p>","[{'comment': 'A bit more doc would help here, i.e. the List<long[]> will contains zero or more entries, each entry is a non-null array of length two containing the 64-bit pair output from the cyclic hash function.', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
131,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasher.java,"@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+
+import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType;
+
+/**
+ * An implementation of Hasher that attempts to leak as little data as possible.
+ * Each item in the hasher is represented by two (2) longs.  So this Hasher will
+ * still indicate how many items are in the hasher but will not leak the buffers
+ * that are being hashed as the @code DynamicHasher} does.
+ * <p>
+ * This hasher only accepts HashFunctions that are cyclic in nature.
+ * </p>
+ * @see DynamicHasher
+ * @see ProcessType
+ */
+public class CachingHasher implements Hasher {
+
+    /**
+     * The list of byte arrays that are to be hashed.
+     */
+    private final List<long[]> buffers;
+
+    /**
+     * The hash function identity
+     */
+    private final HashFunctionIdentity functionIdentity;
+
+    /**
+     * Constructs a CachingHasher from a list of arrays of hash values.
+     * <p>
+     * The list of hash values comprises a @code{List&lt;long[]&gt;} where each @code{long[]}
+     * is comprises two (2) values that are the result of hashing the original buffer.  Thus a
+     * CachingHasher that was built from five (5) buffers will have five arrays of two @code{longs}
+     * each.
+     * </p>
+     * @param functionIdentity The identity of the function.
+     * @param buffers          a list of @code{long} arrays comprising two (2) values.
+     * @throws IllegalArgumentException if the name does not indicate a cyclic
+     *                                  hashing function.
+     */
+    public CachingHasher(HashFunctionIdentity functionIdentity, List<long[]> buffers) {
+        this.functionIdentity = checkIdentity(functionIdentity);
+        this.buffers = new ArrayList<long[]>(buffers);
+    }
+
+    /**
+     * Constructs a CachingHasher from an array of arrys of hash values.
+     *
+     * @param functionIdentity The identity of the function.
+     * @param buffers          an array of @code{long} arrays comprising two (2) values.
+     * @throws IllegalArgumentException if the name does not indicate a cyclic
+     *                                  hashing function.
+     */
+    public CachingHasher(HashFunctionIdentity functionIdentity, long[][] buffers) {
+        this.functionIdentity = checkIdentity(functionIdentity);
+        this.buffers = Arrays.asList(buffers);
+    }
+
+    /**
+     * Checks that the name is valid for this hasher.
+     *
+     * @param functionIdentity the Function Identity to check.
+     */
+    private static HashFunctionIdentity checkIdentity(HashFunctionIdentity functionIdentity) {
+        if (functionIdentity.getProcessType() != ProcessType.CYCLIC) {
+            throw new IllegalArgumentException(""Only cyclic hash functions may be used in a caching hasher"");
+        }
+        return functionIdentity;
+    }
+
+    @Override
+    public HashFunctionIdentity getHashFunctionIdentity() {
+        return functionIdentity;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return buffers.isEmpty();
+    }
+
+
+    @Override
+    public PrimitiveIterator.OfInt getBits(Shape shape) {
+        HashFunctionValidator.checkAreEqual(getHashFunctionIdentity(),
+            shape.getHashFunctionIdentity());
+        return new IntIterator(shape);
+    }
+
+    /**
+     * Gets the long representations of the buffers.
+     * <p>
+     * This method returns the long representations of the buffers.  This is commonly used
+     * to transmit the Hasher from one system to another.
+     * </p>
+     * @return a copy if the long buffer representation.
+     */
+    public List<long[]> getBuffers() {
+        return new ArrayList<long[]>( buffers );
+    }
+
+    /**
+     * The iterator of integers.
+     */
+    private class IntIterator implements PrimitiveIterator.OfInt {
+        private int buffer = 0;
+        private int funcCount = 0;
+        private final Shape shape;
+        private long accumulator;
+
+        /**
+         * Creates iterator with the specified shape.
+         *
+         * @param shape
+         */
+        private IntIterator(Shape shape) {
+            this.shape = shape;
+            this.accumulator = buffers.isEmpty() ? 0 : buffers.get(0)[0];
+        }
+
+        @Override
+        public boolean hasNext() {
+            if (buffers.isEmpty()) {
+                return false;
+            }
+            return buffer < buffers.size() - 1 || funcCount < shape.getNumberOfHashFunctions();
+        }
+
+        @Override
+        public int nextInt() {
+            if (hasNext()) {
+                if (funcCount >= shape.getNumberOfHashFunctions()) {
+                    funcCount = 0;
+                    buffer++;
+                    accumulator = buffers.get(buffer)[0];
+                }
+                int result = (int) Math.floorMod(accumulator, (long) shape.getNumberOfBits());
+                funcCount++;
+                accumulator += buffers.get(buffer)[1];
+                return result;
+            }
+            throw new NoSuchElementException();
+        }
+
+    }
+
+    /**
+     * The builder for CachingHashers.
+     *
+     * @since 4.5
+     */
+    public static class Builder implements Hasher.Builder {
+        /**
+         * The list of byte[] that are to be hashed.
+         */
+        private List<byte[]> buffers;
+
+        /**
+         * The function that the resulting DynamicHasher will use.
+         */
+        private HashFunction function;
+
+        /**
+         * Constructs a CachingHashers builder.
+         *
+         * @param function the function implementation.
+         * @throws IllegalArgumentException if the function is not a cyclic implementation.
+         */
+        public Builder(HashFunction function) {
+            checkIdentity(function);
+            this.function = function;
+            this.buffers = new ArrayList<byte[]>();
+
+        }
+
+        /**
+         * Builds the hasher.
+         *
+         * @return A CachingHashers with the specified name, function and buffers.
+         */
+        @Override
+        public CachingHasher build() throws IllegalArgumentException {
+            List<long[]> cache = new ArrayList<long[]>();","[{'comment': 'use final', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
131,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasher.java,"@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+
+import org.apache.commons.collections4.bloomfilter.hasher.HashFunctionIdentity.ProcessType;
+
+/**
+ * An implementation of Hasher that attempts to leak as little data as possible.
+ * Each item in the hasher is represented by two (2) longs.  So this Hasher will
+ * still indicate how many items are in the hasher but will not leak the buffers
+ * that are being hashed as the @code DynamicHasher} does.
+ * <p>
+ * This hasher only accepts HashFunctions that are cyclic in nature.
+ * </p>
+ * @see DynamicHasher
+ * @see ProcessType
+ */
+public class CachingHasher implements Hasher {
+
+    /**
+     * The list of byte arrays that are to be hashed.
+     */
+    private final List<long[]> buffers;
+
+    /**
+     * The hash function identity
+     */
+    private final HashFunctionIdentity functionIdentity;
+
+    /**
+     * Constructs a CachingHasher from a list of arrays of hash values.
+     * <p>
+     * The list of hash values comprises a @code{List&lt;long[]&gt;} where each @code{long[]}
+     * is comprises two (2) values that are the result of hashing the original buffer.  Thus a
+     * CachingHasher that was built from five (5) buffers will have five arrays of two @code{longs}
+     * each.
+     * </p>
+     * @param functionIdentity The identity of the function.
+     * @param buffers          a list of @code{long} arrays comprising two (2) values.
+     * @throws IllegalArgumentException if the name does not indicate a cyclic
+     *                                  hashing function.
+     */
+    public CachingHasher(HashFunctionIdentity functionIdentity, List<long[]> buffers) {
+        this.functionIdentity = checkIdentity(functionIdentity);
+        this.buffers = new ArrayList<long[]>(buffers);
+    }
+
+    /**
+     * Constructs a CachingHasher from an array of arrys of hash values.
+     *
+     * @param functionIdentity The identity of the function.
+     * @param buffers          an array of @code{long} arrays comprising two (2) values.
+     * @throws IllegalArgumentException if the name does not indicate a cyclic
+     *                                  hashing function.
+     */
+    public CachingHasher(HashFunctionIdentity functionIdentity, long[][] buffers) {
+        this.functionIdentity = checkIdentity(functionIdentity);
+        this.buffers = Arrays.asList(buffers);
+    }
+
+    /**
+     * Checks that the name is valid for this hasher.
+     *
+     * @param functionIdentity the Function Identity to check.
+     */
+    private static HashFunctionIdentity checkIdentity(HashFunctionIdentity functionIdentity) {
+        if (functionIdentity.getProcessType() != ProcessType.CYCLIC) {
+            throw new IllegalArgumentException(""Only cyclic hash functions may be used in a caching hasher"");
+        }
+        return functionIdentity;
+    }
+
+    @Override
+    public HashFunctionIdentity getHashFunctionIdentity() {
+        return functionIdentity;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return buffers.isEmpty();
+    }
+
+
+    @Override
+    public PrimitiveIterator.OfInt getBits(Shape shape) {
+        HashFunctionValidator.checkAreEqual(getHashFunctionIdentity(),
+            shape.getHashFunctionIdentity());
+        return new IntIterator(shape);
+    }
+
+    /**
+     * Gets the long representations of the buffers.
+     * <p>
+     * This method returns the long representations of the buffers.  This is commonly used
+     * to transmit the Hasher from one system to another.
+     * </p>
+     * @return a copy if the long buffer representation.
+     */
+    public List<long[]> getBuffers() {
+        return new ArrayList<long[]>( buffers );
+    }
+
+    /**
+     * The iterator of integers.
+     */
+    private class IntIterator implements PrimitiveIterator.OfInt {
+        private int buffer = 0;
+        private int funcCount = 0;
+        private final Shape shape;
+        private long accumulator;
+
+        /**
+         * Creates iterator with the specified shape.
+         *
+         * @param shape
+         */
+        private IntIterator(Shape shape) {
+            this.shape = shape;
+            this.accumulator = buffers.isEmpty() ? 0 : buffers.get(0)[0];
+        }
+
+        @Override
+        public boolean hasNext() {
+            if (buffers.isEmpty()) {
+                return false;
+            }
+            return buffer < buffers.size() - 1 || funcCount < shape.getNumberOfHashFunctions();
+        }
+
+        @Override
+        public int nextInt() {
+            if (hasNext()) {
+                if (funcCount >= shape.getNumberOfHashFunctions()) {
+                    funcCount = 0;
+                    buffer++;
+                    accumulator = buffers.get(buffer)[0];
+                }
+                int result = (int) Math.floorMod(accumulator, (long) shape.getNumberOfBits());
+                funcCount++;
+                accumulator += buffers.get(buffer)[1];
+                return result;
+            }
+            throw new NoSuchElementException();
+        }
+
+    }
+
+    /**
+     * The builder for CachingHashers.
+     *
+     * @since 4.5
+     */
+    public static class Builder implements Hasher.Builder {
+        /**
+         * The list of byte[] that are to be hashed.
+         */
+        private List<byte[]> buffers;
+
+        /**
+         * The function that the resulting DynamicHasher will use.
+         */
+        private HashFunction function;
+
+        /**
+         * Constructs a CachingHashers builder.
+         *
+         * @param function the function implementation.
+         * @throws IllegalArgumentException if the function is not a cyclic implementation.
+         */
+        public Builder(HashFunction function) {
+            checkIdentity(function);
+            this.function = function;
+            this.buffers = new ArrayList<byte[]>();
+
+        }
+
+        /**
+         * Builds the hasher.
+         *
+         * @return A CachingHashers with the specified name, function and buffers.
+         */
+        @Override
+        public CachingHasher build() throws IllegalArgumentException {
+            List<long[]> cache = new ArrayList<long[]>();
+            for (byte[] buff : buffers) {
+                long[] result = new long[2];
+                result[0] = function.apply(buff, 0);
+                result[1] = function.apply(buff, 1) - result[0];
+                cache.add(result);
+            }
+            return new CachingHasher(function, cache);
+        }
+
+        @Override
+        public final Builder with(byte property) {
+            return with(new byte[] { property });
+        }
+
+        @Override
+        public final Builder with(byte[] property) {
+            buffers.add(property);
+            return this;
+        }
+
+        @Override
+        public final Builder with(String property) {
+            return with(property.getBytes(StandardCharsets.UTF_8));
+        }
+","[{'comment': 'Remove empty line', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
131,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/HashFunctionIdentityImpl.java,"@@ -51,7 +51,8 @@ public HashFunctionIdentityImpl(final HashFunctionIdentity identity) {
      * @param process the processes of the hash function.
      * @param signature the signature for the hash function.
      */
-    public HashFunctionIdentityImpl(final String provider, final String name, final Signedness signedness, final ProcessType process,
+    public HashFunctionIdentityImpl(final String provider, final String name, final Signedness signedness,","[{'comment': 'No need for the line wrap here. It is unrelated to the PR.', 'commenter': 'aherbert'}, {'comment': 'reversed ', 'commenter': 'Claudenw'}]"
131,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/HashFunctionValidator.java,"@@ -20,7 +20,7 @@
 /**
  * Contains validation for hash functions.
  */
-final class HashFunctionValidator {
+public final class HashFunctionValidator {","[{'comment': 'Why make this public here? That would fix it in the API. Currently it is only used internally.\r\n\r\n', 'commenter': 'aherbert'}, {'comment': 'reversed - unintended for this pull ', 'commenter': 'Claudenw'}]"
131,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasherBuilderTest.java,"@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import java.util.PrimitiveIterator.OfInt;
+
+import org.apache.commons.collections4.bloomfilter.hasher.function.MD5Cyclic;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * {@link CachingHasher.Builder} tests.
+ */
+public class CachingHasherBuilderTest {
+
+    private CachingHasher.Builder builder;
+    private final Shape shape = new Shape(new MD5Cyclic(), 1, Integer.MAX_VALUE, 1);
+
+    /**
+     * Tests that hashing a byte works as expected.
+     */
+    @Test
+    public void buildTest_byte() {
+        final CachingHasher hasher = builder.with((byte) 0x1).build();
+
+        final int expected = 1483089307;
+
+        final OfInt iter = hasher.getBits(shape);
+
+        assertTrue(iter.hasNext());
+        assertEquals(expected, iter.nextInt());
+        assertFalse(iter.hasNext());
+    }
+
+    /**
+     * Tests that hashing a byte array works as expected.
+     */
+    @Test
+    public void buildTest_byteArray() {
+        final CachingHasher hasher = builder.with(""Hello"".getBytes()).build();
+        final int expected = 1519797563;
+
+        final OfInt iter = hasher.getBits(shape);
+
+        assertTrue(iter.hasNext());
+        assertEquals(expected, iter.nextInt());
+        assertFalse(iter.hasNext());
+    }
+
+    /**
+     * Tests that an empty hasher works as expected.
+     */
+    @Test
+    public void buildTest_Empty() {
+        final CachingHasher hasher = builder.build();
+
+        final OfInt iter = hasher.getBits(shape);
+
+        assertFalse(iter.hasNext());
+    }
+
+    /**
+     * Tests that hashing a string works as expected.
+     */
+    @Test
+    public void buildTest_String() {
+        final CachingHasher hasher = builder.with(""Hello"").build();
+        final int expected = 1519797563;
+
+        final OfInt iter = hasher.getBits(shape);
+
+        assertTrue(iter.hasNext());
+        assertEquals(expected, iter.nextInt());
+        assertFalse(iter.hasNext());
+    }
+
+    /**
+     * Sets up the builder for testing.
+     */
+    @Before","[{'comment': 'Move this to the top of the test', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
131,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasherTest.java,"@@ -0,0 +1,241 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+import java.util.PrimitiveIterator.OfInt;
+
+import org.apache.commons.collections4.bloomfilter.hasher.function.MD5Cyclic;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Tests the {@link CachingHasher}.
+ */
+public class CachingHasherTest {
+    private CachingHasher.Builder builder;
+    private Shape shape;
+
+    private final HashFunctionIdentity testFunction = new HashFunctionIdentity() {
+
+        @Override
+        public String getName() {
+            return ""Test Function"";
+        }
+
+        @Override
+        public ProcessType getProcessType() {
+            return ProcessType.CYCLIC;
+        }
+
+        @Override
+        public String getProvider() {
+            return ""Apache Commons Collection Tests"";
+        }
+
+        @Override
+        public long getSignature() {
+            return 0;
+        }
+
+        @Override
+        public Signedness getSignedness() {
+            return Signedness.SIGNED;
+        }
+    };
+
+    /**
+     * Sets up the CachingHasher.
+     */
+    @Before
+    public void setup() {
+        builder = new CachingHasher.Builder(new MD5Cyclic());
+        shape = new Shape(new MD5Cyclic(), 3, 72, 17);
+    }
+
+    /**
+     * Tests that the expected bits are returned from hashing.
+     */
+    @Test
+    public void testGetBits() {
+","[{'comment': 'Empty line', 'commenter': 'aherbert'}]"
131,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasherTest.java,"@@ -0,0 +1,241 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+import java.util.PrimitiveIterator.OfInt;
+
+import org.apache.commons.collections4.bloomfilter.hasher.function.MD5Cyclic;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Tests the {@link CachingHasher}.
+ */
+public class CachingHasherTest {
+    private CachingHasher.Builder builder;
+    private Shape shape;
+
+    private final HashFunctionIdentity testFunction = new HashFunctionIdentity() {
+
+        @Override
+        public String getName() {
+            return ""Test Function"";
+        }
+
+        @Override
+        public ProcessType getProcessType() {
+            return ProcessType.CYCLIC;
+        }
+
+        @Override
+        public String getProvider() {
+            return ""Apache Commons Collection Tests"";
+        }
+
+        @Override
+        public long getSignature() {
+            return 0;
+        }
+
+        @Override
+        public Signedness getSignedness() {
+            return Signedness.SIGNED;
+        }
+    };
+
+    /**
+     * Sets up the CachingHasher.
+     */
+    @Before
+    public void setup() {
+        builder = new CachingHasher.Builder(new MD5Cyclic());
+        shape = new Shape(new MD5Cyclic(), 3, 72, 17);
+    }
+
+    /**
+     * Tests that the expected bits are returned from hashing.
+     */
+    @Test
+    public void testGetBits() {
+
+        final int[] expected = { 6, 69, 44, 19, 10, 57, 48, 23, 70, 61, 36, 11, 2, 49, 24, 15, 62 };
+
+        final Hasher hasher = builder.with(""Hello"").build();
+
+        final OfInt iter = hasher.getBits(shape);
+
+        for (final int element : expected) {
+            assertTrue(iter.hasNext());
+            assertEquals(element, iter.nextInt());
+        }
+        assertFalse(iter.hasNext());
+    }
+
+    /**
+     * Tests that bits from multiple hashes are returned correctly.
+     */
+    @Test
+    public void testGetBits_MultipleHashes() {
+        final int[] expected = { 6, 69, 44, 19, 10, 57, 48, 23, 70, 61, 36, 11, 2, 49, 24, 15, 62, 1, 63, 53, 43, 17, 7,
+                69, 59, 49, 39, 13, 3, 65, 55, 45, 35, 25 };
+
+        final Hasher hasher = builder.with(""Hello"").with(""World"").build();
+
+        final OfInt iter = hasher.getBits(shape);
+
+        for (final int element : expected) {
+            assertTrue(iter.hasNext());
+            assertEquals(element, iter.nextInt());
+        }
+        assertFalse(iter.hasNext());
+        try {
+            iter.next();
+            fail(""Should have thown NoSuchElementException"");
+        } catch (final NoSuchElementException ignore) {
+            // do nothing
+        }
+    }
+
+    /**
+     * Tests that retrieving bits for the wrong shape throws an exception.
+     */
+    @Test
+    public void testGetBits_WongShape() {
+
+        final Hasher hasher = builder.with(""Hello"").build();
+
+        try {
+            hasher.getBits(new Shape(testFunction, 3, 72, 17));
+            fail(""Should have thown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // do nothing
+        }
+    }
+
+    /**
+     * Tests if isEmpty() reports correctly and the iterator returns no values.
+     */
+    @Test
+    public void testIsEmpty() {
+        CachingHasher hasher = builder.build();
+        assertTrue(hasher.isEmpty());
+        final OfInt iter = hasher.getBits(shape);
+        assertFalse(iter.hasNext());
+        try {
+            iter.next();
+            fail(""Should have thown NoSuchElementException"");
+        } catch (final NoSuchElementException expected) {
+            // do nothing
+        }
+
+        assertFalse(builder.with(""Hello"").build().isEmpty());
+    }
+
+    @Test
+    public void testNonCyclicHashFunction() {
+        HashFunctionIdentity hfi = new HashFunctionIdentity() {","[{'comment': 'Cleaner to use HashFunctionIdentityImpl here.', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
131,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasherTest.java,"@@ -0,0 +1,241 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+import java.util.PrimitiveIterator.OfInt;
+
+import org.apache.commons.collections4.bloomfilter.hasher.function.MD5Cyclic;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Tests the {@link CachingHasher}.
+ */
+public class CachingHasherTest {
+    private CachingHasher.Builder builder;
+    private Shape shape;
+
+    private final HashFunctionIdentity testFunction = new HashFunctionIdentity() {","[{'comment': 'Cleaner to use HashFunctionIdentityImpl here.', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
131,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasherTest.java,"@@ -0,0 +1,241 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+import java.util.PrimitiveIterator.OfInt;
+
+import org.apache.commons.collections4.bloomfilter.hasher.function.MD5Cyclic;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Tests the {@link CachingHasher}.
+ */
+public class CachingHasherTest {
+    private CachingHasher.Builder builder;
+    private Shape shape;
+
+    private final HashFunctionIdentity testFunction = new HashFunctionIdentity() {
+
+        @Override
+        public String getName() {
+            return ""Test Function"";
+        }
+
+        @Override
+        public ProcessType getProcessType() {
+            return ProcessType.CYCLIC;
+        }
+
+        @Override
+        public String getProvider() {
+            return ""Apache Commons Collection Tests"";
+        }
+
+        @Override
+        public long getSignature() {
+            return 0;
+        }
+
+        @Override
+        public Signedness getSignedness() {
+            return Signedness.SIGNED;
+        }
+    };
+
+    /**
+     * Sets up the CachingHasher.
+     */
+    @Before
+    public void setup() {
+        builder = new CachingHasher.Builder(new MD5Cyclic());
+        shape = new Shape(new MD5Cyclic(), 3, 72, 17);
+    }
+
+    /**
+     * Tests that the expected bits are returned from hashing.
+     */
+    @Test
+    public void testGetBits() {
+
+        final int[] expected = { 6, 69, 44, 19, 10, 57, 48, 23, 70, 61, 36, 11, 2, 49, 24, 15, 62 };
+
+        final Hasher hasher = builder.with(""Hello"").build();
+
+        final OfInt iter = hasher.getBits(shape);
+
+        for (final int element : expected) {
+            assertTrue(iter.hasNext());
+            assertEquals(element, iter.nextInt());
+        }
+        assertFalse(iter.hasNext());
+    }
+
+    /**
+     * Tests that bits from multiple hashes are returned correctly.
+     */
+    @Test
+    public void testGetBits_MultipleHashes() {
+        final int[] expected = { 6, 69, 44, 19, 10, 57, 48, 23, 70, 61, 36, 11, 2, 49, 24, 15, 62, 1, 63, 53, 43, 17, 7,
+                69, 59, 49, 39, 13, 3, 65, 55, 45, 35, 25 };
+
+        final Hasher hasher = builder.with(""Hello"").with(""World"").build();
+
+        final OfInt iter = hasher.getBits(shape);
+
+        for (final int element : expected) {
+            assertTrue(iter.hasNext());
+            assertEquals(element, iter.nextInt());
+        }
+        assertFalse(iter.hasNext());
+        try {
+            iter.next();
+            fail(""Should have thown NoSuchElementException"");
+        } catch (final NoSuchElementException ignore) {
+            // do nothing
+        }
+    }
+
+    /**
+     * Tests that retrieving bits for the wrong shape throws an exception.
+     */
+    @Test
+    public void testGetBits_WongShape() {
+
+        final Hasher hasher = builder.with(""Hello"").build();
+
+        try {
+            hasher.getBits(new Shape(testFunction, 3, 72, 17));
+            fail(""Should have thown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // do nothing
+        }
+    }
+
+    /**
+     * Tests if isEmpty() reports correctly and the iterator returns no values.
+     */
+    @Test
+    public void testIsEmpty() {
+        CachingHasher hasher = builder.build();
+        assertTrue(hasher.isEmpty());
+        final OfInt iter = hasher.getBits(shape);
+        assertFalse(iter.hasNext());
+        try {
+            iter.next();
+            fail(""Should have thown NoSuchElementException"");
+        } catch (final NoSuchElementException expected) {
+            // do nothing
+        }
+
+        assertFalse(builder.with(""Hello"").build().isEmpty());
+    }
+
+    @Test
+    public void testNonCyclicHashFunction() {
+        HashFunctionIdentity hfi = new HashFunctionIdentity() {
+
+            @Override
+            public String getName() {
+                return ""Testing-NonCyclic-Hash"";
+            }
+
+            @Override
+            public ProcessType getProcessType() {
+                return ProcessType.ITERATIVE;
+            }
+
+            @Override
+            public String getProvider() {
+                return ""Apache Commons Collection Testing"";
+            }
+
+            @Override
+            public long getSignature() {
+                return 0;
+            }
+
+            @Override
+            public Signedness getSignedness() {
+                return Signedness.SIGNED;
+            }
+        };
+
+        try {
+            new CachingHasher(hfi, new long[][] { { 1, 4 }, { 3, 6 } });
+            fail(""Should have thrown exception"");
+        } catch (IllegalArgumentException expected) {
+            // do nothing.
+        }
+
+    }
+
+    @Test
+    public void testGetBuffers() {
+        final CachingHasher hasher = builder.with(""Hello"").build();
+
+        List<long[]> buffers = hasher.getBuffers();
+        HashFunctionIdentity id = hasher.getHashFunctionIdentity();
+
+        CachingHasher hasher2 = new CachingHasher( id, buffers );
+
+        PrimitiveIterator.OfInt iter1 = hasher.getBits(shape);
+        PrimitiveIterator.OfInt iter2 = hasher2.getBits(shape);
+
+        while (iter1.hasNext())","[{'comment': 'This should have failed checkstyle. Have you based on the current master?', 'commenter': 'aherbert'}]"
131,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasherTest.java,"@@ -0,0 +1,241 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+import java.util.PrimitiveIterator.OfInt;
+
+import org.apache.commons.collections4.bloomfilter.hasher.function.MD5Cyclic;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Tests the {@link CachingHasher}.
+ */
+public class CachingHasherTest {
+    private CachingHasher.Builder builder;
+    private Shape shape;
+
+    private final HashFunctionIdentity testFunction = new HashFunctionIdentity() {
+
+        @Override
+        public String getName() {
+            return ""Test Function"";
+        }
+
+        @Override
+        public ProcessType getProcessType() {
+            return ProcessType.CYCLIC;
+        }
+
+        @Override
+        public String getProvider() {
+            return ""Apache Commons Collection Tests"";
+        }
+
+        @Override
+        public long getSignature() {
+            return 0;
+        }
+
+        @Override
+        public Signedness getSignedness() {
+            return Signedness.SIGNED;
+        }
+    };
+
+    /**
+     * Sets up the CachingHasher.
+     */
+    @Before
+    public void setup() {
+        builder = new CachingHasher.Builder(new MD5Cyclic());
+        shape = new Shape(new MD5Cyclic(), 3, 72, 17);
+    }
+
+    /**
+     * Tests that the expected bits are returned from hashing.
+     */
+    @Test
+    public void testGetBits() {
+
+        final int[] expected = { 6, 69, 44, 19, 10, 57, 48, 23, 70, 61, 36, 11, 2, 49, 24, 15, 62 };
+
+        final Hasher hasher = builder.with(""Hello"").build();
+
+        final OfInt iter = hasher.getBits(shape);
+
+        for (final int element : expected) {
+            assertTrue(iter.hasNext());
+            assertEquals(element, iter.nextInt());
+        }
+        assertFalse(iter.hasNext());
+    }
+
+    /**
+     * Tests that bits from multiple hashes are returned correctly.
+     */
+    @Test
+    public void testGetBits_MultipleHashes() {
+        final int[] expected = { 6, 69, 44, 19, 10, 57, 48, 23, 70, 61, 36, 11, 2, 49, 24, 15, 62, 1, 63, 53, 43, 17, 7,
+                69, 59, 49, 39, 13, 3, 65, 55, 45, 35, 25 };
+
+        final Hasher hasher = builder.with(""Hello"").with(""World"").build();
+
+        final OfInt iter = hasher.getBits(shape);
+
+        for (final int element : expected) {
+            assertTrue(iter.hasNext());
+            assertEquals(element, iter.nextInt());
+        }
+        assertFalse(iter.hasNext());
+        try {
+            iter.next();
+            fail(""Should have thown NoSuchElementException"");
+        } catch (final NoSuchElementException ignore) {
+            // do nothing
+        }
+    }
+
+    /**
+     * Tests that retrieving bits for the wrong shape throws an exception.
+     */
+    @Test
+    public void testGetBits_WongShape() {
+
+        final Hasher hasher = builder.with(""Hello"").build();
+
+        try {
+            hasher.getBits(new Shape(testFunction, 3, 72, 17));
+            fail(""Should have thown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // do nothing
+        }
+    }
+
+    /**
+     * Tests if isEmpty() reports correctly and the iterator returns no values.
+     */
+    @Test
+    public void testIsEmpty() {
+        CachingHasher hasher = builder.build();
+        assertTrue(hasher.isEmpty());
+        final OfInt iter = hasher.getBits(shape);
+        assertFalse(iter.hasNext());
+        try {
+            iter.next();
+            fail(""Should have thown NoSuchElementException"");
+        } catch (final NoSuchElementException expected) {
+            // do nothing
+        }
+
+        assertFalse(builder.with(""Hello"").build().isEmpty());
+    }
+
+    @Test
+    public void testNonCyclicHashFunction() {
+        HashFunctionIdentity hfi = new HashFunctionIdentity() {
+
+            @Override
+            public String getName() {
+                return ""Testing-NonCyclic-Hash"";
+            }
+
+            @Override
+            public ProcessType getProcessType() {
+                return ProcessType.ITERATIVE;
+            }
+
+            @Override
+            public String getProvider() {
+                return ""Apache Commons Collection Testing"";
+            }
+
+            @Override
+            public long getSignature() {
+                return 0;
+            }
+
+            @Override
+            public Signedness getSignedness() {
+                return Signedness.SIGNED;
+            }
+        };
+
+        try {
+            new CachingHasher(hfi, new long[][] { { 1, 4 }, { 3, 6 } });
+            fail(""Should have thrown exception"");
+        } catch (IllegalArgumentException expected) {
+            // do nothing.
+        }
+
+    }
+
+    @Test
+    public void testGetBuffers() {
+        final CachingHasher hasher = builder.with(""Hello"").build();
+
+        List<long[]> buffers = hasher.getBuffers();
+        HashFunctionIdentity id = hasher.getHashFunctionIdentity();
+
+        CachingHasher hasher2 = new CachingHasher( id, buffers );
+
+        PrimitiveIterator.OfInt iter1 = hasher.getBits(shape);
+        PrimitiveIterator.OfInt iter2 = hasher2.getBits(shape);
+
+        while (iter1.hasNext())
+        {
+            assertTrue( ""Too few values in second hasher"", iter2.hasNext());
+            assertEquals( ""Wrong value"", iter1.next(), iter2.next() );
+        }
+        assertFalse( ""Second hasher has too many values"", iter2.hasNext());
+    }
+
+    @Test
+    public void testConstructorWithLongArray() {
+        final CachingHasher hasher = builder.with(""Hello"").build();
+
+        List<long[]> buffers = hasher.getBuffers();
+        assertEquals( 1, buffers.size() );
+
+        long[][] ary = new long[1][];
+        ary[0] = buffers.get(0);
+
+        HashFunctionIdentity id = hasher.getHashFunctionIdentity();
+
+
+        CachingHasher hasher2 = new CachingHasher( id, ary );
+
+        PrimitiveIterator.OfInt iter1 = hasher.getBits(shape);
+        PrimitiveIterator.OfInt iter2 = hasher2.getBits(shape);
+
+        while (iter1.hasNext())
+        {","[{'comment': 'Another `{` on the wrong line', 'commenter': 'aherbert'}]"
131,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/CachingHasherTest.java,"@@ -0,0 +1,241 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.PrimitiveIterator;
+import java.util.PrimitiveIterator.OfInt;
+
+import org.apache.commons.collections4.bloomfilter.hasher.function.MD5Cyclic;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Tests the {@link CachingHasher}.
+ */
+public class CachingHasherTest {
+    private CachingHasher.Builder builder;
+    private Shape shape;
+
+    private final HashFunctionIdentity testFunction = new HashFunctionIdentity() {
+
+        @Override
+        public String getName() {
+            return ""Test Function"";
+        }
+
+        @Override
+        public ProcessType getProcessType() {
+            return ProcessType.CYCLIC;
+        }
+
+        @Override
+        public String getProvider() {
+            return ""Apache Commons Collection Tests"";
+        }
+
+        @Override
+        public long getSignature() {
+            return 0;
+        }
+
+        @Override
+        public Signedness getSignedness() {
+            return Signedness.SIGNED;
+        }
+    };
+
+    /**
+     * Sets up the CachingHasher.
+     */
+    @Before
+    public void setup() {
+        builder = new CachingHasher.Builder(new MD5Cyclic());
+        shape = new Shape(new MD5Cyclic(), 3, 72, 17);
+    }
+
+    /**
+     * Tests that the expected bits are returned from hashing.
+     */
+    @Test
+    public void testGetBits() {
+
+        final int[] expected = { 6, 69, 44, 19, 10, 57, 48, 23, 70, 61, 36, 11, 2, 49, 24, 15, 62 };
+
+        final Hasher hasher = builder.with(""Hello"").build();
+
+        final OfInt iter = hasher.getBits(shape);
+
+        for (final int element : expected) {
+            assertTrue(iter.hasNext());
+            assertEquals(element, iter.nextInt());
+        }
+        assertFalse(iter.hasNext());
+    }
+
+    /**
+     * Tests that bits from multiple hashes are returned correctly.
+     */
+    @Test
+    public void testGetBits_MultipleHashes() {
+        final int[] expected = { 6, 69, 44, 19, 10, 57, 48, 23, 70, 61, 36, 11, 2, 49, 24, 15, 62, 1, 63, 53, 43, 17, 7,
+                69, 59, 49, 39, 13, 3, 65, 55, 45, 35, 25 };
+
+        final Hasher hasher = builder.with(""Hello"").with(""World"").build();
+
+        final OfInt iter = hasher.getBits(shape);
+
+        for (final int element : expected) {
+            assertTrue(iter.hasNext());
+            assertEquals(element, iter.nextInt());
+        }
+        assertFalse(iter.hasNext());
+        try {
+            iter.next();
+            fail(""Should have thown NoSuchElementException"");
+        } catch (final NoSuchElementException ignore) {
+            // do nothing
+        }
+    }
+
+    /**
+     * Tests that retrieving bits for the wrong shape throws an exception.
+     */
+    @Test
+    public void testGetBits_WongShape() {
+","[{'comment': 'empty line', 'commenter': 'aherbert'}]"
144,src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java,"@@ -497,7 +494,7 @@ public boolean remove(final Object key) {
         protected boolean canRemove = false;
 
         /**
-         * Constructor.
+         * Constructor a KeySetIterator of the BidiMap","[{'comment': '""Constructor of a"" or ""Constructs a"" would sound better I think.\r\n\r\nHowever, I think just ""Constructor"" is much simpler/easier to maintain (ditto for the other similar changes in this PR)', 'commenter': 'kinow'}, {'comment': '""Constructor."" or ""Constructs a new instance."" is a good place holder comment, otherwise, you can describe what kind of initialization takes place.\r\n', 'commenter': 'garydgregory'}]"
144,src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java,"@@ -620,7 +617,7 @@ public void remove() {
         private static final long serialVersionUID = 4040410962603292348L;
 
         /**
-         * Constructs a new view of the BidiMap.
+         * Constructs a new view of the BidiMap","[{'comment': 'I think we have some other statements in the code base that end in a period. Any specific reason to remove them? If not, I think it would be simpler to just leave them as-is.', 'commenter': 'kinow'}, {'comment': '-1: A sentence ends with a period.\r\n', 'commenter': 'garydgregory'}]"
144,src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java,"@@ -452,7 +449,7 @@ public void clear() {
         private static final long serialVersionUID = -7107935777385040694L;
 
         /**
-         * Constructs a new view of the BidiMap.
+         * Constructs a new KeySet of the BidiMap","[{'comment': 'I think the view it referred to was more in an abstract way, but I think it should be fine to be specific and mention the `KeySet` type here.', 'commenter': 'kinow'}]"
144,src/main/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMap.java,"@@ -26,9 +26,9 @@
 import org.apache.commons.collections4.BidiMap;
 
 /**
- * Implementation of {@code BidiMap} that uses two {@code LinkedHashMap} instances.
+ * Implementation of {@link BidiMap} that uses two {@link LinkedHashMap} instances.","[{'comment': 'This might have been intentional? Some people prefer to avoid adding too many links in the Javadoc (forgot where I saw a presentation about that, but it was in some guide for writing Javadocs where the author mentioned to keep the number of links low, so users are not distracted).', 'commenter': 'kinow'}, {'comment': ""That's silly IMO, these links are fine.\r\n"", 'commenter': 'garydgregory'}, {'comment': 'I found the document I mentioned earlier. It was not exactly a presentation, but the Oracle docs for javadocs: https://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#styleguide (where it says ""Use in-line links economically""). There\'s also a similar style guide in UI/UX, to avoid cluttering user interfaces. However, I\'m fine whichever way :+1: ', 'commenter': 'kinow'}]"
144,src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java,"@@ -782,7 +782,7 @@ private static boolean isBlack(final Node<?, ?> node, final DataElement dataElem
     }
 
     /**
-     * force a node (if it exists) red
+     * Force a node (if it exists) red.","[{'comment': 'If a method starts with ""make..."", it usually reads better to start the Javadoc with ""Makes..."" IMO, It\'s confusing to have the Javadoc be different, otherwise you could say that all method that start with ""set..."" also ""forces"" a value.', 'commenter': 'garydgregory'}]"
144,src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java,"@@ -1130,7 +1130,7 @@ private void doRedBlackDeleteFixup(final Node<K, V> replacementNode, final DataE
     }
 
     /**
-     * swap two nodes (except for their content), taking care of
+     * Swap two nodes (except for their content), taking care of","[{'comment': '""Swap"" -> ""Swaps""', 'commenter': 'garydgregory'}]"
144,src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java,"@@ -1230,8 +1230,8 @@ private void swapPosition(final Node<K, V> x, final Node<K, V> y, final DataElem
     }
 
     /**
-     * check if an object is fit to be proper input ... has to be
-     * Comparable and non-null
+     * Check if an object is fit to be proper input ... has to be","[{'comment': '""Check"" -> ""Checks""', 'commenter': 'garydgregory'}]"
160,src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java,"@@ -0,0 +1,127 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.function.Function;
+
+import org.apache.commons.collections4.bloomfilter.hasher.DynamicHasher;
+import org.apache.commons.collections4.bloomfilter.hasher.Hasher;
+import org.apache.commons.collections4.bloomfilter.hasher.Shape;
+import org.apache.commons.collections4.bloomfilter.hasher.function.Murmur128x64Cyclic;
+
+/**
+ * A bloom filter that uses a BitSetBloomFilter to create a Bloom filter that
+ * can merge instances of a specific class.
+ *
+ * @param <T> The Class to merge.
+ * @since 4.5
+ */
+public class SimpleBloomFilter<T> extends BitSetBloomFilter implements BloomFilter {
+
+    /**
+     * The function that converts the instance of T to the SimpleBuilder.
+     * <p>
+     * If the object T is to be considered as a single item in the filter then
+     * function must create the {@code SimpleBuilder} and only call a single {@code with()}
+     * method.</p>
+     * <p>
+     * If the object T is to be considered as several items then the function must
+     * create the {@code SimpleBuilder} and call the {@code with()} method once for each item.</p>
+     */
+    private Function<T, SimpleBuilder> func;
+
+    /**
+     * Constructs a SimpleBloomFilter from the shape and function.  This constructor
+     * creates an empty Bloom filter.
+     * @param hasher the Hasher to use.
+     * @param shape the Shape of the Bloom filter.
+     * @param func a Function to convert T to a SimpleBuilder.
+     * @see #func
+     */
+    public SimpleBloomFilter(Hasher hasher, Shape shape, Function<T, SimpleBuilder> func) {
+        super(hasher, shape);
+        this.func = func;
+    }
+
+    /**
+     * Constructs a SimpleBloomFilter from the shape and function.  This constructor
+     * creates an empty Bloom filter.
+     * @param shape the Shape of the Bloom filter.
+     * @param func a Function to convert T to a SimpleBuilder.
+     * @see #func
+     */
+    public SimpleBloomFilter(Shape shape, Function<T, SimpleBuilder> func) {
+        super(shape);
+        this.func = func;
+    }
+
+    /**
+     * Constructs a SimpleBloomFilter from the shape, function and a data object.
+     * This constructor creates an Bloom filter populated with the data from the
+     * {@code data} parameter.
+     * @param shape the Shape of the Bloom filter.
+     * @param func a Function to convert T to a SimpleBuilder.
+     * @param data the data object to populate the filter with.
+     * @see #func
+     */
+    public SimpleBloomFilter(Shape shape, Function<T, SimpleBuilder> func, T data) {
+        this(shape, func);
+        this.merge( data );
+    }
+
+    /**
+     * Merges a data object into this filter.
+     *
+     * <p>Note: This method should return {@code true} even if no additional bit indexes were
+     * enabled. A {@code false} result indicates that this filter is not ensured to contain
+     * the {@code data}.
+     *
+     * @param data the data to merge.
+     * @return true if the merge was successful
+     * @throws IllegalArgumentException if the shape of the other filter does not match
+     * the shape of this filter
+     */
+    public boolean merge( T data ) {
+        return this.merge( this.func.apply( data ).build() );
+    }
+
+
+    /**
+     * Returns {@code true} if this filter contains the object.
+     * Specifically this returns {@code true} if this filter is enabled for all bit indexes
+     * identified by the hashing of the object {@code data}.
+     *
+     * @param data the data to check for.
+     * @return true if this filter is enabled for all bits specified by the data object.
+     */
+    public boolean contains( T data ) {
+        return this.contains( this.func.apply( data ).build() );
+    }","[{'comment': 'The `merge` and `contains` functions look much simpler for the caller user :+1: ', 'commenter': 'kinow'}]"
160,src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java,"@@ -0,0 +1,127 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.function.Function;
+
+import org.apache.commons.collections4.bloomfilter.hasher.DynamicHasher;
+import org.apache.commons.collections4.bloomfilter.hasher.Hasher;
+import org.apache.commons.collections4.bloomfilter.hasher.Shape;
+import org.apache.commons.collections4.bloomfilter.hasher.function.Murmur128x64Cyclic;
+
+/**
+ * A bloom filter that uses a BitSetBloomFilter to create a Bloom filter that
+ * can merge instances of a specific class.
+ *
+ * @param <T> The Class to merge.
+ * @since 4.5
+ */
+public class SimpleBloomFilter<T> extends BitSetBloomFilter implements BloomFilter {
+
+    /**
+     * The function that converts the instance of T to the SimpleBuilder.
+     * <p>
+     * If the object T is to be considered as a single item in the filter then
+     * function must create the {@code SimpleBuilder} and only call a single {@code with()}
+     * method.</p>
+     * <p>
+     * If the object T is to be considered as several items then the function must
+     * create the {@code SimpleBuilder} and call the {@code with()} method once for each item.</p>
+     */
+    private Function<T, SimpleBuilder> func;
+
+    /**
+     * Constructs a SimpleBloomFilter from the shape and function.  This constructor
+     * creates an empty Bloom filter.
+     * @param hasher the Hasher to use.
+     * @param shape the Shape of the Bloom filter.
+     * @param func a Function to convert T to a SimpleBuilder.
+     * @see #func
+     */
+    public SimpleBloomFilter(Hasher hasher, Shape shape, Function<T, SimpleBuilder> func) {
+        super(hasher, shape);
+        this.func = func;
+    }
+
+    /**
+     * Constructs a SimpleBloomFilter from the shape and function.  This constructor
+     * creates an empty Bloom filter.
+     * @param shape the Shape of the Bloom filter.
+     * @param func a Function to convert T to a SimpleBuilder.
+     * @see #func
+     */
+    public SimpleBloomFilter(Shape shape, Function<T, SimpleBuilder> func) {
+        super(shape);
+        this.func = func;
+    }
+
+    /**
+     * Constructs a SimpleBloomFilter from the shape, function and a data object.
+     * This constructor creates an Bloom filter populated with the data from the
+     * {@code data} parameter.
+     * @param shape the Shape of the Bloom filter.
+     * @param func a Function to convert T to a SimpleBuilder.
+     * @param data the data object to populate the filter with.
+     * @see #func","[{'comment': ""#TodayILeaned. Didn't know we could link with the object :+1: "", 'commenter': 'kinow'}, {'comment': 'Just ran this locally on Java 8: `mvn javadoc:javadoc`\r\n\r\nWhen browsing the output the link for `func` does nothing. So it appears even though you can build the javadoc this will not generate documentation from the private field.\r\n\r\nDoing the same on Java 14 and the `func` listed under `See Also:` is not a link. It may be that this should be a javadoc error but the maven plugin is not set up to flag it, or it may just not be reported as an error. \r\n\r\nCurrently the intention to bring the documentation from the private field is not being realised. So this class should be rewritten to move this javadoc somewhere public.\r\n', 'commenter': 'aherbert'}]"
160,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/HasherBuilderTest.java,"@@ -108,4 +110,156 @@ static String getExtendedString() {
         };
         return String.valueOf(data);
     }
+
+    /**
+     * Test that adding an integer into the hasher works correctly
+     */
+    @Test
+    public void withIntTest() {
+        TestBuilder builder = new TestBuilder();
+        Integer[] values = { Integer.valueOf(0), Integer.MAX_VALUE, Integer.MIN_VALUE };
+        for (int i : values) {
+            builder.with(i);
+        }
+
+        for (int i = 0; i < values.length; i++) {
+            Assert.assertArrayEquals(ByteBuffer.allocate(Integer.BYTES).putInt(values[i]).array(),
+                    builder.items.get(i));
+        }
+    }
+
+    /**
+     * Test that adding a long into the hasher works correctly
+     */
+    @Test
+    public void withLongTest() {
+        TestBuilder builder = new TestBuilder();
+        Long[] values = { Long.valueOf(0), Long.MAX_VALUE, Long.MIN_VALUE };
+        for (long l : values) {
+            builder.with(l);
+        }
+
+        for (int i = 0; i < values.length; i++) {
+            Assert.assertArrayEquals(ByteBuffer.allocate(Long.BYTES).putLong(values[i]).array(), builder.items.get(i));
+        }
+    }
+
+    /**
+     * Test that adding a double into the hasher works correctly
+     */
+    @Test
+    public void withDoubleTest() {
+        TestBuilder builder = new TestBuilder();
+        Double[] values = { Double.valueOf(0.0), Double.MAX_VALUE, Double.MIN_VALUE, Double.MIN_NORMAL,
+            Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.NaN };
+        for (double d : values) {
+            builder.with(d);
+        }
+
+        for (int i = 0; i < values.length; i++) {
+            Assert.assertArrayEquals(ByteBuffer.allocate(Double.BYTES).putDouble(values[i]).array(),
+                    builder.items.get(i));
+        }
+    }
+
+    /**
+     * Test that adding a float into the hasher works correctly
+     */
+    @Test
+    public void withFloatTest() {
+        TestBuilder builder = new TestBuilder();
+        Float[] values = { Float.valueOf(0.0f), Float.MAX_VALUE, Float.MIN_VALUE, Float.MIN_NORMAL,
+            Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, Float.NaN };
+        for (float f : values) {
+            builder.with(f);
+        }
+
+        for (int i = 0; i < values.length; i++) {
+            Assert.assertArrayEquals(ByteBuffer.allocate(Float.BYTES).putFloat(values[i]).array(),
+                    builder.items.get(i));
+        }
+    }
+
+    /**
+     * Test that adding a character into the hasher works correctly
+     */
+    @Test
+    public void withCharTest() {
+        TestBuilder builder = new TestBuilder();
+        Character[] values = { Character.valueOf((char) 0), Character.MAX_HIGH_SURROGATE, Character.MAX_LOW_SURROGATE,
+            Character.MAX_SURROGATE, Character.MAX_VALUE, Character.MIN_HIGH_SURROGATE, Character.MIN_LOW_SURROGATE,
+            Character.MIN_SURROGATE, Character.MIN_VALUE };
+        for (char c : values) {
+            builder.with(c);
+        }
+
+        for (int i = 0; i < values.length; i++) {
+            Assert.assertArrayEquals(ByteBuffer.allocate(Character.BYTES).putChar(values[i]).array(),
+                    builder.items.get(i));
+        }
+    }
+
+    /**
+     * Test that adding a short into the hasher works correctly
+     */
+    @Test
+    public void withShortTest() {
+        TestBuilder builder = new TestBuilder();
+        Short[] values = { Short.valueOf((short) 0), Short.MAX_VALUE, Short.MIN_VALUE };
+        for (short s : values) {
+            builder.with(s);
+        }
+
+        for (int i = 0; i < values.length; i++) {
+            Assert.assertArrayEquals(ByteBuffer.allocate(Short.BYTES).putShort(values[i]).array(),
+                    builder.items.get(i));
+        }
+    }
+
+    /**
+     * Test that adding a BigInteger into the hasher works correctly
+     */
+    @Test
+    public void withBigIngeterTest() {
+        TestBuilder builder = new TestBuilder();
+        BigInteger[] values = { BigInteger.ZERO, BigInteger.ONE, BigInteger.TWO, BigInteger.TEN,","[{'comment': ""@Claudenw it looks like `.TWO` is private in Java 8, only `ONE, `TEN`, `ZERO` are available: https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html\r\n\r\nThere's an error in the Java 8 build in Travis."", 'commenter': 'kinow'}]"
160,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/Hasher.java,"@@ -103,6 +108,95 @@ default Builder withUnencoded(CharSequence item) {
             }
             return with(bytes);
         }
+
+        /**
+         * Adds an integer into the hasher.  The integer is converted into 4 bytes
+         * through the use of ByteBuffer.putInt.
+         * @param data the integer to add.
+         * @return a reference to this object
+         * @see ByteBuffer#putInt
+         */
+        default B with(int data) {
+            return with( ByteBuffer.allocate(Integer.BYTES).putInt( data ).array());
+        }
+
+        /**
+         * Adds a long into the hasher.  The long is converted into 8 bytes
+         * through the use of ByteBuffer.putLong.
+         * @param data the long to add.
+         * @return a reference to this object
+         * @see ByteBuffer#putLong
+         */
+        default B with(long data) {
+            return with( ByteBuffer.allocate(Long.BYTES).putLong( data ).array());
+        }
+
+        /**
+         * Adds a double into the hasher.  The double is converted into 8 bytes
+         * through the use of ByteBuffer.putDouble.
+         * @param data the double to add.
+         * @return a reference to this object
+         * @see ByteBuffer#putDouble
+         */
+        default B with(double data) {
+            return with( ByteBuffer.allocate(Double.BYTES).putDouble( data ).array());
+        }
+
+        /**
+         * Adds a float into the hasher.  The float is converted into 4 bytes
+         * through the use of ByteBuffer.putFloat.
+         * @param data the float to add.
+         * @return a reference to this object
+         * @see ByteBuffer#putFloat
+         */
+        default B with(float data) {
+            return with( ByteBuffer.allocate(Float.BYTES).putFloat( data ).array());
+        }
+
+        /**
+         * Adds a char into the hasher.  The char is converted into 2 bytes
+         * through the use of ByteBuffer.putChar.
+         * @param data the char to add.
+         * @return a reference to this object
+         * @see ByteBuffer#putChar
+         */
+        default  B with(char data) {
+            return with( ByteBuffer.allocate(Character.BYTES).putChar( data ).array());
+        }
+
+        /**
+         * Adds a short into the hasher.  The short is converted into 2 bytes
+         * through the use of ByteBuffer.putShort.
+         * @param data the short to add.
+         * @return a reference to this object
+         * @see ByteBuffer#putShort
+         */
+        default B with(short data) {
+            return with( ByteBuffer.allocate(Short.BYTES).putShort( data ).array());
+        }
+
+        /**
+         * Adds a BigInteger into the hasher.
+         * @param data the BigInteger to add.
+         * @return a reference to this object
+         */
+        default B with(BigInteger data) {
+            return with( data.toByteArray() );
+        }
+
+        /**
+         * Adds a BigDecimal into the hasher.
+         * The scale of the BigDecimal is placed in the buffer followed by the
+         * byte array for the unscaled value.
+         * @param data the BigDecimal to add.
+         * @return a reference to this object
+         */
+        default B with(BigDecimal data) {
+            byte[] value = data.unscaledValue().toByteArray();
+            return with( ByteBuffer.allocate( Integer.BYTES+value.length )","[{'comment': 'return with( ByteBuffer.allocate( Integer.BYTES + value.length )', 'commenter': 'dota17'}]"
160,src/test/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilterMultipleItemTest.java,"@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.function.Function;
+
+import org.apache.commons.collections4.bloomfilter.SimpleBloomFilter.SimpleBuilder;
+import org.apache.commons.collections4.bloomfilter.SimpleBloomFilterTest.TypedObject;
+import org.apache.commons.collections4.bloomfilter.hasher.DynamicHasher;
+import org.apache.commons.collections4.bloomfilter.hasher.Hasher;
+import org.apache.commons.collections4.bloomfilter.hasher.Shape;
+import org.apache.commons.collections4.bloomfilter.hasher.function.Murmur128x64Cyclic;
+import org.junit.Assert;
+import org.junit.Test;
+
+/**
+ * Tests for the {@link SimpleBloomFilter} when T represents a single
+ * item in the filter.
+ */
+public class SimpleBloomFilterMultipleItemTest extends AbstractBloomFilterTest {
+
+    public SimpleBloomFilterMultipleItemTest() {
+        shape = new Shape( new Murmur128x64Cyclic(), 3, 72, 17);
+    }
+
+    protected Function<TypedObject, SimpleBuilder> getFunc() {
+        return new Function<TypedObject, SimpleBuilder>(){
+
+            @Override
+            public SimpleBuilder apply(TypedObject t) {
+                return (SimpleBuilder) new SimpleBuilder()
+                        .withUnencoded( t.hello)
+                        .withUnencoded( t.world );
+
+            }};
+    }
+
+    @Override
+    protected SimpleBloomFilter<TypedObject> createEmptyFilter(final Shape shape) {
+        return new SimpleBloomFilter<TypedObject>(shape, getFunc());
+    }
+
+    @Override
+    protected SimpleBloomFilter<TypedObject> createFilter(final Hasher hasher, final Shape shape) {
+        return new SimpleBloomFilter<TypedObject>(hasher, shape, getFunc());
+    }
+
+    /**
+     * Tests that adding {@code TypedObject} adds as multiple items.
+     */
+    @Test
+    public void mergeTTest() {
+        SimpleBloomFilter<TypedObject> bloomFilter = createEmptyFilter( shape );
+        bloomFilter.merge( new TypedObject() );
+
+        Hasher hasher = new DynamicHasher.Builder(new Murmur128x64Cyclic() )
+                .withUnencoded(""hello"")
+                .withUnencoded(""world"").build();
+
+        BloomFilter other = new BitSetBloomFilter( hasher, shape );
+        Assert.assertArrayEquals( other.getBits(), bloomFilter.getBits() );
+
+    }
+
+
+    /**
+     * Tests that contains {@code TypedObject} works as expected.
+     */
+    @Test
+    public void containsTTest() {
+        SimpleBloomFilter<TypedObject> bloomFilter = createEmptyFilter( shape );
+        bloomFilter.merge( new TypedObject() );
+
+        TypedObject t = new TypedObject();
+
+        Assert.assertTrue( bloomFilter.contains(t));
+
+        t.hello=""hola"";","[{'comment': 't.hello = ""hola"";', 'commenter': 'dota17'}]"
160,src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java,"@@ -0,0 +1,127 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.function.Function;
+
+import org.apache.commons.collections4.bloomfilter.hasher.DynamicHasher;
+import org.apache.commons.collections4.bloomfilter.hasher.Hasher;
+import org.apache.commons.collections4.bloomfilter.hasher.Shape;
+import org.apache.commons.collections4.bloomfilter.hasher.function.Murmur128x64Cyclic;
+
+/**
+ * A bloom filter that uses a BitSetBloomFilter to create a Bloom filter that
+ * can merge instances of a specific class.
+ *
+ * @param <T> The Class to merge.
+ * @since 4.5
+ */
+public class SimpleBloomFilter<T> extends BitSetBloomFilter implements BloomFilter {
+
+    /**
+     * The function that converts the instance of T to the SimpleBuilder.
+     * <p>
+     * If the object T is to be considered as a single item in the filter then
+     * function must create the {@code SimpleBuilder} and only call a single {@code with()}
+     * method.</p>
+     * <p>
+     * If the object T is to be considered as several items then the function must
+     * create the {@code SimpleBuilder} and call the {@code with()} method once for each item.</p>
+     */
+    private Function<T, SimpleBuilder> func;
+
+    /**
+     * Constructs a SimpleBloomFilter from the shape and function.  This constructor
+     * creates an empty Bloom filter.
+     * @param hasher the Hasher to use.
+     * @param shape the Shape of the Bloom filter.
+     * @param func a Function to convert T to a SimpleBuilder.
+     * @see #func
+     */
+    public SimpleBloomFilter(Hasher hasher, Shape shape, Function<T, SimpleBuilder> func) {
+        super(hasher, shape);
+        this.func = func;
+    }
+
+    /**
+     * Constructs a SimpleBloomFilter from the shape and function.  This constructor
+     * creates an empty Bloom filter.
+     * @param shape the Shape of the Bloom filter.
+     * @param func a Function to convert T to a SimpleBuilder.
+     * @see #func
+     */
+    public SimpleBloomFilter(Shape shape, Function<T, SimpleBuilder> func) {
+        super(shape);
+        this.func = func;
+    }
+
+    /**
+     * Constructs a SimpleBloomFilter from the shape, function and a data object.
+     * This constructor creates an Bloom filter populated with the data from the
+     * {@code data} parameter.
+     * @param shape the Shape of the Bloom filter.
+     * @param func a Function to convert T to a SimpleBuilder.
+     * @param data the data object to populate the filter with.
+     * @see #func
+     */
+    public SimpleBloomFilter(Shape shape, Function<T, SimpleBuilder> func, T data) {
+        this(shape, func);
+        this.merge( data );","[{'comment': 'No extra spaces please: `this.merge( data );` -> `this.merge(data);`', 'commenter': 'garydgregory'}, {'comment': 'As before, creating a filter and adding data are two separate functions. E.g. there is no constructor for an ArrayList that accepts a single item as well as the capacity. \r\n\r\nThis concept is better removed or changed to create a filter with another Bloom filter (i.e. a collection). Here this highlights the dual functionality of the Shape which specifies not only the number of hash functions per item but also contains the number of expected items which is not strictly necessary for the filter to function. Creating from another Bloom filter can copy the other filter shape (indeed it mush match hash function identity and number of hash functions) but what would be the expected number of items?\r\n', 'commenter': 'aherbert'}, {'comment': ""The purpose of the SimpleBloomFilter was to provide a class that is simple to use and works for a great many users.  It is, in some ways, patterned after the Guava Bloom filter implementation.\r\n\r\nThe goal is to construct a Bloom filter that accepts objects of type T.  So there is a `merge( T )` and a `contains( T )` method.\r\n\r\nWhether or not there is a constructor for an ArrayList that accepts a single item as well as a capacity is immaterial here.  By definition the Bloom filter has a concept of the number of items that will be added.  That concept is mathematically tied to other factors such as the number of hash functions for each item, the number of bits, and the probability of false positives.  Yes the shape has all 4 values.  No, you don't need all 4 values all the time. But, they are mathematically bound together and so make sense to be represented as the Shape.\r\n\r\nThis constructor is simply a short hand for `new SimpleBloomFilter(Shape shape, Function<T, SimpleBuilder> func).merge( T )` and does not restrict the user from creating another BloomFilter and merging it with this one.\r\n\r\nIf you are asking for another constructor that takes an existing BloomFilter as a parameter to provide the shape and an initial data load, that could be provided, but is not a reason not to have this constructor.  Is that what you are asking for?\r\n\r\n\r\n "", 'commenter': 'Claudenw'}, {'comment': ""I am more asking to remove clutter from the API. It does not seem essential to me to have this constructor that saves 1 line of code.\r\n\r\nWhen using a Bloom filter it would be expected to add hundreds or thousands of items. This will be done in a loop or over time by a method. Adding a single item at the creation point is a drop in the ocean against the final result of the saturated filter.\r\n\r\nThis is where my example of the ArrayList comes in (or any collection for that matter). There are no collections in the JDK that are created with an item except the singleton specialisations. Thus the language do not see this as a common case to satisfy. I'd suggest dropping the constructor that takes an item.\r\n\r\nI would not add a constructor that accepts a Bloom filter since that also only saves 1 line of code over just calling merge on the next line.\r\n"", 'commenter': 'aherbert'}, {'comment': 'The BloomFilter constructor that  takes a Hasher effectively does the same thing: creates the container and populates it.  Should that also be removed?  Perhaps a Jira ticket should be opened for that change.', 'commenter': 'Claudenw'}]"
160,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/HasherBuilderTest.java,"@@ -29,7 +32,8 @@
 
 /**
  * Tests the
- * {@link org.apache.commons.collections4.bloomfilter.hasher.Hasher.Builder Hasher.Builder}.
+ * {@link org.apache.commons.collections4.bloomfilter.hasher.Hasher.Builder
+ * Hasher.Builder}.","[{'comment': 'Introduced new formatting', 'commenter': 'aherbert'}, {'comment': 'The problem with converting T directly to a byte[] is two fold.\r\n\r\nFirst, to do the conversion to the byte[] you need to know the Shape.\r\n\r\nSecond, it confuses the architecture.  In the architecture\r\n\r\nThe Hasher is responsible for\r\n- hashing one or more items.\r\n- being able to replay the hash of the item(s).\r\n- converting the hash(es) into a collection of indexes into a bit vector.\r\n\r\nThe Shape is responsible for: \r\n- providing the number of bits that is represented by each item in the Bloom filter, also known as the number of hash functions, or _k_.\r\n- providing the length of the bit vector, also known as _m_.\r\n- providing the number of expected items in the Bloom filter, also known as _n_.\r\n- calculating the probability of false positive results, also known as _p_.\r\n\r\nThe Bloom filter is responsible for:\r\n- the implementation and management of a logical bit vector of _m_ bits.\r\n- determining if another Bloom filter is contained in this filter. `contains( BloomFilter )`\r\n- determining if the items contained in Hasher, taken as a whole, are contained in this filter. `contains( Hasher )`.  This is equivalent to constructing a second Bloom filter and calling the above but without the overhead.\r\n- merging another bloom filter into this filter. `merge( BloomFilter )`\r\n- merging the items contained in a Hasher, taken as a whole, into this filter. `merge( Hasher )`.  As with the contains method this is equivalent to constructing a Bloom filter and calling the above.\r\n\r\nBy using a function to go directly from T to byte[], the the function has to know the Shape of the filter that it is going to be used in.  Under the current architecture the Hasher does not care what the Shape is until the collection of indexes for a specific Shape are requested. \r\n\r\nThe SimpleHasher was chosen because it defines the underlying hash function (Murmur128x64Cyclic), any Hasher implementation would be an acceptable return value for the Function in the constructor.\r\n', 'commenter': 'Claudenw'}, {'comment': 'I think I was not clear. The `byte[]` is just the part of the item T that you want to hash. So you have two situations where you convert the item T to either:\r\n\r\n1. T -> List<byte[]>\r\n2. T -> byte[]\r\n\r\nThese are then fed into the DynamicHasher. In case 1 you have a byte[] for each property or part of T you want to add to the Bloom filter. In case 2 you are adding the entire item T as a single entity.\r\n\r\nYou could group 1 and 2 into the same situation where I concatenate the parts that would make up the List<byte[]> to a single longer array and create a SimpleBuilder containing the result. The idea is the same: a single item T should only add one set of indices to the Bloom filter.\r\n\r\nI do not suggest by-passing the Hasher. I suggest making it easier to specify case 2. Thus as a user I can convert my item to a binary form `byte[]` then the SimpleBloomFilter would do the rest of the work to hash the binary form and create a sequence of indexes for the filter shape.\r\n\r\nThis is why I suggested a `Function<T, byte[]>` version. The `byte[]` would be used internally by the SimpleBloomFilter to create a Hasher and generate indices for the Shape. Essentially this would be:\r\n\r\n```java\r\nbyte[] b = ...;\r\nHasher h = new SimpleBuilder().with(b).build();\r\n```\r\n\r\nBut this could be done using a specialised route that avoids all the object creation, for example using a variant of DynamicHasher that has a single `byte[]` to hash:\r\n\r\n```java\r\nbyte[] b = ...; // The SimpleBloomFilter converts T to byte[]\r\nHashFunction hf = ...; // From the SimpleBloomFilter\r\nHasher h = new DynamicHasher(hf, b);\r\n```\r\n\r\n', 'commenter': 'aherbert'}]"
160,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/HasherBuilderTest.java,"@@ -58,10 +62,9 @@ public Builder with(byte[] item) {
     public void withCharSequenceTest() {
         final String ascii = ""plain"";
         final String extended = getExtendedString();
-        for (final String s : new String[] {ascii, extended}) {
-            for (final Charset cs : new Charset[] {
-                StandardCharsets.ISO_8859_1, StandardCharsets.UTF_8, StandardCharsets.UTF_16
-            }) {
+        for (final String s : new String[] { ascii, extended }) {
+            for (final Charset cs : new Charset[] { StandardCharsets.ISO_8859_1, StandardCharsets.UTF_8,
+                StandardCharsets.UTF_16 }) {
                 TestBuilder builder = new TestBuilder();","[{'comment': 'Introduced new formatting', 'commenter': 'aherbert'}, {'comment': 'I tried to format using the src/conf/checkstyle.xml and the Eclipse checkstyle plugin.  Is that checkstyle.xml up to date or is there a problem with my Eclipse checkstyle configuration?', 'commenter': 'Claudenw'}, {'comment': 'If you are using Eclipse to format the entire file then there is a problem with your Eclipse formatting since it changed what was already in the file. There is no formatting file that has been applied to the collections source code. All formatting is done manually and must pass the checkstyle rules. These rules are not as strict as they could be but that is for another discussion.\r\n\r\nIn general you should only format new additions to existing source. If you reformat the existing source then you are adding noise to the PR.\r\n', 'commenter': 'aherbert'}, {'comment': 'I can not figure out how to get Eclipse to format the line so that the continued array initialization (line 67 above) is not indented an extra 4 space.  Anyone have any idea how to do this?', 'commenter': 'Claudenw'}]"
160,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/HasherBuilderTest.java,"@@ -76,16 +79,15 @@ public void withCharSequenceTest() {
     public void withUnecodedCharSequenceTest() {
         final String ascii = ""plain"";
         final String extended = getExtendedString();
-        for (final String s : new String[] {ascii, extended}) {
+        for (final String s : new String[] { ascii, extended }) {","[{'comment': 'Introduced new formatting', 'commenter': 'aherbert'}]"
160,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/HasherBuilderTest.java,"@@ -76,16 +79,15 @@ public void withCharSequenceTest() {
     public void withUnecodedCharSequenceTest() {
         final String ascii = ""plain"";
         final String extended = getExtendedString();
-        for (final String s : new String[] {ascii, extended}) {
+        for (final String s : new String[] { ascii, extended }) {
             final TestBuilder builder = new TestBuilder();
             builder.withUnencoded(s);
             final byte[] encoded = builder.items.get(0);
             final char[] original = s.toCharArray();
             // Should be twice the length
             Assert.assertEquals(original.length * 2, encoded.length);
             // Should be little endian (lower bits first)
-            final CharBuffer buffer = ByteBuffer.wrap(encoded)
-                                                .order(ByteOrder.LITTLE_ENDIAN).asCharBuffer();
+            final CharBuffer buffer = ByteBuffer.wrap(encoded).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer();","[{'comment': 'Introduced new formatting', 'commenter': 'aherbert'}]"
160,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/HasherBuilderTest.java,"@@ -98,7 +100,7 @@ public void withUnecodedCharSequenceTest() {
      * @return the extended string
      */
     static String getExtendedString() {
-        final char[] data = {'e', 'x', 't', 'e', 'n', 'd', 'e', 'd', ' ',
+        final char[] data = { 'e', 'x', 't', 'e', 'n', 'd', 'e', 'd', ' ',","[{'comment': 'Introduced new formatting', 'commenter': 'aherbert'}]"
160,src/main/java/org/apache/commons/collections4/bloomfilter/BitSetBloomFilter.java,"@@ -25,7 +25,7 @@
 import org.apache.commons.collections4.bloomfilter.hasher.StaticHasher;
 
 /**
- * A bloom filter using a Java BitSet to track enabled bits. This is a standard
+ * A bloom filter uses a Java BitSet to track enabled bits. This is a standard","[{'comment': 'I do not agree this is the correct grammar:\r\n\r\n`""A bloom filter using a Java BitSet""`: _This_ implementation of a Bloom filter is using a Java BitSet ...\r\n\r\n`""A bloom filter uses a Java BitSet""`: _Any_ implementation of a Bloom filter uses a Java BitSet ...\r\n\r\n', 'commenter': 'aherbert'}, {'comment': 'BitSet is a specific class.  The implementations in this library use BitSet but it is not required.  One could use long[] (without resorting to using the BitSet class) or one could use other BitSet like implementations.  ', 'commenter': 'Claudenw'}, {'comment': 'Perhaps the grammar should be:\r\n```\r\nA bloom filter **that** uses a Java BitSet\r\n```\r\nAnyway, this is a change totally unrelated to the SimpleBloomFilter in this PR. So should be reverted.\r\n\r\nSince the backing implementation is largely irrelevant (aside from allowing the determination of memory requirements) a better wording would then be `A Bloom filter using a fixed size array ...` and the entire class renamed to ArrayBloomFilter. So this change should be done separately.\r\n', 'commenter': 'aherbert'}]"
160,src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java,"@@ -0,0 +1,127 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.function.Function;
+
+import org.apache.commons.collections4.bloomfilter.hasher.DynamicHasher;
+import org.apache.commons.collections4.bloomfilter.hasher.Hasher;
+import org.apache.commons.collections4.bloomfilter.hasher.Shape;
+import org.apache.commons.collections4.bloomfilter.hasher.function.Murmur128x64Cyclic;
+
+/**
+ * A bloom filter that uses a BitSetBloomFilter to create a Bloom filter that
+ * can merge instances of a specific class.
+ *
+ * @param <T> The Class to merge.
+ * @since 4.5
+ */
+public class SimpleBloomFilter<T> extends BitSetBloomFilter implements BloomFilter {
+
+    /**
+     * The function that converts the instance of T to the SimpleBuilder.
+     * <p>
+     * If the object T is to be considered as a single item in the filter then
+     * function must create the {@code SimpleBuilder} and only call a single {@code with()}
+     * method.</p>
+     * <p>
+     * If the object T is to be considered as several items then the function must
+     * create the {@code SimpleBuilder} and call the {@code with()} method once for each item.</p>
+     */
+    private Function<T, SimpleBuilder> func;
+
+    /**
+     * Constructs a SimpleBloomFilter from the shape and function.  This constructor
+     * creates an empty Bloom filter.
+     * @param hasher the Hasher to use.
+     * @param shape the Shape of the Bloom filter.
+     * @param func a Function to convert T to a SimpleBuilder.
+     * @see #func
+     */
+    public SimpleBloomFilter(Hasher hasher, Shape shape, Function<T, SimpleBuilder> func) {
+        super(hasher, shape);
+        this.func = func;
+    }
+
+    /**
+     * Constructs a SimpleBloomFilter from the shape and function.  This constructor
+     * creates an empty Bloom filter.
+     * @param shape the Shape of the Bloom filter.
+     * @param func a Function to convert T to a SimpleBuilder.
+     * @see #func
+     */
+    public SimpleBloomFilter(Shape shape, Function<T, SimpleBuilder> func) {
+        super(shape);
+        this.func = func;
+    }
+
+    /**
+     * Constructs a SimpleBloomFilter from the shape, function and a data object.
+     * This constructor creates an Bloom filter populated with the data from the
+     * {@code data} parameter.
+     * @param shape the Shape of the Bloom filter.
+     * @param func a Function to convert T to a SimpleBuilder.
+     * @param data the data object to populate the filter with.
+     * @see #func
+     */
+    public SimpleBloomFilter(Shape shape, Function<T, SimpleBuilder> func, T data) {
+        this(shape, func);
+        this.merge( data );
+    }
+
+    /**
+     * Merges a data object into this filter.
+     *
+     * <p>Note: This method should return {@code true} even if no additional bit indexes were
+     * enabled. A {@code false} result indicates that this filter is not ensured to contain
+     * the {@code data}.
+     *
+     * @param data the data to merge.
+     * @return true if the merge was successful
+     * @throws IllegalArgumentException if the shape of the other filter does not match
+     * the shape of this filter
+     */
+    public boolean merge( T data ) {
+        return this.merge( this.func.apply( data ).build() );
+    }
+
+
+    /**
+     * Returns {@code true} if this filter contains the object.
+     * Specifically this returns {@code true} if this filter is enabled for all bit indexes
+     * identified by the hashing of the object {@code data}.
+     *
+     * @param data the data to check for.
+     * @return true if this filter is enabled for all bits specified by the data object.
+     */
+    public boolean contains( T data ) {
+        return this.contains( this.func.apply( data ).build() );
+    }
+
+    /**
+     * A Hasher.Builder for the SimpleBloom filter.
+     * This builder uses the Murmur 128 x64 cyclic hash.
+     *
+     * @see Murmur128x64Cyclic
+     */
+    public static class SimpleBuilder extends DynamicHasher.Builder {
+
+        public SimpleBuilder() {","[{'comment': 'public class should have a constructor comment', 'commenter': 'aherbert'}]"
160,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/Hasher.java,"@@ -103,6 +108,95 @@ default Builder withUnencoded(CharSequence item) {
             }
             return with(bytes);
         }
+
+        /**
+         * Adds an integer into the hasher.  The integer is converted into 4 bytes
+         * through the use of ByteBuffer.putInt.
+         * @param data the integer to add.
+         * @return a reference to this object
+         * @see ByteBuffer#putInt
+         */
+        default B with(int data) {
+            return with( ByteBuffer.allocate(Integer.BYTES).putInt( data ).array());
+        }
+
+        /**
+         * Adds a long into the hasher.  The long is converted into 8 bytes
+         * through the use of ByteBuffer.putLong.
+         * @param data the long to add.
+         * @return a reference to this object
+         * @see ByteBuffer#putLong
+         */
+        default B with(long data) {
+            return with( ByteBuffer.allocate(Long.BYTES).putLong( data ).array());
+        }
+
+        /**
+         * Adds a double into the hasher.  The double is converted into 8 bytes
+         * through the use of ByteBuffer.putDouble.
+         * @param data the double to add.
+         * @return a reference to this object
+         * @see ByteBuffer#putDouble
+         */
+        default B with(double data) {
+            return with( ByteBuffer.allocate(Double.BYTES).putDouble( data ).array());","[{'comment': 'Here I would use:\r\n```java\r\nreturn with(Double.doubleToRawLongBits(data));\r\n```\r\n\r\nsame for float.\r\n', 'commenter': 'aherbert'}]"
160,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/Hasher.java,"@@ -103,6 +108,95 @@ default Builder withUnencoded(CharSequence item) {
             }
             return with(bytes);
         }
+
+        /**
+         * Adds an integer into the hasher.  The integer is converted into 4 bytes
+         * through the use of ByteBuffer.putInt.
+         * @param data the integer to add.
+         * @return a reference to this object
+         * @see ByteBuffer#putInt
+         */
+        default B with(int data) {
+            return with( ByteBuffer.allocate(Integer.BYTES).putInt( data ).array());","[{'comment': 'If you read the code behind `ByteBuffer.allocate` there is a lot of overhead to these calls. If this Builder is going to be efficient then I would suggest writing the methods explicitly:\r\n```java\r\n// little-endian\r\nreturn with(new byte[]{(byte) (data      ), \r\n                       (byte) (data >>  8), \r\n                       (byte) (data >> 16), \r\n                       (byte) (data >> 24)});\r\n```', 'commenter': 'aherbert'}]"
160,src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java,"@@ -0,0 +1,127 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.function.Function;
+
+import org.apache.commons.collections4.bloomfilter.hasher.DynamicHasher;
+import org.apache.commons.collections4.bloomfilter.hasher.Hasher;
+import org.apache.commons.collections4.bloomfilter.hasher.Shape;
+import org.apache.commons.collections4.bloomfilter.hasher.function.Murmur128x64Cyclic;
+
+/**
+ * A bloom filter that uses a BitSetBloomFilter to create a Bloom filter that
+ * can merge instances of a specific class.
+ *
+ * @param <T> The Class to merge.
+ * @since 4.5
+ */
+public class SimpleBloomFilter<T> extends BitSetBloomFilter implements BloomFilter {
+
+    /**
+     * The function that converts the instance of T to the SimpleBuilder.
+     * <p>
+     * If the object T is to be considered as a single item in the filter then
+     * function must create the {@code SimpleBuilder} and only call a single {@code with()}
+     * method.</p>
+     * <p>
+     * If the object T is to be considered as several items then the function must
+     * create the {@code SimpleBuilder} and call the {@code with()} method once for each item.</p>
+     */
+    private Function<T, SimpleBuilder> func;
+
+    /**
+     * Constructs a SimpleBloomFilter from the shape and function.  This constructor
+     * creates an empty Bloom filter.","[{'comment': 'This is not an empty filter: it has a hasher argument.\r\n\r\nI would drop this constructor. Creating a Bloom filter and adding data are two separate functions.', 'commenter': 'aherbert'}]"
201,src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java,"@@ -125,7 +125,7 @@ public void resetFull() {
 
     //-----------------------------------------------------------------------
     /**
-     * Returns the {@link #collection} field cast to a {@link Bag}.
+     * Returns the {@link Collection} field cast to a {@link Bag}.","[{'comment': ""That's a link to the [`collection`](https://github.com/apache/commons-collections/blob/3945e6c48e2dd83c6b4b65c135f0bfc2f28ed52a/src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java#L141) variable of the parent class."", 'commenter': 'kinow'}, {'comment': 'sorry..I revert AbstractBagTest', 'commenter': 'EruDev'}, {'comment': ""No problem, thanks @EruDev . Could you squash your commits too? For a small change, it's preferable to have a single (or very few) commit. Please.\r\n\r\nThanks!"", 'commenter': 'kinow'}, {'comment': 'I close this PR and resubmit.', 'commenter': 'EruDev'}]"
209,src/test/java/org/apache/commons/collections4/iterators/LoopingListIteratorTest.java,"@@ -21,8 +21,8 @@
 import java.util.List;
 import java.util.NoSuchElementException;
 
-import org.junit.Test;
-import static org.junit.Assert.*;
+import org.junit.jupiter.api.Test;
+import static org.junit.jupiter.api.Assertions.*;","[{'comment': '@arturobernalg \r\nDid you forget to flip the arguments on the `assert*` API calls in this file and subsequent files?', 'commenter': 'garydgregory'}, {'comment': ""HI @garydgregory \r\n\r\nNop. I don't.  I working on change/migrate the rest of the class. Trying to find out how migrate the BulkTest that extends TestCase hehehe. \r\n\r\nAny advice is more than welcome"", 'commenter': 'arturobernalg'}, {'comment': ""I don't have specific advice, that is some older code initially based on JUnit 3."", 'commenter': 'garydgregory'}, {'comment': ""HI @garydgregory  \r\n\r\nI can imagine. My idea it's split the migration in several PR.  In that way i can reduce the number of file to review and reduce the errors"", 'commenter': 'arturobernalg'}]"
209,src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionBuilderTest.java,"@@ -86,14 +89,14 @@ public void createPredicatedCollectionWithNotNullPredicate() {
     }
 
     private void checkPredicatedCollection1(final Collection<String> collection) {
-        Assert.assertEquals(1, collection.size());
+        assertEquals(1, collection.size());
 
         collection.add(""test2"");
-        Assert.assertEquals(2, collection.size());
+        assertEquals(2, collection.size());
 
         try {
             collection.add(null);
-            Assert.fail(""Expecting IllegalArgumentException for failing predicate!"");
+            fail(""Expecting IllegalArgumentException for failing predicate!"");","[{'comment': 'Use assertThrows()', 'commenter': 'garydgregory'}, {'comment': 'Done', 'commenter': 'arturobernalg'}]"
209,src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionBuilderTest.java,"@@ -122,17 +125,17 @@ public void createPredicatedCollectionWithPredicate() {
     }
 
     private void checkPredicatedCollection2(final Collection<Integer> collection) {
-        Assert.assertEquals(2, collection.size());
+        assertEquals(2, collection.size());
 
         try {
             collection.add(4);
-            Assert.fail(""Expecting IllegalArgumentException for failing predicate!"");
+            fail(""Expecting IllegalArgumentException for failing predicate!"");","[{'comment': 'Use assertThrows()', 'commenter': 'garydgregory'}, {'comment': 'Done', 'commenter': 'arturobernalg'}]"
238,src/main/java/org/apache/commons/collections4/iterators/ZippedTupleIterator.java,"@@ -0,0 +1,176 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.iterators;
+
+import static java.util.Objects.requireNonNull;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import org.apache.commons.collections4.iterators.ZippedTupleIterator.ZippedTuple;
+
+/**
+ * Provides a iteration over the elements contained in a pair of Iterators.
+ *
+ * <p>
+ * Given two {@link Iterator} instances {@code A} and {@code B}, the {@link #next} method on this
+ * iterator provide a Pair of {@code A.next()} and {@code B.next()} until one of the iterators is
+ * exhausted.
+ * </p>
+ * Example usage:
+ * <pre>{@code
+ *   List<Integer> studentIds = ...
+ *   List<String> studentNames = ...
+ *
+ *   ZippedTupleIterator<ZippedTuple<Integer, String>> zippedIterator =
+ *     ZippedTupleIterator.ofIterables(studentIds, studentNames);
+ *
+ *   while (zippedIterator.hasNext()) {
+ *     ZippedTuple<Integer, String> item = zippedIterator.next();
+ *     ...
+ *   }
+ * }</pre>
+ *
+ * @param <L> the left elements' type
+ * @param <R> the right elements' type
+ */
+public class ZippedTupleIterator<L, R> implements Iterator<ZippedTuple<L, R>> {","[{'comment': 'Why is this prefixed with ""zip"" when it has nothing to do with zip files?', 'commenter': 'garydgregory'}, {'comment': ""I think it is related to [zipper](https://en.wikipedia.org/wiki/Zipper_(data_structure)). Like Python stdlib's [zip function](https://docs.python.org/3/library/functions.html#zip). Scala and Clojure also have a similar function I think."", 'commenter': 'kinow'}, {'comment': 'Maybe but the prefix here is ""zipped"" not ""zipper"", terrible name IMO.', 'commenter': 'garydgregory'}, {'comment': ""I'm not good naming things, so can't really suggest a better one. The code example in the Python docs uses `zipped` too for the variable that contains the tuples returned with `zip` (that were zipped), so that should sound OK for users coming from Python (or JS using Lodash's [zip/unzip](https://lodash.com/docs/#unzip) which I'm using in my current project). But if that's confusing for other users, we can try to think in a better name I think."", 'commenter': 'kinow'}, {'comment': 'Updated to use `PairedIterator` and `PairedIterable` names. Hope is acceptable to all.', 'commenter': 'anantdamle'}]"
238,src/test/java/org/apache/commons/collections4/iterators/ZippedTupleIteratorTest.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.iterators;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.Random;
+import java.util.UUID;
+import org.apache.commons.collections4.IteratorUtils;
+import org.apache.commons.collections4.iterators.ZippedTupleIterator.ZippedTuple;
+
+
+/** Unit test suite for {@link ZippingIterator}. */
+public final class ZippedTupleIteratorTest
+    extends AbstractIteratorTest<ZippedTuple<String, Integer>> {
+
+  //------------------------------------------------------------ Conventional
+
+  public ZippedTupleIteratorTest(String testName) {
+    super(testName);
+  }
+
+  //------------------------------------------------------------ Lifecycle
+
+  private ArrayList<String> smallStringsList = null;
+  private ArrayList<String> largeStringsList = null;
+  private ArrayList<Integer> smallIntsList = null;
+  private ArrayList<Integer> largeIntsList = null;
+
+  // Unequal sized lists
+  private static final int SMALL_LIST_SIZE = 20;
+  private static final int LARGE_LIST_SIZE = 40;
+
+  @Override
+  protected void setUp() throws Exception {
+    super.setUp();
+
+    smallStringsList = new ArrayList<>();
+    largeStringsList = new ArrayList<>();
+    smallIntsList = new ArrayList<>();
+    largeIntsList = new ArrayList<>();
+
+    Random random = new Random();
+
+    for (int i = 0; i < SMALL_LIST_SIZE; i++) {
+      smallIntsList.add(random.nextInt());
+      smallStringsList.add(UUID.randomUUID().toString());
+    }
+
+    for (int i = 0; i < LARGE_LIST_SIZE; i++) {
+      largeIntsList.add(random.nextInt());
+      largeStringsList.add(UUID.randomUUID().toString());
+    }
+  }
+
+  @Override
+  public boolean supportsRemove() {
+    return false;
+  }
+
+  //---------------------------------------------------- TestIterator Methods
+
+  @Override
+  public Iterator<ZippedTuple<String, Integer>> makeEmptyIterator() {
+    return ZippedTupleIterator.of(IteratorUtils.emptyIterator(), IteratorUtils.emptyIterator());
+  }
+
+  @Override
+  public Iterator<ZippedTuple<String, Integer>> makeObject() {
+    return ZippedTupleIterator.of(smallStringsList.iterator(), smallIntsList.iterator());
+  }
+
+  public void testLeftIteratorLargerThanRight() {
+    Iterator<ZippedTuple<String, Integer>> zipPairIterator =
+        ZippedTupleIterator.ofIterables(largeStringsList, smallIntsList);
+
+
+    for (int i = 0; i < SMALL_LIST_SIZE; i++) {
+      assertTrue(zipPairIterator.hasNext());
+      ZippedTuple<String, Integer> zippedItem = zipPairIterator.next();
+
+      assertEquals(largeStringsList.get(i) , zippedItem.getLeftItem());
+      assertEquals(smallIntsList.get(i) , zippedItem.getRightItem());
+    }
+
+    assertFalse(zipPairIterator.hasNext());
+  }
+
+  public void testRightIteratorLargerThanLeft() {
+    Iterator<ZippedTuple<String, Integer>> zipPairIterator =
+        ZippedTupleIterator.ofIterables(smallStringsList, largeIntsList);
+
+
+    for (int i = 0; i < SMALL_LIST_SIZE; i++) {
+      assertTrue(zipPairIterator.hasNext());
+      ZippedTuple<String, Integer> zippedItem = zipPairIterator.next();
+
+      assertEquals(smallStringsList.get(i) , zippedItem.getLeftItem());
+      assertEquals(largeIntsList.get(i) , zippedItem.getRightItem());
+    }
+
+    assertFalse(zipPairIterator.hasNext());
+  }
+
+  public void testEmptyLeftIterator() {
+    Iterator<ZippedTuple<String, Integer>> zipPairIterator =
+        ZippedTupleIterator.of(IteratorUtils.emptyIterator(), largeIntsList.iterator());
+
+    assertFalse(zipPairIterator.hasNext());
+  }
+
+  public void testEmptyRightIterator() {
+    Iterator<ZippedTuple<String, Integer>> zipPairIterator =
+        ZippedTupleIterator.of(largeStringsList.iterator(), IteratorUtils.emptyIterator());
+
+    assertFalse(zipPairIterator.hasNext());
+  }
+
+
+  public void testValidTupleString() {
+    Iterator<ZippedTuple<String, Integer>> zipPairIterator =
+        ZippedTupleIterator.ofIterables(smallStringsList, largeIntsList);
+
+
+    for (int i = 0; i < SMALL_LIST_SIZE; i++) {
+      assertTrue(zipPairIterator.hasNext());
+      ZippedTuple<String, Integer> zippedItem = zipPairIterator.next();
+
+      assertEquals(
+          String.format(""{%s, %s}"", zippedItem.getLeftItem(), zippedItem.getRightItem()),
+          zippedItem.toString());
+    }
+
+    assertFalse(zipPairIterator.hasNext());
+  }
+}","[{'comment': 'Missing new line', 'commenter': 'kinow'}, {'comment': 'Done/', 'commenter': 'anantdamle'}]"
238,src/main/java/org/apache/commons/collections4/IteratorUtils.java,"@@ -907,6 +908,20 @@ public static NodeListIterator nodeListIterator(final Node node) {
         return new ZippingIterator<>(iterators);
     }
 
+    /**
+     * Returns an iterator that provides the elements contained in a pair of Iterators.
+     *
+     * @param <L> the left elements' type
+     * @param <R> the right elements' type
+     * @param left the iterator for the left side elements
+     * @param right the iterator for the right side elements
+     * @return an iterator, to iterate over the decorated iterators together until one is exhausted
+     * @throws NullPointerException if any iterator is null","[{'comment': 'All new public and protected methods should have a Javadoc since 4.5 tag.', 'commenter': 'garydgregory'}, {'comment': 'Added a more descriptive Javadoc.', 'commenter': 'anantdamle'}]"
238,src/test/java/org/apache/commons/collections4/iterators/PairedIteratorTest.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.iterators;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.Random;
+import java.util.UUID;
+import org.apache.commons.collections4.IteratorUtils;
+import org.apache.commons.collections4.iterators.PairedIterator.PairedItem;
+
+
+/** Unit test suite for {@link ZippingIterator}. */
+public final class PairedIteratorTest
+    extends AbstractIteratorTest<PairedItem<String, Integer>> {
+
+    //------------------------------------------------------------ Conventional","[{'comment': 'No need for these inline comments, they document nothing.', 'commenter': 'garydgregory'}, {'comment': 'Removed.\r\nHad copied them from another test.', 'commenter': 'anantdamle'}]"
238,src/main/java/org/apache/commons/collections4/iterators/PairedIterator.java,"@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.iterators;
+
+import static java.util.Objects.requireNonNull;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import org.apache.commons.collections4.iterators.PairedIterator.PairedItem;
+
+/**
+ * Provides a iteration over the elements contained in a pair of Iterators.
+ *
+ * <p>
+ * Given two {@link Iterator} instances {@code A} and {@code B}, the {@link #next} method on this
+ * iterator provide a Pair of {@code A.next()} and {@code B.next()} until one of the iterators is
+ * exhausted.
+ * </p>
+ * Example usage:
+ * <pre>{@code
+ *   List<Integer> studentIds = ...
+ *   List<String> studentNames = ...
+ *
+ *   PairedIterator<PairedItem<Integer, String>> pairedIterator =
+ *     PairedIterator.ofIterables(studentIds, studentNames);
+ *
+ *   while (pairedIterator.hasNext()) {
+ *     PairedItem<Integer, String> item = zippedIterator.next();
+ *     ...
+ *   }
+ * }</pre>
+ *
+ * @param <L> the left elements' type
+ * @param <R> the right elements' type
+ */
+public class PairedIterator<L, R> implements Iterator<PairedItem<L, R>> {
+
+    /**
+     * The left {@link Iterator}s to evaluate.
+     */
+    private final Iterator<L> leftIterator;
+
+    /**
+     * The right {@link Iterator}s to evaluate.
+     */
+    private final Iterator<R> rightIterator;
+
+    // Constructor
+    // ----------------------------------------------------------------------
+
+    /**
+     * Constructs a new {@code ZipPairIterator} that will provide  iteration over the two given
+     * iterators.
+     *
+     * @param leftIterator  the iterator for the left side element.
+     * @param rightIterator the iterator for the right side element.
+     * @throws NullPointerException if either iterator is null
+     */
+    public PairedIterator(Iterator<L> leftIterator, Iterator<R> rightIterator) {
+        this.leftIterator = requireNonNull(leftIterator);
+        this.rightIterator = requireNonNull(rightIterator);
+    }
+
+    /**
+     * Convenience static factory to construct the ZipPairIterator
+     *
+     * @param leftIterator  the iterator for the left side element.
+     * @param rightIterator the iterator for the right side element.
+     * @return the iterator to iterate over the provided iterators.
+     * @throws NullPointerException if either iterator is null
+     */
+    public static <L, R> PairedIterator<L, R> of(Iterator<L> leftIterator, Iterator<R> rightIterator) {
+        return new PairedIterator<>(leftIterator, rightIterator);
+    }
+
+    /**
+     * Convenience static factory to construct the ZipPairIterator from any {@link Iterable} sources.
+     *
+     * @param leftIterable  the iterable for the left side element.
+     * @param rightIterable the iterable for the right side element.
+     * @return the iterator to iterate over the iterators derived from the provided iterables.
+     * @throws NullPointerException if either iterables is null
+     */
+    public static <L, R> PairedIterator<L, R> ofIterables(Iterable<L> leftIterable, Iterable<R> rightIterable) {
+        return of(requireNonNull(leftIterable).iterator(), requireNonNull(rightIterable).iterator());
+    }
+
+    // Iterator Methods
+    // -------------------------------------------------------------------
+
+    /**
+     * Returns {@code true} if both the child iterators have remaining elements.
+     *
+     * @return true if both the child iterators have remaining elements
+     */
+    @Override
+    public boolean hasNext() {
+        return leftIterator.hasNext() && rightIterator.hasNext();
+    }
+
+    /**
+     * Returns the next elements from both the child iterators.
+     *
+     * @return the next elements from both the iterators.
+     * @throws NoSuchElementException if any one child iterator is exhausted.
+     */
+    @Override
+    public PairedItem<L, R> next() {
+        if (!hasNext()) {
+            throw new NoSuchElementException();
+        }
+
+        return PairedItem.of(leftIterator.next(), rightIterator.next());
+    }
+
+    /**
+     * An immutable tuple class to represent elements from both the iterators.
+     *
+     * @param <L> the left elements' type
+     * @param <R> the right elements' type
+     */","[{'comment': 'We need to think about this because Common Lang already defines different kinds of Pair classes...', 'commenter': 'garydgregory'}, {'comment': ""I usually use `ImmutablePair`, but that is in apache/commons-lang3 , that is not a dependency in this project and didn't think should add, but open to ideas. If you point me to a Pair Class, would be open to using an existing pair class.\r\n"", 'commenter': 'anantdamle'}]"
238,src/test/java/org/apache/commons/collections4/PairedIterableTest.java,"@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.Random;
+import java.util.UUID;
+import java.util.stream.Collectors;
+import org.apache.commons.collections4.iterators.PairedIterator.PairedItem;
+import org.junit.Before;
+import org.junit.Test;
+
+public final class PairedIterableTest {
+    private ArrayList<String> smallStringsList = null;","[{'comment': ""Don't override default vslues with default values."", 'commenter': 'garydgregory'}, {'comment': 'done.', 'commenter': 'anantdamle'}]"
238,src/test/java/org/apache/commons/collections4/iterators/PairedIteratorTest.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.iterators;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.Random;
+import java.util.UUID;
+import org.apache.commons.collections4.IteratorUtils;
+import org.apache.commons.collections4.iterators.PairedIterator.PairedItem;
+
+
+/** Unit test suite for {@link ZippingIterator}. */
+public final class PairedIteratorTest
+    extends AbstractIteratorTest<PairedItem<String, Integer>> {
+
+    //------------------------------------------------------------ Conventional
+
+    public PairedIteratorTest(String testName) {
+        super(testName);
+    }
+
+    //------------------------------------------------------------ Lifecycle
+
+    private ArrayList<String> smallStringsList = null;
+    private ArrayList<String> largeStringsList = null;
+    private ArrayList<Integer> smallIntsList = null;
+    private ArrayList<Integer> largeIntsList = null;
+
+    // Unequal sized lists
+    private static final int SMALL_LIST_SIZE = 20;","[{'comment': 'If you expect the sizes to be different, you should assert that fact somewhere. ', 'commenter': 'garydgregory'}, {'comment': 'added two tests: `testLeftIteratorLargerThanRight` and `testRightIteratorLargerThanLeft` to match the tests of same name from PairedIteratorTest', 'commenter': 'anantdamle'}]"
238,src/main/java/org/apache/commons/collections4/IteratorUtils.java,"@@ -127,7 +87,7 @@ private IteratorUtils() {}
      * @return an iterator over nothing
      */
     public static <E> ResettableIterator<E> emptyIterator() {
-        return EmptyIterator.<E>resettableEmptyIterator();
+        return EmptyIterator.resettableEmptyIterator();","[{'comment': 'These changes are unrelated, small PRs are better for reviewers ;-)', 'commenter': 'garydgregory'}, {'comment': 'Done.', 'commenter': 'anantdamle'}]"
238,src/main/java/org/apache/commons/collections4/IterableUtils.java,"@@ -554,6 +555,34 @@
         };
     }
 
+    /**
+     * Provides iteration over the elements contained in a pair of Iterables in-tandem.
+     * <p>
+     * The returned iterable has an iterator that traverses the elements in {@code a}
+     * and {@code b} together until one of the iterables is traversed completely.
+     * <p>","[{'comment': 'Close HTML tags.', 'commenter': 'garydgregory'}, {'comment': 'Done.', 'commenter': 'anantdamle'}]"
238,src/main/java/org/apache/commons/collections4/IterableUtils.java,"@@ -554,6 +555,34 @@
         };
     }
 
+    /**
+     * Provides iteration over the elements contained in a pair of Iterables in-tandem.
+     * <p>
+     * The returned iterable has an iterator that traverses the elements in {@code a}
+     * and {@code b} together until one of the iterables is traversed completely.
+     * <p>
+     * The returned iterable's iterator does NOT support {@code remove()}.
+     *
+     * @param <L> the left elements' type
+     * @param <R> the right elements' type
+     * @param left the iterable for the left side elements
+     * @param right the iterable for the right side elements
+     * @return an iterable, over the decorated iterables to traverse them together until one is
+     * exhausted
+     * @throws NullPointerException if any iterator is null
+     */","[{'comment': 'New public and protected method should have `@since 4.5` Javadoc tags.\r\n', 'commenter': 'garydgregory'}, {'comment': 'Done', 'commenter': 'anantdamle'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java,"@@ -120,7 +120,23 @@ public void forEachBitMap(LongConsumer consumer) {
         if (cardinality() == 0) {
             return;
         }
-        BitMapProducer.fromIndexProducer( this, shape).forEachBitMap(consumer);
+        // because our indices are always in order we can
+        // shorten the time necessary to create the longs for the
+        // consumer
+        long bitMap =0;
+        int idx=0;
+        for (int i : indices) {
+            if (BitMap.getLongIndex(i) != idx) {
+                consumer.accept( bitMap );
+                bitMap = 0;
+                idx = BitMap.getLongIndex(i);
+            }
+            bitMap |= BitMap.getLongBit(i);
+        }
+        if (bitMap != 0)
+        {","[{'comment': 'this `{` can be in the same line of `if` as in the rest of the code.', 'commenter': 'kinow'}]"
258,src/test/java/org/apache/commons/collections4/bloomfilter/ShapeFactoryTest.java,"@@ -0,0 +1,224 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests the {@link Shape} class.
+ */
+public class ShapeFactoryTest {
+
+
+    /*
+     * values from https://hur.st/bloomfilter/?n=5&p=.1&m=&k=
+     *
+     * n = 5
+     *
+     * p = 0.100375138 (1 in 10)
+     *
+     * m = 24 (3B)
+     *
+     * k = 3
+     */
+
+
+    /**
+     * Tests that if the number of items less than 1 an IllegalArgumentException is thrown.
+     */
+    @Test
+    public void badNumberOfItemsTest() {
+        try {
+            Shape.Factory.fromNM(0, 24);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+        try {
+            Shape.Factory.fromNMK(0, 24, 5);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+        try {
+            Shape.Factory.fromNP(0, 0.02 );
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+    }
+
+    /**
+     * Tests that if the number of bits is less than 1 an exception is thrown
+     */
+    @Test
+    public void badNumberOfBitsTest() {
+        try {
+            Shape.Factory.fromNM( 5, 0 );
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+        try {
+            Shape.Factory.fromNMK( 5, 0, 7 );
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+        try {
+            Shape.Factory.fromPMK( 0.035, 0, 7 );
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+    }
+
+    /**
+     * Tests that if the number of hash functions is less than 1 an exception is thrown.
+     */
+    @Test
+    public void badNumberOfHashFunctionsTest() {
+        try {
+            Shape.Factory.fromNMK(5, 26, 0);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+        try {
+            Shape.Factory.fromPMK(0.35, 26, 0);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+    }
+
+    /**
+     * Tests that if the calculated probability is greater than or equal to 1 an IllegalArgumentException is thrown
+     */
+    @Test
+    public void badProbabilityTest() {
+        try {
+            Shape.Factory.fromNMK( 4000, 8, 1);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+        try {
+            Shape.Factory.fromNP(10, 0.0);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // do nothing.
+        }
+        try {
+            Shape.Factory.fromNP( 10, 1.0);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // do nothing.
+        }
+        try {
+            Shape.Factory.fromNP( 10, Double.NaN);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // do nothing.
+        }
+    }
+
+
+    /**
+     * Tests that when the number of items, number of bits and number of hash functions is passed the values are
+     * calculated correctly.
+     */
+    @Test
+    public void fromNMK_test() {
+        /*
+         * values from https://hur.st/bloomfilter/?n=5&m=24&k=4
+         */
+        final Shape filterConfig = Shape.Factory.fromNMK( 5, 24, 4);
+
+        assertEquals(24, filterConfig.getNumberOfBits());
+        assertEquals(4, filterConfig.getNumberOfHashFunctions());
+        assertEquals(0.102194782, filterConfig.getProbability(5 ), 0.000001);
+    }
+
+    /**
+     * Tests that the number of items and number of bits is passed the other values are calculated correctly.
+     */
+    @Test
+    public void fromNM_Test() {
+        /*
+         * values from https://hur.st/bloomfilter/?n=5&m=24
+         */
+        final Shape filterConfig = Shape.Factory.fromNM(5, 24);
+
+        assertEquals(24, filterConfig.getNumberOfBits());
+        assertEquals(3, filterConfig.getNumberOfHashFunctions());
+        assertEquals(0.100375138, filterConfig.getProbability(5), 0.000001);
+    }
+
+
+
+
+    /**
+     * Tests that if calculated number of bits is greater than Integer.MAX_VALUE an IllegalArgumentException is thrown.
+     */
+    @Test
+    public void numberOfBitsOverflowTest() {
+        try {
+            Shape.Factory.fromNP(Integer.MAX_VALUE, 0.1);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // do nothing.
+        }","[{'comment': ""I think there's a new syntax in JUnit 5, `assertThrows(IllegalArgumentException.class, () => { Shape.Fctory ... })` I think?"", 'commenter': 'kinow'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
258,src/test/java/org/apache/commons/collections4/bloomfilter/ShapeFactoryTest.java,"@@ -0,0 +1,224 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests the {@link Shape} class.
+ */
+public class ShapeFactoryTest {
+
+
+    /*
+     * values from https://hur.st/bloomfilter/?n=5&p=.1&m=&k=
+     *
+     * n = 5
+     *
+     * p = 0.100375138 (1 in 10)
+     *
+     * m = 24 (3B)
+     *
+     * k = 3
+     */
+
+
+    /**
+     * Tests that if the number of items less than 1 an IllegalArgumentException is thrown.
+     */
+    @Test
+    public void badNumberOfItemsTest() {
+        try {
+            Shape.Factory.fromNM(0, 24);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+        try {
+            Shape.Factory.fromNMK(0, 24, 5);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+        try {
+            Shape.Factory.fromNP(0, 0.02 );
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+    }
+
+    /**
+     * Tests that if the number of bits is less than 1 an exception is thrown
+     */
+    @Test
+    public void badNumberOfBitsTest() {
+        try {
+            Shape.Factory.fromNM( 5, 0 );
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+        try {
+            Shape.Factory.fromNMK( 5, 0, 7 );
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+        try {
+            Shape.Factory.fromPMK( 0.035, 0, 7 );
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+    }
+
+    /**
+     * Tests that if the number of hash functions is less than 1 an exception is thrown.
+     */
+    @Test
+    public void badNumberOfHashFunctionsTest() {
+        try {
+            Shape.Factory.fromNMK(5, 26, 0);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+        try {
+            Shape.Factory.fromPMK(0.35, 26, 0);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+    }
+
+    /**
+     * Tests that if the calculated probability is greater than or equal to 1 an IllegalArgumentException is thrown
+     */
+    @Test
+    public void badProbabilityTest() {
+        try {
+            Shape.Factory.fromNMK( 4000, 8, 1);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+        try {
+            Shape.Factory.fromNP(10, 0.0);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // do nothing.
+        }
+        try {
+            Shape.Factory.fromNP( 10, 1.0);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // do nothing.
+        }
+        try {
+            Shape.Factory.fromNP( 10, Double.NaN);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // do nothing.
+        }","[{'comment': 'See comment below about `assertThrows` from JUnit 5. That can simplify these test methods :point_up: ', 'commenter': 'kinow'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
258,src/test/java/org/apache/commons/collections4/bloomfilter/ShapeTest.java,"@@ -0,0 +1,453 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests the {@link Shape} class.
+ */
+public class ShapeTest {
+
+
+    /*
+     * values from https://hur.st/bloomfilter/?n=5&p=.1&m=&k=
+     *
+     * n = 5
+     *
+     * p = 0.100375138 (1 in 10)
+     *
+     * m = 24 (3B)
+     *
+     * k = 3
+     */
+
+    private final Shape shape = new Shape(3, 24 );
+
+    /**
+     * Tests that if the number of bits less than 1 an IllegalArgumentException is thrown.
+     */
+    @Test
+    public void constructor_items_bits_BadNumberOfBitsTest() {
+        try {
+            new Shape( 5, 0);
+            fail(""Should have thrown IllegalArgumentException"");
+        } catch (final IllegalArgumentException expected) {
+            // expected
+        }
+    }
+
+    //    /**
+    //     * Tests that if the number of hash functions is less than 1 an IllegalArgumentException is thrown.
+    //     */
+    //    @Test
+    //    public void constructor_items_bits_BadNumberOfHashFunctionsTest() {
+    //        try {
+    //            new Shape( 16, 8);
+    //
+    //            fail(""Should have thrown IllegalArgumentException"");
+    //        } catch (final IllegalArgumentException expected) {
+    //            // expected
+    //        }
+    //    }
+
+    //    /**
+    //     * Tests that if the number of items less than 1 an IllegalArgumentException is thrown.
+    //     */
+    //    @Test
+    //    public void constructor_items_bits_BadNumberOfItemsTest() {
+    //        try {
+    //            new Shape(testFunction, 0, 24);
+    //            fail(""Should have thrown IllegalArgumentException"");
+    //        } catch (final IllegalArgumentException expected) {
+    //            // expected
+    //        }
+    //    }
+
+    //    /**
+    //     * Tests that if the number of bits is less than 1 an exception is thrown
+    //     */
+    //    @Test
+    //    public void constructor_items_bits_hash_BadNumberOfBitsTest() {
+    //        try {
+    //            new Shape(testFunction, 5, 0, 1);
+    //            fail(""Should have thrown IllegalArgumentException"");
+    //        } catch (final IllegalArgumentException expected) {
+    //            // expected
+    //        }
+    //    }","[{'comment': ""Is it going to be used in the future? If not I think we can remove it (since it's a WIP PR it might be still under development... :+1: )"", 'commenter': 'kinow'}]"
258,src/test/java/org/apache/commons/collections4/bloomfilter/BitMapTest.java,"@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import org.junit.Test;
+
+public class BitMapTest {
+
+    @Test
+    public void checkPositiveTest() {
+        BitMap.checkPositive(0);
+        BitMap.checkPositive(0);
+        try {
+            BitMap.checkPositive(-1);
+
+        } catch (IndexOutOfBoundsException expected) {
+            // do nothing
+        }","[{'comment': 'assertThrows :point_up: ', 'commenter': 'kinow'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java,"@@ -71,48 +78,18 @@
  *  <h3>
  *  Shape</h3>
  *  <p>
- *  Describes the Bloom filter using the
- * standard number of bits, number of hash functions and number of items along with a
- * description of the HashFunction. It is this description that has caused the most issues
- * of late. </p>
- *  <h3>
- *  Hasher</h3>
- *  <p>
- *  converts byte buffers into an iterator if int based
- * on a Shape. There are 2 implementations of Hasher provided <ul>
- *  <li>
- *  Dynamic - calls
- * the HashFunction for each value required in the Bloom filter.</li>
- *  <li>
- *  Static - based
- * on a pre-calculated list of Bloom filter index values. It is also limited to generating
- * values for a specific Shape.</li>
- *  </ul>
+ *  The Shape describes the Bloom filter using the number of bits and the number of hash functions</p>
  *
  *  <h3>
- *  Hash Functions</h3>
- *  <p>
- *  Hash
- * functions generate individual index values for the filter from a byte buffer. There are
- * four implementations provided. </p>
- *  <h3>
- *  HashFunctionIdentity</h3>
+ *  Hasher</h3>
  *  <p>
- *  The
- * HashFunctionIdentity is the base interface for the HashFunction. It tracks three (3)
- * properties: <ul>
- *  <li>
- *  The Hashing algorithm</li>
- *  <li>
- *  Whether the contents of the
- * resulting hash buffer are read as signed or unsigned values.</li>
- *  <li>
- *  Whether the hash
- * function uses an iterative or cyclic method. In traditional iterative methods this is
- * done by calling the selected hash function with a different seed for each hash
- * required. The second method described by Adam Kirsch and Micheal Mitzenmacher[1] has
- * become more common and is used in applications like Cassandra[2].</li>
- *  </ul>
+ *  A Hasher converts bytes into an series of integers based on a Shape.  With the exception of the HasherCollecton,
+ *  Each hasher represents one item being added to the Bloom filter.  The HasherCollection represents the
+ *  number of items as the sum of the number of items represented by Hashers in the collection.</p>
+ *  <p>The SimpleHasher uses a combinatorial generation technique to create the integers. It is easily
+ *  initialized by using a standard @{code MessageDigest} or other Hash function to hash the item to insert and","[{'comment': ""I think it's `{@code MessageDigest}`? At least I never tried the `@` out of brackets (doing the review on GitHub UI, sorry, no IDE to confirm at the moment)."", 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/package-info.java,"@@ -16,8 +16,24 @@
  */
 
 /**
- * Provides classes and interfaces to define the shape of a Bloom filter and the conversion
- * of generic bytes to a hash of bit indexes to be used with a Bloom filter.
+ *
+ * With the exception of the HasherCollection, a Hasher represents an item of arbitrary
+ * byte size as multiple byte representations of fixed size (multiple hashes). The hashers
+ * are be used to create indices for a Bloom filter.</p>
+ *
+ * <p>Hashers create @{code IndexProducer} instances for hashed items based
+ * on a @{code Shape}.</p>
+ *
+ * <p>The method used to generate the multiple hashes is dependent upon the Hasher
+ * implementation.  The SimpleHasher uses a combinatorial strategy to create the
+ * multiple hashes from a single starting hash.</p>
+ *
+ * <p>Note that the process of generating hashes and mapping them to a Bloom
+ * filter shape may create duplicate indexes. The Hasher implementation is required to
+ * remove all duplicate values for a single item.  Thus tge hasher may generate fewer","[{'comment': ""s/tge/the (probably worth checking if another javadoc has a similar typo; I think I read another javadoc similar to this one, not sure if copy+paste wasn't sued)"", 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/HasherCollection.java,"@@ -0,0 +1,109 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter.hasher;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.Objects;
+import java.util.function.IntConsumer;
+import org.apache.commons.collections4.bloomfilter.IndexProducer;
+import org.apache.commons.collections4.bloomfilter.Shape;
+
+/**
+ * A collection of Hashers.  Useful when the generation of a Bloom filter depends upon
+ * multiple items.  Hashers for each item are added to the HasherCollection and then
+ * the collection is used wherever a Hasher can be used in the API.
+ *
+ * @since 4.5
+ */
+public class HasherCollection implements Hasher {
+
+    /**
+     * The list of hashers to be used to generate the indices.
+     */
+    private final List<Hasher> hashers;
+
+    /**
+     * Constructs an empty HasherCollection.
+     */
+    public HasherCollection() {
+        this.hashers = new ArrayList<>();
+    }
+
+    /**
+     * Constructs a HasherCollection from a collection of Hasher objects.
+     *
+     * @param hashers A collections of Hashers to build the indices with.
+     */
+    public HasherCollection(final Collection<Hasher> hashers) {
+        Objects.requireNonNull( hashers, ""hashers"");
+        this.hashers = new ArrayList<>(hashers);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param function the function to use.
+     * @param buffers the byte buffers that will be hashed.
+     */
+    public HasherCollection(Hasher... hashers) {
+        this( Arrays.asList(hashers));
+    }
+
+    /**
+     * Adds a hasher to the collection.
+     * @param hasher The hasher to add.
+     */
+    public void add(Hasher hasher) {
+        Objects.requireNonNull( hasher, ""hasher"");
+        hashers.add(hasher);
+    }
+
+    /**
+     * Add all the Hashers in a collection to this HasherCollection.
+     * @param hashers The hashers to add.
+     */
+    public void add(Collection<Hasher> hashers) {
+        Objects.requireNonNull( hashers, ""hashers"");
+        hashers.addAll(hashers);
+    }
+
+    @Override
+    public IndexProducer indices(final Shape shape) {
+        Objects.requireNonNull( shape, ""shape"");
+        return new IndexProducer() {
+            @Override
+            public void forEachIndex(IntConsumer consumer) {
+                for (Hasher hasher : hashers) {
+                    hasher.indices( shape ).forEachIndex(consumer);
+                }
+            }
+        };
+    }
+
+    @Override
+    public int size() {
+        int i = 0;
+        for (Hasher h : hashers )
+        {","[{'comment': 'normally the `{` stays in the same line of the `for` in Commons Collections.', 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/exceptions/package-info.java,"@@ -14,11 +14,4 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-/**
- * Provides implementations of the Bloom filter
- * {@link org.apache.commons.collections4.bloomfilter.hasher.HashFunction HashFunction} interface.
- *
- * @since 4.5
- */
-package org.apache.commons.collections4.bloomfilter.hasher.function;
+package org.apache.commons.collections4.bloomfilter.exceptions;","[{'comment': 'Missing newline.', 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java,"@@ -356,9 +239,31 @@ private void add(final int idx, final int addend) {
      * @param idx the index
      * @param subtrahend the amount to subtract
      */
-    private void subtract(final int idx, final int subtrahend) {
+    protected void subtract(final int idx, final int subtrahend) {
         final int updated = counts[idx] - subtrahend;
         state |= updated;
         counts[idx] = updated;
     }
+
+
+    @Override
+    public Shape getShape() {
+        return shape;
+    }
+
+    @Override
+    public boolean contains(IndexProducer indexProducer) {
+        try {
+            indexProducer.forEachIndex( idx -> {if ( this.counts[idx] == 0  ) { throw new NoMatchException(); }} );","[{'comment': 'Maybe instead of `throw new NoMatchException()`, just `return false` here?', 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -16,44 +16,55 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
 import org.apache.commons.collections4.bloomfilter.hasher.Hasher;
-import org.apache.commons.collections4.bloomfilter.hasher.Shape;
-import org.apache.commons.collections4.bloomfilter.hasher.StaticHasher;
 
 /**
  * The interface that describes a Bloom filter.
  * @since 4.5
  */
-public interface BloomFilter {
+public interface BloomFilter extends IndexProducer, BitMapProducer {
 
-    // Query Operations
+    /**
+     * Return the Bloom filter data as a BitMap array.
+     * @param filter the filter to get the data from.
+     * @return An array of BitMap long.
+     */
+    public static long[] asBitMapArray( BloomFilter filter ) {
+        BitMapProducer.ArrayBuilder builder = new BitMapProducer.ArrayBuilder(filter.getShape());
+        filter.forEachBitMap( builder );
+        return builder.getArray();
+    }
 
     /**
-     * Gets the shape of this filter.
-     *
-     * @return the shape of this filter
+     * Return the Bloom filter data as an array of indices for the enabled bits.
+     * @param filter the Filter to get the data from.
+     * @return An array of indices for enabled bits in the Bloom filter.
      */
-    Shape getShape();
+    public static int[] asIndexArray( BloomFilter filter ) {
+        List<Integer> lst = new ArrayList<Integer>();
+        filter.forEachIndex( lst::add );
+        return lst.stream().mapToInt( Integer::intValue ).toArray();
+    }
+
+
+    // Query Operations
 
     /**
-     * Gets an array of little-endian long values representing the bits of this filter.
-     *
-     * <p>The returned array will have length {@code ceil(m / 64)} where {@code m} is the
-     * number of bits in the filter and {@code ceil} is the ceiling function.
-     * Bits 0-63 are in the first long. A value of 1 at a bit position indicates the bit
-     * index is enabled.
-     *
-     * @return the {@code long[]} representation of this filter
+     * This method is used to determine the best method for matching.  For `sparse` implementations the `getIndices()`","[{'comment': 'Not sure if it changed in Javadoc, but normally \\`sparse\\` would be written as `{@code sparse}` (ditto for \\`getIndices()\\`).', 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -16,44 +16,55 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
 import org.apache.commons.collections4.bloomfilter.hasher.Hasher;
-import org.apache.commons.collections4.bloomfilter.hasher.Shape;
-import org.apache.commons.collections4.bloomfilter.hasher.StaticHasher;
 
 /**
  * The interface that describes a Bloom filter.
  * @since 4.5
  */
-public interface BloomFilter {
+public interface BloomFilter extends IndexProducer, BitMapProducer {
 
-    // Query Operations
+    /**
+     * Return the Bloom filter data as a BitMap array.
+     * @param filter the filter to get the data from.
+     * @return An array of BitMap long.
+     */
+    public static long[] asBitMapArray( BloomFilter filter ) {
+        BitMapProducer.ArrayBuilder builder = new BitMapProducer.ArrayBuilder(filter.getShape());
+        filter.forEachBitMap( builder );
+        return builder.getArray();
+    }
 
     /**
-     * Gets the shape of this filter.
-     *
-     * @return the shape of this filter
+     * Return the Bloom filter data as an array of indices for the enabled bits.
+     * @param filter the Filter to get the data from.
+     * @return An array of indices for enabled bits in the Bloom filter.
      */
-    Shape getShape();
+    public static int[] asIndexArray( BloomFilter filter ) {
+        List<Integer> lst = new ArrayList<Integer>();
+        filter.forEachIndex( lst::add );
+        return lst.stream().mapToInt( Integer::intValue ).toArray();
+    }
+
+
+    // Query Operations
 
     /**
-     * Gets an array of little-endian long values representing the bits of this filter.
-     *
-     * <p>The returned array will have length {@code ceil(m / 64)} where {@code m} is the
-     * number of bits in the filter and {@code ceil} is the ceiling function.
-     * Bits 0-63 are in the first long. A value of 1 at a bit position indicates the bit
-     * index is enabled.
-     *
-     * @return the {@code long[]} representation of this filter
+     * This method is used to determine the best method for matching.  For `sparse` implementations the `getIndices()`
+     * method is more efficient.  Implementers should determine if it is easier for the implementation to return am array of","[{'comment': '/am/an', 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -62,56 +73,131 @@
      * effectively {@code (this AND other) == other}.
      *
      * @param other the other Bloom filter
-     * @return true if this filter is enabled for all enabled bits in the other filter
-     * @throws IllegalArgumentException if the shape of the other filter does not match
-     * the shape of this filter
+     * @return true if all enabled bits in the other filter are enabled in this filter.
      */
-    boolean contains(BloomFilter other);
+    default boolean contains(BloomFilter other) {
+        Objects.requireNonNull( other, ""other"");
+        return isSparse() ? contains( (IndexProducer) other) :
+            contains( (BitMapProducer) other );
+    }
 
     /**
-     * Returns {@code true} if this filter contains the specified decomposed Bloom filter.
+     * Returns {@code true} if this filter contains the bits specified in the hasher.
      * Specifically this returns {@code true} if this filter is enabled for all bit indexes
-     * identified by the {@code hasher}. Using the bit representations this is
+     * identified by the {@code hasher}. Using the BitMap representations this is
      * effectively {@code (this AND hasher) == hasher}.
      *
      * @param hasher the hasher to provide the indexes
      * @return true if this filter is enabled for all bits specified by the hasher
      * @throws IllegalArgumentException if the hasher cannot generate indices for the shape of
      * this filter
      */
-    boolean contains(Hasher hasher);
+    default boolean contains(Hasher hasher) {
+        Objects.requireNonNull( hasher, ""Hasher"");
+        Shape shape = getShape();
+        return contains( hasher.indices(shape));
+    }
 
-    // Modification Operations
+    /**
+     * Returns {@code true} if this filter contains the indices specified IndexProducer.
+     * Specifically this returns {@code true} if this filter is enabled for all bit indexes
+     * identified by the {@code IndexProducer}.
+     *
+     * @param indexProducer the IndexProducer to provide the indexes
+     * @return true if this filter is enabled for all bits specified by the IndexProducer
+     */
+    boolean contains(IndexProducer indexProducer);
 
     /**
-     * Merges the specified Bloom filter into this Bloom filter. Specifically all bit indexes
-     * that are enabled in the {@code other} filter will be enabled in this filter.
+     * Returns {@code true} if this filter contains the bits specified in the BitMaps produced by the
+     * bitMapProducer.
+     *
+     * @param bitMapProducer the the {@code BitMapProducer} to provide the BitMaps.
+     * @return true if this filter is enabled for all bits specified by the BitMaps
+     */
+    boolean contains(BitMapProducer bitMapProducer);
+
+    /**
+     * Merges the specified Bloom filter with this Bloom filter creating a new Bloom filter.
+     * Specifically all bit indexes that are enabled in the {@code other} and in @code this} filter will be
+     * enabled in the resulting filter.
+     *
+     * @param other the other Bloom filter
+     * @return The new Bloom filter.
+     */
+    default BloomFilter merge(BloomFilter other) {
+        Objects.requireNonNull( other, ""other"");
+        Shape shape = getShape();
+        BloomFilter result = BitMap.isSparse( (cardinality() + other.cardinality()), getShape() ) ?
+                new SparseBloomFilter(shape) :
+                    new SimpleBloomFilter(shape);","[{'comment': 'Wrong indentation? :point_up: not matching the other `?` statement alignment.', 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java,"@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Objects;
+import java.util.function.IntConsumer;
+import java.util.function.LongConsumer;
+
+import org.apache.commons.collections4.bloomfilter.exceptions.NoMatchException;
+import org.apache.commons.collections4.bloomfilter.hasher.Hasher;
+
+/**
+ * A bloom filter using an array of BitMaps to track enabled bits. This is a standard
+ * implementation and should work well for most Bloom filters.
+ * @since 4.5
+ */
+public class SimpleBloomFilter implements BloomFilter {
+
+    /**
+     * The array of BitMap longs that defines this Bloom filter.
+     */
+    private long[] bitMap;
+
+    /**
+     * The Shape of this Bloom filter
+     */
+    private final Shape shape;
+
+    /**
+     * The cardinality of this Bloom filter.
+     */
+    private int cardinality;
+
+    /**
+     * Constructs an empty BitSetBloomFilter.
+     *
+     */
+    public SimpleBloomFilter(Shape shape) {
+        Objects.requireNonNull( shape, ""shape"");
+        this.shape = shape;
+        this.bitMap = new long[0];
+        this.cardinality = 0;
+    }
+
+    /**
+     * Constructor.
+     * @param shape The shape for the filter.
+     * @param hasher the Hasher to initialize the filter with.
+     */
+    public SimpleBloomFilter(final Shape shape, Hasher hasher) {
+        Objects.requireNonNull( shape, ""shape"");
+        Objects.requireNonNull( hasher, ""hasher"");
+        this.shape = shape;
+
+        BitMapProducer producer = BitMapProducer.fromIndexProducer( hasher.indices(shape), shape);
+        BitMapProducer.ArrayBuilder builder = new BitMapProducer.ArrayBuilder(shape);
+        producer.forEachBitMap( builder );
+        this.bitMap = builder.getArray();
+        this.cardinality = 0;
+        forEachBitMap( w -> this.cardinality += Long.bitCount(w));
+    }
+
+    @Override
+    public boolean mergeInPlace(BloomFilter other) {
+        Objects.requireNonNull( other, ""other"");
+        BitMapProducer.ArrayBuilder builder = new BitMapProducer.ArrayBuilder(shape, this.bitMap);
+        other.forEachBitMap( builder );
+        this.bitMap = builder.getArray();
+        this.cardinality = 0;
+        forEachBitMap( w -> this.cardinality += Long.bitCount(w));
+        return true;
+    }
+
+    @Override
+    public Shape getShape() {
+        return shape;
+    }
+
+    @Override
+    public boolean isSparse() {
+        return false;
+    }
+
+    @Override
+    public int cardinality() {
+        return this.cardinality;
+    }
+
+    @Override
+    public void forEachIndex(IntConsumer consumer) {
+        Objects.requireNonNull( consumer, ""consumer"");
+        IndexProducer.fromBitMapProducer(this).forEachIndex(consumer);
+    }
+
+    @Override
+    public void forEachBitMap(LongConsumer consumer) {
+        Objects.requireNonNull( consumer, ""consumer"");
+        for ( long l : bitMap ) {
+            consumer.accept(l);
+        }
+    }
+
+    @Override
+    public boolean contains(IndexProducer indexProducer) {
+        return contains( BitMapProducer.fromIndexProducer(indexProducer, shape));
+    }
+
+
+    @Override
+    public boolean contains(BitMapProducer bitMapProducer) {
+        LongConsumer consumer = new LongConsumer() {
+            int i=0;
+            @Override
+            public void accept(long w) {
+                if ((bitMap[i++] & w) != w)
+                { throw new NoMatchException();","[{'comment': 'Move the `{` to the same line as the `if`, and fix the `throw` indentation?', 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java,"@@ -155,10 +99,13 @@
     boolean remove(BloomFilter other);
 
     /**
-     * Removes the specified decomposed Bloom filter from this Bloom filter. Specifically
+     * Removes the specified hasher from the Bloom filter from this Bloom filter. Specifically
      * all counts for the <em>distinct</em> indexes identified by the {@code hasher} will be
      * decremented by 1. If the {@code hasher} contains duplicate bit indexes these are ignored.
      *
+     * For HasherCollections each SimpleHasher will be considered a single item and decremented","[{'comment': 'Add `<p>` for this paragraph?', 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java,"@@ -169,33 +116,63 @@
      */
     boolean remove(Hasher hasher);
 
+
     /**
-     * Adds the specified counting Bloom filter to this Bloom filter. Specifically
-     * all counts for the indexes identified by the {@code other} filter will be incremented
-     * by their corresponding counts in the {@code other} filter.
+     * Adds the specified BitCountProducer to this Bloom filter. Specifically
+     * all counts for the indexes identified by the {@code other} will be incremented
+     * by their corresponding values in the {@code other}.
      *
-     * <p>This method will return true if the filter is valid after the operation.
+     * <p>This method will return true if the filter is valid after the operation.</p>
      *
-     * @param other the other counting Bloom filter
+     * @param other the BitCountProducer to add.
      * @return true if the addition was successful and the state is valid
-     * @throws IllegalArgumentException if the shape of the other filter does not match
-     * the shape of this filter
      * @see #isValid()
      */
-    boolean add(CountingBloomFilter other);
+    boolean add(BitCountProducer other);
 
     /**
-     * Adds the specified counting Bloom filter to this Bloom filter. Specifically
-     * all counts for the indexes identified by the {@code other} filter will be decremented
-     * by their corresponding counts in the {@code other} filter.
+     * Adds the specified BitCountProducer to this Bloom filter. Specifically
+     * all counts for the indexes identified by the {@code other} will be decremented
+     * by their corresponding values in the {@code other}.
      *
-     * <p>This method will return true if the filter is valid after the operation.
+     * <p>This method will return true if the filter is valid after the operation.</p>
      *
-     * @param other the other counting Bloom filter
+     * @param other the BitCountProducer to subtract.
      * @return true if the subtraction was successful and the state is valid
-     * @throws IllegalArgumentException if the shape of the other filter does not match
-     * the shape of this filter
      * @see #isValid()
      */
-    boolean subtract(CountingBloomFilter other);
+    boolean subtract(BitCountProducer other);
+
+    /**
+     * Merges the specified Bloom filter into this Bloom filter to produce a new CountingBloomFilter.
+     * Specifically the new Bloom filter will contain all the counts of this filter and in addition
+     * all bit indexes that are enabled in the {@code other} filter will be incremented
+     * by one in the new filter.
+     *
+     * <p>Note: the validity of the resulting filter is not guaranteed.  When in doubt {@code isValid()}
+     * should be called on the new filter.</p>
+     *
+     * @param other the other Bloom filter
+     * @return A new CountingBloomFilter instance.
+     */
+    @Override
+    CountingBloomFilter merge(BloomFilter other);
+
+    /**
+     * Merges the specified hasher with this Bloom filter to create a new CountingBloomFilter.
+     * Specifically the new Bloom filter will contain all the counts of this filter and in addition
+     * all bit indexes specified by the {@code hasher} will be incremented
+     * by one in the new filter.
+     *
+     * For HasherCollections each SimpleHasher will be considered a single item and increment","[{'comment': 'New `<p>` for this paragraph?', 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java,"@@ -0,0 +1,455 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Objects;
+
+/**
+ * The definition of a Bloom filter shape.
+ *
+ * <p> This class contains the values for the filter configuration and is used to
+ * convert a Hasher into a BloomFilter as well as verify that two Bloom filters are
+ * compatible. (i.e. can be compared or merged)</p>
+ *
+ * <h2>Interrelatedness of values</h2>
+ *
+ * <dl> <dt>Number of Items ({@code n})</dt>
+ * <dd>{@code n = ceil(m / (-k / ln(1 - exp(ln(p) / k))))}</dd> <dt>Probability of
+ * False Positives ({@code p})</dt> <dd>{@code p = pow(1 - exp(-k / (m / n)), k)}</dd> <dt>Number
+ * of Bits ({@code m})</dt>
+ * <dd>{@code m = ceil((n * ln(p)) / ln(1 / pow(2, ln(2))))}</dd> <dt>Number of
+ * Functions ({@code k})</dt> <dd>{@code k = round((m / n) * ln(2))}</dd> </dl>
+ *
+ * @see <a href=""http://hur.st/bloomfilter?n=3&p=1.0E-5"">Bloom Filter calculator</a>
+ * @see <a href=""https://en.wikipedia.org/wiki/Bloom_filter"">Bloom filter
+ * [Wikipedia]</a>
+ * @since 4.5
+ */
+public final class Shape {
+
+    /**
+     * Number of hash functions to create a filter ({@code k}).
+     */
+    private final int numberOfHashFunctions;
+
+    /**
+     * Number of bits in the filter ({@code m}).
+     */
+    private final int numberOfBits;
+
+    /**
+     * Constructs a filter configuration with the specified number of items ({@code n}) and
+     * bits ({@code m}).
+     *
+     * <p>The optimal number of hash functions ({@code k}) is computed.
+     * <pre>k = round((m / n) * ln(2))</pre>
+     *
+     * <p>The false-positive probability is computed using the number of items, bits and hash
+     * functions. An exception is raised if this is greater than or equal to 1 (i.e. the
+     * shape is invalid for use as a Bloom filter).
+     *
+     * @param numberOfHashFunctions Number of hash functions to use for each item placed in the filter.
+     * @param numberOfBits The number of bits in the filter
+     * @throws IllegalArgumentException if {@code numberOfHashFunctions < 1} or {@code numberOfBits < 1}
+     */
+    public Shape(final int numberOfHashFunctions, final int numberOfBits) {
+        this.numberOfBits = checkNumberOfBits(numberOfBits);
+        this.numberOfHashFunctions = checkNumberOfHashFunctions(numberOfHashFunctions);
+    }
+
+    /**
+     * Check number of bits is strictly positive.
+     *
+     * @param numberOfBits the number of bits
+     * @return the number of bits
+     * @throws IllegalArgumentException if the number of bits is {@code < 1}
+     */
+    private static int checkNumberOfBits(final int numberOfBits) {
+        if (numberOfBits < 1) {
+            throw new IllegalArgumentException(""Number of bits must be greater than 0: "" + numberOfBits);
+        }
+        return numberOfBits;
+    }
+
+    /**
+     * Check number of hash functions is strictly positive
+     *
+     * @param numberOfHashFunctions the number of hash functions
+     * @return the number of hash functions
+     * @throws IllegalArgumentException if the number of hash functions is {@code < 1}
+     */
+    private static int checkNumberOfHashFunctions(final int numberOfHashFunctions) {
+        if (numberOfHashFunctions < 1) {
+            throw new IllegalArgumentException(""Number of hash functions must be greater than 0: "" + numberOfHashFunctions);
+        }
+        return numberOfHashFunctions;
+    }
+
+    @Override
+    public boolean equals(final Object o) {
+        if (o instanceof Shape) {
+            final Shape other = (Shape) o;
+            return numberOfBits == other.numberOfBits &&
+                    numberOfHashFunctions == other.numberOfHashFunctions;
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(numberOfBits, numberOfHashFunctions);
+    }
+
+    /**
+     * Gets the number of bits in the Bloom filter.
+     * This is also known as {@code m}.
+     *
+     * @return the number of bits in the Bloom filter ({@code m}).
+     */
+    public int getNumberOfBits() {
+        return numberOfBits;
+    }
+
+
+    /**
+     * Gets the number of hash functions used to construct the filter.
+     * This is also known as {@code k}.
+     *
+     * @return the number of hash functions used to construct the filter ({@code k}).
+     */
+    public int getNumberOfHashFunctions() {
+        return numberOfHashFunctions;
+    }
+
+
+    /**
+     * Calculates the probability of false positives ({@code p}) given
+     * numberOfItems ({@code n}), numberOfBits ({@code m}) and numberOfHashFunctions ({@code k}).
+     * <pre>p = pow(1 - exp(-k / (m / n)), k)</pre>
+     *
+     * <p>This is the probability that a Bloom filter will return true for the presence of an item
+     * when it does not contain the item.
+     *
+     * <p>The probability assumes that the Bloom filter is filled with the expected number of
+     * items. If the filter contains fewer items then the actual probability will be lower.
+     * Thus this returns the worst-case false positive probability for a filter that has not
+     * exceeded its expected number of items.
+     *
+     * @param numberOfItems the number of items hashed into the Bloom filter.
+     * @return the probability of false positives.
+     * @see #getNumberOfItems()
+     */
+    public double getProbability(int numberOfItems) {
+        if (numberOfItems < 0) {
+            throw new IllegalArgumentException(""Number of items must be greater than or equal to 0: "" + numberOfItems);
+        }
+        if (numberOfItems == 0) {
+            return 0;
+        }
+        return Math.pow(1.0 - Math.exp(-1.0 * numberOfHashFunctions * numberOfItems / numberOfBits),
+                numberOfHashFunctions);
+    }
+
+    @Override
+    public String toString() {
+        return String.format(""Shape[ m=%s k=%s ]"",
+                numberOfBits, numberOfHashFunctions);
+    }
+
+    /**
+     * Estimate the number of items in a Bloom filter with this shape and the specified number of bits enabled.
+     * @param hammingValue the number of enabled  bits.
+     * @return An estimate of the number of items in the Bloom filter.
+     */
+    public double estimateN( int hammingValue ) {
+        double c = hammingValue;
+        double m = numberOfBits;
+        double k = numberOfHashFunctions;
+        return  -(m / k) * Math.log(1.0 - (c / m));
+    }
+
+    /**
+     * The factory to assist in the creation of proper Shapes.
+     *
+     * In the methods of this factory the `fraom` names are appended with the standard variable","[{'comment': 'add a `<p>`?', 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java,"@@ -18,101 +18,78 @@
 /**
  * A collection of extensible Bloom filter classes and interfaces.
  *
- * <h2>
- *  Background:</h2>
- *  <p>
- *  A Bloom filter is conceptually a bit vector. It is used to
- * tell you where things are not. Basically, you create a Bloom filter by creating hashes
- * and converting those to enabled bits in a vector. You can merge the Bloom filters
- * together with logical ""or"" (call this filter ""B""). You can then check to see if filter
- * ""A"" was ""or""ed into ""B"" by testing A &amp; B == A. if the statement is false then ""A"" was
- * not merged into ""B"", otherwise it _might_ have. They are generally used where hash
- * tables would be too large or as a filter front end for longer processes. For example
+ * <h2>Background:</h2>
+ *
+ * <p>The Bloom filter is a probabilistic data structure that indicates where things are not.
+ * Conceptually it is a a bit vector. You create a Bloom filter by creating hashes
+ * and converting those to enabled bits in the vector. Multiple Bloom filters may be merged
+ * together into one Bloom filter.  It is possible to test if a filter {@code B} as merged into
+ * another filter {@code A} by verifying that {@code (A & B) == B}.</p>
+ *
+ * <p>Bloom filters are generally used where hash
+ * tables would be too large, or as a filter front end for longer processes. For example
  * most browsers have a Bloom filter that is built from all known bad URLs (ones that
  * serve up malware). When you enter a URL the browser builds a Bloom filter and checks to
  * see if it is ""in"" the bad URL filter. If not the URL is good, if it matches, then the
  * expensive lookup on a remote system is made to see if it actually is in the list. There
  * are lots of other uses, and in most cases the reason is to perform a fast check as a
  * gateway for a longer operation. </p>
- *  <h3>
- *  BloomFilter</h3>
- *  <p>
- *  The bloom filter code is
- * an abstract class that requires implementation of 4 methods: <ul>
- *  <li>
- *  getBits() which
- * returns the set bits as a buffer encoded into an array of long.</li>
- *  <li>
- *  getHasher()
- * which returns a list of integers that are indexes of the bits that are enabled. These
- * are returned in a Hasher construct.</li>
- *  <li>
- *  merge( BloomFilter ) to merge another
- * Bloom filter into this one.</li>
- *  <li>
- *  merge( Hasher ) to merge the values in a hasher
- * into this Bloom filter.</li>
- *  </ul>
- *  There are 3 implementations of Bloom filter
- * provided: <ul>
- *  <li>
- *  BitSetBloomFilter - based on the Java BitSet class.</li>
- *  <li>
- *
- * CountingBloomFilter - uses a sparse array of integers (Map) to implement a counting
- * Bloom filter. This filter also implements remove() methods as that is the great
- * advantage of a counting Bloom filter.</li>
- *  <li>
- *  HasherBloomFilter - implements bloom
- * filter on a Hasher. A rather slow implementation but convenient in some
- * situations.</li>
- *  </ul>
- *
- *  <h3>
- *  Shape</h3>
- *  <p>
- *  Describes the Bloom filter using the
- * standard number of bits, number of hash functions and number of items along with a
- * description of the HashFunction. It is this description that has caused the most issues
- * of late. </p>
- *  <h3>
- *  Hasher</h3>
- *  <p>
- *  converts byte buffers into an iterator if int based
- * on a Shape. There are 2 implementations of Hasher provided <ul>
- *  <li>
- *  Dynamic - calls
- * the HashFunction for each value required in the Bloom filter.</li>
- *  <li>
- *  Static - based
- * on a pre-calculated list of Bloom filter index values. It is also limited to generating
- * values for a specific Shape.</li>
- *  </ul>
- *
- *  <h3>
- *  Hash Functions</h3>
- *  <p>
- *  Hash
- * functions generate individual index values for the filter from a byte buffer. There are
- * four implementations provided. </p>
- *  <h3>
- *  HashFunctionIdentity</h3>
- *  <p>
- *  The
- * HashFunctionIdentity is the base interface for the HashFunction. It tracks three (3)
- * properties: <ul>
- *  <li>
- *  The Hashing algorithm</li>
- *  <li>
- *  Whether the contents of the
- * resulting hash buffer are read as signed or unsigned values.</li>
- *  <li>
- *  Whether the hash
- * function uses an iterative or cyclic method. In traditional iterative methods this is
- * done by calling the selected hash function with a different seed for each hash
- * required. The second method described by Adam Kirsch and Micheal Mitzenmacher[1] has
- * become more common and is used in applications like Cassandra[2].</li>
- *  </ul>
+ *
+ * <h3>BloomFilter</h3>
+ *
+ * <p>The Bloom filter architecture here is designed so that the implementation of the storage of bit is abstracted.
+ * Programs that utilize the Bloom filters may use the {@code BitMapProducer} or {@code IndexProducer} to retrieve a
+ * representation of the internal structure.  Additional methods are available in the {@code BitMap} to assist in
+ * manipulation of the representations.</p>
+ *
+ * <p>The bloom filter code is an interface that requires implementation of 6 methods:</p>
+ * <ul>
+ * <li>{@code cardinality()}
+ * returns the number of bits enabled in the Bloom filter.</li>
+ *
+ * <li>{@code contains(BitMapProducer)} which
+ * returns true if the bits specified by the BitMaps generated by the BitMapProducer are enabled in the Bloom filter.</li>
+ *
+ *  <li>{@code contains(IndexProducer)} which
+ * returns true if the bits specified by the Indices generated  by IndexProducer are enabled in the Bloom filter.</li>
+ *
+ * <li>{@code getShape()} which
+ * returns shape the Bloom filter was created with.</li>
+
+ * <li>{@code isSparse()} which
+ * returns true if an the implementation tracks indices natively, false if BitMaps are used.  In cases where
+ * neither are used the {@code isSparse} return value should reflect which is faster to produce.</li>
+ *
+ * <li>{@code mergeInPlace(BloomFilter)} which
+ * utilizes either the {@code BitMapProducer} or {@code IndexProducer} from the argument to enable extra bits
+ * in the internal representation of the Bloom filter..</li>
+ * </ul>
+ *
+ * <p>Other methods should be implemented where they can be done so more efficiently than the default implementations.
+ * </p>
+ *
+ * <h3>CountingBloomFilter</h3>
+ *
+ * <p>The counting bloom filter extends the Bloom filter by counting the number of times a specific bit has been
+ * enabled or disabled.  This allows the removal (opposite of merge) of Bloom filters at the expense of additional
+ * overhead.</p>
+ *
+ * <h3>Shape</h3>
+ *
+ * <p>The Shape describes the Bloom filter using the number of bits and the number of hash functions</p>
+ *
+ * <h3>Hasher</h3>
+ *
+ * <p>A Hasher converts bytes into an series of integers based on a Shape.  With the exception of the HasherCollecton,
+ *  Each hasher represents one item being added to the Bloom filter.  The HasherCollection represents the
+ *  number of items as the sum of the number of items represented by the Hashers in the collection.</p>
+ *
+ *  <p>The SimpleHasher uses a combinatorial generation technique to create the integers. It is easily
+ *  initialized by using a standard {@code MessageDigest} or other Hash function to hash the item to insert and
+ *  then splitting the hash bytes in half and considering each as a long value.</p>
+ *
+ *  <p>Other implementations of the Hasher are easy to implement, and should make use of the {@code Hahser.Filter}","[{'comment': 's/Hahser/Hasher', 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java,"@@ -18,101 +18,78 @@
 /**
  * A collection of extensible Bloom filter classes and interfaces.
  *
- * <h2>
- *  Background:</h2>
- *  <p>
- *  A Bloom filter is conceptually a bit vector. It is used to
- * tell you where things are not. Basically, you create a Bloom filter by creating hashes
- * and converting those to enabled bits in a vector. You can merge the Bloom filters
- * together with logical ""or"" (call this filter ""B""). You can then check to see if filter
- * ""A"" was ""or""ed into ""B"" by testing A &amp; B == A. if the statement is false then ""A"" was
- * not merged into ""B"", otherwise it _might_ have. They are generally used where hash
- * tables would be too large or as a filter front end for longer processes. For example
+ * <h2>Background:</h2>
+ *
+ * <p>The Bloom filter is a probabilistic data structure that indicates where things are not.
+ * Conceptually it is a a bit vector. You create a Bloom filter by creating hashes
+ * and converting those to enabled bits in the vector. Multiple Bloom filters may be merged
+ * together into one Bloom filter.  It is possible to test if a filter {@code B} as merged into
+ * another filter {@code A} by verifying that {@code (A & B) == B}.</p>
+ *
+ * <p>Bloom filters are generally used where hash
+ * tables would be too large, or as a filter front end for longer processes. For example
  * most browsers have a Bloom filter that is built from all known bad URLs (ones that
  * serve up malware). When you enter a URL the browser builds a Bloom filter and checks to
  * see if it is ""in"" the bad URL filter. If not the URL is good, if it matches, then the
  * expensive lookup on a remote system is made to see if it actually is in the list. There
  * are lots of other uses, and in most cases the reason is to perform a fast check as a
  * gateway for a longer operation. </p>
- *  <h3>
- *  BloomFilter</h3>
- *  <p>
- *  The bloom filter code is
- * an abstract class that requires implementation of 4 methods: <ul>
- *  <li>
- *  getBits() which
- * returns the set bits as a buffer encoded into an array of long.</li>
- *  <li>
- *  getHasher()
- * which returns a list of integers that are indexes of the bits that are enabled. These
- * are returned in a Hasher construct.</li>
- *  <li>
- *  merge( BloomFilter ) to merge another
- * Bloom filter into this one.</li>
- *  <li>
- *  merge( Hasher ) to merge the values in a hasher
- * into this Bloom filter.</li>
- *  </ul>
- *  There are 3 implementations of Bloom filter
- * provided: <ul>
- *  <li>
- *  BitSetBloomFilter - based on the Java BitSet class.</li>
- *  <li>
- *
- * CountingBloomFilter - uses a sparse array of integers (Map) to implement a counting
- * Bloom filter. This filter also implements remove() methods as that is the great
- * advantage of a counting Bloom filter.</li>
- *  <li>
- *  HasherBloomFilter - implements bloom
- * filter on a Hasher. A rather slow implementation but convenient in some
- * situations.</li>
- *  </ul>
- *
- *  <h3>
- *  Shape</h3>
- *  <p>
- *  Describes the Bloom filter using the
- * standard number of bits, number of hash functions and number of items along with a
- * description of the HashFunction. It is this description that has caused the most issues
- * of late. </p>
- *  <h3>
- *  Hasher</h3>
- *  <p>
- *  converts byte buffers into an iterator if int based
- * on a Shape. There are 2 implementations of Hasher provided <ul>
- *  <li>
- *  Dynamic - calls
- * the HashFunction for each value required in the Bloom filter.</li>
- *  <li>
- *  Static - based
- * on a pre-calculated list of Bloom filter index values. It is also limited to generating
- * values for a specific Shape.</li>
- *  </ul>
- *
- *  <h3>
- *  Hash Functions</h3>
- *  <p>
- *  Hash
- * functions generate individual index values for the filter from a byte buffer. There are
- * four implementations provided. </p>
- *  <h3>
- *  HashFunctionIdentity</h3>
- *  <p>
- *  The
- * HashFunctionIdentity is the base interface for the HashFunction. It tracks three (3)
- * properties: <ul>
- *  <li>
- *  The Hashing algorithm</li>
- *  <li>
- *  Whether the contents of the
- * resulting hash buffer are read as signed or unsigned values.</li>
- *  <li>
- *  Whether the hash
- * function uses an iterative or cyclic method. In traditional iterative methods this is
- * done by calling the selected hash function with a different seed for each hash
- * required. The second method described by Adam Kirsch and Micheal Mitzenmacher[1] has
- * become more common and is used in applications like Cassandra[2].</li>
- *  </ul>
+ *
+ * <h3>BloomFilter</h3>
+ *
+ * <p>The Bloom filter architecture here is designed so that the implementation of the storage of bit is abstracted.
+ * Programs that utilize the Bloom filters may use the {@code BitMapProducer} or {@code IndexProducer} to retrieve a
+ * representation of the internal structure.  Additional methods are available in the {@code BitMap} to assist in
+ * manipulation of the representations.</p>
+ *
+ * <p>The bloom filter code is an interface that requires implementation of 6 methods:</p>
+ * <ul>
+ * <li>{@code cardinality()}
+ * returns the number of bits enabled in the Bloom filter.</li>
+ *
+ * <li>{@code contains(BitMapProducer)} which
+ * returns true if the bits specified by the BitMaps generated by the BitMapProducer are enabled in the Bloom filter.</li>
+ *
+ *  <li>{@code contains(IndexProducer)} which
+ * returns true if the bits specified by the Indices generated  by IndexProducer are enabled in the Bloom filter.</li>
+ *
+ * <li>{@code getShape()} which
+ * returns shape the Bloom filter was created with.</li>
+
+ * <li>{@code isSparse()} which
+ * returns true if an the implementation tracks indices natively, false if BitMaps are used.  In cases where
+ * neither are used the {@code isSparse} return value should reflect which is faster to produce.</li>
+ *
+ * <li>{@code mergeInPlace(BloomFilter)} which
+ * utilizes either the {@code BitMapProducer} or {@code IndexProducer} from the argument to enable extra bits
+ * in the internal representation of the Bloom filter..</li>
+ * </ul>
+ *
+ * <p>Other methods should be implemented where they can be done so more efficiently than the default implementations.
+ * </p>
+ *
+ * <h3>CountingBloomFilter</h3>
+ *
+ * <p>The counting bloom filter extends the Bloom filter by counting the number of times a specific bit has been
+ * enabled or disabled.  This allows the removal (opposite of merge) of Bloom filters at the expense of additional
+ * overhead.</p>
+ *
+ * <h3>Shape</h3>
+ *
+ * <p>The Shape describes the Bloom filter using the number of bits and the number of hash functions</p>
+ *
+ * <h3>Hasher</h3>
+ *
+ * <p>A Hasher converts bytes into an series of integers based on a Shape.  With the exception of the HasherCollecton,
+ *  Each hasher represents one item being added to the Bloom filter.  The HasherCollection represents the
+ *  number of items as the sum of the number of items represented by the Hashers in the collection.</p>
+ *
+ *  <p>The SimpleHasher uses a combinatorial generation technique to create the integers. It is easily
+ *  initialized by using a standard {@code MessageDigest} or other Hash function to hash the item to insert and
+ *  then splitting the hash bytes in half and considering each as a long value.</p>
+ *
+ *  <p>Other implementations of the Hasher are easy to implement, and should make use of the {@code Hahser.Filter}
+ *  and/r {@code Hahser.FileredIntConsumer} classes to filter out duplicate indices.</p>","[{'comment': 's/Hahser/Hasher', 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/package-info.java,"@@ -16,10 +16,64 @@
  */
 
 /**
- * Provides classes and interfaces to define the shape of a Bloom filter and the conversion
- * of generic bytes to a hash of bit indexes to be used with a Bloom filter.
+ * Hasher implementations and tools.
  *
+ *
+ * <h2>Hasher</h2>
+ *
+ * <p>A Hasher converts one or more items into an {@code IndexProducer} series of integers based on a {@code Shape}.
+ *
+ *
+ * The base Hasher implementations
+ * are as follows:</p>
+ *
+ *  <h3>SimpleHasher</h3>
+ *
+ *  <p>The SimpleHasher represents one item being added to the Bloom filter.  It utilizes the combinatorial strategy
+ *  as described by <a href='https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf'>Krisch and Mitzenmacher</a>.
+ *  Generally, a hash value is created by hashing together multiple properties of the item being added. The hash value is
+ *  then used to create a SimpleHasher.</p>
+ *
+ *  <p>This hasher represents a single item and thus does not return duplicate indices.</p>
+ *
+ *  <h3>HasherCollection</h3>
+ *
+ *  <p>The HasherCollection is a collection of Hashers that implements the Hasher interface.  Each hasher within the collection
+ *  represents a single item, or in the case of a HasherCollections multiple items.</p>
+ *
+ *  <p>This hahser represents multiple items and thus may return duplicate indices.</p>","[{'comment': 's/hahser/hasher', 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/package-info.java,"@@ -16,10 +16,64 @@
  */
 
 /**
- * Provides classes and interfaces to define the shape of a Bloom filter and the conversion
- * of generic bytes to a hash of bit indexes to be used with a Bloom filter.
+ * Hasher implementations and tools.
  *
+ *
+ * <h2>Hasher</h2>
+ *
+ * <p>A Hasher converts one or more items into an {@code IndexProducer} series of integers based on a {@code Shape}.
+ *
+ *
+ * The base Hasher implementations
+ * are as follows:</p>
+ *
+ *  <h3>SimpleHasher</h3>
+ *
+ *  <p>The SimpleHasher represents one item being added to the Bloom filter.  It utilizes the combinatorial strategy
+ *  as described by <a href='https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf'>Krisch and Mitzenmacher</a>.
+ *  Generally, a hash value is created by hashing together multiple properties of the item being added. The hash value is
+ *  then used to create a SimpleHasher.</p>
+ *
+ *  <p>This hasher represents a single item and thus does not return duplicate indices.</p>
+ *
+ *  <h3>HasherCollection</h3>
+ *
+ *  <p>The HasherCollection is a collection of Hashers that implements the Hasher interface.  Each hasher within the collection
+ *  represents a single item, or in the case of a HasherCollections multiple items.</p>
+ *
+ *  <p>This hahser represents multiple items and thus may return duplicate indices.</p>
+ *
+ *  <h3>SingleItemHasherCollection</h3>
+ *
+ *  <p>A collection of Hashers that are combined to represent a single item.  Like the HasherCollection this Hasher is composed
+ *  of multiple Hashers.  Unlike the HasherCollection, this hasher reports that it is only one item.</p>
+ *
+ *
+ *  <p>This hasher represents a single item and thus does not return duplicate indices.</p>
+ *
+ *  <h3>Other Implementations</h3>
+ *
+ *  <p>Other implementations of the Hasher are easy to implement.  Hashers that represent single items should make use of the
+ *  {@code Hahser.Filter} and/or {@code Hahser.FileredIntConsumer} classes to filter out duplicate indices.</p>","[{'comment': 's/Hahser/Hasher twice (a misspelling easy to happen, worth checking in the rest of the code/docs with `grep` or IDE)', 'commenter': 'kinow'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/BitMapProducer.java,"@@ -0,0 +1,172 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Arrays;
+import java.util.Objects;
+import java.util.function.IntPredicate;
+import java.util.function.LongPredicate;
+
+/**
+ * Produces BitMap longs for a Bloom filter.
+ *
+ * Each bit map is a little-endian long value representing a block of bits of this filter.
+ *
+ * <p>The returned array will have length {@code ceil(m / 64)} where {@code m} is the
+ * number of bits in the filter and {@code ceil} is the ceiling function.
+ * Bits 0-63 are in the first long. A value of 1 at a bit position indicates the bit
+ * index is enabled.
+ *
+ * The producer may stop at the last non zero BitMap or may produce zero value bit maps to the limit determined by
+ * a shape..","[{'comment': 'Extra `.`', 'commenter': 'kinow'}, {'comment': 'Fixed the typos and did a search for both the ""hasher"" typo and the double dots.', 'commenter': 'Claude-at-Instaclustr'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/hasher/Hasher.java,"@@ -16,117 +16,127 @@
  */
 package org.apache.commons.collections4.bloomfilter.hasher;
 
-import java.nio.charset.Charset;
-import java.util.PrimitiveIterator;
+import org.apache.commons.collections4.bloomfilter.Shape;
+
+import java.util.function.IntPredicate;
+
+import org.apache.commons.collections4.bloomfilter.BitMap;
+import org.apache.commons.collections4.bloomfilter.IndexProducer;
 
 /**
- * A Hasher represents items of arbitrary byte size as a byte representation of
- * fixed size (a hash). The hash representations can be used to create indexes
- * for a Bloom filter.
- *
- * <p>The hash for each item is created using a hash function; use of different
- * seeds allows generation of different hashes for the same item. The hashes can
- * be dynamically converted into the bit index representation used by a Bloom
- * filter. The shape of the Bloom filter defines the number of indexes per item
- * and the range of the indexes. The hasher can generate the correct number of
- * indexes in the range required by the Bloom filter for each item it
- * represents.
- *
- * <p>Note that the process of generating hashes and mapping them to a Bloom
- * filter shape may create duplicate indexes. The hasher may generate fewer than
- * the required number of hash functions per item if duplicates have been
- * removed. Implementations of {@code iterator()} may return duplicate values
- * and may return values in a random order. See implementation javadoc notes as
- * to the guarantees provided by the specific implementation.
- *
- * <p>Hashers have an identity based on the hashing algorithm used.
+ * A Hasher creates IndexProducer based on the hash implementation and the
+ * provided Shape.
  *
  * @since 4.5
  */
 public interface Hasher {
 
     /**
-     * A builder to build a hasher.
+     * Creates an IndexProducer for this hasher based on the Shape.
      *
-     * <p>A hasher represents one or more items of arbitrary byte size. The builder
-     * contains methods to collect byte representations of items. Each method to add
-     * to the builder will add an entire item to the final hasher created by the
-     * {@link #build()} method.
+     * <p>The @{code IndexProducer} will create indices within the range defined by the number of bits in
+     * the shape. The total number of indices will respect the number of hash functions per item
+     * defined by the shape. However the count of indices may not be a multiple of the number of
+     * hash functions once implementation has removed duplicates.</p>
      *
-     * @since 4.5
+     * <p>This IndexProducer must be deterministic in that it must return the same indices for the
+     * same Shape.</p>
+     *
+     * <p>No guarantee is made as to order of indices.</p>
+     * <p>Duplicates indices for a single item must be removed.</p>
+     *
+     * @param shape the shape of the desired Bloom filter.
+     * @return the iterator of integers
      */
-    interface Builder {
+    IndexProducer indices(Shape shape);
 
-        /**
-         * Builds the hasher from all the items.
-         *
-         * <p>This method will clear the builder for future use.
-         *
-         * @return the fully constructed hasher
-         */
-        Hasher build();
+    /**
+     * Gets the number of items that will be hashed by the {@code IndexProducer}.
+     * @return The number of items that will be hashed by the {@code IndexProducer}.
+     */
+    int size();
 
-        /**
-         * Adds a byte array item to the hasher.
-         *
-         * @param item the item to add
-         * @return a reference to this object
-         */
-        Builder with(byte[] item);
+    /**
+     * Returns true if there are no items to be hashed.
+     * @return {@code true} if there are no items to be hashed.
+     */
+    default boolean isEmpty() {
+        return size() == 0;
+    }
+
+    /**
+     * A convenience class for Hasher implementations to filter out duplicate indices.
+     *
+     * <p><em>If the index is negative the behavior is not defined.</em></p>
+     *
+     * <p>This is conceptually a unique filter implemented as a {@code Predicate<int>}.</p>
+     * @since 4.5
+     */
+    class Filter {
+        private long[] bits;
+        private int size;
 
         /**
-         * Adds a character sequence item to the hasher using the specified {@code charset}
-         * encoding.
+         * Constructor.
          *
-         * @param item the item to add
-         * @param charset the character set
-         * @return a reference to this object
+         * @param size The number of numbers to track. Values from 0 to size-1 will be tracked.
          */
-        default Builder with(final CharSequence item, final Charset charset) {
-            return with(item.toString().getBytes(charset));
+        public Filter(int size) {
+            bits = new long[BitMap.numberOfBitMaps(size)];
+            this.size = size;
         }
 
         /**
-         * Adds a character sequence item to the hasher. Each 16-bit character is
-         * converted to 2 bytes using little-endian order.
+         * Test if the number has not been seen.
+         *
+         * <p>The first time a number is tested the method returns {@code true} and returns
+         * {@code false} for every time after that.</p>
          *
-         * @param item the item to add
-         * @return a reference to this object
+         * <p><em>If the input is not in the range [0,size) an IndexOutOfBoundsException exception is thrown.</em></p>
+         *
+         * @param number the number to check.
+         * @return {@code true} if the number has not been seen, {@code false} otherwise.
+         * @see Hasher.Filter#Filter(int)
          */
-        default Builder withUnencoded(final CharSequence item) {
-            final int length = item.length();
-            final byte[] bytes = new byte[length * 2];
-            for (int i = 0; i < length; i++) {
-                final char ch = item.charAt(i);
-                bytes[i * 2] = (byte) ch;
-                bytes[i * 2 + 1] = (byte) (ch >>> 8);
+        public boolean test(int number) {
+            if (number < 0) {
+                throw new IndexOutOfBoundsException(""number may not be less than zero. "" + number);
+            }
+            if (number >= size) {
+                throw new IndexOutOfBoundsException(String.format(""number to large %d >= %d"", number, size));
             }
-            return with(bytes);
+            boolean retval = !BitMap.contains(bits, number);
+            BitMap.set(bits, number);
+            return retval;
         }
     }
 
     /**
-     * Gets an iterator of integers that are the bits to enable in the Bloom
-     * filter based on the shape.
-     *
-     * <p>The iterator will create indexes within the range defined by the number of bits in
-     * the shape. The total number of indexes will respect the number of hash functions per item
-     * defined by the shape. However the count of indexes may not be a multiple of the number of
-     * hash functions if the implementation has removed duplicates.
+     * Class to wrap an that an IntPredicate only receives an integer value once.","[{'comment': 'The sentence does not make sense.', 'commenter': 'aherbert'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/BitMapProducer.java,"@@ -0,0 +1,172 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Arrays;
+import java.util.Objects;
+import java.util.function.IntPredicate;
+import java.util.function.LongPredicate;
+
+/**
+ * Produces BitMap longs for a Bloom filter.
+ *
+ * Each bit map is a little-endian long value representing a block of bits of this filter.
+ *
+ * <p>The returned array will have length {@code ceil(m / 64)} where {@code m} is the
+ * number of bits in the filter and {@code ceil} is the ceiling function.
+ * Bits 0-63 are in the first long. A value of 1 at a bit position indicates the bit
+ * index is enabled.
+ *
+ * The producer may stop at the last non zero BitMap or may produce zero value bit maps to the limit determined by
+ * a shape.
+ *
+ * @since 4.5
+ */
+public interface BitMapProducer {
+
+    /**
+     * Each BitMap is passed to the predicate in order.  The predicate is applied to each
+     * bitmap value, if the predicate returns {@code false} the execution is stopped, {@code false}
+     * is returned, and no further bitmaps are processed.
+     *
+     * <p>Any exceptions thrown by the action are relayed to the caller.</p>
+     *
+     * @param predicate the function to execute
+     * @return {@code true} if all bitmaps returned {@code true}, {@code false} otherwise.
+     * @throws NullPointerException if the specified consumer is null
+     */
+    boolean forEachBitMap(LongPredicate predicate);
+
+    /**
+     * Creates a BitMapProducer from an array of Long.
+     * @param bitMaps the bitMaps to return.
+     * @return a BitMapProducer.
+     */
+    static BitMapProducer fromLongArray(long... bitMaps) {
+        return new BitMapProducer() {
+
+            @Override
+            public boolean forEachBitMap(LongPredicate predicate) {
+                for (long word : bitMaps) {
+                    if (!predicate.test(word)) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+
+        };
+    }
+
+    /**
+     * Creates a BitMapProducer from an IndexProducer.
+     * @param producer the IndexProducer that specifies the indexes of the bits to enable.
+     * @param numberOfBits the number of bits in the Bloom filter.
+     * @return A BitMapProducer that produces the BitMap equivalent of the Indices from the producer.
+     */
+    static BitMapProducer fromIndexProducer(IndexProducer producer, int numberOfBits) {
+        Objects.requireNonNull(producer, ""producer"");
+        Objects.requireNonNull(numberOfBits, ""numberOfBits"");
+
+        return new BitMapProducer() {
+            private int maxBucket = -1;
+            private long[] result = new long[BitMap.numberOfBitMaps(numberOfBits)];
+
+            @Override
+            public boolean forEachBitMap(LongPredicate predicate) {
+                Objects.requireNonNull(predicate, ""predicate"");
+                /*
+                 * we can not assume that all the ints will be in order and not repeated. This
+                 * is because the HasherCollection does not make the guarantee.
+                 */
+                // process all the ints into a array of BitMaps
+                IntPredicate builder = new IntPredicate() {
+                    @Override
+                    public boolean test(int i) {
+                        int bucketIdx = BitMap.getLongIndex(i);
+                        maxBucket = maxBucket < bucketIdx ? bucketIdx : maxBucket;
+                        result[bucketIdx] |= BitMap.getLongBit(i);
+                        return true;
+                    }
+                };
+                producer.forEachIndex(builder);
+                // send the bitmaps to the consumer.
+                for (int bucket = 0; bucket <= maxBucket; bucket++) {
+                    if (!predicate.test(result[bucket])) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+        };
+    }
+
+    /**
+     * A LongConsumer that builds an Array of BitMaps as produced by a BitMapProducer.
+     *
+     */
+    class ArrayBuilder implements LongPredicate {
+        private long[] result;
+        private int idx = 0;
+        private int bucketCount = 0;
+
+        /**
+         * Constructor that creates an empty ArrayBuilder.
+         * @param shape The shape used to generate the BitMaps.
+         */
+        public ArrayBuilder(Shape shape) {
+            this(shape, null);
+        }
+
+        /**
+         * Constructor that creates an array builder with an initial value.
+         * @param shape The shape used to generate the BitMaps.
+         * @param initialValue an array of BitMap values to initialize the builder with.  May be {@code null}.
+         * @throws IllegalArgumentException is the length of initialValue is greater than the number of","[{'comment': '`if` the length.\r\n\r\nShould `buckets` be replaced with `bit maps`. Bucket is not used anywhere else in the package javadoc. It is only used internally in the ArrayBuilder', 'commenter': 'aherbert'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -16,138 +16,265 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
+import java.util.Objects;
+import java.util.function.IntPredicate;
+
 import org.apache.commons.collections4.bloomfilter.hasher.Hasher;
-import org.apache.commons.collections4.bloomfilter.hasher.Shape;
-import org.apache.commons.collections4.bloomfilter.hasher.StaticHasher;
 
 /**
  * The interface that describes a Bloom filter.
  * @since 4.5
  */
-public interface BloomFilter {
+public interface BloomFilter extends IndexProducer, BitMapProducer {
 
-    // Query Operations
+    /**
+     * Return the Bloom filter data as a BitMap array.
+     * @param filter the filter to get the data from.
+     * @return An array of BitMap long.","[{'comment': 'of BitMap data.\r\n\r\nAll bit maps are longs in this codebase. This usage does not read correctly.', 'commenter': 'aherbert'}]"
258,src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java,"@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Objects;
+import java.util.function.IntPredicate;
+import java.util.function.LongPredicate;
+
+/**
+ * An object that produces indices of a Bloom filter.
+ *
+ * @since 4.5
+ */
+public interface IndexProducer {
+
+    /**
+     * Each index is passed to the predicate.  The predicate is applied to each
+     * index value, if the predicate returns {@code false} the execution is stopped, {@code false}
+     * is returned, and no further indices are processed.
+     *
+     * <p>Any exceptions thrown by the action are relayed to the caller.</p>
+     *
+     * <p>Indices ordering is not guaranteed</p>
+     *
+     * @param predicate the action to be performed for each non-zero bit index.
+     * @return {@code true} if all indexes return true from consumer, {@code false} otherwise.
+     * @throws NullPointerException if the specified action is null
+     */
+    boolean forEachIndex(IntPredicate predicate);
+
+    /**
+     * Creates an IndexProducer from an array of integers
+     * @param values the index values
+     * @return an IndexProducer that uses the values.
+     */
+    static IndexProducer fromIntArray( final int[] values ) {","[{'comment': 'Remove the whitespace around the argument', 'commenter': 'aherbert'}]"
272,src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java,"@@ -213,7 +213,7 @@ public boolean equals(final Object object) {
             if (object == this) {
                 return true;
             }
-            return object == this || decorated().equals(object);
+            return decorated().equals(object);","[{'comment': 'This should be a ternary.\r\n\r\nThere is also an error in the original code in that comparing two difference SynchronizedCollection instances on the same decorated collection will yield a `false` when it should be `true`.\r\n\r\n`object.decorated() == this.decorated()`', 'commenter': 'Claudenw'}]"
272,src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java,"@@ -273,12 +273,11 @@ public boolean equals(final Object object) {
         }
         if (object.getClass().equals(this.getClass())) {
             final FixedOrderComparator<?> comp = (FixedOrderComparator<?>) object;
-            return (null == map ? null == comp.map : map.equals(comp.map)) &&
-                   (null == unknownObjectBehavior ? null == comp.unknownObjectBehavior :
-                        unknownObjectBehavior == comp.unknownObjectBehavior &&
-                        counter == comp.counter &&
-                        isLocked == comp.isLocked &&
-                        unknownObjectBehavior == comp.unknownObjectBehavior);
+            return map.equals(comp.map)
+                    && (null == unknownObjectBehavior ? null == comp.unknownObjectBehavior :
+                    unknownObjectBehavior == comp.unknownObjectBehavior","[{'comment': 'This should probably call `Objects.equals( unknownObjectBehavior, comp.unknownObjectBehavior )`', 'commenter': 'Claudenw'}]"
287,src/test/java/org/apache/commons/collections4/ClosureUtilsTest.java,"@@ -138,18 +135,13 @@ public void testWhileClosure() {
         ClosureUtils.whileClosure(PredicateUtils.uniquePredicate(), cmd).execute(null);
         assertEquals(1, cmd.count);
 
-        try {
-            ClosureUtils.whileClosure(null, ClosureUtils.nopClosure());
-            fail();
-        } catch (final NullPointerException ex) {}
-        try {
-            ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), null);
-            fail();
-        } catch (final NullPointerException ex) {}
-        try {
-            ClosureUtils.whileClosure(null, null);
-            fail();
-        } catch (final NullPointerException ex) {}
+        assertAll(
+                () -> assertThrows(NullPointerException.class, () -> ClosureUtils.whileClosure(null, ClosureUtils.nopClosure())),
+","[{'comment': ""Why are there extra blank lines between arguments? We don't do this for other method calls."", 'commenter': 'garydgregory'}, {'comment': 'I had not spotted i was doing that.', 'commenter': 'nhojpatrick'}]"
287,src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java,"@@ -501,26 +499,29 @@ public void exists() {
 
     @Test
     public void extractSingleton() {
-        ArrayList<String> coll = null;
-        try {
-            CollectionUtils.extractSingleton(coll);
-            fail(""expected NullPointerException from extractSingleton(null)"");
-        } catch (final NullPointerException e) {
-        }
-        coll = new ArrayList<>();
-        try {
-            CollectionUtils.extractSingleton(coll);
-            fail(""expected IllegalArgumentException from extractSingleton(empty)"");
-        } catch (final IllegalArgumentException e) {
-        }
-        coll.add(""foo"");
-        assertEquals(""foo"", CollectionUtils.extractSingleton(coll));
-        coll.add(""bar"");
-        try {
-            CollectionUtils.extractSingleton(coll);
-            fail(""expected IllegalArgumentException from extractSingleton(size == 2)"");
-        } catch (final IllegalArgumentException e) {
-        }
+        assertAll(
+                () -> {
+                    ArrayList<String> collNull = null;
+                    assertThrows(NullPointerException.class, () -> CollectionUtils.extractSingleton(collNull),
+                            ""expected NullPointerException from extractSingleton(null)"");
+                },
+","[{'comment': 'No need for an extra blank line to separate method arguments.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java,"@@ -501,26 +499,29 @@ public void exists() {
 
     @Test
     public void extractSingleton() {
-        ArrayList<String> coll = null;
-        try {
-            CollectionUtils.extractSingleton(coll);
-            fail(""expected NullPointerException from extractSingleton(null)"");
-        } catch (final NullPointerException e) {
-        }
-        coll = new ArrayList<>();
-        try {
-            CollectionUtils.extractSingleton(coll);
-            fail(""expected IllegalArgumentException from extractSingleton(empty)"");
-        } catch (final IllegalArgumentException e) {
-        }
-        coll.add(""foo"");
-        assertEquals(""foo"", CollectionUtils.extractSingleton(coll));
-        coll.add(""bar"");
-        try {
-            CollectionUtils.extractSingleton(coll);
-            fail(""expected IllegalArgumentException from extractSingleton(size == 2)"");
-        } catch (final IllegalArgumentException e) {
-        }
+        assertAll(
+                () -> {
+                    ArrayList<String> collNull = null;
+                    assertThrows(NullPointerException.class, () -> CollectionUtils.extractSingleton(collNull),
+                            ""expected NullPointerException from extractSingleton(null)"");
+                },
+
+                () -> {
+                    ArrayList<String> collEmpty = new ArrayList<>();
+                    assertThrows(IllegalArgumentException.class, () -> CollectionUtils.extractSingleton(collEmpty),
+                            ""expected IllegalArgumentException from extractSingleton(empty)"");
+                },
+","[{'comment': 'No need for an extra blank line to separate method arguments.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java,"@@ -2225,12 +2195,9 @@ public void testSubtractWithPredicate() {
     public void testSynchronizedCollection() {
         final Collection<Object> col = CollectionUtils.synchronizedCollection(new ArrayList<>());
         assertTrue(col instanceof SynchronizedCollection, ""Returned object should be a SynchronizedCollection."");
-        try {
-            CollectionUtils.synchronizedCollection(null);
-            fail(""Expecting NullPointerException for null collection."");
-        } catch (final NullPointerException ex) {
-            // expected
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java,"@@ -2284,12 +2251,9 @@ public void testUnionNullColl2() {
     public void testUnmodifiableCollection() {
         final Collection<Object> col = CollectionUtils.unmodifiableCollection(new ArrayList<>());
         assertTrue(col instanceof UnmodifiableCollection, ""Returned object should be a UnmodifiableCollection."");
-        try {
-            CollectionUtils.unmodifiableCollection(null);
-            fail(""Expecting NullPointerException for null collection."");
-        } catch (final NullPointerException ex) {
-            // expected
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/IterableUtilsTest.java,"@@ -111,12 +112,9 @@ public void forEach() {
         col.add(listB);
         IterableUtils.forEach(col, testClosure);
         assertTrue(listA.isEmpty() && listB.isEmpty());
-        try {
-            IterableUtils.forEach(col, null);
-            fail(""expecting NullPointerException"");
-        } catch (final NullPointerException npe) {
-            // expected
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/IterableUtilsTest.java,"@@ -274,12 +265,9 @@ public void find() {
         test = IterableUtils.find(iterableA, testPredicate);
         assertNull(test);
         assertNull(IterableUtils.find(null, testPredicate));
-        try {
-            IterableUtils.find(iterableA, null);
-            fail(""expecting NullPointerException"");
-        } catch (final NullPointerException npe) {
-            // expected
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/IterableUtilsTest.java,"@@ -291,51 +279,32 @@ public void indexOf() {
         index = IterableUtils.indexOf(iterableA, testPredicate);
         assertEquals(-1, index);
         assertEquals(-1, IterableUtils.indexOf(null, testPredicate));
-        try {
-            IterableUtils.indexOf(iterableA, null);
-            fail(""expecting NullPointerException"");
-        } catch (final NullPointerException npe) {
-            // expected
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/IterableUtilsTest.java,"@@ -350,19 +319,11 @@ public void matchesAny() {
 
     @Test
     public void matchesAll() {
-        try {
-            assertFalse(IterableUtils.matchesAll(null, null));
-            fail(""predicate must not be null"");
-        } catch (final NullPointerException ex) {
-            // expected
-        }
-
-        try {
-            assertFalse(IterableUtils.matchesAll(iterableA, null));
-            fail(""predicate must not be null"");
-        } catch (final NullPointerException ex) {
-            // expected
-        }
+        assertThrows(NullPointerException.class, () -> assertFalse(IterableUtils.matchesAll(null, null)),
+                ""predicate must not be null"");
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/MapUtilsTest.java,"@@ -871,11 +840,9 @@ public void testPopulateMultiMap() {
 
     @Test
     public void testIterableMap() {
-        try {
-            MapUtils.iterableMap(null);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException e) {
-        }
+        assertThrows(NullPointerException.class, () -> MapUtils.iterableMap(null),
+                ""Should throw NullPointerException"");
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/MapUtilsTest.java,"@@ -889,11 +856,9 @@ public void testIterableMap() {
 
     @Test
     public void testIterableSortedMap() {
-        try {
-            MapUtils.iterableSortedMap(null);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException e) {
-        }
+        assertThrows(NullPointerException.class, () -> MapUtils.iterableSortedMap(null),
+                ""Should throw NullPointerException"");
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/ShapeTest.java,"@@ -266,123 +222,81 @@ public void constructor_items_probability_Test() {
      */
     @Test
     public void constructor_nm_noName() {
-        try {
-            new Shape(null, 5, 72);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 5, 72),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that the constructor with a null name, number of items, size of filter, and number of functions fails.
      */
     @Test
     public void constructor_nmk_noName() {
-        try {
-            new Shape(null, 5, 72, 17);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 5, 72, 17),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that the constructor with a null name, number of items, and probability fails.
      */
     @Test
     public void constructor_np_noName() {
-        try {
-            new Shape(null, 5, 0.1);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 5, 0.1),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that the constructor with a null name, probability, size of filter, and number of functions fails.
      */
     @Test
     public void constructor_pmk_noName() {
-        try {
-            new Shape(null, 0.1, 72, 17);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 0.1, 72, 17),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that if the number of bits is less than 1 an exception is thrown
      */
     @Test
     public void constructor_probability_bits_hash_BadNumberOfBitsTest() {
-        try {
-            new Shape(testFunction, 0.5, 0, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
+        assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, 0.5, 0, 1),
+                ""Should have thrown IllegalArgumentException"");
     }
 
     /**
      * Tests that if the number of functions is less than 1 an exception is thrown
      */
     @Test
     public void constructor_probability_bits_hash_BadNumberOfHashFunctionsTest() {
-        try {
-            new Shape(testFunction, 0.5, 24, 0);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
+        assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, 0.5, 24, 0),
+                ""Should have thrown IllegalArgumentException"");
     }
 
     /**
      * Tests that invalid probability values cause and IllegalArgumentException to be thrown.
      */
     @Test
     public void constructor_probability_bits_hash_BadProbabilityTest() {
-        // probability should not be 0
-        try {
-            new Shape(testFunction, 0.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be = -1
-        try {
-            new Shape(testFunction, -1.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be < -1
-        try {
-            new Shape(testFunction, -1.5, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be = 1
-        try {
-            new Shape(testFunction, 1.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be > 1
-        try {
-            new Shape(testFunction, 2.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
+        assertAll(
+                // probability should not be 0
+                () -> assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, 0.0, 24, 1),
+                        ""Should have thrown IllegalArgumentException""),
+","[{'comment': 'No need for an extra blank line to separate method arguments.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/ShapeTest.java,"@@ -266,123 +222,81 @@ public void constructor_items_probability_Test() {
      */
     @Test
     public void constructor_nm_noName() {
-        try {
-            new Shape(null, 5, 72);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 5, 72),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that the constructor with a null name, number of items, size of filter, and number of functions fails.
      */
     @Test
     public void constructor_nmk_noName() {
-        try {
-            new Shape(null, 5, 72, 17);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 5, 72, 17),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that the constructor with a null name, number of items, and probability fails.
      */
     @Test
     public void constructor_np_noName() {
-        try {
-            new Shape(null, 5, 0.1);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 5, 0.1),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that the constructor with a null name, probability, size of filter, and number of functions fails.
      */
     @Test
     public void constructor_pmk_noName() {
-        try {
-            new Shape(null, 0.1, 72, 17);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 0.1, 72, 17),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that if the number of bits is less than 1 an exception is thrown
      */
     @Test
     public void constructor_probability_bits_hash_BadNumberOfBitsTest() {
-        try {
-            new Shape(testFunction, 0.5, 0, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
+        assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, 0.5, 0, 1),
+                ""Should have thrown IllegalArgumentException"");
     }
 
     /**
      * Tests that if the number of functions is less than 1 an exception is thrown
      */
     @Test
     public void constructor_probability_bits_hash_BadNumberOfHashFunctionsTest() {
-        try {
-            new Shape(testFunction, 0.5, 24, 0);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
+        assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, 0.5, 24, 0),
+                ""Should have thrown IllegalArgumentException"");
     }
 
     /**
      * Tests that invalid probability values cause and IllegalArgumentException to be thrown.
      */
     @Test
     public void constructor_probability_bits_hash_BadProbabilityTest() {
-        // probability should not be 0
-        try {
-            new Shape(testFunction, 0.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be = -1
-        try {
-            new Shape(testFunction, -1.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be < -1
-        try {
-            new Shape(testFunction, -1.5, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be = 1
-        try {
-            new Shape(testFunction, 1.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be > 1
-        try {
-            new Shape(testFunction, 2.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
+        assertAll(
+                // probability should not be 0
+                () -> assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, 0.0, 24, 1),
+                        ""Should have thrown IllegalArgumentException""),
+
+                // probability should not be = -1
+                () -> assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, -1.0, 24, 1),
+                        ""Should have thrown IllegalArgumentException""),
+","[{'comment': 'No need for an extra blank line to separate method arguments.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/ShapeTest.java,"@@ -266,123 +222,81 @@ public void constructor_items_probability_Test() {
      */
     @Test
     public void constructor_nm_noName() {
-        try {
-            new Shape(null, 5, 72);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 5, 72),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that the constructor with a null name, number of items, size of filter, and number of functions fails.
      */
     @Test
     public void constructor_nmk_noName() {
-        try {
-            new Shape(null, 5, 72, 17);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 5, 72, 17),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that the constructor with a null name, number of items, and probability fails.
      */
     @Test
     public void constructor_np_noName() {
-        try {
-            new Shape(null, 5, 0.1);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 5, 0.1),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that the constructor with a null name, probability, size of filter, and number of functions fails.
      */
     @Test
     public void constructor_pmk_noName() {
-        try {
-            new Shape(null, 0.1, 72, 17);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 0.1, 72, 17),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that if the number of bits is less than 1 an exception is thrown
      */
     @Test
     public void constructor_probability_bits_hash_BadNumberOfBitsTest() {
-        try {
-            new Shape(testFunction, 0.5, 0, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
+        assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, 0.5, 0, 1),
+                ""Should have thrown IllegalArgumentException"");
     }
 
     /**
      * Tests that if the number of functions is less than 1 an exception is thrown
      */
     @Test
     public void constructor_probability_bits_hash_BadNumberOfHashFunctionsTest() {
-        try {
-            new Shape(testFunction, 0.5, 24, 0);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
+        assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, 0.5, 24, 0),
+                ""Should have thrown IllegalArgumentException"");
     }
 
     /**
      * Tests that invalid probability values cause and IllegalArgumentException to be thrown.
      */
     @Test
     public void constructor_probability_bits_hash_BadProbabilityTest() {
-        // probability should not be 0
-        try {
-            new Shape(testFunction, 0.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be = -1
-        try {
-            new Shape(testFunction, -1.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be < -1
-        try {
-            new Shape(testFunction, -1.5, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be = 1
-        try {
-            new Shape(testFunction, 1.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be > 1
-        try {
-            new Shape(testFunction, 2.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
+        assertAll(
+                // probability should not be 0
+                () -> assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, 0.0, 24, 1),
+                        ""Should have thrown IllegalArgumentException""),
+
+                // probability should not be = -1
+                () -> assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, -1.0, 24, 1),
+                        ""Should have thrown IllegalArgumentException""),
+
+                // probability should not be < -1
+                () -> assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, -1.5, 24, 1),
+                        ""Should have thrown IllegalArgumentException""),
+","[{'comment': 'No need for an extra blank line to separate method arguments.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/ShapeTest.java,"@@ -266,123 +222,81 @@ public void constructor_items_probability_Test() {
      */
     @Test
     public void constructor_nm_noName() {
-        try {
-            new Shape(null, 5, 72);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 5, 72),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that the constructor with a null name, number of items, size of filter, and number of functions fails.
      */
     @Test
     public void constructor_nmk_noName() {
-        try {
-            new Shape(null, 5, 72, 17);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 5, 72, 17),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that the constructor with a null name, number of items, and probability fails.
      */
     @Test
     public void constructor_np_noName() {
-        try {
-            new Shape(null, 5, 0.1);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 5, 0.1),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that the constructor with a null name, probability, size of filter, and number of functions fails.
      */
     @Test
     public void constructor_pmk_noName() {
-        try {
-            new Shape(null, 0.1, 72, 17);
-            fail(""Should throw NullPointerException"");
-        } catch (final NullPointerException expected) {
-            // do nothing
-        }
+        assertThrows(NullPointerException.class, () -> new Shape(null, 0.1, 72, 17),
+                ""Should throw NullPointerException"");
     }
 
     /**
      * Tests that if the number of bits is less than 1 an exception is thrown
      */
     @Test
     public void constructor_probability_bits_hash_BadNumberOfBitsTest() {
-        try {
-            new Shape(testFunction, 0.5, 0, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
+        assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, 0.5, 0, 1),
+                ""Should have thrown IllegalArgumentException"");
     }
 
     /**
      * Tests that if the number of functions is less than 1 an exception is thrown
      */
     @Test
     public void constructor_probability_bits_hash_BadNumberOfHashFunctionsTest() {
-        try {
-            new Shape(testFunction, 0.5, 24, 0);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
+        assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, 0.5, 24, 0),
+                ""Should have thrown IllegalArgumentException"");
     }
 
     /**
      * Tests that invalid probability values cause and IllegalArgumentException to be thrown.
      */
     @Test
     public void constructor_probability_bits_hash_BadProbabilityTest() {
-        // probability should not be 0
-        try {
-            new Shape(testFunction, 0.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be = -1
-        try {
-            new Shape(testFunction, -1.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be < -1
-        try {
-            new Shape(testFunction, -1.5, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be = 1
-        try {
-            new Shape(testFunction, 1.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
-
-        // probability should not be > 1
-        try {
-            new Shape(testFunction, 2.0, 24, 1);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // expected
-        }
+        assertAll(
+                // probability should not be 0
+                () -> assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, 0.0, 24, 1),
+                        ""Should have thrown IllegalArgumentException""),
+
+                // probability should not be = -1
+                () -> assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, -1.0, 24, 1),
+                        ""Should have thrown IllegalArgumentException""),
+
+                // probability should not be < -1
+                () -> assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, -1.5, 24, 1),
+                        ""Should have thrown IllegalArgumentException""),
+
+                // probability should not be = 1
+                () -> assertThrows(IllegalArgumentException.class, () -> new Shape(testFunction, 1.0, 24, 1),
+                        ""Should have thrown IllegalArgumentException""),
+","[{'comment': 'No need for an extra blank line to separate method arguments.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/StaticHasherTest.java,"@@ -203,12 +201,9 @@ public void testConstructor_Iterator_ValueTooBig() {
 
         final int[] values = {shape.getNumberOfBits(), 3, 5, 7, 9, 3, 5, 1};
         final Iterator<Integer> iter = Arrays.stream(values).iterator();
-        try {
-            new StaticHasher(iter, shape);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // do nothing
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/bloomfilter/hasher/StaticHasherTest.java,"@@ -220,12 +215,9 @@ public void testConstructor_Iterator_ValueTooSmall() {
 
         final int[] values = {-1, 3, 5, 7, 9, 3, 5, 1};
         final Iterator<Integer> iter = Arrays.stream(values).iterator();
-        try {
-            new StaticHasher(iter, shape);
-            fail(""Should have thrown IllegalArgumentException"");
-        } catch (final IllegalArgumentException expected) {
-            // do nothing
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java,"@@ -81,11 +86,9 @@ public void testBounded() {
         assertEquals(""f"", iter.next());
 
         assertFalse(iter.hasNext());
-        try {
-            iter.next();
-            fail(""Expected NoSuchElementException."");
-        } catch (final NoSuchElementException nsee) { /* Success case */
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java,"@@ -114,11 +117,8 @@ public void testSameAsDecorated() {
         assertEquals(""g"", iter.next());
 
         assertFalse(iter.hasNext());
-        try {
-            iter.next();
-            fail(""Expected NoSuchElementException."");
-        } catch (final NoSuchElementException nsee) { /* Success case */
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java,"@@ -130,11 +130,8 @@ public void testSameAsDecorated() {
     public void testEmptyBounded() {
         final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 3, 0);
         assertFalse(iter.hasNext());
-        try {
-            iter.next();
-            fail(""Expected NoSuchElementException."");
-        } catch (final NoSuchElementException nsee) { /* Success case */
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java,"@@ -172,11 +163,8 @@ public void testNegativeMax() {
     public void testOffsetGreaterThanSize() {
         final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 10, 4);
         assertFalse(iter.hasNext());
-        try {
-            iter.next();
-            fail(""Expected NoSuchElementException."");
-        } catch (final NoSuchElementException nsee) { /* Success case */
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java,"@@ -203,11 +191,8 @@ public void testMaxGreaterThanSize() {
         assertEquals(""g"", iter.next());
 
         assertFalse(iter.hasNext());
-        try {
-            iter.next();
-            fail(""Expected NoSuchElementException."");
-        } catch (final NoSuchElementException nsee) { /* Success case */
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java,"@@ -271,11 +249,8 @@ public void testRemoveFirst() {
         assertEquals(""f"", iter.next());
 
         assertFalse(iter.hasNext());
-        try {
-            iter.next();
-            fail(""Expected NoSuchElementException."");
-        } catch (final NoSuchElementException nsee) { /* Success case */
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java,"@@ -303,11 +278,8 @@ public void testRemoveMiddle() {
         assertEquals(""f"", iter.next());
 
         assertFalse(iter.hasNext());
-        try {
-            iter.next();
-            fail(""Expected NoSuchElementException."");
-        } catch (final NoSuchElementException nsee) { /* Success case */
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java,"@@ -331,21 +303,17 @@ public void testRemoveLast() {
         assertEquals(""f"", iter.next());
 
         assertFalse(iter.hasNext());
-        try {
-            iter.next();
-            fail(""Expected NoSuchElementException."");
-        } catch (final NoSuchElementException nsee) { /* Success case */
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java,"@@ -331,21 +303,17 @@ public void testRemoveLast() {
         assertEquals(""f"", iter.next());
 
         assertFalse(iter.hasNext());
-        try {
-            iter.next();
-            fail(""Expected NoSuchElementException."");
-        } catch (final NoSuchElementException nsee) { /* Success case */
-        }
+
+        final NoSuchElementException thrown = assertThrows(NoSuchElementException.class, () -> iter.next());
+        assertThat(thrown.getMessage(), is(nullValue()));
 
         iter.remove();
         assertFalse(testListCopy.contains(""f""));
 
         assertFalse(iter.hasNext());
-        try {
-            iter.next();
-            fail(""Expected NoSuchElementException."");
-        } catch (final NoSuchElementException nsee) { /* Success case */
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java,"@@ -364,10 +332,9 @@ public void remove() {
         final Iterator<E> iter = new BoundedIterator<>(mockIterator, 1, 5);
         assertTrue(iter.hasNext());
         assertEquals(""b"", iter.next());
-        try {
-            iter.remove();
-            fail(""Expected UnsupportedOperationException."");
-        } catch (final UnsupportedOperationException usoe) { /* Success case */
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/iterators/LoopingIteratorTest.java,"@@ -152,19 +136,16 @@ public void testRemoving1() throws Exception {
         assertEquals(0, list.size(), ""list should have 0 elements."");
 
         assertFalse(loop.hasNext(), ""4th hasNext should return false"");
-        try {
-            loop.next();
-            fail(""Expected NoSuchElementException to be thrown."");
-        } catch (final NoSuchElementException ex) {
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
287,src/test/java/org/apache/commons/collections4/iterators/LoopingListIteratorTest.java,"@@ -193,11 +181,8 @@ public void testRemovingElementsAndIteratingForward() {
         assertEquals(0, list.size());
 
         assertFalse(loop.hasNext());
-        try {
-            loop.next();
-            fail();
-        } catch (final NoSuchElementException ex) {
-        }
+","[{'comment': 'No need for an extra blank line.', 'commenter': 'garydgregory'}]"
300,src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java,"@@ -315,6 +316,24 @@ public void testDataSizeAfterSerialization() throws IOException, ClassNotFoundEx
 
     }
 
+    /**
+     * Test whether remove is not removing last entry after calling hasNext.
+     * <p>
+     * See <a href=""https://issues.apache.org/jira/browse/COLLECTIONS-802"">COLLECTIONS-802: ReferenceMap iterator remove violates contract</a>
+     */
+    @Test
+    public void testIteratorLastEntryCanBeRemovedAfterHasNext() {
+        ReferenceMap<Integer, Integer> map = new ReferenceMap<>();
+        map.put(1, 2);
+        Iterator<Map.Entry<Integer, Integer>> iter = map.entrySet().iterator();
+        assertTrue(iter.hasNext());
+        iter.next();
+        // below line should not affect remove
+        assertFalse(iter.hasNext());
+        iter.remove();
+        assertTrue(""Expect empty but have entry: "" + map, map.isEmpty());
+    }","[{'comment': 'Fix looks OK, and the test is failing on `master`, passing on this branch. We could also modify the test to be more similar to the one reported in the issue.\r\n\r\n```diff\r\ndiff --git a/src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java b/src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java\r\nindex 509ac514..c6625909 100644\r\n--- a/src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java\r\n+++ b/src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java\r\n@@ -327,7 +327,8 @@ public class ReferenceMapTest<K, V> extends AbstractIterableMapTest<K, V> {\r\n         map.put(1, 2);\r\n         Iterator<Map.Entry<Integer, Integer>> iter = map.entrySet().iterator();\r\n         assertTrue(iter.hasNext());\r\n-        iter.next();\r\n+        assertTrue(iter.hasNext());\r\n+        assertEquals(Integer.valueOf(1), iter.next().getKey());\r\n         // below line should not affect remove\r\n         assertFalse(iter.hasNext());\r\n         iter.remove();\r\n```\r\nBut not really important, the last `assertTrue` is where the test fails on `master`.', 'commenter': 'kinow'}]"
300,src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java,"@@ -794,23 +794,21 @@ protected void nullValue() {
         public boolean hasNext() {
             checkMod();
             while (nextNull()) {
-                ReferenceEntry<K, V> e = entry;
+                ReferenceEntry<K, V> e = next;
                 int i = index;
                 while (e == null && i > 0) {
                     i--;
                     e = (ReferenceEntry<K, V>) parent.data[i];
                 }
-                entry = e;
+                next = e;
                 index = i;
                 if (e == null) {
-                    currentKey = null;
-                    currentValue = null;","[{'comment': 'Fix is here :point_up: , the rest is renaming variables.', 'commenter': 'kinow'}]"
316,src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java,"@@ -231,7 +231,29 @@ public boolean forEachIndex(IntPredicate consumer) {
     @Override
     public boolean forEachBitMap(LongPredicate consumer) {
         Objects.requireNonNull(consumer, ""consumer"");
-        return BitMapProducer.fromIndexProducer(this, shape.getNumberOfBits()).forEachBitMap(consumer);
+        int blocksm1 = BitMap.numberOfBitMaps(shape.getNumberOfBits()) - 1;","[{'comment': '`final int blocksm1`\r\n\r\nAlthough it is the same number I would prefer `counts.length` here and not `shape.getNumberOfBits()` since it is the total length of the counts array that is being iterated over.', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
316,src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java,"@@ -231,7 +231,29 @@ public boolean forEachIndex(IntPredicate consumer) {
     @Override
     public boolean forEachBitMap(LongPredicate consumer) {
         Objects.requireNonNull(consumer, ""consumer"");
-        return BitMapProducer.fromIndexProducer(this, shape.getNumberOfBits()).forEachBitMap(consumer);
+        int blocksm1 = BitMap.numberOfBitMaps(shape.getNumberOfBits()) - 1;
+        int i = 0;
+        long value;
+        // must break final block separate as the the number of bits may not fall on the long boundary","[{'comment': 'Remove `the the`', 'commenter': 'aherbert'}, {'comment': 'done', 'commenter': 'Claudenw'}]"
320,src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java,"@@ -52,5 +55,14 @@ public interface Hasher {
      * @param shape the shape of the desired Bloom filter.
      * @return the iterator of integers
      */
-    IndexProducer uniqueIndices(Shape shape);
+    default IndexProducer uniqueIndices(Shape shape) {
+        return new IndexProducer() {","[{'comment': 'The functional interface can return a lambda:\r\n```java\r\n        return consumer -> {\r\n            Objects.requireNonNull(consumer, ""consumer"");\r\n            return Hasher.this.indices(shape).forEachIndex(IndexFilter.create(shape, consumer));\r\n        };\r\n```', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
320,src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java,"@@ -186,20 +186,6 @@ public double estimateN(int cardinality) {
         return -(m / k) * Math.log1p(-c / m);
     }
 
-    /**","[{'comment': 'This was from a previous documented factory. If you are happy that this is covered by the class javadoc then fine. I think the factory method names can be implied to use the standard variable names, but it is not explicitly documented. \r\n\r\nNote: Unrelated - why is shape comparable? I thought this was previously discussed as unnecessary. I cannot find a Jira ticket for this. The method is not tested to return a specific order; its only usage in the package is in the equals function.\r\n\r\n', 'commenter': 'aherbert'}]"
320,src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java,"@@ -129,24 +126,60 @@ public IndexProducer indices(final Shape shape) {
             @Override
             public boolean forEachIndex(IntPredicate consumer) {
                 Objects.requireNonNull(consumer, ""consumer"");
-                int bits = shape.getNumberOfBits();
-                /*
-                 * Essentially this is computing a wrapped modulus from a start point and an
-                 * increment. So actually you only need two modulus operations before the loop.
-                 * This avoids any modulus operation inside the while loop. It uses a long index
-                 * to avoid overflow.
-                 */
-                long index = mod(initial, bits);
+                final int bits = shape.getNumberOfBits();
+                // Enhanced double hashing:
+                // hash[i] = ( h1(x) + i*h2(x) + (i*i*i - i)/6 ) mod bits
+                // See: https://en.wikipedia.org/wiki/Double_hashing#Enhanced_double_hashing
+                //
+                // Essentially this is computing a wrapped modulus from a start point and an
+                // increment and an additional term as a tetrahedral number.
+                // You only need two modulus operations before the loop. Within the loop
+                // the modulus is handled using the sign bit to detect wrapping to ensure:
+                // 0 <= index < bits
+                // 0 <= inc < bits
+                // The final hash is:
+                // hash[i] = ( h1(x) - i*h2(x) - (i*i*i - i)/6 ) wrapped in [0, bits)
+
+                int index = mod(initial, bits);
                 int inc = mod(increment, bits);
 
-                for (int functionalCount = 0; functionalCount < shape.getNumberOfHashFunctions(); functionalCount++) {
-
-                    if (!consumer.test((int) index)) {
-                        return false;
+                final int k = shape.getNumberOfHashFunctions();
+                if (k>bits) {","[{'comment': '`k > bits`', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
320,src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java,"@@ -58,50 +59,46 @@ private static long toLong(byte[] byteArray, int offset, int len) {
     }
 
     /**
-     * Constructs the SimpleHasher from a byte array.
+     * Constructs the EnhancedDoubleHasher from a byte array.
      * <p>The byte array is split in 2 and each half is interpreted as a long value.
      * Excess bytes are ignored.  This simplifies the conversion from a Digest or hasher algorithm output
      * to the two values used by the SimpleHasher.</p>
-     * <p><em>If the second long is zero the default increment is used instead.</em></p>
      * @param buffer the buffer to extract the longs from.
      * @throws IllegalArgumentException is buffer length is zero.
-     * @see #getDefaultIncrement()
      */
-    public SimpleHasher(byte[] buffer) {
+    public EnhancedDoubleHasher(byte[] buffer) {
         if (buffer.length == 0) {
             throw new IllegalArgumentException(""buffer length must be greater than 0"");
         }
         int segment = buffer.length / 2;","[{'comment': ""Since length will be positive you could use a bit shift here: `int segment = buffer.length >>> 1`\r\n\r\nThe conversion to long is not easy to explain and the javadoc is missing details. After dividing in half, up to the first 8 bytes from each half are used to construct a long. The bytes are interpreted in big-endian order but if the buffer is less than 8 bytes then zeros are effectively prepended at the start.\r\n\r\nThis is a non-standard zero fill behaviour (true big-endian number after the BE):\r\n```\r\n// big-endian order with zero filling start\r\na          -> a          BE: a0000000\r\nab         -> ab         BE: ab000000\r\nabcdefg    -> abcdefg    BE: abcdefg0\r\nabcdefgh   -> abcdefgh   BE: abcdefgh\r\n\r\n// Now ignoring the end as we reached 8 bytes\r\nabcdefghi  -> abcdefgh\r\nabcdefghij -> abcdefgh\r\n```\r\nThis is basically not achieving the same as:\r\n```Java\r\n        // copy (with zero-fill) at least 8 bytes from the offset\r\n        return ByteBuffer.wrap(\r\n            Arrays.copyOfRange(byteArray, offset, offset + Math.max(len, 8)))\r\n            .order(ByteOrder.BIG_ENDIAN)\r\n            .getLong();\r\n```\r\n\r\nIf you keep it the same then note that the `toLong` method can avoid an addition inside the loop by using a start-end iteration:\r\n```java\r\n    private static long toLong(byte[] byteArray, int offset, int len) {\r\n        long val = 0;\r\n        final int end = offset + Math.min(len, Long.BYTES);\r\n        for (int i = offset; i < end; i++) {\r\n            val <<= 8;\r\n            val |= (byteArray[i] & 0xff);\r\n        }\r\n        return val;\r\n    }\r\n```\r\nThe bytes could be interpreted as little-endian:\r\n```java\r\n    private static long toLong(byte[] byteArray, int offset, int len) {\r\n        long val = 0;\r\n        final int end = offset + Math.min(len, Long.BYTES);\r\n        int shift = 0;\r\n        for (int i = offset; i < end; i++) {\r\n            val |= (byteArray[i] & 0xff) << shift;\r\n            shift += 8;\r\n        }\r\n        return val;\r\n    }\r\n```\r\nUsing the little endian is easier to explain as the bytes are cut in half and up to 8 bytes from each is read as a long in little endian order. \r\n\r\nUsing little-endian, or the current code, both create smaller numbers when needing zero fill. Only a true big-endian read will create a large number.\r\n\r\n### Thoughts on the hasher input:\r\n\r\nNote that it is worse to create smaller numbers for the increment and start point. If the start is smaller than the number of bits in a filter then hashing will start at the same point when the size increases; likewise the increment will be the same if it remains smaller than the number of bits in the filter and so the first few indices will be the same if the number of bits changes (but is still larger than the increment). In a worse case scenario with small start and increments for all items, hashing may not create indices that fill the full region within a much larger filter. Imagine hashers created with a single byte for the start and increment (bounded to 255) with a filter size of 30000 and number of hash functions as 5. Ignoring the tetrahedral addition (a maximum of 20 for k=5) the max index is 255 * 4 + 255 = 1275, this covers 4.25% of the filter. This also ignores the negative wrapping but the behaviour is the same, some bits cannot be reached.\r\n\r\nSo this needs to be avoided as the filter probability assumptions will be void. If the start and increment are larger than the number of bits then the modulus will create a 'random' position and increment within the size. However if limited to only 1 byte then you still only have 255 possible start positions even though randomly spread. So use big-endian numbers does not help. What matters is the number of bits of entropy in the start and increment. If there are more than 4 bytes to create the long (little-endian) the numbers will be expected to exceed the maximum size of a filter (limited to a 32-bit int).\r\n\r\nThis behaviour could be noted in the javadoc. It is recommended to create a hasher using at least twice the number of random bytes as the number of non-zero bytes in the shape number of bits:\r\n```java\r\n2 * Math.ceil(Integer.highestOneBit(shape.getNumberOfBits()) / 8.0)\r\n```\r\nThat is quite verbose. To simplify then assume a max size shape and recommend that a hasher is not constructed with fewer than 8 bytes of entropy through the `byte[]` constructor, or the 4 bytes of entropy for each argument to the `long, long` constructor; and then update to interpret the bytes as little-endian.\r\n"", 'commenter': 'aherbert'}, {'comment': 'Converted to big endian adding extra bytes of 0 when there are not enough bytes in the buffer.  Added ""Thoughts on hasher"" to the class javadocs. \r\n', 'commenter': 'Claudenw'}]"
320,src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java,"@@ -21,14 +21,15 @@
 
 /**
  * A Hasher that implements combinatorial hashing as as described by
- * <a href=""https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf"">Krisch and Mitzenmacher</a>.
+ * <a href=""https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf"">Krisch and Mitzenmacher</a> using the enhanced double hashing technique
+ * described in the wikipedia article  <a href=""https://en.wikipedia.org/wiki/Double_hashing#Enhanced_double_hashing"">Double Hashing</a>.
  * <p>
  * Common use for this hasher is to generate a byte array as the output of a hashing","[{'comment': '`Common use for this hasher is to generate bit indices from a byte array output of ...`', 'commenter': 'aherbert'}, {'comment': 'fixed.', 'commenter': 'Claudenw'}]"
320,src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java,"@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Objects;
+import java.util.function.IntPredicate;
+
+/**
+ * To be used for testing only.
+ */
+class IncrementingHasher implements Hasher {
+
+    /**
+     * The initial hash value.
+     */
+    private final long initial;
+
+    /**
+     * The value to increment the hash value by.
+     */
+    private final long increment;
+
+    /**
+     * Constructs the IncrementingHasher from 2 longs.  The long values will be interpreted as unsigned values.
+     * <p><em>If the increment is zero the default increment is used instead.</em></p>
+     * @param initial The initial value for the hasher.
+     * @param increment The value to increment the hash by on each iteration.
+     * @see #getDefaultIncrement()","[{'comment': 'NA', 'commenter': 'aherbert'}, {'comment': 'removed', 'commenter': 'Claudenw'}]"
320,src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java,"@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Objects;
+import java.util.function.IntPredicate;
+
+/**
+ * To be used for testing only.
+ */
+class IncrementingHasher implements Hasher {
+
+    /**
+     * The initial hash value.
+     */
+    private final long initial;
+
+    /**
+     * The value to increment the hash value by.
+     */
+    private final long increment;
+
+    /**
+     * Constructs the IncrementingHasher from 2 longs.  The long values will be interpreted as unsigned values.
+     * <p><em>If the increment is zero the default increment is used instead.</em></p>
+     * @param initial The initial value for the hasher.
+     * @param increment The value to increment the hash by on each iteration.
+     * @see #getDefaultIncrement()
+     */
+    IncrementingHasher(long initial, long increment) {
+        this.initial = initial;
+        this.increment = increment;
+    }
+
+    /**
+     * Performs a modulus calculation on an unsigned long and an integer divisor.
+     * @param dividend a unsigned long value to calculate the modulus of.
+     * @param divisor the divisor for the modulus calculation.
+     * @return the remainder or modulus value.
+     */
+    static int mod(long dividend, int divisor) {","[{'comment': 'Duplicate of `EnhancedDoubleHasher.mod`. Since that method (which is tested) is package-private then just call that.', 'commenter': 'aherbert'}, {'comment': 'done', 'commenter': 'Claudenw'}]"
320,src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java,"@@ -129,24 +126,60 @@ public IndexProducer indices(final Shape shape) {
             @Override
             public boolean forEachIndex(IntPredicate consumer) {
                 Objects.requireNonNull(consumer, ""consumer"");
-                int bits = shape.getNumberOfBits();
-                /*
-                 * Essentially this is computing a wrapped modulus from a start point and an
-                 * increment. So actually you only need two modulus operations before the loop.
-                 * This avoids any modulus operation inside the while loop. It uses a long index
-                 * to avoid overflow.
-                 */
-                long index = mod(initial, bits);
+                final int bits = shape.getNumberOfBits();
+                // Enhanced double hashing:
+                // hash[i] = ( h1(x) + i*h2(x) + (i*i*i - i)/6 ) mod bits
+                // See: https://en.wikipedia.org/wiki/Double_hashing#Enhanced_double_hashing
+                //
+                // Essentially this is computing a wrapped modulus from a start point and an
+                // increment and an additional term as a tetrahedral number.
+                // You only need two modulus operations before the loop. Within the loop
+                // the modulus is handled using the sign bit to detect wrapping to ensure:
+                // 0 <= index < bits
+                // 0 <= inc < bits
+                // The final hash is:
+                // hash[i] = ( h1(x) - i*h2(x) - (i*i*i - i)/6 ) wrapped in [0, bits)
+
+                int index = mod(initial, bits);
                 int inc = mod(increment, bits);
 
-                for (int functionalCount = 0; functionalCount < shape.getNumberOfHashFunctions(); functionalCount++) {
-
-                    if (!consumer.test((int) index)) {
-                        return false;
+                final int k = shape.getNumberOfHashFunctions();
+                if (k>bits) {
+                    for (int j = k; j > 0;) {
+                        // handle k > bits
+                        final int block = Math.min(j, bits);
+                        j -= block;
+                        for (int i = 0; i < block; i++) {
+                            if (!consumer.test(index)) {
+                                return false;","[{'comment': 'This line has no coverage.\r\n\r\nThe last commit to Codecov failed. I reran the job to see if it was a glitch. You can do the same locally using:\r\n```Java\r\nmvn test jacoco:report\r\nopen target/site/jacoco/org.apache.commons.collections4.bloomfilter/EnhancedDoubleHasher.java.html\r\n```', 'commenter': 'aherbert'}, {'comment': 'Added test', 'commenter': 'Claudenw'}]"
320,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java,"@@ -78,12 +81,40 @@ public void testHashing(int k, int m) {
 
     @Test
     public void testUniqueIndex() {
-        // create a hasher that produces duplicates with the specified shape.
-        // this setup produces 5, 17, 29, 41, 53, 65 two times
-        Shape shape = Shape.fromKM(12, 72);
-        Hasher hasher = new SimpleHasher(5, 12);
-        Set<Integer> set = new HashSet<>();
-        assertTrue(hasher.uniqueIndices(shape).forEachIndex(set::add), ""Duplicate detected"");
-        assertEquals(6, set.size());
+        // @formatter:off
+        /*
+         * The probability of a collision when","[{'comment': 'Is there a reference for this?', 'commenter': 'aherbert'}, {'comment': 'After thinking about it for a bit, it was pointless.  Removed and replaced with a much simpler explanation.', 'commenter': 'Claudenw'}]"
320,src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java,"@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Objects;
+import java.util.function.IntPredicate;
+
+/**
+ * To be used for testing only.","[{'comment': 'You could transfer the javadoc from the old SimpleHasher to here. At least then the method is explained.', 'commenter': 'aherbert'}, {'comment': 'done', 'commenter': 'Claudenw'}]"
320,src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java,"@@ -0,0 +1,229 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Objects;
+import java.util.function.IntPredicate;
+
+/**
+ * A Hasher that implements combinatorial hashing as as described by
+ * <a href=""https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf"">Krisch and Mitzenmacher</a> using the enhanced double hashing technique
+ * described in the wikipedia article  <a href=""https://en.wikipedia.org/wiki/Double_hashing#Enhanced_double_hashing"">Double Hashing</a>.
+ * <p>
+ * Common use for this hasher is to generate bit indices from a byte array output of a hashing
+ * or MessageDigest algorithm.</p>
+ *
+ * <h2>Thoughts on the hasher input</h2>
+ *
+ *<p>Note that it is worse to create smaller numbers for the <code>initial</code> and <code>increment</code>. If the <code>initial</code> is smaller than","[{'comment': 'Use `{@code ...}` tags', 'commenter': 'aherbert'}]"
320,src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java,"@@ -0,0 +1,229 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Objects;
+import java.util.function.IntPredicate;
+
+/**
+ * A Hasher that implements combinatorial hashing as as described by
+ * <a href=""https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf"">Krisch and Mitzenmacher</a> using the enhanced double hashing technique
+ * described in the wikipedia article  <a href=""https://en.wikipedia.org/wiki/Double_hashing#Enhanced_double_hashing"">Double Hashing</a>.
+ * <p>
+ * Common use for this hasher is to generate bit indices from a byte array output of a hashing
+ * or MessageDigest algorithm.</p>
+ *
+ * <h2>Thoughts on the hasher input</h2>
+ *
+ *<p>Note that it is worse to create smaller numbers for the <code>initial</code> and <code>increment</code>. If the <code>initial</code> is smaller than
+ * the number of bits in a filter then hashing will start at the same point when the size increases; likewise the <code>increment</code> will be
+ * the same if it remains smaller than the number of bits in the filter and so the first few indices will be the same if the number of bits
+ * changes (but is still larger than the <code>increment</code>). In a worse case scenario with small <code>initial</code> and <code>increment</code> for
+ * all items, hashing may not create indices that fill the full region within a much larger filter. Imagine hashers created with <code>initial</code>
+ * and <code>increment</code> values less than 255 with a filter size of 30000 and number of hash functions as 5. Ignoring the
+ * tetrahedral addition (a maximum of 20 for k=5) the max index is 255 * 4 + 255 = 1275, this covers 4.25% of the filter. This also
+ * ignores the negative wrapping but the behaviour is the same, some bits cannot be reached.
+ * </p><p>
+ * So this needs to be avoided as the filter probability assumptions will be void. If the <code>initial</code> and <code>increment</code> are larger
+ * than the number of bits then the modulus will create a 'random' position and increment within the size.
+ * </p>
+ *
+ * @since 4.5
+ */
+public class EnhancedDoubleHasher implements Hasher {
+
+    /**
+     * The initial hash value.
+     */
+    private final long initial;
+
+    /**
+     * The value to increment the hash value by.
+     */
+    private final long increment;
+
+    /**
+     * Convert bytes to big-endian long filling with zero bytes as necessary..
+     * @param byteArray the byte array to extract the values from.
+     * @param offset the offset to start extraction from.
+     * @param len the length of the extraction, may be longer than 8.
+     * @return
+     */
+    private static long toLong(byte[] byteArray, int offset, int len) {
+        long val = 0;
+        len = Math.min(len, Long.BYTES);
+        int shift = Long.SIZE;
+        for (int i = 0; i < len; i++) {
+            shift -=  Byte.SIZE;
+            val |= ((long) (byteArray[offset + i] & 0x00FF) << shift);","[{'comment': '`0xff` or `0xFF`: no need for the leading zeros', 'commenter': 'aherbert'}]"
320,src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java,"@@ -0,0 +1,229 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Objects;
+import java.util.function.IntPredicate;
+
+/**
+ * A Hasher that implements combinatorial hashing as as described by
+ * <a href=""https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf"">Krisch and Mitzenmacher</a> using the enhanced double hashing technique
+ * described in the wikipedia article  <a href=""https://en.wikipedia.org/wiki/Double_hashing#Enhanced_double_hashing"">Double Hashing</a>.
+ * <p>
+ * Common use for this hasher is to generate bit indices from a byte array output of a hashing
+ * or MessageDigest algorithm.</p>
+ *
+ * <h2>Thoughts on the hasher input</h2>
+ *
+ *<p>Note that it is worse to create smaller numbers for the <code>initial</code> and <code>increment</code>. If the <code>initial</code> is smaller than
+ * the number of bits in a filter then hashing will start at the same point when the size increases; likewise the <code>increment</code> will be
+ * the same if it remains smaller than the number of bits in the filter and so the first few indices will be the same if the number of bits
+ * changes (but is still larger than the <code>increment</code>). In a worse case scenario with small <code>initial</code> and <code>increment</code> for
+ * all items, hashing may not create indices that fill the full region within a much larger filter. Imagine hashers created with <code>initial</code>
+ * and <code>increment</code> values less than 255 with a filter size of 30000 and number of hash functions as 5. Ignoring the
+ * tetrahedral addition (a maximum of 20 for k=5) the max index is 255 * 4 + 255 = 1275, this covers 4.25% of the filter. This also
+ * ignores the negative wrapping but the behaviour is the same, some bits cannot be reached.
+ * </p><p>
+ * So this needs to be avoided as the filter probability assumptions will be void. If the <code>initial</code> and <code>increment</code> are larger
+ * than the number of bits then the modulus will create a 'random' position and increment within the size.
+ * </p>
+ *
+ * @since 4.5
+ */
+public class EnhancedDoubleHasher implements Hasher {
+
+    /**
+     * The initial hash value.
+     */
+    private final long initial;
+
+    /**
+     * The value to increment the hash value by.
+     */
+    private final long increment;
+
+    /**
+     * Convert bytes to big-endian long filling with zero bytes as necessary..
+     * @param byteArray the byte array to extract the values from.
+     * @param offset the offset to start extraction from.
+     * @param len the length of the extraction, may be longer than 8.
+     * @return
+     */
+    private static long toLong(byte[] byteArray, int offset, int len) {
+        long val = 0;
+        len = Math.min(len, Long.BYTES);","[{'comment': 'Directly iterate over the index?:\r\n```Java\r\n        final int end = offset + Math.min(len, Long.BYTES);\r\n        for (int i = offset; i < end; i++) {\r\n```', 'commenter': 'aherbert'}]"
320,src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java,"@@ -0,0 +1,229 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Objects;
+import java.util.function.IntPredicate;
+
+/**
+ * A Hasher that implements combinatorial hashing as as described by
+ * <a href=""https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf"">Krisch and Mitzenmacher</a> using the enhanced double hashing technique
+ * described in the wikipedia article  <a href=""https://en.wikipedia.org/wiki/Double_hashing#Enhanced_double_hashing"">Double Hashing</a>.
+ * <p>
+ * Common use for this hasher is to generate bit indices from a byte array output of a hashing
+ * or MessageDigest algorithm.</p>
+ *
+ * <h2>Thoughts on the hasher input</h2>
+ *
+ *<p>Note that it is worse to create smaller numbers for the <code>initial</code> and <code>increment</code>. If the <code>initial</code> is smaller than
+ * the number of bits in a filter then hashing will start at the same point when the size increases; likewise the <code>increment</code> will be
+ * the same if it remains smaller than the number of bits in the filter and so the first few indices will be the same if the number of bits
+ * changes (but is still larger than the <code>increment</code>). In a worse case scenario with small <code>initial</code> and <code>increment</code> for
+ * all items, hashing may not create indices that fill the full region within a much larger filter. Imagine hashers created with <code>initial</code>
+ * and <code>increment</code> values less than 255 with a filter size of 30000 and number of hash functions as 5. Ignoring the
+ * tetrahedral addition (a maximum of 20 for k=5) the max index is 255 * 4 + 255 = 1275, this covers 4.25% of the filter. This also
+ * ignores the negative wrapping but the behaviour is the same, some bits cannot be reached.
+ * </p><p>
+ * So this needs to be avoided as the filter probability assumptions will be void. If the <code>initial</code> and <code>increment</code> are larger
+ * than the number of bits then the modulus will create a 'random' position and increment within the size.
+ * </p>
+ *
+ * @since 4.5
+ */
+public class EnhancedDoubleHasher implements Hasher {
+
+    /**
+     * The initial hash value.
+     */
+    private final long initial;
+
+    /**
+     * The value to increment the hash value by.
+     */
+    private final long increment;
+
+    /**
+     * Convert bytes to big-endian long filling with zero bytes as necessary..
+     * @param byteArray the byte array to extract the values from.
+     * @param offset the offset to start extraction from.
+     * @param len the length of the extraction, may be longer than 8.
+     * @return
+     */
+    private static long toLong(byte[] byteArray, int offset, int len) {
+        long val = 0;
+        len = Math.min(len, Long.BYTES);
+        int shift = Long.SIZE;
+        for (int i = 0; i < len; i++) {
+            shift -=  Byte.SIZE;
+            val |= ((long) (byteArray[offset + i] & 0x00FF) << shift);
+        }
+        return val;
+    }
+
+    /**
+     * Constructs the EnhancedDoubleHasher from a byte array.
+     * <p>
+     * This method simplifies the conversion from a Digest or hasher algorithm output
+     * to the two values used by the EnhancedDoubleHasher.</p>
+     * <p>The byte array is split in 2 and the first 8 bytes of each half are interpreted as a big-endian long value.
+     * Excess bytes are ignored.
+     * If there are fewer than 16 bytes the following conversions are made.
+     *</p>
+     * <ol>
+     * <li>If there is an odd number of bytes the excess byte is assigned to the increment value</li>
+     * <li>The bytes alloted are read in big-endian order any byte not populated is set to zero.</li>
+     * </ol>
+     * <p>
+     * This ensures that small arrays generate the largest possible increment and initial values.
+     * </p>
+     * @param buffer the buffer to extract the longs from.
+     * @throws IllegalArgumentException is buffer length is zero.
+     */
+    public EnhancedDoubleHasher(byte[] buffer) {
+        if (buffer.length == 0) {
+            throw new IllegalArgumentException(""buffer length must be greater than 0"");
+        }
+        // divide by 2
+        int segment = buffer.length / 2;
+        this.initial = toLong(buffer, 0, segment);
+        this.increment = toLong(buffer, segment, buffer.length - segment);
+    }
+
+    /**
+     * Constructs the EnhancedDoubleHasher from 2 longs.  The long values will be interpreted as unsigned values.
+     * @param initial The initial value for the hasher.
+     * @param increment The value to increment the hash by on each iteration.
+     */
+    public EnhancedDoubleHasher(long initial, long increment) {
+        this.initial = initial;
+        this.increment = increment;
+    }
+
+    /**
+     * Gets the initial value for the hash calculation.
+     * @return the initial value for the hash calculation.
+     */
+    long getInitial() {
+        return initial;
+    }
+
+    /**
+     * Gets the increment value for the hash calculation.
+     * @return the increment value for the hash calculation.
+     */
+    long getIncrement() {
+        return increment;
+    }
+
+    /**
+     * Performs a modulus calculation on an unsigned long and an integer divisor.
+     * @param dividend a unsigned long value to calculate the modulus of.
+     * @param divisor the divisor for the modulus calculation.
+     * @return the remainder or modulus value.
+     */
+    static int mod(long dividend, int divisor) {
+        // See Hacker's Delight (2nd ed), section 9.3.
+        // Assume divisor is positive.
+        // Divide half the unsigned number and then double the quotient result.
+        final long quotient = ((dividend >>> 1) / divisor) << 1;
+        final long remainder = dividend - quotient * divisor;
+        // remainder in [0, 2 * divisor)
+        return (int) (remainder >= divisor ? remainder - divisor : remainder);
+    }
+
+    @Override
+    public IndexProducer indices(final Shape shape) {
+        Objects.requireNonNull(shape, ""shape"");
+
+        return new IndexProducer() {
+
+            @Override
+            public boolean forEachIndex(IntPredicate consumer) {
+                Objects.requireNonNull(consumer, ""consumer"");
+                final int bits = shape.getNumberOfBits();
+                // Enhanced double hashing:
+                // hash[i] = ( h1(x) + i*h2(x) + (i*i*i - i)/6 ) mod bits
+                // See: https://en.wikipedia.org/wiki/Double_hashing#Enhanced_double_hashing
+                //
+                // Essentially this is computing a wrapped modulus from a start point and an
+                // increment and an additional term as a tetrahedral number.
+                // You only need two modulus operations before the loop. Within the loop
+                // the modulus is handled using the sign bit to detect wrapping to ensure:
+                // 0 <= index < bits
+                // 0 <= inc < bits
+                // The final hash is:
+                // hash[i] = ( h1(x) - i*h2(x) - (i*i*i - i)/6 ) wrapped in [0, bits)
+
+                int index = mod(initial, bits);
+                int inc = mod(increment, bits);
+
+                final int k = shape.getNumberOfHashFunctions();
+                if (k > bits) {
+                    for (int j = k; j > 0;) {
+                        // handle k > bits
+                        final int block = Math.min(j, bits);
+                        j -= block;
+                        for (int i = 0; i < block; i++) {
+                            if (!consumer.test(index)) {
+                                return false;
+                            }
+                            // Update index and handle wrapping
+                            index -= inc;
+                            index = index < 0 ? index + bits : index;
+
+                            // Incorporate the counter into the increment to create a
+                            // tetrahedral number additional term, and handle wrapping.
+                            inc -= i;
+                            inc = inc < 0 ? inc + bits : inc;
+                        }
+                    }
+                } else {
+                    for (int i = 0; i < k; i++) {
+                        if (!consumer.test(index)) {
+                            return false;
+                        }
+                        // Update index and handle wrapping
+                        index -= inc;
+                        index = index < 0 ? index + bits : index;
+
+                        // Incorporate the counter into the increment to create a
+                        // tetrahedral number additional term, and handle wrapping.
+                        inc -= i;
+                        inc = inc < 0 ? inc + bits : inc;
+                    }
+","[{'comment': 'Remove extra blank line', 'commenter': 'aherbert'}]"
320,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java,"@@ -74,16 +77,28 @@ public void testHashing(int k, int m) {
         });
         assertEquals(k * getHasherSize(hasher), count[0],
                 () -> String.format(""Did not produce k=%d * m=%d indices"", k, getHasherSize(hasher)));
+
+        // test early exit
+        count[0] = 0;
+        hasher.indices(Shape.fromKM(k, m)).forEachIndex(i -> {
+            assertTrue(i >= 0 && i < m, () -> ""Out of range: "" + i + "", m="" + m);
+            count[0]++;
+            return false;
+        });
+        assertEquals(1, count[0], ""did not exit early"" );
     }
 
     @Test
     public void testUniqueIndex() {
-        // create a hasher that produces duplicates with the specified shape.
-        // this setup produces 5, 17, 29, 41, 53, 65 two times
-        Shape shape = Shape.fromKM(12, 72);
-        Hasher hasher = new SimpleHasher(5, 12);
-        Set<Integer> set = new HashSet<>();
-        assertTrue(hasher.uniqueIndices(shape).forEachIndex(set::add), ""Duplicate detected"");
-        assertEquals(6, set.size());
+        // generating 11 numbers in the ragne of [0,9] will yield at least on collision.","[{'comment': '`range`', 'commenter': 'aherbert'}]"
320,src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java,"@@ -0,0 +1,94 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests the {@link EnhancedDoubleHasher}.
+ */
+public class EnhancedDoubleHasherTest extends AbstractHasherTest {
+
+    @Override
+    protected Hasher createHasher() {
+        return new EnhancedDoubleHasher(1, 1);
+    }
+
+    @Override
+    protected Hasher createEmptyHasher() {
+        return NullHasher.INSTANCE;
+    }
+
+    @Override
+    protected int getHasherSize(Hasher hasher) {
+        return 1;
+    }
+
+    @Test
+    public void testConstructor() {
+        // single value become increment.
+        EnhancedDoubleHasher hasher = new EnhancedDoubleHasher( new byte[] { 1 } );
+        assertEquals( 0, hasher.getInitial() );
+        assertEquals( 0x100000000000000L, hasher.getIncrement() );","[{'comment': 'In this test It may be useful to have the leading zero. You can break up the constants using underscores:\r\n```\r\n0x0100_0000_0000_0000L\r\n```\r\nThis makes it more readable. Typically using `_` every 2 bytes is common but here we could use every byte:\r\n```\r\n0x01_00_00_00_00_00_00_00L\r\n```', 'commenter': 'aherbert'}]"
320,src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java,"@@ -0,0 +1,94 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests the {@link EnhancedDoubleHasher}.
+ */
+public class EnhancedDoubleHasherTest extends AbstractHasherTest {
+
+    @Override
+    protected Hasher createHasher() {
+        return new EnhancedDoubleHasher(1, 1);
+    }
+
+    @Override
+    protected Hasher createEmptyHasher() {
+        return NullHasher.INSTANCE;
+    }
+
+    @Override
+    protected int getHasherSize(Hasher hasher) {
+        return 1;
+    }
+
+    @Test
+    public void testConstructor() {","[{'comment': 'testByteConstructor', 'commenter': 'aherbert'}]"
320,src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java,"@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Objects;
+import java.util.function.IntPredicate;
+
+/**
+ * A Hasher that implements simple combinatorial hashing as as described by
+ * <a href=""https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf"">Krisch and Mitzenmacher</a>.
+ *
+ * <p>To be used for testing only.</p>
+ *
+ * @since 4.5
+ */
+class IncrementingHasher implements Hasher {
+
+    /**
+     * The initial hash value.
+     */
+    private final long initial;
+
+    /**
+     * The value to increment the hash value by.
+     */
+    private final long increment;
+
+    /**
+     * Constructs the IncrementingHasher from 2 longs.  The long values will be interpreted as unsigned values.
+     * <p>
+     * The initial hash value will be the modulus of the initial value.
+     * Subsequent values will be calculated by repeatedly adding the increment to the last value and taking the modulus.
+     * </p>
+     * @param initial The initial value for the hasher.
+     * @param increment The value to increment the hash by on each iteration.
+     * @see #getDefaultIncrement()","[{'comment': 'The reference to `getDefaultIncrement()` is still present.', 'commenter': 'aherbert'}]"
320,src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java,"@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Objects;
+import java.util.function.IntPredicate;
+
+/**
+ * A Hasher that implements simple combinatorial hashing as as described by
+ * <a href=""https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf"">Krisch and Mitzenmacher</a>.
+ *
+ * <p>To be used for testing only.</p>
+ *
+ * @since 4.5
+ */
+class IncrementingHasher implements Hasher {
+
+    /**
+     * The initial hash value.
+     */
+    private final long initial;
+
+    /**
+     * The value to increment the hash value by.
+     */
+    private final long increment;
+
+    /**
+     * Constructs the IncrementingHasher from 2 longs.  The long values will be interpreted as unsigned values.
+     * <p>
+     * The initial hash value will be the modulus of the initial value.
+     * Subsequent values will be calculated by repeatedly adding the increment to the last value and taking the modulus.
+     * </p>
+     * @param initial The initial value for the hasher.
+     * @param increment The value to increment the hash by on each iteration.
+     * @see #getDefaultIncrement()
+     */
+    IncrementingHasher(long initial, long increment) {
+        this.initial = initial;
+        this.increment = increment;
+    }
+
+    @Override
+    public IndexProducer indices(final Shape shape) {
+        Objects.requireNonNull(shape, ""shape"");
+
+        return new IndexProducer() {
+
+            @Override
+            public boolean forEachIndex(IntPredicate consumer) {
+                Objects.requireNonNull(consumer, ""consumer"");
+                int bits = shape.getNumberOfBits();
+                /*
+                 * Essentially this is computing a wrapped modulus from a start point and an
+                 * increment. So actually you only need two modulus operations before the loop.
+                 * This avoids any modulus operation inside the while loop. It uses a long index
+                 * to avoid overflow.
+                 */
+                long index = EnhancedDoubleHasher.mod(initial, bits);
+                int inc = EnhancedDoubleHasher.mod(increment, bits);
+
+                for (int functionalCount = 0; functionalCount < shape.getNumberOfHashFunctions(); functionalCount++) {
+","[{'comment': 'Remove extra line', 'commenter': 'aherbert'}]"
320,src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java,"@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Objects;
+import java.util.function.IntPredicate;
+
+/**
+ * A Hasher that implements simple combinatorial hashing as as described by
+ * <a href=""https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf"">Krisch and Mitzenmacher</a>.
+ *
+ * <p>To be used for testing only.</p>
+ *
+ * @since 4.5
+ */
+class IncrementingHasher implements Hasher {
+
+    /**
+     * The initial hash value.
+     */
+    private final long initial;
+
+    /**
+     * The value to increment the hash value by.
+     */
+    private final long increment;
+
+    /**
+     * Constructs the IncrementingHasher from 2 longs.  The long values will be interpreted as unsigned values.
+     * <p>
+     * The initial hash value will be the modulus of the initial value.
+     * Subsequent values will be calculated by repeatedly adding the increment to the last value and taking the modulus.
+     * </p>
+     * @param initial The initial value for the hasher.
+     * @param increment The value to increment the hash by on each iteration.
+     * @see #getDefaultIncrement()
+     */
+    IncrementingHasher(long initial, long increment) {
+        this.initial = initial;
+        this.increment = increment;
+    }
+
+    @Override
+    public IndexProducer indices(final Shape shape) {
+        Objects.requireNonNull(shape, ""shape"");
+
+        return new IndexProducer() {
+
+            @Override
+            public boolean forEachIndex(IntPredicate consumer) {
+                Objects.requireNonNull(consumer, ""consumer"");
+                int bits = shape.getNumberOfBits();
+                /*
+                 * Essentially this is computing a wrapped modulus from a start point and an","[{'comment': 'Change c-style comment to a Java block comment (using `//`)', 'commenter': 'aherbert'}]"
320,src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java,"@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.Objects;
+import java.util.function.IntPredicate;
+
+/**
+ * A Hasher that implements simple combinatorial hashing as as described by
+ * <a href=""https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf"">Krisch and Mitzenmacher</a>.
+ *
+ * <p>To be used for testing only.</p>
+ *
+ * @since 4.5
+ */
+class IncrementingHasher implements Hasher {
+
+    /**
+     * The initial hash value.
+     */
+    private final long initial;
+
+    /**
+     * The value to increment the hash value by.
+     */
+    private final long increment;
+
+    /**
+     * Constructs the IncrementingHasher from 2 longs.  The long values will be interpreted as unsigned values.
+     * <p>
+     * The initial hash value will be the modulus of the initial value.
+     * Subsequent values will be calculated by repeatedly adding the increment to the last value and taking the modulus.
+     * </p>
+     * @param initial The initial value for the hasher.
+     * @param increment The value to increment the hash by on each iteration.
+     * @see #getDefaultIncrement()
+     */
+    IncrementingHasher(long initial, long increment) {
+        this.initial = initial;
+        this.increment = increment;
+    }
+
+    @Override
+    public IndexProducer indices(final Shape shape) {
+        Objects.requireNonNull(shape, ""shape"");
+
+        return new IndexProducer() {
+
+            @Override
+            public boolean forEachIndex(IntPredicate consumer) {
+                Objects.requireNonNull(consumer, ""consumer"");
+                int bits = shape.getNumberOfBits();
+                /*
+                 * Essentially this is computing a wrapped modulus from a start point and an
+                 * increment. So actually you only need two modulus operations before the loop.
+                 * This avoids any modulus operation inside the while loop. It uses a long index
+                 * to avoid overflow.
+                 */
+                long index = EnhancedDoubleHasher.mod(initial, bits);
+                int inc = EnhancedDoubleHasher.mod(increment, bits);
+
+                for (int functionalCount = 0; functionalCount < shape.getNumberOfHashFunctions(); functionalCount++) {
+
+                    if (!consumer.test((int) index)) {
+                        return false;
+                    }
+                    index += inc;
+                    index = index >= bits ? index - bits : index;
+                }
+                return true;
+            }
+
+            @Override
+            public int[] asIndexArray() {
+                int[] result = new int[shape.getNumberOfHashFunctions()];
+                int[] idx = new int[1];
+                /*","[{'comment': 'Change c-style comment to use `// ...`', 'commenter': 'aherbert'}]"
325,src/site/xdoc/pick.xml,"@@ -112,66 +112,66 @@ The <a href=""https://commons.apache.org/collections/apidocs-COLLECTIONS_3_1/org/
 <h3>Map interface</h3>
 
 <p>
-The <a href=""http://java.sun.com/j2se/1.4/docs/api/java/util/Map.html"">Map</a> interface and implementations in both the JDK and Commons Collections allow you to lookup data from a key to a value. This is one of the most powerful interfaces in the JDK, however it is very difficult to implement. These are the available implementations:
+The <a href=""https://docs.oracle.com/javase/8/docs/api/java/util/Map.html"">Map</a> interface and implementations in both the JDK and Commons Collections allow you to lookup data from a key to a value. This is one of the most powerful interfaces in the JDK, however it is very difficult to implement. These are the available implementations:
 <table>
 <tr>
-<td><a href=""http://java.sun.com/j2se/1.4/docs/api/java/util/HashMap.html"">HashMap</a> (JDK)</td>
+<td><a href=""https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html"">HashMap</a> (JDK)</td>
 <td>This map is the most commonly used and fastest implementation. It is suitable for most situations and can store any object. Objects are stored in any order, and the order may change over time.</td>
 </tr>
 <tr>
-<td><a href=""https://commons.apache.org/collections/apidocs-COLLECTIONS_3_1/org/apache/commons/collections/map/HashedMap.html"">HashedMap</a></td>
-<td>The Commons Collections hash map implementation which is very similar in design to HashMap, but also supports easy iteration via a <a href=""https://commons.apache.org/collections/apidocs-COLLECTIONS_3_1/org/apache/commons/collections/MapIterator.html"">MapIterator</a>. This implementation is also designed to be subclassed. Use this map if you want to use the extra iterator, or to subclass. Otherwise, there is no advantage (or disadvantage) compared to the JDK HashMap.</td>
+<td><a href=""https://javadoc.io/doc/commons-collections/commons-collections/3.1/org/apache/commons/collections/map/HashedMap.html"">HashedMap</a></td>
+<td>The Commons Collections hash map implementation which is very similar in design to HashMap, but also supports easy iteration via a <a href=""https://javadoc.io/doc/commons-collections/commons-collections/3.1/org/apache/commons/collections/MapIterator.html"">MapIterator</a>. This implementation is also designed to be subclassed. Use this map if you want to use the extra iterator, or to subclass. Otherwise, there is no advantage (or disadvantage) compared to the JDK HashMap.</td>
 </tr>
 <tr>
-<td><a href=""https://commons.apache.org/collections/apidocs-COLLECTIONS_3_1/org/apache/commons/collections/map/IdentityMap.html"">IdentityMap</a></td>
+<td><a href=""https://javadoc.io/doc/commons-collections/commons-collections/3.1/org/apache/commons/collections/map/IdentityMap.html"">IdentityMap</a></td>
 <td>This map operates exactly as per HashedMap but compares keys and values using == not .equals().</td>
 </tr>
 <tr>
-<td><a href=""http://java.sun.com/j2se/1.4/docs/api/java/util/IdentityHashMap.html"">IdentityHashMap</a> (JDK)</td>
+<td><a href=""https://docs.oracle.com/javase/8/docs/api/java/util/IdentityHashMap.html"">IdentityHashMap</a> (JDK)</td>
 <td>This map operates exactly as per HashMap but compares keys and values using == not .equals().</td>
 </tr>
 <tr>
-<td><a href=""http://java.sun.com/j2se/1.4/docs/api/java/util/TreeMap.html"">TreeMap</a> (JDK)</td>
-<td>This map ensures that the keys are always sorted, and iteration order is consistent. All keys must implement <a href=""http://java.sun.com/j2se/1.4/docs/api/java/lang/Comparable.html"">Comparable</a>, unless a comparator is supplied. This map should be used if you need the map to be sorted.</td>
+<td><a href=""https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html"">TreeMap</a> (JDK)</td>
+<td>This map ensures that the keys are always sorted, and iteration order is consistent. All keys must implement <a href=""https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html"">Comparable</a>, unless a comparator is supplied. This map should be used if you need the map to be sorted.</td>
 </tr>
 <tr>
-<td><a href=""https://commons.apache.org/collections/apidocs-COLLECTIONS_3_1/org/apache/commons/collections/map/LinkedMap.html"">LinkedMap</a></td>
+<td><a href=""https://javadoc.io/doc/commons-collections/commons-collections/3.1/org/apache/commons/collections/map/LinkedMap.html"">LinkedMap</a></td>
 <td>This map maintains the order that each object is added to the map. When the map is viewed via an iterator, the insertion order will be seen. This map should be used if you need to retain the insertion order.</td>
 </tr>
 <tr>
-<td><a href=""http://java.sun.com/j2se/1.4/docs/api/java/util/LinkedHashMap.html"">LinkedHashMap</a> (JDK)</td>
+<td><a href=""https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html"">LinkedHashMap</a> (JDK)</td>
 <td>This map, available from JDK 1.4, maintains the order that each object is added to the map. When the map is viewed via an iterator, the insertion order will be seen. Commons collections' LinkedMap provides the same functionality for JDK1.2 onwards and provides a MapIterator.</td>
 </tr>
 <tr>
-<td><a href=""https://commons.apache.org/collections/apidocs-COLLECTIONS_3_1/org/apache/commons/collections/map/ListOrderedMap.html"">ListOrderedMap</a></td>
+<td><a href=""https://javadoc.io/doc/commons-collections/commons-collections/3.1/org/apache/commons/collections/map/ListOrderedMap.html"">ListOrderedMap</a></td>
 <td>This map decorates another map to maintains the order that each object is added to the map. The order is maintained using a list. This map should be used if you need to retain the insertion order but you also need the special features of another map.</td>
 </tr>
 <tr>
-<td><a href=""https://commons.apache.org/collections/apidocs-COLLECTIONS_3_1/org/apache/commons/collections/map/LRUMap.html"">LRUMap</a></td>
+<td><a href=""https://javadoc.io/doc/commons-collections/commons-collections/3.1/org/apache/commons/collections/map/LRUMap.html"">LRUMap</a></td>
 <td>This map places a maximum size limit on the map and removes the least recently used (LRU) key-value when it is full. This map should be used for caches where you want to limit the maximum memory size used, and are happy with the least recently used algorithm for removals.</td>
 </tr>
 <tr>
-<td><a href=""https://commons.apache.org/collections/apidocs-COLLECTIONS_3_1/org/apache/commons/collections/map/ReferenceMap.html"">ReferenceMap</a></td>
+<td><a href=""https://javadoc.io/doc/commons-collections/commons-collections/3.1/org/apache/commons/collections/map/ReferenceMap.html"">ReferenceMap</a></td>
 <td>This map enables keys and values to be garbage collected whilst still held in the map. This can be useful for building memory sensitive caches. This map should be used for caches where you want to allow garbage collection from the map.</td>
 </tr>
 <tr>
-<td><a href=""http://java.sun.com/j2se/1.4/docs/api/java/util/WeakHashMap.html"">WeakHashMap</a> (JDK)</td>
+<td><a href=""https://docs.oracle.com/javase/8/docs/api/java/util/WeakHashMap.html"">WeakHashMap</a> (JDK)</td>
 <td>This map stores each key-value pair with a key that can be garbage collected. This can be useful for building memory sensitive caches. ReferenceMap provides the same functionality but with much more flexibility.</td>
 </tr>
 <tr>
-<td><a href=""https://commons.apache.org/collections/apidocs-COLLECTIONS_3_1/org/apache/commons/collections/map/ReferenceIdentityMap.html"">ReferenceIdentityMap</a></td>
+<td><a href=""https://javadoc.io/doc/commons-collections/commons-collections/3.1/org/apache/commons/collections/map/ReferenceIdentityMap.html"">ReferenceIdentityMap</a></td>
 <td>This map operates exactly as per ReferenceMap but compares keys and values using == not .equals().</td>
 </tr>
 <tr>
-<td><a href=""https://commons.apache.org/collections/apidocs-COLLECTIONS_3_1/org/apache/commons/collections/map/SingletonMap.html"">SingletonMap</a></td>
+<td><a href=""https://javadoc.io/doc/commons-collections/commons-collections/3.1/org/apache/commons/collections/map/SingletonMap.html"">SingletonMap</a></td>
 <td>This map is restricted to storing one key-value pair. It may contain no more than and no less than one pair. It provides a MapIterator. This map should be used if you want to return one key-value pair and must use the Map interface.</td>
 </tr>
 <tr>
-<td><a href=""https://commons.apache.org/collections/apidocs-COLLECTIONS_3_1/org/apache/commons/collections/map/Flat3Map.html"">Flat3Map</a></td>
+<td><a href=""https://javadoc.io/doc/commons-collections/commons-collections/3.1/org/apache/commons/collections/map/Flat3Map.html"">Flat3Map</a></td>
 <td>This map is optimised to store one, two or three key-value pairs and outperforms HashMap at these sizes. For size four and above performance is about 5% slower than HashMap. This map also has good garbage collection characteristics when below size four. It provides a MapIterator. This map should be used if are 99% sure that the map will be size three or less.</td>
 </tr>
 <tr>
-<td><a href=""https://commons.apache.org/collections/apidocs-COLLECTIONS_3_1/org/apache/commons/collections/map/StaticBucketMap.html"">StaticBucketMap</a></td>
+<td><a href=""https://javadoc.io/doc/commons-collections/commons-collections/3.1/org/apache/commons/collections/map/StaticBucketMap.html"">StaticBucketMap</a></td>","[{'comment': ""I think an alternative here would be to fix the apache.org link. The javadoc.io is maintained externally, and I'm not sure if it'd be available in the long run. The link to report issues leads to an account of a single GitHub user, i.e. bus-factor=1 for reporting issues & maintenance."", 'commenter': 'kinow'}, {'comment': '@kinow, unfortunately the javadoc for commons-collection 3.1 is not available on https://commons.apache.org/proper/commons-collections/javadocs/. Should I use links to the 3.2.2 ?', 'commenter': 'marcwrobel'}, {'comment': '@kinow, I will use the 4.4 version instead. I think it makes more sense.', 'commenter': 'marcwrobel'}, {'comment': '@kinow, I had to remove the documentation about `org.apache.commons.collections.map.IdentityMap` : This class has been removed in version 4.0 (see https://commons.apache.org/proper/commons-collections/release_4_0.html).', 'commenter': 'marcwrobel'}]"
325,src/site/xdoc/download_collections.xml,"@@ -208,27 +208,27 @@ limitations under the License.
         <table>
           <tr>
               <td><a href=""[preferred]/commons/collections/binaries/commons-collections-3.2.2-bin.tar.gz"">commons-collections-3.2.2-bin.tar.gz</a></td>
-              <td><a href=""https://www.apache.org/dist/commons/collections/binaries/commons-collections-3.2.2-bin.tar.gz.sha256"">sha256</a></td>
-              <td><a href=""https://www.apache.org/dist/commons/collections/binaries/commons-collections-3.2.2-bin.tar.gz.asc"">pgp</a></td>
+              <td><a href=""https://downloads.apache.org/commons/collections/binaries/commons-collections-3.2.2-bin.tar.gz.sha256"">sha256</a></td>
+              <td><a href=""https://downloads.apache.org/commons/collections/binaries/commons-collections-3.2.2-bin.tar.gz.asc"">pgp</a></td>
           </tr>
           <tr>
               <td><a href=""[preferred]/commons/collections/binaries/commons-collections-3.2.2-bin.zip"">commons-collections-3.2.2-bin.zip</a></td>
-              <td><a href=""https://www.apache.org/dist/commons/collections/binaries/commons-collections-3.2.2-bin.zip.sha256"">sha256</a></td>
-              <td><a href=""https://www.apache.org/dist/commons/collections/binaries/commons-collections-3.2.2-bin.zip.asc"">pgp</a></td>
+              <td><a href=""https://downloads.apache.org/commons/collections/binaries/commons-collections-3.2.2-bin.zip.sha256"">sha256</a></td>
+              <td><a href=""https://downloads.apache.org/commons/collections/binaries/commons-collections-3.2.2-bin.zip.asc"">pgp</a></td>
           </tr>
         </table>
       </subsection>
       <subsection name=""Source"">
         <table>
           <tr>
               <td><a href=""[preferred]/commons/collections/source/commons-collections-3.2.2-src.tar.gz"">commons-collections-3.2.2-src.tar.gz</a></td>
-              <td><a href=""https://www.apache.org/dist/commons/collections/source/commons-collections-3.2.2-src.tar.gz.sha256"">sha256</a></td>
-              <td><a href=""https://www.apache.org/dist/commons/collections/source/commons-collections-3.2.2-src.tar.gz.asc"">pgp</a></td>
+              <td><a href=""https://downloads.apache.org/commons/collections/source/commons-collections-3.2.2-src.tar.gz.sha256"">sha256</a></td>
+              <td><a href=""https://downloads.apache.org/commons/collections/source/commons-collections-3.2.2-src.tar.gz.asc"">pgp</a></td>
           </tr>
           <tr>
               <td><a href=""[preferred]/commons/collections/source/commons-collections-3.2.2-src.zip"">commons-collections-3.2.2-src.zip</a></td>
-              <td><a href=""https://www.apache.org/dist/commons/collections/source/commons-collections-3.2.2-src.zip.sha256"">sha256</a></td>
-              <td><a href=""https://www.apache.org/dist/commons/collections/source/commons-collections-3.2.2-src.zip.asc"">pgp</a></td>
+              <td><a href=""https://downloads.apache.org/commons/collections/source/commons-collections-3.2.2-src.zip.sha256"">sha256</a></td>
+              <td><a href=""https://downloads.apache.org/commons/collections/source/commons-collections-3.2.2-src.zip.asc"">pgp</a></td>","[{'comment': ""The old links appear to still work, but maybe it's fine to update this file manually.\r\n\r\nIt is automatically generated by the commons-build-plugin: https://github.com/apache/commons-build-plugin/tree/master/src/main/resources/commons-xdoc-templates"", 'commenter': 'kinow'}, {'comment': 'File has been rollbacked.', 'commenter': 'marcwrobel'}]"
325,RELEASE-NOTES.txt,"@@ -347,4 +347,4 @@ o COLLECTIONS-217:  Calling ""setValue(Object)"" on any Entry returned by a ""Flat3
 For complete information on Apache Commons Collections, including instructions on how to submit bug reports,
 patches, or suggestions for improvement, see the Apache Commons Collections website:
 
-https://commons.apache.org/collections/
+https://commons.apache.org/proper/commons-collections/","[{'comment': ':+1: less one hop to reach the page.\r\n\r\nNote, however, that this file is automatically re-generated by the commons-release-plugin: https://github.com/apache/commons-release-plugin/blob/3a0a64db33251d5a3bc808790d140f7db7347157/src/changes/release-notes.vm\r\n\r\nA release-manager follows steps defined in this page, which includes other commands that generate this and other files: https://commons.apache.org/releases/prepare.html', 'commenter': 'kinow'}, {'comment': 'File has been rollbacked.', 'commenter': 'marcwrobel'}]"
325,README.md,"@@ -46,15 +46,15 @@ Apache Commons Collections
 [![Build Status](https://travis-ci.org/apache/commons-collections.svg)](https://travis-ci.org/apache/commons-collections)
 [![Coverage Status](https://coveralls.io/repos/apache/commons-collections/badge.svg)](https://coveralls.io/r/apache/commons-collections)
 [![Maven Central](https://maven-badges.herokuapp.com/maven-central/org.apache.commons/commons-collections4/badge.svg)](https://maven-badges.herokuapp.com/maven-central/org.apache.commons/commons-collections4/)
-[![Javadocs](https://javadoc.io/badge/org.apache.commons/commons-collections4/4.4.svg)](https://javadoc.io/doc/org.apache.commons/commons-collections4/4.4)
+[![Javadocs](https://javadoc.io/badge/org.apache.commons/commons-collections4/4.4.svg)](https://commons.apache.org/proper/commons-collections/javadocs/api-4.4/)
 
 The Apache Commons Collections package contains types that extend and augment the Java Collections Framework.
 
 Documentation
 -------------
 
-More information can be found on the [Apache Commons Collections homepage](https://commons.apache.org/proper/commons-collections).
-The [Javadoc](https://commons.apache.org/proper/commons-collections/apidocs) can be browsed.
+More information can be found on the [Apache Commons Collections homepage](https://commons.apache.org/proper/commons-collections/).
+The [Javadoc](https://commons.apache.org/proper/commons-collections/apidocs/) can be browsed.","[{'comment': 'I believe this file is generated automatically by the commons plug-ins.', 'commenter': 'kinow'}, {'comment': 'File has been rollbacked.', 'commenter': 'marcwrobel'}]"
325,README.md,"@@ -46,15 +46,15 @@ Apache Commons Collections
 [![Build Status](https://travis-ci.org/apache/commons-collections.svg)](https://travis-ci.org/apache/commons-collections)
 [![Coverage Status](https://coveralls.io/repos/apache/commons-collections/badge.svg)](https://coveralls.io/r/apache/commons-collections)
 [![Maven Central](https://maven-badges.herokuapp.com/maven-central/org.apache.commons/commons-collections4/badge.svg)](https://maven-badges.herokuapp.com/maven-central/org.apache.commons/commons-collections4/)
-[![Javadocs](https://javadoc.io/badge/org.apache.commons/commons-collections4/4.4.svg)](https://javadoc.io/doc/org.apache.commons/commons-collections4/4.4)
+[![Javadocs](https://javadoc.io/badge/org.apache.commons/commons-collections4/4.4.svg)](https://commons.apache.org/proper/commons-collections/javadocs/api-4.4/)","[{'comment': ':+1: better to use the apache.org link whenever possible. Thanks!', 'commenter': 'kinow'}]"
325,CONTRIBUTING.md,"@@ -106,8 +106,8 @@ Additional Resources
 + [Contributing patches](https://commons.apache.org/patches.html)
 + [Apache Commons Collections JIRA project page][jira]
 + [Contributor License Agreement][cla]
-+ [General GitHub documentation](https://help.github.com/)
-+ [GitHub pull request documentation](https://help.github.com/articles/creating-a-pull-request/)
++ [General GitHub documentation](https://docs.github.com/en)
++ [GitHub pull request documentation](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request)
 + [Apache Commons Twitter Account](https://twitter.com/ApacheCommons)
 + `#apache-commons` IRC channel on `irc.freenode.net`","[{'comment': 'This file is automatically re-generated by the commons-build-plugin, where I believe the links are also incorrect.\r\n\r\nIt means that even if we merge this commit, during the next release these files will be overwritten bringing back the same old links :+1: : https://github.com/apache/commons-build-plugin/blob/master/src/main/resources/commons-xdoc-templates/contributing-md-template.md', 'commenter': 'kinow'}, {'comment': 'File has been rollbacked.', 'commenter': 'marcwrobel'}]"
329,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -29,6 +29,15 @@
  */
 public interface BloomFilter extends IndexProducer, BitMapProducer {
 
+    /**
+     * The sparse characteristic used to determine the best method for matching.
+     * <p>For `sparse` implementations
+     * the {@code forEachIndex(IntConsumer consumer)} method is more efficient.  For non `sparse` implementations
+     * the {@code forEachBitMap(LongConsumer consumer)} is more efficient.  Implementers should determine if it is easier
+     * for the implementation to produce indexes of bit map blocks.</p>
+     */
+    int SPARSE=0x1;","[{'comment': '`SPARSE = 0x1`', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
329,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -38,17 +47,12 @@ public interface BloomFilter extends IndexProducer, BitMapProducer {
     // Query Operations
 
     /**
-     * This method is used to determine the best method for matching.
-     *
-     * <p>For `sparse` implementations
-     * the {@code forEachIndex(IntConsumer consumer)} method is more efficient.  For non `sparse` implementations
-     * the {@code forEachBitMap(LongConsumer consumer)} is more efficient.  Implementers should determine if it is easier
-     * for the implementation to produce indexes of bit map blocks.</p>
-     *
-     * @return {@code true} if the implementation is sparse {@code false} otherwise.
-     * @see BitMap
+     * Returns the bitmap of characteristics of the filter.
+     * <p>
+     * Characteristics are defined as bits witin the characteristics integer.","[{'comment': '`within`', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
329,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -38,17 +47,12 @@ public interface BloomFilter extends IndexProducer, BitMapProducer {
     // Query Operations
 
     /**
-     * This method is used to determine the best method for matching.
-     *
-     * <p>For `sparse` implementations
-     * the {@code forEachIndex(IntConsumer consumer)} method is more efficient.  For non `sparse` implementations
-     * the {@code forEachBitMap(LongConsumer consumer)} is more efficient.  Implementers should determine if it is easier
-     * for the implementation to produce indexes of bit map blocks.</p>
-     *
-     * @return {@code true} if the implementation is sparse {@code false} otherwise.
-     * @see BitMap
+     * Returns the bitmap of characteristics of the filter.","[{'comment': 'Drop the `bitmap of`. I think it confusing as `bitmap` in this package is specifically used to refer to a range of indices [0, 63] packed into a long.', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
329,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -69,7 +73,7 @@ public interface BloomFilter extends IndexProducer, BitMapProducer {
      */
     default boolean contains(BloomFilter other) {
         Objects.requireNonNull(other, ""other"");
-        return isSparse() ? contains((IndexProducer) other) : contains((BitMapProducer) other);
+        return (characteristics()&SPARSE)>0 ? contains((IndexProducer) other) : contains((BitMapProducer) other);","[{'comment': 'whitespace: `(characteristics() & SPARSE) != 0`', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
329,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -144,7 +148,7 @@ default boolean merge(Hasher hasher) {
         Objects.requireNonNull(hasher, ""hasher"");
         Shape shape = getShape();
         // create the bloomfilter that is most likely to merge quickly with this one
-        BloomFilter result = isSparse() ? new SparseBloomFilter(shape, hasher) : new SimpleBloomFilter(shape, hasher);
+        BloomFilter result = (characteristics()&SPARSE)>0 ? new SparseBloomFilter(shape, hasher) : new SimpleBloomFilter(shape, hasher);","[{'comment': 'whitespace: `(characteristics() & SPARSE) != 0`', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
329,src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java,"@@ -65,7 +65,7 @@ public SimpleBloomFilter(BloomFilter other) {
         this.shape = other.getShape();
         this.bitMap = new long[BitMap.numberOfBitMaps(shape.getNumberOfBits())];
         this.cardinality = 0;
-        if (other.isSparse()) {
+        if ((other.characteristics()&SPARSE)>0) {","[{'comment': 'whitespace: `(other.characteristics() & SPARSE) != 0`', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
329,src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java,"@@ -194,7 +194,7 @@ public boolean merge(Hasher hasher) {
     @Override
     public boolean merge(BloomFilter other) {
         Objects.requireNonNull(other, ""other"");
-        if (other.isSparse()) {
+        if ((other.characteristics()&SPARSE)>0) {","[{'comment': 'whitespace: `(other.characteristics() & SPARSE) != 0`', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
329,src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java,"@@ -169,7 +169,7 @@ public boolean merge(Hasher hasher) {
     @Override
     public boolean merge(BloomFilter other) {
         Objects.requireNonNull(other, ""other"");
-        IndexProducer producer = other.isSparse() ? (IndexProducer) other : IndexProducer.fromBitMapProducer(other);
+        IndexProducer producer = (other.characteristics()&SPARSE)>0 ? (IndexProducer) other : IndexProducer.fromBitMapProducer(other);","[{'comment': 'whitespace: `(other.characteristics() & SPARSE) != 0`', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
329,src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java,"@@ -58,7 +58,7 @@ public SparseBloomFilter(BloomFilter other) {
         Objects.requireNonNull(other, ""other"");
         this.shape = other.getShape();
         this.indices = new TreeSet<>();
-        if (other.isSparse()) {
+        if ((other.characteristics()&SPARSE)>0) {","[{'comment': 'whitespace: `(other.characteristics() & SPARSE) != 0`', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
331,src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java,"@@ -77,6 +79,92 @@ public interface CountingBloomFilter extends BloomFilter, BitCountProducer {
 
     // Modification Operations
 
+    /**
+     * Merges the specified Bloom filter into this Bloom filter.
+     *
+     * <p>Specifically: all counts for the indexes identified by the {@code other} filter will be incremented by 1,</p>
+     *
+     * <p>Note: If the other filter is a counting Bloom filter the index counts are ignored and it is treated as an
+     * IndexProducer.</p>
+     *
+     * <p>This method will return {@code true} if the filter is valid after the operation.</p>
+     *
+     * @param other the other Bloom filter
+     * @return {@code true} if the removal was successful and the state is valid
+     * @see #isValid()
+     * @see #add(BitCountProducer)
+     */
+    default boolean merge(final BloomFilter other) {
+        Objects.requireNonNull(other, ""other"");
+        try {
+            return add(BitCountProducer.from(other));
+        } catch (IndexOutOfBoundsException e) {
+            throw new IllegalArgumentException(e);
+        }
+    }
+
+    /**
+     * Merges the specified Hasher into this Bloom filter.
+     *
+     * <p>Specifically: all counts for the unique indexes identified by the {@code hasher} will be incremented by 1,</p>
+     *
+     * <p>This method will return {@code true} if the filter is valid after the operation.</p>
+     *
+     * @param hasher the hasher
+     * @return {@code true} if the removal was successful and the state is valid
+     * @see #isValid()
+     * @see #add(BitCountProducer)
+     */
+    default boolean merge(final Hasher hasher) {
+        Objects.requireNonNull(hasher, ""hasher"");
+        try {
+            return add(BitCountProducer.from(hasher.uniqueIndices(getShape())));
+        } catch (IndexOutOfBoundsException e) {
+            throw new IllegalArgumentException(
+                    String.format(""Filter only accepts values in the [0,%d) range"", getShape().getNumberOfBits()));","[{'comment': 'The caught exception should be added as the cause', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
331,src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java,"@@ -77,6 +79,92 @@ public interface CountingBloomFilter extends BloomFilter, BitCountProducer {
 
     // Modification Operations
 
+    /**
+     * Merges the specified Bloom filter into this Bloom filter.
+     *
+     * <p>Specifically: all counts for the indexes identified by the {@code other} filter will be incremented by 1,</p>
+     *
+     * <p>Note: If the other filter is a counting Bloom filter the index counts are ignored and it is treated as an
+     * IndexProducer.</p>
+     *
+     * <p>This method will return {@code true} if the filter is valid after the operation.</p>
+     *
+     * @param other the other Bloom filter
+     * @return {@code true} if the removal was successful and the state is valid
+     * @see #isValid()
+     * @see #add(BitCountProducer)
+     */
+    default boolean merge(final BloomFilter other) {
+        Objects.requireNonNull(other, ""other"");
+        try {
+            return add(BitCountProducer.from(other));
+        } catch (IndexOutOfBoundsException e) {
+            throw new IllegalArgumentException(e);
+        }
+    }
+
+    /**
+     * Merges the specified Hasher into this Bloom filter.
+     *
+     * <p>Specifically: all counts for the unique indexes identified by the {@code hasher} will be incremented by 1,</p>
+     *
+     * <p>This method will return {@code true} if the filter is valid after the operation.</p>
+     *
+     * @param hasher the hasher
+     * @return {@code true} if the removal was successful and the state is valid
+     * @see #isValid()
+     * @see #add(BitCountProducer)
+     */
+    default boolean merge(final Hasher hasher) {
+        Objects.requireNonNull(hasher, ""hasher"");
+        try {
+            return add(BitCountProducer.from(hasher.uniqueIndices(getShape())));
+        } catch (IndexOutOfBoundsException e) {
+            throw new IllegalArgumentException(
+                    String.format(""Filter only accepts values in the [0,%d) range"", getShape().getNumberOfBits()));
+        }
+    }
+
+    /**
+     * Merges the specified index producer into this Bloom filter.
+     *
+     * <p>Specifically: all counts for the indexes identified by the {@code indexProducer} will be incremented by 1,</p>
+     *
+     * <p>This method will return {@code true} if the filter is valid after the operation.</p>
+     *
+     * <p>Note: This method expects and index producer that does not return duplicates.</p>
+     *
+     * @param indexProducer the IndexProducer
+     * @return {@code true} if the removal was successful and the state is valid
+     * @see #isValid()
+     * @see #add(BitCountProducer)
+     */
+    default boolean merge(final IndexProducer indexProducer) {
+        Objects.requireNonNull(indexProducer, ""producer"");
+        try {
+            return add(BitCountProducer.from(indexProducer));
+        } catch (IndexOutOfBoundsException e) {
+            throw new IllegalArgumentException(
+                    String.format(""Filter only accepts values in the [0,%d) range"", getShape().getNumberOfBits()));","[{'comment': 'The caught exception should be added as the cause.\r\n\r\nNote: the other default methods that catch and wrap the IOOBE do not add a message but do add the cause. There should be consistency here. Perhaps change all to use the same message and add the IOOBE as the cause.', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
331,src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java,"@@ -92,12 +180,15 @@ public interface CountingBloomFilter extends BloomFilter, BitCountProducer {
      * @see #isValid()
      * @see #subtract(BitCountProducer)
      */
-    boolean remove(BloomFilter other);
+    default boolean remove(final BloomFilter other) {
+        Objects.requireNonNull(other, ""other"");
+        return subtract(BitCountProducer.from(other));","[{'comment': 'Note: This calls subtract with a BitCountProducer. But does not catch and wrap IOOBE. Should it be:\r\n```Java\r\nreturn remove((IndexProducer) other);\r\n```', 'commenter': 'aherbert'}]"
331,src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java,"@@ -77,6 +79,92 @@ public interface CountingBloomFilter extends BloomFilter, BitCountProducer {
 
     // Modification Operations
 
+    /**
+     * Merges the specified Bloom filter into this Bloom filter.
+     *
+     * <p>Specifically: all counts for the indexes identified by the {@code other} filter will be incremented by 1,</p>
+     *
+     * <p>Note: If the other filter is a counting Bloom filter the index counts are ignored and it is treated as an
+     * IndexProducer.</p>
+     *
+     * <p>This method will return {@code true} if the filter is valid after the operation.</p>
+     *
+     * @param other the other Bloom filter
+     * @return {@code true} if the removal was successful and the state is valid
+     * @see #isValid()
+     * @see #add(BitCountProducer)
+     */
+    default boolean merge(final BloomFilter other) {
+        Objects.requireNonNull(other, ""other"");","[{'comment': 'Could this be changed to:\r\n```Java\r\nreturn merge((IndexProducer) other);\r\n```', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
331,src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java,"@@ -77,6 +79,92 @@ public interface CountingBloomFilter extends BloomFilter, BitCountProducer {
 
     // Modification Operations
 
+    /**
+     * Merges the specified Bloom filter into this Bloom filter.
+     *
+     * <p>Specifically: all counts for the indexes identified by the {@code other} filter will be incremented by 1,</p>
+     *
+     * <p>Note: If the other filter is a counting Bloom filter the index counts are ignored and it is treated as an
+     * IndexProducer.</p>
+     *
+     * <p>This method will return {@code true} if the filter is valid after the operation.</p>
+     *
+     * @param other the other Bloom filter
+     * @return {@code true} if the removal was successful and the state is valid
+     * @see #isValid()
+     * @see #add(BitCountProducer)
+     */
+    default boolean merge(final BloomFilter other) {
+        Objects.requireNonNull(other, ""other"");
+        try {
+            return add(BitCountProducer.from(other));
+        } catch (IndexOutOfBoundsException e) {
+            throw new IllegalArgumentException(e);
+        }
+    }
+
+    /**
+     * Merges the specified Hasher into this Bloom filter.
+     *
+     * <p>Specifically: all counts for the unique indexes identified by the {@code hasher} will be incremented by 1,</p>
+     *
+     * <p>This method will return {@code true} if the filter is valid after the operation.</p>
+     *
+     * @param hasher the hasher
+     * @return {@code true} if the removal was successful and the state is valid
+     * @see #isValid()
+     * @see #add(BitCountProducer)
+     */
+    default boolean merge(final Hasher hasher) {
+        Objects.requireNonNull(hasher, ""hasher"");
+        try {
+            return add(BitCountProducer.from(hasher.uniqueIndices(getShape())));
+        } catch (IndexOutOfBoundsException e) {
+            throw new IllegalArgumentException(
+                    String.format(""Filter only accepts values in the [0,%d) range"", getShape().getNumberOfBits()));
+        }
+    }
+
+    /**
+     * Merges the specified index producer into this Bloom filter.
+     *
+     * <p>Specifically: all counts for the indexes identified by the {@code indexProducer} will be incremented by 1,</p>
+     *
+     * <p>This method will return {@code true} if the filter is valid after the operation.</p>
+     *
+     * <p>Note: This method expects and index producer that does not return duplicates.</p>
+     *
+     * @param indexProducer the IndexProducer
+     * @return {@code true} if the removal was successful and the state is valid
+     * @see #isValid()
+     * @see #add(BitCountProducer)
+     */
+    default boolean merge(final IndexProducer indexProducer) {
+        Objects.requireNonNull(indexProducer, ""producer"");
+        try {
+            return add(BitCountProducer.from(indexProducer));
+        } catch (IndexOutOfBoundsException e) {
+            throw new IllegalArgumentException(
+                    String.format(""Filter only accepts values in the [0,%d) range"", getShape().getNumberOfBits()));
+        }
+    }
+
+    /**
+     * Merges the specified BitMap producer into this Bloom filter.
+     *
+     * <p>Specifically: all counts for the indexes identified by the {@code bitMapProducer} will be incremented by 1,</p>
+     *
+     * <p>This method will return {@code true} if the filter is valid after the operation.</p>
+     *
+     * @param bitMapProducer the BitMapProducer
+     * @return {@code true} if the removal was successful and the state is valid
+     * @see #isValid()
+     * @see #add(BitCountProducer)
+     */
+    default boolean merge(final BitMapProducer bitMapProducer) {
+        return merge(IndexProducer.fromBitMapProducer(bitMapProducer));","[{'comment': '`Objects.requireNonNull(indexProducer, ""bitMapProducer"");` ?\r\n\r\nJust to get the correct exception message rather than the message from the IndexProducer.', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
331,src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java,"@@ -110,7 +201,52 @@ public interface CountingBloomFilter extends BloomFilter, BitCountProducer {
      * @see #isValid()
      * @see #subtract(BitCountProducer)
      */
-    boolean remove(Hasher hasher);
+    default boolean remove(final Hasher hasher) {
+        Objects.requireNonNull(hasher, ""hasher"");
+        return subtract(BitCountProducer.from(hasher.uniqueIndices(getShape())));","[{'comment': 'No catch of IOOBE and wrapping to IAE', 'commenter': 'aherbert'}]"
331,src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java,"@@ -110,7 +201,52 @@ public interface CountingBloomFilter extends BloomFilter, BitCountProducer {
      * @see #isValid()
      * @see #subtract(BitCountProducer)
      */
-    boolean remove(Hasher hasher);
+    default boolean remove(final Hasher hasher) {
+        Objects.requireNonNull(hasher, ""hasher"");
+        return subtract(BitCountProducer.from(hasher.uniqueIndices(getShape())));
+    }
+
+    /**
+     * Removes the values from the specified IndexProducer from the Bloom filter from this Bloom filter.
+     *
+     * <p>Specifically all counts for the unique indices produced by the {@code hasher} will be
+     * decremented by 1.</p>
+     *
+     * <p>This method will return {@code true} if the filter is valid after the operation.</p>
+     *
+     * <p>Node: This method expects index producers that produce unique values.</p>
+     *
+     * @param indexProducer the IndexProducer to provide the indexes
+     * @return {@code true} if the removal was successful and the state is valid
+     * @see #isValid()
+     * @see #subtract(BitCountProducer)
+     */
+    default boolean remove(final IndexProducer indexProducer) {
+        Objects.requireNonNull(indexProducer, ""indexProducer"");
+        try {
+            return subtract(BitCountProducer.from(indexProducer));
+        } catch (IndexOutOfBoundsException e) {
+            throw new IllegalArgumentException(
+                    String.format(""Filter only accepts values in the [0,%d) range"", getShape().getNumberOfBits()));
+        }
+    }
+
+    /**
+     * Removes the specified BitMapProducer from this Bloom filter.
+     *
+     * <p>Specifically all counts for the indices produced by the {@code bitMapProducer} will be
+     * decremented by 1.</p>
+     *
+     * <p>This method will return {@code true} if the filter is valid after the operation.</p>
+     *
+     * @param bitMapProducer the BitMapProducer to provide the indexes
+     * @return {@code true} if the removal was successful and the state is valid
+     * @see #isValid()
+     * @see #subtract(BitCountProducer)
+     */
+    default boolean remove(final BitMapProducer bitMapProducer) {
+        return remove(IndexProducer.fromBitMapProducer(bitMapProducer));","[{'comment': 'This double wraps the input: `BitMapProducer -> IndexProducer -> BitCountProducer`. This could be a future optimisation to go direct: `BitMapProducer -> BitCountProducer`. The method could be done in an internal helper class.', 'commenter': 'aherbert'}]"
331,src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java,"@@ -133,12 +81,9 @@ public SimpleBloomFilter copy() {
         return new SimpleBloomFilter(this);
     }
 
-    /**
-     * Performs a merge using an IndexProducer.
-     * @param indexProducer the IndexProducer to merge from.
-     * @throws IllegalArgumentException if producer sends illegal value.
-     */
-    private void merge(IndexProducer indexProducer) {
+    @Override
+    public boolean merge(IndexProducer indexProducer) {
+        Objects.requireNonNull(indexProducer, ""indexProducer"");
         indexProducer.forEachIndex(idx -> {
             if (idx < 0 || idx >= shape.getNumberOfBits()) {
                 throw new IllegalArgumentException(String.format(","[{'comment': 'I note that here the index range uses a closed range [0, x-1]. Other exception message use an open range on the upper bound [0, x).', 'commenter': 'aherbert'}]"
331,src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java,"@@ -140,12 +78,9 @@ private boolean add(int idx) {
         return true;
     }
 
-    /**
-     * Performs a merge using an IndexProducer.
-     * @param indexProducer the IndexProducer to merge from.
-     * @throws IllegalArgumentException if producer sends illegal value.
-     */
-    private void merge(IndexProducer indexProducer) {
+    @Override
+    public boolean merge(IndexProducer indexProducer) {
+        Objects.requireNonNull(indexProducer, ""indexProducer"");","[{'comment': 'Note:\r\n\r\nThis merge method (and others such as remove/add/subtract) throw exceptions. However the filter will be left in a corrupted state if some of the indices have been processed before the exception. Implementing these methods as an atomic transaction would be slower and more involved. So I suggest that the non-atomic nature of the bulk updates to a filter are commented, perhaps at the package level, as a design decision to achieve maximum performance under correct usage.', 'commenter': 'aherbert'}]"
331,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java,"@@ -186,8 +179,10 @@ public final void testContains() {
     @Test
     public final void testEstimateIntersection() {
 
-        final BloomFilter bf = createFilter(getTestShape(), from1);
-        final BloomFilter bf2 = createFilter(getTestShape(), bigHasher);
+        final BloomFilter bf = createEmptyFilter(getTestShape());
+        bf.merge(from1);
+        final BloomFilter bf2 = createEmptyFilter(getTestShape());
+        bf2.merge(from1);","[{'comment': '`bf2` should merge `bigHasher`', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
331,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java,"@@ -62,49 +62,34 @@ protected final Shape getTestShape() {
      */
     protected abstract T createEmptyFilter(Shape shape);
 
-    /**
-     * Create the BloomFilter implementation we are testing.
-     *
-     * @param shape the shape of the filter.
-     * @param hasher the hasher to use to create the filter.
-     * @return a BloomFilter implementation.
-     */
-    protected abstract T createFilter(Shape shape, Hasher hasher);","[{'comment': 'Why not maintain these methods as non-abstract, e.g.\r\n```Java\r\nprotected T createFilter(Shape shape, Hasher hasher) {\r\n    T f = createEmptyFilter(Shape shape);\r\n    f.merge(hasher);\r\n    return f;\r\n}\r\n```\r\n\r\nThen you do not have to change all the existing tests to create and then merge the argument.\r\n', 'commenter': 'aherbert'}, {'comment': 'If this is a common pattern then why are we removing it from the interface?  I think the addition of the 2 merge functions is a good one, but I am still not convinced that the move from a simple constructor to 2 methods is a good one.  I think the convenience constructors should remain.', 'commenter': 'Claudenw'}, {'comment': 'This is a common pattern for _testing_.\r\n\r\nOut of curiosity I would ask you to search your use cases in your own production code to see how often you create a filter and then add only item immediately.\r\n\r\nI would think this is equivalent to having an ArrayList constructor that adds 1 item. This is not in the JDK. There are better alternatives for such a case such as a singleton list or using Arrays.asList.\r\n\r\nOn top of this the item you are adding will require some source of indices (e.g. a Hasher, another filter, etc). So there will already be some lines of code to create that from the actual Object, or collection of Objects, that are being used to initialise the filter. \r\n\r\nIf you find use cases for this then we can add a more suitable functionality in later releases, or perhaps this exact functionality. For now the purpose is to reduce the initial public API to a manageable release and then receive feedback from the community on what features to enhance.', 'commenter': 'aherbert'}, {'comment': 'changed', 'commenter': 'Claudenw'}]"
331,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java,"@@ -97,8 +97,8 @@ public void testUniqueIndex() {
         List<Integer> full = Arrays.stream(producer.asIndexArray()).boxed().collect(Collectors.toList());
         producer = hasher.uniqueIndices(shape);
         List<Integer> unique = Arrays.stream(producer.asIndexArray()).boxed().collect(Collectors.toList());
-        assertTrue( full.size() > unique.size() );
-        Set<Integer> set = new HashSet<Integer>( unique );
-        assertEquals( set.size(), unique.size() );
+        assertTrue(full.size() > unique.size());
+        Set<Integer> set = new HashSet<Integer>(unique);","[{'comment': 'Note: You can use the diamond operator `<>` in generics so you do not require the `<Integer>`', 'commenter': 'aherbert'}, {'comment': 'changed', 'commenter': 'Claudenw'}]"
331,src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java,"@@ -196,6 +196,7 @@ public AbstractDefaultBloomFilter copy() {
             result.indices.addAll(indices);
             return result;
         }
+","[{'comment': 'Remove the extra line', 'commenter': 'aherbert'}, {'comment': 'removed', 'commenter': 'Claudenw'}]"
331,src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java,"@@ -49,52 +49,63 @@ private static void assertSymmetricOperation(double expected, ToDoubleBiFunction
         assertEquals(expected, operation.applyAsDouble(filter2, filter1), ""op(filter2, filter1)"");
     }
 
+    private BloomFilter forTest(Shape shape, Hasher hasher) {","[{'comment': 'I would name these `createFilter` to be self documenting.', 'commenter': 'aherbert'}, {'comment': 'done', 'commenter': 'Claudenw'}]"
331,pom.xml,"@@ -588,9 +588,9 @@
     <commons.jira.pid>12310465</commons.jira.pid>
     <!-- The RC version used in the staging repository URL. -->
     <commons.rc.version>RC1</commons.rc.version>
-    <checkstyle.version>3.1.2</checkstyle.version>
+    <checkstyle.version>3.2.0</checkstyle.version>","[{'comment': 'The changes to pom.xml and changes.xml should not be here.', 'commenter': 'aherbert'}]"
331,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java,"@@ -93,16 +94,30 @@ protected final Shape getTestShape() {
      *
      */
     @Test
-    public void testConstructWithBadHasher() {
+    public void testMergeWithBadHasher() {
         // value too large
+        final BloomFilter f = createEmptyFilter(getTestShape());
         assertThrows(IllegalArgumentException.class,
-                () -> createFilter(getTestShape(), new BadHasher(getTestShape().getNumberOfBits())));
+                () -> f.merge(new BadHasher(getTestShape().getNumberOfBits())));
         // negative value
-        assertThrows(IllegalArgumentException.class, () -> createFilter(getTestShape(), new BadHasher(-1)));
+        BloomFilter f2 = createEmptyFilter(getTestShape());
+        assertThrows(IllegalArgumentException.class, () -> f2.merge(new BadHasher(-1)));
     }
 
     @Test
-    public void testConstructWitBitMapProducer() {
+    public void testMergeWithHasher() {
+        // value too large
+        final BloomFilter f = createEmptyFilter(getTestShape());
+        f.merge(from1);
+        int[] idx = f.asIndexArray();
+        assertEquals(getTestShape().getNumberOfHashFunctions(), idx.length);
+        for (int i=0; i<idx.length; i++) {","[{'comment': 'Whitespace:\r\n```Java\r\nfor (int i = 0; i < idx.length; i++) {\r\n    assertEquals(i + 1, idx[i]);\r\n```', 'commenter': 'aherbert'}]"
331,src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java,"@@ -33,66 +33,31 @@ protected SparseBloomFilter createEmptyFilter(final Shape shape) {
 
     @Override
     protected SparseBloomFilter createFilter(final Shape shape, final Hasher hasher) {
-        return new SparseBloomFilter(shape, hasher);","[{'comment': 'Since these methods just do the same as `createEmptyFilter(Shape)` then `merge(source)` I do not understand why they have to be overridden. The implementation can be in the Abstract test:\r\n```Java\r\nprotected BloomFilter createFilter(final Shape shape, final Hasher hasher) {\r\n    BloomFilter bf = createEmptyFilter(shape);\r\n    bf.merge(hasher);\r\n    return bf;\r\n}\r\n```\r\nIs it because the return argument type is incorrect? Then this can be fixed with:\r\n```Java\r\nprotected SparseBloomFilter createFilter(final Shape shape, final Hasher hasher) {\r\n    return (SparseBloomFilter) super.createFilter(shape, hasher);\r\n}\r\n```\r\nDoing it this way ensures all filters are using the same create and merge method to populate the new filter.\r\n', 'commenter': 'aherbert'}]"
331,src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java,"@@ -33,66 +33,31 @@ protected SparseBloomFilter createEmptyFilter(final Shape shape) {
 
     @Override
     protected SparseBloomFilter createFilter(final Shape shape, final Hasher hasher) {
-        return new SparseBloomFilter(shape, hasher);
+        SparseBloomFilter bf = new SparseBloomFilter(shape);
+        bf.merge(hasher);
+        return bf;
     }
 
     @Override
     protected SparseBloomFilter createFilter(final Shape shape, final BitMapProducer producer) {
-        return new SparseBloomFilter(shape, producer);
+        SparseBloomFilter bf = new SparseBloomFilter(shape);
+        bf.merge(producer);
+        return bf;
     }
 
     @Override
     protected SparseBloomFilter createFilter(final Shape shape, final IndexProducer producer) {
-        return new SparseBloomFilter(shape, producer);
+        SparseBloomFilter bf = new SparseBloomFilter(shape);
+        bf.merge(producer);
+        return bf;
     }
 
-    private void executeNestedTest(SparseBloomFilterTest nestedTest) {
-        nestedTest.testContains();
-        nestedTest.testEstimateIntersection();
-        nestedTest.testEstimateN();
-        nestedTest.testEstimateUnion();
-        nestedTest.testIsFull();
-        nestedTest.testMerge();
-    }
-
-    @Test
-    public void testConstructors() {
-
-        // copy of Sparse
-        SparseBloomFilterTest nestedTest = new SparseBloomFilterTest() {
-
-            @Override
-            protected SparseBloomFilter createEmptyFilter(Shape shape) {
-                return new SparseBloomFilter(new SparseBloomFilter(shape));
-            }
-
-            @Override
-            protected SparseBloomFilter createFilter(Shape shape, Hasher hasher) {
-                return new SparseBloomFilter(new SparseBloomFilter(shape, hasher));
-            }
-        };
-        executeNestedTest(nestedTest);
-
-        // copy of Simple
-        nestedTest = new SparseBloomFilterTest() {
-
-            @Override
-            protected SparseBloomFilter createEmptyFilter(Shape shape) {
-                return new SparseBloomFilter(new SimpleBloomFilter(shape));
-            }
-
-            @Override
-            protected SparseBloomFilter createFilter(Shape shape, Hasher hasher) {
-                return new SparseBloomFilter(new SimpleBloomFilter(shape, hasher));
-            }
-        };
-        executeNestedTest(nestedTest);
-    }
 
     @Test
     public void testBitMapProducerEdgeCases() {
         int[] values = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 65, 66, 67, 68, 69, 70, 71 };
-        BloomFilter bf = createFilter(getTestShape(), IndexProducer.fromIndexArray(values));","[{'comment': ""Why not use `createFilter` here. You have already reinstated the method. You should roll back the changes throughout the test suite where you previously dropped the method.\r\n\r\nYour current diff seems to have too many changes. I think you should:\r\n\r\n- branch from master\r\n- copy all the modified classes in `main/java/...` over the existing classes\r\n- modify only the 'createFilter' methods in the test classes and any other location that previously used the removed constructors.\r\n- set your upstream to this PR branch in your github and force push the changes. That should clear all your current git history and just introduce the desired changes.\r\n\r\n"", 'commenter': 'aherbert'}]"
331,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -60,6 +60,11 @@ public interface BloomFilter extends IndexProducer, BitMapProducer {
      */
     Shape getShape();
 
+    /**","[{'comment': 'Why is the clear method being added here? Your PR branch should be rebased on the current master as this change should not be in this PR.', 'commenter': 'aherbert'}]"
335,src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java,"@@ -19,7 +19,22 @@
 import java.util.function.IntPredicate;
 
 /**
- * Produces bit counts for counting type Bloom filters.
+ * Defines a mapping of index to counts.
+ *
+ * A BitCountProducer may return duplicate indices and may be unordered.
+ *
+ * The guarantees are:","[{'comment': '<p>', 'commenter': 'aherbert'}]"
335,src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java,"@@ -19,7 +19,22 @@
 import java.util.function.IntPredicate;
 
 /**
- * Produces bit counts for counting type Bloom filters.
+ * Defines a mapping of index to counts.
+ *
+ * A BitCountProducer may return duplicate indices and may be unordered.
+ *
+ * The guarantees are:
+ * <ul>
+ * <li>that for every unique value produced by the IndexProducer there will be at least one
+ * index in the BitCountProducer.</li>
+ * <li>that the total count of a specific value produced by the IndexProducer will equal the
+ * total of the counts in the BitCountProducer for that index.</li>
+ * </ul>
+ * Example:","[{'comment': '<p>', 'commenter': 'aherbert'}]"
335,src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java,"@@ -19,7 +19,22 @@
 import java.util.function.IntPredicate;
 
 /**
- * Produces bit counts for counting type Bloom filters.
+ * Defines a mapping of index to counts.
+ *
+ * A BitCountProducer may return duplicate indices and may be unordered.
+ *
+ * The guarantees are:
+ * <ul>
+ * <li>that for every unique value produced by the IndexProducer there will be at least one
+ * index in the BitCountProducer.</li>
+ * <li>that the total count of a specific value produced by the IndexProducer will equal the
+ * total of the counts in the BitCountProducer for that index.</li>
+ * </ul>
+ * Example:
+ *
+ * An IndexProducer that generates the values [1,2,3,1,5,6] can be represented by a BitCountProducer","[{'comment': '<p>', 'commenter': 'aherbert'}]"
335,src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java,"@@ -47,7 +60,7 @@ default boolean forEachIndex(IntPredicate predicate) {
 
     /**
      * Creates a BitCountProducer from an IndexProducer.  The resulting
-     * producer will count each enabled bit once.
+     * producer will return every index from the IndexProducer with a count of 1.","[{'comment': 'I would add: Duplicate indices are not expected to be aggregated. Duplicates will be output by the producer and each will be associated with a count of 1.', 'commenter': 'aherbert'}, {'comment': 'added with reference to class javaodc', 'commenter': 'Claudenw'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitCountProducerTest.java,"@@ -60,23 +48,37 @@ public boolean test(int index, int count) {
     @Override
     protected abstract BitCountProducer createEmptyProducer();
 
-    /**
-     * Determines if empty tests should be run.  Some producers do not implement an empty
-     * version.  Tests for those classes should return false.
-     * @return true if the empty tests are supported
-     */
-    protected boolean supportsEmpty() {
-        return true;
-    }
 
     @Test
-    public final void testForEachCount() {
-
+    public final void testForEachCountResults() {
         assertFalse(createProducer().forEachCount(FALSE_CONSUMER), ""non-empty should be false"");
         assertTrue(createProducer().forEachCount(TRUE_CONSUMER), ""non-empty should be true"");
-        if (supportsEmpty()) {
-            assertTrue(createEmptyProducer().forEachCount(FALSE_CONSUMER), ""empty should be true"");
-            assertTrue(createEmptyProducer().forEachCount(TRUE_CONSUMER), ""empty should be true"");
-        }
+        assertTrue(createEmptyProducer().forEachCount(FALSE_CONSUMER), ""empty should be true"");
+        assertTrue(createEmptyProducer().forEachCount(TRUE_CONSUMER), ""empty should be true"");
+    }
+
+    protected abstract int[][] getExpectedBitCount();","[{'comment': 'This should be commented as the expected count for the method `forEachCount`. It should also be moved above the test methods to put all abstract methods in the same location.\r\n\r\nNote that this test for BitCountProducer extends the test for IndexProducer. There is some mismatch here between the tests. The AbstractIndexProducerTest verifies that forEachIndex and asIndexArray are consistent (they output the same indices, but the order and uniqueness does not matter). Each is then tested for its behaviour for ordering and uniqueness; these may be different for the two methods. However I note that there is no test for what the expected indices should actually be, i.e. there is not a `protected abstract int[] getExpectedIndices()` and you have added this method. However note that this method for the expected indices should be used to check the distinct indices and without ordering requirements since the behaviour is separately tested.\r\n\r\nThe AbstractBitCountProducerTest extends the AbstractIndexProducerTest. So we know that the IndexProducer behaviour is tested. But here we now test the expected order and distinctness of the bit counts in one method. I note that there is only one method for the BitCountProducer and so consistency between different output of the counts in not an issue. However a test should be added for consistency between the bit counts and the indices.\r\n\r\nFor parity with AbstractIndexProducerTest I created this implementation:\r\n```Java\r\npublic abstract class AbstractBitCountProducerTest extends AbstractIndexProducerTest {\r\n    /** Flag to indicate the {@link BitCountProducer#forEachCount(BitCountConsumer)} is ordered. */\r\n    protected static final int FOR_EACH_COUNT_ORDERED = 0x10;\r\n    /** Flag to indicate the {@link BitCountProducer#forEachCount(BitCountConsumer)} is distinct. */\r\n    protected static final int FOR_EACH_COUNT_DISTINCT = 0x20;\r\n\r\n    /**\r\n     * A testing BitCountConsumer that always returns true.\r\n     */\r\n    private static final BitCountConsumer TRUE_CONSUMER = (i, j) -> true;\r\n    /**\r\n     * A testing BitCountConsumer that always returns false.\r\n     */\r\n    private static final BitCountConsumer FALSE_CONSUMER = (i, j) -> false;\r\n\r\n    /**\r\n     * Creates a producer with some data.\r\n     * @return a producer with some data\r\n     */\r\n    @Override\r\n    protected abstract BitCountProducer createProducer();\r\n\r\n    /**\r\n     * Creates an producer without data.\r\n     * @return a producer that has no data.\r\n     */\r\n    @Override\r\n    protected abstract BitCountProducer createEmptyProducer();\r\n\r\n    // Document me ...\r\n    protected abstract int[][] getExpectedBitCount();\r\n\r\n    @Test\r\n    public final void testForEachCountPredicates() {\r\n        BitCountProducer populated = createProducer();\r\n        BitCountProducer empty = createEmptyProducer();\r\n\r\n        assertFalse(populated.forEachCount(FALSE_CONSUMER), ""non-empty should be false"");\r\n        assertTrue(empty.forEachCount(FALSE_CONSUMER), ""empty should be true"");\r\n\r\n        assertTrue(populated.forEachCount(TRUE_CONSUMER), ""non-empty should be true"");\r\n        assertTrue(empty.forEachCount(TRUE_CONSUMER), ""empty should be true"");\r\n    }\r\n\r\n    @Test\r\n    public final void testEmptyBitCountProducer() {\r\n        BitCountProducer empty = createEmptyProducer();\r\n        int ary[] = empty.asIndexArray();\r\n        Assertions.assertEquals(0, ary.length);\r\n        assertTrue(empty.forEachCount((i, j) -> {\r\n            throw new AssertionError(""forEachCount consumer should not be called"");\r\n        }));\r\n    }\r\n\r\n    @Test\r\n    public final void testIndexConsistency() {\r\n        BitCountProducer producer = createProducer();\r\n        BitSet bs1 = new BitSet();\r\n        BitSet bs2 = new BitSet();\r\n        producer.forEachIndex(i -> {\r\n            bs1.set(i);\r\n            return true;\r\n        });\r\n        producer.forEachCount((i, j) -> {\r\n            bs2.set(i);\r\n            return true;\r\n        });\r\n        Assertions.assertEquals(bs1, bs2);\r\n    }\r\n\r\n    @Test\r\n    public void testForEachCount() {\r\n        // Assumes the collections bag works. Could be replaced with Map<Integer,Integer> with more work.\r\n        final TreeBag<Integer> expected = new TreeBag<>();\r\n        Arrays.stream(getExpectedBitCount()).forEach(c -> expected.add(c[0], c[1]));\r\n        final TreeBag<Integer> actual = new TreeBag<>();\r\n        createProducer().forEachCount((i, j) -> actual.add(i, j));\r\n        assertEquals(expected, actual);\r\n    }\r\n\r\n    @Test\r\n    public final void testBehaviourForEachCount() {\r\n        int flags = getBehaviour();\r\n        IntList list = new IntList();\r\n        createProducer().forEachCount((i, j) -> list.add(i));\r\n        int[] actual = list.toArray();\r\n        if ((flags & FOR_EACH_COUNT_ORDERED) != 0) {\r\n            int[] expected = Arrays.stream(actual).sorted().toArray();\r\n            Assertions.assertArrayEquals(expected, actual);\r\n        }\r\n        if ((flags & FOR_EACH_COUNT_DISTINCT) != 0) {\r\n            long count = Arrays.stream(actual).distinct().count();\r\n            Assertions.assertEquals(count, actual.length);\r\n        }\r\n        int[] expected = getExpectedForEach();\r\n        Assertions.assertArrayEquals( expected, actual);\r\n    }\r\n\r\n    @Test\r\n    public void testForEachCountEarlyExit() {\r\n        int[] passes = new int[1];\r\n        assertTrue(createEmptyProducer().forEachCount((i, j) -> {\r\n            passes[0]++;\r\n            return false;\r\n        }));\r\n        Assertions.assertEquals(0, passes[0]);\r\n\r\n        assertFalse(createProducer().forEachCount((i, j) -> {\r\n            passes[0]++;\r\n            return false;\r\n        }));\r\n        Assertions.assertEquals(1, passes[0]);\r\n    }\r\n}\r\n```\r\nThis test passes for all implementations. Note that I did not update all the tests to use the new flags marking the FOR_EACH_COUNT behaviour. They work with the current FOR_EACH behaviour flags, i.e. the behaviour of forEachCount is the same as forEachIndex for all implementations. So perhaps this can be dropped and we document the test to assume the forEach methods have the same behaviour.\r\n', 'commenter': 'aherbert'}, {'comment': 'moved and code added.', 'commenter': 'Claudenw'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java,"@@ -144,12 +148,13 @@ public final void testBehaviourAsIndexArray() {
             long count = Arrays.stream(actual).distinct().count();
             Assertions.assertEquals(count, actual.length);
         }
+        int[] expected = getExpectedIndex();","[{'comment': 'This should not be in the behaviour test.\r\n\r\nNote that I did observe failures in the DefaultIndexProducerTest on this method. When duplicates are randomly generated this method will fail.', 'commenter': 'aherbert'}, {'comment': 'removed', 'commenter': 'Claudenw'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java,"@@ -161,6 +166,8 @@ public final void testBehaviourForEach() {
             long count = Arrays.stream(actual).distinct().count();
             Assertions.assertEquals(count, actual.length);
         }
+        int[] expected = getExpectedForEach();","[{'comment': 'This should not be in the behaviour test', 'commenter': 'aherbert'}, {'comment': 'Moved to its own testForEachIndex', 'commenter': 'Claudenw'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java,"@@ -93,6 +92,12 @@ int[] toArray() {
      */
     protected abstract int getBehaviour();
 
+    protected abstract int[] getExpectedIndex();
+
+    protected int[] getExpectedForEach() {
+        return getExpectedIndex();
+    }
+
     @Test
     public final void testForEachIndex() {","[{'comment': 'testForEachIndexPredicates', 'commenter': 'aherbert'}, {'comment': 'renamed', 'commenter': 'Claudenw'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java,"@@ -93,6 +92,12 @@ int[] toArray() {
      */
     protected abstract int getBehaviour();
 
+    protected abstract int[] getExpectedIndex();
+
+    protected int[] getExpectedForEach() {","[{'comment': 'This method is not required. The indices are checked in different tests: the indices are correct; the indices may be sorted; the indices may be distinct.', 'commenter': 'aherbert'}, {'comment': 'removed', 'commenter': 'Claudenw'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java,"@@ -93,6 +92,12 @@ int[] toArray() {
      */
     protected abstract int getBehaviour();
 
+    protected abstract int[] getExpectedIndex();","[{'comment': 'I think this should be used in a new test that only checks the same indices are returned. Other tests are used to determine ordering and uniqueness.\r\n```Java\r\n    @Test\r\n    public final void testForEachIndex() {\r\n        IndexProducer producer = createProducer();\r\n        BitSet bs1 = new BitSet();\r\n        BitSet bs2 = new BitSet();\r\n        Arrays.stream(getExpectedIndex()).forEach(bs1::set);\r\n        createProducer().forEachIndex(i -> {\r\n            bs2.set(i);\r\n            return true;\r\n        });\r\n        Assertions.assertEquals(bs1, bs2);\r\n    }\r\n```\r\n', 'commenter': 'aherbert'}, {'comment': 'added', 'commenter': 'Claudenw'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java,"@@ -29,6 +29,26 @@ public class DefaultIndexProducerTest extends AbstractIndexProducerTest {
 
     private int[] values = generateIntArray(10, 512);
 
+    @Override
+    protected int[] getExpectedIndex() {
+        int last = -1;
+        IntList lst = new IntList();
+        for (int idx : values) {
+            if (idx != last) {","[{'comment': 'This is not eliminating duplicates (which I presume is the intention) since `values` is not sorted. This manifested as a flaky test when the expected indices array did not match the actual.', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromDefaultIndexProducerTest.java,"@@ -41,24 +37,19 @@ protected int getBehaviour() {
         return AS_ARRAY_DISTINCT | AS_ARRAY_ORDERED;
     }
 
-    @Test
-    @Disabled(""Current behaviour will return the same index twice, each with a count of 1"")
-    public final void testFromIndexProducer() {
-
-        BitCountProducer producer = createProducer();
-        Map<Integer, Integer> m = new HashMap<>();
+    @Override
+    protected int[][] getExpectedBitCount() {
+        return new int[][]{{0, 1}, {63, 1}, {1, 1}, {1, 1}, {64, 1}, {127, 1}, {128, 1}};
+    }
 
-        producer.forEachCount((i, v) -> {
-            m.put(i, v);
-            return true;
-        });
+    @Override
+    protected int[] getExpectedIndex() {
+        return expected;","[{'comment': 'If the Abstract test is modified as suggested to separately test behaviour and the expected indices then this can `return data`.', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromIntArrayTest.java,"@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+public class BitCountProducerFromIntArrayTest extends AbstractBitCountProducerTest {
+
+    int[] data = {6, 8, 1, 2, 4, 4, 5};
+    int[] expected = {1, 2, 4, 5, 6, 8};","[{'comment': 'Updating the abstract test removes the requirement for `expected`', 'commenter': 'aherbert'}, {'comment': 'Removed', 'commenter': 'Claudenw'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherTest.java,"@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+public class BitCountProducerFromHasherTest extends AbstractBitCountProducerTest {
+
+    @Override
+    protected BitCountProducer createProducer() {
+        return BitCountProducer.from(new IncrementingHasher(0, 1).indices(Shape.fromKM(17, 72)));","[{'comment': 'I would update the test to use something other than IncrementingHasher(0, 1), perhaps IncrementingHasher(3, 1), or IncrementingHasher(3, 2). This would check a non-sequential set of indices.', 'commenter': 'aherbert'}, {'comment': 'done', 'commenter': 'Claudenw'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSparseBloomFilterTest.java,"@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+public class BitCountProducerFromSparseBloomFilterTest extends AbstractBitCountProducerTest {
+
+    protected Shape shape = Shape.fromKM(17, 72);
+
+    @Override
+    protected BitCountProducer createProducer() {
+        Hasher hasher = new IncrementingHasher(0, 1);
+        BloomFilter bf = new SparseBloomFilter(shape);
+        bf.merge(hasher);
+        return BitCountProducer.from(bf);
+","[{'comment': 'Remove empty line', 'commenter': 'aherbert'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java,"@@ -93,8 +98,36 @@ int[] toArray() {
      */
     protected abstract int getBehaviour();
 
+    /**
+     * Creates an array of expected indices.
+     * @return an array of expected indices.
+     */
+    protected abstract int[] getExpectedIndices();
+
+    @Test
+    public final void testAsIndexArrayValues() {
+        List<Integer> lst = new ArrayList<>();
+        Arrays.stream(createProducer().asIndexArray()).boxed().forEach( lst::add );
+        for (int i : getExpectedIndices()) {
+            assertTrue( lst.contains(i), ""Missing ""+i );
+        }
+    }
+
     @Test
     public final void testForEachIndex() {
+        //IndexProducer producer = createProducer();","[{'comment': 'Remove commented out producer', 'commenter': 'aherbert'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java,"@@ -134,7 +167,6 @@ public final void testConsistency() {
     @Test
     public final void testBehaviourAsIndexArray() {
         int flags = getBehaviour();
-        Assumptions.assumeTrue((flags & (AS_ARRAY_ORDERED | AS_ARRAY_DISTINCT)) != 0);","[{'comment': 'These Assumptions will skip the test if there is no known behaviour. Otherwise the test asserts nothing so there is no point running it.', 'commenter': 'aherbert'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitCountProducerTest.java,"@@ -16,35 +16,29 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import org.apache.commons.collections4.bloomfilter.BitCountProducer.BitCountConsumer;
 import org.junit.jupiter.api.Test;
 
 public abstract class AbstractBitCountProducerTest extends AbstractIndexProducerTest {","[{'comment': ""I am not seeing the version of AbstractBitCountProducerTest that I provided. However you have noted in the comment that you 'moved and added code'. So I am not sure what you updated. I think all you need to do is paste in the test methods from the version I provided. In your current version the test asserts that the order from getExpectedBitCount is matched, including any duplicate indices. In my test class we separate the aggregation of the bit counts (testForEachCount) and the test for uniqueness and ordering (testBehaviourForEachCount) to respect the behaviour flag. There is also an early exit test. This thus makes the BitCount producer test more closely match the IndexProducer test."", 'commenter': 'aherbert'}]"
335,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java,"@@ -43,7 +48,7 @@ public abstract class AbstractIndexProducerTest {
     /**
      * An expandable list of int values.
      */
-    private static class IntList {
+    protected static class IntList {","[{'comment': 'This can be private. It is not used in any other class.', 'commenter': 'aherbert'}]"
336,src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java,"@@ -136,6 +143,18 @@
 
     // These fields are used by reset() and verify(), and any test
     // method that tests a modification.
+    /**
+     * Flag to indicate the collection makes no ordering guarantees for the iterator. If this is not used
+     * then the behaviour is assumed to be ordered and the output order of the iterator is matched by
+     * the toArray method.
+     */
+    protected static final int UNORDERED = 0x1;
+
+    /**
+     * Flag to indicate the collection makes ordering guarantees for the iterator. This is used by the default
+     * implementation of {@link #getIterationBehaviour()}
+     */
+    protected static final int ORDERED = 0x0;","[{'comment': 'I do not think we need this. If something is not UNORDERED then it can be assumed it is ordered.', 'commenter': 'aherbert'}]"
336,src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java,"@@ -487,6 +506,16 @@ public Object[] getOtherNonNullStringElements() {
         };
     }
 
+    /**
+     * Return a flag specifying the iteration behaviour of the collection.
+     * This is used to change the assertions used by specific tests.
+     * Default implementation returns {@link #ORDERED} as iteration behaviour
+     * @return the iteration behaviour
+     */
+    protected int getIterationBehaviour(){
+        return ORDERED;","[{'comment': 'Just return 0 for the default behaviour', 'commenter': 'aherbert'}]"
336,src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java,"@@ -1095,9 +1124,15 @@ public void testCollectionToArray2() {
 
         array = getCollection().toArray(new Object[0]);
         a = getCollection().toArray();
-        assertEquals(""toArrays should be equal"",
-                     Arrays.asList(array), Arrays.asList(a));
 
+        if((getIterationBehaviour() & UNORDERED) != 0) {","[{'comment': 'Note there is a second assertion on line 1154 using assertEquals with two lists. This should also be changed to use a hashset if unordered.', 'commenter': 'aherbert'}]"
336,src/test/java/org/apache/commons/collections4/bag/SynchronizedBagTest.java,"@@ -46,6 +46,10 @@ public String getCompatibilityVersion() {
         return ""4"";
     }
 
+    @Override
+    protected int getIterationBehaviour(){
+        return UNORDERED;
+    }","[{'comment': 'Add an empty line after this method.', 'commenter': 'aherbert'}]"
336,src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java,"@@ -70,6 +70,13 @@
  * <li>{@link #isFailFastSupported()}
  * </ul>
  * <p>
+ * <b>Indicate Collection Iteration behaviour</b>
+ * </p>
+ * Override these if your collection makes no ordering guarantees for the iterator","[{'comment': 'Requires a `<p>` tag before `Override`. Looking at the rest of the javadoc the paragraphs are not closed. So the `</p>` on line 74 should change to a `<p>`.', 'commenter': 'aherbert'}]"
341,src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java,"@@ -1801,6 +1832,12 @@ public void verify() {
             super.verify();
             AbstractMapTest.this.verify();
         }
+
+        @Override
+        protected int getIterationBehaviour(){
+            return AbstractMapTest.this.getIterationBehaviour();
+        }
+","[{'comment': 'Remove empty line', 'commenter': 'aherbert'}]"
341,src/test/java/org/apache/commons/collections4/bag/HashBagTest.java,"@@ -45,6 +45,11 @@ public String getCompatibilityVersion() {
         return ""4"";
     }
 
+    @Override
+    protected int getIterationBehaviour() {
+        return UNORDERED;
+    }
+
 //    public void testCreate() throws Exception {","[{'comment': 'Add an empty line here', 'commenter': 'aherbert'}]"
341,src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java,"@@ -954,6 +973,12 @@ public Collection<Entry<K, V>> makeConfirmedFullCollection() {
             return null;
         }
 
+
+        @Override
+        protected int getIterationBehaviour() {
+            return AbstractMultiValuedMapTest.this.getIterationBehaviour();
+        }
+","[{'comment': 'Remove empty line', 'commenter': 'aherbert'}]"
341,src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java,"@@ -1009,6 +1034,11 @@ public boolean isTestSerialization() {
             return false;
         }
 
+        @Override
+        protected int getIterationBehaviour() {
+            return AbstractMultiValuedMapTest.this.getIterationBehaviour();
+        }
+","[{'comment': 'Remove empty line', 'commenter': 'aherbert'}]"
341,src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java,"@@ -1090,6 +1120,11 @@ public Collection<V> makeConfirmedFullCollection() {
             return null;
         }
 
+        @Override
+        protected int getIterationBehaviour() {
+            return AbstractMultiValuedMapTest.this.getIterationBehaviour();
+        }
+","[{'comment': 'Remove empty line', 'commenter': 'aherbert'}]"
341,src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java,"@@ -1160,6 +1195,11 @@ public void resetEmpty() {
             TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());
         }
 
+        @Override
+        protected int getIterationBehaviour() {
+            return AbstractMultiValuedMapTest.this.getIterationBehaviour();
+        }
+","[{'comment': 'Remove empty line', 'commenter': 'aherbert'}]"
341,src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java,"@@ -1257,6 +1297,12 @@ public boolean areEqualElementsDistinguishable() {
         public boolean isTestSerialization() {
             return false;
         }
+
+        @Override
+        protected int getIterationBehaviour() {
+            return AbstractMultiValuedMapTest.this.getIterationBehaviour();
+        }
+","[{'comment': 'Remove empty line', 'commenter': 'aherbert'}]"
341,src/test/java/org/apache/commons/collections4/multiset/AbstractMultiSetTest.java,"@@ -687,6 +687,12 @@ public void resetFull() {
         public void verify() {
             super.verify();
         }
+
+        @Override
+        protected int getIterationBehaviour() {
+            return AbstractMultiSetTest.this.getIterationBehaviour();
+        }
+","[{'comment': 'Remove empty line', 'commenter': 'aherbert'}]"
341,src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java,"@@ -211,6 +218,18 @@ public void resetFull() {
         }
     }
 
+    /**
+     * Return a flag specifying the iteration behaviour of the map.
+     * This is used to change the assertions used by specific tests.
+     * The default implementation returns 0 which indicates ordered iteration behaviour.
+     *
+     * @return the iteration behaviour
+     * @see #UNORDERED
+     */
+    protected int getIterationBehaviour(){","[{'comment': 'Add a space: `() {`\r\n\r\nThis method only applies to the iteration of the values of the multi map when it is tested as a collection. I think the method name can be the same as that used in AbstractCollectionTest. But the property should be reused. So UNORDERED must be made public in AbstractCollectionTest.', 'commenter': 'aherbert'}]"
341,src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java,"@@ -60,6 +60,13 @@
     /** MultiValuedHashMap created by reset(). */
     protected MultiValuedMap<K, V> confirmed;
 
+    /**
+     * Flag to indicate the map makes no ordering guarantees for the iterator. If this is not used
+     * then the behaviour is assumed to be ordered and the output order of the iterator is matched by
+     * the toArray method.
+     */
+    protected static final int UNORDERED = 0x1;","[{'comment': 'Remove this. The property to use when configuring the behaviour of the AbstractCollectionTest should be the flag defined in AbstractCollectionTest.', 'commenter': 'aherbert'}]"
341,src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java,"@@ -211,6 +218,18 @@ public void resetFull() {
         }
     }
 
+    /**
+     * Return a flag specifying the iteration behaviour of the map.
+     * This is used to change the assertions used by specific tests.
+     * The default implementation returns 0 which indicates ordered iteration behaviour.
+     *
+     * @return the iteration behaviour
+     * @see #UNORDERED","[{'comment': 'This javadoc will change to `@see AbstractCollectionTest#UNORDERED`', 'commenter': 'aherbert'}]"
341,src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java,"@@ -524,6 +538,18 @@ public void testSampleMappings() {
         }
     }
 
+    /**
+     * Return a flag specifying the iteration behaviour of the collection.
+     * This is used to change the assertions used by specific tests.
+     * The default implementation returns 0 which indicates ordered iteration behaviour.
+     *
+     * @return the iteration behaviour
+     * @see #UNORDERED","[{'comment': 'Change to `@see AbstractCollectionTest#UNORDERED`', 'commenter': 'aherbert'}]"
341,src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java,"@@ -134,6 +141,13 @@
         JDK12 = str.startsWith(""1.2"");
     }
 
+    /**
+     * Flag to indicate the collection makes no ordering guarantees for the iterator. If this is not used
+     * then the behaviour is assumed to be ordered and the output order of the iterator is matched by
+     * the toArray method.
+     */
+    protected static final int UNORDERED = 0x1;","[{'comment': 'Remove this. The property from AbstractCollectionTest should be used as it is configuring the test within that class.', 'commenter': 'aherbert'}]"
353,src/main/java/org/apache/commons/collections4/bidimap/DualHashBidiMap.java,"@@ -22,6 +22,7 @@
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.LinkedMap;","[{'comment': '`s/LinkedMap/LinkedHashMap`\r\n\r\nMake sure you read `CONTRIBUTING.md` too as it contains useful information for contributing code.\r\n\r\n', 'commenter': 'kinow'}, {'comment': 'Yes, thanks', 'commenter': 'anantdahiya8'}]"
353,src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java,"@@ -265,16 +266,18 @@ private void removeValue(final BidiMap<?, ?> map, final Object value) {
 
     @Test
     public void testBidiKeySetValuesOrder() {
-        resetFull();
-        final Iterator<K> keys = map.keySet().iterator();
-        final Iterator<V> values = map.values().iterator();
-        while (keys.hasNext() && values.hasNext()) {
-            final K key = keys.next();
-            final V value = values.next();
-            assertSame(map.get(key), value);
-        }
-        assertFalse(keys.hasNext());
-        assertFalse(values.hasNext());
+        if((getIterationBehaviour() & AbstractCollectionTest.UNORDERED) == 0){","[{'comment': 'Using an if statement does not allow reporting that the test has been skipped. Can you revert and use the previous suggestion to skip based on an assumption (Junit5):\r\n```Java\r\npublic void testBidiKeySetValuesOrder() {\r\n    // Skip if collection is unordered\r\n    Assumptions.assumeFalse((getIterationBehaviour() & AbstractCollectionTest.UNORDERED) != 0);\r\n```\r\n', 'commenter': 'aherbert'}, {'comment': '@aherbert Got it. Updated', 'commenter': 'anantdahiya8'}]"
357,src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java,"@@ -66,6 +66,16 @@ public HasherCollection(Hasher... hashers) {
         this(Arrays.asList(hashers));
     }
 
+    @Override
+    public boolean isEmpty() {
+        for (Hasher h : hashers) {
+            if (!h.isEmpty()) {
+                return false;
+            }
+        }
+        return true;","[{'comment': 'Bit rusty in Java & streams, but I **think** this is equivalent to:\r\n\r\n```java\r\nreturn hashers.stream().noneMatch(Hasher::isEmpty);\r\n```', 'commenter': 'kinow'}, {'comment': ""Out of the loop, so can't comment on the addition of that method, but the rest of the code looks Ok :+1: "", 'commenter': 'kinow'}, {'comment': 'I am fine with a non-stream method to avoid the stream object creation overhead.', 'commenter': 'aherbert'}, {'comment': 'Leaving as non-stream method to avoid the stream object creation overhead.', 'commenter': 'Claudenw'}]"
357,src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java,"@@ -52,6 +53,11 @@ protected int getHasherSize(Hasher hasher) {
         return 1;
     }
 
+    @Override
+    public void testIsEmpty() {
+        assertFalse( createHasher().isEmpty() );","[{'comment': 'No extra spaces around parens.', 'commenter': 'garydgregory'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
357,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java,"@@ -85,4 +86,7 @@ public void testHashing(int k, int m) {
         });
         assertEquals(1, count[0], ""did not exit early"");
     }
+
+    @Test
+    public abstract void testIsEmpty();","[{'comment': 'Why is this abstract?\r\n```Java\r\npublic void testIsEmpty() {\r\n    Assertions.assertTrue(createEmptyHasher().isEmpty());\r\n    Assertions.assertFalse(createHasher().isEmpty());\r\n}\r\n```\r\nThe specific use case in HasherCollection with a non-empty collection of empty hashers can be left to override this test.', 'commenter': 'aherbert'}, {'comment': 'changed', 'commenter': 'Claudenw'}]"
357,src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java,"@@ -61,4 +61,10 @@ default IndexProducer uniqueIndices(Shape shape) {
             return Hasher.this.indices(shape).forEachIndex(IndexFilter.create(shape, consumer));
         };
     }
+
+    /**
+     * Returns {@code true} if the hasher is empty and will return no values.
+     * @return {@code true} if the hasher is empty and will return no values.
+     */
+    boolean isEmpty();","[{'comment': 'I think this should have a default implementation of `return false;`.\r\n\r\nThere are very few places where it has to be overridden. When this has a default implementation the interface can remain a functional interface.', 'commenter': 'aherbert'}, {'comment': 'changed', 'commenter': 'Claudenw'}]"
357,src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java,"@@ -61,4 +61,15 @@ default IndexProducer uniqueIndices(Shape shape) {
             return Hasher.this.indices(shape).forEachIndex(IndexFilter.create(shape, consumer));
         };
     }
+
+    /**
+     * Returns {@code true} if the hasher is empty and will return no values.
+     *
+     * By default this method returns {@code false}.","[{'comment': 'Needs a `<p>` tag. Change to `<p>The default implementation returns ... </p>`', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -214,26 +215,48 @@ default boolean isFull() {
      * <p>By default this is the rounding of the {@code Shape.estimateN(cardinality)} calculation for the
      * shape and cardinality of this filter.</p>
      *
-     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter.</p>
+     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter
+     * by rounding the value from the calculation described in the {@code Shape} class javadoc.</p>
      *
-     * @return an estimate of the number of items in the bloom filter.
+     * <p><em>Note:</em></p>
+     * <ul>
+     * <li> if cardinality == numberOfBits, then result is Integer.MAX_VALUE.</li>
+     * <li> if cardinality &gt; numberOfBits, then an IllegalArgumentException is thrown.</li>
+     * </ul>
+     *
+     * @return an estimate of the number of items in the bloom filter.  Will return Integer.MAX_VALUE if the
+     * estimate is larger than Integer.MAX_VALUE.
+     * @throws IllegalArgumentException if the cardinality is &gt; numberOfBits as defined in Shape.
      * @see Shape#estimateN(int)
+     * @see Shape
      */
     default int estimateN() {
-        return (int) Math.round(getShape().estimateN(cardinality()));
+        double d = getShape().estimateN(cardinality());
+        if (Double.isInfinite(d)) {
+            return Integer.MAX_VALUE;
+        }
+        if (Double.isNaN(d)) {","[{'comment': 'Can this happen without an error in the cardinality computation?', 'commenter': 'aherbert'}, {'comment': 'Is this possible without a broken filter `cardinality` or `Shape.estimateN`?', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -245,16 +268,43 @@ default int estimateUnion(final BloomFilter other) {
     /**
      * Estimates the number of items in the intersection of this Bloom filter with the other bloom filter.
      *
-     * <p>By default this is the {@code estimateN() + other.estimateN() - estimateUnion(other)} </p>
+     * <p>This method produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both
+     * of the filters by rounding the value from the calculation described in the {@code Shape} class javadoc.</p>
      *
-     * <p>This produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both
-     * of the filters.</p>
+     * <p><em>{@code estimateIntersection} should only be called with Bloom filters of the same Shape.  If called on Bloom
+     * filters of differing shape this method is not symmetric. If {@code other} has more bits an {@code IllegalArgumentException}
+     * may be thrown.</em></p>
      *
      * @param other The other Bloom filter
-     * @return an estimate of the number of items in the intersection.
+     * @return an estimate of the number of items in the intersection. If the calculated estimate is larger than Integer.MAX_VALUE then MAX_VALUE is returned.
+     * @throws IllegalArgumentException if the estimated N for the union of the filters is infinite.
+     * @see #estimateN()
+     * @see Shape
      */
     default int estimateIntersection(final BloomFilter other) {
         Objects.requireNonNull(other, ""other"");
-        return estimateN() + other.estimateN() - estimateUnion(other);
+        double eThis = getShape().estimateN(cardinality());
+        double eOther = getShape().estimateN(other.cardinality());
+        long estimate = 0L;
+        if (Double.isInfinite(eThis) && Double.isInfinite(eOther)) {
+            // if both are infinite the union is infinite and we return Integer.MAX_VALUE
+            return Integer.MAX_VALUE;
+        }
+        // if one is infinite the intersection is the other.
+        if (Double.isInfinite(eThis)) {
+            estimate = Math.round( eOther );","[{'comment': 'Remove surrounding whitespace `(eOther)`', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -245,16 +268,43 @@ default int estimateUnion(final BloomFilter other) {
     /**
      * Estimates the number of items in the intersection of this Bloom filter with the other bloom filter.
      *
-     * <p>By default this is the {@code estimateN() + other.estimateN() - estimateUnion(other)} </p>
+     * <p>This method produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both
+     * of the filters by rounding the value from the calculation described in the {@code Shape} class javadoc.</p>
      *
-     * <p>This produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both
-     * of the filters.</p>
+     * <p><em>{@code estimateIntersection} should only be called with Bloom filters of the same Shape.  If called on Bloom
+     * filters of differing shape this method is not symmetric. If {@code other} has more bits an {@code IllegalArgumentException}
+     * may be thrown.</em></p>
      *
      * @param other The other Bloom filter
-     * @return an estimate of the number of items in the intersection.
+     * @return an estimate of the number of items in the intersection. If the calculated estimate is larger than Integer.MAX_VALUE then MAX_VALUE is returned.
+     * @throws IllegalArgumentException if the estimated N for the union of the filters is infinite.
+     * @see #estimateN()
+     * @see Shape
      */
     default int estimateIntersection(final BloomFilter other) {
         Objects.requireNonNull(other, ""other"");
-        return estimateN() + other.estimateN() - estimateUnion(other);
+        double eThis = getShape().estimateN(cardinality());
+        double eOther = getShape().estimateN(other.cardinality());
+        long estimate = 0L;
+        if (Double.isInfinite(eThis) && Double.isInfinite(eOther)) {
+            // if both are infinite the union is infinite and we return Integer.MAX_VALUE
+            return Integer.MAX_VALUE;
+        }
+        // if one is infinite the intersection is the other.
+        if (Double.isInfinite(eThis)) {
+            estimate = Math.round( eOther );
+        } else if (Double.isInfinite(eOther)) {
+            estimate = Math.round( eThis );","[{'comment': 'Remove surrounding whitespace', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -245,16 +268,43 @@ default int estimateUnion(final BloomFilter other) {
     /**
      * Estimates the number of items in the intersection of this Bloom filter with the other bloom filter.
      *
-     * <p>By default this is the {@code estimateN() + other.estimateN() - estimateUnion(other)} </p>
+     * <p>This method produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both
+     * of the filters by rounding the value from the calculation described in the {@code Shape} class javadoc.</p>
      *
-     * <p>This produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both
-     * of the filters.</p>
+     * <p><em>{@code estimateIntersection} should only be called with Bloom filters of the same Shape.  If called on Bloom
+     * filters of differing shape this method is not symmetric. If {@code other} has more bits an {@code IllegalArgumentException}
+     * may be thrown.</em></p>
      *
      * @param other The other Bloom filter
-     * @return an estimate of the number of items in the intersection.
+     * @return an estimate of the number of items in the intersection. If the calculated estimate is larger than Integer.MAX_VALUE then MAX_VALUE is returned.
+     * @throws IllegalArgumentException if the estimated N for the union of the filters is infinite.
+     * @see #estimateN()
+     * @see Shape
      */
     default int estimateIntersection(final BloomFilter other) {
         Objects.requireNonNull(other, ""other"");
-        return estimateN() + other.estimateN() - estimateUnion(other);
+        double eThis = getShape().estimateN(cardinality());
+        double eOther = getShape().estimateN(other.cardinality());
+        long estimate = 0L;
+        if (Double.isInfinite(eThis) && Double.isInfinite(eOther)) {
+            // if both are infinite the union is infinite and we return Integer.MAX_VALUE
+            return Integer.MAX_VALUE;
+        }
+        // if one is infinite the intersection is the other.
+        if (Double.isInfinite(eThis)) {
+            estimate = Math.round( eOther );
+        } else if (Double.isInfinite(eOther)) {
+            estimate = Math.round( eThis );
+        } else {
+            BloomFilter union = this.copy();
+            union.merge(other);
+            double eUnion = getShape().estimateN(union.cardinality());
+            if (Double.isInfinite(eUnion)) {
+                throw new IllegalArgumentException( ""The estimated N for the union of the filters is infinite"");
+            }
+            // all estimated values are small values greater than 0 but less that number of bits
+            estimate = Math.round( eThis + eOther - eUnion );","[{'comment': 'Surrounding whitespace', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -245,16 +268,43 @@ default int estimateUnion(final BloomFilter other) {
     /**
      * Estimates the number of items in the intersection of this Bloom filter with the other bloom filter.
      *
-     * <p>By default this is the {@code estimateN() + other.estimateN() - estimateUnion(other)} </p>
+     * <p>This method produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both
+     * of the filters by rounding the value from the calculation described in the {@code Shape} class javadoc.</p>
      *
-     * <p>This produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both
-     * of the filters.</p>
+     * <p><em>{@code estimateIntersection} should only be called with Bloom filters of the same Shape.  If called on Bloom
+     * filters of differing shape this method is not symmetric. If {@code other} has more bits an {@code IllegalArgumentException}
+     * may be thrown.</em></p>
      *
      * @param other The other Bloom filter
-     * @return an estimate of the number of items in the intersection.
+     * @return an estimate of the number of items in the intersection. If the calculated estimate is larger than Integer.MAX_VALUE then MAX_VALUE is returned.
+     * @throws IllegalArgumentException if the estimated N for the union of the filters is infinite.
+     * @see #estimateN()
+     * @see Shape
      */
     default int estimateIntersection(final BloomFilter other) {
         Objects.requireNonNull(other, ""other"");
-        return estimateN() + other.estimateN() - estimateUnion(other);
+        double eThis = getShape().estimateN(cardinality());
+        double eOther = getShape().estimateN(other.cardinality());
+        long estimate = 0L;
+        if (Double.isInfinite(eThis) && Double.isInfinite(eOther)) {
+            // if both are infinite the union is infinite and we return Integer.MAX_VALUE
+            return Integer.MAX_VALUE;
+        }
+        // if one is infinite the intersection is the other.
+        if (Double.isInfinite(eThis)) {
+            estimate = Math.round( eOther );
+        } else if (Double.isInfinite(eOther)) {
+            estimate = Math.round( eThis );
+        } else {
+            BloomFilter union = this.copy();
+            union.merge(other);
+            double eUnion = getShape().estimateN(union.cardinality());
+            if (Double.isInfinite(eUnion)) {
+                throw new IllegalArgumentException( ""The estimated N for the union of the filters is infinite"");","[{'comment': 'Remove whitespace after `(`', 'commenter': 'aherbert'}]"
358,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java,"@@ -227,21 +227,35 @@ public void testClear() {
     }
 
     /**
-     * Tests that the andCardinality calculations are correct.
+     * Tests that the estimated intersection calculations are correct.
      */
     @Test
     public final void testEstimateIntersection() {
 
         final BloomFilter bf = createFilter(getTestShape(), from1);
         final BloomFilter bf2 = createFilter(getTestShape(), bigHasher);
+        final BloomFilter bf3 = createFilter(getTestShape(), fullHasher);
 
         assertEquals(1, bf.estimateIntersection(bf2));
         assertEquals(1, bf2.estimateIntersection(bf));
-
-        final BloomFilter bf3 = createEmptyFilter(getTestShape());
-
-        assertEquals(0, bf.estimateIntersection(bf3));
-        assertEquals(0, bf3.estimateIntersection(bf));
+        assertEquals(1, bf.estimateIntersection(bf3));
+        assertEquals(1, bf2.estimateIntersection(bf));
+        assertEquals(2, bf3.estimateIntersection(bf2));
+
+        final BloomFilter bf4 = createEmptyFilter(getTestShape());
+
+        assertEquals(0, bf.estimateIntersection(bf4));
+        assertEquals(0, bf4.estimateIntersection(bf));
+
+        // test split to union
+        HasherCollection firstHalf = new HasherCollection(new IncrementingHasher(0, 1)/* 0-16 */,
+                new IncrementingHasher(17, 1)/* 17-33 */, new IncrementingHasher(33, 1)/* 33-49 */);
+                // test split to union
+        HasherCollection secondHalf = new HasherCollection(new IncrementingHasher(50, 1)/* 50-66 */,
+                        new IncrementingHasher(67, 1)/* 67-83 */);
+        BloomFilter bf5 = createFilter( getTestShape(), firstHalf);","[{'comment': 'Whitespace after `(` (and also the same issue on the next line)', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java,"@@ -36,6 +36,49 @@
  * <dd>{@code k = round((m / n) * ln(2))}</dd>
  * </dl>
  *
+ * <h2>Estimations from cardinality based on shape</h2>
+ *
+ * <p>Several estimates can be calculated from the Shape and the cardinality of a Bloom filter.</p>
+ *
+ * <p>In the calculation below the following values are used:</p>
+ * <ul>
+ * <li>double c = the cardinality of the Bloom filter.</li>
+ * <li>double m = numberOfBits as specified in the shape.</li>
+ * <li>double k = numberOfHashFunctions as specified in the shape.</li>
+ * </ul>
+ *
+ * <h3>Estimate N - n()</h3>
+ *
+ * <p>The calculation for the estimate of N is: {@code -(m/k) * ln( 1 - (c/m))}.  This is the calculation","[{'comment': 'Remove whitespace: `ln( 1 -` to `ln(1 -`', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java,"@@ -36,6 +36,49 @@
  * <dd>{@code k = round((m / n) * ln(2))}</dd>
  * </dl>
  *
+ * <h2>Estimations from cardinality based on shape</h2>
+ *
+ * <p>Several estimates can be calculated from the Shape and the cardinality of a Bloom filter.</p>
+ *
+ * <p>In the calculation below the following values are used:</p>
+ * <ul>
+ * <li>double c = the cardinality of the Bloom filter.</li>
+ * <li>double m = numberOfBits as specified in the shape.</li>
+ * <li>double k = numberOfHashFunctions as specified in the shape.</li>
+ * </ul>
+ *
+ * <h3>Estimate N - n()</h3>
+ *
+ * <p>The calculation for the estimate of N is: {@code -(m/k) * ln( 1 - (c/m))}.  This is the calculation
+ * performed by the {@code Shape.estimateN(cardinality)} method below.  This estimates is roughly equivalent to the","[{'comment': '`This estimate` (no estimates)', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java,"@@ -36,6 +36,49 @@
  * <dd>{@code k = round((m / n) * ln(2))}</dd>
  * </dl>
  *
+ * <h2>Estimations from cardinality based on shape</h2>
+ *
+ * <p>Several estimates can be calculated from the Shape and the cardinality of a Bloom filter.</p>
+ *
+ * <p>In the calculation below the following values are used:</p>
+ * <ul>
+ * <li>double c = the cardinality of the Bloom filter.</li>
+ * <li>double m = numberOfBits as specified in the shape.</li>
+ * <li>double k = numberOfHashFunctions as specified in the shape.</li>
+ * </ul>
+ *
+ * <h3>Estimate N - n()</h3>
+ *
+ * <p>The calculation for the estimate of N is: {@code -(m/k) * ln( 1 - (c/m))}.  This is the calculation
+ * performed by the {@code Shape.estimateN(cardinality)} method below.  This estimates is roughly equivalent to the
+ * number of hashers that have been merged into a filter to create the cardinality specified.</p>
+ *
+ * <p><em>Note:</em></p>
+ * <ul>
+ * <li> if cardinality == numberOfBits, then result is infinity.</li>","[{'comment': '`<li>if` on this line and the next', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java,"@@ -36,6 +36,49 @@
  * <dd>{@code k = round((m / n) * ln(2))}</dd>
  * </dl>
  *
+ * <h2>Estimations from cardinality based on shape</h2>
+ *
+ * <p>Several estimates can be calculated from the Shape and the cardinality of a Bloom filter.</p>
+ *
+ * <p>In the calculation below the following values are used:</p>
+ * <ul>
+ * <li>double c = the cardinality of the Bloom filter.</li>
+ * <li>double m = numberOfBits as specified in the shape.</li>
+ * <li>double k = numberOfHashFunctions as specified in the shape.</li>
+ * </ul>
+ *
+ * <h3>Estimate N - n()</h3>
+ *
+ * <p>The calculation for the estimate of N is: {@code -(m/k) * ln( 1 - (c/m))}.  This is the calculation
+ * performed by the {@code Shape.estimateN(cardinality)} method below.  This estimates is roughly equivalent to the
+ * number of hashers that have been merged into a filter to create the cardinality specified.</p>
+ *
+ * <p><em>Note:</em></p>
+ * <ul>
+ * <li> if cardinality == numberOfBits, then result is infinity.</li>
+ * <li> if cardinality &gt; numberOfBits, then result is NaN.</li>
+ * </ul>
+ *
+ * <h3>Estimate N of Union - n(A &cup; B)</h3>
+ *
+ * <p>To estimate the number of items in the union of two Bloom filters with the same shape, merge them together and
+ * calculate the estimated N from the result.</p>
+ *
+ * <h3>Estimate N of the Intersection - n(A &cap; B)</h3>
+ *
+ * <p>To estimate the number of items in the intersection of two Bloom filters A and B with the same shape the calculation is:
+ * n(A) + n(b) - n( A &cup; B )","[{'comment': '`n(A &cup; B)`', 'commenter': 'aherbert'}]"
358,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java,"@@ -227,21 +227,35 @@ public void testClear() {
     }
 
     /**
-     * Tests that the andCardinality calculations are correct.
+     * Tests that the estimated intersection calculations are correct.
      */
     @Test
     public final void testEstimateIntersection() {
 
         final BloomFilter bf = createFilter(getTestShape(), from1);
         final BloomFilter bf2 = createFilter(getTestShape(), bigHasher);
+        final BloomFilter bf3 = createFilter(getTestShape(), fullHasher);
 
         assertEquals(1, bf.estimateIntersection(bf2));
         assertEquals(1, bf2.estimateIntersection(bf));
-
-        final BloomFilter bf3 = createEmptyFilter(getTestShape());
-
-        assertEquals(0, bf.estimateIntersection(bf3));
-        assertEquals(0, bf3.estimateIntersection(bf));
+        assertEquals(1, bf.estimateIntersection(bf3));
+        assertEquals(1, bf2.estimateIntersection(bf));
+        assertEquals(2, bf3.estimateIntersection(bf2));
+
+        final BloomFilter bf4 = createEmptyFilter(getTestShape());
+
+        assertEquals(0, bf.estimateIntersection(bf4));
+        assertEquals(0, bf4.estimateIntersection(bf));
+
+        // test split to union
+        HasherCollection firstHalf = new HasherCollection(new IncrementingHasher(0, 1)/* 0-16 */,
+                new IncrementingHasher(17, 1)/* 17-33 */, new IncrementingHasher(33, 1)/* 33-49 */);
+                // test split to union","[{'comment': 'Indentation of this comment is wrong', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -214,26 +215,48 @@ default boolean isFull() {
      * <p>By default this is the rounding of the {@code Shape.estimateN(cardinality)} calculation for the
      * shape and cardinality of this filter.</p>
      *
-     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter.</p>
+     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter
+     * by rounding the value from the calculation described in the {@code Shape} class javadoc.</p>
      *
-     * @return an estimate of the number of items in the bloom filter.
+     * <p><em>Note:</em></p>
+     * <ul>
+     * <li> if cardinality == numberOfBits, then result is Integer.MAX_VALUE.</li>","[{'comment': '`<li>if` on this line and the next', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -214,26 +215,48 @@ default boolean isFull() {
      * <p>By default this is the rounding of the {@code Shape.estimateN(cardinality)} calculation for the
      * shape and cardinality of this filter.</p>
      *
-     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter.</p>
+     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter
+     * by rounding the value from the calculation described in the {@code Shape} class javadoc.</p>
      *
-     * @return an estimate of the number of items in the bloom filter.
+     * <p><em>Note:</em></p>
+     * <ul>
+     * <li> if cardinality == numberOfBits, then result is Integer.MAX_VALUE.</li>
+     * <li> if cardinality &gt; numberOfBits, then an IllegalArgumentException is thrown.</li>
+     * </ul>
+     *
+     * @return an estimate of the number of items in the bloom filter.  Will return Integer.MAX_VALUE if the
+     * estimate is larger than Integer.MAX_VALUE.
+     * @throws IllegalArgumentException if the cardinality is &gt; numberOfBits as defined in Shape.
      * @see Shape#estimateN(int)
+     * @see Shape
      */
     default int estimateN() {
-        return (int) Math.round(getShape().estimateN(cardinality()));
+        double d = getShape().estimateN(cardinality());
+        if (Double.isInfinite(d)) {
+            return Integer.MAX_VALUE;
+        }
+        if (Double.isNaN(d)) {
+            throw new IllegalArgumentException(""Cardinality too large: ""+cardinality());","[{'comment': 'Add whitespace around the `+` char', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -214,26 +215,48 @@ default boolean isFull() {
      * <p>By default this is the rounding of the {@code Shape.estimateN(cardinality)} calculation for the
      * shape and cardinality of this filter.</p>
      *
-     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter.</p>
+     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter
+     * by rounding the value from the calculation described in the {@code Shape} class javadoc.</p>
      *
-     * @return an estimate of the number of items in the bloom filter.
+     * <p><em>Note:</em></p>
+     * <ul>
+     * <li> if cardinality == numberOfBits, then result is Integer.MAX_VALUE.</li>
+     * <li> if cardinality &gt; numberOfBits, then an IllegalArgumentException is thrown.</li>
+     * </ul>
+     *
+     * @return an estimate of the number of items in the bloom filter.  Will return Integer.MAX_VALUE if the
+     * estimate is larger than Integer.MAX_VALUE.
+     * @throws IllegalArgumentException if the cardinality is &gt; numberOfBits as defined in Shape.
      * @see Shape#estimateN(int)
+     * @see Shape
      */
     default int estimateN() {
-        return (int) Math.round(getShape().estimateN(cardinality()));
+        double d = getShape().estimateN(cardinality());
+        if (Double.isInfinite(d)) {
+            return Integer.MAX_VALUE;
+        }
+        if (Double.isNaN(d)) {
+            throw new IllegalArgumentException(""Cardinality too large: ""+cardinality());
+        }
+        long l = Math.round(d);
+        return l>Integer.MAX_VALUE?Integer.MAX_VALUE:(int) l;","[{'comment': 'Add whitespace: `l > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) l;`', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -214,26 +215,48 @@ default boolean isFull() {
      * <p>By default this is the rounding of the {@code Shape.estimateN(cardinality)} calculation for the
      * shape and cardinality of this filter.</p>
      *
-     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter.</p>
+     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter
+     * by rounding the value from the calculation described in the {@code Shape} class javadoc.</p>
      *
-     * @return an estimate of the number of items in the bloom filter.
+     * <p><em>Note:</em></p>
+     * <ul>
+     * <li> if cardinality == numberOfBits, then result is Integer.MAX_VALUE.</li>
+     * <li> if cardinality &gt; numberOfBits, then an IllegalArgumentException is thrown.</li>
+     * </ul>
+     *
+     * @return an estimate of the number of items in the bloom filter.  Will return Integer.MAX_VALUE if the
+     * estimate is larger than Integer.MAX_VALUE.
+     * @throws IllegalArgumentException if the cardinality is &gt; numberOfBits as defined in Shape.
      * @see Shape#estimateN(int)
+     * @see Shape
      */
     default int estimateN() {
-        return (int) Math.round(getShape().estimateN(cardinality()));
+        double d = getShape().estimateN(cardinality());
+        if (Double.isInfinite(d)) {
+            return Integer.MAX_VALUE;
+        }
+        if (Double.isNaN(d)) {
+            throw new IllegalArgumentException(""Cardinality too large: ""+cardinality());
+        }
+        long l = Math.round(d);
+        return l>Integer.MAX_VALUE?Integer.MAX_VALUE:(int) l;
     }
 
     /**
      * Estimates the number of items in the union of this Bloom filter with the other bloom filter.
      *
-     * <p>By default this is the {@code estimateN()} of the merging of this filter with the {@code other} filter.</p>
-     *
      * <p>This produces an estimate roughly equivalent to the number of unique Hashers that have been merged into either
-     * of the filters.</p>
+     * of the filters by rounding the value from the calculation described in the {@code Shape} class javadoc.</p>","[{'comment': '`{@link Shape`', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -214,26 +215,48 @@ default boolean isFull() {
      * <p>By default this is the rounding of the {@code Shape.estimateN(cardinality)} calculation for the
      * shape and cardinality of this filter.</p>
      *
-     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter.</p>
+     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter
+     * by rounding the value from the calculation described in the {@code Shape} class javadoc.</p>","[{'comment': '`{@link Shape`', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -245,16 +268,43 @@ default int estimateUnion(final BloomFilter other) {
     /**
      * Estimates the number of items in the intersection of this Bloom filter with the other bloom filter.
      *
-     * <p>By default this is the {@code estimateN() + other.estimateN() - estimateUnion(other)} </p>
+     * <p>This method produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both
+     * of the filters by rounding the value from the calculation described in the {@code Shape} class javadoc.</p>","[{'comment': '`{@link Shape`', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -245,16 +268,43 @@ default int estimateUnion(final BloomFilter other) {
     /**
      * Estimates the number of items in the intersection of this Bloom filter with the other bloom filter.
      *
-     * <p>By default this is the {@code estimateN() + other.estimateN() - estimateUnion(other)} </p>
+     * <p>This method produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both
+     * of the filters by rounding the value from the calculation described in the {@link Shape} class javadoc.</p>
      *
-     * <p>This produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both
-     * of the filters.</p>
+     * <p><em>{@code estimateIntersection} should only be called with Bloom filters of the same Shape.  If called on Bloom
+     * filters of differing shape this method is not symmetric. If {@code other} has more bits an {@code IllegalArgumentException}
+     * may be thrown.</em></p>
      *
      * @param other The other Bloom filter
-     * @return an estimate of the number of items in the intersection.
+     * @return an estimate of the number of items in the intersection. If the calculated estimate is larger than Integer.MAX_VALUE then MAX_VALUE is returned.
+     * @throws IllegalArgumentException if the estimated N for the union of the filters is infinite.
+     * @see #estimateN()
+     * @see Shape
      */
     default int estimateIntersection(final BloomFilter other) {
         Objects.requireNonNull(other, ""other"");
-        return estimateN() + other.estimateN() - estimateUnion(other);
+        double eThis = getShape().estimateN(cardinality());
+        double eOther = getShape().estimateN(other.cardinality());
+        long estimate = 0L;
+        if (Double.isInfinite(eThis) && Double.isInfinite(eOther)) {
+            // if both are infinite the union is infinite and we return Integer.MAX_VALUE
+            return Integer.MAX_VALUE;
+        }
+        // if one is infinite the intersection is the other.
+        if (Double.isInfinite(eThis)) {
+            estimate = Math.round(eOther);
+        } else if (Double.isInfinite(eOther)) {
+            estimate = Math.round(eThis);
+        } else {
+            BloomFilter union = this.copy();
+            union.merge(other);
+            double eUnion = getShape().estimateN(union.cardinality());
+            if (Double.isInfinite(eUnion)) {
+                throw new IllegalArgumentException(""The estimated N for the union of the filters is infinite"");
+            }
+            // all estimated values are small values greater than 0 but less that number of bits
+            estimate = Math.round(eThis + eOther - eUnion);
+        }
+        return estimate>Integer.MAX_VALUE?Integer.MAX_VALUE:(int) estimate;","[{'comment': 'Formatting: `estimate > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) estimate;`\r\n\r\nCould be changed to:\r\n```Java\r\nreturn (int) Math.min(Integer.MAX_VALUE, estimate);\r\n```\r\nHowever that does obfuscate the fact there is no coverage of this edge case.\r\n', 'commenter': 'aherbert'}, {'comment': 'Leaving as is to verify test coverage', 'commenter': 'Claudenw'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -245,16 +268,43 @@ default int estimateUnion(final BloomFilter other) {
     /**
      * Estimates the number of items in the intersection of this Bloom filter with the other bloom filter.
      *
-     * <p>By default this is the {@code estimateN() + other.estimateN() - estimateUnion(other)} </p>
+     * <p>This method produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both
+     * of the filters by rounding the value from the calculation described in the {@link Shape} class javadoc.</p>
      *
-     * <p>This produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both
-     * of the filters.</p>
+     * <p><em>{@code estimateIntersection} should only be called with Bloom filters of the same Shape.  If called on Bloom
+     * filters of differing shape this method is not symmetric. If {@code other} has more bits an {@code IllegalArgumentException}
+     * may be thrown.</em></p>
      *
      * @param other The other Bloom filter
-     * @return an estimate of the number of items in the intersection.
+     * @return an estimate of the number of items in the intersection. If the calculated estimate is larger than Integer.MAX_VALUE then MAX_VALUE is returned.
+     * @throws IllegalArgumentException if the estimated N for the union of the filters is infinite.
+     * @see #estimateN()
+     * @see Shape
      */
     default int estimateIntersection(final BloomFilter other) {
         Objects.requireNonNull(other, ""other"");
-        return estimateN() + other.estimateN() - estimateUnion(other);
+        double eThis = getShape().estimateN(cardinality());
+        double eOther = getShape().estimateN(other.cardinality());
+        long estimate = 0L;
+        if (Double.isInfinite(eThis) && Double.isInfinite(eOther)) {
+            // if both are infinite the union is infinite and we return Integer.MAX_VALUE
+            return Integer.MAX_VALUE;
+        }
+        // if one is infinite the intersection is the other.
+        if (Double.isInfinite(eThis)) {
+            estimate = Math.round(eOther);
+        } else if (Double.isInfinite(eOther)) {
+            estimate = Math.round(eThis);
+        } else {
+            BloomFilter union = this.copy();
+            union.merge(other);
+            double eUnion = getShape().estimateN(union.cardinality());
+            if (Double.isInfinite(eUnion)) {
+                throw new IllegalArgumentException(""The estimated N for the union of the filters is infinite"");
+            }
+            // all estimated values are small values greater than 0 but less that number of bits","[{'comment': '`less than`', 'commenter': 'aherbert'}, {'comment': 'Modified to specify exact upper limit', 'commenter': 'Claudenw'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -214,26 +215,48 @@ default boolean isFull() {
      * <p>By default this is the rounding of the {@code Shape.estimateN(cardinality)} calculation for the
      * shape and cardinality of this filter.</p>
      *
-     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter.</p>
+     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter
+     * by rounding the value from the calculation described in the {@link Shape} class javadoc.</p>
      *
-     * @return an estimate of the number of items in the bloom filter.
+     * <p><em>Note:</em></p>
+     * <ul>
+     * <li>if cardinality == numberOfBits, then result is Integer.MAX_VALUE.</li>
+     * <li>if cardinality &gt; numberOfBits, then an IllegalArgumentException is thrown.</li>
+     * </ul>
+     *
+     * @return an estimate of the number of items in the bloom filter.  Will return Integer.MAX_VALUE if the
+     * estimate is larger than Integer.MAX_VALUE.
+     * @throws IllegalArgumentException if the cardinality is &gt; numberOfBits as defined in Shape.
      * @see Shape#estimateN(int)
+     * @see Shape
      */
     default int estimateN() {
-        return (int) Math.round(getShape().estimateN(cardinality()));
+        double d = getShape().estimateN(cardinality());
+        if (Double.isInfinite(d)) {
+            return Integer.MAX_VALUE;
+        }
+        if (Double.isNaN(d)) {
+            throw new IllegalArgumentException(""Cardinality too large: "" + cardinality());
+        }
+        long l = Math.round(d);
+        return l > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) l;","[{'comment': 'Could be changed to:\r\n```Java\r\nreturn (int) Math.min(Integer.MAX_VALUE, l);\r\n```\r\nHowever that does obfuscate the fact there is no coverage of this edge case.', 'commenter': 'aherbert'}, {'comment': 'leaving as is to verify test coverage', 'commenter': 'Claudenw'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -302,7 +302,7 @@ default int estimateIntersection(final BloomFilter other) {
             if (Double.isInfinite(eUnion)) {
                 throw new IllegalArgumentException(""The estimated N for the union of the filters is infinite"");
             }
-            // all estimated values are small values greater than 0 but less that number of bits
+            // maximum estimate value using integer valuess is: 46144189292","[{'comment': 'I do not think this comment change helps. I think the original comment is valid, i.e. since all values are positive and in the range of an integer then this will not overflow a long. ', 'commenter': 'aherbert'}]"
358,src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java,"@@ -114,10 +114,6 @@ public boolean merge(final BitMapProducer bitMapProducer) {
             // idx[0] will be limit+1 so decrement it
             idx[0]--;
             final int idxLimit = BitMap.getLongIndex(shape.getNumberOfBits());
-            if (idxLimit < idx[0]) {","[{'comment': 'I assume you are removing this as it is unreachable code, i.e. any idxLimit < idx[0] would generate an index out of bounds exception in `bitMap[idx[0]++]`. ', 'commenter': 'aherbert'}]"
358,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapProducerTest.java,"@@ -103,6 +103,18 @@ public final void testForEachBitMapPair() {
         Arrays.fill(count, 0);
         createProducer().forEachBitMapPair(createEmptyProducer(), lbp);
         assertEquals(count[2], count[1]);
+
+        // test where both producer does not process all records and function
+        // returns false before the processing is completed.
+        int[] limit = new int[1];
+        final LongBiPredicate shortFunc =  (x, y) -> {
+            limit[0]++;
+            return limit[0]<2;","[{'comment': 'whitespace `limit[0] < 2`', 'commenter': 'aherbert'}]"
358,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapProducerTest.java,"@@ -103,6 +103,18 @@ public final void testForEachBitMapPair() {
         Arrays.fill(count, 0);
         createProducer().forEachBitMapPair(createEmptyProducer(), lbp);
         assertEquals(count[2], count[1]);
+
+        // test where both producer does not process all records and function
+        // returns false before the processing is completed.
+        int[] limit = new int[1];
+        final LongBiPredicate shortFunc =  (x, y) -> {
+            limit[0]++;
+            return limit[0]<2;
+        };
+        final BitMapProducer shortProducer = (l) -> {","[{'comment': 'No need for parentheses around `l`', 'commenter': 'aherbert'}]"
358,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapProducerTest.java,"@@ -103,6 +103,18 @@ public final void testForEachBitMapPair() {
         Arrays.fill(count, 0);
         createProducer().forEachBitMapPair(createEmptyProducer(), lbp);
         assertEquals(count[2], count[1]);
+
+        // test where both producer does not process all records and function","[{'comment': 'IIUC the producer `shortProducer` will process all records (since it always returns true). Do you mean:\r\n```\r\n// test where the created producer does not process all records because the predicate function\r\n// returns false before the processing is completed.\r\n```', 'commenter': 'aherbert'}]"
358,src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapProducerTest.java,"@@ -87,4 +87,23 @@ public void testFromBitMapArray() {
         final long[] ary = BitMapProducer.fromBitMapArray(expected).asBitMapArray();
         assertArrayEquals(expected, ary);
     }
+
+    @Test
+    public void testAsBitMapArrayLargeArray() {
+        final long[] expected = generateLongArray(32);
+        BitMapProducer producer = new BitMapProducer() {
+","[{'comment': 'Remove empty line', 'commenter': 'aherbert'}]"
361,src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+/**
+ * A collection of methods and statics that represent standard hashers in testing.
+ */
+public class TestingHashers {","[{'comment': 'No requirement for `public` in the class or any methods.', 'commenter': 'aherbert'}, {'comment': 'made package private', 'commenter': 'Claudenw'}]"
361,src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+/**
+ * A collection of methods and statics that represent standard hashers in testing.
+ */
+public class TestingHashers {
+    /**
+     * Hasher that increments from 1
+     */
+    public static final Hasher from1 = new IncrementingHasher(1, 1);
+
+    /**
+     * Hasher that increments from 11
+     */
+    public static final Hasher from11 = new IncrementingHasher(11, 1);
+
+    /**
+     * Do not instantiate","[{'comment': 'Full stop', 'commenter': 'aherbert'}]"
361,src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+/**
+ * A collection of methods and statics that represent standard hashers in testing.
+ */
+public class TestingHashers {
+    /**
+     * Hasher that increments from 1
+     */
+    public static final Hasher from1 = new IncrementingHasher(1, 1);
+
+    /**
+     * Hasher that increments from 11
+     */
+    public static final Hasher from11 = new IncrementingHasher(11, 1);
+
+    /**
+     * Do not instantiate
+     */
+    private TestingHashers() {}
+
+    /**
+     * Merge several Hashers together into a single Bloom filter.
+     * @param <T> The type of bloom filter.
+     * @param filter The Bloom filter to populate
+     * @param hashers The hashers to merge
+     * @return {@code filter} for chaining
+     */
+    public static <T extends BloomFilter> T mergeHashers(T filter, Hasher...hashers) {
+        for (Hasher h : hashers) {
+            filter.merge(h);
+        }
+        return filter;
+    }
+
+    /**
+     * Merge {@code from1} and {@code from11} into a single Bloom filter.
+     * @param <T> The type of bloom filter.
+     * @param filter The Bloom filter to populate
+     * @return {@code filter} for chaining
+     */
+    public static <T extends BloomFilter> T bigHasher(T filter) {","[{'comment': 'A self-documenting name would be useful here: `mergeHasherFrom1AndHasherFrom11`\r\n', 'commenter': 'aherbert'}]"
361,src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+/**
+ * A collection of methods and statics that represent standard hashers in testing.
+ */
+public class TestingHashers {
+    /**
+     * Hasher that increments from 1
+     */
+    public static final Hasher from1 = new IncrementingHasher(1, 1);
+
+    /**
+     * Hasher that increments from 11
+     */
+    public static final Hasher from11 = new IncrementingHasher(11, 1);
+
+    /**
+     * Do not instantiate
+     */
+    private TestingHashers() {}
+
+    /**
+     * Merge several Hashers together into a single Bloom filter.
+     * @param <T> The type of bloom filter.
+     * @param filter The Bloom filter to populate
+     * @param hashers The hashers to merge
+     * @return {@code filter} for chaining
+     */
+    public static <T extends BloomFilter> T mergeHashers(T filter, Hasher...hashers) {
+        for (Hasher h : hashers) {
+            filter.merge(h);
+        }
+        return filter;
+    }
+
+    /**
+     * Merge {@code from1} and {@code from11} into a single Bloom filter.
+     * @param <T> The type of bloom filter.
+     * @param filter The Bloom filter to populate
+     * @return {@code filter} for chaining
+     */
+    public static <T extends BloomFilter> T bigHasher(T filter) {
+        return mergeHashers(filter, from1, from11);
+    }
+
+    /**
+     * Create a hasher that fills the entire range.
+     * @param <T> the Bloom filter type.
+     * @param filter the Bloom filter to populate
+     * @return {@code filter} for chaining
+     */
+    public static <T extends BloomFilter> T fullHasher(T filter) {
+        for (int i=0; i<filter.getShape().getNumberOfBits(); i+=filter.getShape().getNumberOfHashFunctions()) {","[{'comment': 'Whitespace:\r\n```Java\r\nint n = filter.getShape().getNumberOfBits();\r\nint k = filter.getShape().getNumberOfHashFunctions();\r\nfor (int i = 0; i < n; i += k) {', 'commenter': 'aherbert'}, {'comment': 'fixed', 'commenter': 'Claudenw'}]"
361,src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+/**","[{'comment': 'Add an empty line', 'commenter': 'aherbert'}]"
361,src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+/**
+ * A collection of methods and statics that represent standard hashers in testing.
+ */
+public class TestingHashers {
+    /**
+     * Hasher that increments from 1
+     */
+    public static final Hasher from1 = new IncrementingHasher(1, 1);","[{'comment': 'Naming conventions: `FROM1`', 'commenter': 'aherbert'}]"
361,src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+/**
+ * A collection of methods and statics that represent standard hashers in testing.
+ */
+public class TestingHashers {
+    /**
+     * Hasher that increments from 1","[{'comment': 'Full stop.', 'commenter': 'aherbert'}]"
361,src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+/**
+ * A collection of methods and statics that represent standard hashers in testing.
+ */
+public class TestingHashers {
+    /**
+     * Hasher that increments from 1
+     */
+    public static final Hasher from1 = new IncrementingHasher(1, 1);
+
+    /**
+     * Hasher that increments from 11","[{'comment': 'Full stop', 'commenter': 'aherbert'}]"
361,src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+/**
+ * A collection of methods and statics that represent standard hashers in testing.
+ */
+public class TestingHashers {
+    /**
+     * Hasher that increments from 1
+     */
+    public static final Hasher from1 = new IncrementingHasher(1, 1);
+
+    /**
+     * Hasher that increments from 11
+     */
+    public static final Hasher from11 = new IncrementingHasher(11, 1);","[{'comment': 'Naming conventions: `FROM11`', 'commenter': 'aherbert'}]"
396,src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java,"@@ -99,7 +99,7 @@ void testModEdgeCases() {
         for (final long dividend : new long[] {-1, -2, -3, -6378683, -23567468136887892L, Long.MIN_VALUE, 345, 678686,
             67868768686878924L, Long.MAX_VALUE}) {
             for (final int divisor : new int[] {1, 2, 3, 5, 13, Integer.MAX_VALUE}) {
-                assertEquals((int) Long.remainderUnsigned(dividend, divisor), EnhancedDoubleHasher.mod(dividend, divisor),
+                assertEquals((int) Long.remainderUnsigned(dividend, divisor), BitMap.mod(dividend, divisor),","[{'comment': '@garydgregory I think your issue would be solved if @Claudenw moves this test to the BitMapTest. It is no longer applicable to the EnhancedDoubleHasher.', 'commenter': 'aherbert'}, {'comment': ""When doing this can you add an extra case for `dividend=0`. This is not currently covered.\r\n\r\nI don't think we need edge cases to show behaviour when the divisor is negative. This method is written for performance and omits checks for bad arguments. However the javadoc can be updated to make it a user beware method. It should add strong wording that the result is undefined if the divisor is negative, and there will be an java.lang.ArithmeticException if the divisor is zero."", 'commenter': 'aherbert'}]"
397,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -289,12 +289,12 @@ default int estimateIntersection(final BloomFilter other) {
             // if both are infinite the union is infinite and we return Integer.MAX_VALUE
             return Integer.MAX_VALUE;
         }
-        long estimate;","[{'comment': 'This change is unrelated to COLLECTIONS-841.\r\n\r\nI note that `Long.numberOfLeadingZeros(46144189292 * 2) == 27` so the change to a double with 53-bits is OK. Do you have a test that shows the estimate being negative? Is this due to almost saturation of the filter and estimateN being close to infinity (since infinity throws)?', 'commenter': 'aherbert'}, {'comment': '> \r\nI am working on a stable Bloom filter implementation -- I think I have it working but I have a lot more checking to do.  The implementation and definition is based on http://webdocs.cs.ualberta.ca/~drafiei/papers/DupDet06Sigmod.pdf\r\n\r\nThe stable Bloom filter is intended to be used in a streaming environment so it disables some random bits before each item is added.  The upshot is that when the system attempts to turn on all the bits in the filter it will most likely fail.  So some tests do not function as for the normal Bloom filter.\r\n\r\nIf you are interested in looking at the code it can be found in https://github.com/Claudenw/IdSupplier\r\n\r\nI have proposed that Kafka use a stable Bloom filter to resolve one of the issues they are working on.\r\n\r\n', 'commenter': 'Claudenw'}]"
397,src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java,"@@ -132,7 +132,7 @@ long getIncrement() {
     /**
      * Performs a modulus calculation on an unsigned long and an integer divisor.
      * @param dividend a unsigned long value to calculate the modulus of.
-     * @param divisor the divisor for the modulus calculation.
+     * @param divisor the divisor for the modulus calculation, must be positive.","[{'comment': 'Also not related to COLLECTIONS-841 but trivial. I have updated master in commit 1d07ca40667849742d8712bf55770c559cd6203d', 'commenter': 'aherbert'}]"
397,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java,"@@ -424,11 +424,11 @@ public void testBitMapProducerSize() {
     /**
      * Testing class returns the value as the only value.
      */
-    class BadHasher implements Hasher {
+    public static class BadHasher implements Hasher {","[{'comment': 'Why public? If this must be public I assume you are using it in a different package which currently does not exist. Thus the change seems unjustified at present.', 'commenter': 'aherbert'}]"
397,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java,"@@ -218,7 +218,7 @@ public void testClear() {
      * Tests that the estimated intersection calculations are correct.
      */
     @Test
-    public final void testEstimateIntersection() {
+    public void testEstimateIntersection() {","[{'comment': 'If these must be non-final due to a requirement to change the implementation then this means that a new implementation of the `BloomFilter` interface will not function the same as what we currently have. Without a new class as such a use case it seems wrong to make this change.\r\n', 'commenter': 'aherbert'}]"
397,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java,"@@ -247,10 +247,10 @@ public final void testEstimateIntersection() {
     }
 
     /**
-     * Tests that the andCardinality calculations are correct.
+     * Tests that the estimateUnion calculations are correct.","[{'comment': 'Good spot. I updated master in 1d07ca40667849742d8712bf55770c559cd6203d', 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java,"@@ -19,7 +19,7 @@
 import java.util.Objects;
 
 /**
- * The interface that describes a Bloom filter that associates a count with each
+ * The interface that describes a Bloom filter that associates a cell with each","[{'comment': 'Changing count to cell has led to some loss of information. The word count is obviously a tracking of occurrences. The word cell is not. IIUC a cell is a count for an index, thus it encapsulates both terms, i.e. you cannot have a cell without an index: cell = (index, count). If a cell did not have an associated index then it is simply a count.\r\n\r\nWhere does this leave the naming of `CountingBloomFilter` and `ArrayCountingBloomFilter`?\r\n', 'commenter': 'aherbert'}, {'comment': 'Definition of cell and usage of cell vs count was reviewed and corrections made', 'commenter': 'Claudenw'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java,"@@ -164,17 +221,17 @@ default boolean merge(final BitMapProducer bitMapProducer) {
     /**
      * Removes the specified Bloom filter from this Bloom filter.
      *
-     * <p>Specifically: all counts for the indexes identified by the {@code other} filter will be decremented by 1.</p>
+     * <p>Specifically: all cells for the indexes identified by the {@code other} filter will be decremented by 1.</p>
      *
-     * <p>Note: If the other filter is a counting Bloom filter the index counts are ignored and it is treated as an
+     * <p>Note: If the other filter is a counting Bloom filter the othre filter's cells are ignored and it is treated as an","[{'comment': '`othre`', 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java,"@@ -77,22 +77,79 @@ public interface CountingBloomFilter extends BloomFilter, BitCountProducer {
      */
     boolean isValid();
 
+    /**
+     * Returns maximum value for a cell in this Counting filter.
+     * @return the maximum value for a cell in this Counting filter.
+     */
+    int getMaxCell();
+
+    /**
+     * Determines the maximum number of times the Bloom filter could have been inserted
+     * into this counting filter.
+     * @param bloomFilter the Bloom filter the check for.
+     * @return the maximum number of times the Bloom filter could have been inserted.
+     */
+    default int getMaxInsert(BloomFilter bloomFilter) {
+        return getMaxInsert((BitMapProducer) bloomFilter);
+    }
+
+    /**
+     * Determines the maximum number of times the IndexProducer could have been inserted
+     * into this counting filter.
+     * @param idxProducer the producer to drive the count check.
+     * @return the maximum number of times the IndexProducer could have been inserted.
+     */
+    default int getMaxInsert(IndexProducer idxProducer) {
+        return getMaxInsert( BitMapProducer.fromIndexProducer(idxProducer, getShape().getNumberOfBits()));","[{'comment': 'whitespace `( BitMap`', 'commenter': 'aherbert'}]"
406,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java,"@@ -289,6 +291,50 @@ public void testExcludesDuplicates() {
         bf1.merge(hasher);
         bf1.remove(hasher);
         assertEquals(0, bf1.cardinality());
-        assertTrue(bf1.forEachCount((x, y) -> false), ""Hasher in removes results in value not equal to 0"");
+        assertTrue(bf1.forEachCell((x, y) -> false), ""Hasher in removes results in value not equal to 0"");
+    }
+
+    private void verifyMaxInsert( CountingBloomFilter bf, int from1, int from11) {
+        BloomFilter bfFrom0 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());
+        bfFrom0.merge(new IncrementingHasher(0, 1));
+        BloomFilter bfFrom1 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());
+        bfFrom1.merge(TestingHashers.FROM1);
+        BloomFilter bfFrom11 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());
+        bfFrom11.merge(TestingHashers.FROM11);
+
+        assertEquals( 0, bf.getMaxInsert(new IncrementingHasher(0, 1)));","[{'comment': 'No whitespace after `assertEquals(`', 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java,"@@ -121,7 +186,7 @@ default boolean merge(final Hasher hasher) {
     /**
      * Merges the specified index producer into this Bloom filter.
      *
-     * <p>Specifically: all counts for the indexes identified by the {@code indexProducer} will be incremented by 1.</p>
+     * <p>Specifically: all cells for the indexes identified by the {@code indexProducer} will be incremented by 1.</p>","[{'comment': 'I don\'t think your conversion to a CellProducer upholds this contract. The cells will not be incremented by 1; they will be incremented by the count of the indices because merge then calls add.\r\n\r\nIIUC a merge is from BloomFilter and should flatten all arguments to an effective bitmap, removing duplicates. The add operation should not remove duplicate indices because they are treated as cells with a count above 1.\r\n\r\nWe should have some tests to check these definitions are upheld.\r\n\r\n```Java\r\nArrayCountingBloomFilter f1 = new ArrayCountingBloomFilter(Shape.fromKM(1, 10));\r\nArrayCountingBloomFilter f2 = f1.copy();\r\nArrayCountingBloomFilter f3 = f1.copy();\r\nIndexProducer ip = p -> {\r\n    p.test(3);\r\n    p.test(3);\r\n    return true;\r\n};\r\n// The merge SHOULD increment cells by 1\r\nf1.merge(ip);\r\n// The add should increment cells by 2\r\nf2.add(CellProducer.from(ip));\r\n// This merge will increment by 1 as the round-trip makes the indices unique\r\nf3.merge(IndexProducer.fromIndexArray(ip.asIndexArray()));\r\n\r\nf1.forEachCell((k, v) -> {\r\n    System.out.printf(""%d = %d%n"", k, v);\r\n    return true;\r\n});\r\nf2.forEachCell((k, v) -> {\r\n    System.out.printf(""%d = %d%n"", k, v);\r\n    return true;\r\n});\r\nf3.forEachCell((k, v) -> {\r\n    System.out.printf(""%d = %d%n"", k, v);\r\n    return true;\r\n});\r\n```\r\nPrints:\r\n```\r\n3 = 2    // ERROR !\r\n3 = 2\r\n3 = 1\r\n```\r\n', 'commenter': 'aherbert'}, {'comment': 'Agree this is incorrect.   I am adding this as a test to the AbstractCountingFilterTest.\r\n\r\nI think that we should make the following changes.\r\n\r\nfor counting filters\r\n\r\n- merge always increments the cell value by at most 1.\r\n- remove always decrements the cell value by at most 1.\r\n- add and subtract as used to increment/decrement by more than 1.\r\n\r\nfor index producers\r\n\r\n- as array always returns the indices in the number and order they are produced.\r\n- move the ""unique"" method from hashers to index producers. Hashers create index producers.  Let the use of the producer determine if it needs to be unique.\r\n\r\n', 'commenter': 'Claudenw'}, {'comment': 'Agree with all points except:\r\n\r\n""as array always returns the indices in the number and order they are produced.""\r\n\r\nThis constraint may impact performance. Is it required?\r\n\r\nA hasher asIndexArray may not wish to do this as the indices are random. The EnhancedDoubleHasher current returns the indices unordered.\r\n', 'commenter': 'aherbert'}, {'comment': 'Is it ""required"" no, but when working in complex arrangements it mean that the simply converting to an array does not change the state of the data.  In most cases this is not an issue.   The only case where it is an issue is when a Hasher backed IndexProducer.asArray() is called.  In all other cases (I think) the array either already exists or exists in a different form (BitMaps, CellProducers).   BitMaps and CellProducers always return distinct values in order.\r\n\r\nMy plan was to lift the code from BitMapProducer that produces bitMaps and use it to produce an array of indices from a Hasher.\r\n\r\nPerhaps my original comment is not clear.  Basically, however the underlying storage produces the indices is the order and number that will be produced in the array.', 'commenter': 'Claudenw'}, {'comment': 'If you wish to return a distinct array then the default method in the interface using a bit set will be fine.\n\nIf you wish to return a count of duplicate indices then the current implementation will work if you just sort the array it currently creates. This may be faster than using a complicated intermediate data structure. The hasher is likely to have a small array and the speed of the sort will be fast.\n\nThis may be an opportunity to use some more characteristics flags where an index producer can declare if the indices are sorted and or duplicates. Then the interface can provide default methods to remove duplicates or sort them.\n', 'commenter': 'aherbert'}, {'comment': 'If we have IndexProducer.asArray output the indices in the order that they would be returned by IndexProducer.forEachIndex() then we are not changing the data based on the representation.\r\n\r\nThis also means that sorting can be done by generating an array, using Array.sort() and then using the result to create an IndexProducer.fromIndexArray() to create the sorted index.\r\n\r\nThe characteristics flag may be a good idea. We already have them in the test code.\r\n\r\nHow about we move this forward as is and merge it.  I think the change is large enough (I was trying to keep is small).\r\n\r\nI still need to get the LayeredBloom filter added and it will need to be updated once we have this in place. \r\nFinally, I have the StableBloom filter, which may clarify some of the questions we have a bout characteristics and whether we have chosen the proper restrictions on IndexProducer and CellProducers.', 'commenter': 'Claudenw'}, {'comment': 'The last bit of my previous message was not meant to indicate that this should not be merged, just that there are 2 more changes coming as different pull requests.', 'commenter': 'Claudenw'}, {'comment': 'I misread your previous statement ""as array always returns the indices in the number and order they are produced."" I took that to mean in order, i.e. sorted. Re-reading it I see that you are stating that the order matches the output produced by forEachIndex.\r\n\r\nThis is fine. But it now means the default implementation of asIndexArray (which creates sorted, unique indices) is now in conflict with the javadoc.', 'commenter': 'aherbert'}, {'comment': 'PS. I just saw that you changed the default implementation of asIndexArray to respect the order of forEachIndex. I noted a problem with the internal comment in that method about the capacity.', 'commenter': 'aherbert'}, {'comment': 'Should all be fixed and ready to go now.', 'commenter': 'Claudenw'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java,"@@ -117,11 +118,64 @@ public boolean test(long word) {
      * @return An int array of the data.
      */
     default int[] asIndexArray() {
-        final BitSet result = new BitSet();
+        class Indices {
+            private int[] data = new int[32];
+            private int size;
+
+            boolean add(final int index) {
+                if (size == data.length) {
+                    // This will throw an out-of-memory error if there are too many bits.
+                    // Since bits are addressed using 32-bit signed integer indices
+                    // the maximum length should be ~2^31 / 2^6 = ~2^25.","[{'comment': 'This is wrong. You are not using the int[] as a bitmap. You are using it to store indices. So you can get out of memory. However at some point you will not be able to return the array if it needs more than the max capacity of an array. A larger limit is:\r\n```java\r\ndata = Arrays.copyOf(data, (int) Math.min(MAX_ARRAY_SIZE, size * 2L);\r\n```\r\nwith MAX_ARRAY_SIZE something big. Previous versions of the JDK java.util.ArrayList use Integer.MAX_VALUE - 8.\r\n', 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java,"@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.TreeMap;
+import java.util.function.IntPredicate;
+
+
+/**
+ * Some Bloom filter implementations use a count rather than a bit flag. The term {@code Cell} is used to
+ * refer to these counts and their associated index.  This class is the equivalent of the index producer except
+ * that it produces cells.
+ *
+ * <p>Note that a CellProducer must not return duplicate indices and must be ordered.</p>
+ *
+ * <p>Implementations must guarantee that:</p>
+ *
+ * <ul>
+ * <li>The IndexProducer implementation returns unique ordered indices.</li>
+ * <li>The cells are produced in IndexProducer order.</li>
+ * <li>For every value produced by the IndexProducer there will be only one matching
+ * cell produced by the CellProducer.</li>
+ * <li>The CellProducer will not generate cells with indices that are not output by the IndexProducer.</li>
+ * <li>The IndexProducer will not generate indices that have a zero count for the cell.</li>
+ * </ul>
+ *
+ * @since 4.5
+ */
+@FunctionalInterface
+public interface CellProducer extends IndexProducer {
+
+    /**
+     * Performs the given action for each {@code cell}  where the cell count is non-zero.
+     *
+     * <p>Some Bloom filter implementations use a count rather than a bit flag.  The term {@code Cell} is used to
+     * refer to these counts.</p>
+     *
+     * <p>Any exceptions thrown by the action are relayed to the caller. The consumer is applied to each
+     * cell. If the consumer returns {@code false} the execution is stopped, {@code false}
+     * is returned, and no further pairs are processed.</p>
+     *
+     * @param consumer the action to be performed for each non-zero cell.
+     * @return {@code true} if all cells return true from consumer, {@code false} otherwise.
+     * @throws NullPointerException if the specified consumer is null
+     */
+    boolean forEachCell(CellConsumer consumer);
+
+    /**
+     * The default implementation returns distinct and ordered indices for all cells with a non-zero count.
+     */
+    @Override
+    default boolean forEachIndex(final IntPredicate predicate) {
+        return forEachCell((i, v) -> predicate.test(i));
+    }
+
+    @Override
+    default IndexProducer uniqueIndices() {
+        return this;
+    }
+
+    /**
+     * Creates a CellProducer from an IndexProducer.
+     *
+     * <p>Note the following properties:
+     * <ul>
+     * <li>Each index returned from the IndexProducer is assumed to have a cell value of 1.</li>
+     * <li>The CellProducer aggregates duplicate indices from the IndexProducer.</li>
+     * </ul>
+     *
+     * <p>A CellProducer that outputs the mapping [(1,2),(2,3),(3,1)] can be created from many combinations
+     * of indices including:
+     * <pre>
+     * [1, 1, 2, 2, 2, 3]
+     * [1, 3, 1, 2, 2, 2]
+     * [3, 2, 1, 2, 1, 2]
+     * ...
+     * </pre>
+     *
+     * @param producer An index producer.
+     * @return A CellProducer with the same indices as the IndexProducer.
+     */
+    static CellProducer from(final IndexProducer producer) {
+        return new CellProducer() {
+            TreeMap<CounterCell, CounterCell> counterCells = new TreeMap<>();
+
+            private void populate() {
+                if (counterCells.isEmpty()) {
+                    producer.forEachIndex( idx -> {
+                        CounterCell cell = new CounterCell(idx, 1);
+                        CounterCell counter = counterCells.get(cell);
+                        if (counter == null) {
+                            counterCells.put(cell, cell);
+                        } else {
+                            counter.count++;
+                        }
+                        return true;
+                    });
+                }
+            }
+
+            @Override
+            public int[] asIndexArray() {
+                populate();
+                return counterCells.keySet().stream().mapToInt( c -> c.idx ).toArray();
+            }
+
+            @Override
+            public boolean forEachCell(CellConsumer consumer) {
+                populate();
+                for (CounterCell cell : counterCells.values()) {
+                    if (!consumer.test(cell.idx, cell.count) ) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+
+            /**
+             * Class to track cell values in the TreeMap.
+             */
+            final class CounterCell implements Comparable<CounterCell> {
+                final int idx;
+                int count;
+
+                CounterCell(int idx, int count) {
+                    this.idx = idx;
+                    this.count = count;
+                }
+
+                @Override
+                public int compareTo(CounterCell other) {
+                    return Integer.compare( idx,  other.idx);
+                }
+            }
+        };
+    }
+
+    /**
+     * Represents an operation that accepts an {@code <index, cell>} pair.","[{'comment': 'Refers to `<index, cell>` pair. The rest of the interface is `<index, count>`.', 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java,"@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.TreeMap;
+import java.util.function.IntPredicate;
+
+
+/**
+ * Some Bloom filter implementations use a count rather than a bit flag. The term {@code Cell} is used to
+ * refer to these counts and their associated index.  This class is the equivalent of the index producer except
+ * that it produces cells.
+ *
+ * <p>Note that a CellProducer must not return duplicate indices and must be ordered.</p>
+ *
+ * <p>Implementations must guarantee that:</p>
+ *
+ * <ul>
+ * <li>The IndexProducer implementation returns unique ordered indices.</li>
+ * <li>The cells are produced in IndexProducer order.</li>
+ * <li>For every value produced by the IndexProducer there will be only one matching
+ * cell produced by the CellProducer.</li>
+ * <li>The CellProducer will not generate cells with indices that are not output by the IndexProducer.</li>
+ * <li>The IndexProducer will not generate indices that have a zero count for the cell.</li>
+ * </ul>
+ *
+ * @since 4.5
+ */
+@FunctionalInterface
+public interface CellProducer extends IndexProducer {
+
+    /**
+     * Performs the given action for each {@code cell}  where the cell count is non-zero.
+     *
+     * <p>Some Bloom filter implementations use a count rather than a bit flag.  The term {@code Cell} is used to
+     * refer to these counts.</p>
+     *
+     * <p>Any exceptions thrown by the action are relayed to the caller. The consumer is applied to each
+     * cell. If the consumer returns {@code false} the execution is stopped, {@code false}
+     * is returned, and no further pairs are processed.</p>
+     *
+     * @param consumer the action to be performed for each non-zero cell.
+     * @return {@code true} if all cells return true from consumer, {@code false} otherwise.
+     * @throws NullPointerException if the specified consumer is null
+     */
+    boolean forEachCell(CellConsumer consumer);
+
+    /**
+     * The default implementation returns distinct and ordered indices for all cells with a non-zero count.
+     */
+    @Override
+    default boolean forEachIndex(final IntPredicate predicate) {
+        return forEachCell((i, v) -> predicate.test(i));
+    }
+
+    @Override
+    default IndexProducer uniqueIndices() {
+        return this;
+    }
+
+    /**
+     * Creates a CellProducer from an IndexProducer.
+     *
+     * <p>Note the following properties:
+     * <ul>
+     * <li>Each index returned from the IndexProducer is assumed to have a cell value of 1.</li>
+     * <li>The CellProducer aggregates duplicate indices from the IndexProducer.</li>
+     * </ul>
+     *
+     * <p>A CellProducer that outputs the mapping [(1,2),(2,3),(3,1)] can be created from many combinations
+     * of indices including:
+     * <pre>
+     * [1, 1, 2, 2, 2, 3]
+     * [1, 3, 1, 2, 2, 2]
+     * [3, 2, 1, 2, 1, 2]
+     * ...
+     * </pre>
+     *
+     * @param producer An index producer.
+     * @return A CellProducer with the same indices as the IndexProducer.
+     */
+    static CellProducer from(final IndexProducer producer) {
+        return new CellProducer() {
+            TreeMap<CounterCell, CounterCell> counterCells = new TreeMap<>();
+
+            private void populate() {
+                if (counterCells.isEmpty()) {
+                    producer.forEachIndex( idx -> {
+                        CounterCell cell = new CounterCell(idx, 1);
+                        CounterCell counter = counterCells.get(cell);
+                        if (counter == null) {
+                            counterCells.put(cell, cell);
+                        } else {
+                            counter.count++;
+                        }
+                        return true;
+                    });
+                }
+            }
+
+            @Override
+            public int[] asIndexArray() {
+                populate();
+                return counterCells.keySet().stream().mapToInt( c -> c.idx ).toArray();
+            }
+
+            @Override
+            public boolean forEachCell(CellConsumer consumer) {
+                populate();
+                for (CounterCell cell : counterCells.values()) {
+                    if (!consumer.test(cell.idx, cell.count) ) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+
+            /**
+             * Class to track cell values in the TreeMap.
+             */
+            final class CounterCell implements Comparable<CounterCell> {
+                final int idx;
+                int count;
+
+                CounterCell(int idx, int count) {
+                    this.idx = idx;
+                    this.count = count;
+                }
+
+                @Override
+                public int compareTo(CounterCell other) {
+                    return Integer.compare( idx,  other.idx);","[{'comment': 'Whitespace', 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java,"@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.TreeMap;
+import java.util.function.IntPredicate;
+
+
+/**
+ * Some Bloom filter implementations use a count rather than a bit flag. The term {@code Cell} is used to
+ * refer to these counts and their associated index.  This class is the equivalent of the index producer except
+ * that it produces cells.
+ *
+ * <p>Note that a CellProducer must not return duplicate indices and must be ordered.</p>
+ *
+ * <p>Implementations must guarantee that:</p>
+ *
+ * <ul>
+ * <li>The IndexProducer implementation returns unique ordered indices.</li>
+ * <li>The cells are produced in IndexProducer order.</li>
+ * <li>For every value produced by the IndexProducer there will be only one matching
+ * cell produced by the CellProducer.</li>
+ * <li>The CellProducer will not generate cells with indices that are not output by the IndexProducer.</li>
+ * <li>The IndexProducer will not generate indices that have a zero count for the cell.</li>
+ * </ul>
+ *
+ * @since 4.5
+ */
+@FunctionalInterface
+public interface CellProducer extends IndexProducer {
+
+    /**
+     * Performs the given action for each {@code cell}  where the cell count is non-zero.
+     *
+     * <p>Some Bloom filter implementations use a count rather than a bit flag.  The term {@code Cell} is used to
+     * refer to these counts.</p>
+     *
+     * <p>Any exceptions thrown by the action are relayed to the caller. The consumer is applied to each
+     * cell. If the consumer returns {@code false} the execution is stopped, {@code false}
+     * is returned, and no further pairs are processed.</p>
+     *
+     * @param consumer the action to be performed for each non-zero cell.
+     * @return {@code true} if all cells return true from consumer, {@code false} otherwise.
+     * @throws NullPointerException if the specified consumer is null
+     */
+    boolean forEachCell(CellConsumer consumer);
+
+    /**
+     * The default implementation returns distinct and ordered indices for all cells with a non-zero count.
+     */
+    @Override
+    default boolean forEachIndex(final IntPredicate predicate) {
+        return forEachCell((i, v) -> predicate.test(i));
+    }
+
+    @Override
+    default IndexProducer uniqueIndices() {
+        return this;
+    }
+
+    /**
+     * Creates a CellProducer from an IndexProducer.
+     *
+     * <p>Note the following properties:
+     * <ul>
+     * <li>Each index returned from the IndexProducer is assumed to have a cell value of 1.</li>
+     * <li>The CellProducer aggregates duplicate indices from the IndexProducer.</li>
+     * </ul>
+     *
+     * <p>A CellProducer that outputs the mapping [(1,2),(2,3),(3,1)] can be created from many combinations
+     * of indices including:
+     * <pre>
+     * [1, 1, 2, 2, 2, 3]
+     * [1, 3, 1, 2, 2, 2]
+     * [3, 2, 1, 2, 1, 2]
+     * ...
+     * </pre>
+     *
+     * @param producer An index producer.
+     * @return A CellProducer with the same indices as the IndexProducer.
+     */
+    static CellProducer from(final IndexProducer producer) {
+        return new CellProducer() {
+            TreeMap<CounterCell, CounterCell> counterCells = new TreeMap<>();
+
+            private void populate() {
+                if (counterCells.isEmpty()) {
+                    producer.forEachIndex( idx -> {
+                        CounterCell cell = new CounterCell(idx, 1);
+                        CounterCell counter = counterCells.get(cell);
+                        if (counter == null) {
+                            counterCells.put(cell, cell);
+                        } else {
+                            counter.count++;
+                        }
+                        return true;
+                    });
+                }
+            }
+
+            @Override
+            public int[] asIndexArray() {
+                populate();
+                return counterCells.keySet().stream().mapToInt( c -> c.idx ).toArray();
+            }
+
+            @Override
+            public boolean forEachCell(CellConsumer consumer) {
+                populate();
+                for (CounterCell cell : counterCells.values()) {
+                    if (!consumer.test(cell.idx, cell.count) ) {","[{'comment': 'whitespace', 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java,"@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.TreeMap;
+import java.util.function.IntPredicate;
+
+
+/**
+ * Some Bloom filter implementations use a count rather than a bit flag. The term {@code Cell} is used to
+ * refer to these counts and their associated index.  This class is the equivalent of the index producer except
+ * that it produces cells.
+ *
+ * <p>Note that a CellProducer must not return duplicate indices and must be ordered.</p>
+ *
+ * <p>Implementations must guarantee that:</p>
+ *
+ * <ul>
+ * <li>The IndexProducer implementation returns unique ordered indices.</li>
+ * <li>The cells are produced in IndexProducer order.</li>
+ * <li>For every value produced by the IndexProducer there will be only one matching
+ * cell produced by the CellProducer.</li>
+ * <li>The CellProducer will not generate cells with indices that are not output by the IndexProducer.</li>
+ * <li>The IndexProducer will not generate indices that have a zero count for the cell.</li>
+ * </ul>
+ *
+ * @since 4.5
+ */
+@FunctionalInterface
+public interface CellProducer extends IndexProducer {
+
+    /**
+     * Performs the given action for each {@code cell}  where the cell count is non-zero.
+     *
+     * <p>Some Bloom filter implementations use a count rather than a bit flag.  The term {@code Cell} is used to
+     * refer to these counts.</p>
+     *
+     * <p>Any exceptions thrown by the action are relayed to the caller. The consumer is applied to each
+     * cell. If the consumer returns {@code false} the execution is stopped, {@code false}
+     * is returned, and no further pairs are processed.</p>
+     *
+     * @param consumer the action to be performed for each non-zero cell.
+     * @return {@code true} if all cells return true from consumer, {@code false} otherwise.
+     * @throws NullPointerException if the specified consumer is null
+     */
+    boolean forEachCell(CellConsumer consumer);
+
+    /**
+     * The default implementation returns distinct and ordered indices for all cells with a non-zero count.
+     */
+    @Override
+    default boolean forEachIndex(final IntPredicate predicate) {
+        return forEachCell((i, v) -> predicate.test(i));
+    }
+
+    @Override
+    default IndexProducer uniqueIndices() {
+        return this;
+    }
+
+    /**
+     * Creates a CellProducer from an IndexProducer.
+     *
+     * <p>Note the following properties:
+     * <ul>
+     * <li>Each index returned from the IndexProducer is assumed to have a cell value of 1.</li>
+     * <li>The CellProducer aggregates duplicate indices from the IndexProducer.</li>
+     * </ul>
+     *
+     * <p>A CellProducer that outputs the mapping [(1,2),(2,3),(3,1)] can be created from many combinations
+     * of indices including:
+     * <pre>
+     * [1, 1, 2, 2, 2, 3]
+     * [1, 3, 1, 2, 2, 2]
+     * [3, 2, 1, 2, 1, 2]
+     * ...
+     * </pre>
+     *
+     * @param producer An index producer.
+     * @return A CellProducer with the same indices as the IndexProducer.
+     */
+    static CellProducer from(final IndexProducer producer) {
+        return new CellProducer() {
+            TreeMap<CounterCell, CounterCell> counterCells = new TreeMap<>();
+
+            private void populate() {
+                if (counterCells.isEmpty()) {
+                    producer.forEachIndex( idx -> {
+                        CounterCell cell = new CounterCell(idx, 1);
+                        CounterCell counter = counterCells.get(cell);
+                        if (counter == null) {
+                            counterCells.put(cell, cell);
+                        } else {
+                            counter.count++;
+                        }
+                        return true;
+                    });
+                }
+            }
+
+            @Override
+            public int[] asIndexArray() {
+                populate();
+                return counterCells.keySet().stream().mapToInt( c -> c.idx ).toArray();","[{'comment': 'whitespace', 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java,"@@ -32,6 +33,8 @@
 @FunctionalInterface
 public interface IndexProducer {
 
+    int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;","[{'comment': 'This should not be in the interface. It makes it a public variable.\r\n\r\nI suggest moving the array sizing functionality to a package private class, e.g.:\r\n```java\r\nfinal class IndexUtils {\r\n    // Ensure the array can add an element at the specified index\r\n    static int[] ensureCapacityForAdd(int[] array, int index) {\r\n        // ...\r\n    }\r\n}\r\n```\r\nThere is no other static helper class suitable, so just create an appropriately named class.', 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java,"@@ -117,11 +120,60 @@ public boolean test(long word) {
      * @return An int array of the data.
      */
     default int[] asIndexArray() {
-        final BitSet result = new BitSet();
+        class Indices {
+            private int[] data = new int[32];
+            private int size;
+
+            boolean add(final int index) {
+                if (size == data.length) {
+                    data = Arrays.copyOf(data, (int) Math.min(MAX_ARRAY_SIZE, size * 2L));
+                }
+                data[size++] = index;
+                return true;
+            }
+
+            int[] toArray() {
+                // Edge case to avoid a large array copy
+                return size == data.length ? data : Arrays.copyOf(data, size);
+            }
+        }
+        Indices indices = new Indices();
+        forEachIndex(indices::add);
+        return indices.toArray();
+    }
+
+    /**
+     * Creates an IndexProducer of unique indices for this index.
+     *
+     * <p>This is like the `indices(Shape)` method except that it adds the guarantee that no
+     * duplicate values will be returned. The indices produced are equivalent to those returned
+     * from by a Bloom filter created from this hasher.</p>
+     *
+     * @return the iterator of integers
+     * @throws IndexOutOfBoundsException if any index is less than 0
+     */
+    default IndexProducer uniqueIndices() {
+        final BitSet bitSet = new BitSet();
         forEachIndex(i -> {
-            result.set(i);
+            bitSet.set(i);
             return true;
         });
-        return result.stream().toArray();
+
+        return new IndexProducer() {
+            @Override
+            public boolean forEachIndex(IntPredicate predicate) {
+                for (int idx = bitSet.nextSetBit(0); idx >= 0; idx = bitSet.nextSetBit(idx+1)) {","[{'comment': '`idx + 1`', 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java,,"[{'comment': 'All these changes are not related to this PR. Please revert.\r\n\r\nThey can be considered separately. By chaining predicates using `and`, `or` and `negate` you are adding a layer of obfuscation where the method calls may make the filter less efficient. A performance benchmark would useful here.', 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java,"@@ -309,4 +309,12 @@ default int estimateIntersection(final BloomFilter other) {
         }
         return estimate>Integer.MAX_VALUE?Integer.MAX_VALUE:(int) estimate;
     }
+
+    /**
+     * Most Bloom filter's create unique IndexProducers.","[{'comment': ""`filter's` to `filters`\r\n\r\nThis is low quality javadoc."", 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java,"@@ -117,11 +120,60 @@ public boolean test(long word) {
      * @return An int array of the data.
      */
     default int[] asIndexArray() {
-        final BitSet result = new BitSet();
+        class Indices {
+            private int[] data = new int[32];
+            private int size;
+
+            boolean add(final int index) {
+                if (size == data.length) {
+                    data = Arrays.copyOf(data, (int) Math.min(MAX_ARRAY_SIZE, size * 2L));
+                }
+                data[size++] = index;
+                return true;
+            }
+
+            int[] toArray() {
+                // Edge case to avoid a large array copy
+                return size == data.length ? data : Arrays.copyOf(data, size);
+            }
+        }
+        Indices indices = new Indices();
+        forEachIndex(indices::add);
+        return indices.toArray();
+    }
+
+    /**
+     * Creates an IndexProducer of unique indices for this index.
+     *
+     * <p>This is like the `indices(Shape)` method except that it adds the guarantee that no","[{'comment': 'Since you moved this from Hasher it refers to a non-existent method `indices(Shape)`. This paragraph also refers to `this hasher`\r\n', 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java,"@@ -117,11 +120,60 @@ public boolean test(long word) {
      * @return An int array of the data.
      */
     default int[] asIndexArray() {
-        final BitSet result = new BitSet();
+        class Indices {
+            private int[] data = new int[32];
+            private int size;
+
+            boolean add(final int index) {
+                if (size == data.length) {
+                    data = Arrays.copyOf(data, (int) Math.min(MAX_ARRAY_SIZE, size * 2L));
+                }
+                data[size++] = index;
+                return true;
+            }
+
+            int[] toArray() {
+                // Edge case to avoid a large array copy
+                return size == data.length ? data : Arrays.copyOf(data, size);
+            }
+        }
+        Indices indices = new Indices();
+        forEachIndex(indices::add);
+        return indices.toArray();
+    }
+
+    /**
+     * Creates an IndexProducer of unique indices for this index.","[{'comment': 'Creates an IndexProducer that returns the same indices as this instance, removing duplicates so that each index will be output only once.', 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java,"@@ -117,11 +120,60 @@ public boolean test(long word) {
      * @return An int array of the data.
      */
     default int[] asIndexArray() {
-        final BitSet result = new BitSet();
+        class Indices {
+            private int[] data = new int[32];
+            private int size;
+
+            boolean add(final int index) {
+                if (size == data.length) {
+                    data = Arrays.copyOf(data, (int) Math.min(MAX_ARRAY_SIZE, size * 2L));
+                }
+                data[size++] = index;
+                return true;
+            }
+
+            int[] toArray() {
+                // Edge case to avoid a large array copy
+                return size == data.length ? data : Arrays.copyOf(data, size);
+            }
+        }
+        Indices indices = new Indices();
+        forEachIndex(indices::add);
+        return indices.toArray();
+    }
+
+    /**
+     * Creates an IndexProducer of unique indices for this index.
+     *
+     * <p>This is like the `indices(Shape)` method except that it adds the guarantee that no
+     * duplicate values will be returned. The indices produced are equivalent to those returned
+     * from by a Bloom filter created from this hasher.</p>
+     *
+     * @return the iterator of integers
+     * @throws IndexOutOfBoundsException if any index is less than 0","[{'comment': 'This IOOB exception is only relevant to the default implementation. As such I would remove it from the `@throws` and document the default implementation. ""The default implementation will filter the indices from this instance and return them in ascending order. Any indices less than zero are invalid and will generate a runtime exception.""', 'commenter': 'aherbert'}]"
406,src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java,"@@ -103,40 +172,41 @@ default boolean merge(final BloomFilter other) {
     /**
      * Merges the specified Hasher into this Bloom filter.
      *
-     * <p>Specifically: all counts for the unique indexes identified by the {@code hasher} will be incremented by 1.</p>
+     * <p>Specifically: all cells for the unique indexes identified by the {@code hasher} will be incremented by 1.</p>
      *
      * <p>This method will return {@code true} if the filter is valid after the operation.</p>
      *
      * @param hasher the hasher
      * @return {@code true} if the removal was successful and the state is valid
      * @see #isValid()
-     * @see #add(BitCountProducer)
+     * @see #add(CellProducer)
      */
     @Override
     default boolean merge(final Hasher hasher) {
         Objects.requireNonNull(hasher, ""hasher"");
-        return merge(hasher.uniqueIndices(getShape()));
+        return merge(hasher.indices(getShape()));
     }
 
     /**
      * Merges the specified index producer into this Bloom filter.
      *
-     * <p>Specifically: all counts for the indexes identified by the {@code indexProducer} will be incremented by 1.</p>
+     * <p>Specifically: all unique cells for the indices identified by the {@code indexProducer} will be incremented by 1.</p>
      *
      * <p>This method will return {@code true} if the filter is valid after the operation.</p>
      *
-     * <p>Note: Indices that are returned multiple times will be incremented multiple times.</p>
+     * <p>Note: If indices that are returned multiple times should be incremented multiple times convert the IndexProducer
+     * to a CellProducer and add that.</p>
      *
      * @param indexProducer the IndexProducer
      * @return {@code true} if the removal was successful and the state is valid
      * @see #isValid()
-     * @see #add(BitCountProducer)
+     * @see #add(CellProducer)
      */
     @Override
     default boolean merge(final IndexProducer indexProducer) {
         Objects.requireNonNull(indexProducer, ""indexProducer"");
         try {
-            return add(BitCountProducer.from(indexProducer));
+            return add(CellProducer.from(indexProducer.uniqueIndices()));
         } catch (final IndexOutOfBoundsException e) {","[{'comment': 'Note: Although not related to this PR I find it presumptuous that the code may throw an index out of bounds exception. This exception is possible from the `uniqueIndices` default implementation (see my comments on that elsewhere in this PR), and if the `indexProducer` has its own unique indices and is broken, it would be from the `add` method of the implementing counting Bloom filter. That is allowed to throw whatever runtime exception it desires. So why are we wrapping this one possible exception, and then re-throwing it as another RTE when neither are documented? This should be discussed somewhere (e.g. mailing list).', 'commenter': 'aherbert'}]"
406,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellProducerTest.java,"@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
+
+import java.util.Arrays;
+import java.util.BitSet;
+
+import org.apache.commons.collections4.bloomfilter.CellProducer.CellConsumer;
+import org.junit.jupiter.api.Test;
+
+public abstract class AbstractCellProducerTest extends AbstractIndexProducerTest {
+
+    /**
+     * A testing CellConsumer that always returns true.
+     */
+    private static final CellConsumer TRUE_CONSUMER = (i, j) -> true;
+    /**
+     * A testing CellConsumer that always returns false.
+     */
+    private static final CellConsumer FALSE_CONSUMER = (i, j) -> false;
+
+    /**
+     * Creates an array of expected values that alignes with the expected indices entries.
+     * @return an array of expected values.
+     * @see AbstractIndexProducerTest#getExpectedIndices()
+     */
+    protected abstract int[] getExpectedValues();
+
+    @Override
+    protected final int getAsIndexArrayBehaviour() {
+        return ORDERED | DISTINCT;
+    }
+
+    /**
+     * Creates a producer with some data.
+     * @return a producer with some data
+     */
+    @Override
+    protected abstract CellProducer createProducer();
+
+    /**
+     * Creates a producer without data.
+     * @return a producer that has no data.
+     */
+    @Override
+    protected abstract CellProducer createEmptyProducer();
+
+    @Test
+    public final void testForEachCellPredicates() {
+        final CellProducer populated = createProducer();
+        final CellProducer empty = createEmptyProducer();
+
+        assertFalse(populated.forEachCell(FALSE_CONSUMER), ""non-empty should be false"");
+        assertTrue(empty.forEachCell(FALSE_CONSUMER), ""empty should be true"");
+
+        assertTrue(populated.forEachCell(TRUE_CONSUMER), ""non-empty should be true"");
+        assertTrue(empty.forEachCell(TRUE_CONSUMER), ""empty should be true"");
+    }
+
+    @Test
+    public final void testEmptyCellProducer() {
+        final CellProducer empty = createEmptyProducer();
+        final int ary[] = empty.asIndexArray();
+        assertEquals(0, ary.length);
+        assertTrue(empty.forEachCell((i, j) -> {
+            fail(""forEachCell consumer should not be called"");
+            return false;
+        }));
+    }
+
+    @Test
+    public final void testIndexConsistency() {
+        final CellProducer producer = createProducer();
+        final BitSet bs1 = new BitSet();
+        final BitSet bs2 = new BitSet();
+        producer.forEachIndex(i -> {
+            bs1.set(i);
+            return true;
+        });
+        producer.forEachCell((i, j) -> {
+            bs2.set(i);
+            return true;
+        });
+        assertEquals(bs1, bs2);
+    }
+
+    @Test
+    public void testForEachCellValues() {
+        int[] expectedIdx = getExpectedIndices();
+        int[] expectedValue = getExpectedValues();
+        assertEquals( expectedIdx.length, expectedValue.length, ""expected index length and value length do not match"");
+        int[] idx = {0};
+        createProducer().forEachCell((i, j) -> {
+            assertEquals(expectedIdx[idx[0]], i, ""bad index at ""+idx[0]);
+            assertEquals(expectedValue[idx[0]], j, ""bad value at ""+idx[0]);
+            idx[0]++;
+            return true;
+        });
+    }
+
+    /**
+     * Test the behavior of {@link CellProducer#forEachCell(CellConsumer)} with respect
+     * to ordered and distinct indices. Currently the behavior is assumed to be the same as
+     * {@link IndexProducer#forEachIndex(java.util.function.IntPredicate)}.
+     */
+    @Test
+    public final void testBehaviourForEachCell() {
+        final IntList list = new IntList();
+        createProducer().forEachCell((i, j) -> list.add(i));
+        final int[] actual = list.toArray();
+        // check order
+        final int[] expected = Arrays.stream(actual).sorted().toArray();
+        assertArrayEquals(expected, actual);
+        // check distinct
+        final long count = Arrays.stream(actual).distinct().count();
+        assertEquals(count, actual.length);
+    }
+
+    @Test
+    public void testForEachCellEarlyExit() {
+        final int[] passes = new int[1];
+        assertTrue(createEmptyProducer().forEachCell((i, j) -> {
+            passes[0]++;
+            return false;
+        }));
+        assertEquals(0, passes[0]);
+
+        assertFalse(createProducer().forEachCell((i, j) -> {","[{'comment': 'This test heavily assumes that the `createProducer` will have more than 1 cell populated so you can early exit.', 'commenter': 'aherbert'}]"
406,src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellProducerTest.java,"@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
+
+import java.util.Arrays;
+import java.util.BitSet;
+
+import org.apache.commons.collections4.bloomfilter.CellProducer.CellConsumer;
+import org.junit.jupiter.api.Test;
+
+public abstract class AbstractCellProducerTest extends AbstractIndexProducerTest {
+
+    /**
+     * A testing CellConsumer that always returns true.
+     */
+    private static final CellConsumer TRUE_CONSUMER = (i, j) -> true;
+    /**
+     * A testing CellConsumer that always returns false.
+     */
+    private static final CellConsumer FALSE_CONSUMER = (i, j) -> false;
+
+    /**
+     * Creates an array of expected values that alignes with the expected indices entries.
+     * @return an array of expected values.
+     * @see AbstractIndexProducerTest#getExpectedIndices()
+     */
+    protected abstract int[] getExpectedValues();
+
+    @Override
+    protected final int getAsIndexArrayBehaviour() {
+        return ORDERED | DISTINCT;
+    }
+
+    /**
+     * Creates a producer with some data.
+     * @return a producer with some data
+     */
+    @Override
+    protected abstract CellProducer createProducer();
+
+    /**
+     * Creates a producer without data.
+     * @return a producer that has no data.
+     */
+    @Override
+    protected abstract CellProducer createEmptyProducer();
+
+    @Test
+    public final void testForEachCellPredicates() {
+        final CellProducer populated = createProducer();
+        final CellProducer empty = createEmptyProducer();
+
+        assertFalse(populated.forEachCell(FALSE_CONSUMER), ""non-empty should be false"");
+        assertTrue(empty.forEachCell(FALSE_CONSUMER), ""empty should be true"");
+
+        assertTrue(populated.forEachCell(TRUE_CONSUMER), ""non-empty should be true"");
+        assertTrue(empty.forEachCell(TRUE_CONSUMER), ""empty should be true"");
+    }
+
+    @Test
+    public final void testEmptyCellProducer() {
+        final CellProducer empty = createEmptyProducer();
+        final int ary[] = empty.asIndexArray();
+        assertEquals(0, ary.length);
+        assertTrue(empty.forEachCell((i, j) -> {
+            fail(""forEachCell consumer should not be called"");
+            return false;
+        }));
+    }
+
+    @Test
+    public final void testIndexConsistency() {
+        final CellProducer producer = createProducer();
+        final BitSet bs1 = new BitSet();
+        final BitSet bs2 = new BitSet();
+        producer.forEachIndex(i -> {
+            bs1.set(i);
+            return true;
+        });
+        producer.forEachCell((i, j) -> {
+            bs2.set(i);
+            return true;
+        });
+        assertEquals(bs1, bs2);
+    }
+
+    @Test
+    public void testForEachCellValues() {
+        int[] expectedIdx = getExpectedIndices();
+        int[] expectedValue = getExpectedValues();
+        assertEquals( expectedIdx.length, expectedValue.length, ""expected index length and value length do not match"");","[{'comment': 'whitespace', 'commenter': 'aherbert'}]"
