Pull,Path,Diff_hunk,Comment
78,curator-client/src/main/java/org/apache/curator/ensemble/exhibitor/ExhibitorEnsembleProvider.java,"@@ -301,7 +301,7 @@ else if ( port != thePort )
                     values.putAll(decodeExhibitorList(encoded));
                     done = true;
                 }
-                catch ( Throwable e )
+                catch ( Exception e )","[{'comment': ""I don't understand how this is an improvement. Exceptions such as NPE or OOM would be lost with this change. By catching Throwable, those exceptions are logged.\n"", 'commenter': 'Randgalt'}, {'comment': ""NPE still gets caught. If OOM is thrown, does it really make sense to retry? That's usually a pretty drastic condition and very often the JVM is not actually in a recoverable state. The OOM can be thrown because of a different thread going wonky, and we have no way to clean up the resources it was using.\n"", 'commenter': 'madrob'}, {'comment': ""Probably not. But, I'd view that as a separate issue. It's technically up to the retry policy passed to ExhibitorEnsembleProvider.\n"", 'commenter': 'Randgalt'}, {'comment': 'You also need to \\worry about ThreadDeath error:\n\nhttps://docs.oracle.com/javase/7/docs/api/java/lang/ThreadDeath.html\n\n```\nAn application should catch instances of this class only if it must clean up after being terminated asynchronously. \nIf ThreadDeath is caught by a method, it is important that it be rethrown so that the thread actually dies.\n```\n\nSo ThreadDeath Error can be logged, but should never retry to avoid destabilizing JVM.\n', 'commenter': 'SamG1000'}]"
78,curator-framework/src/main/java/org/apache/curator/framework/imps/CuratorFrameworkImpl.java,"@@ -812,31 +812,28 @@ private void performBackgroundOperation(OperationAndData<?> operationAndData)
                 queueOperation(operationAndData);
             }
         }
-        catch ( Throwable e )
+        catch ( CuratorConnectionLossException e )","[{'comment': 'Similar to above. If Throwable is not caught, the exception will be lost. By catching Throwable, the exception will get logged.\n', 'commenter': 'Randgalt'}]"
165,curator-client/src/main/java/org/apache/curator/ConnectionState.java,"@@ -199,13 +202,28 @@ private synchronized void checkTimeouts() throws Exception
                     {
                         log.error(String.format(""Connection timed out for connection string (%s) and timeout (%d) / elapsed (%d)"", zooKeeper.getConnectionString(), connectionTimeoutMs, elapsed), connectionLossException);
                     }
-                    tracer.get().addCount(""connections-timed-out"", 1);
+                    new EventTrace(""connections-timed-out"", tracer.get(), getSessionId()).commit();
                     throw connectionLossException;
                 }
             }
         }
     }
 
+    /**
+     * Return the current session id
+     */
+    public long getSessionId() {
+        long sessionId = -1;
+        if (isConnected()) {
+            try {
+                sessionId = getZooKeeper().getSessionId();","[{'comment': 'This is an expensive call. Is it really necessary? Maybe we can get the session ID cheaper by a direct call to `zooKeeper.getZooKeeper()` - (checking for nulls)\n', 'commenter': 'Randgalt'}, {'comment': ""Session id is a useful information to track the client side issue, it's kind of identity, so we would like to include it. I'll change it to use zookeeper.getZookeeper() directly here.\n"", 'commenter': 'lvfangmin'}]"
179,curator-framework/src/main/java/org/apache/curator/framework/imps/EnsembleTracker.java,"@@ -179,13 +179,16 @@ public static String configToConnectionString(QuorumVerifier data) throws Except
 
     private void processConfigData(byte[] data) throws Exception
     {
-        log.info(""New config event received: "" + Arrays.toString(data));
-
         Properties properties = new Properties();
         properties.load(new ByteArrayInputStream(data));
         QuorumMaj newConfig = new QuorumMaj(properties);
         currentConfig.set(newConfig);
 
+        if ( log.isInfoEnabled() )","[{'comment': 'Instead of this check you can do:\r\n\r\n```java\r\nlog.info(""New config event received: {}"", properties);\r\n```', 'commenter': 'Randgalt'}]"
197,curator-client/src/main/java/org/apache/curator/ConnectionState.java,"@@ -160,13 +162,33 @@ public void process(WatchedEvent event)
             }
         }
 
+        // only wait during tests
+        assert waitOnExpiredEvent(event.getState());","[{'comment': ""How is this meant to work? Are you assuming that assertions will only be enabled in testing? If you need some logic to only be executed during testing shouldn't there be some sort of internal flag indicating this?"", 'commenter': 'cammckenzie'}, {'comment': ""Yes, assuming assertions are enabled in testing. I've added the delay here wait for the reconnect to happen, but since now the reset is called later in the method it might no longer be necessary."", 'commenter': 'Zoltan-Szekeres'}, {'comment': ""I don't think that it's reasonable to assume that assertions will only be turned on during testing. If you look at something like LeaderSelector, it has specific code in there to support unit testing (the debugLeadershipLatch variable).\r\n\r\nIf you can cause the problem to occur without this code though, then it should be removed. I had a quick play with it and I couldn't seem to reproduce it without this code though."", 'commenter': 'cammckenzie'}, {'comment': 'I changed using a debug flag instead of assert. I added an accessor class to be able to set the flag in the package private ConnectionState class.\r\n\r\nI cannot cause the problem to occur without this code.', 'commenter': 'Zoltan-Szekeres'}]"
197,curator-client/src/main/java/org/apache/curator/ConnectionState.java,"@@ -160,13 +162,33 @@ public void process(WatchedEvent event)
             }
         }
 
+        // only wait during tests
+        assert waitOnExpiredEvent(event.getState());
+
         for ( Watcher parentWatcher : parentWatchers )
         {
-
             OperationTrace trace = new OperationTrace(""connection-state-parent-process"", tracer.get(), getSessionId());
             parentWatcher.process(event);
             trace.commit();
         }
+
+        if (eventTypeNone) handleState(event.getState());
+    }
+
+    // only for testing
+    private boolean waitOnExpiredEvent(Event.KeeperState currentState)","[{'comment': 'What is the purpose of the boolean return? The method only ever returns true? Is it purely so you can call it from the assert?', 'commenter': 'cammckenzie'}, {'comment': 'Yes - only so that it can be called form assert.', 'commenter': 'Zoltan-Szekeres'}]"
197,curator-client/src/main/java/org/apache/curator/ConnectionState.java,"@@ -283,12 +300,19 @@ private boolean checkState(Event.KeeperState state, boolean wasConnected)
             new EventTrace(state.toString(), tracer.get(), getSessionId()).commit();
         }
 
-        if ( checkNewConnectionString && zooKeeper.hasNewConnectionString() )
+        return isConnected;
+    }
+
+    private void handleState(Event.KeeperState state)
+    {
+        if (state == Event.KeeperState.Expired)
+        {
+            handleExpiredSession();","[{'comment': ""We've lost functionality here right? If there's a new connection string and an expired session we don't get the new connection string."", 'commenter': 'Randgalt'}, {'comment': 'It gets handled in the handleState() method, which is called from process()', 'commenter': 'cammckenzie'}, {'comment': ""It's `handleState()` that I'm concerned about. When `state == Event.KeeperState.Expired` the `zooKeeper.hasNewConnectionString()` isn't called."", 'commenter': 'Randgalt'}, {'comment': ""Isn't that true of the existing implementation though? If the state is expired then the checkNewConnectionString flag gets set to false so the handleNewConnectionString() method won't get called."", 'commenter': 'cammckenzie'}, {'comment': ""Oh - I think you're right. The old version set `checkNewConnectionString=false`"", 'commenter': 'Randgalt'}]"
206,src/site/confluence/index.confluence,"@@ -2,7 +2,10 @@ h1. Welcome to Apache Curator
 
 h2. What is Curator?
 
-Curator _n &#x02c8;kyoor&#x035d;&#x02cc;&#x0101;t&#x0259;r_: a keeper or custodian of a museum or other collection \- A ZooKeeper Keeper.","[{'comment': ""I'd like to keep this line please. "", 'commenter': 'Randgalt'}]"
206,src/site/confluence/index.confluence,"@@ -4,6 +4,10 @@ h2. What is Curator?
 
 Curator _n &#x02c8;kyoor&#x035d;&#x02cc;&#x0101;t&#x0259;r_: a keeper or custodian of a museum or other collection \- A ZooKeeper Keeper.
 
+Then, what is Apache Curator? Apache Curator is a Java/JVM client library for [[Apache ZooKeeper|https://zookeeper.apache.org/]], a distributed coordination service.","[{'comment': '""Then, what is Apache Curator?"" is unnecessary IMO. I prefer the line without this.', 'commenter': 'Randgalt'}]"
209,pom.xml,"@@ -277,6 +277,16 @@
             <timezone>-8</timezone>
             <url>https://people.apache.org/~enis</url>
         </developer>
+
+        <developer>
+            <name>Fangmin Lyu</name>
+            <email>fangmin@apache.org</email>
+            <roles>
+                <role>PMC Member</role>","[{'comment': 'You are also a  <role>Committer</role>', 'commenter': 'Randgalt'}, {'comment': '@Randgalt to be clear, you mean I can commit without have this being reviewed?', 'commenter': 'lvfangmin'}, {'comment': 'No, I meant you need to add another line to the file:\r\n\r\n```xml\r\n<role>Committer</role>\r\n```', 'commenter': 'Randgalt'}]"
237,curator-framework/pom.xml,"@@ -100,6 +100,27 @@
                     </execution>
                 </executions>
             </plugin>
+            <plugin>
+                <groupId>org.apache.felix</groupId>
+                <artifactId>maven-bundle-plugin</artifactId>
+                <version>3.3.0</version>
+                <extensions>true</extensions>
+                <configuration>
+                    <instructions>
+                        <Import-Package>!org.apache.curator,*</Import-Package>","[{'comment': 'There is no need to define the plugin again. The plugin is defined once in the parent pom and inherited from the rest of the modules.\r\n\r\nTo customize a modules configuration please set properties:\r\n- `osgi.import.package`\r\n- `osgi.export.package`', 'commenter': 'iocanel'}]"
243,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatchIsolatedZookeeper.java,"@@ -0,0 +1,224 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.leader;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotEquals;
+import static org.testng.Assert.assertTrue;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.net.SocketException;
+
+import org.apache.curator.framework.recipes.leader.testing.DummyLeaderLatch;
+import org.apache.curator.test.TestingCluster;
+import org.apache.curator.test.TestingZooKeeperServer;
+import org.apache.zookeeper.server.quorum.Leader;
+import org.apache.zookeeper.server.quorum.LearnerHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+/** Tests issue: CURATOR-444: Zookeeper node is isolated from other zookeepers but not from curator
+ *  temporally */
+
+
+public class TestLeaderLatchIsolatedZookeeper {
+
+	private static final Logger logger = LoggerFactory.getLogger(TestLeaderLatchIsolatedZookeeper.class);
+	private static final int CONNECTION_TIMEOUT_MS = 15000;
+	private static final int SESSION_TIMEOUT_MS = 10000;
+
+	private TestingCluster cluster;
+	private DummyLeaderLatch firstClient;
+	private DummyLeaderLatch secondClient;
+
+	@BeforeMethod
+	public void beforeMethod() throws Exception {
+		cluster = new TestingCluster(3);
+		cluster.start();
+		firstClient  = new DummyLeaderLatch(cluster.getConnectString(), SESSION_TIMEOUT_MS, CONNECTION_TIMEOUT_MS, ""First"");
+		secondClient = new DummyLeaderLatch(cluster.getConnectString(), SESSION_TIMEOUT_MS, CONNECTION_TIMEOUT_MS, ""Second"");
+		firstClient.startAndAwaitElection();
+		secondClient.startAndAwaitElection();
+		logger.info(""Session: "" + SESSION_TIMEOUT_MS + "" connection "" + CONNECTION_TIMEOUT_MS );
+	}
+
+	@AfterMethod
+	public void afterMethod() throws IOException {
+		firstClient.stop();
+		secondClient.stop();
+		cluster.close();
+		DummyLeaderLatch.resetHistory();
+	}
+
+	@Test
+	public void testThatStartsWithOnlyOneLeader() throws Exception {
+		assertNotEquals(firstClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToLatch());
+	}
+
+	@Test
+	public void testThatStartCoherent() throws Exception {
+		assertEquals(firstClient.isLeaderAccordingToLatch(),  firstClient.isLeaderAccordingToEvents());
+		assertEquals(secondClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToEvents());
+	}
+
+	@Test(invocationCount = 10)
+	public void testThatResistsNetworkGlitches() throws Exception {
+
+		blockLeaderListeningForSomeTime(SESSION_TIMEOUT_MS);
+
+		Thread.sleep(SESSION_TIMEOUT_MS * 3);
+
+		assertTrue(isHistoryValid(), ""History is not valid: "" + DummyLeaderLatch.getEventHistory());
+
+		assertEquals(   firstClient.isLeaderAccordingToLatch(),  firstClient.isLeaderAccordingToEvents());
+		assertEquals(  secondClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToEvents());
+		assertNotEquals(firstClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToLatch());
+	}
+
+	private void blockLeaderListeningForSomeTime(long milliseconds) throws InterruptedException {
+		for(TestingZooKeeperServer server : cluster.getServers()) {
+
+			if (server.getQuorumPeer().leader != null) {
+				Leader leader = server.getQuorumPeer().leader;
+
+				for (LearnerHandler learnerHandler : leader.getLearners()) {
+
+					logger.info(""Locking "" + learnerHandler.getName());
+					HandlerLocker locker = new HandlerLocker(learnerHandler, milliseconds);
+					locker.start();","[{'comment': 'These threads never get stopped again do they?', 'commenter': 'cammckenzie'}]"
243,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatchIsolatedZookeeper.java,"@@ -0,0 +1,224 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.leader;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotEquals;
+import static org.testng.Assert.assertTrue;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.net.SocketException;
+
+import org.apache.curator.framework.recipes.leader.testing.DummyLeaderLatch;
+import org.apache.curator.test.TestingCluster;
+import org.apache.curator.test.TestingZooKeeperServer;
+import org.apache.zookeeper.server.quorum.Leader;
+import org.apache.zookeeper.server.quorum.LearnerHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+/** Tests issue: CURATOR-444: Zookeeper node is isolated from other zookeepers but not from curator
+ *  temporally */
+
+
+public class TestLeaderLatchIsolatedZookeeper {
+
+	private static final Logger logger = LoggerFactory.getLogger(TestLeaderLatchIsolatedZookeeper.class);
+	private static final int CONNECTION_TIMEOUT_MS = 15000;
+	private static final int SESSION_TIMEOUT_MS = 10000;
+
+	private TestingCluster cluster;
+	private DummyLeaderLatch firstClient;
+	private DummyLeaderLatch secondClient;
+
+	@BeforeMethod
+	public void beforeMethod() throws Exception {
+		cluster = new TestingCluster(3);
+		cluster.start();
+		firstClient  = new DummyLeaderLatch(cluster.getConnectString(), SESSION_TIMEOUT_MS, CONNECTION_TIMEOUT_MS, ""First"");
+		secondClient = new DummyLeaderLatch(cluster.getConnectString(), SESSION_TIMEOUT_MS, CONNECTION_TIMEOUT_MS, ""Second"");
+		firstClient.startAndAwaitElection();
+		secondClient.startAndAwaitElection();
+		logger.info(""Session: "" + SESSION_TIMEOUT_MS + "" connection "" + CONNECTION_TIMEOUT_MS );
+	}
+
+	@AfterMethod
+	public void afterMethod() throws IOException {
+		firstClient.stop();
+		secondClient.stop();
+		cluster.close();
+		DummyLeaderLatch.resetHistory();
+	}
+
+	@Test
+	public void testThatStartsWithOnlyOneLeader() throws Exception {
+		assertNotEquals(firstClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToLatch());
+	}
+
+	@Test
+	public void testThatStartCoherent() throws Exception {
+		assertEquals(firstClient.isLeaderAccordingToLatch(),  firstClient.isLeaderAccordingToEvents());
+		assertEquals(secondClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToEvents());
+	}
+
+	@Test(invocationCount = 10)
+	public void testThatResistsNetworkGlitches() throws Exception {
+
+		blockLeaderListeningForSomeTime(SESSION_TIMEOUT_MS);
+
+		Thread.sleep(SESSION_TIMEOUT_MS * 3);
+
+		assertTrue(isHistoryValid(), ""History is not valid: "" + DummyLeaderLatch.getEventHistory());
+
+		assertEquals(   firstClient.isLeaderAccordingToLatch(),  firstClient.isLeaderAccordingToEvents());
+		assertEquals(  secondClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToEvents());
+		assertNotEquals(firstClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToLatch());
+	}
+
+	private void blockLeaderListeningForSomeTime(long milliseconds) throws InterruptedException {
+		for(TestingZooKeeperServer server : cluster.getServers()) {
+
+			if (server.getQuorumPeer().leader != null) {
+				Leader leader = server.getQuorumPeer().leader;
+
+				for (LearnerHandler learnerHandler : leader.getLearners()) {
+
+					logger.info(""Locking "" + learnerHandler.getName());
+					HandlerLocker locker = new HandlerLocker(learnerHandler, milliseconds);
+					locker.start();
+				}
+			}
+		}
+	}
+
+	private static class HandlerLocker extends Thread{
+
+		private final long milliseconds;
+		private final LearnerHandler learnerHandler;
+
+		public HandlerLocker(LearnerHandler learnerHandler, long milliseconds){
+			this.learnerHandler = learnerHandler;
+			this.milliseconds = milliseconds;
+		}
+
+		@Override
+		public void run() {
+			//suspendThread();
+			//closeSocket();
+			//lockSocket();
+			forceTimeout();","[{'comment': ""If these commented out things aren't used, then can we remove?"", 'commenter': 'cammckenzie'}]"
243,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatchIsolatedZookeeper.java,"@@ -0,0 +1,224 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.leader;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotEquals;
+import static org.testng.Assert.assertTrue;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.net.SocketException;
+
+import org.apache.curator.framework.recipes.leader.testing.DummyLeaderLatch;
+import org.apache.curator.test.TestingCluster;
+import org.apache.curator.test.TestingZooKeeperServer;
+import org.apache.zookeeper.server.quorum.Leader;
+import org.apache.zookeeper.server.quorum.LearnerHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+/** Tests issue: CURATOR-444: Zookeeper node is isolated from other zookeepers but not from curator
+ *  temporally */
+
+
+public class TestLeaderLatchIsolatedZookeeper {
+
+	private static final Logger logger = LoggerFactory.getLogger(TestLeaderLatchIsolatedZookeeper.class);
+	private static final int CONNECTION_TIMEOUT_MS = 15000;
+	private static final int SESSION_TIMEOUT_MS = 10000;
+
+	private TestingCluster cluster;
+	private DummyLeaderLatch firstClient;
+	private DummyLeaderLatch secondClient;
+
+	@BeforeMethod
+	public void beforeMethod() throws Exception {
+		cluster = new TestingCluster(3);
+		cluster.start();
+		firstClient  = new DummyLeaderLatch(cluster.getConnectString(), SESSION_TIMEOUT_MS, CONNECTION_TIMEOUT_MS, ""First"");
+		secondClient = new DummyLeaderLatch(cluster.getConnectString(), SESSION_TIMEOUT_MS, CONNECTION_TIMEOUT_MS, ""Second"");
+		firstClient.startAndAwaitElection();
+		secondClient.startAndAwaitElection();
+		logger.info(""Session: "" + SESSION_TIMEOUT_MS + "" connection "" + CONNECTION_TIMEOUT_MS );
+	}
+
+	@AfterMethod
+	public void afterMethod() throws IOException {
+		firstClient.stop();
+		secondClient.stop();
+		cluster.close();
+		DummyLeaderLatch.resetHistory();
+	}
+
+	@Test
+	public void testThatStartsWithOnlyOneLeader() throws Exception {
+		assertNotEquals(firstClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToLatch());
+	}
+
+	@Test
+	public void testThatStartCoherent() throws Exception {
+		assertEquals(firstClient.isLeaderAccordingToLatch(),  firstClient.isLeaderAccordingToEvents());
+		assertEquals(secondClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToEvents());
+	}
+
+	@Test(invocationCount = 10)
+	public void testThatResistsNetworkGlitches() throws Exception {
+
+		blockLeaderListeningForSomeTime(SESSION_TIMEOUT_MS);
+
+		Thread.sleep(SESSION_TIMEOUT_MS * 3);
+
+		assertTrue(isHistoryValid(), ""History is not valid: "" + DummyLeaderLatch.getEventHistory());
+
+		assertEquals(   firstClient.isLeaderAccordingToLatch(),  firstClient.isLeaderAccordingToEvents());
+		assertEquals(  secondClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToEvents());
+		assertNotEquals(firstClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToLatch());
+	}
+
+	private void blockLeaderListeningForSomeTime(long milliseconds) throws InterruptedException {
+		for(TestingZooKeeperServer server : cluster.getServers()) {
+
+			if (server.getQuorumPeer().leader != null) {
+				Leader leader = server.getQuorumPeer().leader;
+
+				for (LearnerHandler learnerHandler : leader.getLearners()) {
+
+					logger.info(""Locking "" + learnerHandler.getName());
+					HandlerLocker locker = new HandlerLocker(learnerHandler, milliseconds);
+					locker.start();
+				}
+			}
+		}
+	}
+
+	private static class HandlerLocker extends Thread{
+
+		private final long milliseconds;
+		private final LearnerHandler learnerHandler;
+
+		public HandlerLocker(LearnerHandler learnerHandler, long milliseconds){
+			this.learnerHandler = learnerHandler;
+			this.milliseconds = milliseconds;
+		}
+
+		@Override
+		public void run() {
+			//suspendThread();
+			//closeSocket();
+			//lockSocket();
+			forceTimeout();
+		}
+
+		private void forceTimeout(){
+			try{
+				Socket socket = learnerHandler.getSocket();
+				int oldTimeout = learnerHandler.getSocket().getSoTimeout();
+				socket.setSoTimeout(1);
+				Thread.sleep(SESSION_TIMEOUT_MS);
+				socket.setSoTimeout(oldTimeout);
+
+			}catch (SocketException ex){
+				logger.error(""Error forcing timeout"", ex);
+			} catch (InterruptedException ex) {
+				logger.error(""Interrupted while forcing timeout"", ex);
+			}
+		}
+
+
+		private void lockSocket(){
+			try{","[{'comment': 'Method is not used?', 'commenter': 'cammckenzie'}]"
243,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatchIsolatedZookeeper.java,"@@ -0,0 +1,224 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.leader;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotEquals;
+import static org.testng.Assert.assertTrue;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.net.SocketException;
+
+import org.apache.curator.framework.recipes.leader.testing.DummyLeaderLatch;
+import org.apache.curator.test.TestingCluster;
+import org.apache.curator.test.TestingZooKeeperServer;
+import org.apache.zookeeper.server.quorum.Leader;
+import org.apache.zookeeper.server.quorum.LearnerHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+/** Tests issue: CURATOR-444: Zookeeper node is isolated from other zookeepers but not from curator
+ *  temporally */
+
+
+public class TestLeaderLatchIsolatedZookeeper {
+
+	private static final Logger logger = LoggerFactory.getLogger(TestLeaderLatchIsolatedZookeeper.class);
+	private static final int CONNECTION_TIMEOUT_MS = 15000;
+	private static final int SESSION_TIMEOUT_MS = 10000;
+
+	private TestingCluster cluster;
+	private DummyLeaderLatch firstClient;
+	private DummyLeaderLatch secondClient;
+
+	@BeforeMethod
+	public void beforeMethod() throws Exception {
+		cluster = new TestingCluster(3);
+		cluster.start();
+		firstClient  = new DummyLeaderLatch(cluster.getConnectString(), SESSION_TIMEOUT_MS, CONNECTION_TIMEOUT_MS, ""First"");
+		secondClient = new DummyLeaderLatch(cluster.getConnectString(), SESSION_TIMEOUT_MS, CONNECTION_TIMEOUT_MS, ""Second"");
+		firstClient.startAndAwaitElection();
+		secondClient.startAndAwaitElection();
+		logger.info(""Session: "" + SESSION_TIMEOUT_MS + "" connection "" + CONNECTION_TIMEOUT_MS );
+	}
+
+	@AfterMethod
+	public void afterMethod() throws IOException {
+		firstClient.stop();
+		secondClient.stop();
+		cluster.close();
+		DummyLeaderLatch.resetHistory();
+	}
+
+	@Test
+	public void testThatStartsWithOnlyOneLeader() throws Exception {
+		assertNotEquals(firstClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToLatch());
+	}
+
+	@Test
+	public void testThatStartCoherent() throws Exception {
+		assertEquals(firstClient.isLeaderAccordingToLatch(),  firstClient.isLeaderAccordingToEvents());
+		assertEquals(secondClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToEvents());
+	}
+
+	@Test(invocationCount = 10)
+	public void testThatResistsNetworkGlitches() throws Exception {
+
+		blockLeaderListeningForSomeTime(SESSION_TIMEOUT_MS);
+
+		Thread.sleep(SESSION_TIMEOUT_MS * 3);
+
+		assertTrue(isHistoryValid(), ""History is not valid: "" + DummyLeaderLatch.getEventHistory());
+
+		assertEquals(   firstClient.isLeaderAccordingToLatch(),  firstClient.isLeaderAccordingToEvents());
+		assertEquals(  secondClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToEvents());
+		assertNotEquals(firstClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToLatch());
+	}
+
+	private void blockLeaderListeningForSomeTime(long milliseconds) throws InterruptedException {
+		for(TestingZooKeeperServer server : cluster.getServers()) {
+
+			if (server.getQuorumPeer().leader != null) {
+				Leader leader = server.getQuorumPeer().leader;
+
+				for (LearnerHandler learnerHandler : leader.getLearners()) {
+
+					logger.info(""Locking "" + learnerHandler.getName());
+					HandlerLocker locker = new HandlerLocker(learnerHandler, milliseconds);
+					locker.start();
+				}
+			}
+		}
+	}
+
+	private static class HandlerLocker extends Thread{
+
+		private final long milliseconds;
+		private final LearnerHandler learnerHandler;
+
+		public HandlerLocker(LearnerHandler learnerHandler, long milliseconds){
+			this.learnerHandler = learnerHandler;
+			this.milliseconds = milliseconds;
+		}
+
+		@Override
+		public void run() {
+			//suspendThread();
+			//closeSocket();
+			//lockSocket();
+			forceTimeout();
+		}
+
+		private void forceTimeout(){
+			try{
+				Socket socket = learnerHandler.getSocket();
+				int oldTimeout = learnerHandler.getSocket().getSoTimeout();
+				socket.setSoTimeout(1);
+				Thread.sleep(SESSION_TIMEOUT_MS);
+				socket.setSoTimeout(oldTimeout);
+
+			}catch (SocketException ex){
+				logger.error(""Error forcing timeout"", ex);
+			} catch (InterruptedException ex) {
+				logger.error(""Interrupted while forcing timeout"", ex);
+			}
+		}
+
+
+		private void lockSocket(){
+			try{
+				logger.info(""["" + System.currentTimeMillis() + ""] locking socket for learner handler "" + learnerHandler.getName() + "" for "" + milliseconds);
+
+				Socket socket = learnerHandler.getSocket();
+				synchronized (socket){
+					learnerHandler.getSocket().wait(milliseconds);
+				}
+				logger.info(""["" + System.currentTimeMillis() + ""] freeing socket for learner handler "" + learnerHandler.getName() + "" after "" + milliseconds);
+
+			}catch (InterruptedException ex){
+				String message = ""Failed to lock socket for "" + milliseconds + "" ms"";
+				logger.error(message);
+				Thread.currentThread().interrupt();
+				throw new RuntimeException(message, ex);
+			}
+		}
+
+		private void suspendThread(){","[{'comment': 'Method is not used?', 'commenter': 'cammckenzie'}]"
243,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatchIsolatedZookeeper.java,"@@ -0,0 +1,224 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.leader;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotEquals;
+import static org.testng.Assert.assertTrue;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.net.SocketException;
+
+import org.apache.curator.framework.recipes.leader.testing.DummyLeaderLatch;
+import org.apache.curator.test.TestingCluster;
+import org.apache.curator.test.TestingZooKeeperServer;
+import org.apache.zookeeper.server.quorum.Leader;
+import org.apache.zookeeper.server.quorum.LearnerHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+/** Tests issue: CURATOR-444: Zookeeper node is isolated from other zookeepers but not from curator
+ *  temporally */
+
+
+public class TestLeaderLatchIsolatedZookeeper {
+
+	private static final Logger logger = LoggerFactory.getLogger(TestLeaderLatchIsolatedZookeeper.class);
+	private static final int CONNECTION_TIMEOUT_MS = 15000;
+	private static final int SESSION_TIMEOUT_MS = 10000;
+
+	private TestingCluster cluster;
+	private DummyLeaderLatch firstClient;
+	private DummyLeaderLatch secondClient;
+
+	@BeforeMethod
+	public void beforeMethod() throws Exception {
+		cluster = new TestingCluster(3);
+		cluster.start();
+		firstClient  = new DummyLeaderLatch(cluster.getConnectString(), SESSION_TIMEOUT_MS, CONNECTION_TIMEOUT_MS, ""First"");
+		secondClient = new DummyLeaderLatch(cluster.getConnectString(), SESSION_TIMEOUT_MS, CONNECTION_TIMEOUT_MS, ""Second"");
+		firstClient.startAndAwaitElection();
+		secondClient.startAndAwaitElection();
+		logger.info(""Session: "" + SESSION_TIMEOUT_MS + "" connection "" + CONNECTION_TIMEOUT_MS );
+	}
+
+	@AfterMethod
+	public void afterMethod() throws IOException {
+		firstClient.stop();
+		secondClient.stop();
+		cluster.close();
+		DummyLeaderLatch.resetHistory();
+	}
+
+	@Test
+	public void testThatStartsWithOnlyOneLeader() throws Exception {
+		assertNotEquals(firstClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToLatch());
+	}
+
+	@Test
+	public void testThatStartCoherent() throws Exception {
+		assertEquals(firstClient.isLeaderAccordingToLatch(),  firstClient.isLeaderAccordingToEvents());
+		assertEquals(secondClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToEvents());
+	}
+
+	@Test(invocationCount = 10)
+	public void testThatResistsNetworkGlitches() throws Exception {
+
+		blockLeaderListeningForSomeTime(SESSION_TIMEOUT_MS);
+
+		Thread.sleep(SESSION_TIMEOUT_MS * 3);
+
+		assertTrue(isHistoryValid(), ""History is not valid: "" + DummyLeaderLatch.getEventHistory());
+
+		assertEquals(   firstClient.isLeaderAccordingToLatch(),  firstClient.isLeaderAccordingToEvents());
+		assertEquals(  secondClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToEvents());
+		assertNotEquals(firstClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToLatch());
+	}
+
+	private void blockLeaderListeningForSomeTime(long milliseconds) throws InterruptedException {
+		for(TestingZooKeeperServer server : cluster.getServers()) {
+
+			if (server.getQuorumPeer().leader != null) {
+				Leader leader = server.getQuorumPeer().leader;
+
+				for (LearnerHandler learnerHandler : leader.getLearners()) {
+
+					logger.info(""Locking "" + learnerHandler.getName());
+					HandlerLocker locker = new HandlerLocker(learnerHandler, milliseconds);
+					locker.start();
+				}
+			}
+		}
+	}
+
+	private static class HandlerLocker extends Thread{
+
+		private final long milliseconds;
+		private final LearnerHandler learnerHandler;
+
+		public HandlerLocker(LearnerHandler learnerHandler, long milliseconds){
+			this.learnerHandler = learnerHandler;
+			this.milliseconds = milliseconds;
+		}
+
+		@Override
+		public void run() {
+			//suspendThread();
+			//closeSocket();
+			//lockSocket();
+			forceTimeout();
+		}
+
+		private void forceTimeout(){
+			try{
+				Socket socket = learnerHandler.getSocket();
+				int oldTimeout = learnerHandler.getSocket().getSoTimeout();
+				socket.setSoTimeout(1);
+				Thread.sleep(SESSION_TIMEOUT_MS);
+				socket.setSoTimeout(oldTimeout);
+
+			}catch (SocketException ex){
+				logger.error(""Error forcing timeout"", ex);
+			} catch (InterruptedException ex) {
+				logger.error(""Interrupted while forcing timeout"", ex);
+			}
+		}
+
+
+		private void lockSocket(){
+			try{
+				logger.info(""["" + System.currentTimeMillis() + ""] locking socket for learner handler "" + learnerHandler.getName() + "" for "" + milliseconds);
+
+				Socket socket = learnerHandler.getSocket();
+				synchronized (socket){
+					learnerHandler.getSocket().wait(milliseconds);
+				}
+				logger.info(""["" + System.currentTimeMillis() + ""] freeing socket for learner handler "" + learnerHandler.getName() + "" after "" + milliseconds);
+
+			}catch (InterruptedException ex){
+				String message = ""Failed to lock socket for "" + milliseconds + "" ms"";
+				logger.error(message);
+				Thread.currentThread().interrupt();
+				throw new RuntimeException(message, ex);
+			}
+		}
+
+		private void suspendThread(){
+			try{
+				logger.info(""["" + System.currentTimeMillis() + ""] Suspending learner handler "" + learnerHandler.getName() + "" for "" + milliseconds);
+
+				learnerHandler.suspend();
+				Thread.sleep(milliseconds);
+				learnerHandler.resume();
+
+				logger.info(""["" + System.currentTimeMillis() + ""] Resume learner handler "" + learnerHandler.getName() + "" after "" + milliseconds);
+
+
+			}catch (InterruptedException ex){
+
+				String message = ""Failed to wait "" + milliseconds + "" ms"";
+				logger.error(message);
+				Thread.currentThread().interrupt();
+				throw new RuntimeException(message, ex);
+			}
+
+		}
+
+		private void closeSocket(){","[{'comment': 'Method is not used?', 'commenter': 'cammckenzie'}]"
243,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/testing/DummyLeaderLatch.java,"@@ -0,0 +1,189 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.leader.testing;
+
+import static org.apache.curator.framework.recipes.leader.LeaderLatch.CloseMode.NOTIFY_LEADER;
+
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.xml.ws.Holder;","[{'comment': 'Unused import?', 'commenter': 'cammckenzie'}]"
243,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/testing/DummyLeaderLatch.java,"@@ -0,0 +1,189 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.leader.testing;
+
+import static org.apache.curator.framework.recipes.leader.LeaderLatch.CloseMode.NOTIFY_LEADER;
+
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.xml.ws.Holder;
+
+import org.apache.curator.RetryPolicy;
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.CuratorFrameworkFactory;
+import org.apache.curator.framework.recipes.leader.LeaderLatch;
+import org.apache.curator.framework.recipes.leader.LeaderLatchListener;
+import org.apache.curator.framework.recipes.leader.Participant;
+import org.apache.curator.retry.ExponentialBackoffRetry;
+import org.apache.curator.test.Timing;","[{'comment': 'Unused import?', 'commenter': 'cammckenzie'}]"
243,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatchIsolatedZookeeper.java,"@@ -0,0 +1,224 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.leader;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotEquals;
+import static org.testng.Assert.assertTrue;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.net.SocketException;
+
+import org.apache.curator.framework.recipes.leader.testing.DummyLeaderLatch;
+import org.apache.curator.test.TestingCluster;
+import org.apache.curator.test.TestingZooKeeperServer;
+import org.apache.zookeeper.server.quorum.Leader;
+import org.apache.zookeeper.server.quorum.LearnerHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+/** Tests issue: CURATOR-444: Zookeeper node is isolated from other zookeepers but not from curator
+ *  temporally */
+
+
+public class TestLeaderLatchIsolatedZookeeper {
+
+	private static final Logger logger = LoggerFactory.getLogger(TestLeaderLatchIsolatedZookeeper.class);
+	private static final int CONNECTION_TIMEOUT_MS = 15000;
+	private static final int SESSION_TIMEOUT_MS = 10000;
+
+	private TestingCluster cluster;
+	private DummyLeaderLatch firstClient;
+	private DummyLeaderLatch secondClient;
+
+	@BeforeMethod
+	public void beforeMethod() throws Exception {
+		cluster = new TestingCluster(3);
+		cluster.start();
+		firstClient  = new DummyLeaderLatch(cluster.getConnectString(), SESSION_TIMEOUT_MS, CONNECTION_TIMEOUT_MS, ""First"");
+		secondClient = new DummyLeaderLatch(cluster.getConnectString(), SESSION_TIMEOUT_MS, CONNECTION_TIMEOUT_MS, ""Second"");
+		firstClient.startAndAwaitElection();
+		secondClient.startAndAwaitElection();
+		logger.info(""Session: "" + SESSION_TIMEOUT_MS + "" connection "" + CONNECTION_TIMEOUT_MS );
+	}
+
+	@AfterMethod
+	public void afterMethod() throws IOException {
+		firstClient.stop();
+		secondClient.stop();
+		cluster.close();
+		DummyLeaderLatch.resetHistory();
+	}
+
+	@Test
+	public void testThatStartsWithOnlyOneLeader() throws Exception {
+		assertNotEquals(firstClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToLatch());
+	}
+
+	@Test
+	public void testThatStartCoherent() throws Exception {
+		assertEquals(firstClient.isLeaderAccordingToLatch(),  firstClient.isLeaderAccordingToEvents());
+		assertEquals(secondClient.isLeaderAccordingToLatch(), secondClient.isLeaderAccordingToEvents());
+	}
+
+	@Test(invocationCount = 10)
+	public void testThatResistsNetworkGlitches() throws Exception {","[{'comment': ""Is it possible to make the test more reliable? Running it 10 times at 30 seconds an invocation increases our regression run by 5 minutes, which isn't ideal."", 'commenter': 'cammckenzie'}]"
243,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/testing/DummyLeaderLatch.java,"@@ -0,0 +1,189 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.leader.testing;
+
+import static org.apache.curator.framework.recipes.leader.LeaderLatch.CloseMode.NOTIFY_LEADER;
+
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.xml.ws.Holder;
+
+import org.apache.curator.RetryPolicy;
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.CuratorFrameworkFactory;
+import org.apache.curator.framework.recipes.leader.LeaderLatch;
+import org.apache.curator.framework.recipes.leader.LeaderLatchListener;
+import org.apache.curator.framework.recipes.leader.Participant;
+import org.apache.curator.retry.ExponentialBackoffRetry;
+import org.apache.curator.test.Timing;
+import org.apache.zookeeper.KeeperException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class DummyLeaderLatch implements LeaderLatchListener{
+
+	public static class History{
+		private String id;
+		private boolean leader;
+
+		private History(String id, boolean leader){
+			this.id = id;
+			this.leader = leader;
+		}
+
+		public String getId(){
+			return id;
+		}
+
+		public boolean isLeader(){
+			return leader;
+		}
+
+		@Override
+		public String toString(){
+			return id + "": "" + (leader ? ""toLeader"" : ""notLeader"");
+		}
+	}
+
+	private static final RetryPolicy 	RETRY_POLICY = new ExponentialBackoffRetry(100, 3);
+	private static final String 	   	LATCH_PATH   = ""/leader/dummy/leaderLatch"";
+	private static final Logger 	  	LOGGER 		 = LoggerFactory.getLogger(DummyLeaderLatch.class);
+	private static LinkedList<History> history = new LinkedList<>();
+
+
+	private final LeaderLatch leaderLatch;
+	private final CuratorFramework curatorFramework;
+	private final AtomicBoolean leader = new AtomicBoolean(false);
+
+	public DummyLeaderLatch(final String connectionString,
+							final int sessionTimeoutMs,
+							final int connectionTimeoutMs,
+							final String instanceId){
+
+		curatorFramework = CuratorFrameworkFactory.builder()
+				.retryPolicy(RETRY_POLICY)
+				.connectString(connectionString)
+				.sessionTimeoutMs(sessionTimeoutMs)
+				.connectionTimeoutMs(connectionTimeoutMs)
+				.build();
+		leaderLatch = new LeaderLatch(curatorFramework, LATCH_PATH, instanceId, NOTIFY_LEADER);
+		leaderLatch.addListener(this);
+	}
+
+	public void start() throws Exception {
+		curatorFramework.start();
+		curatorFramework.blockUntilConnected();
+		createPath(LATCH_PATH);
+		leaderLatch.start();
+	}
+
+	/**
+	 * Starts the service and waits until the latch already has a leader that may be a different node.
+	 */
+	public void startAndAwaitElection() throws Exception {
+		start();
+		existsLeader();
+	}
+
+	public void awaitElection() throws Exception {
+		while (!existsLeader()) {
+			Thread.sleep(100L);
+		}
+	}
+
+	public void awaitLeadershipLost() throws Exception {
+		while (existsLeader()) {
+			Thread.sleep(100L);
+		}
+	}
+
+	private boolean existsLeader() throws Exception {
+		for (Participant participant : leaderLatch.getParticipants()) {
+			if (participant.isLeader()) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+
+	public void stop() throws IOException {
+		leaderLatch.close();
+		curatorFramework.close();
+	}
+
+	@Override
+	public void isLeader() {
+		synchronized (this){
+			leader.set(true);
+			history.add( new History(leaderLatch.getId(), true));
+		}
+	}
+
+	@Override
+	public void notLeader() {
+		synchronized (this){
+			leader.set(false);
+			history.add( new History(leaderLatch.getId(), false));
+		}
+	}
+
+	public boolean isLeaderAccordingToEvents(){
+		return leader.get();
+	}
+
+	public boolean isLeaderAccordingToLatch(){
+		return leaderLatch.hasLeadership();
+	}
+
+	public static List<History> getEventHistory(){
+		return history;
+	}
+
+	public static void resetHistory(){
+		history = new LinkedList<>();
+	}
+
+	/**
+	 * Synchronously creates all nodes in a path in ZooKeeper if they don't exist.
+	 * <p>
+	 * All API calls provided by Curator for path creation with parents do async
+	 *
+	 * @param path the path
+	 */
+	private void createPath(final String path) throws Exception {
+		final String[] split = path.split(""/"");","[{'comment': ""why don't you use `create().creatingParentsIfNeeded()`?"", 'commenter': 'Randgalt'}]"
243,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/testing/DummyLeaderLatch.java,"@@ -0,0 +1,189 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.leader.testing;
+
+import static org.apache.curator.framework.recipes.leader.LeaderLatch.CloseMode.NOTIFY_LEADER;
+
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.xml.ws.Holder;
+
+import org.apache.curator.RetryPolicy;
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.CuratorFrameworkFactory;
+import org.apache.curator.framework.recipes.leader.LeaderLatch;
+import org.apache.curator.framework.recipes.leader.LeaderLatchListener;
+import org.apache.curator.framework.recipes.leader.Participant;
+import org.apache.curator.retry.ExponentialBackoffRetry;
+import org.apache.curator.test.Timing;
+import org.apache.zookeeper.KeeperException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class DummyLeaderLatch implements LeaderLatchListener{
+
+	public static class History{
+		private String id;
+		private boolean leader;
+
+		private History(String id, boolean leader){
+			this.id = id;
+			this.leader = leader;
+		}
+
+		public String getId(){
+			return id;
+		}
+
+		public boolean isLeader(){
+			return leader;
+		}
+
+		@Override
+		public String toString(){
+			return id + "": "" + (leader ? ""toLeader"" : ""notLeader"");
+		}
+	}
+
+	private static final RetryPolicy 	RETRY_POLICY = new ExponentialBackoffRetry(100, 3);
+	private static final String 	   	LATCH_PATH   = ""/leader/dummy/leaderLatch"";
+	private static final Logger 	  	LOGGER 		 = LoggerFactory.getLogger(DummyLeaderLatch.class);
+	private static LinkedList<History> history = new LinkedList<>();
+
+
+	private final LeaderLatch leaderLatch;
+	private final CuratorFramework curatorFramework;
+	private final AtomicBoolean leader = new AtomicBoolean(false);
+
+	public DummyLeaderLatch(final String connectionString,
+							final int sessionTimeoutMs,
+							final int connectionTimeoutMs,
+							final String instanceId){
+
+		curatorFramework = CuratorFrameworkFactory.builder()
+				.retryPolicy(RETRY_POLICY)
+				.connectString(connectionString)
+				.sessionTimeoutMs(sessionTimeoutMs)
+				.connectionTimeoutMs(connectionTimeoutMs)
+				.build();
+		leaderLatch = new LeaderLatch(curatorFramework, LATCH_PATH, instanceId, NOTIFY_LEADER);
+		leaderLatch.addListener(this);
+	}
+
+	public void start() throws Exception {
+		curatorFramework.start();
+		curatorFramework.blockUntilConnected();
+		createPath(LATCH_PATH);","[{'comment': ""The leader latch code will create the path for you - there's no need for this."", 'commenter': 'Randgalt'}]"
256,curator-x-discovery/src/test/java/org/apache/curator/x/discovery/details/DiscoveryPathConstructorImplTest.java,"@@ -0,0 +1,59 @@
+package org.apache.curator.x.discovery.details;
+
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+public class DiscoveryPathConstructorImplTest
+{
+
+    @Test
+    public void testCanonicalDiscoveryPathConstructor()
+    {
+        Assert.expectThrows(IllegalArgumentException.class, new Assert.ThrowingRunnable()
+            {
+                @Override
+                public void run() throws Throwable {
+                    new DiscoveryPathConstructorImpl(null);
+                }
+            }
+        );
+    }
+
+    @Test
+    public void testGetBasePath() throws Exception
+    {
+        Assert.assertEquals(new DiscoveryPathConstructorImpl(""/foo/bar"").getBasePath(), ""/foo/bar"");
+        Assert.assertEquals(new DiscoveryPathConstructorImpl(""foo/bar"").getBasePath(), ""/foo/bar"");","[{'comment': 'I worried if we should forbid this pattern, said the base dir passed without a leading slash, instead of tolerate it.\r\n\r\nIt seems somehow informal especially for `foo/bar/` patterns.', 'commenter': 'tisonkun'}]"
256,curator-x-discovery/src/main/java/org/apache/curator/x/discovery/DiscoveryPathConstructor.java,"@@ -0,0 +1,49 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.curator.x.discovery;
+
+/**
+ * Constructs ZooKeeper paths to services for service discovering.
+ */
+public interface DiscoveryPathConstructor {
+    /**
+     * Return the path where all service names registered.
+     *
+     * @return the base path of all services
+     */
+    String getBasePath();
+
+    /**
+     * Return the path where all instances of the service registered.
+     *
+     * @param serviceName service name
+     * @return  path to service instances
+     */
+    String getPathForInstances(String serviceName);
+
+    /**
+     * Return the path where specified instance registered.
+     *
+     * @param serviceName service name
+     * @param instanceId instance id
+     * @return path to concrete instance
+     */
+    String getPathForInstance(String serviceName, String instanceId);","[{'comment': 'Do we need this ? From javadocs, I concludes to ""/base-path/{serviceName}/instance-dir/{instanceId}"". Seems that `getPathForInstances` will give us directory for `instanceId` and `ServiceDiscoveryImpl::queryForInstances` depends on this. We need service directory and instance directory, that is all ?', 'commenter': 'kezhuw'}, {'comment': '> From javadocs, I concludes to ""/base-path/{serviceName}/instance-dir/{instanceId}""\r\n\r\nNo. This is an extension point that users can customize arbitrarily. The discussion happened on the JIRA ticket. You can check it out - https://issues.apache.org/jira/browse/CURATOR-457\r\n\r\nAnd I\'m OK to postpone this ticket unless anyone shows a real-world use case.', 'commenter': 'tisonkun'}, {'comment': ""Given what the javadoc says:\r\n1. `getPathForInstances`: Return the path where all instances of the service registered.\r\n2. `getPathForInstance`: Return the path where specified instance registered.\r\n\r\nThe second can't be an extension point to return arbitrary path. Otherwise, it violates the first.\r\n\r\nAlso, I don't think this `getPathForInstance` will work. Assumes:\r\n\r\n* `getBasePath()` returns `/base-path`.\r\n* `getPathForInstances(serviceName)` returns `/base-path/{serviceName}/instances/`.\r\n\r\nIs it possible for `getPathForInstance(serviceName, instanceId)` to return paths other than `/base-path/{serviceName}/instances/{instanceId}` ? If it is possible, how should `Collection<ServiceInstance<T>> queryForInstances(String name)` be implemented ? I expect the current implementation will break.\r\n\r\nI think `getPathForInstance(serviceName, instanceId)` should behave same as `ZKPaths.makePath(getPathForInstances(serviceName), instanceId)` for this customization to function correctly. \r\n\r\n> And I'm OK to postpone this ticket unless anyone shows a real-world use case.\r\n\r\nThe jira already presented a good use case from my perspective. I can continue the rest if above make sense to you and in case you are not available to push forward this. I don't think we should/can expect response from original author given his/her inactivity."", 'commenter': 'kezhuw'}, {'comment': ""I go through the original ticket an think that it's the implementor's responsibility to implement the method correctly.\r\n\r\nThe original ticket argues that the default `ZKPaths.makePath` cannot satisfy some cases. And `ServiceDiscoveryImpl` delegates the related methods to the new PathConstructor:\r\n\r\n```java\r\n    @Override\r\n    public Collection<String> queryForNames() throws Exception {\r\n        List<String> names = client.getChildren().forPath(pathConstructor.getBasePath());\r\n        return ImmutableList.copyOf(names);\r\n    }\r\n    String pathForName(String serviceName) {\r\n        return pathConstructor.getPathForInstances(serviceName);\r\n    }\r\n    @VisibleForTesting\r\n    String pathForInstance(String serviceName, String instanceId) {\r\n        return pathConstructor.getPathForInstance(serviceName, instanceId);\r\n    }\r\n```"", 'commenter': 'tisonkun'}, {'comment': '@kezhuw does my explanation resolve your comment? Or you still have some suggestions to add on this patch? Feel free to share the patch or open a pull request onto this one and we can discuss on the concrete changeset.', 'commenter': 'tisonkun'}, {'comment': '@tisonkun I will open a pull request for discussion.', 'commenter': 'kezhuw'}]"
297,curator-framework/src/main/java/org/apache/curator/framework/CuratorFramework.java,"@@ -331,4 +329,29 @@
      * @return true/false
      */
     boolean isZk34CompatibilityMode();
+
+    /**
+     * Calls {@link #notifyAll()} on the given object after first synchronizing on it. This is
+     * done from the {@link #runSafe(Runnable)} thread.
+     *
+     * @param monitorHolder object to sync on and notify
+     * @since 4.1.0
+     */
+    default void postSafeNotify(Object monitorHolder)","[{'comment': 'Thinking about the future...\r\nWould it be better to make it return a CompletableFuture?\r\nThis way the caller will have a chance to know when eventually the operation has been executed', 'commenter': 'eolivelli'}, {'comment': ""Good idea - I'll add that"", 'commenter': 'Randgalt'}]"
297,curator-framework/src/main/java/org/apache/curator/framework/CuratorFrameworkFactory.java,"@@ -474,6 +477,28 @@ public Builder schemaSet(SchemaSet schemaSet)
             return this;
         }
 
+        /**
+         * Curator (and user) recipes will use this executor to call notifyAll
+         * and other blocking calls that might normally block ZooKeeper's event thread.
+         * By default, an executor is allocated internally using the provided (or default)
+         * {@link #threadFactory(java.util.concurrent.ThreadFactory)}. Use this method
+         * to set a custom executor.
+         *
+         * @param runSafeService executor to use for calls to notifyAll from Watcher callbacks etc
+         * @return this
+         * @since 4.1.0
+         */
+        public Builder runSafeService(Executor runSafeService)
+        {
+            this.runSafeService = runSafeService;
+            return null;","[{'comment': 'This should return this rather than null', 'commenter': 'cammckenzie'}, {'comment': 'damn - good catch', 'commenter': 'Randgalt'}]"
300,curator-client/src/test/java/org/apache/curator/utils/TestZKPaths.java,"@@ -26,6 +26,18 @@
 
 public class TestZKPaths
 {
+    @Test","[{'comment': ""I'm +1 on this change but do you mind writing more tests in `TestZKPaths`? I'd like to see more complete coverage of the new methods."", 'commenter': 'Randgalt'}, {'comment': '@marquiswang any chance for more tests? ', 'commenter': 'Randgalt'}, {'comment': 'Sorry, I have been on an extended trip and have not had a chance to work on this. I can definitely add tests when I get home in mid March.', 'commenter': 'marquiswang'}, {'comment': 'ping @marquiswang do you have some spare time to bring back this patch? You can merge master and add tests :)', 'commenter': 'tisonkun'}, {'comment': 'Hello, blast from the past. I supppooooose I can look into it when I get a moment.', 'commenter': 'marquiswang'}, {'comment': '@marquiswang lol. Go ahead!', 'commenter': 'tisonkun'}]"
301,curator-x-discovery-server/pom.xml,"@@ -127,4 +127,41 @@
             </plugin>
         </plugins>
     </build>
+
+    <profiles>
+        <profile>
+            <id>jdk-9-plus</id>","[{'comment': ""I'm -1 on this change. I'd rather see a comprehensive Java 11 PR (we have a Jira for this already). Java 9 is not an LTS release."", 'commenter': 'Randgalt'}, {'comment': ""This profile is activated whenever the test runtime is Java 9+ (including Java 11). I could change this to Java 11+, so that Java 9 and 10 are not supported at all, but I don't see much sense in doing this. In fact, that would break the workflow for people who want to run some tests locally and for whatever reason they happen to have Java 9 or 10, but not Java 11 installed (that was my case)."", 'commenter': 'leventov'}]"
334,curator-framework/src/main/java/org/apache/curator/framework/api/AddWatchBuilder.java,"@@ -0,0 +1,32 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.api;
+
+import org.apache.zookeeper.AddWatchMode;
+
+public interface AddWatchBuilder extends AddWatchBuilder2","[{'comment': 'Why do we need AddWatchBuilder2 and AddWatchBuilder separated? Why not merge them into one interface? Did you want to clean AddWatchBuilder from the parent interfaces?', 'commenter': 'shayshim'}, {'comment': '`AddWatchBuilder` has the ""withMode"" method which is optional.', 'commenter': 'Randgalt'}, {'comment': ""OK, it is just a little hard for me with using the same name but with 2 as suffix, but I don't have a better name to offer :)"", 'commenter': 'shayshim'}]"
334,curator-x-async/src/main/java/org/apache/curator/x/async/api/AsyncCuratorFrameworkDsl.java,"@@ -112,4 +112,11 @@
      * @return builder object
      */
     AsyncRemoveWatchesBuilder removeWatches();
+
+    /**
+     * Start an add watch builder
+     *","[{'comment': 'Consider adding something like: supported only when ZooKeeper client of version 3.6 or above is used, throws IllegalStateException for ZooKeeper client 3.5 or below', 'commenter': 'shayshim'}]"
334,curator-framework/src/main/java/org/apache/curator/framework/imps/CuratorFrameworkImpl.java,"@@ -572,6 +572,13 @@ public RemoveWatchesBuilder watches()
         return new RemoveWatchesBuilderImpl(this);
     }
 
+    @Override
+    public WatchesBuilder watchers()
+    {
+        Preconditions.checkState(Compatibility.hasPersistentWatchers(), ""addWatch() is not supported in the ZooKeeper library being used. Use watches() instead."");","[{'comment': 'The exception message: ""addWatch()"" -> ""watchers()""', 'commenter': 'shayshim'}]"
334,curator-x-async/src/main/java/org/apache/curator/x/async/api/AsyncCuratorFrameworkDsl.java,"@@ -112,4 +112,11 @@
      * @return builder object
      */
     AsyncRemoveWatchesBuilder removeWatches();
+
+    /**
+     * Start an add watch builder
+     *
+     * @return builder object
+     */
+    AsyncWatchBuilder addWatch();","[{'comment': ""Shouldn't addWatch() be named watchers(), line in CuratorFramwork, to be consistent with the naming?"", 'commenter': 'shayshim'}, {'comment': 'No, the DSL verbs are different in for async and sync', 'commenter': 'Randgalt'}]"
334,curator-framework/src/test/java/org/apache/curator/framework/imps/TestWatchesBuilder.java,"@@ -611,6 +614,56 @@ public void pathAddedForGuaranteedOperation(
         }
     }
 
+    @Test(groups = CuratorTestBase.zk36Group)
+    public void testPersistentRecursiveWatch() throws Exception
+    {
+        try ( CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1)) )
+        {
+            client.start();
+            client.blockUntilConnected();
+
+            CountDownLatch latch = new CountDownLatch(5);
+            Watcher watcher = event -> latch.countDown();
+            client.watchers().add().withMode(AddWatchMode.PERSISTENT_RECURSIVE).usingWatcher(watcher).forPath(""/test"");
+
+            client.create().forPath(""/test"");","[{'comment': 'Not interesting to test here also other recursive events like data changes and remove nodes?\r\nAlso, might be good to create and modify recursively ""/not-the-test"" and make sure nothing comes from there.\r\nAnd remove watcher tests shouldn\'t be repeated for persistent/recursive too?', 'commenter': 'shayshim'}, {'comment': ""I was thinking it isn't necessary to test functionality that's already tested in ZK itself. But, this is a good point. I'll add some more tests."", 'commenter': 'Randgalt'}]"
334,curator-x-async/src/main/java/org/apache/curator/x/async/details/AsyncCuratorFrameworkImpl.java,"@@ -151,6 +153,13 @@ public AsyncRemoveWatchesBuilder removeWatches()
         return new AsyncRemoveWatchesBuilderImpl(client, filters);
     }
 
+    @Override
+    public AsyncWatchBuilder addWatch()
+    {
+        Preconditions.checkState(Compatibility.hasPersistentWatchers(), ""addWatch() is not supported in the ZooKeeper library being used."");","[{'comment': 'I would throw UnsupportedOperationException', 'commenter': 'eolivelli'}, {'comment': ""it's always been this way - I'd rather leave it for historical reasons"", 'commenter': 'Randgalt'}]"
334,curator-framework/src/test/java/org/apache/curator/framework/imps/TestWatchesBuilder.java,"@@ -610,6 +613,122 @@ public void pathAddedForGuaranteedOperation(
         }
     }
 
+    @Test(groups = CuratorTestBase.zk36Group)
+    public void testPersistentWatch() throws Exception
+    {
+        try ( CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1)) )
+        {
+            client.start();
+            client.blockUntilConnected();
+
+            CountDownLatch latch = new CountDownLatch(3);
+            Watcher watcher = event -> latch.countDown();
+            client.watchers().add().withMode(AddWatchMode.PERSISTENT).usingWatcher(watcher).forPath(""/test/foo"");
+
+            client.create().creatingParentsIfNeeded().forPath(""/test/foo"");
+            client.setData().forPath(""/test/foo"", ""hey"".getBytes());
+            client.delete().forPath(""/test/foo"");
+
+            Assert.assertTrue(timing.awaitLatch(latch));
+        }
+    }
+
+    @Test(groups = CuratorTestBase.zk36Group)
+    public void testPersistentWatchInBackground() throws Exception
+    {
+        try ( CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1)) )
+        {
+            client.start();
+            client.blockUntilConnected();
+
+            CountDownLatch backgroundLatch = new CountDownLatch(1);","[{'comment': ""What's the purpose of the backgroundLatch? It doesn't seem to actually get used (beyond being counted down)."", 'commenter': 'cammckenzie'}]"
334,curator-framework/src/test/java/org/apache/curator/framework/imps/TestWatchesBuilder.java,"@@ -610,6 +613,122 @@ public void pathAddedForGuaranteedOperation(
         }
     }
 
+    @Test(groups = CuratorTestBase.zk36Group)
+    public void testPersistentWatch() throws Exception
+    {
+        try ( CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1)) )
+        {
+            client.start();
+            client.blockUntilConnected();
+
+            CountDownLatch latch = new CountDownLatch(3);
+            Watcher watcher = event -> latch.countDown();
+            client.watchers().add().withMode(AddWatchMode.PERSISTENT).usingWatcher(watcher).forPath(""/test/foo"");
+
+            client.create().creatingParentsIfNeeded().forPath(""/test/foo"");
+            client.setData().forPath(""/test/foo"", ""hey"".getBytes());
+            client.delete().forPath(""/test/foo"");
+
+            Assert.assertTrue(timing.awaitLatch(latch));
+        }
+    }
+
+    @Test(groups = CuratorTestBase.zk36Group)
+    public void testPersistentWatchInBackground() throws Exception
+    {
+        try ( CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1)) )
+        {
+            client.start();
+            client.blockUntilConnected();
+
+            CountDownLatch backgroundLatch = new CountDownLatch(1);
+            BackgroundCallback backgroundCallback = (__, ___) -> backgroundLatch.countDown();
+            CountDownLatch latch = new CountDownLatch(3);
+            Watcher watcher = event -> latch.countDown();
+            client.watchers().add().withMode(AddWatchMode.PERSISTENT).inBackground(backgroundCallback).usingWatcher(watcher).forPath(""/test/foo"");
+
+            client.create().creatingParentsIfNeeded().forPath(""/test/foo"");
+            client.setData().forPath(""/test/foo"", ""hey"".getBytes());
+            client.delete().forPath(""/test/foo"");
+
+            Assert.assertTrue(timing.awaitLatch(latch));
+        }
+    }
+
+    @Test(groups = CuratorTestBase.zk36Group)
+    public void testPersistentRecursiveWatch() throws Exception
+    {
+        try ( CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1)) )
+        {
+            client.start();
+            client.blockUntilConnected();
+
+            CountDownLatch latch = new CountDownLatch(5);
+            Watcher watcher = event -> latch.countDown();
+            client.watchers().add().withMode(AddWatchMode.PERSISTENT_RECURSIVE).usingWatcher(watcher).forPath(""/test"");
+
+            client.create().forPath(""/test"");
+            client.create().forPath(""/test/a"");
+            client.create().forPath(""/test/a/b"");
+            client.create().forPath(""/test/a/b/c"");
+            client.create().forPath(""/test/a/b/c/d"");
+
+            Assert.assertTrue(timing.awaitLatch(latch));
+        }
+    }
+
+    @Test(groups = CuratorTestBase.zk36Group)
+    public void testPersistentRecursiveWatchInBackground() throws Exception
+    {
+        try ( CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1)) )
+        {
+            client.start();
+            client.blockUntilConnected();
+
+            CountDownLatch backgroundLatch = new CountDownLatch(1);","[{'comment': 'As for previous backgroundLatch comment', 'commenter': 'cammckenzie'}, {'comment': 'Good catch on both', 'commenter': 'Randgalt'}]"
334,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderSelectorEdges.java,"@@ -26,6 +26,7 @@
 import org.apache.curator.framework.state.ConnectionState;
 import org.apache.curator.retry.RetryNTimes;
 import org.apache.curator.test.BaseClassForTests;
+import org.apache.curator.test.compatibility.CuratorTestBase;","[{'comment': 'Unused import', 'commenter': 'tisonkun'}]"
335,curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/CuratorCache.java,"@@ -0,0 +1,133 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.curator.framework.recipes.cache;
+
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.listen.Listenable;
+import java.io.Closeable;
+import java.util.Optional;
+import java.util.stream.Stream;
+
+/**
+ * <p>
+ *     A utility that attempts to keep the data from a node locally cached. Optionally the entire
+ *     tree of children below the node can also be cached. Will respond to update/create/delete events, pull
+ *     down the data, etc. You can register listeners that will get notified when changes occur.
+ * </p>
+ *
+ * <p>
+ *     <b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must
+ *     be prepared for false-positives and false-negatives. Additionally, always use the version number
+ *     when updating data to avoid overwriting another process' change.
+ * </p>
+ */
+public interface CuratorCache extends Closeable, CuratorCacheAccessor
+{
+    /**
+     * cache build options
+     */
+    enum Options
+    {
+        /**
+         * Normally the entire tree of nodes starting at the given node are cached. This option
+         * causes only the given node to be cached (i.e. a single node cache)
+         */
+        SINGLE_NODE_CACHE,
+
+        /**
+         * Decompress data via {@link org.apache.curator.framework.api.GetDataBuilder#decompressed()}
+         */
+        COMPRESSED_DATA,
+
+        /**
+         * Normally, when the cache is closed via {@link CuratorCache#close()}, the storage is cleared
+         * via {@link CuratorCacheStorage#clear()}. This option prevents the storage from being cleared.
+         */
+        DO_NOT_CLEAR_ON_CLOSE
+    }
+
+    /**
+     * Return a Curator Cache for the given path with the given options using a standard storage instance
+     *
+     * @param client Curator client
+     * @param path path to cache
+     * @param options any options
+     * @return cache (note it must be started via {@link #start()}
+     */
+    static CuratorCache build(CuratorFramework client, String path, Options... options)
+    {
+        return builder(client, path).withOptions(options).build();
+    }
+
+    /**
+     * Start a Curator Cache builder
+     *
+     * @param client Curator client
+     * @param path path to cache
+     * @return builder
+     */
+    static CuratorCacheBuilder builder(CuratorFramework client, String path)
+    {
+        return new CuratorCacheBuilderImpl(client, path);
+    }
+
+    /**
+     * Start the cache. This will cause a complete refresh from the cache's root node and generate
+     * events for all nodes found, etc.
+     */
+    void start();
+
+    /**
+     * Close the cache, stop responding to events, etc.
+     */
+    @Override
+    void close();
+
+    /**
+     * Return the listener container so that listeners can be registered to be notified of changes to the cache
+     *
+     * @return listener container
+     */
+    Listenable<CuratorCacheListener> listenable();
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    Optional<ChildData> get(String path);
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    int size();
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    Stream<ChildData> stream();
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    Stream<ChildData> streamImmediateChildren(String fromParent);","[{'comment': 'Is this method for compatibility of `PathChildrenCache#getCurrentData`? If so, shall we mention it?', 'commenter': 'tisonkun'}, {'comment': ""I'm not happy with this API. I'm going to change it. Please refer to the next commit."", 'commenter': 'Randgalt'}]"
335,curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/CuratorCacheBuilder.java,"@@ -0,0 +1,68 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.curator.framework.recipes.cache;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+public interface CuratorCacheBuilder
+{
+    /**
+     * @param options any options
+     * @return this
+     */
+    CuratorCacheBuilder withOptions(CuratorCache.Options... options);
+
+    /**
+     * Alternate storage to use. If not specified, {@link StandardCuratorCacheStorage#standard()} is used
+     *
+     * @param storage storage instance to use
+     * @return this
+     */
+    CuratorCacheBuilder withStorage(CuratorCacheStorage storage);
+
+    /**
+     * By default any unexpected exception is handled by logging the exception. You can change
+     * so that a handler is called instead. Under normal circumstances, this shouldn't be necessary.
+     *
+     * @param exceptionHandler exception handler to use
+     */
+    CuratorCacheBuilder withExceptionHandler(Consumer<Exception> exceptionHandler);
+
+    /**
+     * Low-level replacement for runSafe. Listeners are notified by calling
+     * {@code runSafe(() -> listenerManager.forEach(...))}. This should work for nearly any
+     * case. However, you can provide a different handler instead so that runSafe is not
+     * used. The proc must behave similar to {@link org.apache.curator.framework.CuratorFramework#runSafe(Runnable)}.
+     * Under normal circumstances, this shouldn't be necessary.
+     *
+     * @param runSafeProc runSafe proc
+     * @return this
+     */
+    CuratorCacheBuilder withListenerRunProc(Function<Runnable, CompletableFuture<Void>> runSafeProc);","[{'comment': ""Shall we add a test or example for the use case? I don't see the motivation here in practice."", 'commenter': 'tisonkun'}]"
335,curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/CuratorCache.java,"@@ -0,0 +1,127 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.curator.framework.recipes.cache;
+
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.listen.Listenable;
+import java.io.Closeable;
+import java.util.Optional;
+import java.util.stream.Stream;
+
+/**
+ * <p>
+ *     A utility that attempts to keep the data from a node locally cached. Optionally the entire
+ *     tree of children below the node can also be cached. Will respond to update/create/delete events, pull
+ *     down the data, etc. You can register listeners that will get notified when changes occur.
+ * </p>
+ *
+ * <p>
+ *     <b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must","[{'comment': 'This comment was never very clear to me, and if it is not only me, maybe it is good opportunity to rephrase it or give more details. \r\nBy ""false positive"" here do you mean that we might get events that do not reflect anymore the latest state of the zknode? \r\nThese events are still true, just a bit late. Soon there should follow the subsequent events until latest state is reflected. This behavior is general in ZK clients, not just the cache.\r\nBy ""false negative"" do you mean that we can miss events because ZK only sends the latest event (e.g. while cache might have been disconnected for a while, missing some zknode events)? Again, I feel like it is true for any ZK client, not just the cache. Though in Persistent Watchers I guess we potentially miss less momentarily events, because the Watcher is always there.', 'commenter': 'shayshim'}]"
335,curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/CuratorCacheImpl.java,"@@ -0,0 +1,301 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.cache;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Sets;
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.api.BackgroundCallback;
+import org.apache.curator.framework.api.CuratorEvent;
+import org.apache.curator.framework.listen.Listenable;
+import org.apache.curator.framework.listen.StandardListenerManager;
+import org.apache.curator.framework.recipes.watch.PersistentWatcher;
+import org.apache.curator.utils.ThreadUtils;
+import org.apache.curator.utils.ZKPaths;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.data.Stat;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import static org.apache.curator.framework.recipes.cache.CuratorCacheListener.Type.*;
+import static org.apache.zookeeper.KeeperException.Code.NONODE;
+import static org.apache.zookeeper.KeeperException.Code.OK;
+
+class CuratorCacheImpl implements CuratorCache
+{
+    private final Logger log = LoggerFactory.getLogger(getClass());
+    private final AtomicReference<State> state = new AtomicReference<>(State.LATENT);
+    private final PersistentWatcher persistentWatcher;
+    private final CuratorFramework client;
+    private final CuratorCacheStorage storage;
+    private final String path;
+    private final boolean recursive;
+    private final boolean compressedData;
+    private final boolean clearOnClose;
+    private final StandardListenerManager<CuratorCacheListener> listenerManager = StandardListenerManager.standard();
+    private final Consumer<Exception> exceptionHandler;
+    private final OutstandingOps outstandingOps = new OutstandingOps(() -> callListeners(CuratorCacheListener::initialized));
+
+    private enum State
+    {
+        LATENT,
+        STARTED,
+        CLOSED
+    }
+
+    CuratorCacheImpl(CuratorFramework client, CuratorCacheStorage storage, String path, Options[] optionsArg, Consumer<Exception> exceptionHandler)
+    {
+        Set<Options> options = (optionsArg != null) ? Sets.newHashSet(optionsArg) : Collections.emptySet();
+        this.client = client;
+        this.storage = (storage != null) ? storage : CuratorCacheStorage.standard();
+        this.path = path;
+        recursive = !options.contains(Options.SINGLE_NODE_CACHE);
+        compressedData = options.contains(Options.COMPRESSED_DATA);
+        clearOnClose = !options.contains(Options.DO_NOT_CLEAR_ON_CLOSE);
+        persistentWatcher = new PersistentWatcher(client, path, recursive);
+        persistentWatcher.getListenable().addListener(this::processEvent);
+        persistentWatcher.getResetListenable().addListener(this::rebuild);
+        this.exceptionHandler = (exceptionHandler != null) ? exceptionHandler : e -> log.error(""CuratorCache error"", e);
+    }
+
+    @Override
+    public void start()
+    {
+        Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), ""Already started"");
+        persistentWatcher.start();
+    }
+
+    @Override
+    public void close()
+    {
+        if ( state.compareAndSet(State.STARTED, State.CLOSED) )","[{'comment': ""Minor corner, but calling `close()` on cache that wasn't started is a no-op. Intuitively to me it should remain `CLOSED` in this case. If you agree, you could instead use:\r\n`if (state.getAndSet(CLOSED) == STARTED) ...`"", 'commenter': 'shayshim'}, {'comment': ""This pattern is used throughout Curator. It's actually an error to call `close()` without first calling `start()`. Maybe it should be an exception. We can deal with all instances of this pattern in a separate issue."", 'commenter': 'Randgalt'}, {'comment': ""If that's the pattern everyone already used to, then I think it is better to leave it without change. It is minor consideration anyways, and always can be overridden with a boolean paired to the cache from the outside. "", 'commenter': 'shayshim'}]"
335,curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/OutstandingOps.java,"@@ -0,0 +1,60 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.cache;
+
+import java.util.concurrent.atomic.AtomicLong;
+
+class OutstandingOps
+{
+    private final Runnable completionProc;
+    private volatile AtomicLong count = new AtomicLong(0);","[{'comment': 'What not final?', 'commenter': 'eolivelli'}, {'comment': 'It gets set to null after `completionProc` is called to signal decrement/increment are no longer necessary.', 'commenter': 'Randgalt'}]"
335,curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/OutstandingOps.java,"@@ -0,0 +1,60 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.cache;
+
+import java.util.concurrent.atomic.AtomicLong;
+
+class OutstandingOps
+{
+    private final Runnable completionProc;
+    private volatile AtomicLong count = new AtomicLong(0);
+
+    OutstandingOps(Runnable completionProc)
+    {
+        this.completionProc = completionProc;
+    }
+
+    void increment()
+    {
+        AtomicLong localCount = count;
+        if ( localCount != null )
+        {
+            localCount.incrementAndGet();
+        }
+    }
+
+    void decrement()
+    {
+        AtomicLong localCount = count;
+        if ( localCount != null )
+        {
+            if ( (localCount.decrementAndGet() == 0) )
+            {
+                count = null;","[{'comment': 'I am not sure this trick works.\r\n\r\nYou can be here when another thread calls increment function.\r\nYou are not inside a lock', 'commenter': 'eolivelli'}, {'comment': 'Look at the next line `if ( localCount.compareAndSet(0, Long.MIN_VALUE) )` - that ensures consistency (please review and confirm).', 'commenter': 'Randgalt'}, {'comment': ""Hmm - I think there's a race here - I'm going to address."", 'commenter': 'Randgalt'}, {'comment': '@eolivelli I reworked it - please re-check', 'commenter': 'Randgalt'}]"
335,curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/OutstandingOps.java,"@@ -0,0 +1,55 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.cache;
+
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+
+class OutstandingOps","[{'comment': 'An alternative is that `java.util.concurrent.Phaser` which already implements semantic like `OutstandingOps`.\r\n\r\n```java\r\nRunnable r = () -> callListeners(CuratorCacheListener::initialized);\r\nPhaser p = new Phaser() {\r\n  @Override\r\n            protected boolean onAdvance(int phase, int registeredParties) {\r\n                r.run();\r\n                return true;\r\n            }\r\n}\r\n```\r\n\r\nand replace `increment` as `register` while `decrement` as `arriveAndDeregister`', 'commenter': 'tisonkun'}, {'comment': ""Ooh - TIL - I didn't know about that. Thanks. Looking into it now."", 'commenter': 'Randgalt'}, {'comment': 'Phaser looks to be a kind of barrier. How would it be used in this context @TisonKun ?', 'commenter': 'Randgalt'}, {'comment': 'It seems `OutstandingOps` is a one-shot barrier, so that as the code snippet above when we have new outstanding op we register a party and terminate the phaser at the first time it is advanced. Is it the semantic of `OutstandingOps`?', 'commenter': 'tisonkun'}, {'comment': 'It\'s the same idea as in TreeCache. When the cache is started each outstanding operation increments a counter and when the op completes it decrements the counter. It\'s not exact, but it provides a way to handle the ""cache is initialized"" feature. Once the outstanding ops counter gets back to 0 it\'s no longer used.', 'commenter': 'Randgalt'}, {'comment': 'Yes that is the same as things in my mind. Since `OutstandingOps` implemented correctly now, we can have a follow-up to see if it\'s worth we replace it with Java builtins and I will share a patch with description there. At most it is an ""improvement"" and should not block this PR to merge :)\r\n\r\nFor the ""how"", it seems to me that https://github.com/apache/curator/pull/335#discussion_r399591042 is clear.', 'commenter': 'tisonkun'}]"
335,curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/CuratorCacheImpl.java,"@@ -0,0 +1,301 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.cache;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Sets;
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.api.BackgroundCallback;
+import org.apache.curator.framework.api.CuratorEvent;
+import org.apache.curator.framework.listen.Listenable;
+import org.apache.curator.framework.listen.StandardListenerManager;
+import org.apache.curator.framework.recipes.watch.PersistentWatcher;
+import org.apache.curator.utils.ThreadUtils;
+import org.apache.curator.utils.ZKPaths;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.data.Stat;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import static org.apache.curator.framework.recipes.cache.CuratorCacheListener.Type.*;
+import static org.apache.zookeeper.KeeperException.Code.NONODE;
+import static org.apache.zookeeper.KeeperException.Code.OK;
+
+class CuratorCacheImpl implements CuratorCache
+{
+    private final Logger log = LoggerFactory.getLogger(getClass());
+    private final AtomicReference<State> state = new AtomicReference<>(State.LATENT);
+    private final PersistentWatcher persistentWatcher;
+    private final CuratorFramework client;
+    private final CuratorCacheStorage storage;
+    private final String path;
+    private final boolean recursive;
+    private final boolean compressedData;
+    private final boolean clearOnClose;
+    private final StandardListenerManager<CuratorCacheListener> listenerManager = StandardListenerManager.standard();
+    private final Consumer<Exception> exceptionHandler;
+    private final OutstandingOps outstandingOps = new OutstandingOps(() -> callListeners(CuratorCacheListener::initialized));
+
+    private enum State
+    {
+        LATENT,
+        STARTED,
+        CLOSED
+    }
+
+    CuratorCacheImpl(CuratorFramework client, CuratorCacheStorage storage, String path, Options[] optionsArg, Consumer<Exception> exceptionHandler)
+    {
+        Set<Options> options = (optionsArg != null) ? Sets.newHashSet(optionsArg) : Collections.emptySet();
+        this.client = client;
+        this.storage = (storage != null) ? storage : CuratorCacheStorage.standard();
+        this.path = path;
+        recursive = !options.contains(Options.SINGLE_NODE_CACHE);
+        compressedData = options.contains(Options.COMPRESSED_DATA);
+        clearOnClose = !options.contains(Options.DO_NOT_CLEAR_ON_CLOSE);
+        persistentWatcher = new PersistentWatcher(client, path, recursive);
+        persistentWatcher.getListenable().addListener(this::processEvent);
+        persistentWatcher.getResetListenable().addListener(this::rebuild);
+        this.exceptionHandler = (exceptionHandler != null) ? exceptionHandler : e -> log.error(""CuratorCache error"", e);
+    }
+
+    @Override
+    public void start()
+    {
+        Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), ""Already started"");
+        persistentWatcher.start();
+    }
+
+    @Override
+    public void close()
+    {
+        if ( state.compareAndSet(State.STARTED, State.CLOSED) )
+        {
+            persistentWatcher.close();
+            if ( clearOnClose )
+            {
+                storage.clear();
+            }
+        }
+    }
+
+    @Override
+    public Listenable<CuratorCacheListener> listenable()
+    {
+        return listenerManager;
+    }
+
+    @Override
+    public Optional<ChildData> get(String path)
+    {
+        return storage.get(path);
+    }
+
+    @Override
+    public int size()
+    {
+        return storage.size();
+    }
+
+    @Override
+    public Stream<ChildData> stream()
+    {
+        return storage.stream();
+    }
+
+    @VisibleForTesting
+    CuratorCacheStorage storage()
+    {
+        return storage;
+    }
+
+    private void rebuild()
+    {
+        if ( state.get() != State.STARTED )
+        {
+            return;
+        }
+
+        // rebuild from the root first
+        nodeChanged(path);","[{'comment': 'This call is going to also get all data of children recursively, and update the storage accordingly, so why do we need to pass the storage again as below?', 'commenter': 'shayshim'}, {'comment': ""Consider the case where the cache is in sync and then there is a network partition for a period of time. When the connection is restored, every node in the cache has to be re-considered as the new state of the server is not known. You can't just rebuild the cache from zero either as the client still needs to get events for changes. Neither can we just rebuild from the root node as checkChildrenChanged() stops if the cVersion is the same. E.g.\r\n\r\nPre network partition:\r\n\r\n```\r\nroot\r\n      Node A1\r\n            Node B1\r\n                Node C1\r\n      Node A2\r\n```\r\n\r\nPost network partition:\r\n\r\n```\r\nroot\r\n      Node A1\r\n            Node B1\r\n                Node C2       --- C1 deleted, C2 is new\r\n      Node A2\r\n```\r\n\r\nRebuilding only from the Root would not detect that C1 was deleted and C2 was added because the cVersion of A1 would be the same."", 'commenter': 'Randgalt'}]"
335,curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/CuratorCacheImpl.java,"@@ -0,0 +1,301 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.cache;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Sets;
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.api.BackgroundCallback;
+import org.apache.curator.framework.api.CuratorEvent;
+import org.apache.curator.framework.listen.Listenable;
+import org.apache.curator.framework.listen.StandardListenerManager;
+import org.apache.curator.framework.recipes.watch.PersistentWatcher;
+import org.apache.curator.utils.ThreadUtils;
+import org.apache.curator.utils.ZKPaths;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.data.Stat;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import static org.apache.curator.framework.recipes.cache.CuratorCacheListener.Type.*;
+import static org.apache.zookeeper.KeeperException.Code.NONODE;
+import static org.apache.zookeeper.KeeperException.Code.OK;
+
+class CuratorCacheImpl implements CuratorCache","[{'comment': ""This cache does not allow to maintain only the immediate children? I noticed `parentPathFilter`, but shouldn't we allow that for efficiancy? (for cases of many grandchildren and so deeper that their updates are not interesting in this cache context.) Maybe not useful enough to bother, just asking."", 'commenter': 'shayshim'}, {'comment': 'If someone really needs to emulate PathChildrenCache it could be done with a custom implementation of `CuratorCacheStorage`. I thought it added too much weight to have APIs that only cache 1 level. ', 'commenter': 'Randgalt'}, {'comment': 'Also - the new CuratorCache uses a Persistent watcher internally (which I added to ZK for 3.6). Those watchers only have 2 modes - single node watch or entire tree watch. So, the new CuratorCache matches this.', 'commenter': 'Randgalt'}]"
335,curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/OutstandingOps.java,"@@ -0,0 +1,55 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.cache;
+
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+
+class OutstandingOps
+{
+    private final AtomicReference<Runnable> completionProc;
+    private final AtomicLong count = new AtomicLong(0);
+    private volatile boolean active = true;
+
+    OutstandingOps(Runnable completionProc)
+    {
+        this.completionProc = new AtomicReference<>(completionProc);
+    }
+
+    void increment()
+    {
+        if ( active )
+        {
+            count.incrementAndGet();
+        }
+    }
+
+    void decrement()
+    {
+        if ( active && (count.decrementAndGet() == 0) )","[{'comment': 'Much better!', 'commenter': 'eolivelli'}]"
335,curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/CuratorCacheImpl.java,"@@ -0,0 +1,301 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.cache;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Sets;
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.api.BackgroundCallback;
+import org.apache.curator.framework.api.CuratorEvent;
+import org.apache.curator.framework.listen.Listenable;
+import org.apache.curator.framework.listen.StandardListenerManager;
+import org.apache.curator.framework.recipes.watch.PersistentWatcher;
+import org.apache.curator.utils.ThreadUtils;
+import org.apache.curator.utils.ZKPaths;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.data.Stat;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import static org.apache.curator.framework.recipes.cache.CuratorCacheListener.Type.*;
+import static org.apache.zookeeper.KeeperException.Code.NONODE;
+import static org.apache.zookeeper.KeeperException.Code.OK;
+
+class CuratorCacheImpl implements CuratorCache
+{
+    private final Logger log = LoggerFactory.getLogger(getClass());
+    private final AtomicReference<State> state = new AtomicReference<>(State.LATENT);
+    private final PersistentWatcher persistentWatcher;
+    private final CuratorFramework client;
+    private final CuratorCacheStorage storage;
+    private final String path;
+    private final boolean recursive;
+    private final boolean compressedData;
+    private final boolean clearOnClose;
+    private final StandardListenerManager<CuratorCacheListener> listenerManager = StandardListenerManager.standard();
+    private final Consumer<Exception> exceptionHandler;
+    private final OutstandingOps outstandingOps = new OutstandingOps(() -> callListeners(CuratorCacheListener::initialized));
+
+    private enum State
+    {
+        LATENT,
+        STARTED,
+        CLOSED
+    }
+
+    CuratorCacheImpl(CuratorFramework client, CuratorCacheStorage storage, String path, Options[] optionsArg, Consumer<Exception> exceptionHandler)
+    {
+        Set<Options> options = (optionsArg != null) ? Sets.newHashSet(optionsArg) : Collections.emptySet();
+        this.client = client;
+        this.storage = (storage != null) ? storage : CuratorCacheStorage.standard();
+        this.path = path;
+        recursive = !options.contains(Options.SINGLE_NODE_CACHE);
+        compressedData = options.contains(Options.COMPRESSED_DATA);
+        clearOnClose = !options.contains(Options.DO_NOT_CLEAR_ON_CLOSE);
+        persistentWatcher = new PersistentWatcher(client, path, recursive);
+        persistentWatcher.getListenable().addListener(this::processEvent);
+        persistentWatcher.getResetListenable().addListener(this::rebuild);
+        this.exceptionHandler = (exceptionHandler != null) ? exceptionHandler : e -> log.error(""CuratorCache error"", e);
+    }
+
+    @Override
+    public void start()
+    {
+        Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), ""Already started"");
+        persistentWatcher.start();
+    }
+
+    @Override
+    public void close()
+    {
+        if ( state.compareAndSet(State.STARTED, State.CLOSED) )
+        {
+            persistentWatcher.close();
+            if ( clearOnClose )
+            {
+                storage.clear();
+            }
+        }
+    }
+
+    @Override
+    public Listenable<CuratorCacheListener> listenable()
+    {
+        return listenerManager;
+    }
+
+    @Override
+    public Optional<ChildData> get(String path)
+    {
+        return storage.get(path);
+    }
+
+    @Override
+    public int size()
+    {
+        return storage.size();
+    }
+
+    @Override
+    public Stream<ChildData> stream()
+    {
+        return storage.stream();
+    }
+
+    @VisibleForTesting
+    CuratorCacheStorage storage()
+    {
+        return storage;
+    }
+
+    private void rebuild()
+    {
+        if ( state.get() != State.STARTED )
+        {
+            return;
+        }
+
+        // rebuild from the root first
+        nodeChanged(path);
+
+        // rebuild remaining nodes - note: this may cause some nodes to be queried twice
+        // (though versions checks will minimize that). If someone can think of a better
+        // way let us know
+        storage.stream()
+            .map(ChildData::getPath)
+            .filter(p -> !p.equals(path))
+            .forEach(this::nodeChanged);
+    }
+
+    private void processEvent(WatchedEvent event)
+    {
+        if ( state.get() != State.STARTED )
+        {
+            return;
+        }
+
+        // NOTE: Persistent/Recursive watchers never trigger NodeChildrenChanged
+
+        switch ( event.getType() )
+        {
+        case NodeDataChanged:
+        case NodeCreated:
+        {
+            nodeChanged(event.getPath());
+            break;
+        }
+
+        case NodeDeleted:
+        {
+            removeStorage(event.getPath());
+            break;
+        }
+        }
+    }
+
+    private void checkChildrenChanged(String fromPath, Stat oldStat, Stat newStat)
+    {
+        if ( (state.get() != State.STARTED) || !recursive )
+        {
+            return;
+        }
+
+        if ( (oldStat != null) && (oldStat.getCversion() == newStat.getCversion()) )
+        {
+            return; // children haven't changed
+        }
+
+        try
+        {
+            BackgroundCallback callback = (__, event) -> {
+                if ( event.getResultCode() == OK.intValue() )
+                {
+                    event.getChildren().forEach(child -> nodeChanged(ZKPaths.makePath(fromPath, child)));
+                }
+                else if ( event.getResultCode() == NONODE.intValue() )
+                {
+                    removeStorage(event.getPath());
+                }
+                else
+                {
+                    handleException(event);
+                }
+                outstandingOps.decrement();
+            };
+
+            outstandingOps.increment();
+            client.getChildren().inBackground(callback).forPath(fromPath);
+        }
+        catch ( Exception e )
+        {
+            handleException(e);
+        }
+    }
+
+    private void nodeChanged(String fromPath)
+    {
+        if ( state.get() != State.STARTED )
+        {
+            return;
+        }
+
+        try
+        {
+            BackgroundCallback callback = (__, event) -> {
+                if ( event.getResultCode() == OK.intValue() )
+                {
+                    Optional<ChildData> childData = putStorage(new ChildData(event.getPath(), event.getStat(), event.getData()));
+                    checkChildrenChanged(event.getPath(), childData.map(ChildData::getStat).orElse(null), event.getStat());
+                }
+                else if ( event.getResultCode() == NONODE.intValue() )
+                {
+                    removeStorage(event.getPath());
+                }
+                else
+                {
+                    handleException(event);
+                }
+                outstandingOps.decrement();
+            };
+
+            outstandingOps.increment();
+            if ( compressedData )
+            {
+                client.getData().decompressed().inBackground(callback).forPath(fromPath);","[{'comment': 'General question about the inBackground callbacks - they are all going to be serialized on the single ZK event thread?', 'commenter': 'shayshim'}, {'comment': 'Yes, background callbacks are called from the single ZK event thread. Is there a concern?', 'commenter': 'Randgalt'}, {'comment': 'No concern, just wanted to make sure. `addListener(T listener, Executor executor)` can be used to offload heavy listeners to another single threaded `Executor`.', 'commenter': 'shayshim'}]"
335,curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/CuratorCacheImpl.java,"@@ -0,0 +1,301 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.recipes.cache;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Sets;
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.api.BackgroundCallback;
+import org.apache.curator.framework.api.CuratorEvent;
+import org.apache.curator.framework.listen.Listenable;
+import org.apache.curator.framework.listen.StandardListenerManager;
+import org.apache.curator.framework.recipes.watch.PersistentWatcher;
+import org.apache.curator.utils.ThreadUtils;
+import org.apache.curator.utils.ZKPaths;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.data.Stat;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import static org.apache.curator.framework.recipes.cache.CuratorCacheListener.Type.*;
+import static org.apache.zookeeper.KeeperException.Code.NONODE;
+import static org.apache.zookeeper.KeeperException.Code.OK;
+
+class CuratorCacheImpl implements CuratorCache
+{
+    private final Logger log = LoggerFactory.getLogger(getClass());
+    private final AtomicReference<State> state = new AtomicReference<>(State.LATENT);
+    private final PersistentWatcher persistentWatcher;
+    private final CuratorFramework client;
+    private final CuratorCacheStorage storage;
+    private final String path;
+    private final boolean recursive;
+    private final boolean compressedData;
+    private final boolean clearOnClose;
+    private final StandardListenerManager<CuratorCacheListener> listenerManager = StandardListenerManager.standard();
+    private final Consumer<Exception> exceptionHandler;
+    private final OutstandingOps outstandingOps = new OutstandingOps(() -> callListeners(CuratorCacheListener::initialized));
+
+    private enum State
+    {
+        LATENT,
+        STARTED,
+        CLOSED
+    }
+
+    CuratorCacheImpl(CuratorFramework client, CuratorCacheStorage storage, String path, Options[] optionsArg, Consumer<Exception> exceptionHandler)
+    {
+        Set<Options> options = (optionsArg != null) ? Sets.newHashSet(optionsArg) : Collections.emptySet();
+        this.client = client;
+        this.storage = (storage != null) ? storage : CuratorCacheStorage.standard();
+        this.path = path;
+        recursive = !options.contains(Options.SINGLE_NODE_CACHE);
+        compressedData = options.contains(Options.COMPRESSED_DATA);
+        clearOnClose = !options.contains(Options.DO_NOT_CLEAR_ON_CLOSE);
+        persistentWatcher = new PersistentWatcher(client, path, recursive);
+        persistentWatcher.getListenable().addListener(this::processEvent);
+        persistentWatcher.getResetListenable().addListener(this::rebuild);
+        this.exceptionHandler = (exceptionHandler != null) ? exceptionHandler : e -> log.error(""CuratorCache error"", e);
+    }
+
+    @Override
+    public void start()
+    {
+        Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), ""Already started"");
+        persistentWatcher.start();
+    }
+
+    @Override
+    public void close()
+    {
+        if ( state.compareAndSet(State.STARTED, State.CLOSED) )
+        {
+            persistentWatcher.close();
+            if ( clearOnClose )
+            {
+                storage.clear();
+            }
+        }
+    }
+
+    @Override
+    public Listenable<CuratorCacheListener> listenable()
+    {
+        return listenerManager;
+    }
+
+    @Override
+    public Optional<ChildData> get(String path)
+    {
+        return storage.get(path);
+    }
+
+    @Override
+    public int size()
+    {
+        return storage.size();
+    }
+
+    @Override
+    public Stream<ChildData> stream()
+    {
+        return storage.stream();
+    }
+
+    @VisibleForTesting
+    CuratorCacheStorage storage()
+    {
+        return storage;
+    }
+
+    private void rebuild()
+    {
+        if ( state.get() != State.STARTED )
+        {
+            return;
+        }
+
+        // rebuild from the root first
+        nodeChanged(path);
+
+        // rebuild remaining nodes - note: this may cause some nodes to be queried twice
+        // (though versions checks will minimize that). If someone can think of a better
+        // way let us know
+        storage.stream()
+            .map(ChildData::getPath)
+            .filter(p -> !p.equals(path))
+            .forEach(this::nodeChanged);
+    }
+
+    private void processEvent(WatchedEvent event)
+    {
+        if ( state.get() != State.STARTED )
+        {
+            return;
+        }
+
+        // NOTE: Persistent/Recursive watchers never trigger NodeChildrenChanged
+
+        switch ( event.getType() )
+        {
+        case NodeDataChanged:
+        case NodeCreated:
+        {
+            nodeChanged(event.getPath());
+            break;
+        }
+
+        case NodeDeleted:
+        {
+            removeStorage(event.getPath());
+            break;
+        }
+        }
+    }
+
+    private void checkChildrenChanged(String fromPath, Stat oldStat, Stat newStat)
+    {
+        if ( (state.get() != State.STARTED) || !recursive )
+        {
+            return;
+        }
+
+        if ( (oldStat != null) && (oldStat.getCversion() == newStat.getCversion()) )
+        {
+            return; // children haven't changed
+        }
+
+        try
+        {
+            BackgroundCallback callback = (__, event) -> {
+                if ( event.getResultCode() == OK.intValue() )
+                {
+                    event.getChildren().forEach(child -> nodeChanged(ZKPaths.makePath(fromPath, child)));
+                }
+                else if ( event.getResultCode() == NONODE.intValue() )
+                {
+                    removeStorage(event.getPath());
+                }
+                else
+                {
+                    handleException(event);
+                }
+                outstandingOps.decrement();
+            };
+
+            outstandingOps.increment();
+            client.getChildren().inBackground(callback).forPath(fromPath);
+        }
+        catch ( Exception e )
+        {
+            handleException(e);
+        }
+    }
+
+    private void nodeChanged(String fromPath)
+    {
+        if ( state.get() != State.STARTED )
+        {
+            return;
+        }
+
+        try
+        {
+            BackgroundCallback callback = (__, event) -> {
+                if ( event.getResultCode() == OK.intValue() )
+                {
+                    Optional<ChildData> childData = putStorage(new ChildData(event.getPath(), event.getStat(), event.getData()));
+                    checkChildrenChanged(event.getPath(), childData.map(ChildData::getStat).orElse(null), event.getStat());
+                }
+                else if ( event.getResultCode() == NONODE.intValue() )
+                {
+                    removeStorage(event.getPath());
+                }
+                else
+                {
+                    handleException(event);
+                }
+                outstandingOps.decrement();
+            };
+
+            outstandingOps.increment();
+            if ( compressedData )
+            {
+                client.getData().decompressed().inBackground(callback).forPath(fromPath);
+            }
+            else
+            {
+                client.getData().inBackground(callback).forPath(fromPath);
+            }
+        }
+        catch ( Exception e )
+        {
+            handleException(e);
+        }
+    }
+
+    private Optional<ChildData> putStorage(ChildData data)
+    {
+        Optional<ChildData> previousData = storage.put(data);
+        if ( previousData.isPresent() )
+        {
+            if ( previousData.get().getStat().getVersion() != data.getStat().getVersion() )
+            {
+                callListeners(l -> l.event(NODE_CHANGED, previousData.get(), data));
+            }
+        }
+        else
+        {
+            callListeners(l -> l.event(NODE_CREATED, null, data));
+        }
+        return previousData;
+    }
+
+    private void removeStorage(String path)
+    {
+        storage.remove(path).ifPresent(previousData -> callListeners(l -> l.event(NODE_DELETED, previousData, null)));
+    }
+
+    private void callListeners(Consumer<CuratorCacheListener> proc)
+    {
+        if ( state.get() == State.STARTED )
+        {
+            client.runSafe(() -> listenerManager.forEach(proc));
+        }
+    }
+
+    private void handleException(CuratorEvent event)
+    {
+        handleException(KeeperException.create(KeeperException.Code.get(event.getResultCode())));
+    }
+
+    private void handleException(Exception e)
+    {
+        ThreadUtils.checkInterrupted(e);","[{'comment': ""In case of `InterruptedException` you both reset the interrupt on the thread and propagate the exception to user. Shouldn't you do only one of them, but not both?"", 'commenter': 'shayshim'}, {'comment': ""It's important to reset the interrupted flag. I don't think we should count on the end user doing that. Curator has had this behavior for a long time. Maybe we can re-visit it in another issue."", 'commenter': 'Randgalt'}]"
372,curator-client/src/test/java/org/apache/curator/BasicTests.java,"@@ -30,15 +37,13 @@
 import org.apache.zookeeper.ZooDefs;
 import org.apache.zookeeper.ZooKeeper;
 import org.mockito.Mockito;
-import org.testng.Assert;
-import org.testng.annotations.Test;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 public class BasicTests extends BaseClassForTests
 {
-    @Test
+    @RepeatedIfExceptionsTest(repeats = BaseClassForTests.REPEATS)","[{'comment': ""Isn't there any other way of achieve this behaviour? It looks quite awkward to use this custom annotation instead of a simple '@Test'"", 'commenter': 'eolivelli'}, {'comment': ""There are multiple ways to repeat failed tests with jUnit5.\r\nMost simple is Maven's surefire plugin, which works now with jUnit5.\r\nBut in Curator in the original solution not all of the tests have been repeated when failed. Some of them have been tried only once, some not.\r\nThis extension provides an annotation which you can use on those tests which you want to repeat when failed, but still have the option to use @Test on those you are not interested in. I thinks this greater flexibility is valuable.\r\nWhat do you think?"", 'commenter': 'tamaashu'}, {'comment': ""Personally (non binding) I would prefer to use the standard tools from the jUnit framework + surefire.\r\nSo add a simply rerunFailingTests on surefire configuration is a better option.\r\n\r\nIt would be better to not have flaky tests at all, but that would be a different story\r\n\r\n@Randgalt what's your opinion ?\r\n"", 'commenter': 'eolivelli'}, {'comment': 'I agree that not having to annotate every test is a good idea. If this functionality can be provided by configuration at a higher level that sounds like a good approach to me.', 'commenter': 'cammckenzie'}, {'comment': ""@Randgalt I you also prefer the maven based solution, I can change it, it's not a big deal.\r\nThe only difference is that then we cannot define on test level which tests should re-run if fail. But I don't see it as a problem."", 'commenter': 'tamaashu'}]"
372,pom.xml,"@@ -657,6 +674,12 @@
                     <version>${maven-bundle-plugin-version}</version>
                 </plugin>
 
+                <plugin>
+                    <groupId>org.commonjava.maven.plugins</groupId>
+                    <artifactId>directory-maven-plugin</artifactId>","[{'comment': ""What's the purpose of this plugin?"", 'commenter': 'eolivelli'}, {'comment': ""When I tried to build only one sub-component of Curator maven-license-plugin always failed as didn't find the file **/src/etc/header.txt**.\r\nThis plugin helps to find the root directory of the project and than it can be used in the license plugin as **${main.basedir}/src/etc/header.txt**"", 'commenter': 'tamaashu'}, {'comment': 'very good ! thank you very much !', 'commenter': 'eolivelli'}]"
375,curator-examples/src/main/java/discovery/DiscoveryExample.java,"@@ -192,8 +194,13 @@ private static void listInstances(ServiceDiscovery<InstanceDetails> serviceDisco
                 }
             }
         }
-        finally","[{'comment': 'Please keep the closing of resources into the finally block', 'commenter': 'eolivelli'}, {'comment': ""OK, thank you. I'll put the resource shutdown in the finally block."", 'commenter': 'iwangjie'}]"
375,curator-examples/src/main/java/discovery/DiscoveryExample.java,"@@ -192,6 +194,14 @@ private static void listInstances(ServiceDiscovery<InstanceDetails> serviceDisco
                 }
             }
         }
+        catch ( Exception e )
+        {
+            if ( e instanceof KeeperException.NoNodeException )","[{'comment': 'which instruction can throw this exception ? is it possible that it is throws inside the inner loop ? \r\nin that case we could end the loop prematurely .\r\nthat do you think ?', 'commenter': 'eolivelli'}, {'comment': 'When there is no one service in the registration call list will directly exit the process, and in fact should be prompted without any services, unless it is other exceptions, do you think?', 'commenter': 'iwangjie'}, {'comment': ""Maybe, if it's not a NoNodeException, I should throw it to stop the execution of the program, right?"", 'commenter': 'iwangjie'}, {'comment': ""let's make it simple.\r\nif you found this problem with NoNode then let's fix only it.\r\n\r\nif you have ever saw other errors, then it is worth to do more\r\n\r\nwhat do you think ?"", 'commenter': 'eolivelli'}, {'comment': 'OK, it has been modified', 'commenter': 'iwangjie'}]"
375,curator-examples/src/main/java/discovery/DiscoveryExample.java,"@@ -192,6 +194,14 @@ private static void listInstances(ServiceDiscovery<InstanceDetails> serviceDisco
                 }
             }
         }
+        catch ( Exception e )
+        {
+            if ( e instanceof KeeperException.NoNodeException )
+            {
+                System.err.println(""There are no registered instances."");
+                return;
+            }","[{'comment': 'any other exception should be rethrown', 'commenter': 'eolivelli'}, {'comment': ""Yes, that's what I thought, and I hope what I'm doing now is the same as what we discussed."", 'commenter': 'iwangjie'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java,"@@ -87,6 +93,7 @@ public CreateBuilderImpl(CuratorFrameworkImpl client, CreateMode createMode, Bac
         this.createParentsAsContainers = createParentsAsContainers;
         this.compress = compress;
         this.setDataIfExists = setDataIfExists;
+        this.idempotent = false; // TODO should I add this to async framework as well? Looks like that's the reason this is a public constructor","[{'comment': 'For now I think just leave this as defaulting to false, and we can add to the async framework in another PR.', 'commenter': 'cammckenzie'}, {'comment': 'can we please remove TODO and create an issue ? \r\nor we can leave here the TODO but put the link to the JIRA', 'commenter': 'eolivelli'}, {'comment': 'created https://issues.apache.org/jira/browse/CURATOR-589', 'commenter': 'jmslocum16'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/DeleteBuilderImpl.java,"@@ -173,6 +186,11 @@ public void performBackgroundOperation(final OperationAndData<String> operationA
                         @Override
                         public void processResult(int rc, String path, Object ctx)
                         {
+                            if ( (rc == KeeperException.Code.OK.intValue()) && failNextDeleteForTesting )
+                            {
+                                failNextDeleteForTesting = false;
+                                rc = KeeperException.Code.CONNECTIONLOSS.intValue();
+                            }
                             trace.setReturnCode(rc).setPath(path).commit();","[{'comment': ""Just a nit pick as this won't happen outside testing, but I think that the trace.setReturnCode should be called at the top of the method."", 'commenter': 'cammckenzie'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/SetDataBuilderImpl.java,"@@ -51,6 +62,8 @@ public SetDataBuilderImpl(CuratorFrameworkImpl client, Backgrounding backgroundi
         this.backgrounding = backgrounding;
         this.version = version;
         this.compress = compress;
+        // TODO jslocum - this is only public for x-async api. Should I add idempotent there too?","[{'comment': 'I think just leave it for now and default idempotent to false. Can update with a subsequent PR if required.', 'commenter': 'cammckenzie'}, {'comment': 'can we link a JIRA ?', 'commenter': 'eolivelli'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/SetDataBuilderImpl.java,"@@ -228,10 +289,25 @@ public void performBackgroundOperation(final OperationAndData<PathAndBytes> oper
                     @Override
                     public void processResult(int rc, String path, Object ctx, Stat stat)
                     {
+                        if ( (rc == KeeperException.Code.OK.intValue()) && failNextSetForTesting )
+                        {
+                            failNextSetForTesting = false;
+                            rc = KeeperException.Code.CONNECTIONLOSS.intValue();
+                        }
+
                         trace.setReturnCode(rc).setRequestBytesLength(data).setPath(path).setStat(stat).commit();","[{'comment': 'Move trace to top of method', 'commenter': 'cammckenzie'}]"
376,pom.xml,"@@ -68,7 +68,7 @@
 
         <!-- versions -->
         <zookeeper-version>3.6.0</zookeeper-version>
-        <maven-bundle-plugin-version>4.1.0</maven-bundle-plugin-version>
+        <maven-bundle-plugin-version>5.1.1</maven-bundle-plugin-version>","[{'comment': ""I assume this version upgrade won't have any unexpected impacts, but my familiarity with Maven is pretty minimal. @eolivelli @Randgalt thoughts?"", 'commenter': 'cammckenzie'}, {'comment': ""Yeah, I changed this because i was getting build errors trying to build curator locally.\r\nThis was the recommended fix I found, and it did fix it for me. I am also not a maven expert so if there is a different or better way to fix it I'm happy to change it."", 'commenter': 'jmslocum16'}, {'comment': 'It should be fine to make the upgrade', 'commenter': 'eolivelli'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java,"@@ -807,6 +826,53 @@ public void performBackgroundOperation(OperationAndData<PathAndBytes> op) throws
         client.queueOperation(new OperationAndData<>(operation, null, null, null, null, null));
     }
 
+    private void backgroundCheckIdempotent(final CuratorFrameworkImpl client, final OperationAndData<PathAndBytes> mainOperationAndData, final String path, final Backgrounding backgrounding)
+    {
+        final AsyncCallback.DataCallback dataCallback = new AsyncCallback.DataCallback()
+        {
+            @Override
+            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
+            {
+                if ( rc == KeeperException.Code.NONODE.intValue() )
+                {
+                    client.queueOperation(mainOperationAndData);    // try to create it again
+                }
+                else
+                {
+                    if ( rc == KeeperException.Code.OK.intValue() )
+                    {
+                        if ( failNextIdempotentCheckForTesting )
+                        {
+                            failNextIdempotentCheckForTesting = false;
+                            rc = KeeperException.Code.CONNECTIONLOSS.intValue();
+                        }
+                        else if ( !IdempotentUtils.matches(0, mainOperationAndData.getData().getData(), stat.getVersion(), data) )
+                        {
+                            rc = KeeperException.Code.NODEEXISTS.intValue();
+                        }
+                    }
+                    sendBackgroundResponse(rc, path, ctx, path, stat, mainOperationAndData);
+                }
+            }
+        };
+        BackgroundOperation<PathAndBytes> operation = new BackgroundOperation<PathAndBytes>()
+        {
+            @Override
+            public void performBackgroundOperation(OperationAndData<PathAndBytes> op) throws Exception
+            {
+                try
+                {
+                    client.getZooKeeper().getData(path, false, dataCallback, backgrounding.getContext());
+                }
+                catch ( KeeperException e )
+                {
+                    // ignore","[{'comment': 'log ?', 'commenter': 'eolivelli'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/IdempotentUtils.java,"@@ -0,0 +1,53 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.curator.framework.imps;
+
+/*
+ * Utilties Class for idempotent operatons. 
+ */
+class IdempotentUtils
+{
+
+    /**
+     * Returns whether the version and data currently in the node match what would be expected in the idempotent retry case. 
+     */
+    static boolean matches(int expectedVersion, byte[] expectedData, int actualVersion, byte[] actualData)
+    {
+        return expectedVersion == actualVersion && matches(expectedData, actualData);
+    }
+
+    /**
+     * Returns whether the data currently in the node matches what would be expected in the idempotent retry case (ignoring version).
+     */
+    static boolean matches(byte[] expectedData, byte[] actualData)
+    {
+        if ( expectedData.length != actualData.length )","[{'comment': 'can we use java.util.Arrays.equals ?', 'commenter': 'eolivelli'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/SetDataBuilderImpl.java,"@@ -210,6 +230,47 @@ public Stat forPath(String path) throws Exception
         return this;
     }
 
+    private void backgroundCheckIdempotent(final CuratorFrameworkImpl client, final OperationAndData<PathAndBytes> mainOperationAndData, final String path, final Backgrounding backgrounding)
+    {
+        final AsyncCallback.DataCallback dataCallback = new AsyncCallback.DataCallback()
+        {
+            @Override
+            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
+            {
+                    if ( rc == KeeperException.Code.OK.intValue() )
+                    {
+                        if ( failNextIdempotentCheckForTesting )
+                        {
+                            failNextIdempotentCheckForTesting = false;
+                            rc = KeeperException.Code.CONNECTIONLOSS.intValue();
+                        }
+                        else if ( !idempotentSetMatches(stat.getVersion(), mainOperationAndData.getData().getData(), data) )
+                        {
+                            rc = KeeperException.Code.BADVERSION.intValue();
+                        }
+                    }
+                    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_DATA, rc, path, null, ctx, stat, null, null, null, null, null);
+                    client.processBackgroundOperation(mainOperationAndData, event);
+            }
+        };
+        BackgroundOperation<PathAndBytes> operation = new BackgroundOperation<PathAndBytes>()
+        {
+            @Override
+            public void performBackgroundOperation(OperationAndData<PathAndBytes> op) throws Exception
+            {
+                try
+                {
+                    client.getZooKeeper().getData(path, false, dataCallback, backgrounding.getContext());
+                }
+                catch ( KeeperException e )
+                {
+                    // ignore","[{'comment': 'log ?', 'commenter': 'eolivelli'}]"
376,curator-examples/src/main/java/framework/CrudExamples.java,"@@ -119,6 +145,24 @@ public static void      guaranteedDelete(CuratorFramework client, String path) t
         client.delete().guaranteed().forPath(path);
     }
 
+    public static void      idempotentDelete(CuratorFramework client, String path, int currentVersion) throws Exception","[{'comment': 'nit: why not `deleteIdempotent`', 'commenter': 'tisonkun'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java,"@@ -87,6 +93,8 @@ public CreateBuilderImpl(CuratorFrameworkImpl client, CreateMode createMode, Bac
         this.createParentsAsContainers = createParentsAsContainers;
         this.compress = compress;
         this.setDataIfExists = setDataIfExists;
+        // TODO implement this in CURATOR-589","[{'comment': 'remove before merging', 'commenter': 'tisonkun'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java,"@@ -57,12 +57,17 @@
     private boolean compress;
     private boolean setDataIfExists;
     private int setDataIfExistsVersion = -1;
+    private boolean idempotent;","[{'comment': 'how about just set a default `false` here?', 'commenter': 'tisonkun'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java,"@@ -642,6 +657,10 @@ else if ( (rc == KeeperException.Code.NODEEXISTS.intValue()) && setDataIfExists
                     {
                         backgroundSetData(client, operationAndData, operationAndData.getData().getPath(), backgrounding);
                     }
+                    else if ( (rc == KeeperException.Code.NODEEXISTS.intValue()) && idempotent && !createMode.isSequential() )","[{'comment': 'Can we log a warning when user set `idempotent` with sequential node?', 'commenter': 'tisonkun'}, {'comment': ""Actually, after thinking about this some more, and reading the zookeeper documentation, I don't think it's possible to get a NODE_EXISTS exception with sequential creates (which makes sense now that I think about it):\r\nhttps://zookeeper.apache.org/doc/r3.3.3/api/org/apache/zookeeper/ZooKeeper.html#create(java.lang.String,%20byte[],%20java.util.List,%20org.apache.zookeeper.CreateMode)\r\n\r\nSo I just removed the check for createMode.isSequential() entirely."", 'commenter': 'jmslocum16'}, {'comment': ""you're right. sequential always succeeds."", 'commenter': 'tisonkun'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java,"@@ -1147,12 +1235,35 @@ public String call() throws Exception
                                 if ( setDataIfExists )
                                 {
                                     Stat setStat = client.getZooKeeper().setData(path, data, setDataIfExistsVersion);
-                                    if(storingStat != null)
+                                    if ( storingStat != null )
                                     {
                                         DataTree.copyStat(setStat, storingStat);
                                     }
                                     createdPath = path;
                                 }
+                                else if ( idempotent && !createMode.isSequential() )","[{'comment': 'ditto warning suggestion here, or we can check whenever an operation triggered.', 'commenter': 'tisonkun'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/SetDataBuilderImpl.java,"@@ -36,13 +39,22 @@
     private Backgrounding                   backgrounding;
     private int                             version;
     private boolean                         compress;
+    private boolean                         idempotent;","[{'comment': 'ditto default `false` suggest here.', 'commenter': 'tisonkun'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/SetDataBuilderImpl.java,"@@ -51,6 +63,8 @@ public SetDataBuilderImpl(CuratorFrameworkImpl client, Backgrounding backgroundi
         this.backgrounding = backgrounding;
         this.version = version;
         this.compress = compress;
+        // TODO implement this in CURATOR-589","[{'comment': 'ditto removal suggestion here.', 'commenter': 'tisonkun'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/SetDataBuilderImpl.java,"@@ -210,6 +231,48 @@ public Stat forPath(String path) throws Exception
         return this;
     }
 
+    private void backgroundCheckIdempotent(final CuratorFrameworkImpl client, final OperationAndData<PathAndBytes> mainOperationAndData, final String path, final Backgrounding backgrounding)
+    {
+        final AsyncCallback.DataCallback dataCallback = new AsyncCallback.DataCallback()
+        {
+            @Override
+            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
+            {
+                    if ( rc == KeeperException.Code.OK.intValue() )
+                    {
+                        if ( failNextIdempotentCheckForTesting )
+                        {
+                            failNextIdempotentCheckForTesting = false;
+                            rc = KeeperException.Code.CONNECTIONLOSS.intValue();
+                        }
+                        else if ( !idempotentSetMatches(stat.getVersion(), mainOperationAndData.getData().getData(), data) )
+                        {
+                            rc = KeeperException.Code.BADVERSION.intValue();
+                        }
+                    }
+                    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_DATA, rc, path, null, ctx, stat, null, null, null, null, null);","[{'comment': '```suggestion\r\n                    final CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_DATA, rc, path, null, ctx, stat, null, null, null, null, null);\r\n```', 'commenter': 'tisonkun'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java,"@@ -569,7 +583,7 @@ public String forPath(final String givenPath, byte[] data) throws Exception
             data = client.getCompressionProvider().compress(givenPath, data);
         }
 
-        final String adjustedPath = adjustPath(client.fixForNamespace(givenPath, createMode.isSequential()));
+        final String adjustedPath = adjustPath(client.fixForNamespace(givenPath, createMode.isnSequential()));","[{'comment': 'isnSequential is presumably a typo?', 'commenter': 'cammckenzie'}, {'comment': 'oh, yeah :( fixed', 'commenter': 'jmslocum16'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java,"@@ -74,6 +79,7 @@
         createParentsAsContainers = false;
         compress = false;
         setDataIfExists = false;
+        idempotent = false;","[{'comment': 'if we have a default value, then this is redundant.', 'commenter': 'tisonkun'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java,"@@ -87,6 +93,7 @@ public CreateBuilderImpl(CuratorFrameworkImpl client, CreateMode createMode, Bac
         this.createParentsAsContainers = createParentsAsContainers;
         this.compress = compress;
         this.setDataIfExists = setDataIfExists;
+        this.idempotent = false;","[{'comment': 'ditto', 'commenter': 'tisonkun'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/SetDataBuilderImpl.java,"@@ -36,13 +39,22 @@
     private Backgrounding                   backgrounding;
     private int                             version;
     private boolean                         compress;
+    private boolean                         idempotent = false;
+
+    @VisibleForTesting
+    boolean failNextSetForTesting = false;
+    @VisibleForTesting
+    boolean failBeforeNextSetForTesting = false;
+    @VisibleForTesting
+    boolean failNextIdempotentCheckForTesting = false;
 
     SetDataBuilderImpl(CuratorFrameworkImpl client)
     {
         this.client = client;
         backgrounding = new Backgrounding();
         version = -1;
         compress = false;
+        idempotent = false;","[{'comment': 'ditto', 'commenter': 'tisonkun'}]"
376,curator-framework/src/main/java/org/apache/curator/framework/imps/SetDataBuilderImpl.java,"@@ -51,6 +63,7 @@ public SetDataBuilderImpl(CuratorFrameworkImpl client, Backgrounding backgroundi
         this.backgrounding = backgrounding;
         this.version = version;
         this.compress = compress;
+        this.idempotent = false;","[{'comment': 'ditto', 'commenter': 'tisonkun'}]"
391,curator-framework/src/test/java/org/apache/curator/framework/imps/TestFramework.java,"@@ -1070,10 +1077,28 @@ public void testCreateModes() throws Exception
 
             stat = client.checkExists().forPath(realPath);
             assertNull(stat);
+            ","[{'comment': ""Break this off into a new unit test. It's got nothing to do with testing create modes."", 'commenter': 'cammckenzie'}, {'comment': 'Done', 'commenter': 'liran2000'}]"
391,curator-client/src/main/java/org/apache/curator/utils/ConfigurableZookeeperFactory.java,"@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.curator.utils;
+
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.admin.ZooKeeperAdmin;
+import org.apache.zookeeper.client.ZKClientConfig;
+
+/**
+ * Configurable ZookeeperFactory, by using org.apache.zookeeper.client.ZKClientConfig.
+ * 
+ * @author Liran Mendelovich","[{'comment': ""We don't use @Author annotations (not sure why exactly, just history)."", 'commenter': 'cammckenzie'}]"
391,curator-framework/src/main/java/org/apache/curator/framework/imps/CuratorFrameworkImpl.java,"@@ -200,23 +232,39 @@ public QuorumVerifier getCurrentConfig()
         return (ensembleTracker != null) ? ensembleTracker.getCurrentConfig() : null;
     }
 
-    private ZookeeperFactory makeZookeeperFactory(final ZookeeperFactory actualZookeeperFactory)
+    private ZookeeperFactory makeZookeeperFactory(final ZookeeperFactory actualZookeeperFactory, ZKClientConfig zkClientConfig)
     {
+    	if (actualZookeeperFactory instanceof ConfigurableZookeeperFactory) {","[{'comment': ""I'm -1 on using `instanceof`. Wouldn't it be better to add a `default` method to `ZookeeperFactory` that takes the `ZKClientConfig`? It could be optional and forward to the older versions when not present. The default version in `DefaultZookeeperFactory` would throw an exception."", 'commenter': 'Randgalt'}, {'comment': 'Understood. Done.', 'commenter': 'liran2000'}]"
391,curator-framework/src/test/java/org/apache/curator/framework/imps/TestFramework.java,"@@ -50,26 +59,24 @@
 import org.apache.zookeeper.Watcher;
 import org.apache.zookeeper.ZooDefs;
 import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.client.ZKClientConfig;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Tag;
 import org.junit.jupiter.api.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
+import com.google.common.collect.Lists;
 
 @SuppressWarnings(""deprecation"")
 @Tag(CuratorTestBase.zk35TestCompatibilityGroup)
 public class TestFramework extends BaseClassForTests
 {
+	private final Logger log = LoggerFactory.getLogger(getClass());","[{'comment': 'Usually loggers are static fields\r\n`private static final Logger log = LoggerFactory.getLogger(TestFramework.class);`\r\n', 'commenter': 'eolivelli'}, {'comment': 'I wrote it exactly as already implemented at the same package, to be consistent:\r\n\r\nhttps://github.com/apache/curator/blob/b9dc9bd4056dba18c29a4f3127df43b930449abe/curator-framework/src/test/java/org/apache/curator/framework/imps/TestFrameworkBackground.java#L56\r\n\r\nhttps://github.com/apache/curator/blob/b9dc9bd4056dba18c29a4f3127df43b930449abe/curator-framework/src/test/java/org/apache/curator/framework/imps/TestFrameworkEdges.java#L78', 'commenter': 'liran2000'}, {'comment': 'sorry.\r\nyou are right.\r\nI forgot that we are in Curator and we have different conventions.\r\n\r\nthanks for checking out', 'commenter': 'eolivelli'}]"
391,curator-framework/src/test/java/org/apache/curator/framework/imps/TestFramework.java,"@@ -1073,7 +1080,41 @@ public void testCreateModes() throws Exception
         }
         finally
         {
-            CloseableUtils.closeQuietly(client);
+        	CloseableUtils.closeQuietly(client);
+        }
+    }
+    
+    @Test
+    public void testConfigurableZookeeper() throws Exception
+    {
+    	CuratorFramework client = null;
+        try
+        {
+        	ZKClientConfig zkClientConfig = new ZKClientConfig();
+    		String zookeeperRequestTimeout = ""30000"";
+    		zkClientConfig.setProperty(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT, zookeeperRequestTimeout);
+    		client = CuratorFrameworkFactory.newClient(server.getConnectString(), 30000, 30000, new RetryOneTime(1), zkClientConfig);
+            client.start();
+        	
+            byte[] writtenBytes = {1, 2, 3};
+            client.create().forPath(""/test"", writtenBytes);
+
+            byte[] readBytes = client.getData().forPath(""/test"");
+            assertArrayEquals(writtenBytes, readBytes);
+            assertEquals(zookeeperRequestTimeout, client.getZookeeperClient().getZooKeeper().getClientConfig().getProperty(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT));
+            
+        } catch (NoSuchMethodError e) {
+			log.debug(""NoSuchMethodError: "", e);","[{'comment': 'Can you please fix formatting here?\r\n\r\nOtherwise I will do it as follow up.\r\nI will merge this patch today.\r\n\r\nWe are also going to cut a release as soon as possible \r\n', 'commenter': 'eolivelli'}, {'comment': 'Sure, done.\r\nBTW, at my IDE this formatting, formatting was fine, depends on IDE config, I will notice it.\r\n', 'commenter': 'liran2000'}, {'comment': '@eolivelli thanks, can be merged and then resolve the Jira issue', 'commenter': 'liran2000'}]"
394,curator-recipes/src/test/java/org/apache/curator/framework/recipes/locks/TestInterProcessReadWriteLock.java,"@@ -362,4 +362,77 @@ private void doLocking(InterProcessLock lock, AtomicInteger concurrentCount, Ato
             }
         }
     }
+
+    public static class LockPathInterProcessReadWriteLock extends InterProcessReadWriteLock","[{'comment': 'This class seems not used.\r\n\r\nAre you missing a commit?\r\nIs there any test that covers these new APIs?', 'commenter': 'eolivelli'}, {'comment': 'Yes, it is not used, as I have only added it to demonstrate that there is a way to subclass `InterProcessReadWriteLock` the desired way. I will add a test today.', 'commenter': 'faucct'}]"
395,curator-x-async/src/test/java/org/apache/curator/x/async/modeled/TestZPath.java,"@@ -57,11 +57,11 @@ public void testBasic()
         assertFalse(path.startsWith(ZPath.root.child(""two"")));
 
         ZPath checkIdLike = ZPath.parse(""/one/{two}/three"");","[{'comment': 'The contract for `ZPath.parse()` is that it does _not_ recognize parameters. This is why the original test is `assertFalse`. This PR changes this contract. `parseWithIds()` should be used instead.', 'commenter': 'Randgalt'}, {'comment': 'I see.  That seemed like a bug to me, but I can see now when considering the two methods the difference in contracts.  \r\n\r\nPerhaps additional documentation would be helpful here (which I\'m happy to help with).\r\n\r\nIn the parseWithId\'s method, I see a ""TODO"" comment without any explanation of what remains to be done.  Is this something we should address as well?\r\n\r\nDo you concur that the original problem of having something like ""/root"" as the first parameter should be considered valid?\r\n\r\n\r\n\r\n', 'commenter': 'Ryan0751'}, {'comment': '> Perhaps additional documentation would be helpful here (which I\'m happy to help with).\r\n\r\nWe\'d really appreciate that!\r\n\r\n> n the parseWithId\'s method, I see a ""TODO""\r\n\r\nMan - I don\'t remember :( the code looks good to me now though\r\n\r\n> Do you concur that the original problem of having something like ""/root"" as the first parameter should be considered valid?\r\n\r\nI\'m not sure. Curator (and ZooKeeper itself) has historically had a lot of trouble with leading slashes and the root path (`/`). I\'d like to see copious testing on this if we were to make a change. For example, over the years we\'ve gotten PRs trying to change how `ZKPaths.java` works and they all introduce problems. I\'m not saying the way it\'s implemented is ideal but that it may be too late on this.', 'commenter': 'Randgalt'}, {'comment': ""Thank you for the back history.\r\n\r\nThat does make me nervous to introduce this type of change.  And, given there are other ways to construct the path the way the I want, it may not be worth the risk.\r\n\r\nI'd still be happy to make a few additions to the documentation (javadoc as well as those unit test cases) so that confusion for people like me is reduced in the future :)\r\n\r\nWould it be more appropriate to re-purpose this PR, or create a new one?"", 'commenter': 'Ryan0751'}, {'comment': 'Up to you - whatever is easiest', 'commenter': 'Randgalt'}, {'comment': 'Sorry for the churn, but now that I\'m looking at this again more closely, the current implementation does still seem to have a bug to me.\r\n\r\nI understand that the parse() method doesn\'t resolve parameters, and that parseWithID\'s does resolve parameters.\r\n\r\nThe unit test calls parse() on a path when parameters in it.\r\n\r\nExample:\r\n`ZPath checkIdLike = ZPath.parse(""/one/{two}/three"");`\r\n\r\nAs expected, that doesn\'t touch the parameters, and returns a ZPath in checkIdLike of:\r\n`/one/{two}/three`\r\n\r\nNext, the ""isResolved()"" method is called on that path, and the unit test is currently expecting it to be resolved:\r\nassertTrue(checkIdLike.isResolved());\r\n\r\nThe confusion for me is:  How is that considered a resolved path if `checkIdLike` still contains the `{two}` parameter?\r\n\r\nMy change had fixed this, so that if any parameters (items in `{}` delimiters} is found in the ZPath, it\'s considered unresolved.\r\n', 'commenter': 'Ryan0751'}, {'comment': ""`ZPath.parse()` doesn't consider IDs. The use-case here people who put things in their path that look like ZPath IDs. They don't want them considered as IDs and want them treated as normal paths. So, yes, it's correct in this test that isResolved() returns true. "", 'commenter': 'Randgalt'}, {'comment': 'I will update the documentation to indicate that resolved state is set by by the appropriate parse methods and is not indicative of the presence of parameter looking things in the path.', 'commenter': 'Ryan0751'}]"
397,curator-framework/src/test/java/org/apache/curator/framework/imps/TestWatcherIdentity.java,"@@ -32,167 +38,152 @@
 import org.apache.zookeeper.Watcher;
 import org.junit.jupiter.api.Test;
 
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
+import com.google.common.collect.Sets;
 
-public class TestWatcherIdentity extends BaseClassForTests
-{
-    private static final String PATH = ""/foo"";
-
-    private static class CountCuratorWatcher implements CuratorWatcher
-    {
-        private final AtomicInteger count = new AtomicInteger(0);
-
-        @Override
-        public void process(WatchedEvent event) throws Exception
-        {
-            count.incrementAndGet();
-        }
-    }
-
-    private static class CountZKWatcher implements Watcher
-    {
-        private final AtomicInteger count = new AtomicInteger(0);
-
-        @Override
-        public void process(WatchedEvent event)
-        {
-            count.incrementAndGet();
-        }
-    }
-
-    @Test
-    public void testSameWatcherPerZKDocs() throws Exception
-    {
-        CountZKWatcher actualWatcher = new CountZKWatcher();
-        Timing timing = new Timing();
-        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));
-        try
-        {
-            client.start();
-            client.create().forPath(""/test"");
-
-            // per ZK docs, this watcher should only trigger once
-            client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
-            client.getData().usingWatcher(actualWatcher).forPath(""/test"");
-
-            client.setData().forPath(""/test"", ""foo"".getBytes());
-            client.delete().forPath(""/test"");
-            timing.sleepABit();
-            assertEquals(actualWatcher.count.getAndSet(0), 1);
-
-            client.create().forPath(""/test"");
-            client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
-            client.delete().forPath(""/test"");
-            timing.sleepABit();
-            assertEquals(actualWatcher.count.get(), 1);
-        }
-        finally
-        {
-            CloseableUtils.closeQuietly(client);
-        }
-    }
-
-    @Test
-    public void testSameCuratorWatcherPerZKDocs() throws Exception
-    {
-        CountCuratorWatcher actualWatcher = new CountCuratorWatcher();
-        Timing timing = new Timing();
-        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));
-        try
-        {
-            client.start();
-            client.create().forPath(""/test"");
-
-            // per ZK docs, this watcher should only trigger once
-            client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
-            client.getData().usingWatcher(actualWatcher).forPath(""/test"");
-
-            client.setData().forPath(""/test"", ""foo"".getBytes());
-            client.delete().forPath(""/test"");
-            timing.sleepABit();
-            assertEquals(actualWatcher.count.getAndSet(0), 1);
-
-            client.create().forPath(""/test"");
-            client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
-            client.delete().forPath(""/test"");
-            timing.sleepABit();
-            assertEquals(actualWatcher.count.get(), 1);
-        }
-        finally
-        {
-            CloseableUtils.closeQuietly(client);
-        }
-    }
-
-    @Test
-    public void testSetAddition()
-    {
-        Watcher watcher = new Watcher()
-        {
-            @Override
-            public void process(WatchedEvent event)
-            {
-
-            }
-        };
-        NamespaceWatcher namespaceWatcher1 = new NamespaceWatcher(null, watcher, ""/foo"");
-        NamespaceWatcher namespaceWatcher2 = new NamespaceWatcher(null, watcher, ""/foo"");
-        assertEquals(namespaceWatcher1, namespaceWatcher2);
-        assertFalse(namespaceWatcher1.equals(watcher));
-        assertFalse(watcher.equals(namespaceWatcher1));
-        Set<Watcher> set = Sets.newHashSet();
-        set.add(namespaceWatcher1);
-        set.add(namespaceWatcher2);
-        assertEquals(set.size(), 1);
-    }
-
-    @Test
-    public void testCuratorWatcher() throws Exception
-    {
-        Timing timing = new Timing();
-        CountCuratorWatcher watcher = new CountCuratorWatcher();
-        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));
-        try
-        {
-            client.start();
-            client.create().forPath(PATH);
-            // Add twice the same watcher on the same path
-            client.getData().usingWatcher(watcher).forPath(PATH);
-            client.getData().usingWatcher(watcher).forPath(PATH);
-            // Ok, let's test it
-            client.setData().forPath(PATH, new byte[]{});
-            timing.sleepABit();
-            assertEquals(1, watcher.count.get());
-        }
-        finally
-        {
-            CloseableUtils.closeQuietly(client);
-        }
-    }
-
-
-    @Test
-    public void testZKWatcher() throws Exception
-    {
-        Timing timing = new Timing();
-        CountZKWatcher watcher = new CountZKWatcher();
-        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));
-        try
-        {
-            client.start();
-            client.create().forPath(PATH);
-            // Add twice the same watcher on the same path
-            client.getData().usingWatcher(watcher).forPath(PATH);
-            client.getData().usingWatcher(watcher).forPath(PATH);
-            // Ok, let's test it
-            client.setData().forPath(PATH, new byte[]{});
-            timing.sleepABit();
-            assertEquals(1, watcher.count.get());
-        }
-        finally
-        {
-            CloseableUtils.closeQuietly(client);
-        }
-    }
+public class TestWatcherIdentity extends BaseClassForTests {
+	private static final String PATH = ""/foo"";
+
+	private static class CountZKWatcher implements Watcher {
+		private final AtomicInteger count = new AtomicInteger(0);
+
+		@Override
+		public void process(WatchedEvent event) {
+			count.incrementAndGet();
+		}
+	}
+
+	@Test
+	public void testSameWatcherPerZKDocs() throws Exception {
+		CountZKWatcher actualWatcher = new CountZKWatcher();
+		Timing timing = new Timing();
+		CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(),
+				timing.connection(), new RetryOneTime(1));
+		try {
+			client.start();
+			client.create().forPath(""/test"");
+
+			// per ZK docs, this watcher should only trigger once
+			client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
+			client.getData().usingWatcher(actualWatcher).forPath(""/test"");
+
+			client.setData().forPath(""/test"", ""foo"".getBytes());
+			client.delete().forPath(""/test"");
+			timing.sleepABit();
+			assertEquals(actualWatcher.count.getAndSet(0), 1);
+
+			client.create().forPath(""/test"");
+			client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
+			client.delete().forPath(""/test"");
+			timing.sleepABit();
+			assertEquals(actualWatcher.count.get(), 1);
+		} finally {
+			CloseableUtils.closeQuietly(client);
+		}
+	}
+
+	@Test
+	public void testSameCuratorWatcherPerZKDocs() throws Exception {
+		// Create variables for tracking behaviors of mock object
+		AtomicInteger actualWatcherCount = new AtomicInteger(0);
+		// Construct mock object
+		CuratorWatcher actualWatcher = mock(CuratorWatcher.class);
+		// Method Stubs
+		doAnswer((stubInvo) -> {
+			actualWatcherCount.incrementAndGet();
+			return null;
+		}).when(actualWatcher).process(any(WatchedEvent.class));
+		Timing timing = new Timing();
+		CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(),
+				timing.connection(), new RetryOneTime(1));
+		try {
+			client.start();
+			client.create().forPath(""/test"");
+
+			// per ZK docs, this watcher should only trigger once
+			client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
+			client.getData().usingWatcher(actualWatcher).forPath(""/test"");
+
+			client.setData().forPath(""/test"", ""foo"".getBytes());
+			client.delete().forPath(""/test"");
+			timing.sleepABit();
+			assertEquals(actualWatcherCount.getAndSet(0), 1);
+
+			client.create().forPath(""/test"");
+			client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
+			client.delete().forPath(""/test"");
+			timing.sleepABit();
+			assertEquals(actualWatcherCount.get(), 1);
+		} finally {
+			CloseableUtils.closeQuietly(client);
+		}
+	}
+
+	@Test
+	public void testSetAddition() {
+		Watcher watcher = new Watcher() {
+			@Override
+			public void process(WatchedEvent event) {
+
+			}
+		};
+		NamespaceWatcher namespaceWatcher1 = new NamespaceWatcher(null, watcher, ""/foo"");
+		NamespaceWatcher namespaceWatcher2 = new NamespaceWatcher(null, watcher, ""/foo"");
+		assertEquals(namespaceWatcher1, namespaceWatcher2);
+		assertFalse(namespaceWatcher1.equals(watcher));
+		assertFalse(watcher.equals(namespaceWatcher1));
+		Set<Watcher> set = Sets.newHashSet();
+		set.add(namespaceWatcher1);
+		set.add(namespaceWatcher2);
+		assertEquals(set.size(), 1);
+	}
+
+	@Test
+	public void testCuratorWatcher() throws Exception {
+		Timing timing = new Timing();
+		// Create variables for tracking behaviors of mock object
+		AtomicInteger watcherCount = new AtomicInteger(0);
+		// Construct mock object
+		CuratorWatcher watcher = mock(CuratorWatcher.class);
+		// Method Stubs
+		doAnswer((stubInvo) -> {
+			watcherCount.incrementAndGet();
+			return null;
+		}).when(watcher).process(any(WatchedEvent.class));
+		CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(),
+				timing.connection(), new RetryOneTime(1));
+		try {
+			client.start();
+			client.create().forPath(PATH);
+			// Add twice the same watcher on the same path
+			client.getData().usingWatcher(watcher).forPath(PATH);
+			client.getData().usingWatcher(watcher).forPath(PATH);
+			// Ok, let's test it
+			client.setData().forPath(PATH, new byte[] {});
+			timing.sleepABit();
+			assertEquals(1, watcherCount.get());
+		} finally {
+			CloseableUtils.closeQuietly(client);
+		}
+	}
+
+	@Test
+	public void testZKWatcher() throws Exception {
+		Timing timing = new Timing();
+		CountZKWatcher watcher = new CountZKWatcher();
+		CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(),
+				timing.connection(), new RetryOneTime(1));
+		try {
+			client.start();
+			client.create().forPath(PATH);
+			// Add twice the same watcher on the same path
+			client.getData().usingWatcher(watcher).forPath(PATH);
+			client.getData().usingWatcher(watcher).forPath(PATH);
+			// Ok, let's test it
+			client.setData().forPath(PATH, new byte[] {});
+			timing.sleepABit();","[{'comment': ""What about using Awaiatility and wait for the condition to become 'true'"", 'commenter': 'eolivelli'}, {'comment': ""Make sense to me, thanks for the suggestion, I'll use Awaiatility to replace timeing. "", 'commenter': 'wx930910'}]"
397,curator-framework/src/test/java/org/apache/curator/framework/imps/TestWatcherIdentity.java,"@@ -32,167 +38,152 @@
 import org.apache.zookeeper.Watcher;
 import org.junit.jupiter.api.Test;
 
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
+import com.google.common.collect.Sets;
 
-public class TestWatcherIdentity extends BaseClassForTests
-{
-    private static final String PATH = ""/foo"";
-
-    private static class CountCuratorWatcher implements CuratorWatcher
-    {
-        private final AtomicInteger count = new AtomicInteger(0);
-
-        @Override
-        public void process(WatchedEvent event) throws Exception
-        {
-            count.incrementAndGet();
-        }
-    }
-
-    private static class CountZKWatcher implements Watcher
-    {
-        private final AtomicInteger count = new AtomicInteger(0);
-
-        @Override
-        public void process(WatchedEvent event)
-        {
-            count.incrementAndGet();
-        }
-    }
-
-    @Test
-    public void testSameWatcherPerZKDocs() throws Exception
-    {
-        CountZKWatcher actualWatcher = new CountZKWatcher();
-        Timing timing = new Timing();
-        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));
-        try
-        {
-            client.start();
-            client.create().forPath(""/test"");
-
-            // per ZK docs, this watcher should only trigger once
-            client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
-            client.getData().usingWatcher(actualWatcher).forPath(""/test"");
-
-            client.setData().forPath(""/test"", ""foo"".getBytes());
-            client.delete().forPath(""/test"");
-            timing.sleepABit();
-            assertEquals(actualWatcher.count.getAndSet(0), 1);
-
-            client.create().forPath(""/test"");
-            client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
-            client.delete().forPath(""/test"");
-            timing.sleepABit();
-            assertEquals(actualWatcher.count.get(), 1);
-        }
-        finally
-        {
-            CloseableUtils.closeQuietly(client);
-        }
-    }
-
-    @Test
-    public void testSameCuratorWatcherPerZKDocs() throws Exception
-    {
-        CountCuratorWatcher actualWatcher = new CountCuratorWatcher();
-        Timing timing = new Timing();
-        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));
-        try
-        {
-            client.start();
-            client.create().forPath(""/test"");
-
-            // per ZK docs, this watcher should only trigger once
-            client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
-            client.getData().usingWatcher(actualWatcher).forPath(""/test"");
-
-            client.setData().forPath(""/test"", ""foo"".getBytes());
-            client.delete().forPath(""/test"");
-            timing.sleepABit();
-            assertEquals(actualWatcher.count.getAndSet(0), 1);
-
-            client.create().forPath(""/test"");
-            client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
-            client.delete().forPath(""/test"");
-            timing.sleepABit();
-            assertEquals(actualWatcher.count.get(), 1);
-        }
-        finally
-        {
-            CloseableUtils.closeQuietly(client);
-        }
-    }
-
-    @Test
-    public void testSetAddition()
-    {
-        Watcher watcher = new Watcher()
-        {
-            @Override
-            public void process(WatchedEvent event)
-            {
-
-            }
-        };
-        NamespaceWatcher namespaceWatcher1 = new NamespaceWatcher(null, watcher, ""/foo"");
-        NamespaceWatcher namespaceWatcher2 = new NamespaceWatcher(null, watcher, ""/foo"");
-        assertEquals(namespaceWatcher1, namespaceWatcher2);
-        assertFalse(namespaceWatcher1.equals(watcher));
-        assertFalse(watcher.equals(namespaceWatcher1));
-        Set<Watcher> set = Sets.newHashSet();
-        set.add(namespaceWatcher1);
-        set.add(namespaceWatcher2);
-        assertEquals(set.size(), 1);
-    }
-
-    @Test
-    public void testCuratorWatcher() throws Exception
-    {
-        Timing timing = new Timing();
-        CountCuratorWatcher watcher = new CountCuratorWatcher();
-        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));
-        try
-        {
-            client.start();
-            client.create().forPath(PATH);
-            // Add twice the same watcher on the same path
-            client.getData().usingWatcher(watcher).forPath(PATH);
-            client.getData().usingWatcher(watcher).forPath(PATH);
-            // Ok, let's test it
-            client.setData().forPath(PATH, new byte[]{});
-            timing.sleepABit();
-            assertEquals(1, watcher.count.get());
-        }
-        finally
-        {
-            CloseableUtils.closeQuietly(client);
-        }
-    }
-
-
-    @Test
-    public void testZKWatcher() throws Exception
-    {
-        Timing timing = new Timing();
-        CountZKWatcher watcher = new CountZKWatcher();
-        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));
-        try
-        {
-            client.start();
-            client.create().forPath(PATH);
-            // Add twice the same watcher on the same path
-            client.getData().usingWatcher(watcher).forPath(PATH);
-            client.getData().usingWatcher(watcher).forPath(PATH);
-            // Ok, let's test it
-            client.setData().forPath(PATH, new byte[]{});
-            timing.sleepABit();
-            assertEquals(1, watcher.count.get());
-        }
-        finally
-        {
-            CloseableUtils.closeQuietly(client);
-        }
-    }
+public class TestWatcherIdentity extends BaseClassForTests {
+	private static final String PATH = ""/foo"";
+
+	private static class CountZKWatcher implements Watcher {
+		private final AtomicInteger count = new AtomicInteger(0);
+
+		@Override
+		public void process(WatchedEvent event) {
+			count.incrementAndGet();
+		}
+	}
+
+	@Test
+	public void testSameWatcherPerZKDocs() throws Exception {
+		CountZKWatcher actualWatcher = new CountZKWatcher();
+		Timing timing = new Timing();
+		CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(),
+				timing.connection(), new RetryOneTime(1));
+		try {
+			client.start();
+			client.create().forPath(""/test"");
+
+			// per ZK docs, this watcher should only trigger once
+			client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
+			client.getData().usingWatcher(actualWatcher).forPath(""/test"");
+
+			client.setData().forPath(""/test"", ""foo"".getBytes());
+			client.delete().forPath(""/test"");
+			timing.sleepABit();
+			assertEquals(actualWatcher.count.getAndSet(0), 1);
+
+			client.create().forPath(""/test"");
+			client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
+			client.delete().forPath(""/test"");
+			timing.sleepABit();
+			assertEquals(actualWatcher.count.get(), 1);
+		} finally {
+			CloseableUtils.closeQuietly(client);
+		}
+	}
+
+	@Test
+	public void testSameCuratorWatcherPerZKDocs() throws Exception {
+		// Create variables for tracking behaviors of mock object
+		AtomicInteger actualWatcherCount = new AtomicInteger(0);
+		// Construct mock object
+		CuratorWatcher actualWatcher = mock(CuratorWatcher.class);
+		// Method Stubs
+		doAnswer((stubInvo) -> {
+			actualWatcherCount.incrementAndGet();
+			return null;
+		}).when(actualWatcher).process(any(WatchedEvent.class));","[{'comment': 'We can further improve test by removing the method stub and the AtomicInteger variable. We can directly verify the behavior of `process(WacthedEvent)` by using Mockito.verify() with timeout function (so we can also remove `timing.sleepABit()`). This will make test condition more explict and elegant.', 'commenter': 'wx930910'}]"
397,curator-framework/src/test/java/org/apache/curator/framework/imps/TestWatcherIdentity.java,"@@ -30,169 +36,141 @@
 import org.apache.curator.utils.CloseableUtils;
 import org.apache.zookeeper.WatchedEvent;
 import org.apache.zookeeper.Watcher;
+import org.awaitility.Awaitility;
 import org.junit.jupiter.api.Test;
+import org.mockito.Mockito;
 
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
+import com.google.common.collect.Sets;
 
-public class TestWatcherIdentity extends BaseClassForTests
-{
-    private static final String PATH = ""/foo"";
-
-    private static class CountCuratorWatcher implements CuratorWatcher
-    {
-        private final AtomicInteger count = new AtomicInteger(0);
-
-        @Override
-        public void process(WatchedEvent event) throws Exception
-        {
-            count.incrementAndGet();
-        }
-    }
-
-    private static class CountZKWatcher implements Watcher
-    {
-        private final AtomicInteger count = new AtomicInteger(0);
-
-        @Override
-        public void process(WatchedEvent event)
-        {
-            count.incrementAndGet();
-        }
-    }
-
-    @Test
-    public void testSameWatcherPerZKDocs() throws Exception
-    {
-        CountZKWatcher actualWatcher = new CountZKWatcher();
-        Timing timing = new Timing();
-        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));
-        try
-        {
-            client.start();
-            client.create().forPath(""/test"");
-
-            // per ZK docs, this watcher should only trigger once
-            client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
-            client.getData().usingWatcher(actualWatcher).forPath(""/test"");
-
-            client.setData().forPath(""/test"", ""foo"".getBytes());
-            client.delete().forPath(""/test"");
-            timing.sleepABit();
-            assertEquals(actualWatcher.count.getAndSet(0), 1);
-
-            client.create().forPath(""/test"");
-            client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
-            client.delete().forPath(""/test"");
-            timing.sleepABit();
-            assertEquals(actualWatcher.count.get(), 1);
-        }
-        finally
-        {
-            CloseableUtils.closeQuietly(client);
-        }
-    }
-
-    @Test
-    public void testSameCuratorWatcherPerZKDocs() throws Exception
-    {
-        CountCuratorWatcher actualWatcher = new CountCuratorWatcher();
-        Timing timing = new Timing();
-        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));
-        try
-        {
-            client.start();
-            client.create().forPath(""/test"");
-
-            // per ZK docs, this watcher should only trigger once
-            client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
-            client.getData().usingWatcher(actualWatcher).forPath(""/test"");
-
-            client.setData().forPath(""/test"", ""foo"".getBytes());
-            client.delete().forPath(""/test"");
-            timing.sleepABit();
-            assertEquals(actualWatcher.count.getAndSet(0), 1);
-
-            client.create().forPath(""/test"");
-            client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
-            client.delete().forPath(""/test"");
-            timing.sleepABit();
-            assertEquals(actualWatcher.count.get(), 1);
-        }
-        finally
-        {
-            CloseableUtils.closeQuietly(client);
-        }
-    }
-
-    @Test
-    public void testSetAddition()
-    {
-        Watcher watcher = new Watcher()
-        {
-            @Override
-            public void process(WatchedEvent event)
-            {
-
-            }
-        };
-        NamespaceWatcher namespaceWatcher1 = new NamespaceWatcher(null, watcher, ""/foo"");
-        NamespaceWatcher namespaceWatcher2 = new NamespaceWatcher(null, watcher, ""/foo"");
-        assertEquals(namespaceWatcher1, namespaceWatcher2);
-        assertFalse(namespaceWatcher1.equals(watcher));
-        assertFalse(watcher.equals(namespaceWatcher1));
-        Set<Watcher> set = Sets.newHashSet();
-        set.add(namespaceWatcher1);
-        set.add(namespaceWatcher2);
-        assertEquals(set.size(), 1);
-    }
-
-    @Test
-    public void testCuratorWatcher() throws Exception
-    {
-        Timing timing = new Timing();
-        CountCuratorWatcher watcher = new CountCuratorWatcher();
-        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));
-        try
-        {
-            client.start();
-            client.create().forPath(PATH);
-            // Add twice the same watcher on the same path
-            client.getData().usingWatcher(watcher).forPath(PATH);
-            client.getData().usingWatcher(watcher).forPath(PATH);
-            // Ok, let's test it
-            client.setData().forPath(PATH, new byte[]{});
-            timing.sleepABit();
-            assertEquals(1, watcher.count.get());
-        }
-        finally
-        {
-            CloseableUtils.closeQuietly(client);
-        }
-    }
-
-
-    @Test
-    public void testZKWatcher() throws Exception
-    {
-        Timing timing = new Timing();
-        CountZKWatcher watcher = new CountZKWatcher();
-        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));
-        try
-        {
-            client.start();
-            client.create().forPath(PATH);
-            // Add twice the same watcher on the same path
-            client.getData().usingWatcher(watcher).forPath(PATH);
-            client.getData().usingWatcher(watcher).forPath(PATH);
-            // Ok, let's test it
-            client.setData().forPath(PATH, new byte[]{});
-            timing.sleepABit();
-            assertEquals(1, watcher.count.get());
-        }
-        finally
-        {
-            CloseableUtils.closeQuietly(client);
-        }
-    }
+public class TestWatcherIdentity extends BaseClassForTests {
+	private static final String PATH = ""/foo"";
+	private static final int TIMEOUT_MS = 100000;
+
+	private static class CountZKWatcher implements Watcher {
+		private final AtomicInteger count = new AtomicInteger(0);
+
+		@Override
+		public void process(WatchedEvent event) {
+			count.incrementAndGet();
+		}
+	}
+
+	@Test
+	public void testSameWatcherPerZKDocs() throws Exception {
+		CountZKWatcher actualWatcher = new CountZKWatcher();
+		Timing timing = new Timing();
+		CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(),
+				timing.connection(), new RetryOneTime(1));
+		try {
+			client.start();
+			client.create().forPath(""/test"");
+
+			// per ZK docs, this watcher should only trigger once
+			client.checkExists().usingWatcher(actualWatcher).forPath(""/test"");
+			client.getData().usingWatcher(actualWatcher).forPath(""/test"");
+
+			client.setData().forPath(""/test"", ""foo"".getBytes());
+			client.delete().forPath(""/test"");
+			Awaitility.waitAtMost(Duration.ofMillis(TIMEOUT_MS))","[{'comment': 'We can use the default time out', 'commenter': 'eolivelli'}, {'comment': 'Changed `waitAtMost(Duration)` to `await()`', 'commenter': 'wx930910'}]"
398,curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java,"@@ -540,10 +540,17 @@ public String getLastPathIsLeader()
     @VisibleForTesting
     volatile CountDownLatch debugResetWaitLatch = null;
 
+    @VisibleForTesting
+    volatile CountDownLatch debugRestWaitBeforeNodeDelete = null;","[{'comment': ""```suggestion\r\n    volatile CountDownLatch debugResetWaitBeforeNodeDeleteLatch = null;\r\n```\r\nThere's a typo in the name. Additionally, we might want to add `Latch` at the end to reflect the purpose of this member analogously to the other latches."", 'commenter': 'XComp'}]"
398,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatch.java,"@@ -220,6 +223,108 @@ public void testWatchedNodeDeletedOnReconnect() throws Exception
         }
     }
 
+    @Test
+    public void testCheckLeaderShipTiming() throws Exception
+    {
+        final String latchPath = ""/test"";
+        Timing timing = new Timing();
+        List<LeaderLatch> latches = Lists.newArrayList();
+        List<CuratorFramework> clients = Lists.newArrayList();
+        final BlockingQueue<String> states = Queues.newLinkedBlockingQueue();
+        ExecutorService executorService = Executors.newFixedThreadPool(2);
+        for ( int i = 0; i < 2; ++i ) {
+            try {
+                CuratorFramework client = CuratorFrameworkFactory.builder()
+                        .connectString(server.getConnectString())
+                        .connectionTimeoutMs(10000)
+                        .sessionTimeoutMs(60000)
+                        .retryPolicy(new RetryOneTime(1))
+                        .connectionStateErrorPolicy(new StandardConnectionStateErrorPolicy())
+                        .build();
+                ConnectionStateListener stateListener = new ConnectionStateListener()
+                {
+                    @Override
+                    public void stateChanged(CuratorFramework client, ConnectionState newState)
+                    {
+                        if (newState == ConnectionState.CONNECTED) {
+                            states.add(newState.name());
+                        }
+                    }
+                };
+                client.getConnectionStateListenable().addListener(stateListener);
+                client.start();
+                clients.add(client);
+                LeaderLatch latch = new LeaderLatch(client, latchPath, String.valueOf(i));
+                LeaderLatchListener listener = new LeaderLatchListener() {
+                    @Override
+                    public void isLeader() {
+                        states.add(""true"");
+                    }
+
+                    @Override
+                    public void notLeader() {
+                        states.add(""false"");
+                    }
+                };
+                latch.addListener(listener);
+                latch.start();
+                latches.add(latch);
+                assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());
+                if (i == 0) {
+                    assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ""true"");
+                }
+            }
+            catch (Exception e){","[{'comment': ""Why are we hiding thrown exceptions here? Shouldn't we expose it as part of the test run if something went wrong? :thinking: The test would succeed if the Exception is thrown in this block and caught here."", 'commenter': 'XComp'}]"
398,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatch.java,"@@ -220,6 +223,108 @@ public void testWatchedNodeDeletedOnReconnect() throws Exception
         }
     }
 
+    @Test
+    public void testCheckLeaderShipTiming() throws Exception
+    {
+        final String latchPath = ""/test"";
+        Timing timing = new Timing();
+        List<LeaderLatch> latches = Lists.newArrayList();
+        List<CuratorFramework> clients = Lists.newArrayList();
+        final BlockingQueue<String> states = Queues.newLinkedBlockingQueue();
+        ExecutorService executorService = Executors.newFixedThreadPool(2);
+        for ( int i = 0; i < 2; ++i ) {
+            try {
+                CuratorFramework client = CuratorFrameworkFactory.builder()
+                        .connectString(server.getConnectString())
+                        .connectionTimeoutMs(10000)
+                        .sessionTimeoutMs(60000)
+                        .retryPolicy(new RetryOneTime(1))
+                        .connectionStateErrorPolicy(new StandardConnectionStateErrorPolicy())
+                        .build();
+                ConnectionStateListener stateListener = new ConnectionStateListener()
+                {
+                    @Override
+                    public void stateChanged(CuratorFramework client, ConnectionState newState)
+                    {
+                        if (newState == ConnectionState.CONNECTED) {
+                            states.add(newState.name());
+                        }
+                    }
+                };
+                client.getConnectionStateListenable().addListener(stateListener);
+                client.start();
+                clients.add(client);
+                LeaderLatch latch = new LeaderLatch(client, latchPath, String.valueOf(i));
+                LeaderLatchListener listener = new LeaderLatchListener() {
+                    @Override
+                    public void isLeader() {
+                        states.add(""true"");
+                    }
+
+                    @Override
+                    public void notLeader() {
+                        states.add(""false"");
+                    }
+                };
+                latch.addListener(listener);
+                latch.start();
+                latches.add(latch);
+                assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());
+                if (i == 0) {
+                    assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ""true"");","[{'comment': '```suggestion\r\n                    assertEquals(""The first LeaderLatch instance should acquire leadership."", states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ""true"");\r\n```\r\nnit: maybe adding a bit more context to this polling here to describe the test case', 'commenter': 'XComp'}]"
398,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatch.java,"@@ -220,6 +223,108 @@ public void testWatchedNodeDeletedOnReconnect() throws Exception
         }
     }
 
+    @Test
+    public void testCheckLeaderShipTiming() throws Exception
+    {
+        final String latchPath = ""/test"";
+        Timing timing = new Timing();
+        List<LeaderLatch> latches = Lists.newArrayList();
+        List<CuratorFramework> clients = Lists.newArrayList();
+        final BlockingQueue<String> states = Queues.newLinkedBlockingQueue();
+        ExecutorService executorService = Executors.newFixedThreadPool(2);
+        for ( int i = 0; i < 2; ++i ) {
+            try {
+                CuratorFramework client = CuratorFrameworkFactory.builder()
+                        .connectString(server.getConnectString())
+                        .connectionTimeoutMs(10000)
+                        .sessionTimeoutMs(60000)
+                        .retryPolicy(new RetryOneTime(1))
+                        .connectionStateErrorPolicy(new StandardConnectionStateErrorPolicy())
+                        .build();
+                ConnectionStateListener stateListener = new ConnectionStateListener()
+                {
+                    @Override
+                    public void stateChanged(CuratorFramework client, ConnectionState newState)
+                    {
+                        if (newState == ConnectionState.CONNECTED) {
+                            states.add(newState.name());
+                        }
+                    }
+                };
+                client.getConnectionStateListenable().addListener(stateListener);
+                client.start();
+                clients.add(client);
+                LeaderLatch latch = new LeaderLatch(client, latchPath, String.valueOf(i));
+                LeaderLatchListener listener = new LeaderLatchListener() {
+                    @Override
+                    public void isLeader() {
+                        states.add(""true"");
+                    }
+
+                    @Override
+                    public void notLeader() {
+                        states.add(""false"");
+                    }
+                };
+                latch.addListener(listener);
+                latch.start();
+                latches.add(latch);
+                assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());
+                if (i == 0) {
+                    assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ""true"");
+                }
+            }
+            catch (Exception e){
+                return;
+            }
+        }
+        timing.forWaiting().sleepABit();
+        // now latch1 is leader, latch2 is not leader. latch2 listens to the ephemeral node created by latch1","[{'comment': 'nit: Moving comments into assert messages improves the test output and still works as some kind of comment. This comment could be added to the `assertTrue` and `assertFalse` in line 284-285 below describing the currently expected state.', 'commenter': 'XComp'}]"
398,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatch.java,"@@ -220,6 +223,108 @@ public void testWatchedNodeDeletedOnReconnect() throws Exception
         }
     }
 
+    @Test
+    public void testCheckLeaderShipTiming() throws Exception
+    {
+        final String latchPath = ""/test"";
+        Timing timing = new Timing();
+        List<LeaderLatch> latches = Lists.newArrayList();
+        List<CuratorFramework> clients = Lists.newArrayList();
+        final BlockingQueue<String> states = Queues.newLinkedBlockingQueue();
+        ExecutorService executorService = Executors.newFixedThreadPool(2);
+        for ( int i = 0; i < 2; ++i ) {
+            try {
+                CuratorFramework client = CuratorFrameworkFactory.builder()
+                        .connectString(server.getConnectString())
+                        .connectionTimeoutMs(10000)
+                        .sessionTimeoutMs(60000)
+                        .retryPolicy(new RetryOneTime(1))
+                        .connectionStateErrorPolicy(new StandardConnectionStateErrorPolicy())
+                        .build();
+                ConnectionStateListener stateListener = new ConnectionStateListener()
+                {
+                    @Override
+                    public void stateChanged(CuratorFramework client, ConnectionState newState)
+                    {
+                        if (newState == ConnectionState.CONNECTED) {
+                            states.add(newState.name());
+                        }
+                    }
+                };
+                client.getConnectionStateListenable().addListener(stateListener);
+                client.start();
+                clients.add(client);
+                LeaderLatch latch = new LeaderLatch(client, latchPath, String.valueOf(i));
+                LeaderLatchListener listener = new LeaderLatchListener() {
+                    @Override
+                    public void isLeader() {
+                        states.add(""true"");
+                    }
+
+                    @Override
+                    public void notLeader() {
+                        states.add(""false"");
+                    }
+                };
+                latch.addListener(listener);
+                latch.start();
+                latches.add(latch);
+                assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());
+                if (i == 0) {
+                    assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ""true"");
+                }
+            }
+            catch (Exception e){
+                return;
+            }
+        }
+        timing.forWaiting().sleepABit();
+        // now latch1 is leader, latch2 is not leader. latch2 listens to the ephemeral node created by latch1
+        LeaderLatch latch1 = latches.get(0);
+        LeaderLatch latch2 = latches.get(1);
+        assertTrue(latch1.hasLeadership());
+        assertFalse(latch2.hasLeadership());
+        try {
+            latch2.debugRestWaitBeforeNodeDelete = new CountDownLatch(1);
+            latch2.debugResetWaitLatch = new CountDownLatch(1);
+            latch1.debugResetWaitLatch = new CountDownLatch(1);
+
+            // force latch1 and latch2 reset
+            latch1.reset();
+            ForkJoinPool.commonPool().submit(() -> {","[{'comment': ""Should we add a comment here on why we're calling `latch2.reset()` in a separate thread? AFAIU, it's done to not make the test's thread block due to `latch2.debugRestWaitBeforeNodeDelete`. It might help readers if this is reflected in a comment here. WDYT?"", 'commenter': 'XComp'}]"
398,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatch.java,"@@ -220,6 +223,108 @@ public void testWatchedNodeDeletedOnReconnect() throws Exception
         }
     }
 
+    @Test
+    public void testCheckLeaderShipTiming() throws Exception
+    {
+        final String latchPath = ""/test"";
+        Timing timing = new Timing();
+        List<LeaderLatch> latches = Lists.newArrayList();
+        List<CuratorFramework> clients = Lists.newArrayList();
+        final BlockingQueue<String> states = Queues.newLinkedBlockingQueue();
+        ExecutorService executorService = Executors.newFixedThreadPool(2);
+        for ( int i = 0; i < 2; ++i ) {
+            try {
+                CuratorFramework client = CuratorFrameworkFactory.builder()
+                        .connectString(server.getConnectString())
+                        .connectionTimeoutMs(10000)
+                        .sessionTimeoutMs(60000)
+                        .retryPolicy(new RetryOneTime(1))
+                        .connectionStateErrorPolicy(new StandardConnectionStateErrorPolicy())
+                        .build();
+                ConnectionStateListener stateListener = new ConnectionStateListener()
+                {
+                    @Override
+                    public void stateChanged(CuratorFramework client, ConnectionState newState)
+                    {
+                        if (newState == ConnectionState.CONNECTED) {
+                            states.add(newState.name());","[{'comment': 'nit: Adding the `LeaderLatch` ID (we could use for loop `i`) here might help further down in the test understanding the state of the queue.', 'commenter': 'XComp'}]"
398,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatch.java,"@@ -220,6 +223,108 @@ public void testWatchedNodeDeletedOnReconnect() throws Exception
         }
     }
 
+    @Test
+    public void testCheckLeaderShipTiming() throws Exception
+    {
+        final String latchPath = ""/test"";
+        Timing timing = new Timing();
+        List<LeaderLatch> latches = Lists.newArrayList();
+        List<CuratorFramework> clients = Lists.newArrayList();
+        final BlockingQueue<String> states = Queues.newLinkedBlockingQueue();
+        ExecutorService executorService = Executors.newFixedThreadPool(2);
+        for ( int i = 0; i < 2; ++i ) {
+            try {
+                CuratorFramework client = CuratorFrameworkFactory.builder()
+                        .connectString(server.getConnectString())
+                        .connectionTimeoutMs(10000)
+                        .sessionTimeoutMs(60000)
+                        .retryPolicy(new RetryOneTime(1))
+                        .connectionStateErrorPolicy(new StandardConnectionStateErrorPolicy())
+                        .build();
+                ConnectionStateListener stateListener = new ConnectionStateListener()
+                {
+                    @Override
+                    public void stateChanged(CuratorFramework client, ConnectionState newState)
+                    {
+                        if (newState == ConnectionState.CONNECTED) {
+                            states.add(newState.name());
+                        }
+                    }
+                };
+                client.getConnectionStateListenable().addListener(stateListener);
+                client.start();
+                clients.add(client);
+                LeaderLatch latch = new LeaderLatch(client, latchPath, String.valueOf(i));
+                LeaderLatchListener listener = new LeaderLatchListener() {
+                    @Override
+                    public void isLeader() {
+                        states.add(""true"");
+                    }
+
+                    @Override
+                    public void notLeader() {
+                        states.add(""false"");
+                    }
+                };","[{'comment': ""Using the `LeaderLatch` ID in the event labels (as mentioned above) might help when evaluating the queue later on in the test. But to be fair: doing the asserts on `hasLeadership` like it's already done below (lines 303-304) serves the same purpose. I just mention it as another idea here. :shrug: "", 'commenter': 'XComp'}]"
398,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatch.java,"@@ -220,6 +223,108 @@ public void testWatchedNodeDeletedOnReconnect() throws Exception
         }
     }
 
+    @Test
+    public void testCheckLeaderShipTiming() throws Exception
+    {
+        final String latchPath = ""/test"";
+        Timing timing = new Timing();
+        List<LeaderLatch> latches = Lists.newArrayList();
+        List<CuratorFramework> clients = Lists.newArrayList();
+        final BlockingQueue<String> states = Queues.newLinkedBlockingQueue();
+        ExecutorService executorService = Executors.newFixedThreadPool(2);
+        for ( int i = 0; i < 2; ++i ) {
+            try {
+                CuratorFramework client = CuratorFrameworkFactory.builder()
+                        .connectString(server.getConnectString())
+                        .connectionTimeoutMs(10000)
+                        .sessionTimeoutMs(60000)
+                        .retryPolicy(new RetryOneTime(1))
+                        .connectionStateErrorPolicy(new StandardConnectionStateErrorPolicy())
+                        .build();
+                ConnectionStateListener stateListener = new ConnectionStateListener()
+                {
+                    @Override
+                    public void stateChanged(CuratorFramework client, ConnectionState newState)
+                    {
+                        if (newState == ConnectionState.CONNECTED) {
+                            states.add(newState.name());
+                        }
+                    }
+                };
+                client.getConnectionStateListenable().addListener(stateListener);
+                client.start();
+                clients.add(client);
+                LeaderLatch latch = new LeaderLatch(client, latchPath, String.valueOf(i));
+                LeaderLatchListener listener = new LeaderLatchListener() {
+                    @Override
+                    public void isLeader() {
+                        states.add(""true"");
+                    }
+
+                    @Override
+                    public void notLeader() {
+                        states.add(""false"");
+                    }
+                };
+                latch.addListener(listener);
+                latch.start();
+                latches.add(latch);
+                assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());
+                if (i == 0) {
+                    assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ""true"");
+                }
+            }
+            catch (Exception e){
+                return;
+            }
+        }
+        timing.forWaiting().sleepABit();
+        // now latch1 is leader, latch2 is not leader. latch2 listens to the ephemeral node created by latch1
+        LeaderLatch latch1 = latches.get(0);
+        LeaderLatch latch2 = latches.get(1);","[{'comment': ""```suggestion\r\n        LeaderLatch initialLeaderLatch = latches.get(0);\r\n        LeaderLatch initialNonLeaderLatch = latches.get(1);\r\n```\r\nnit: maybe, making the variable more descriptive to avoid confusion. Especially because we're switching the order here in comparison to what is described in the PR description and the corresponding ticket."", 'commenter': 'XComp'}]"
398,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatch.java,"@@ -220,6 +223,108 @@ public void testWatchedNodeDeletedOnReconnect() throws Exception
         }
     }
 
+    @Test
+    public void testCheckLeaderShipTiming() throws Exception
+    {
+        final String latchPath = ""/test"";
+        Timing timing = new Timing();
+        List<LeaderLatch> latches = Lists.newArrayList();
+        List<CuratorFramework> clients = Lists.newArrayList();
+        final BlockingQueue<String> states = Queues.newLinkedBlockingQueue();
+        ExecutorService executorService = Executors.newFixedThreadPool(2);
+        for ( int i = 0; i < 2; ++i ) {
+            try {
+                CuratorFramework client = CuratorFrameworkFactory.builder()
+                        .connectString(server.getConnectString())
+                        .connectionTimeoutMs(10000)
+                        .sessionTimeoutMs(60000)
+                        .retryPolicy(new RetryOneTime(1))
+                        .connectionStateErrorPolicy(new StandardConnectionStateErrorPolicy())
+                        .build();
+                ConnectionStateListener stateListener = new ConnectionStateListener()
+                {
+                    @Override
+                    public void stateChanged(CuratorFramework client, ConnectionState newState)
+                    {
+                        if (newState == ConnectionState.CONNECTED) {
+                            states.add(newState.name());
+                        }
+                    }
+                };
+                client.getConnectionStateListenable().addListener(stateListener);
+                client.start();
+                clients.add(client);
+                LeaderLatch latch = new LeaderLatch(client, latchPath, String.valueOf(i));
+                LeaderLatchListener listener = new LeaderLatchListener() {
+                    @Override
+                    public void isLeader() {
+                        states.add(""true"");
+                    }
+
+                    @Override
+                    public void notLeader() {
+                        states.add(""false"");
+                    }
+                };
+                latch.addListener(listener);
+                latch.start();
+                latches.add(latch);
+                assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());
+                if (i == 0) {
+                    assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ""true"");
+                }
+            }
+            catch (Exception e){
+                return;
+            }
+        }
+        timing.forWaiting().sleepABit();","[{'comment': ""What's the purpose of waiting here? :thinking: "", 'commenter': 'XComp'}]"
401,curator-recipes/src/main/java/org/apache/curator/framework/recipes/queue/ChildrenCache.java,"@@ -86,12 +101,14 @@ private Data(List<String> children, long version)
 
     void start() throws Exception
     {
-        sync(true);
+        client.getConnectionStateListenable().addListener(connectionStateListener);
+        sync();
     }
 
     @Override
     public void close() throws IOException
     {
+        client.getConnectionStateListenable().removeListener(connectionStateListener);","[{'comment': 'Should not this be after `client.removeWatchers()`, in reverse order with `#start()`?', 'commenter': 'faucct'}]"
401,curator-recipes/src/main/java/org/apache/curator/framework/recipes/queue/ChildrenCache.java,"@@ -66,6 +68,19 @@ public void processResult(CuratorFramework client, CuratorEvent event) throws Ex
         }
     };
 
+    private final ConnectionStateListener connectionStateListener = (__, newState) -> {
+        if ((newState == ConnectionState.CONNECTED) || (newState == ConnectionState.RECONNECTED)) {
+            try
+            {
+                sync();
+            }
+            catch ( Exception e )
+            {
+                throw new RuntimeException(e);","[{'comment': 'will this error be logged somewhere ?\r\nas we cannot perform any recovery\r\nwill it make more sense to simply log the exception and do not rethrow it ?\r\n', 'commenter': 'eolivelli'}, {'comment': ""Yeah, it logs. It's not very obvious but these are handled by `MappingListenerManager` (see https://github.com/apache/curator/blob/master/curator-framework/src/main/java/org/apache/curator/framework/listen/MappingListenerManager.java#L85)"", 'commenter': 'Randgalt'}]"
410,curator-framework/src/main/java/org/apache/curator/framework/imps/GzipCompressionProvider.java,"@@ -45,6 +45,23 @@
     /** GZIP header magic number. */
     private static final int GZIP_MAGIC = 0x8b1f;
 
+    private static final String JAVA_VERSION_STR = System.getProperty(""java.version"", ""-1"");
+    private static final int JAVA_VERSION;
+    static {
+        if (""1.8"".equals(JAVA_VERSION_STR)) {
+            JAVA_VERSION = 8;
+        } else if (JAVA_VERSION_STR.contains(""-"")) {
+            // e.g. 18-ea, take 18
+            JAVA_VERSION = Integer.parseInt(JAVA_VERSION_STR.split(""-"", 2)[0]);
+        } else if (JAVA_VERSION_STR.contains(""."")) {
+            // e.g. 17.0.1, take 17
+            JAVA_VERSION = Integer.parseInt(JAVA_VERSION_STR.split(""\\."", 2)[0]);
+        } else {
+            JAVA_VERSION = Integer.parseInt(JAVA_VERSION_STR, 10);
+        }
+    }
+    private static final byte OS_BIT = JAVA_VERSION >= 16 ? (byte) -1 : 0;","[{'comment': 'could you add a comment explaining why this is needed ? ', 'commenter': 'nicoloboschi'}, {'comment': ""I just reverse engineered it.\r\nI don't know what exactly has changed in JDK 16 that caused the breakage here.\r\nThis is the reason I said `I'd recommend a deeper look here!`. Someone who knows this code better may have better idea what is going on."", 'commenter': 'martin-g'}, {'comment': 'I think this is the related issue \r\nhttps://bugs.openjdk.java.net/browse/JDK-8244706\r\n', 'commenter': 'nicoloboschi'}, {'comment': 'I will add it as a comment!', 'commenter': 'martin-g'}]"
430,curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java,"@@ -604,7 +604,7 @@ else if ( ourIndex == 0 )
                 @Override
                 public void process(WatchedEvent event)
                 {
-                    if ( (state.get() == State.STARTED) && (event.getType() == Event.EventType.NodeDeleted) && (localOurPath != null) )","[{'comment': 'In this situation `localOurPath` must be not null.', 'commenter': 'tisonkun'}, {'comment': 'Good point. Due to the condition in [LeaderLatch:588](https://github.com/apache/curator/blob/425598cb6bf6a5b227a5fdd293fe46c7978d6578/curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java#L588), `ourIndex` must be `-1` if `localOurPath` is actually `null` and, therefore, would prevent the execution from reaching the `else` branch (instead the if condition in [LeaderLatch:592](https://github.com/apache/curator/blob/425598cb6bf6a5b227a5fdd293fe46c7978d6578/curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java#L592) applies) where the watcher is set.', 'commenter': 'XComp'}]"
430,curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java,"@@ -667,9 +667,9 @@ protected void handleStateChange(ConnectionState newState)
             {
                 try
                 {
-                    if ( client.getConnectionStateErrorPolicy().isErrorState(ConnectionState.SUSPENDED) || !hasLeadership.get() )","[{'comment': '`getChildren` does nothing if we still hold leadership. And actually even if `hasLeadership` is true, we can say nothing if we coming back from a connection error.', 'commenter': 'tisonkun'}]"
430,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatch.java,"@@ -218,6 +218,30 @@ public void testWatchedNodeDeletedOnReconnect() throws Exception
         }
     }
 
+    @Test
+    public void testOurPathDeletedOnReconnect() throws Exception","[{'comment': 'This test can pass on master with 3 nodes created, while with this patch there are 2 nodes created.', 'commenter': 'tisonkun'}, {'comment': 'The test is not suitable for the change. I reverted the change and ran the test. The test still succeeded.', 'commenter': 'XComp'}, {'comment': ""Yes. As described. I don't find a good test case yet :/"", 'commenter': 'tisonkun'}, {'comment': 'What do you think of the following test (I updated the test a bit):\r\n```\r\n    @Test\r\n    public void testLeadershipElectionWhenNodeDisappearsAfterChildrenAreRetrieved() throws Exception\r\n    {\r\n        final String latchPath = ""/foo/bar"";\r\n        final Timing2 timing = new Timing2();\r\n        try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1)))\r\n        {\r\n            client.start();\r\n            LeaderLatch latchInitialLeader = new LeaderLatch(client, latchPath, ""initial-leader"");\r\n            LeaderLatch latchCandidate0 = new LeaderLatch(client, latchPath, ""candidate-0"");\r\n            LeaderLatch latchCandidate1 = new LeaderLatch(client, latchPath, ""candidate-1"");\r\n\r\n            try\r\n            {\r\n                latchInitialLeader.start();\r\n\r\n                // we want to make sure that the leader gets leadership before other instances joining the party\r\n                waitForALeader(Collections.singletonList(latchInitialLeader), new Timing());\r\n\r\n                // candidate #0 will wait for the leader to go away - this should happen after the child nodes are retrieved by candidate #0\r\n                latchCandidate0.debugCheckLeaderShipLatch = new CountDownLatch(1);\r\n\r\n                latchCandidate0.start();\r\n                timing.sleepABit();\r\n\r\n                // no extract CountDownLatch needs to be set here because candidate #1 will rely on candidate #0\r\n                latchCandidate1.start();\r\n                timing.sleepABit();\r\n\r\n                // triggers the removal of the corresponding child node after candidate #0 retrieved the children\r\n                latchInitialLeader.close();\r\n\r\n                latchCandidate0.debugCheckLeaderShipLatch.countDown();\r\n\r\n                waitForALeader(Arrays.asList(latchCandidate0, latchCandidate1), new Timing());\r\n\r\n                assertTrue(latchCandidate0.hasLeadership() ^ latchCandidate1.hasLeadership());\r\n            } finally\r\n            {\r\n                for (LeaderLatch latchToClose : Arrays.asList(latchInitialLeader, latchCandidate0, latchCandidate1))\r\n                {\r\n                    if ( latchToClose.getState() != LeaderLatch.State.CLOSED )\r\n                    {\r\n                        latchToClose.close();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    \r\n```\r\n\r\nThis test case describes the situation for [CURATOR-645](https://issues.apache.org/jira/browse/CURATOR-645). I checked in a local test run, that it will run forever when still using `reset()` in [LeaderLatch:633](https://github.com/apache/curator/blob/425598cb6bf6a5b227a5fdd293fe46c7978d6578/curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java#L633) but would succeed when using `getChildren()`, instead.', 'commenter': 'XComp'}, {'comment': 'Thanks! Integrated.', 'commenter': 'tisonkun'}]"
430,curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java,"@@ -667,9 +670,9 @@ protected void handleStateChange(ConnectionState newState)
             {
                 try
                 {
-                    if ( client.getConnectionStateErrorPolicy().isErrorState(ConnectionState.SUSPENDED) || !hasLeadership.get() )","[{'comment': ""I'm wondering whether we should remove this `if` entirely: Let's assume the current instance doesn't have the leadership but watches the child node referring to the current leader. If the connection was temporarily suspended it could be that the actual leader lost its leadership in the meantime. In that case, we want the current instance to check the leadership. :thinking: "", 'commenter': 'XComp'}, {'comment': ""But thinking about it once more, this might not be an issue because the current LeaderLatch would have a watcher on the current leader's node which would have been triggered when the leader's child would have been deleted. :thinking: "", 'commenter': 'XComp'}, {'comment': ""It's for backward compatibility that once we treat ConnectionLoss as ErrorState. I agree with that since we don't give up the leadership (`reset`) actively, we can remove the `if` condition (but still keep `getChildren`, of course).\r\n\r\nHowever, it can be a follow-up improvement that doesn't affect the correctness. You're welcome to make the patch."", 'commenter': 'tisonkun'}, {'comment': ""If you take a look at FLINK-10052, the final solution is using a SessionErrorPolicy that will skip this `if` block. Since a ConnectionLoss may be only network unstable instead of the node lost its leadership (the ephemeral node). Before this patch it's `reset` to be called and actively give up the leadership, it will cause reelection, increase ZK workload and cause further inconsistency.\r\n\r\nThe thorough solution should be something like I proposed in https://github.com/apache/flink/pull/9878, but I failed to contribute it to the upstream (FLINK-10052 takes more than 2 years to be merged. It's not a good experience to me, lol). We run with the solution in Tencent for years and it works well :)"", 'commenter': 'tisonkun'}]"
430,curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java,"@@ -717,6 +720,7 @@ else if ( !oldValue && newValue )
     private void setNode(String newValue) throws Exception
     {
         String oldPath = ourPath.getAndSet(newValue);
+        log.debug(""setNode with oldPath: {}, newValue: {}"", oldPath, newValue);","[{'comment': '```suggestion\r\n        log.debug(""setNode in {}, with oldPath: {}, newValue: {}"", id, oldPath, newValue);\r\n```\r\nAdding the ID helps when debugging tests that run multiple `LeaderLatch` instances locally.', 'commenter': 'XComp'}, {'comment': 'Updated.', 'commenter': 'tisonkun'}]"
430,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatch.java,"@@ -218,6 +218,56 @@ public void testWatchedNodeDeletedOnReconnect() throws Exception
         }
     }
 
+    @Test
+    public void testLeadershipElectionWhenNodeDisappearsAfterChildrenAreRetrieved() throws Exception
+    {
+        final String latchPath = ""/foo/bar"";
+        final Timing2 timing = new Timing2();
+        try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1)))
+        {
+            client.start();
+            LeaderLatch latchInitialLeader = new LeaderLatch(client, latchPath, ""initial-leader"");
+            LeaderLatch latchCandidate0 = new LeaderLatch(client, latchPath, ""candidate-0"");
+            LeaderLatch latchCandidate1 = new LeaderLatch(client, latchPath, ""candidate-1"");
+
+            try
+            {
+                latchInitialLeader.start();
+
+                // we want to make sure that the leader gets leadership before other instances joining the party
+                waitForALeader(Collections.singletonList(latchInitialLeader), new Timing());
+
+                // candidate #0 will wait for the leader to go away - this should happen after the child nodes are retrieved by candidate #0
+                latchCandidate0.debugCheckLeaderShipLatch = new CountDownLatch(1);
+
+                latchCandidate0.start();
+                timing.sleepABit();
+
+                // no extract CountDownLatch needs to be set here because candidate #1 will rely on candidate #0","[{'comment': '```suggestion\r\n                // no extra CountDownLatch needs to be set here because candidate #1 will rely on candidate #0\r\n```\r\ntypo', 'commenter': 'XComp'}]"
430,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatch.java,"@@ -218,6 +218,56 @@ public void testWatchedNodeDeletedOnReconnect() throws Exception
         }
     }
 
+    @Test
+    public void testLeadershipElectionWhenNodeDisappearsAfterChildrenAreRetrieved() throws Exception
+    {
+        final String latchPath = ""/foo/bar"";
+        final Timing2 timing = new Timing2();
+        try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1)))
+        {
+            client.start();
+            LeaderLatch latchInitialLeader = new LeaderLatch(client, latchPath, ""initial-leader"");
+            LeaderLatch latchCandidate0 = new LeaderLatch(client, latchPath, ""candidate-0"");
+            LeaderLatch latchCandidate1 = new LeaderLatch(client, latchPath, ""candidate-1"");
+
+            try
+            {
+                latchInitialLeader.start();
+
+                // we want to make sure that the leader gets leadership before other instances joining the party","[{'comment': '```suggestion\r\n                // we want to make sure that the leader gets leadership before other instances are joining the party\r\n```\r\nand another typo', 'commenter': 'XComp'}]"
430,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatch.java,"@@ -218,6 +218,56 @@ public void testWatchedNodeDeletedOnReconnect() throws Exception
         }
     }
 
+    @Test
+    public void testLeadershipElectionWhenNodeDisappearsAfterChildrenAreRetrieved() throws Exception
+    {
+        final String latchPath = ""/foo/bar"";
+        final Timing2 timing = new Timing2();
+        try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1)))
+        {
+            client.start();
+            LeaderLatch latchInitialLeader = new LeaderLatch(client, latchPath, ""initial-leader"");
+            LeaderLatch latchCandidate0 = new LeaderLatch(client, latchPath, ""candidate-0"");
+            LeaderLatch latchCandidate1 = new LeaderLatch(client, latchPath, ""candidate-1"");
+
+            try
+            {
+                latchInitialLeader.start();
+
+                // we want to make sure that the leader gets leadership before other instances joining the party
+                waitForALeader(Collections.singletonList(latchInitialLeader), new Timing());
+
+                // candidate #0 will wait for the leader to go away - this should happen after the child nodes are retrieved by candidate #0
+                latchCandidate0.debugCheckLeaderShipLatch = new CountDownLatch(1);
+
+                latchCandidate0.start();
+                timing.sleepABit();","[{'comment': ""tbh, I'm not really happy with the sleep here and in [line 248](https://github.com/apache/curator/pull/430/files#diff-75966280cab1f9788b771d244e889731ba35c7918d365c070565e070d5b801ebR248) because they are a cause for instabilities: The `close` in [line 251](https://github.com/apache/curator/pull/430/files#diff-75966280cab1f9788b771d244e889731ba35c7918d365c070565e070d5b801ebR251) has to happen after the child nodes for `candidate #0` and `candidate #1` are created. AFAIU, we cannot ensure that with the sleep calls due to the asynchronous nature of the `start` command that is triggered right before each sleep.\r\nI tried to add a `waitForCondition` instead, when coming up with this test, initially, that would wait for corresponding child to be created. Unfortunately, this resulted in the test blocking forever because (I guess) the await on the `latchCandidate0.debugCheckLeaderShipLatch` is blocking the thread that executes the `CuratorFrameworkImpl#backgroundOperations` queue which makes any subsequent operation (including the check for children nodes) on the same client being blocked as well.\r\n\r\nI hoped that somebody else could come up with a better approach here. :thinking: "", 'commenter': 'XComp'}, {'comment': ""I found a better solution for that by introducing another ZK client that is used for monitoring the children. That way, we don't end up being blocked on concurrent calls in the actual test. I'm gonna propose the change in a separate review."", 'commenter': 'XComp'}, {'comment': ""@XComp sounds interesting. You can directly make a PR against this patch branch and I'll review it. Sorry that I may not have too much time recently to cooperate on this patch :)"", 'commenter': 'tisonkun'}]"
430,curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java,"@@ -586,6 +586,9 @@ private void checkLeadership(List<String> children) throws Exception
         final String localOurPath = ourPath.get();
         List<String> sortedChildren = LockInternals.getSortedChildren(LOCK_NAME, sorter, children);
         int ourIndex = (localOurPath != null) ? sortedChildren.indexOf(ZKPaths.getNodeFromPath(localOurPath)) : -1;
+
+        log.debug(""checkLeadership with ourPath: {}, children: {}"", localOurPath, sortedChildren);","[{'comment': '```suggestion\r\n        log.debug(""[{}] checkLeadership with ourPath: {}, children: {}"", id, localOurPath, sortedChildren);\r\n```', 'commenter': 'XComp'}, {'comment': 'Updated in cc4c148a1ee3d6513f4b9f2b5fe462caee8e41fe.', 'commenter': 'tisonkun'}]"
430,curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatch.java,"@@ -218,6 +218,56 @@ public void testWatchedNodeDeletedOnReconnect() throws Exception
         }
     }
 
+    @Test
+    public void testLeadershipElectionWhenNodeDisappearsAfterChildrenAreRetrieved() throws Exception
+    {
+        final String latchPath = ""/foo/bar"";
+        final Timing2 timing = new Timing2();
+        try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1)))
+        {
+            client.start();
+            LeaderLatch latchInitialLeader = new LeaderLatch(client, latchPath, ""initial-leader"");
+            LeaderLatch latchCandidate0 = new LeaderLatch(client, latchPath, ""candidate-0"");
+            LeaderLatch latchCandidate1 = new LeaderLatch(client, latchPath, ""candidate-1"");
+
+            try
+            {
+                latchInitialLeader.start();
+
+                // we want to make sure that the leader gets leadership before other instances are joining the party
+                waitForALeader(Collections.singletonList(latchInitialLeader), new Timing());
+
+                // candidate #0 will wait for the leader to go away - this should happen after the child nodes are retrieved by candidate #0
+                latchCandidate0.debugCheckLeaderShipLatch = new CountDownLatch(1);
+
+                latchCandidate0.start();
+                timing.sleepABit();
+
+                // no extra CountDownLatch needs to be set here because candidate #1 will rely on candidate #0
+                latchCandidate1.start();
+                timing.sleepABit();","[{'comment': '```suggestion\r\n                // we want to make sure that the leader gets leadership before other instances are going to join the party\r\n                waitForALeader(Collections.singletonList(latchInitialLeader), new Timing());\r\n\r\n                // candidate #0 will wait for the leader to go away - this should happen after the child nodes are retrieved by candidate #0\r\n                latchCandidate0.debugCheckLeaderShipLatch = new CountDownLatch(1);\r\n                latchCandidate0.start();\r\n                \r\n                final int expectedChildrenAfterCandidate0Joins = 2;\r\n                Awaitility.await(""There should be "" + expectedChildrenAfterCandidate0Joins + "" child nodes created after candidate #0 joins the leader election."")\r\n                    .pollInterval(Duration.ofMillis(100))\r\n                    .pollInSameThread()\r\n                    .until(() -> client.getChildren().forPath(latchPath).size() == expectedChildrenAfterCandidate0Joins);\r\n\r\n                // no extra CountDownLatch needs to be set here because candidate #1 will rely on candidate #0\r\n                latchCandidate1.start();\r\n                \r\n                final int expectedChildrenAfterCandidate1Joins = 3;\r\n                Awaitility.await(""There should be "" + expectedChildrenAfterCandidate1Joins + "" child nodes created after candidate #1 joins the leader election."")\r\n                    .pollInterval(Duration.ofMillis(100))\r\n                    .pollInSameThread()\r\n                    .until(() -> client.getChildren().forPath(latchPath).size() == expectedChildrenAfterCandidate1Joins);\r\n```\r\nInitially, I played around with checking the `ourPath` of each `LeaderLatch` instance. This didn\'t work, because that field is set in a `BackgroundCallback` (see [LeaderLatch:540](https://github.com/apache/curator/blob/2775855fc80fdea8433d5dedbb746f58ddd443c4/curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java#L540)). The background tasks are handled in the `EventThread` of the ZK client. That one is already blocked by the `CountdownLatch` of candidate #0. \r\n\r\nBut we could still use the `SendThread` which is used for outgoing commands. That\'s why calling `.getChildren` on the client itself still works and is sufficient enough to verify that the child nodes are actually created.', 'commenter': 'XComp'}, {'comment': 'You need to add `Awaitility` to the pom of the `curator-recipes` module:\r\n```\r\n        <dependency>\r\n            <groupId>org.awaitility</groupId>\r\n            <artifactId>awaitility</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n```', 'commenter': 'XComp'}, {'comment': 'Resolved.', 'commenter': 'tisonkun'}]"
430,curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java,"@@ -667,9 +670,9 @@ protected void handleStateChange(ConnectionState newState)
             {
                 try
                 {
-                    if ( client.getConnectionStateErrorPolicy().isErrorState(ConnectionState.SUSPENDED) || !hasLeadership.get() )
+                    if ( client.getConnectionStateErrorPolicy().isErrorState(ConnectionState.SUSPENDED) )
                     {
-                        reset();
+                        getChildren();","[{'comment': ""I'm not convinced anymore that this change is correct. Here, we're covering the case where `ConnectionState.SUSPENDED` is considered an error state, i.e. the leadership is lost if the connection was suspended. In that case, we should do a reset because we're considering the leadership being lost already due to the connection instability having caused an error.\r\n\r\nInstead, we should add an `else` branch that does the `getChildren` call in case of a reconnect and the policy is allowing reconnects after suspension."", 'commenter': 'XComp'}, {'comment': ""Ok, after revisiting your response in [that thread earlier in this PR](https://github.com/apache/curator/pull/430#discussion_r967852427), I notice again that `getChildren` is the proper way of doing it:\r\n* either the corresponding child node is still around: Then we would pick up the leadership again.\r\n* if it's not around, `reset()` will be called, anyway\r\n\r\nSorry for the confusion. ...to many threads -.-"", 'commenter': 'XComp'}]"
430,curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java,"@@ -190,6 +190,12 @@ public void close() throws IOException
         close(closeMode);
     }
 
+    // for testing","[{'comment': ""```suggestion\r\n    @VisibleForTesting\r\n```\r\nIsn't this annotation the better way of documenting this here?"", 'commenter': 'XComp'}]"
430,curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java,"@@ -190,6 +190,12 @@ public void close() throws IOException
         close(closeMode);
     }
 
+    // for testing
+    void closeOnDemand() throws IOException
+    {
+        internalClose(closeMode, false);
+    }","[{'comment': ""For now, this is a test-only method. I'm a bit reluctant to add test-related code in production code rather than providing a utilily class instead (to be fair: we do that in curator code in other locations like the `debug*CountDownLatches` in the `LeaderLatch` implementation). I see a risk if convenient methods like this are available in production: They might make it easier to write less-consistent production code. :thinking: "", 'commenter': 'XComp'}, {'comment': '...but if you want to stick to it, I would vote for coming up with a more descriptive name for it: Something like `closeIfStillRunning`', 'commenter': 'XComp'}]"
430,curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java,"@@ -198,9 +204,25 @@ public void close() throws IOException
      * @param closeMode allows the default close mode to be overridden at the time the latch is closed.
      * @throws IOException errors
      */
-    public synchronized void close(CloseMode closeMode) throws IOException
+    public void close(CloseMode closeMode) throws IOException
     {
-        Preconditions.checkState(state.compareAndSet(State.STARTED, State.CLOSED), ""Already closed or has not been started"");
+        internalClose(closeMode, true);
+    }
+
+    private synchronized void internalClose(CloseMode closeMode, boolean failOnClosed) throws IOException
+    {
+        if (!state.compareAndSet(State.STARTED, State.CLOSED))
+        {
+            if (failOnClosed)
+            {
+                throw new IllegalStateException(""Already closed or has not been started"");
+            }
+            else
+            {
+                return;
+            }","[{'comment': ""```suggestion\r\n            return;\r\n```\r\nnit: Is the `else` branch required based on code guidelines? If not, I'd propose removing it to shorten the code. The code format (having opening brackets on a new line) makes the code long, anyway already."", 'commenter': 'XComp'}]"
435,curator-recipes/src/main/java/org/apache/curator/framework/recipes/barriers/DistributedBarrier.java,"@@ -92,6 +93,16 @@ public synchronized void      removeBarrier() throws Exception
         }
     }
 
+    /**
+     * Indicates if the barrier is set or not.
+     *
+     * @return true if the barrier is set.
+     */
+    public synchronized boolean     isSet() throws Exception","[{'comment': 'Annotated with `@VisibleForTesting`.', 'commenter': 'tisonkun'}]"
435,curator-recipes/src/test/java/org/apache/curator/framework/recipes/barriers/TestDistributedBarrier.java,"@@ -218,4 +230,48 @@ public Object call() throws Exception
             client.close();
         }
     }
+
+    @Test
+    public void     testIsSet() throws Exception
+    {
+        try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {
+            client.start();
+
+            final DistributedBarrier barrier = new DistributedBarrier(client, ""/barrier"");
+            barrier.setBarrier();
+
+            assertTrue(barrier.isSet());
+        }
+    }
+
+    @Test
+    public void     testIsNotSet() throws Exception
+    {
+        try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {
+            client.start();
+
+            final DistributedBarrier barrier = new DistributedBarrier(client, ""/barrier"");
+            barrier.setBarrier();
+            barrier.removeBarrier();
+
+            assertFalse(barrier.isSet());
+        }
+    }
+
+    @Test
+    public void     testWatchersRemoved() throws Exception
+    {
+        CuratorFramework              client = mock(CuratorFramework.class);
+        WatcherRemoveCuratorFramework watcherRemoveClient = mock(WatcherRemoveCuratorFramework.class);
+        ExistsBuilder                 existsBuilder = mock(ExistsBuilder.class);
+
+        when(client.newWatcherRemoveCuratorFramework()).thenReturn(watcherRemoveClient);
+        when(watcherRemoveClient.checkExists()).thenReturn(existsBuilder);
+        when(existsBuilder.usingWatcher(any(Watcher.class))).thenReturn(existsBuilder);
+
+        final DistributedBarrier      barrier = new DistributedBarrier(client, ""/barrier"");
+        barrier.waitOnBarrier(1, TimeUnit.SECONDS);
+        verify(watcherRemoveClient, atLeastOnce()).removeWatchers();
+    }","[{'comment': 'Perhaps add watches and verify the following events triggered:\r\n\r\n* DataWatchRemoved\r\n* ChildWatchRemoved\r\n* PersistentWatchRemoved', 'commenter': 'tisonkun'}, {'comment': 'I guess it might be particular important to test this as `ZooKeeper.removeWatches` is cheating since [ZOOKEEPER-1910](https://issues.apache.org/jira/browse/ZOOKEEPER-1910). See also kezhuw/zookeeper-client-rust#2.', 'commenter': 'kezhuw'}, {'comment': '@kezhuw I agree that it can be a bug as I mentioned in https://lists.apache.org/thread/0kcnklcxs0s5656c1sbh3crgdodbb0qg. You can reply on the mailing list and file an issue.', 'commenter': 'tisonkun'}]"
454,curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java,"@@ -797,7 +797,7 @@ public void performBackgroundOperation(OperationAndData<T> dummy) throws Excepti
                 {
                     if ( !client.getZookeeperClient().getRetryPolicy().allowRetry(e) )
                     {
-                        final CuratorEvent event = makeCuratorEvent(client, e.code().intValue(), e.getPath(), null, e.getPath(), null);","[{'comment': ""I overlooked the callback case in reviewing #453, `CuratorEvent::getName` is useless in reconstruction of `KeeperException`. But in callback, it should be `null` as no node is created. This is also consistent with ZooKeeper world's callback. This is currently pushed as hotfix commit. I think it might not worth to create separated pr for this. Any thoughts ? @tisonkun @eolivelli "", 'commenter': 'kezhuw'}, {'comment': ""I'm fine with this change."", 'commenter': 'tisonkun'}, {'comment': 'I changed the `throw e` to `return` in latest push. I think it is unnecessary to report or log such exception as un-handled now.', 'commenter': 'kezhuw'}, {'comment': ""I'd prefer keep it as is to minimize the changeset. Now the exception will be handled by `handleBackgroundOperationException` and keep the current logic doesn't hurt user experience."", 'commenter': 'tisonkun'}, {'comment': ""At least they are two different things. Let's focus them one by one if you insist that such a change benefits."", 'commenter': 'tisonkun'}, {'comment': '@tisonkun You are right. I have reverted such a change to keep it as is. The change will break `TestLeaderAcls::testAclErrorWithLeader` which depends on this un-handled behavior.', 'commenter': 'kezhuw'}]"
454,curator-framework/src/main/java/org/apache/curator/framework/imps/CuratorEventImpl.java,"@@ -133,7 +133,7 @@ public String toString()
         this.resultCode = resultCode;
         this.opResults = (opResults != null) ? ImmutableList.copyOf(opResults) : null;
         this.path = client.unfixForNamespace(path);
-        this.name = name;
+        this.name = client.unfixForNamespace(name);","[{'comment': 'This should be safe as `unfixForNamespace` is tolerated to `null` input.', 'commenter': 'kezhuw'}]"
454,curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java,"@@ -900,8 +900,6 @@ private void sendBackgroundResponse(int rc, String path, Object ctx, String name
 
     private static CuratorEvent makeCuratorEvent(CuratorFrameworkImpl client, int rc, String path, Object ctx, String name, Stat stat)
     {","[{'comment': ""Let's inline this method since it's now only a delegate."", 'commenter': 'tisonkun'}, {'comment': 'I have introduced a static version of `sendBackgroundResponse`, so that all response are go through this method finally. I saw no ""beauty"" code path to construct `CuratorEvent`, too many parameters ...', 'commenter': 'kezhuw'}, {'comment': 'Aha. This is exactly what I once do when hacking #453.', 'commenter': 'tisonkun'}]"
