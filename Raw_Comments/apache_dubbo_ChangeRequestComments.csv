Pull,Path,Diff_hunk,Comment
945,dubbo-container/dubbo-container-api/src/main/resources/META-INF/assembly/bin/start.sh,"@@ -12,11 +12,11 @@ SERVER_PORT=`sed '/dubbo.protocol.port/!d;s/.*=//' conf/dubbo.properties | tr -d
 LOGS_FILE=`sed '/dubbo.log4j.file/!d;s/.*=//' conf/dubbo.properties | tr -d '\r'`
 
 if [ -z ""$SERVER_HOST"" ]; then
-    SERVER_HOST=`127.0.0.1`
+    SERVER_HOST='127.0.0.1'
 fi
 
 if [ -z ""$SERVER_NAME"" ]; then
-    SERVER_NAME=`hostname`
+    SERVER_NAME='hostname'","[{'comment': 'hostname是获取机器别名，需要加反引号""`""\r\n加单引号""‘""后就变成字符串""hostname""了\r\n\r\n如机器名为:""abc.local""\r\n\\`hostname\\`的结果是:  abc.local\r\n\'hostname\'的结果是: hostname', 'commenter': 'lujian0571'}, {'comment': '嗯，谢谢提醒', 'commenter': 'tuser4198'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/java/com/alibaba/dubbo/rpc/benchmark/AbstractBenchmarkClient.java,"@@ -23,12 +17,6 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.CyclicBarrier;
 
-/**
- * Abstract benchmark client,test for difference scenes Usage: -Dwrite.statistics=false BenchmarkClient serverIP
- * serverPort concurrents timeout codectype requestSize runtime(seconds) clientNums
- *
- * @author <a href=""mailto:bluedavy@gmail.com"">bluedavy</a>
- */","[{'comment': 'remove author info only, and keep the others.', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/java/com/alibaba/dubbo/rpc/benchmark/AbstractBenchmarkServer.java,"@@ -12,11 +9,7 @@
 import java.text.SimpleDateFormat;
 import java.util.Date;
 
-/**
- * Abstract benchmark server Usage: BenchmarkServer listenPort maxThreads responseSize
- *
- * @author <a href=""mailto:bluedavy@gmail.com"">bluedavy</a>
- */","[{'comment': 'pls. remove author info only but keep the others.', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/java/com/alibaba/dubbo/rpc/benchmark/AbstractClientRunnable.java,"@@ -12,11 +9,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.CyclicBarrier;
 
-/**
- * Simple Processor RPC Benchmark Client Thread
- *
- * @author <a href=""mailto:bluedavy@gmail.com"">bluedavy</a>
- */","[{'comment': 'pls. remove author info only but keep the others.', 'commenter': 'beiwei30'}, {'comment': 'only remove author info', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/java/com/alibaba/dubbo/rpc/benchmark/ClientRunnable.java,"@@ -8,11 +8,6 @@
 
 import java.util.List;
 
-/**
- * client runnable,so we can collect results
- *
- * @author <a href=""mailto:bluedavy@gmail.com"">bluedavy</a>
- */","[{'comment': 'pls. remove author info only but keep the others.', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/java/com/alibaba/dubbo/rpc/benchmark/ExchangeClientFactory.java,"@@ -14,11 +11,6 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.FutureTask;
 
-/**
- * Abstract ExchangeClient Factory,create custom nums ExchangeClient
- *
- * @author <a href=""mailto:bluedavy@gmail.com"">bluedavy</a>
- */","[{'comment': 'pls. remove author info only but keep the others.', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/java/com/alibaba/dubbo/rpc/benchmark/RequestObject.java,"@@ -1,19 +1,8 @@
 package com.alibaba.dubbo.rpc.benchmark;
 
-/**
- * nfs-rpc
- * Apache License
- * <p>
- * http://code.google.com/p/nfs-rpc (c) 2011
- */
 
 import java.io.Serializable;
 
-/**
- * Just for RPC Benchmark Test,request object
- *
- * @author <a href=""mailto:bluedavy@gmail.com"">bluedavy</a>
- */
 public class RequestObject implements Serializable {","[{'comment': 'pls. remove author info only but keep the others.', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/java/com/alibaba/dubbo/rpc/benchmark/ServiceFactory.java,"@@ -5,11 +5,6 @@
 
 import java.util.concurrent.ConcurrentHashMap;
 
-/**
- * Abstract Service Factory,create custom nums Service
- *
- * @author tony.chenl
- */","[{'comment': 'pls. remove author info only but keep the others.', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/java/com/alibaba/dubbo/rpc/benchmark/AbstractBenchmarkClient.java,"@@ -1,11 +1,5 @@
 package com.alibaba.dubbo.rpc.benchmark;","[{'comment': 'pls. add apache license at the beginning', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/java/com/alibaba/dubbo/rpc/benchmark/AbstractBenchmarkClient.java,"@@ -1,11 +1,5 @@
 package com.alibaba.dubbo.rpc.benchmark;
 
-/**
- * nfs-rpc
- * Apache License
- * <p>
- * http://code.google.com/p/nfs-rpc (c) 2011
- */
 ","[{'comment': 'pls. add apache license at the beginning', 'commenter': 'beiwei30'}, {'comment': '@beiwei30  use our new apache license comments or original comments?', 'commenter': 'DeadLion'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/java/com/alibaba/dubbo/rpc/benchmark/AbstractClientRunnable.java,"@@ -1,8 +1,5 @@
 package com.alibaba.dubbo.rpc.benchmark;
 
-/**","[{'comment': 'pls. add apache license at the beginning', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/java/com/alibaba/dubbo/rpc/benchmark/ClientRunnable.java,"@@ -8,11 +8,6 @@
 ","[{'comment': 'pls. add apache license at the beginning', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/java/com/alibaba/dubbo/rpc/benchmark/DemoService.java,"@@ -1,11 +1,6 @@
 package com.alibaba.dubbo.rpc.benchmark;","[{'comment': 'pls. add apache license at the beginning', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/java/com/alibaba/dubbo/rpc/benchmark/ResponseObject.java,"@@ -1,18 +1,7 @@
 package com.alibaba.dubbo.rpc.benchmark;","[{'comment': 'pls. add apache license at the beginning', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/resources/ProviderSample.xml,"@@ -24,13 +24,13 @@
 
     <dubbo:registry address=""N/A""/>
 
-    <!-- 服务应用配置 -->
+    <!-- service application config -->
     <dubbo:application name=""dubbo_provider""/>
 
-    <!-- 服务提供者全局配置 -->
+    <!-- provider service global config -->","[{'comment': 'service provider', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-benchmark/src/main/resources/ProviderSample.xml,"@@ -24,13 +24,13 @@
 
     <dubbo:registry address=""N/A""/>
 
-    <!-- 服务应用配置 -->
+    <!-- service application config -->
     <dubbo:application name=""dubbo_provider""/>
 
-    <!-- 服务提供者全局配置 -->
+    <!-- provider service global config -->
     <dubbo:protocol name=""dubbo"" port=""20885""/>
 
-    <!-- 服务提供者暴露服务配置 -->
+    <!-- provider service export config -->","[{'comment': 'service provider', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/com/alibaba/dubbo/test/Spring3CompatibilityTest.java,"@@ -7,12 +7,7 @@
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.util.Assert;
 
-/**
- * Dubbo compatibility test on Spring 3.2.x
- *
- * @author <a href=""mailto:mercyblitz@gmail.com"">Mercy</a>
- * @since 2.5.8
- */","[{'comment': 'only remove author info', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-benchmark/src/test/java/com/jingdong/client/DemoBenchmarkClientRunnable.java,"@@ -22,11 +23,6 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.CyclicBarrier;
 
-/**
- * DemoBenchmarkClient.java
- *
- * @author tony.chenl","[{'comment': 'only remove author info', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/com/alibaba/dubbo/test/consumer/ConsumerConfiguration.java,"@@ -6,12 +6,6 @@
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.ImportResource;
 
-/**
- * Consumer {@Link Configuration}
- *
- * @author <a href=""mailto:mercyblitz@gmail.com"">Mercy</a>
- * @since 2.5.8","[{'comment': 'only remove author info', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/com/alibaba/dubbo/test/provider/DefaultDemoService.java,"@@ -3,12 +3,7 @@
 import com.alibaba.dubbo.config.annotation.Service;
 import com.alibaba.dubbo.demo.DemoService;
 
-/**
- * Default {@link DemoService} implementation
- *
- * @author <a href=""mailto:mercyblitz@gmail.com"">Mercy</a>
- * @since 2.5.8","[{'comment': 'only remove author info', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-compatibility/dubbo-test-spring3/src/main/java/com/alibaba/dubbo/test/provider/ProviderConfiguration.java,"@@ -4,12 +4,7 @@
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.ImportResource;
 
-/**
- * Provider {@Link Configuration}
- *
- * @author <a href=""mailto:mercyblitz@gmail.com"">Mercy</a>
- * @since 2.5.8","[{'comment': 'only remove author info', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/annotation/AnnotationProvider.java,"@@ -23,11 +24,7 @@
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.PropertySource;
 
-/**
- * MergeProvider
- *
- * @author william.liangf","[{'comment': 'only remove author info', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/annotation/action/AnnotationAction.java,"@@ -20,11 +21,6 @@
 
 import org.springframework.stereotype.Component;
 
-/**
- * AnnotationAction
- *
- * @author william.liangf","[{'comment': 'only remove author info', 'commenter': 'beiwei30'}]"
1071,dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/annotation/api/AnnotationService.java,"@@ -15,11 +16,7 @@
  */
 package com.alibaba.dubbo.examples.annotation.api;
 
-/**
- * AsyncService
- *
- * @author william.liangf","[{'comment': 'only remove author info', 'commenter': 'beiwei30'}]"
1267,dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java,"@@ -36,6 +36,8 @@
  */
 public class ConsistentHashLoadBalance extends AbstractLoadBalance {
 
+    public static final String NAME = ""consistenthash"";","[{'comment': 'Is this line you added is useless? @dchack   ', 'commenter': 'lovepoem'}, {'comment': ""it's the same as RandomLoadBalance's codes.@lovepoem"", 'commenter': 'dchack'}, {'comment': 'IMO, this is ok.', 'commenter': 'diecui1202'}]"
1267,dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/loadbalance/LoadBalanceTest.java,"@@ -117,6 +127,18 @@ public void testRoundRobinLoadBalance_select() {
         }
     }
 
+    @Test
+    public void testConsistentHashLoadBalance_select() {
+        Map<Invoker, AtomicLong> counter = getInvokeCounter(ConsistentHashLoadBalance.NAME, invocationList);
+
+        long runs = invocationList.size();
+        for (Invoker minvoker : counter.keySet()) {
+            Long count = counter.get(minvoker).get();
+            float ratio = count/(runs / (0f + invokers.size()));
+            Assert.assertTrue(""invoker ratio must be gt 0.5 and lt 2"",ratio>0.5 && ratio< 2);","[{'comment': 'Why `gt 0.5 and lt 2` is a reasonable ratio, can you explain?', 'commenter': 'chickenlj'}, {'comment': 'I also have the same concern.', 'commenter': 'diecui1202'}]"
1267,dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/loadbalance/LoadBalanceTest.java,"@@ -71,6 +73,14 @@ public void setUp() throws Exception {
         invoker3 = EasyMock.createMock(Invoker.class);
         invoker4 = EasyMock.createMock(Invoker.class);
         invoker5 = EasyMock.createMock(Invoker.class);
+        invocationList = new ArrayList<Invocation>();
+        for(int i=0; i<1000; i++){","[{'comment': 'Could you format the code ?', 'commenter': 'diecui1202'}]"
1267,dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/loadbalance/LoadBalanceTest.java,"@@ -71,6 +73,14 @@ public void setUp() throws Exception {
         invoker3 = EasyMock.createMock(Invoker.class);
         invoker4 = EasyMock.createMock(Invoker.class);
         invoker5 = EasyMock.createMock(Invoker.class);
+        invocationList = new ArrayList<Invocation>();
+        for(int i=0; i<1000; i++){
+            Invocation  invocation1 = EasyMock.createMock(Invocation.class);","[{'comment': '`invocation` is a better variable name here.', 'commenter': 'diecui1202'}]"
1267,dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/loadbalance/LoadBalanceTest.java,"@@ -71,6 +73,14 @@ public void setUp() throws Exception {
         invoker3 = EasyMock.createMock(Invoker.class);
         invoker4 = EasyMock.createMock(Invoker.class);
         invoker5 = EasyMock.createMock(Invoker.class);
+        invocationList = new ArrayList<Invocation>();
+        for(int i=0; i<1000; i++){
+            Invocation  invocation1 = EasyMock.createMock(Invocation.class);
+            EasyMock.expect(invocation1.getMethodName()).andReturn(""method1"").anyTimes();
+            EasyMock.expect(invocation1.getArguments()).andReturn(new Object[]{randomString(3),randomString(5)}).anyTimes();
+            EasyMock.replay(invocation1);","[{'comment': 'Here, we have changed test framework to Mockito, so could you change it to mockito again? Thanks.', 'commenter': 'diecui1202'}]"
1351,dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/RpcContext.java,"@@ -610,51 +610,24 @@ public RpcContext setInvocation(Invocation invocation) {
     @SuppressWarnings(""unchecked"")
     public <T> Future<T> asyncCall(Callable<T> callable) {
         try {
-            try {
-                setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());
-                final T o = callable.call();
-                //local invoke will return directly
-                if (o != null) {
-                    FutureTask<T> f = new FutureTask<T>(new Callable<T>() {
-                        public T call() throws Exception {
-                            return o;
-                        }
-                    });
-                    f.run();
-                    return f;
-                } else {
-","[{'comment': ""What if `o == null` is true? Shouldn't we return `RpcContext.getFuture()`?"", 'commenter': 'chickenlj'}, {'comment': ""![image](https://user-images.githubusercontent.com/14085645/36014984-67f65eae-0da7-11e8-983e-8db01f329365.png)\r\n从当前master的dai'ma'lai代码来看，如果o==null，只会走一个空的else块，而第二个catch块是应该是永远无法走到的吧"", 'commenter': 'zhaojigang'}, {'comment': '奥，现在明白了，第二个catch用来捕捉第一个catch抛出的异常，那是否可以直接将第二个catch体内的逻辑直接放在第一个catch内？', 'commenter': 'zhaojigang'}, {'comment': ""Don't you think we should return a future for the `else clause`?"", 'commenter': 'chickenlj'}, {'comment': 'yes, you can wrap a Future for ex in the inner catch.', 'commenter': 'kimmking'}]"
1351,dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/RpcContext.java,"@@ -610,51 +610,24 @@ public RpcContext setInvocation(Invocation invocation) {
     @SuppressWarnings(""unchecked"")
     public <T> Future<T> asyncCall(Callable<T> callable) {
         try {
-            try {
-                setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());
-                final T o = callable.call();
-                //local invoke will return directly
-                if (o != null) {
-                    FutureTask<T> f = new FutureTask<T>(new Callable<T>() {
-                        public T call() throws Exception {
-                            return o;
-                        }
-                    });
-                    f.run();
-                    return f;
-                } else {
-
-                }
-            } catch (Exception e) {
-                throw new RpcException(e);
-            } finally {
-                removeAttachment(Constants.ASYNC_KEY);
+            setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());
+            final T o = callable.call();
+            //local invoke will return directly
+            if (o != null) {
+                FutureTask<T> f = new FutureTask<T>(new Callable<T>() {
+                    public T call() throws Exception {
+                        return o;
+                    }
+                });
+                f.run();
+                return f;
             }
-        } catch (final RpcException e) {","[{'comment': 'I think we should keep this catch clause, so we can pretend to be a real async call and throw exception with `future.get`', 'commenter': 'chickenlj'}, {'comment': 'can we make a testcase to trigger the second catch statement?', 'commenter': 'kimmking'}, {'comment': ""Let's wait for @zhaojigang's reply, i think it would be great for himself to add these changes."", 'commenter': 'chickenlj'}]"
1357,dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java,"@@ -602,90 +596,92 @@ private void loadFile(Map<String, Class<?>> extensionClasses, String dir) {
                                 final int ci = line.indexOf('#');
                                 if (ci >= 0) line = line.substring(0, ci);
                                 line = line.trim();
-                                if (line.length() > 0) {
-                                    try {
-                                        String name = null;
-                                        int i = line.indexOf('=');
-                                        if (i > 0) {
-                                            name = line.substring(0, i).trim();
-                                            line = line.substring(i + 1).trim();
-                                        }
-                                        if (line.length() > 0) {
-                                            Class<?> clazz = Class.forName(line, true, classLoader);
-                                            if (!type.isAssignableFrom(clazz)) {
-                                                throw new IllegalStateException(""Error when load extension class(interface: "" +
-                                                        type + "", class line: "" + clazz.getName() + ""), class ""
-                                                        + clazz.getName() + ""is not subtype of interface."");
-                                            }
-                                            if (clazz.isAnnotationPresent(Adaptive.class)) {
-                                                if (cachedAdaptiveClass == null) {
-                                                    cachedAdaptiveClass = clazz;
-                                                } else if (!cachedAdaptiveClass.equals(clazz)) {
-                                                    throw new IllegalStateException(""More than 1 adaptive class found: ""
-                                                            + cachedAdaptiveClass.getClass().getName()
-                                                            + "", "" + clazz.getClass().getName());
-                                                }
-                                            } else {
-                                                try {
-                                                    clazz.getConstructor(type);
-                                                    Set<Class<?>> wrappers = cachedWrapperClasses;
-                                                    if (wrappers == null) {
-                                                        cachedWrapperClasses = new ConcurrentHashSet<Class<?>>();
-                                                        wrappers = cachedWrapperClasses;
-                                                    }
-                                                    wrappers.add(clazz);
-                                                } catch (NoSuchMethodException e) {
-                                                    clazz.getConstructor();
-                                                    if (name == null || name.length() == 0) {
-                                                        name = findAnnotationName(clazz);
-                                                        if (name == null || name.length() == 0) {
-                                                            if (clazz.getSimpleName().length() > type.getSimpleName().length()
-                                                                    && clazz.getSimpleName().endsWith(type.getSimpleName())) {
-                                                                name = clazz.getSimpleName().substring(0, clazz.getSimpleName().length() - type.getSimpleName().length()).toLowerCase();
-                                                            } else {
-                                                                throw new IllegalStateException(""No such extension name for the class "" + clazz.getName() + "" in the config "" + url);
-                                                            }
-                                                        }
-                                                    }
-                                                    String[] names = NAME_SEPARATOR.split(name);
-                                                    if (names != null && names.length > 0) {
-                                                        Activate activate = clazz.getAnnotation(Activate.class);
-                                                        if (activate != null) {
-                                                            cachedActivates.put(names[0], activate);
-                                                        }
-                                                        for (String n : names) {
-                                                            if (!cachedNames.containsKey(clazz)) {
-                                                                cachedNames.put(clazz, n);
-                                                            }
-                                                            Class<?> c = extensionClasses.get(n);
-                                                            if (c == null) {
-                                                                extensionClasses.put(n, clazz);
-                                                            } else if (c != clazz) {
-                                                                throw new IllegalStateException(""Duplicate extension "" + type.getName() + "" name "" + n + "" on "" + c.getName() + "" and "" + clazz.getName());
-                                                            }
-                                                        }
-                                                    }
-                                                }
-                                            }
-                                        }
-                                    } catch (Throwable t) {
-                                        IllegalStateException e = new IllegalStateException(""Failed to load extension class(interface: "" + type + "", class line: "" + line + "") in "" + url + "", cause: "" + t.getMessage(), t);
-                                        exceptions.put(line, e);
-                                    }
+                                if (!line.isEmpty()) {
+                                    processLine(line, url, classLoader);
                                 }
-                            } // end of while read lines
+                            }
                         } finally {
                             reader.close();
                         }
                     } catch (Throwable t) {
-                        logger.error(""Exception when load extension class(interface: "" +
-                                type + "", class file: "" + url + "") in "" + url, t);
+                        logger.error(""Exception when load extension class(interface: "" + type + "", class file: "" + url + "") in "" + url, t);
+                    }
+                }
+            }
+        } catch (Throwable t) {
+            logger.error(""Exception when load extension class(interface: "" + type + "", description file: "" + fileName + "")."", t);
+        }
+    }
+
+    private void processLine(String line, java.net.URL url, ClassLoader classLoader) {
+        try {
+            String name = null;
+            int i = line.indexOf('=');
+            if (i > 0) {
+                name = line.substring(0, i).trim();
+                line = line.substring(i + 1).trim();
+            }
+            if (line.isEmpty()) {
+                return;
+            }
+            Class<?> clazz = Class.forName(line, true, classLoader);
+            if (!type.isAssignableFrom(clazz)) {
+                throw new IllegalStateException(""Error when load extension class(interface: "" +
+                        type + "", class line: "" + clazz.getName() + ""), class ""
+                        + clazz.getName() + ""is not subtype of interface."");
+            }
+            if (clazz.isAnnotationPresent(Adaptive.class)) {
+                if (cachedAdaptiveClass == null) {
+                    cachedAdaptiveClass = clazz;
+                } else if (!cachedAdaptiveClass.equals(clazz)) {
+                    throw new IllegalStateException(""More than 1 adaptive class found: ""
+                            + cachedAdaptiveClass.getClass().getName()
+                            + "", "" + clazz.getClass().getName());
+                }
+            } else {
+                try {
+                    clazz.getConstructor(type);
+                    if (cachedWrapperClasses == null) {
+                        cachedWrapperClasses = new ConcurrentHashSet<Class<?>>();
+                    }
+                    cachedWrapperClasses.add(clazz);
+                } catch (NoSuchMethodException e) {
+                    clazz.getConstructor();
+                    if (name == null || name.length() == 0) {
+                        name = findAnnotationName(clazz);
+                        if (name == null || name.length() == 0) {
+                            if (clazz.getSimpleName().length() > type.getSimpleName().length()
+                                    && clazz.getSimpleName().endsWith(type.getSimpleName())) {
+                                name = clazz.getSimpleName().substring(0, clazz.getSimpleName().length() - type.getSimpleName().length()).toLowerCase();
+                            } else {
+                                throw new IllegalStateException(""No such extension name for the class "" + clazz.getName() + "" in the config "" + url);
+                            }
+                        }
                     }
-                } // end of while urls
+                    String[] names = NAME_SEPARATOR.split(name);
+                    if (names != null && names.length > 0) {
+                        Activate activate = clazz.getAnnotation(Activate.class);
+                        if (activate != null) {
+                            cachedActivates.put(names[0], activate);
+                        }
+                        for (String n : names) {
+                            cachedNames.putIfAbsent(clazz, n);
+                            if (cachedClasses.get() == null) {
+                                cachedClasses.set(new HashMap<String, Class<?>>());","[{'comment': 'At first, i think move `cachedClasses.set()` here will change the original synchronization scope. But outer callers should make sure all accesses to cachedClasses were synchronized, this condition seems never changed.', 'commenter': 'chickenlj'}]"
1357,dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java,"@@ -574,14 +570,12 @@ private T injectExtension(T instance) {
             }
         }
 
-        Map<String, Class<?>> extensionClasses = new HashMap<String, Class<?>>();","[{'comment': 'notice a HashMap instance is always created in previous version', 'commenter': 'chickenlj'}]"
1388,dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/merger/ArrayMerger.java,"@@ -34,9 +34,7 @@
             if (item != null && item.getClass().isArray()) {
                 totalLen += Array.getLength(item);
             } else {
-                throw new IllegalArgumentException(
-                        new StringBuilder(32).append(i + 1)
-                                .append(""th argument is not an array"").toString());
+                throw new IllegalArgumentException(i + 1 + ""th argument is not an array"");","[{'comment': 'this is incorrect, it should be\r\n\r\n```java\r\nthrow new IllegalArgumentException((i + 1) + ""th argument is not an array"");\r\n```', 'commenter': 'beiwei30'}, {'comment': 'Thanks @beiwei30 , we don\'t need to add the () explicitly.  A example:\r\n```\r\n    public static void main(String[] args) {\r\n\r\n        int x = 10;\r\n        throw new IllegalArgumentException(x + 1 + "" illegal exception"");\r\n    }\r\n```\r\nwill get:\r\n```\r\nException in thread ""main"" java.lang.IllegalArgumentException: 11 illegal exception\r\n```\r\nPlease correct me if I\'m wrong.', 'commenter': 'liketic'}, {'comment': ""agree. I will accept the change, but will submit a supplementary change because it's safer by doing this."", 'commenter': 'beiwei30'}]"
1407,dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/MonitorConfig.java,"@@ -123,4 +125,12 @@ public void setDefault(Boolean isDefault) {
         this.isDefault = isDefault;
     }
 
+    public void setInterval(String interval){
+        this.interval = interval;
+    }
+
+    public String getInterval(){","[{'comment': 'Who calls `getInterval()`?', 'commenter': 'diecui1202'}, {'comment': 'no one call `getInterval()` direct, this is used for fastjson serialize, so it can be passed to `URL`', 'commenter': 'YoungHu'}]"
1407,dubbo-monitor/dubbo-monitor-default/src/main/java/com/alibaba/dubbo/monitor/dubbo/DubboMonitor.java,"@@ -92,6 +93,7 @@ public void send() {
             long maxOutput = numbers[7];
             long maxElapsed = numbers[8];
             long maxConcurrent = numbers[9];
+            String version = getUrl().getParameter(Constants.DEFAULT_PROTOCOL);","[{'comment': 'IMO, this variable is named `protocol` may be better. ', 'commenter': 'diecui1202'}, {'comment': 'why `DEFAULT_PROTOCOL` is necessary to collect?', 'commenter': 'beiwei30'}, {'comment': ""`DEFAULT_PROTOCOL` value is `dubbo`, this code is to get dubbo version but not protocol name. dubbo now upgrade fast, for a team, different project may use different dubbo version(eg 2.5.3, 2.6.0, 2.6.1), IMO, monitor need to know each project's dubbo version, so we can decide how to process the monitor data."", 'commenter': 'YoungHu'}, {'comment': 'sounds a reasonable data to collect, let me think about it more.', 'commenter': 'beiwei30'}]"
1568,dubbo-common/src/main/java/com/alibaba/dubbo/common/threadpool/support/enhanced/EnhancedTaskQueue.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.dubbo.common.threadpool.support.enhanced;
+
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.RejectedExecutionException;
+
+/**
+ * enhanced task queue in the enhanced thread pool
+ */
+public class EnhancedTaskQueue<R extends Runnable> extends LinkedBlockingQueue<Runnable> {
+
+    private static final long serialVersionUID = -2635853580887179627L;
+
+    private EnhancedThreadPoolExecutor executor;
+
+    public EnhancedTaskQueue(int capacity) {
+        super(capacity);
+    }
+
+    public void setExecutor(EnhancedThreadPoolExecutor exec) {
+        executor = exec;
+    }
+
+    @Override
+    public boolean offer(Runnable runnable) {
+        if (executor == null) {
+            throw new RejectedExecutionException(""enhanced queue does not have executor !"");
+        }
+        int currentPoolThreadSize = executor.getPoolSize();
+        //have free worker. put task into queue to let the worker deal with task.","[{'comment': 'leave space after `//`', 'commenter': 'beiwei30'}]"
1568,dubbo-common/src/main/java/com/alibaba/dubbo/common/threadpool/support/enhanced/EnhancedTaskQueue.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.dubbo.common.threadpool.support.enhanced;
+
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.RejectedExecutionException;
+
+/**
+ * enhanced task queue in the enhanced thread pool
+ */
+public class EnhancedTaskQueue<R extends Runnable> extends LinkedBlockingQueue<Runnable> {
+
+    private static final long serialVersionUID = -2635853580887179627L;
+
+    private EnhancedThreadPoolExecutor executor;
+
+    public EnhancedTaskQueue(int capacity) {
+        super(capacity);
+    }
+
+    public void setExecutor(EnhancedThreadPoolExecutor exec) {
+        executor = exec;
+    }
+
+    @Override
+    public boolean offer(Runnable runnable) {
+        if (executor == null) {
+            throw new RejectedExecutionException(""enhanced queue does not have executor !"");
+        }
+        int currentPoolThreadSize = executor.getPoolSize();
+        //have free worker. put task into queue to let the worker deal with task.
+        if (executor.getSubmittedTaskCount() < currentPoolThreadSize) {
+            return super.offer(runnable);
+        }
+
+        // return false to let executor create new worker.
+        if (currentPoolThreadSize < executor.getMaximumPoolSize()) {
+            return false;
+        }
+
+        //currentPoolThreadSize >= max
+        return super.offer(runnable);
+    }
+
+    /**
+     * retry offer task
+     *
+     * @param o task
+     * @return offer success or not
+     * @throws RejectedExecutionException if executor is terminated.
+     */
+    public boolean retryOffer(Runnable o) {
+        if (executor.isShutdown()) {
+            throw new RejectedExecutionException(""Executor is shutdown !"");","[{'comment': 'change ""Executor is shutdown !"" to ""Executor is shutdown!"", there\'s one extra space.', 'commenter': 'beiwei30'}]"
1568,dubbo-common/src/main/java/com/alibaba/dubbo/common/threadpool/support/enhanced/EnhancedTaskQueue.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.dubbo.common.threadpool.support.enhanced;
+
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.RejectedExecutionException;
+
+/**
+ * enhanced task queue in the enhanced thread pool","[{'comment': 'describe the behavior here', 'commenter': 'beiwei30'}]"
1568,dubbo-common/src/main/java/com/alibaba/dubbo/common/threadpool/support/enhanced/EnhancedThreadPool.java,"@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.dubbo.common.threadpool.support.enhanced;
+
+import com.alibaba.dubbo.common.Constants;
+import com.alibaba.dubbo.common.URL;
+import com.alibaba.dubbo.common.threadpool.ThreadPool;
+import com.alibaba.dubbo.common.threadpool.support.AbortPolicyWithReport;
+import com.alibaba.dubbo.common.utils.NamedThreadFactory;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * enhanced thread pool.
+ * When the core threads are all in busy , create new thread instead of putting task into blocking queue .
+ */
+public class EnhancedThreadPool implements ThreadPool {
+
+    @Override
+    public Executor getExecutor(URL url) {
+        String name = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);
+        int cores = url.getParameter(Constants.CORE_THREADS_KEY, Constants.DEFAULT_CORE_THREADS);
+        int threads = url.getParameter(Constants.THREADS_KEY, Integer.MAX_VALUE);
+        int queues = url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES);
+        int alive = url.getParameter(Constants.ALIVE_KEY, Constants.DEFAULT_ALIVE);
+
+        //init queue and enhanced executor
+        EnhancedTaskQueue<Runnable> enhancedTaskQueue = new EnhancedTaskQueue<Runnable>(queues <= 0 ? 1 : queues);
+        EnhancedThreadPoolExecutor executor = new EnhancedThreadPoolExecutor(cores, threads, alive, TimeUnit.MILLISECONDS, enhancedTaskQueue,","[{'comment': 'keep line margin 120 chars.', 'commenter': 'beiwei30'}]"
1568,dubbo-common/src/main/java/com/alibaba/dubbo/common/threadpool/support/enhanced/EnhancedThreadPool.java,"@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.dubbo.common.threadpool.support.enhanced;
+
+import com.alibaba.dubbo.common.Constants;
+import com.alibaba.dubbo.common.URL;
+import com.alibaba.dubbo.common.threadpool.ThreadPool;
+import com.alibaba.dubbo.common.threadpool.support.AbortPolicyWithReport;
+import com.alibaba.dubbo.common.utils.NamedThreadFactory;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * enhanced thread pool.
+ * When the core threads are all in busy , create new thread instead of putting task into blocking queue .","[{'comment': ""remove extra space from 'blocking queue .'"", 'commenter': 'beiwei30'}]"
1568,dubbo-common/src/main/java/com/alibaba/dubbo/common/threadpool/support/enhanced/EnhancedThreadPoolExecutor.java,"@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.dubbo.common.threadpool.support.enhanced;
+
+import java.util.concurrent.RejectedExecutionHandler;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Enhanced thread pool
+ */
+public class EnhancedThreadPoolExecutor extends ThreadPoolExecutor {
+
+    //task count
+    private final AtomicInteger submittedTaskCount = new AtomicInteger(0);
+
+    public EnhancedThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, EnhancedTaskQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {","[{'comment': 'keep line margin 120 chars.', 'commenter': 'beiwei30'}]"
1568,dubbo-common/src/main/java/com/alibaba/dubbo/common/threadpool/support/enhanced/EnhancedThreadPoolExecutor.java,"@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.dubbo.common.threadpool.support.enhanced;
+
+import java.util.concurrent.RejectedExecutionHandler;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Enhanced thread pool
+ */
+public class EnhancedThreadPoolExecutor extends ThreadPoolExecutor {
+
+    //task count
+    private final AtomicInteger submittedTaskCount = new AtomicInteger(0);
+
+    public EnhancedThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, EnhancedTaskQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
+        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
+    }
+
+    /**
+     * @return current tasks which are executed
+     */
+    public int getSubmittedTaskCount() {
+        return submittedTaskCount.get();
+    }
+
+    @Override
+    protected void afterExecute(Runnable r, Throwable t) {
+        submittedTaskCount.decrementAndGet();
+    }
+
+    @Override
+    public void execute(Runnable command) {
+        //do not increment in method beforeExecute!","[{'comment': 'add space after `//`', 'commenter': 'beiwei30'}]"
1568,dubbo-common/src/main/java/com/alibaba/dubbo/common/threadpool/support/enhanced/EnhancedThreadPoolExecutor.java,"@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.dubbo.common.threadpool.support.enhanced;
+
+import java.util.concurrent.RejectedExecutionHandler;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Enhanced thread pool
+ */
+public class EnhancedThreadPoolExecutor extends ThreadPoolExecutor {
+
+    //task count
+    private final AtomicInteger submittedTaskCount = new AtomicInteger(0);
+
+    public EnhancedThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, EnhancedTaskQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
+        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
+    }
+
+    /**
+     * @return current tasks which are executed
+     */
+    public int getSubmittedTaskCount() {
+        return submittedTaskCount.get();
+    }
+
+    @Override
+    protected void afterExecute(Runnable r, Throwable t) {
+        submittedTaskCount.decrementAndGet();
+    }
+
+    @Override
+    public void execute(Runnable command) {
+        //do not increment in method beforeExecute!
+        submittedTaskCount.incrementAndGet();
+        try {
+            super.execute(command);
+        } catch (RejectedExecutionException rx) {
+            //retry to offer the task into queue .","[{'comment': 'add space after `//`', 'commenter': 'beiwei30'}]"
1568,dubbo-common/src/main/java/com/alibaba/dubbo/common/threadpool/support/enhanced/EnhancedThreadPoolExecutor.java,"@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.dubbo.common.threadpool.support.enhanced;
+
+import java.util.concurrent.RejectedExecutionHandler;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Enhanced thread pool
+ */
+public class EnhancedThreadPoolExecutor extends ThreadPoolExecutor {
+
+    //task count
+    private final AtomicInteger submittedTaskCount = new AtomicInteger(0);
+
+    public EnhancedThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, EnhancedTaskQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
+        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
+    }
+
+    /**
+     * @return current tasks which are executed
+     */
+    public int getSubmittedTaskCount() {
+        return submittedTaskCount.get();
+    }
+
+    @Override
+    protected void afterExecute(Runnable r, Throwable t) {
+        submittedTaskCount.decrementAndGet();
+    }
+
+    @Override
+    public void execute(Runnable command) {
+        //do not increment in method beforeExecute!
+        submittedTaskCount.incrementAndGet();
+        try {
+            super.execute(command);
+        } catch (RejectedExecutionException rx) {","[{'comment': 'what happens if exception other than `RejectedExecutionException` is thrown? then submittedTaskCount may have no change to decrease.', 'commenter': 'beiwei30'}, {'comment': ""It can not be a problem because the `submittedTaskCount` will be decreased in the 'afterExecute' method.\r\nBut the RejectedExecutionException is thrown before the task run. So when the RejectedExecutionException is thrown , we should decrease the submittedTaskCount."", 'commenter': 'carryxyh'}]"
1568,dubbo-common/src/main/java/com/alibaba/dubbo/common/threadpool/support/enhanced/EnhancedTaskQueue.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.dubbo.common.threadpool.support.enhanced;","[{'comment': ""I suggest change 'enhanced' into other word, more accurate to describe the behavior, for example: eager or greedy? once decided, pls. change package name, class name, and comments."", 'commenter': 'beiwei30'}, {'comment': 'How about EagerThreadPoolExecutor means the executor is eager to more tasks. ', 'commenter': 'carryxyh'}]"
1707,dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/LRUCache.java,"@@ -46,8 +46,8 @@ protected boolean removeEldestEntry(java.util.Map.Entry<K, V> eldest) {
 
     @Override
     public boolean containsKey(Object key) {
+        lock.lock();","[{'comment': 'why move lock.lock() outside?', 'commenter': 'beiwei30'}, {'comment': 'If according to the original version, when lock.lock() reports an error, it will also enter the finally release lock. According to the Lock.unlock() document, an unchecked exception will be thrown when the non-lock holding thread calls this method:', 'commenter': 'ZhichX'}]"
1707,dubbo-filter/dubbo-filter-cache/src/main/java/com/alibaba/dubbo/cache/support/AbstractCacheFactory.java,"@@ -22,6 +22,7 @@
 import com.alibaba.dubbo.common.URL;
 import com.alibaba.dubbo.rpc.Invocation;
 
+import java.util.Map;","[{'comment': 'looks like a useless import.', 'commenter': 'beiwei30'}, {'comment': 'removed', 'commenter': 'ZhichX'}]"
1707,dubbo-filter/dubbo-filter-cache/src/main/java/com/alibaba/dubbo/cache/support/expiring/ExpiringCache.java,"@@ -0,0 +1,50 @@
+/*","[{'comment': ""instead of introduce AbstractRouter, why don't we do this on the interface?\r\n\r\n```java\r\n    int getPriority();\r\n\r\n    @Override\r\n    default int compareTo(Router o) {\r\n        if (o == null) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n\r\n        if (this.getPriority() == o.getPriority()) {\r\n            if (o.getUrl() == null) {\r\n                return -1;\r\n            }\r\n            return getUrl().toFullString().compareTo(o.getUrl().toFullString());\r\n        } else {\r\n            return this.getPriority() > o.getPriority() ? 1 : -1;\r\n        }\r\n    }\r\n}\r\n```"", 'commenter': 'beiwei30'}, {'comment': '\r\nYour suggestion has been adopted, the default method of jdk8 is really better here, thank you', 'commenter': 'Leishunyu'}]"
1707,dubbo-filter/dubbo-filter-cache/src/main/java/com/alibaba/dubbo/cache/support/expiring/ExpiringMap.java,"@@ -0,0 +1,381 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.alibaba.dubbo.cache.support.expiring;
+
+import java.util.*;","[{'comment': 'pls. use explicit imports, instead of `*`', 'commenter': 'beiwei30'}]"
1707,dubbo-filter/dubbo-filter-cache/src/test/java/com/alibaba/dubbo/cache/filter/CacheFilterTest.java,"@@ -16,78 +16,47 @@
  */
 package com.alibaba.dubbo.cache.filter;","[{'comment': ""The change made on UT doesn't look right. The original UT can test against all cache types."", 'commenter': 'beiwei30'}, {'comment': 'ok, I have deleted the test of expiryMap', 'commenter': 'ZhichX'}, {'comment': 'you should rollback your change made against CacheFilterTest. This test uses `@RunWith(Parameterized.class)` to test against `lru`, `jcache`, `threadlocal`.\r\n\r\n```java\r\n    @Parameters\t\t\r\n     public static List<Object[]> cacheFactories() {\t\t\r\n         return Arrays.asList(new Object[][]{\t\t\r\n                 {""lru"", new LruCacheFactory()},\t\t\r\n                 {""jcache"", new JCacheFactory()},\t\t\r\n                 {""threadlocal"", new ThreadLocalCacheFactory()}\t\t\r\n         });\t\t\r\n     }\r\n```\r\n\r\nyou should consider how to add `expiring` into this test, or write a new test delegated to `expiring` only.', 'commenter': 'beiwei30'}]"
1740,dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/configurator/AbstractConfigurator.java,"@@ -117,15 +117,9 @@ public int compareTo(Configurator o) {
 
         int ipCompare = getUrl().getHost().compareTo(o.getUrl().getHost());
         if (ipCompare == 0) {//host is the same, sort by priority
-            int i = getUrl().getParameter(Constants.PRIORITY_KEY, 0),
+            Integer i = getUrl().getParameter(Constants.PRIORITY_KEY, 0),
                     j = o.getUrl().getParameter(Constants.PRIORITY_KEY, 0);
-            if (i < j) {
-                return -1;
-            } else if (i > j) {
-                return 1;
-            } else {
-                return 0;
-            }
+            return i.compareTo(j);","[{'comment': '-1. \r\n\r\nI would rather remain the current implementation, or use a simplified version `i < j ? -1 : (i == j ? 0 : 1)` instead of calling Integer#compareTo', 'commenter': 'ralf0131'}]"
1764,dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/AnnotationBean.java,"@@ -263,40 +262,41 @@ private Object refer(Reference reference, Class<?> referenceClass) { //method.ge
         if (referenceConfig == null) {
             referenceConfig = new ReferenceBean<Object>(reference);
             if (void.class.equals(reference.interfaceClass())
-                    && """".equals(reference.interfaceName())
-                    && referenceClass.isInterface()) {
+                && """".equals(reference.interfaceName())
+                && referenceClass.isInterface()) {
                 referenceConfig.setInterface(referenceClass);
             }
             if (applicationContext != null) {
                 referenceConfig.setApplicationContext(applicationContext);
-                if (reference.registry() != null && reference.registry().length > 0) {
+                reference.registry();","[{'comment': 'Please remove this line.', 'commenter': 'ralf0131'}, {'comment': 'oh,I am too careless... updated', 'commenter': 'refeccd'}]"
1827,dubbo-rpc/dubbo-rpc-http/src/main/java/com/alibaba/dubbo/rpc/protocol/http/HttpRemoteInvocation.java,"@@ -0,0 +1,57 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.dubbo.rpc.protocol.http;
+
+import com.alibaba.dubbo.common.Constants;
+import com.alibaba.dubbo.common.utils.StringUtils;
+import com.alibaba.dubbo.rpc.RpcContext;
+import org.aopalliance.intercept.MethodInvocation;
+import org.springframework.remoting.support.RemoteInvocation;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.HashMap;
+import java.util.Map;
+
+public class HttpRemoteInvocation extends RemoteInvocation {
+
+    private static final long serialVersionUID = 1L;
+    private static final String dubboAttachmentsAttrName = ""dubbo.attachments"";
+
+    public HttpRemoteInvocation(MethodInvocation methodInvocation) {
+        super(methodInvocation);
+        addAttribute(dubboAttachmentsAttrName, new HashMap<String, String>(RpcContext.getContext().getAttachments()));
+    }
+
+    @Override
+    public Object invoke(Object targetObject) throws NoSuchMethodException, IllegalAccessException,
+            InvocationTargetException {
+        RpcContext context = RpcContext.getContext();
+        context.setAttachments((Map<String, String>) getAttribute(dubboAttachmentsAttrName));
+
+        String generic = (String) getAttribute(Constants.GENERIC_KEY);
+        if (StringUtils.isNotEmpty(generic)) {
+            context.setAttachment(Constants.GENERIC_KEY, generic);
+        }
+        try {
+            return super.invoke(targetObject);
+        } finally {
+            context.setAttachments(null);","[{'comment': ""I think it's too early to remove the attachments."", 'commenter': 'chickenlj'}, {'comment': 'We can leave it to ContextFilter', 'commenter': 'chickenlj'}, {'comment': ""Sorry, there's no problem here. It's ok to clear attachments here, it executes after the Filter chain."", 'commenter': 'chickenlj'}]"
2053,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/extension/SpringExtensionFactory.java,"@@ -51,6 +53,16 @@ public static void clearContexts() {
     @Override
     @SuppressWarnings(""unchecked"")
     public <T> T getExtension(Class<T> type, String name) {
+
+        //SPI never get from spring bean factory
+        if (type.isInterface() && type.isAnnotationPresent(SPI.class)) {
+            ExtensionLoader<T> loader = ExtensionLoader.getExtensionLoader(type);","[{'comment': ""in this case, we should simply return `null` since it is SpiExtensionFactory's duty."", 'commenter': 'beiwei30'}, {'comment': ""you are right, it's not SpringExtensionFactory's duty to find SPI instance."", 'commenter': 'yunxiyi'}]"
2114,dubbo-config/dubbo-config-spring/src/main/resources/META-INF/dubbo.xsd,"@@ -708,6 +708,11 @@
                         <xsd:documentation><![CDATA[ Transporter layer framework: netty mina.... ]]></xsd:documentation>
                     </xsd:annotation>
                 </xsd:attribute>
+                <xsd:attribute name=""threadpool"" type=""xsd:string"" use=""optional"">
+                    <xsd:annotation>
+                        <xsd:documentation><![CDATA[ Consumer threadpool: cached, fixed, limited, eager]]></xsd:documentation>
+                    </xsd:annotation>
+                </xsd:attribute>","[{'comment': 'We may also need the following two parameters:\r\n```xml\r\n                <xsd:attribute name=""threads"" type=""xsd:string"" use=""optional"">\r\n                    <xsd:annotation>\r\n                        <xsd:documentation><![CDATA[ The thread pool size. ]]></xsd:documentation>\r\n                    </xsd:annotation>\r\n                </xsd:attribute>\r\n                <xsd:attribute name=""queues"" type=""xsd:string"" use=""optional"">\r\n                    <xsd:annotation>\r\n                        <xsd:documentation><![CDATA[ The thread pool queue size. ]]></xsd:documentation>\r\n                    </xsd:annotation>\r\n                </xsd:attribute>\r\n```', 'commenter': 'chickenlj'}, {'comment': 'And remember to add the same content to the compatible copy:\r\n\r\nhttps://github.com/apache/incubator-dubbo/blob/master/dubbo-config/dubbo-config-spring/src/main/resources/META-INF/compat/dubbo.xsd', 'commenter': 'chickenlj'}]"
2114,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java,"@@ -113,7 +111,12 @@ public AbstractClient(URL url, ChannelHandler handler) throws RemotingException
 
     protected static ChannelHandler wrapChannelHandler(URL url, ChannelHandler handler) {
         url = ExecutorUtil.setThreadName(url, CLIENT_THREAD_POOL_NAME);
-        url = url.addParameterIfAbsent(Constants.THREADPOOL_KEY, Constants.DEFAULT_CLIENT_THREADPOOL);
+        String key = Constants.DEFAULT_KEY + Constants.HIDE_KEY_PREFIX + Constants.THREADPOOL_KEY;
+        String threadpool = url.getParameter(key);
+        if (StringUtils.isNotEmpty(threadpool)) {
+            url = url.removeParameter(key);
+        }
+        url = url.addParameterIfAbsent(Constants.THREADPOOL_KEY, StringUtils.isNotEmpty(threadpool) ? threadpool : Constants.DEFAULT_CLIENT_THREADPOOL);","[{'comment': 'Do we need to change the code here?\r\nI think we will have `default.threadpool` key in automatically.', 'commenter': 'chickenlj'}, {'comment': '@chickenlj Ok, because I found that when ReferenceConfig integrate the configuration of ConsumerConfig, it will add the prefix ""default."", so the ""threadpool"" property of <dubbo:consumer ../> will change to ""default.thread"" parameter in the URL.\r\nSo, I think we have two ways to optimize the issue.\r\nFirst, take some special process when integrate the ""threadpool"" property of ConsumerConfig to ReferenceConfig to wipe off the prefix ""default.""；\r\nSecond is just the method that this sumbit uses.\r\nIf the second way is not so good, I think we can take the second one.', 'commenter': 'tswstarplanet'}, {'comment': 'Look at the `getParameter(""threadpool"")` logic in URL, it will: first check ""threadpool"" and then check ""default.threadpool""\r\n\r\nhttps://github.com/apache/incubator-dubbo/blob/0b6e6f3a375d82aab1a1f17b034e666c63f61103/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java#L421', 'commenter': 'chickenlj'}]"
2209,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboCodec.java,"@@ -90,6 +90,7 @@ protected Object decodeBody(Channel channel, InputStream is, byte[] header) thro
                             result = new DecodeableRpcResult(channel, res, is,
                                     (Invocation) getRequestData(id), proto);
                             result.decode();
+                            System.out.println(Thread.currentThread().getName());","[{'comment': 'Remove this line', 'commenter': 'chickenlj'}]"
2209,dubbo-common/src/main/java/com/alibaba/dubbo/common/Constants.java,"@@ -589,7 +589,8 @@
 
     public static final long DEFAULT_TPS_LIMIT_INTERVAL = 60 * 1000;
 
-    public static final String DECODE_IN_IO_THREAD_KEY = ""decode.in.io"";
+    //public static final String DECODE_IN_IO_THREAD_KEY = ""decode.in.io"";
+    public static final String DECODE_IN_IO_THREAD_KEY = ""decodeinio"";","[{'comment': 'This change will cause the incompatible problem for users already used this property.\r\n\r\nUse @Parameter annotation to solve this problem, see the comment below.', 'commenter': 'chickenlj'}]"
2209,dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ProtocolConfig.java,"@@ -454,6 +456,14 @@ public void setExtension(String extension) {
         this.extension = extension;
     }
 
+    public Boolean getDecodeInIo() {","[{'comment': 'Add @Parameter(key = ""decode.in.io"")', 'commenter': 'chickenlj'}, {'comment': 'thank you for your repley.there is another group who use the similiar way,and it seems they  dont have to change the src code.I think their way is better.', 'commenter': 'kid1994'}, {'comment': ""@kid1994 Sorry, could you please provide the link to that patch? I couldn't find it."", 'commenter': 'chickenlj'}]"
2210,dubbo-serialization/dubbo-serialization-kryo/src/main/java/org/apache/dubbo/common/serialize/kryo/CompatibleKryo.java,"@@ -34,7 +38,7 @@ public Serializer getDefaultSerializer(Class type) {
             throw new IllegalArgumentException(""type cannot be null."");
         }
 
-        if (!type.isArray() && !type.isEnum() && !ReflectionUtils.checkZeroArgConstructor(type)) {
+        if (!type.isArray() && !type.isEnum() && !type.equals(LocalDate.class) && !type.equals(LocalDateTime.class) && !type.equals(LocalTime.class) && !ReflectionUtils.checkZeroArgConstructor(type)) {","[{'comment': 'Simply check types will not solve the problem.', 'commenter': 'chickenlj'}, {'comment': ""Sorry, I've checked that this works, and kryo has internally registered some Serializers for Java 8 Time types. \r\n\r\nBut we still have a problem, we cannot list all possible classes here."", 'commenter': 'chickenlj'}]"
2213,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/zkclient/ZkClientWrapper.java,"@@ -43,28 +41,26 @@
     private long timeout;
     private ZkClient client;
     private volatile KeeperState state;
-    private ListenableFutureTask<ZkClient> listenableFutureTask;
+    private CompletableFuture<ZkClient> completableFuture;
     private volatile boolean started = false;
+    private static final ExecutorService executor = new ThreadPoolExecutor(0, 10, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new NamedThreadFactory(""DubboMonitorCreator"", true));
 
 
     public ZkClientWrapper(final String serverAddr, long timeout) {
         this.timeout = timeout;
-        listenableFutureTask = ListenableFutureTask.create(new Callable<ZkClient>() {
-            @Override
-            public ZkClient call() throws Exception {
+        completableFuture = CompletableFuture.supplyAsync(()->{
                 return new ZkClient(serverAddr, Integer.MAX_VALUE);
-            }
-        });
+        },executor);
     }
 
     public void start() {
         if (!started) {
-            Thread connectThread = new Thread(listenableFutureTask);
+            Thread connectThread = new Thread();","[{'comment': 'I think `Thread connectThread = new Thread();` is no longer needed here, because we already started `ZkClient` in an async thread by invoking `CompletableFuture.supplyAsync`', 'commenter': 'chickenlj'}]"
2213,dubbo-monitor/dubbo-monitor-api/src/main/java/org/apache/dubbo/monitor/support/AbstractMonitorFactory.java,"@@ -79,10 +70,13 @@ public Monitor getMonitor(URL url) {
             }
 
             final URL monitorUrl = url;
-            final ListenableFutureTask<Monitor> listenableFutureTask = ListenableFutureTask.create(new MonitorCreator(monitorUrl));
-            listenableFutureTask.addListener(new MonitorListener(key));
-            executor.execute(listenableFutureTask);
-            FUTURES.put(key, listenableFutureTask);
+            final CompletableFuture<Monitor> completableFuture = CompletableFuture.supplyAsync(()->{
+                Monitor newMonitor = AbstractMonitorFactory.this.createMonitor(monitorUrl);
+                return newMonitor;
+
+            },executor);
+            completableFuture.thenRunAsync(new MonitorListener(key));","[{'comment': 'We already defined an executor, specify this executor for `thenRunAsync ` may be better.', 'commenter': 'chickenlj'}]"
2213,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/zkclient/ZkClientWrapper.java,"@@ -75,11 +71,11 @@ public void start() {
     }
 
     public void addListener(final IZkStateListener listener) {
-        listenableFutureTask.addListener(new Runnable() {
+        completableFuture.thenRunAsync(new Runnable() {","[{'comment': '`whenComplete` or `handle` maybe better, and try to use lambda.', 'commenter': 'chickenlj'}]"
2213,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/zkclient/ZkClientWrapper.java,"@@ -71,18 +71,10 @@ public void start() {
     }
 
     public void addListener(final IZkStateListener listener) {
-        completableFuture.thenRunAsync(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    client = completableFuture.get();
-                    client.subscribeStateChanges(listener);
-                } catch (InterruptedException e) {
-                    logger.warn(Thread.currentThread().getName() + "" was interrupted unexpectedly, which may cause unpredictable exception!"");
-                } catch (ExecutionException e) {
-                    logger.error(""Got an exception when trying to create zkclient instance, can not connect to zookeeper server, please check!"", e);
-                }
-            }
+        completableFuture.whenComplete((v,e)->{
+            client = v;
+            client.subscribeStateChanges(listener);","[{'comment': 'I think we should handle the possible Exceptions that may come up here.', 'commenter': 'chickenlj'}]"
2228,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java,"@@ -0,0 +1,100 @@
+package org.apache.dubbo.rpc.cluster.router.tag;
+
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.Router;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author kirito.moe@foxmail.com","[{'comment': 'remove author plz', 'commenter': 'kimmking'}, {'comment': 'lack of ASF license in the head:\r\n\r\n```java\r\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n * this work for additional information regarding copyright ownership.\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n * (the ""License""); you may not use this file except in compliance with\r\n * the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an ""AS IS"" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n```', 'commenter': 'beiwei30'}, {'comment': 'got it, i will add licenses for all new files.', 'commenter': 'lexburner'}]"
2228,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java,"@@ -0,0 +1,100 @@
+package org.apache.dubbo.rpc.cluster.router.tag;
+
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.Router;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author kirito.moe@foxmail.com
+ * Date 2018-08-03
+ */
+public class TagRouter implements Router, Comparable<Router> {
+
+    private static final Logger logger = LoggerFactory.getLogger(TagRouter.class);
+
+    private final int priority;
+    private final URL url;
+
+    public static final URL ROUTER_URL =
+            new URL(""tag""
+                    , Constants.ANYHOST_VALUE, 0
+                    , Constants.ANY_VALUE)
+                    .addParameters(
+                            Constants.RUNTIME_KEY, ""true""
+                    );
+
+    public TagRouter(URL url) {
+        this.url = url;
+        this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);
+    }
+
+    public TagRouter() {
+        this.url = ROUTER_URL;
+        this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);
+    }
+
+    @Override
+    public URL getUrl() {
+        return url;
+    }
+
+    @Override
+    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
+        // filter
+        List<Invoker<T>> result = new ArrayList<>();
+        try {
+            // Dynamic param
+            String tag = RpcContext.getContext().getAttachment(Constants.REQUEST_TAG_KEY);
+            // Tag request
+            if (!StringUtils.isEmpty(tag)) {
+                // Select tag invokers first
+                for (Invoker<T> invoker : invokers) {","[{'comment': 'three for statement can be combined one and check conditions in it.', 'commenter': 'kimmking'}, {'comment': 'These three for statements have their own logic, depend on different conditions, can you give me more details, thanks a lot.', 'commenter': 'lexburner'}, {'comment': '@lexburner @kimmking i think three for statement can be combined too,my impl:\r\n\r\n    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {\r\n        // filter\r\n        List<Invoker<T>> result = new ArrayList<>();\r\n        // all invokers that don\'t have ""tag"" parameter in url is a normal invoker\r\n        List<Invoker<T>> normalResult = new ArrayList<>();\r\n        try {\r\n            // Dynamic param\r\n            String tag = RpcContext.getContext().getAttachment(REQUEST_TAG_KEY);\r\n\r\n            for (Invoker<T> invoker : invokers) {\r\n                if (StringUtils.isEmpty(invoker.getUrl().getParameter(TAG_KEY))) {\r\n                    // all invokers that don\'t have ""tag"" parameter in url is a normal invoker\r\n                    normalResult.add(invoker);\r\n                } else {\r\n                    if (invoker.getUrl().getParameter(TAG_KEY).equals(tag)) {\r\n                        result.add(invoker);\r\n                    }\r\n                }\r\n            }\r\n            // If no invoker be selected, downgrade to normal invokers\r\n            if (result.isEmpty()) {\r\n                return normalResult;\r\n            }\r\n            return result;\r\n        } catch (Exception e) {\r\n            logger.error(""Route by tag error,return all invokers."", e);\r\n        }\r\n        // Downgrade to all invokers\r\n        return invokers;\r\n    }', 'commenter': 'hupuxiaojun'}]"
2228,dubbo-config/dubbo-config-spring/src/main/resources/META-INF/dubbo.xsd,"@@ -307,6 +307,12 @@
                         <xsd:documentation><![CDATA[ The serialization protocol of service. ]]></xsd:documentation>
                     </xsd:annotation>
                 </xsd:attribute>
+                <xsd:attribute name=""tag"" type=""xsd:string"">","[{'comment': 'pls. also change dubbo-config-spring/src/main/resources/META-INF/compat/dubbo.xsd', 'commenter': 'beiwei30'}]"
2228,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java,"@@ -0,0 +1,100 @@
+package org.apache.dubbo.rpc.cluster.router.tag;
+
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.Router;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author kirito.moe@foxmail.com
+ * Date 2018-08-03
+ */
+public class TagRouter implements Router, Comparable<Router> {
+
+    private static final Logger logger = LoggerFactory.getLogger(TagRouter.class);
+
+    private final int priority;
+    private final URL url;
+
+    public static final URL ROUTER_URL =
+            new URL(""tag""","[{'comment': 'pls. change this to one liner, or complete remove it since I notice `TagRouter()` is redundant.', 'commenter': 'beiwei30'}]"
2228,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java,"@@ -0,0 +1,100 @@
+package org.apache.dubbo.rpc.cluster.router.tag;
+
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.Router;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author kirito.moe@foxmail.com
+ * Date 2018-08-03
+ */
+public class TagRouter implements Router, Comparable<Router> {
+
+    private static final Logger logger = LoggerFactory.getLogger(TagRouter.class);
+
+    private final int priority;
+    private final URL url;
+
+    public static final URL ROUTER_URL =
+            new URL(""tag""
+                    , Constants.ANYHOST_VALUE, 0
+                    , Constants.ANY_VALUE)
+                    .addParameters(
+                            Constants.RUNTIME_KEY, ""true""
+                    );
+
+    public TagRouter(URL url) {
+        this.url = url;
+        this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);
+    }
+
+    public TagRouter() {
+        this.url = ROUTER_URL;
+        this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);
+    }
+
+    @Override
+    public URL getUrl() {
+        return url;
+    }
+
+    @Override
+    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
+        // filter
+        List<Invoker<T>> result = new ArrayList<>();
+        try {
+            // Dynamic param
+            String tag = RpcContext.getContext().getAttachment(Constants.REQUEST_TAG_KEY);
+            // Tag request
+            if (!StringUtils.isEmpty(tag)) {
+                // Select tag invokers first
+                for (Invoker<T> invoker : invokers) {
+                    if (tag.equals(invoker.getUrl().getParameter(Constants.TAG_KEY))) {
+                        result.add(invoker);
+                    }
+                }
+                // If no invoker be selected, downgrade to normal invokers
+                if (result.isEmpty()) {
+                    for (Invoker<T> invoker : invokers) {
+                        if (StringUtils.isEmpty(invoker.getUrl().getParameter(Constants.TAG_KEY))) {
+                            result.add(invoker);
+                        }
+                    }
+                }
+                // Normal request
+            } else {
+                for (Invoker<T> invoker : invokers) {","[{'comment': ""for normal request, I guess we should include all invokers, no matter the service is published with or without tag, for example: what if all services are published with tag, then is it expected that there's no valid service to invoke?"", 'commenter': 'beiwei30'}, {'comment': 'This is intentional, if a service published with tag, we assume it as a new feature, and won\'t normal request or other feature\'s request hit it. Only the tag request hit the tag service.\r\n\r\nIn another case, tag request can hit normal service if (and only if) there is no tag service, i call it downgrade.\r\n\r\nI know that `no valid service to invoke` was sound terrible , but if users want to use TagRouter , i think it is their duty to know what will happen to their projects. \r\n\r\nBy default, if we do not config like:\r\n\r\n```\r\nMap<String,String> parameters = new HashMap<>();\r\nparameters.put(Constants.ROUTER_KEY, ""tag"");\r\napplicationConfig.setParameters(parameters);\r\n```\r\n\r\nThere will no TagRouter feature exist in our project. **Users who don\'t care about the TagRouter feature are not affected by it.**\r\n\r\n', 'commenter': 'lexburner'}]"
2228,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouterFactory.java,"@@ -0,0 +1,20 @@
+package org.apache.dubbo.rpc.cluster.router.tag;
+
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.cluster.Router;
+import org.apache.dubbo.rpc.cluster.RouterFactory;
+
+/**
+ * @author kirito.moe@foxmail.com","[{'comment': 'again, remove author and add ASF license header.', 'commenter': 'beiwei30'}]"
2228,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouterTest.java,"@@ -0,0 +1,157 @@
+package org.apache.dubbo.rpc.cluster.router.tag;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcInvocation;
+import org.apache.dubbo.rpc.cluster.Router;
+import org.apache.dubbo.rpc.cluster.RouterFactory;
+import org.apache.dubbo.rpc.cluster.router.MockInvoker;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author kirito.moe@foxmail.com","[{'comment': 'again, remove author info and add ASF license header.', 'commenter': 'beiwei30'}]"
2270,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -30,11 +30,7 @@
 import org.apache.dubbo.config.model.ApplicationModel;
 import org.apache.dubbo.config.model.ProviderModel;
 import org.apache.dubbo.config.support.Parameter;
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Protocol;
-import org.apache.dubbo.rpc.ProxyFactory;
-import org.apache.dubbo.rpc.ServiceClassHolder;
+import org.apache.dubbo.rpc.*;","[{'comment': ""Should avoid use of 'import org.apache.dubbo.rpc.*;'"", 'commenter': 'chickenlj'}]"
2278,dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java,"@@ -21,12 +21,7 @@
 import org.apache.dubbo.common.logger.LoggerFactory;
 
 import java.io.IOException;
-import java.net.Inet6Address;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.NetworkInterface;
-import java.net.ServerSocket;
-import java.net.UnknownHostException;
+import java.net.*;","[{'comment': 'Should avoid use of `import *` here', 'commenter': 'chickenlj'}]"
2279,dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2LoggerAdapter.java,"@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.logger.log4j2;
+
+import org.apache.dubbo.common.logger.Level;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerAdapter;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.core.Appender;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.appender.FileAppender;
+
+import java.io.File;
+import java.util.Collection;
+import java.util.Map;
+
+public class Log4j2LoggerAdapter implements LoggerAdapter {
+
+    private File file;
+
+    public Log4j2LoggerAdapter() {
+        try {
+            org.apache.logging.log4j.Logger logger = LogManager.getRootLogger();
+            if (logger != null) {
+                //Appender
+                LoggerContext context = (LoggerContext)LogManager.getContext(false);
+                Map<String, Appender> appenders = context.getConfiguration().getAppenders();
+                Collection<Appender> appenderCollection = appenders.values();","[{'comment': 'Collection is useless.', 'commenter': 'noahziheng'}]"
2279,dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2LoggerAdapter.java,"@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.logger.log4j2;
+
+import org.apache.dubbo.common.logger.Level;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerAdapter;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.core.Appender;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.appender.FileAppender;
+
+import java.io.File;
+import java.util.Collection;
+import java.util.Map;
+
+public class Log4j2LoggerAdapter implements LoggerAdapter {
+
+    private File file;
+
+    public Log4j2LoggerAdapter() {
+        try {
+            org.apache.logging.log4j.Logger logger = LogManager.getRootLogger();
+            if (logger != null) {
+                //Appender
+                LoggerContext context = (LoggerContext)LogManager.getContext(false);
+                Map<String, Appender> appenders = context.getConfiguration().getAppenders();
+                Collection<Appender> appenderCollection = appenders.values();
+                for (Appender appender : appenderCollection) {
+                    if (appender instanceof FileAppender) {
+                        FileAppender fileAppender = (FileAppender)appender;
+                        String fileName = fileAppender.getFileName();
+                        file = new File(fileName);
+                        break;
+                    }
+                }
+            }
+        }catch (Throwable t){
+        }
+    }
+
+    private static org.apache.logging.log4j.Level toLog4jLevel(Level level) {
+        if (level == Level.ALL) { return org.apache.logging.log4j.Level.ALL; }
+        if (level == Level.TRACE) { return org.apache.logging.log4j.Level.TRACE; }
+        if (level == Level.DEBUG) { return org.apache.logging.log4j.Level.DEBUG; }
+        if (level == Level.INFO) { return org.apache.logging.log4j.Level.INFO; }
+        if (level == Level.WARN) { return org.apache.logging.log4j.Level.WARN; }
+        if (level == Level.ERROR) { return org.apache.logging.log4j.Level.ERROR; }
+        return org.apache.logging.log4j.Level.OFF;
+    }
+
+    private static Level fromLog4jLevel(org.apache.logging.log4j.Level level) {
+        if (level == org.apache.logging.log4j.Level.ALL) { return Level.ALL; }
+        if (level == org.apache.logging.log4j.Level.TRACE) { return Level.TRACE; }
+        if (level == org.apache.logging.log4j.Level.DEBUG) { return Level.DEBUG; }
+        if (level == org.apache.logging.log4j.Level.INFO) { return Level.INFO; }
+        if (level == org.apache.logging.log4j.Level.WARN) { return Level.WARN; }
+        if (level == org.apache.logging.log4j.Level.ERROR) { return Level.ERROR; }
+        return Level.OFF;
+    }
+
+    @Override
+    public Logger getLogger(Class<?> key) {
+        return new Log4j2Logger(LogManager.getLogger(key));
+    }
+
+    @Override
+    public Logger getLogger(String key) {
+        return new Log4j2Logger(LogManager.getLogger(key));
+    }
+
+    @Override
+    public Level getLevel() {
+        return fromLog4jLevel(LogManager.getRootLogger().getLevel());
+    }
+
+    @Override
+    public void setLevel(Level level) {","[{'comment': ""`SetLevel` method isn't implemented,"", 'commenter': 'noahziheng'}]"
2279,dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2LoggerAdapter.java,"@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.logger.log4j2;
+
+import org.apache.dubbo.common.logger.Level;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerAdapter;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.core.Appender;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.appender.FileAppender;
+
+import java.io.File;
+import java.util.Collection;
+import java.util.Map;
+
+public class Log4j2LoggerAdapter implements LoggerAdapter {
+
+    private File file;
+
+    public Log4j2LoggerAdapter() {
+        try {
+            org.apache.logging.log4j.Logger logger = LogManager.getRootLogger();
+            if (logger != null) {
+                //Appender
+                LoggerContext context = (LoggerContext)LogManager.getContext(false);
+                Map<String, Appender> appenders = context.getConfiguration().getAppenders();
+                Collection<Appender> appenderCollection = appenders.values();
+                for (Appender appender : appenderCollection) {
+                    if (appender instanceof FileAppender) {
+                        FileAppender fileAppender = (FileAppender)appender;
+                        String fileName = fileAppender.getFileName();
+                        file = new File(fileName);
+                        break;
+                    }
+                }
+            }
+        }catch (Throwable t){
+        }
+    }
+
+    private static org.apache.logging.log4j.Level toLog4jLevel(Level level) {
+        if (level == Level.ALL) { return org.apache.logging.log4j.Level.ALL; }
+        if (level == Level.TRACE) { return org.apache.logging.log4j.Level.TRACE; }
+        if (level == Level.DEBUG) { return org.apache.logging.log4j.Level.DEBUG; }
+        if (level == Level.INFO) { return org.apache.logging.log4j.Level.INFO; }
+        if (level == Level.WARN) { return org.apache.logging.log4j.Level.WARN; }
+        if (level == Level.ERROR) { return org.apache.logging.log4j.Level.ERROR; }
+        return org.apache.logging.log4j.Level.OFF;
+    }
+
+    private static Level fromLog4jLevel(org.apache.logging.log4j.Level level) {
+        if (level == org.apache.logging.log4j.Level.ALL) { return Level.ALL; }
+        if (level == org.apache.logging.log4j.Level.TRACE) { return Level.TRACE; }
+        if (level == org.apache.logging.log4j.Level.DEBUG) { return Level.DEBUG; }
+        if (level == org.apache.logging.log4j.Level.INFO) { return Level.INFO; }
+        if (level == org.apache.logging.log4j.Level.WARN) { return Level.WARN; }
+        if (level == org.apache.logging.log4j.Level.ERROR) { return Level.ERROR; }
+        return Level.OFF;
+    }
+
+    @Override
+    public Logger getLogger(Class<?> key) {
+        return new Log4j2Logger(LogManager.getLogger(key));
+    }
+
+    @Override
+    public Logger getLogger(String key) {
+        return new Log4j2Logger(LogManager.getLogger(key));
+    }
+
+    @Override
+    public Level getLevel() {
+        return fromLog4jLevel(LogManager.getRootLogger().getLevel());
+    }
+
+    @Override
+    public void setLevel(Level level) {
+    }
+
+    @Override
+    public File getFile() {
+        return file;
+    }
+
+    @Override
+    public void setFile(File file) {","[{'comment': ""`SetLevel` method isn't implemented,"", 'commenter': 'noahziheng'}]"
2279,dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2LoggerAdapter.java,"@@ -0,0 +1,105 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.logger.log4j2;
+
+import org.apache.dubbo.common.logger.Level;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerAdapter;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.core.Appender;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.appender.FileAppender;
+
+import java.io.File;
+import java.util.Iterator;
+import java.util.Map;
+
+public class Log4j2LoggerAdapter implements LoggerAdapter {
+
+    private File file;
+
+    public Log4j2LoggerAdapter() {
+        try {
+            org.apache.logging.log4j.Logger logger = LogManager.getRootLogger();
+            if (logger != null) {
+                LoggerContext context = (LoggerContext)LogManager.getContext(false);
+                Map<String, Appender> appenders = context.getConfiguration().getAppenders();","[{'comment': 'Pls check NPE for appenders.', 'commenter': 'diecui1202'}]"
2279,dubbo-common/pom.xml,"@@ -43,6 +43,14 @@
             <groupId>log4j</groupId>
             <artifactId>log4j</artifactId>
         </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-api</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-core</artifactId>
+        </dependency>","[{'comment': 'add provided scope for these 2 dependencies?', 'commenter': 'diecui1202'}]"
2457,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,"@@ -21,10 +21,7 @@
 import org.apache.dubbo.common.extension.ExtensionLoader;
 import org.apache.dubbo.common.serialize.support.SerializableClassRegistry;
 import org.apache.dubbo.common.serialize.support.SerializationOptimizer;
-import org.apache.dubbo.common.utils.ConcurrentHashSet;
-import org.apache.dubbo.common.utils.ConfigUtils;
-import org.apache.dubbo.common.utils.NetUtils;
-import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.common.utils.*;","[{'comment': 'DO NOT use import *', 'commenter': 'diecui1202'}]"
2457,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,"@@ -47,11 +44,7 @@
 import org.apache.dubbo.rpc.protocol.AbstractProtocol;
 
 import java.net.InetSocketAddress;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Map;
-import java.util.Set;
+import java.util.*;","[{'comment': 'the same problem', 'commenter': 'diecui1202'}]"
2457,dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java,"@@ -116,13 +116,15 @@
 
     public static final int DEFAULT_THREADS = 200;
 
-    public static final boolean DEFAULT_KEEP_ALIVE = true;
+    public static final boolean DEFAULT_KEEP_ALIVE = true;`````","[{'comment': 'What is this?', 'commenter': 'diecui1202'}]"
2457,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,"@@ -384,31 +379,37 @@ private void optimizeSerialization(URL url) throws RpcException {
     /**
      * Get shared connection
      */
-    private ExchangeClient getSharedClient(URL url) {
+    private List<ReferenceCountExchangeClient> getSharedClient(URL url) {
         String key = url.getAddress();
-        ReferenceCountExchangeClient client = referenceClientMap.get(key);
-        if (client != null) {
-            if (!client.isClosed()) {
-                client.incrementAndGetCount();
-                return client;
-            } else {
-                referenceClientMap.remove(key);
-            }
+        List<ReferenceCountExchangeClient> clients = referenceClientMap.get(key);
+        if(clients == null) {
+            List<ReferenceCountExchangeClient> referenceCountExchangeClients = buildReferenceCountExchangeClientList(url, key, connectNum);","[{'comment': 'ReferenceCountExchangeClient is for sharing connections. I saw your pr. Your pr wants to create multiple connections instead of sharing connections by default. In this case, what is the purpose of using ReferenceCountExchangeClient?', 'commenter': 'carryxyh'}, {'comment': ""It's reasonable. I'll optimize it again."", 'commenter': 'manzhizhen'}, {'comment': 'Hello, if you just change the default share to multiple, then just change the default value of connections? How do u think about it?\r\n:)', 'commenter': 'carryxyh'}]"
2457,dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java,"@@ -122,7 +122,9 @@
 
     public static final int DEFAULT_ALIVE = 60 * 1000;
 
-    public static final int DEFAULT_CONNECTIONS = 0;
+    public static final String DEFAULT_CONNECTIONS = ""1"";","[{'comment': 'int is better.', 'commenter': 'kimmking'}, {'comment': 'I modified the DEFAULT_CONNECTIONS to see the code, which is not used before. The reason is changed to String type, because it is convenient with ConfigUtils.getProperty, haha', 'commenter': 'manzhizhen'}]"
2457,dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java,"@@ -122,7 +122,9 @@
 
     public static final int DEFAULT_ALIVE = 60 * 1000;
 
-    public static final int DEFAULT_CONNECTIONS = 0;
+    public static final String DEFAULT_CONNECTIONS = ""1"";
+
+    public static final String DEFAULT_CONNECTIONS_KEY = ""default.connections.key"";","[{'comment': 'suggest to change to `public static final String SERVICE_CONNECTIONS_KEY = ""service.connections.key""`', 'commenter': 'beiwei30'}, {'comment': 'Good idea!', 'commenter': 'manzhizhen'}]"
2457,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,"@@ -383,32 +388,57 @@ private void optimizeSerialization(URL url) throws RpcException {
 
     /**
      * Get shared connection
+     *
+     * @param url
+     * @param connectNum
      */
-    private ExchangeClient getSharedClient(URL url) {
+    private List<ReferenceCountExchangeClient> getSharedClient(URL url, int connectNum) {","[{'comment': 'This method should have potential contention issue, especially when `getClients()` gets called with the same URL at the same moment (is it possible?)', 'commenter': 'beiwei30'}, {'comment': 'You are right, this does have a concurrency problem, I fix it, haha！！', 'commenter': 'manzhizhen'}]"
2457,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,"@@ -383,32 +388,57 @@ private void optimizeSerialization(URL url) throws RpcException {
 
     /**
      * Get shared connection
+     *
+     * @param url
+     * @param connectNum
      */
-    private ExchangeClient getSharedClient(URL url) {
+    private List<ReferenceCountExchangeClient> getSharedClient(URL url, int connectNum) {
         String key = url.getAddress();
-        ReferenceCountExchangeClient client = referenceClientMap.get(key);
-        if (client != null) {
-            if (!client.isClosed()) {
+        List<ReferenceCountExchangeClient> clients = referenceClientMap.get(key);
+        boolean firstBuild = false;
+
+        if (clients == null) {
+            List<ReferenceCountExchangeClient> referenceCountExchangeClients = buildReferenceCountExchangeClientList(url, key, connectNum);
+            referenceClientMap.put(key, referenceCountExchangeClients);
+
+            clients = referenceCountExchangeClients;
+
+            firstBuild = true;
+        }
+
+        for (int i = 0; i < clients.size(); i++) {
+            ReferenceCountExchangeClient client = clients.get(i);
+            if (client.isClosed()) {
+                client = buildReferenceCountExchangeClient(url, key);
+                clients.set(i, client);
+
+            } else if (!firstBuild) {
                 client.incrementAndGetCount();
-                return client;
-            } else {
-                referenceClientMap.remove(key);
             }
         }
 
-        locks.putIfAbsent(key, new Object());
-        synchronized (locks.get(key)) {
-            if (referenceClientMap.containsKey(key)) {
-                return referenceClientMap.get(key);
-            }
+        return clients;
+    }
+
+    private List<ReferenceCountExchangeClient> buildReferenceCountExchangeClientList(URL url, String key, int connectNum) {
 
-            ExchangeClient exchangeClient = initClient(url);
-            client = new ReferenceCountExchangeClient(exchangeClient, ghostClientMap);
-            referenceClientMap.put(key, client);
-            ghostClientMap.remove(key);
-            locks.remove(key);
-            return client;
+        List<ReferenceCountExchangeClient> clients = new ArrayList<ReferenceCountExchangeClient>(connectNum);
+
+        for (int i = 0; i < connectNum; i++) {
+            clients.add(buildReferenceCountExchangeClient(url, key));
         }
+
+        return clients;
+    }
+
+    private ReferenceCountExchangeClient buildReferenceCountExchangeClient(URL url, String key) {
+
+        ExchangeClient exchangeClient = initClient(url);
+
+        ReferenceCountExchangeClient client = new ReferenceCountExchangeClient(exchangeClient, ghostClientMap);","[{'comment': '`ghostClientMap` is a mapping between URL and client, but `referenceClientMap` is a mapping between URL and a list of clients.', 'commenter': 'beiwei30'}, {'comment': 'Delayed connections are used to reduce the number of long connections. Create a long connection when a call is initiated. <dubbo:protocol name=""dubbo"" lazy=""true"" />Note: This configuration only works for dubbo protocols that use long connections.\r\nLater I read the code about the delayed connection and found that LazyConnectExchangeClient has two purposes:\r\n1. Create a connection like the delay mentioned earlier, minimizing unnecessary long connection overhead.\r\n2. A kind of protection when closing the connection resource. When the ReferenceCountExchangeClient is closed (multiple URLs refer to the same ReferenceCountExchangeClient, the last URL that will reference the counter to 0 can actually close the ReferenceCountExchangeClient) will be replaced with LazyConnectExchangeClient. When used again, the warn log will be printed. The put operation of ghostClientMap is only available here.\r\n\r\nSo, no matter how many ExchangeClients a URL corresponds to, it only needs a ghost connection in the ghostClientMap, which is a LazyConnectExchangeClient.\r\n\r\nAlso, only the shared ExchangeClient will use the ReferenceCountExchangeClient, so the default client used to share a TCP connection is the ReferenceCountExchangeClient, and the separate TCP connection set by connections does not need or use the ReferenceCountExchangeClient.\r\n\r\n延迟连接用于减少长连接数。当有调用发起时,再创建长连接。<dubbo:protocol name=""dubbo"" lazy=""true"" />注意:该配置只对使用长连接的 dubbo 协议生效。 \r\n后面我有仔细阅读了关于延迟连接的代码，发现LazyConnectExchangeClient有两个用途：\r\n1. 像前面提到的延迟创建连接，尽可能的减少不必要的长连接开销。\r\n2. 关闭连接资源时的一种保护，当ReferenceCountExchangeClient被关闭时（多个URL引用同一个ReferenceCountExchangeClient时，最后那个将引用计数器变为0的URL可以真正关闭该ReferenceCountExchangeClient），会被替换成LazyConnectExchangeClient，一旦再被使用，会打印warn日志。而ghostClientMap的put操作，只有在这里才有。\r\n\r\n所以，不管一个URL对应多少个ExchangeClient，它在ghostClientMap中最多只需要一个幽灵连接，即一个LazyConnectExchangeClient。\r\n\r\n并且，只有共享的ExchangeClient才会用到ReferenceCountExchangeClient，所以默认的共享1条TCP连接所使用的client就是ReferenceCountExchangeClient，而通过connections设置的单独TCP连接不需要也没有使用ReferenceCountExchangeClient。', 'commenter': 'manzhizhen'}, {'comment': 'If I understand the mistake, please correct me, thank you', 'commenter': 'manzhizhen'}]"
2562,dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConfigUtils.java,"@@ -217,7 +217,8 @@ public static Properties loadProperties(String fileName, boolean allowMultiFile)
      */
     public static Properties loadProperties(String fileName, boolean allowMultiFile, boolean optional) {
         Properties properties = new Properties();
-        if (fileName.startsWith(""/"")) {
+        //add scene judgement in windows environment Fix 2557
+        if (fileName.startsWith(""/"")||fileName.matches(""^[A-z]:\\\\\\S+$"")) {","[{'comment': '1. Would u pls format your code?\r\n\r\n2. Pls use doc as this:\r\n// add scene...\r\nRemember the space.\r\n\r\n3. pls add some unit test.', 'commenter': 'carryxyh'}, {'comment': '1.sorry,I do not format my code,I  will do it.\r\n2.ok.I will get the space.\r\n3. the testcase(com.alibaba.dubbo.config.AbstractInterfaceConfigTest#checkApplication1) existed before', 'commenter': 'SuperDubbo'}]"
2566,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java,"@@ -85,24 +85,31 @@ public Registry getRegistry(URL url) {
         url = url.setPath(RegistryService.class.getName())
                 .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())
                 .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);
+        
         String key = url.toServiceString();
-        // Lock the registry access process to ensure a single instance of the registry
-        LOCK.lock();
-        try {
-            Registry registry = REGISTRIES.get(key);
-            if (registry != null) {
-                return registry;
-            }
-            registry = createRegistry(url);
-            if (registry == null) {
-                throw new IllegalStateException(""Can not create registry "" + url);
+        
+        Registry registry = REGISTRIES.get(key);
+
+        if (registry == null){
+
+            //阻塞创建相同的注册服务","[{'comment': ""1.use English\r\n2. use doc like this: // doc...  don't forget the space."", 'commenter': 'carryxyh'}]"
2566,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java,"@@ -85,24 +85,31 @@ public Registry getRegistry(URL url) {
         url = url.setPath(RegistryService.class.getName())
                 .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())
                 .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);
+        
         String key = url.toServiceString();
-        // Lock the registry access process to ensure a single instance of the registry
-        LOCK.lock();
-        try {
-            Registry registry = REGISTRIES.get(key);
-            if (registry != null) {
-                return registry;
-            }
-            registry = createRegistry(url);
-            if (registry == null) {
-                throw new IllegalStateException(""Can not create registry "" + url);
+        
+        Registry registry = REGISTRIES.get(key);
+
+        if (registry == null){
+
+            //阻塞创建相同的注册服务
+            synchronized (key){
+
+                if (registry == null){
+
+                    registry = createRegistry(url) ;
+","[{'comment': 'remove unnecessary enter', 'commenter': 'carryxyh'}]"
2566,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java,"@@ -85,24 +85,31 @@ public Registry getRegistry(URL url) {
         url = url.setPath(RegistryService.class.getName())
                 .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())
                 .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);
+        
         String key = url.toServiceString();
-        // Lock the registry access process to ensure a single instance of the registry
-        LOCK.lock();
-        try {
-            Registry registry = REGISTRIES.get(key);
-            if (registry != null) {
-                return registry;
-            }
-            registry = createRegistry(url);
-            if (registry == null) {
-                throw new IllegalStateException(""Can not create registry "" + url);
+        
+        Registry registry = REGISTRIES.get(key);
+
+        if (registry == null){
+
+            //阻塞创建相同的注册服务
+            synchronized (key){","[{'comment': 'Locking here is not correct.', 'commenter': 'zonghaishang'}]"
2594,dubbo-filter/dubbo-filter-cache/src/main/java/org/apache/dubbo/cache/Cache.java,"@@ -25,4 +25,10 @@
 
     Object get(Object key);
 
+    boolean remove(Object key);","[{'comment': 'how to use it?', 'commenter': 'kimmking'}, {'comment': 'when user want to Invalidate cache,espescially in ThreadLocalCache.details about this commit can be found in [#2592](https://github.com/apache/incubator-dubbo/issues/2592)', 'commenter': 'dugenkui03'}]"
2597,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RandomLoadBalance.java,"@@ -34,13 +34,13 @@
     @Override
     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
         int length = invokers.size(); // Number of invokers
-        int totalWeight = 0; // The sum of weights
         boolean sameWeight = true; // Every invoker has the same weight?
-        for (int i = 0; i < length; i++) {
+        int firstWeight = getWeight(invokers.get(0), invocation);","[{'comment': 'out of bound without checking', 'commenter': 'kimmking'}, {'comment': 'I think it is not necessary to check because the select method of AbstractLoadBalance that invoke the method has check the null pointer and the size of the invoker list. If the size of the list is 0, it will not reach here.', 'commenter': 'tswstarplanet'}]"
2607,dubbo-rpc/dubbo-rpc-rest/src/test/java/com/alibaba/dubbo/rpc/protocol/rest/RestProtocolTest.java,"@@ -20,14 +20,7 @@
 import com.alibaba.dubbo.common.URL;
 import com.alibaba.dubbo.common.extension.ExtensionLoader;
 import com.alibaba.dubbo.common.utils.NetUtils;
-import com.alibaba.dubbo.rpc.Exporter;
-import com.alibaba.dubbo.rpc.Protocol;
-import com.alibaba.dubbo.rpc.ProxyFactory;
-import com.alibaba.dubbo.rpc.Result;
-import com.alibaba.dubbo.rpc.RpcContext;
-import com.alibaba.dubbo.rpc.RpcException;
-import com.alibaba.dubbo.rpc.RpcInvocation;
-import com.alibaba.dubbo.rpc.ServiceClassHolder;
+import com.alibaba.dubbo.rpc.*;","[{'comment': 'no `import *`', 'commenter': 'beiwei30'}]"
2607,dubbo-rpc/dubbo-rpc-rest/src/test/java/com/alibaba/dubbo/rpc/protol/rest/RestProtocolTest.java,"@@ -16,6 +16,7 @@
  */
 package com.alibaba.dubbo.rpc.protol.rest;
 
+import com.alibaba.dubbo.common.Constants;
 import com.alibaba.dubbo.common.URL;
 import com.alibaba.dubbo.common.extension.ExtensionLoader;
 import com.alibaba.dubbo.rpc.*;","[{'comment': 'no `import *` hear too.', 'commenter': 'beiwei30'}]"
2618,dubbo-registry/dubbo-registry-redis/src/test/java/com/alibaba/dubbo/registry/redis/RedisRegistryFactoryTest.java,"@@ -0,0 +1,9 @@
+package com.alibaba.dubbo.registry.redis;
+
+/**
+ * Author: Song Kun","[{'comment': 'remove authoer info', 'commenter': 'carryxyh'}]"
2618,dubbo-registry/dubbo-registry-redis/src/test/java/com/alibaba/dubbo/registry/redis/RedisRegistryFactoryTest.java,"@@ -0,0 +1,9 @@
+package com.alibaba.dubbo.registry.redis;","[{'comment': 'miss license', 'commenter': 'carryxyh'}]"
2618,dubbo-serialization/dubbo-serialization-protobuf/src/main/java/org/apache/dubbo/common/serialize/protobuf/Wrapper.java,"@@ -0,0 +1,16 @@
+package org.apache.dubbo.common.serialize.protobuf;
+
+/**
+ *","[{'comment': 'unnecessary comment', 'commenter': 'carryxyh'}]"
2618,dubbo-serialization/dubbo-serialization-protobuf/src/main/java/org/apache/dubbo/common/serialize/protobuf/utils/WrapperUtils.java,"@@ -0,0 +1,50 @@
+package org.apache.dubbo.common.serialize.protobuf.utils;","[{'comment': 'license', 'commenter': 'carryxyh'}]"
2618,dubbo-serialization/dubbo-serialization-protobuf/src/test/resources/log4j.xml,"@@ -0,0 +1,32 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+ - Copyright 1999-2011 Alibaba Group.
+ -  
+ - Licensed under the Apache License, Version 2.0 (the ""License"");
+ - you may not use this file except in compliance with the License.
+ - You may obtain a copy of the License at
+ -  
+ -      http://www.apache.org/licenses/LICENSE-2.0
+ -  
+ - Unless required by applicable law or agreed to in writing, software
+ - distributed under the License is distributed on an ""AS IS"" BASIS,
+ - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ - See the License for the specific language governing permissions and
+ - limitations under the License.
+-->
+<!DOCTYPE log4j:configuration SYSTEM ""log4j.dtd"">
+<log4j:configuration xmlns:log4j=""http://jakarta.apache.org/log4j/"">
+    <!-- ===================================================================== -->
+    <!-- 以下是appender的定义 -->","[{'comment': 'use english', 'commenter': 'carryxyh'}]"
2618,dubbo-serialization/dubbo-serialization-protobuf/src/main/java/org/apache/dubbo/common/serialize/protobuf/ProtobufObjectOutput.java,"@@ -0,0 +1,121 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.serialize.protobuf;
+
+import io.protostuff.*;","[{'comment': 'It is not recommended like this ""import io.protostuff.*;"" as the checkstyle will report error ""Using the \'.*\' form of import should be avoided""', 'commenter': 'Jeff-Lv'}]"
2618,dubbo-serialization/dubbo-serialization-protobuf/src/main/java/org/apache/dubbo/common/serialize/protobuf/ProtobufObjectOutput.java,"@@ -0,0 +1,121 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.serialize.protobuf;
+
+import io.protostuff.*;
+import io.protostuff.runtime.RuntimeSchema;
+import org.apache.dubbo.common.serialize.ObjectOutput;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Map;
+
+public class ProtobufObjectOutput implements ObjectOutput {
+
+    private DataOutputStream dos;
+
+    public ProtobufObjectOutput(OutputStream outputStream) {
+        dos = new DataOutputStream(outputStream);
+    }
+
+    @Override
+    public void writeObject(Object obj) throws IOException {
+        LinkedBuffer buffer = LinkedBuffer.allocate();","[{'comment': ""The buffer's mainly purpose is for performance with caching. Here is created everytime.\r\n\r\nThe following is a good sample.\r\n`\r\n // Re-use (manage) this buffer to avoid allocating on every serialization\r\n    LinkedBuffer buffer = LinkedBuffer.allocate(512);\r\n\r\n    // ser\r\n    final byte[] protostuff;\r\n    try\r\n    {\r\n        protostuff = ProtostuffIOUtil.toByteArray(foo, schema, buffer);\r\n    }\r\n    finally\r\n    {\r\n        buffer.clear();\r\n    }\r\n`"", 'commenter': 'Jeff-Lv'}]"
2618,dubbo-serialization/dubbo-serialization-protobuf/src/main/java/org/apache/dubbo/common/serialize/protobuf/ProtobufObjectInput.java,"@@ -0,0 +1,157 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.serialize.protobuf;
+
+import io.protostuff.ProtobufIOUtil;
+import io.protostuff.Schema;
+import io.protostuff.runtime.RuntimeSchema;
+import org.apache.dubbo.common.serialize.ObjectInput;
+
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Type;
+
+public class ProtobufObjectInput implements ObjectInput {
+
+    private DataInputStream dis;
+
+    public ProtobufObjectInput(InputStream inputStream) {
+        dis = new DataInputStream(inputStream);
+    }
+
+    @SuppressWarnings(""ResultOfMethodCallIgnored"")
+    @Override
+    public Object readObject() throws IOException, ClassNotFoundException {
+        int classNameLength = dis.readInt();
+        int bytesLength = dis.readInt();
+
+        if (classNameLength < 0 || bytesLength < 0) {
+            throw new IOException();
+        }
+
+        byte[] classNameBytes = new byte[classNameLength];
+        dis.readFully(classNameBytes, 0, classNameLength);
+
+        byte[] bytes = new byte[bytesLength];
+        dis.readFully(bytes, 0, bytesLength);
+
+        String className = new String(classNameBytes);
+        Class clazz = Class.forName(className);
+
+        Object result;
+        if (Utils.WRAPPER_SET.contains(clazz) || clazz.isArray() || clazz.isEnum()) {
+            Schema<Wrapper> schema = RuntimeSchema.getSchema(Wrapper.class);
+            Wrapper wrapper = schema.newMessage();
+            ProtobufIOUtil.mergeFrom(bytes, wrapper, schema);
+            result = wrapper.getData();
+        } else {
+            Schema schema = RuntimeSchema.getSchema(clazz);
+            result = schema.newMessage();
+            ProtobufIOUtil.mergeFrom(bytes, result, schema);
+        }
+
+        return result;
+    }
+
+    @Override
+    public <T> T readObject(Class<T> clazz) throws IOException, ClassNotFoundException {
+        int classNameLength = dis.readInt();
+        int bytesLength = dis.readInt();
+
+        if (classNameLength < 0 || bytesLength < 0) {
+            throw new IOException();
+        }
+
+        byte[] classNameBytes = new byte[classNameLength];
+        dis.read(classNameBytes, 0, classNameLength);
+
+        byte[] bytes = new byte[bytesLength];
+        dis.read(bytes, 0, bytesLength);
+
+        T result;
+        if (Utils.WRAPPER_SET.contains(clazz) || clazz.isArray() || clazz.isEnum()) {
+            Schema<Wrapper> schema = RuntimeSchema.getSchema(Wrapper.class);
+            Wrapper wrapper = schema.newMessage();
+            ProtobufIOUtil.mergeFrom(bytes, wrapper, schema);
+            result = (T) wrapper.getData();
+        } else {
+            Schema<T> schema = RuntimeSchema.getSchema(clazz);
+            result = schema.newMessage();
+            ProtobufIOUtil.mergeFrom(bytes, result, schema);
+        }
+
+        return result;","[{'comment': 'advice to refactor here by method extraction because here is a lot of replicated codes.', 'commenter': 'Jeff-Lv'}]"
2627,dubbo-common/src/main/java/org/apache/dubbo/common/utils/LRUCache.java,"@@ -41,75 +45,90 @@ public LRUCache(int maxCapacity) {
 
     @Override
     protected boolean removeEldestEntry(java.util.Map.Entry<K, V> eldest) {
-        return size() > maxCapacity;
+        readLock.lock();
+        try {
+            return super.size() > maxCapacity;
+        } finally {
+            readLock.unlock();
+        }
     }
 
     @Override
     public boolean containsKey(Object key) {
-        lock.lock();
+        readLock.lock();
         try {
             return super.containsKey(key);
         } finally {
-            lock.unlock();
+            readLock.unlock();
         }
     }
 
     @Override
     public V get(Object key) {
-        lock.lock();
+        readLock.lock();
         try {
             return super.get(key);
         } finally {
-            lock.unlock();
+            readLock.unlock();
         }
     }
 
     @Override
     public V put(K key, V value) {
-        lock.lock();
+        writeLock.lock();
         try {
             return super.put(key, value);
         } finally {
-            lock.unlock();
+            writeLock.unlock();
         }
     }
 
     @Override
     public V remove(Object key) {
-        lock.lock();
+        writeLock.lock();
         try {
             return super.remove(key);
         } finally {
-            lock.unlock();
+            writeLock.unlock();
         }
     }
 
     @Override
     public int size() {
-        lock.lock();
+        readLock.lock();
         try {
             return super.size();
         } finally {
-            lock.unlock();
+            readLock.unlock();
         }
     }
 
     @Override
     public void clear() {
-        lock.lock();
+        writeLock.lock();
         try {
             super.clear();
         } finally {
-            lock.unlock();
+            writeLock.unlock();
         }
     }
 
     public int getMaxCapacity() {
-        return maxCapacity;
+        readLock.lock();","[{'comment': 'why should add lock here?', 'commenter': 'carryxyh'}, {'comment': ""> why should add lock here?\r\n\r\nJust to keep the same style：original code add lock on method `size()`-this method just read variable in HashMap(`transient int size`).this method just read variable `maxCapacity`.\r\n\r\nI think it's safe to remove lock,and that can improve the performance."", 'commenter': 'dugenkui03'}, {'comment': 'agree.\r\nunnecessary lock. :)', 'commenter': 'carryxyh'}, {'comment': '> agree.\r\n> unnecessary lock. :)\r\n\r\n>i ignored that  maxCapacity is volatile,and it is  threadSafe without lock.and size. size() with lock can assure memory visibility [参考](https://stackoverflow.com/questions/12429818/does-explicit-lock-automatically-provide-memory-visibility).i will fix it.', 'commenter': 'dugenkui03'}, {'comment': '> i ignored that maxCapacity is volatile,\r\n\r\nYep, that is why I have questions with lock with this method.', 'commenter': 'carryxyh'}, {'comment': '> > i ignored that maxCapacity is volatile,\r\n> \r\n> Yep, that is why I have questions with lock with this method.\r\n\r\nThx for your help. Code has been updated.', 'commenter': 'dugenkui03'}]"
2627,dubbo-common/src/main/java/org/apache/dubbo/common/utils/LRUCache.java,"@@ -27,7 +27,11 @@
     private static final float DEFAULT_LOAD_FACTOR = 0.75f;
 
     private static final int DEFAULT_MAX_CAPACITY = 1000;
-    private final Lock lock = new ReentrantLock();
+
+    private final ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock(true);","[{'comment': 'Code style.\r\nUse RW_LOCK.', 'commenter': 'carryxyh'}, {'comment': ""> Code style.\r\n> Use RW_LOCK.\r\nnot `static final`,and i think `lock` can't be static.\r\n\r\n"", 'commenter': 'dugenkui03'}, {'comment': 'agree with that can not be static.\r\nbut use upper with final field is better.\r\nwhat do u think?', 'commenter': 'carryxyh'}, {'comment': '> agree with that can not be static.\r\n> but use upper with final field is better.\r\n> what do u think?\r\n\r\nThis is also OK.Code style referred to the jdk before.will fix it.keep dubbo style is better.', 'commenter': 'dugenkui03'}]"
2646,dubbo-demo/dubbo-demo-consumer/src/main/resources/META-INF/spring/dubbo-demo-consumer.xml,"@@ -30,6 +30,8 @@
 
     <!-- generate proxy for the remote service, then demoService can be used in the same way as the
     local regular interface -->
-    <dubbo:reference id=""demoService"" check=""false"" interface=""org.apache.dubbo.demo.DemoService""/>
+    <dubbo:reference id=""demoService"" check=""false"" interface=""org.apache.dubbo.demo.DemoService"">
+        <dubbo:method name=""findFoo"" async=""true"" />","[{'comment': 'What is this config doing?', 'commenter': 'carryxyh'}, {'comment': '> What is this config doing?\r\n\r\ntest the async config of dubbo. ', 'commenter': 'Jeff-Lv'}, {'comment': ""I konw. But this is not test module.\r\nThe demo only maintains the simplest example. If you need to test, please test it in your local, don't submit it to the demo."", 'commenter': 'carryxyh'}]"
2646,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java,"@@ -18,78 +18,50 @@
 
 import org.apache.dubbo.common.logger.Logger;
 import org.apache.dubbo.common.logger.LoggerFactory;","[{'comment': ""this change should be revert, it's for issue#2583"", 'commenter': 'beiwei30'}]"
2647,dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/loadbalance/LoadBalanceTest.java,"@@ -280,45 +429,4 @@ public void testLoadBalanceWarmup() {
                 .calculateWarmupWeight(20 * 60 * 1000, Constants.DEFAULT_WARMUP, Constants.DEFAULT_WEIGHT));
     }
 
-    /*------------------------------------test invokers for weight---------------------------------------*/
-
-    protected List<Invoker<LoadBalanceTest>> weightInvokers = new ArrayList<Invoker<LoadBalanceTest>>();","[{'comment': 'Why u move the code?', 'commenter': 'carryxyh'}, {'comment': ""> Why u move the code?\r\n\r\nIt's a setup logic, not a unit test, I move it to group the logic.\r\n\r\nActually I add weight to all test before someone add separate test for invokers with weight specified. Though i think tests with various weight are enough."", 'commenter': 'jasonjoo2010'}, {'comment': ""And surely it's not a problem on master branch because the logics are split into separated class."", 'commenter': 'jasonjoo2010'}, {'comment': ""Pls keep your pr clean and don't put too much in the same pr.\r\nI don't think this moving is necessary.\r\n:)"", 'commenter': 'carryxyh'}, {'comment': ""> Pls keep your pr clean and don't put too much in the same pr.\r\n> I don't think this moving is necessary.\r\n> :)\r\n\r\nok, I will revert it, but shall i restructure the other unit tests for other kinds of LoadBalance in same PR? Some of them will not fail if something wrong."", 'commenter': 'jasonjoo2010'}, {'comment': ""Hi, I don't think it is necessary.\r\nCi will fail if one of them is failed.\r\n:)"", 'commenter': 'carryxyh'}]"
2647,dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/loadbalance/LoadBalanceTest.java,"@@ -120,80 +245,120 @@ public void testRoundRobinLoadBalance_select() {
             Assert.assertTrue(""abs diff shoud < 1"", Math.abs(count - runs / (0f + invokers.size())) < 1f);
         }
     }
-
+    
+    private void assertStrictWRRResult(int runs, Map<Invoker, InvokeResult> resultMap) {
+        for (InvokeResult invokeResult : resultMap.values()) {
+            Assert.assertTrue(""delta with expected count should < 10%"", 
+                    invokeResult.getDeltaPercentage(runs) < 10);
+            // Because it's a strictly round robin, so the abs delta should be < 10 too
+            Assert.assertTrue(""delta with expected count should < 10"", 
+                    Math.abs(invokeResult.getExpected(runs) - invokeResult.getCount().get()) < 10);
+        }
+    }
+    
+    private void assertResult(int runs, Map<Invoker, InvokeResult> resultMap) {
+        for (InvokeResult invokeResult : resultMap.values()) {
+            Assert.assertTrue(""delta with expected count should < 12%"", 
+                    invokeResult.getDeltaPercentage(runs) < 12);
+        }
+    }
+    
     @Test
-    public void testSelectByWeightLeastActive() {
-        int sumInvoker1 = 0;
-        int sumInvoker2 = 0;
-        int loop = 10000;
-        LeastActiveLoadBalance lb = new LeastActiveLoadBalance();
-        for (int i = 0; i < loop; i++) {
-            Invoker selected = lb.select(weightInvokers, null, weightTestInvocation);
-            if (selected.getUrl().getProtocol().equals(""test1"")) {
-                sumInvoker1++;
-            }
-            if (selected.getUrl().getProtocol().equals(""test2"")) {
-                sumInvoker2++;
+    public void testRoundRobinLoadBalance_weighted_select() {
+        int runs = 10000;
+        Map<Invoker, InvokeResult> resultMap = getWeightedInvokeResult(runs, RoundRobinLoadBalance.NAME);
+        assertStrictWRRResult(runs, resultMap);
+    }
+    
+    @Test
+    public void testRoundRobinLoadBalance_shouldNotRecycle() {
+        int runs = 10000;
+        //tmperately add a new invoker
+        weightInvokers.add(weightInvokerTmp);
+        try {
+            Map<Invoker, InvokeResult> resultMap = getWeightedInvokeResult(runs, RoundRobinLoadBalance.NAME);
+            assertStrictWRRResult(runs, resultMap);
+            RoundRobinLoadBalance lb = (RoundRobinLoadBalance)getLoadBalance(RoundRobinLoadBalance.NAME);
+            Assert.assertEquals(weightInvokers.size(), lb.getInvokerAddrList(weightInvokers, weightTestInvocation).size());
+            
+            //remove the last invoker and retry
+            weightInvokers.remove(weightInvokerTmp);
+            resultMap = getWeightedInvokeResult(runs, RoundRobinLoadBalance.NAME);
+            assertStrictWRRResult(runs, resultMap);
+            Assert.assertNotEquals(weightInvokers.size(), lb.getInvokerAddrList(weightInvokers, weightTestInvocation).size());
+        } finally {
+            weightInvokers.remove(weightInvokerTmp);
+        }
+    }
+    
+    @Test
+    public void testRoundRobinLoadBalance_shouldRecycle() {
+        {
+            Field recycleTimeField = null;","[{'comment': 'bad code style', 'commenter': 'carryxyh'}, {'comment': 'Yes, ur right, I will change it', 'commenter': 'jasonjoo2010'}]"
2647,dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java,"@@ -32,72 +34,131 @@
  *
  */
 public class RoundRobinLoadBalance extends AbstractLoadBalance {
-
     public static final String NAME = ""roundrobin"";
+    
+    private static int RECYCLE_PERIOD = 60000;
+    
+    protected static class WeightedRoundRobin {
+        private int weight;
+        private int current;
+        private long lastRecycle;
+        private long lastUpdate;
+        public int getWeight() {
+            return weight;
+        }
+        public void setWeight(int weight) {
+            this.weight = weight;
+        }
+        public void setCurrent(int current) {
+            this.current = current;
+        }
+        public int increaseWeight() {
+            current += weight;
+            return current;
+        }
+        public void sel(int total) {
+            current -= total;
+        }
+        public long getLastRecycle() {
+            return lastRecycle;
+        }
+        public void setLastRecycle(long lastRecycle) {
+            this.lastRecycle = lastRecycle;
+        }
+        public long getLastUpdate() {
+            return lastUpdate;
+        }
+        public void setLastUpdate(long lastUpdate) {
+            this.lastUpdate = lastUpdate;
+        }
+    }
 
-    private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();
-
+    private ConcurrentMap<String, Map<String, WeightedRoundRobin>> methodWeightMap = new ConcurrentHashMap<String, Map<String, WeightedRoundRobin>>();
+    
+    /**
+     * get invoker addr list cached for specified invocation
+     * <p>
+     * <b>for unit test only</b>
+     * 
+     * @param invokers
+     * @param invocation
+     * @return
+     */
+    protected <T> Collection<String> getInvokerAddrList(List<Invoker<T>> invokers, Invocation invocation) {
+        String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map != null) {
+            return map.keySet();
+        }
+        return null;
+    }
+    
     @Override
     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
         String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
-        int length = invokers.size(); // Number of invokers
-        int maxWeight = 0; // The maximum weight
-        int minWeight = Integer.MAX_VALUE; // The minimum weight
-        final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();
-        int weightSum = 0;
-        for (int i = 0; i < length; i++) {
-            int weight = getWeight(invokers.get(i), invocation);
-            maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight
-            minWeight = Math.min(minWeight, weight); // Choose the minimum weight
-            if (weight > 0) {
-                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));
-                weightSum += weight;
-            }
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map == null) {
+            methodWeightMap.putIfAbsent(key, new HashMap<String, WeightedRoundRobin>());
+            map = methodWeightMap.get(key);
         }
-        AtomicPositiveInteger sequence = sequences.get(key);
-        if (sequence == null) {
-            sequences.putIfAbsent(key, new AtomicPositiveInteger());
-            sequence = sequences.get(key);
-        }
-        int currentSequence = sequence.getAndIncrement();
-        if (maxWeight > 0 && minWeight < maxWeight) {
-            int mod = currentSequence % weightSum;
-            for (int i = 0; i < maxWeight; i++) {
-                for (Map.Entry<Invoker<T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) {
-                    final Invoker<T> k = each.getKey();
-                    final IntegerWrapper v = each.getValue();
-                    if (mod == 0 && v.getValue() > 0) {
-                        return k;
-                    }
-                    if (v.getValue() > 0) {
-                        v.decrement();
-                        mod--;
+        synchronized (map) {
+            int totalWeight = 0;
+            int maxCurrent = Integer.MIN_VALUE;
+            long now = System.currentTimeMillis();
+            boolean needRecycle = false;","[{'comment': 'How does the `needRecycle ` work?', 'commenter': 'carryxyh'}, {'comment': 'Because nodes in list may change(after some nodes offline), some entries in WRR cache map will be skipped.\r\n\r\nBut if some nodes are offline permanent these entries are kinds of waste of memory.\r\nLike `Cache` in guava the recycle will happen every `RECYCLE_TIME` and scan the map removing the entries which `lastupdate > RECYCLE_TIME`. `lastupdate` will be updated every time invoked.', 'commenter': 'jasonjoo2010'}]"
2647,dubbo-cluster/src/test/java/com/alibaba/dubbo/rpc/cluster/loadbalance/LoadBalanceTest.java,"@@ -120,80 +245,120 @@ public void testRoundRobinLoadBalance_select() {
             Assert.assertTrue(""abs diff shoud < 1"", Math.abs(count - runs / (0f + invokers.size())) < 1f);
         }
     }
-
+    
+    private void assertStrictWRRResult(int runs, Map<Invoker, InvokeResult> resultMap) {
+        for (InvokeResult invokeResult : resultMap.values()) {
+            Assert.assertTrue(""delta with expected count should < 10%"", 
+                    invokeResult.getDeltaPercentage(runs) < 10);
+            // Because it's a strictly round robin, so the abs delta should be < 10 too
+            Assert.assertTrue(""delta with expected count should < 10"", 
+                    Math.abs(invokeResult.getExpected(runs) - invokeResult.getCount().get()) < 10);
+        }
+    }
+    
+    private void assertResult(int runs, Map<Invoker, InvokeResult> resultMap) {
+        for (InvokeResult invokeResult : resultMap.values()) {
+            Assert.assertTrue(""delta with expected count should < 12%"", 
+                    invokeResult.getDeltaPercentage(runs) < 12);
+        }
+    }
+    
     @Test
-    public void testSelectByWeightLeastActive() {
-        int sumInvoker1 = 0;
-        int sumInvoker2 = 0;
-        int loop = 10000;
-        LeastActiveLoadBalance lb = new LeastActiveLoadBalance();
-        for (int i = 0; i < loop; i++) {
-            Invoker selected = lb.select(weightInvokers, null, weightTestInvocation);
-            if (selected.getUrl().getProtocol().equals(""test1"")) {
-                sumInvoker1++;
-            }
-            if (selected.getUrl().getProtocol().equals(""test2"")) {
-                sumInvoker2++;
+    public void testRoundRobinLoadBalance_weighted_select() {
+        int runs = 10000;
+        Map<Invoker, InvokeResult> resultMap = getWeightedInvokeResult(runs, RoundRobinLoadBalance.NAME);
+        assertStrictWRRResult(runs, resultMap);
+    }
+    
+    @Test
+    public void testRoundRobinLoadBalance_shouldNotRecycle() {
+        int runs = 10000;
+        //tmperately add a new invoker
+        weightInvokers.add(weightInvokerTmp);
+        try {
+            Map<Invoker, InvokeResult> resultMap = getWeightedInvokeResult(runs, RoundRobinLoadBalance.NAME);
+            assertStrictWRRResult(runs, resultMap);
+            RoundRobinLoadBalance lb = (RoundRobinLoadBalance)getLoadBalance(RoundRobinLoadBalance.NAME);
+            Assert.assertEquals(weightInvokers.size(), lb.getInvokerAddrList(weightInvokers, weightTestInvocation).size());
+            
+            //remove the last invoker and retry
+            weightInvokers.remove(weightInvokerTmp);
+            resultMap = getWeightedInvokeResult(runs, RoundRobinLoadBalance.NAME);
+            assertStrictWRRResult(runs, resultMap);
+            Assert.assertNotEquals(weightInvokers.size(), lb.getInvokerAddrList(weightInvokers, weightTestInvocation).size());
+        } finally {
+            weightInvokers.remove(weightInvokerTmp);
+        }
+    }
+    
+    @Test
+    public void testRoundRobinLoadBalance_shouldRecycle() {
+        {
+            Field recycleTimeField = null;
+            try {
+                //change recycle time to 1 ms
+                recycleTimeField = RoundRobinLoadBalance.class.getDeclaredField(""RECYCLE_PERIOD"");
+                recycleTimeField.setAccessible(true);
+                recycleTimeField.setInt(RoundRobinLoadBalance.class, 10);
+            } catch (NoSuchFieldException e) {
+                Assert.assertTrue(""getField failed"", true);
+            } catch (SecurityException e) {
+                Assert.assertTrue(""getField failed"", true);
+            } catch (IllegalArgumentException e) {
+                Assert.assertTrue(""getField failed"", true);
+            } catch (IllegalAccessException e) {
+                Assert.assertTrue(""getField failed"", true);
             }
-            // never select invoker3 because it's active is more than invoker1 and invoker2
-            Assert.assertTrue(""select is not the least active one"", !selected.getUrl().getProtocol().equals(""test3""));
         }
-        // the sumInvoker1 : sumInvoker2 approximately equal to 1: 9
-        System.out.println(sumInvoker1);
-        System.out.println(sumInvoker2);
-        Assert.assertEquals(""select failed!"", sumInvoker1 + sumInvoker2, loop);
+        int runs = 10000;
+        //temporarily add a new invoker
+        weightInvokers.add(weightInvokerTmp);
+        try {
+            Map<Invoker, InvokeResult> resultMap = getWeightedInvokeResult(runs, RoundRobinLoadBalance.NAME);
+            assertStrictWRRResult(runs, resultMap);
+            RoundRobinLoadBalance lb = (RoundRobinLoadBalance)getLoadBalance(RoundRobinLoadBalance.NAME);
+            Assert.assertEquals(weightInvokers.size(), lb.getInvokerAddrList(weightInvokers, weightTestInvocation).size());
+            
+            //remove the tmp invoker and retry, should recycle its cache
+            weightInvokers.remove(weightInvokerTmp);
+            resultMap = getWeightedInvokeResult(runs, RoundRobinLoadBalance.NAME);
+            assertStrictWRRResult(runs, resultMap);
+            Assert.assertEquals(weightInvokers.size(), lb.getInvokerAddrList(weightInvokers, weightTestInvocation).size());
+        } finally {
+            weightInvokers.remove(weightInvokerTmp);
+        }
     }
 
     @Test
-    public void testSelectByWeightRandom() {
-        int sumInvoker1 = 0;
-        int sumInvoker2 = 0;
-        int sumInvoker3 = 0;
+    public void testSelectByWeightLeastActive() {
         int loop = 10000;
-        RandomLoadBalance lb = new RandomLoadBalance();
-        for (int i = 0; i < loop; i++) {
-            Invoker selected = lb.select(weightInvokers, null, weightTestInvocation);
-            if (selected.getUrl().getProtocol().equals(""test1"")) {
-                sumInvoker1++;
+        Map<Invoker, InvokeResult> resultMap = getWeightedInvokeResult(loop, LeastActiveLoadBalance.NAME);
+        int test3Weight = 0;
+        //find test3's weight
+        for (Entry<Invoker, InvokeResult> entry : resultMap.entrySet()) {
+            String protocol = entry.getKey().getUrl().getProtocol();
+            if (protocol.equals(""test3"")) {
+                //should no request invoked to test3
+                Assert.assertEquals(0, entry.getValue().getCount().get());
+                test3Weight = entry.getValue().getWeight();
             }
-            if (selected.getUrl().getProtocol().equals(""test2"")) {
-                sumInvoker2++;
-            }
-            if (selected.getUrl().getProtocol().equals(""test3"")) {
-                sumInvoker3++;
+        }
+        for (Entry<Invoker, InvokeResult> entry : resultMap.entrySet()) {
+            String protocol = entry.getKey().getUrl().getProtocol();
+            if (!protocol.equals(""test3"")) {
+                InvokeResult invokeResult = entry.getValue();
+                invokeResult.setTotalWeight(invokeResult.getTotalWeight() - test3Weight);
+                // less then 12% requests to expected
+                Assert.assertTrue(invokeResult.getDeltaPercentage(loop) < 12);","[{'comment': ""I don't think this is a good way to calc percentage of select.\r\nIt is not stable."", 'commenter': 'carryxyh'}, {'comment': ""> I don't think this is a good way to calc percentage of select.\r\n> It is not stable.\r\n\r\nThe Unit Test before only covers the invokers without weight specified. So if we add weight to them the actually result will be indetermination in `Random` etc. . So i tried to use percentage to make it.\r\n\r\nSo is there other way to do that? The old logics just print the result."", 'commenter': 'jasonjoo2010'}, {'comment': 'There is no better way yet. But using percentages is not a good way, because it is not stable, which causes us to spend a lot of time re-executing the entire ci.', 'commenter': 'carryxyh'}, {'comment': '> There is no better way yet. But using percentages is not a good way, because it is not stable, which causes us to spend a lot of time re-executing the entire ci.\r\n\r\nI gave a big threshold for those tests and actually there must be a problem if they fail under this condition.\r\n\r\nIs it better then no assertion at all?\r\n\r\nAnd Maybe we will optimize them in future to get a better threshold(eg. better Random).', 'commenter': 'jasonjoo2010'}, {'comment': ""If the threshold is too large, we still can't find it if there is a problem. So how do we determine a suitable threshold?\r\nI think this is difficult. And even if we find this threshold, ut can't be stable, so I don't think we should handle this.\r\n\r\nHow do u think about it?"", 'commenter': 'carryxyh'}, {'comment': ""> If the threshold is too large, we still can't find it if there is a problem. So how do we determine a suitable threshold?\r\n> I think this is difficult. And even if we find this threshold, ut can't be stable, so I don't think we should handle this.\r\n> \r\n> How do u think about it?\r\n\r\nCurrently the threshold is 12% diff to expected requests should dispatch. Maybe there's some problem in Random for example, it will between 0~8% (I think the result should be stable when we simulate 10k request).\r\n\r\n12% under weight is acceptable to me(more like a complete unit test and reliable after hundreds loop), but your opinion is reasonable too.\r\n\r\nSo i won't consist on it and we can make a decision whether to leave them as they were.\r\n\r\nbtw the CI failed and i am checking the problem(seems not because this unit test)."", 'commenter': 'jasonjoo2010'}]"
2647,dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java,"@@ -32,72 +34,131 @@
  *
  */
 public class RoundRobinLoadBalance extends AbstractLoadBalance {
-
     public static final String NAME = ""roundrobin"";
+    
+    private static int RECYCLE_PERIOD = 60000;
+    
+    protected static class WeightedRoundRobin {
+        private int weight;
+        private int current;
+        private long lastRecycle;
+        private long lastUpdate;
+        public int getWeight() {
+            return weight;
+        }
+        public void setWeight(int weight) {
+            this.weight = weight;
+        }
+        public void setCurrent(int current) {
+            this.current = current;
+        }
+        public int increaseWeight() {
+            current += weight;
+            return current;
+        }
+        public void sel(int total) {
+            current -= total;
+        }
+        public long getLastRecycle() {
+            return lastRecycle;
+        }
+        public void setLastRecycle(long lastRecycle) {
+            this.lastRecycle = lastRecycle;
+        }
+        public long getLastUpdate() {
+            return lastUpdate;
+        }
+        public void setLastUpdate(long lastUpdate) {
+            this.lastUpdate = lastUpdate;
+        }
+    }
 
-    private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();
-
+    private ConcurrentMap<String, Map<String, WeightedRoundRobin>> methodWeightMap = new ConcurrentHashMap<String, Map<String, WeightedRoundRobin>>();
+    
+    /**
+     * get invoker addr list cached for specified invocation
+     * <p>
+     * <b>for unit test only</b>
+     * 
+     * @param invokers
+     * @param invocation
+     * @return
+     */
+    protected <T> Collection<String> getInvokerAddrList(List<Invoker<T>> invokers, Invocation invocation) {
+        String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map != null) {
+            return map.keySet();
+        }
+        return null;
+    }
+    
     @Override
     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
         String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
-        int length = invokers.size(); // Number of invokers
-        int maxWeight = 0; // The maximum weight
-        int minWeight = Integer.MAX_VALUE; // The minimum weight
-        final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();
-        int weightSum = 0;
-        for (int i = 0; i < length; i++) {
-            int weight = getWeight(invokers.get(i), invocation);
-            maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight
-            minWeight = Math.min(minWeight, weight); // Choose the minimum weight
-            if (weight > 0) {
-                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));
-                weightSum += weight;
-            }
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map == null) {
+            methodWeightMap.putIfAbsent(key, new HashMap<String, WeightedRoundRobin>());
+            map = methodWeightMap.get(key);
         }
-        AtomicPositiveInteger sequence = sequences.get(key);
-        if (sequence == null) {
-            sequences.putIfAbsent(key, new AtomicPositiveInteger());
-            sequence = sequences.get(key);
-        }
-        int currentSequence = sequence.getAndIncrement();
-        if (maxWeight > 0 && minWeight < maxWeight) {
-            int mod = currentSequence % weightSum;
-            for (int i = 0; i < maxWeight; i++) {
-                for (Map.Entry<Invoker<T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) {
-                    final Invoker<T> k = each.getKey();
-                    final IntegerWrapper v = each.getValue();
-                    if (mod == 0 && v.getValue() > 0) {
-                        return k;
-                    }
-                    if (v.getValue() > 0) {
-                        v.decrement();
-                        mod--;
+        synchronized (map) {","[{'comment': 'big lock???', 'commenter': 'kimmking'}]"
2647,dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java,"@@ -32,72 +34,131 @@
  *
  */
 public class RoundRobinLoadBalance extends AbstractLoadBalance {
-
     public static final String NAME = ""roundrobin"";
+    
+    private static int RECYCLE_PERIOD = 60000;
+    
+    protected static class WeightedRoundRobin {
+        private int weight;
+        private int current;
+        private long lastRecycle;
+        private long lastUpdate;
+        public int getWeight() {
+            return weight;
+        }
+        public void setWeight(int weight) {
+            this.weight = weight;
+        }
+        public void setCurrent(int current) {
+            this.current = current;
+        }
+        public int increaseWeight() {
+            current += weight;
+            return current;
+        }
+        public void sel(int total) {
+            current -= total;
+        }
+        public long getLastRecycle() {
+            return lastRecycle;
+        }
+        public void setLastRecycle(long lastRecycle) {
+            this.lastRecycle = lastRecycle;
+        }
+        public long getLastUpdate() {
+            return lastUpdate;
+        }
+        public void setLastUpdate(long lastUpdate) {
+            this.lastUpdate = lastUpdate;
+        }
+    }
 
-    private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();
-
+    private ConcurrentMap<String, Map<String, WeightedRoundRobin>> methodWeightMap = new ConcurrentHashMap<String, Map<String, WeightedRoundRobin>>();
+    
+    /**
+     * get invoker addr list cached for specified invocation
+     * <p>
+     * <b>for unit test only</b>
+     * 
+     * @param invokers
+     * @param invocation
+     * @return
+     */
+    protected <T> Collection<String> getInvokerAddrList(List<Invoker<T>> invokers, Invocation invocation) {
+        String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map != null) {
+            return map.keySet();
+        }
+        return null;
+    }
+    
     @Override
     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
         String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
-        int length = invokers.size(); // Number of invokers
-        int maxWeight = 0; // The maximum weight
-        int minWeight = Integer.MAX_VALUE; // The minimum weight
-        final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();
-        int weightSum = 0;
-        for (int i = 0; i < length; i++) {
-            int weight = getWeight(invokers.get(i), invocation);
-            maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight
-            minWeight = Math.min(minWeight, weight); // Choose the minimum weight
-            if (weight > 0) {
-                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));
-                weightSum += weight;
-            }
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map == null) {
+            methodWeightMap.putIfAbsent(key, new HashMap<String, WeightedRoundRobin>());
+            map = methodWeightMap.get(key);
         }
-        AtomicPositiveInteger sequence = sequences.get(key);
-        if (sequence == null) {
-            sequences.putIfAbsent(key, new AtomicPositiveInteger());
-            sequence = sequences.get(key);
-        }
-        int currentSequence = sequence.getAndIncrement();
-        if (maxWeight > 0 && minWeight < maxWeight) {
-            int mod = currentSequence % weightSum;
-            for (int i = 0; i < maxWeight; i++) {
-                for (Map.Entry<Invoker<T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) {
-                    final Invoker<T> k = each.getKey();
-                    final IntegerWrapper v = each.getValue();
-                    if (mod == 0 && v.getValue() > 0) {
-                        return k;
-                    }
-                    if (v.getValue() > 0) {
-                        v.decrement();
-                        mod--;
+        synchronized (map) {
+            int totalWeight = 0;
+            int maxCurrent = Integer.MIN_VALUE;
+            long now = System.currentTimeMillis();
+            boolean needRecycle = false;
+            Invoker<T> selectedInvoker = null;
+            WeightedRoundRobin selectedWRR = null;
+            for (Invoker<T> invoker : invokers) {
+                String identifyString = invoker.getUrl().toIdentityString();
+                WeightedRoundRobin weightedRoundRobin = map.get(identifyString);
+                int weight = getWeight(invoker, invocation);
+                if (weight < 0) {
+                    weight = 0;
+                }
+                if (weightedRoundRobin == null) {
+                    weightedRoundRobin = new WeightedRoundRobin();
+                    weightedRoundRobin.setCurrent(0);
+                    weightedRoundRobin.setWeight(weight);
+                    weightedRoundRobin.setLastRecycle(now);
+                    map.put(identifyString, weightedRoundRobin);
+                }
+                if (weight != weightedRoundRobin.getWeight()) {
+                    //weight changed
+                    weightedRoundRobin.setCurrent(0);
+                    weightedRoundRobin.setWeight(weight);
+                }
+                int cur = weightedRoundRobin.increaseWeight();
+                weightedRoundRobin.setLastUpdate(now);
+                if (!needRecycle && now - weightedRoundRobin.getLastRecycle() > RECYCLE_PERIOD) {
+                    //try to recycle useless item every 60s if there is one outdated
+                    needRecycle = true;
+                }
+                if (cur > maxCurrent) {
+                    maxCurrent = cur;
+                    selectedInvoker = invoker;
+                    selectedWRR = weightedRoundRobin;
+                }
+                totalWeight += weight;
+            }
+            //recycle
+            if (needRecycle) {","[{'comment': 'I suggestion use a out thread to check, not in this thread.', 'commenter': 'kimmking'}, {'comment': 'Or ignore, cause not so much keys', 'commenter': 'kimmking'}, {'comment': ""> I suggestion use a out thread to check, not in this thread.\r\n\r\nhi,\r\n\r\nSo there are two things should be pointed out:\r\n\r\n1. check in a separated thread.\r\nThis method take one more thread in dubbo framework and should also add a lock here(or create another map when really recycle happen? It's lock free then.).\r\n\r\n2. just ignore it\r\nIt's good in most cases but will cause increasing memory when the providers are frequently changed. So this balancer will not be operate free.\r\n\r\nAnd the lock is distributed between methods level and only used for some frequently called methods. \r\n\r\nSynchronized lock is an auto-upgrade lock from light weight lock in object header (when no concurrent) to monitor lock. So if the code block can be executed fast enough we may get a light weight lock mostly.\r\n\r\n@kimmking So what do you think about? Lock or lock-free, or a separate thread to do that?"", 'commenter': 'jasonjoo2010'}, {'comment': 'Amazing implementation. \r\n\r\nBut we should avoid `synchronized` as much as possible, besides this synchronization block is too large to effect performance:\r\n\r\n> Synchronized lock is an auto-upgrade lock from light weight lock in object header (when no concurrent) to monitor lock. So if the code block can be executed fast enough we may get a light weight lock mostly.\r\n\r\nThis is not true in this scenario, since it is very possible that multiple threads execute `doSelect` at the same moment.\r\n\r\nI am fine with other parts, but this synchronization block is my major concern.', 'commenter': 'beiwei30'}]"
2647,dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java,"@@ -17,87 +17,140 @@
 package com.alibaba.dubbo.rpc.cluster.loadbalance;
 
 import com.alibaba.dubbo.common.URL;
-import com.alibaba.dubbo.common.utils.AtomicPositiveInteger;
 import com.alibaba.dubbo.rpc.Invocation;
 import com.alibaba.dubbo.rpc.Invoker;
 
-import java.util.LinkedHashMap;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * Round robin load balance.
+ * 
+ * Smoothly round robin's implementation @since 2.6.5 
+ * @author jason
  *
  */
 public class RoundRobinLoadBalance extends AbstractLoadBalance {
-
     public static final String NAME = ""roundrobin"";
+    
+    private static int RECYCLE_PERIOD = 60000;
+    
+    protected static class WeightedRoundRobin {
+        private int weight;
+        private AtomicLong current = new AtomicLong(0);
+        private long lastUpdate;
+        public int getWeight() {
+            return weight;
+        }
+        public void setWeight(int weight) {
+            this.weight = weight;
+            current.set(0);
+        }
+        public long increaseCurrent() {
+            return current.addAndGet(weight);
+        }
+        public void sel(int total) {
+            current.addAndGet(-1 * total);
+        }
+        public long getLastUpdate() {
+            return lastUpdate;
+        }
+        public void setLastUpdate(long lastUpdate) {
+            this.lastUpdate = lastUpdate;
+        }
+    }
 
-    private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();
-
+    private ConcurrentMap<String, Map<String, WeightedRoundRobin>> methodWeightMap = new ConcurrentHashMap<String, Map<String, WeightedRoundRobin>>();
+    private AtomicBoolean updateLock = new AtomicBoolean();
+    
+    /**
+     * get invoker addr list cached for specified invocation
+     * <p>
+     * <b>for unit test only</b>
+     * 
+     * @param invokers
+     * @param invocation
+     * @return
+     */
+    protected <T> Collection<String> getInvokerAddrList(List<Invoker<T>> invokers, Invocation invocation) {
+        String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map != null) {
+            return map.keySet();
+        }
+        return null;
+    }
+    
     @Override
     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
         String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
-        int length = invokers.size(); // Number of invokers
-        int maxWeight = 0; // The maximum weight
-        int minWeight = Integer.MAX_VALUE; // The minimum weight
-        final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();
-        int weightSum = 0;
-        for (int i = 0; i < length; i++) {
-            int weight = getWeight(invokers.get(i), invocation);
-            maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight
-            minWeight = Math.min(minWeight, weight); // Choose the minimum weight
-            if (weight > 0) {
-                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));
-                weightSum += weight;
-            }
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map == null) {
+            methodWeightMap.putIfAbsent(key, new HashMap<String, WeightedRoundRobin>());","[{'comment': 'We should make this map ConcurrentMap too. It is possible that two threads manipulate the same map and even the same key.', 'commenter': 'beiwei30'}, {'comment': 'yeah you are right, i forgot to change it when i remove the synchronized', 'commenter': 'jasonjoo2010'}]"
2647,dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java,"@@ -17,87 +17,140 @@
 package com.alibaba.dubbo.rpc.cluster.loadbalance;
 
 import com.alibaba.dubbo.common.URL;
-import com.alibaba.dubbo.common.utils.AtomicPositiveInteger;
 import com.alibaba.dubbo.rpc.Invocation;
 import com.alibaba.dubbo.rpc.Invoker;
 
-import java.util.LinkedHashMap;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * Round robin load balance.
+ * 
+ * Smoothly round robin's implementation @since 2.6.5 
+ * @author jason
  *
  */
 public class RoundRobinLoadBalance extends AbstractLoadBalance {
-
     public static final String NAME = ""roundrobin"";
+    
+    private static int RECYCLE_PERIOD = 60000;
+    
+    protected static class WeightedRoundRobin {
+        private int weight;
+        private AtomicLong current = new AtomicLong(0);
+        private long lastUpdate;
+        public int getWeight() {
+            return weight;
+        }
+        public void setWeight(int weight) {
+            this.weight = weight;
+            current.set(0);
+        }
+        public long increaseCurrent() {
+            return current.addAndGet(weight);
+        }
+        public void sel(int total) {
+            current.addAndGet(-1 * total);
+        }
+        public long getLastUpdate() {
+            return lastUpdate;
+        }
+        public void setLastUpdate(long lastUpdate) {
+            this.lastUpdate = lastUpdate;
+        }
+    }
 
-    private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();
-
+    private ConcurrentMap<String, Map<String, WeightedRoundRobin>> methodWeightMap = new ConcurrentHashMap<String, Map<String, WeightedRoundRobin>>();
+    private AtomicBoolean updateLock = new AtomicBoolean();
+    
+    /**
+     * get invoker addr list cached for specified invocation
+     * <p>
+     * <b>for unit test only</b>
+     * 
+     * @param invokers
+     * @param invocation
+     * @return
+     */
+    protected <T> Collection<String> getInvokerAddrList(List<Invoker<T>> invokers, Invocation invocation) {
+        String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map != null) {
+            return map.keySet();
+        }
+        return null;
+    }
+    
     @Override
     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
         String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
-        int length = invokers.size(); // Number of invokers
-        int maxWeight = 0; // The maximum weight
-        int minWeight = Integer.MAX_VALUE; // The minimum weight
-        final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();
-        int weightSum = 0;
-        for (int i = 0; i < length; i++) {
-            int weight = getWeight(invokers.get(i), invocation);
-            maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight
-            minWeight = Math.min(minWeight, weight); // Choose the minimum weight
-            if (weight > 0) {
-                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));
-                weightSum += weight;
-            }
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map == null) {
+            methodWeightMap.putIfAbsent(key, new HashMap<String, WeightedRoundRobin>());
+            map = methodWeightMap.get(key);
         }
-        AtomicPositiveInteger sequence = sequences.get(key);
-        if (sequence == null) {
-            sequences.putIfAbsent(key, new AtomicPositiveInteger());
-            sequence = sequences.get(key);
+        int totalWeight = 0;
+        long maxCurrent = Long.MIN_VALUE;
+        long now = System.currentTimeMillis();
+        Invoker<T> selectedInvoker = null;
+        WeightedRoundRobin selectedWRR = null;
+        for (Invoker<T> invoker : invokers) {
+            String identifyString = invoker.getUrl().toIdentityString();
+            WeightedRoundRobin weightedRoundRobin = map.get(identifyString);
+            int weight = getWeight(invoker, invocation);
+            if (weight < 0) {
+                weight = 0;
+            }
+            if (weightedRoundRobin == null) {
+                weightedRoundRobin = new WeightedRoundRobin();
+                weightedRoundRobin.setWeight(weight);
+                map.put(identifyString, weightedRoundRobin);","[{'comment': 'for example: two thread may manipulate map here.', 'commenter': 'beiwei30'}]"
2647,dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java,"@@ -17,87 +17,140 @@
 package com.alibaba.dubbo.rpc.cluster.loadbalance;
 
 import com.alibaba.dubbo.common.URL;
-import com.alibaba.dubbo.common.utils.AtomicPositiveInteger;
 import com.alibaba.dubbo.rpc.Invocation;
 import com.alibaba.dubbo.rpc.Invoker;
 
-import java.util.LinkedHashMap;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * Round robin load balance.
+ * 
+ * Smoothly round robin's implementation @since 2.6.5 
+ * @author jason
  *
  */
 public class RoundRobinLoadBalance extends AbstractLoadBalance {
-
     public static final String NAME = ""roundrobin"";
+    
+    private static int RECYCLE_PERIOD = 60000;
+    
+    protected static class WeightedRoundRobin {
+        private int weight;
+        private AtomicLong current = new AtomicLong(0);
+        private long lastUpdate;
+        public int getWeight() {
+            return weight;
+        }
+        public void setWeight(int weight) {
+            this.weight = weight;
+            current.set(0);
+        }
+        public long increaseCurrent() {
+            return current.addAndGet(weight);
+        }
+        public void sel(int total) {
+            current.addAndGet(-1 * total);
+        }
+        public long getLastUpdate() {
+            return lastUpdate;
+        }
+        public void setLastUpdate(long lastUpdate) {
+            this.lastUpdate = lastUpdate;
+        }
+    }
 
-    private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();
-
+    private ConcurrentMap<String, Map<String, WeightedRoundRobin>> methodWeightMap = new ConcurrentHashMap<String, Map<String, WeightedRoundRobin>>();
+    private AtomicBoolean updateLock = new AtomicBoolean();
+    
+    /**
+     * get invoker addr list cached for specified invocation
+     * <p>
+     * <b>for unit test only</b>
+     * 
+     * @param invokers
+     * @param invocation
+     * @return
+     */
+    protected <T> Collection<String> getInvokerAddrList(List<Invoker<T>> invokers, Invocation invocation) {
+        String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map != null) {
+            return map.keySet();
+        }
+        return null;
+    }
+    
     @Override
     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
         String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
-        int length = invokers.size(); // Number of invokers
-        int maxWeight = 0; // The maximum weight
-        int minWeight = Integer.MAX_VALUE; // The minimum weight
-        final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();
-        int weightSum = 0;
-        for (int i = 0; i < length; i++) {
-            int weight = getWeight(invokers.get(i), invocation);
-            maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight
-            minWeight = Math.min(minWeight, weight); // Choose the minimum weight
-            if (weight > 0) {
-                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));
-                weightSum += weight;
-            }
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map == null) {
+            methodWeightMap.putIfAbsent(key, new HashMap<String, WeightedRoundRobin>());
+            map = methodWeightMap.get(key);
         }
-        AtomicPositiveInteger sequence = sequences.get(key);
-        if (sequence == null) {
-            sequences.putIfAbsent(key, new AtomicPositiveInteger());
-            sequence = sequences.get(key);
+        int totalWeight = 0;
+        long maxCurrent = Long.MIN_VALUE;
+        long now = System.currentTimeMillis();
+        Invoker<T> selectedInvoker = null;
+        WeightedRoundRobin selectedWRR = null;
+        for (Invoker<T> invoker : invokers) {
+            String identifyString = invoker.getUrl().toIdentityString();
+            WeightedRoundRobin weightedRoundRobin = map.get(identifyString);
+            int weight = getWeight(invoker, invocation);
+            if (weight < 0) {
+                weight = 0;
+            }
+            if (weightedRoundRobin == null) {
+                weightedRoundRobin = new WeightedRoundRobin();
+                weightedRoundRobin.setWeight(weight);
+                map.put(identifyString, weightedRoundRobin);
+            }
+            if (weight != weightedRoundRobin.getWeight()) {
+                //weight changed
+                weightedRoundRobin.setWeight(weight);
+            }
+            long cur = weightedRoundRobin.increaseCurrent();
+            weightedRoundRobin.setLastUpdate(now);
+            if (cur > maxCurrent) {
+                maxCurrent = cur;
+                selectedInvoker = invoker;
+                selectedWRR = weightedRoundRobin;
+            }
+            totalWeight += weight;
         }
-        int currentSequence = sequence.getAndIncrement();
-        if (maxWeight > 0 && minWeight < maxWeight) {
-            int mod = currentSequence % weightSum;
-            for (int i = 0; i < maxWeight; i++) {
-                for (Map.Entry<Invoker<T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) {
-                    final Invoker<T> k = each.getKey();
-                    final IntegerWrapper v = each.getValue();
-                    if (mod == 0 && v.getValue() > 0) {
-                        return k;
-                    }
-                    if (v.getValue() > 0) {
-                        v.decrement();
-                        mod--;
+        if (updateLock.get() == false && invokers.size() != map.size()) {","[{'comment': '`updateLock.get() == false` is unnecessary.', 'commenter': 'beiwei30'}, {'comment': ""It's written for easily understood especially when i restructured it with optimistic lock.\r\nSurely i don't insist on it."", 'commenter': 'jasonjoo2010'}]"
2647,dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java,"@@ -17,87 +17,140 @@
 package com.alibaba.dubbo.rpc.cluster.loadbalance;
 
 import com.alibaba.dubbo.common.URL;
-import com.alibaba.dubbo.common.utils.AtomicPositiveInteger;
 import com.alibaba.dubbo.rpc.Invocation;
 import com.alibaba.dubbo.rpc.Invoker;
 
-import java.util.LinkedHashMap;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * Round robin load balance.
+ * 
+ * Smoothly round robin's implementation @since 2.6.5 
+ * @author jason
  *
  */
 public class RoundRobinLoadBalance extends AbstractLoadBalance {
-
     public static final String NAME = ""roundrobin"";
+    
+    private static int RECYCLE_PERIOD = 60000;
+    
+    protected static class WeightedRoundRobin {
+        private int weight;
+        private AtomicLong current = new AtomicLong(0);
+        private long lastUpdate;
+        public int getWeight() {
+            return weight;
+        }
+        public void setWeight(int weight) {
+            this.weight = weight;
+            current.set(0);
+        }
+        public long increaseCurrent() {
+            return current.addAndGet(weight);
+        }
+        public void sel(int total) {
+            current.addAndGet(-1 * total);
+        }
+        public long getLastUpdate() {
+            return lastUpdate;
+        }
+        public void setLastUpdate(long lastUpdate) {
+            this.lastUpdate = lastUpdate;
+        }
+    }
 
-    private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();
-
+    private ConcurrentMap<String, Map<String, WeightedRoundRobin>> methodWeightMap = new ConcurrentHashMap<String, Map<String, WeightedRoundRobin>>();
+    private AtomicBoolean updateLock = new AtomicBoolean();
+    
+    /**
+     * get invoker addr list cached for specified invocation
+     * <p>
+     * <b>for unit test only</b>
+     * 
+     * @param invokers
+     * @param invocation
+     * @return
+     */
+    protected <T> Collection<String> getInvokerAddrList(List<Invoker<T>> invokers, Invocation invocation) {
+        String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map != null) {
+            return map.keySet();
+        }
+        return null;
+    }
+    
     @Override
     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
         String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
-        int length = invokers.size(); // Number of invokers
-        int maxWeight = 0; // The maximum weight
-        int minWeight = Integer.MAX_VALUE; // The minimum weight
-        final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();
-        int weightSum = 0;
-        for (int i = 0; i < length; i++) {
-            int weight = getWeight(invokers.get(i), invocation);
-            maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight
-            minWeight = Math.min(minWeight, weight); // Choose the minimum weight
-            if (weight > 0) {
-                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));
-                weightSum += weight;
-            }
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map == null) {
+            methodWeightMap.putIfAbsent(key, new ConcurrentHashMap<String, WeightedRoundRobin>());
+            map = methodWeightMap.get(key);
         }
-        AtomicPositiveInteger sequence = sequences.get(key);
-        if (sequence == null) {
-            sequences.putIfAbsent(key, new AtomicPositiveInteger());
-            sequence = sequences.get(key);
+        int totalWeight = 0;
+        long maxCurrent = Long.MIN_VALUE;
+        long now = System.currentTimeMillis();
+        Invoker<T> selectedInvoker = null;
+        WeightedRoundRobin selectedWRR = null;
+        for (Invoker<T> invoker : invokers) {
+            String identifyString = invoker.getUrl().toIdentityString();
+            WeightedRoundRobin weightedRoundRobin = map.get(identifyString);","[{'comment': 'we should use `putIfAbsent` too here.', 'commenter': 'beiwei30'}]"
2647,dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java,"@@ -17,87 +17,140 @@
 package com.alibaba.dubbo.rpc.cluster.loadbalance;
 
 import com.alibaba.dubbo.common.URL;
-import com.alibaba.dubbo.common.utils.AtomicPositiveInteger;
 import com.alibaba.dubbo.rpc.Invocation;
 import com.alibaba.dubbo.rpc.Invoker;
 
-import java.util.LinkedHashMap;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * Round robin load balance.
+ * 
+ * Smoothly round robin's implementation @since 2.6.5 
+ * @author jason
  *
  */
 public class RoundRobinLoadBalance extends AbstractLoadBalance {
-
     public static final String NAME = ""roundrobin"";
+    
+    private static int RECYCLE_PERIOD = 60000;
+    
+    protected static class WeightedRoundRobin {
+        private int weight;
+        private AtomicLong current = new AtomicLong(0);
+        private long lastUpdate;
+        public int getWeight() {
+            return weight;
+        }
+        public void setWeight(int weight) {
+            this.weight = weight;
+            current.set(0);
+        }
+        public long increaseCurrent() {
+            return current.addAndGet(weight);
+        }
+        public void sel(int total) {
+            current.addAndGet(-1 * total);
+        }
+        public long getLastUpdate() {
+            return lastUpdate;
+        }
+        public void setLastUpdate(long lastUpdate) {
+            this.lastUpdate = lastUpdate;
+        }
+    }
 
-    private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();
-
+    private ConcurrentMap<String, Map<String, WeightedRoundRobin>> methodWeightMap = new ConcurrentHashMap<String, Map<String, WeightedRoundRobin>>();
+    private AtomicBoolean updateLock = new AtomicBoolean();
+    
+    /**
+     * get invoker addr list cached for specified invocation
+     * <p>
+     * <b>for unit test only</b>
+     * 
+     * @param invokers
+     * @param invocation
+     * @return
+     */
+    protected <T> Collection<String> getInvokerAddrList(List<Invoker<T>> invokers, Invocation invocation) {
+        String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map != null) {
+            return map.keySet();
+        }
+        return null;
+    }
+    
     @Override
     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
         String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
-        int length = invokers.size(); // Number of invokers
-        int maxWeight = 0; // The maximum weight
-        int minWeight = Integer.MAX_VALUE; // The minimum weight
-        final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();
-        int weightSum = 0;
-        for (int i = 0; i < length; i++) {
-            int weight = getWeight(invokers.get(i), invocation);
-            maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight
-            minWeight = Math.min(minWeight, weight); // Choose the minimum weight
-            if (weight > 0) {
-                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));
-                weightSum += weight;
-            }
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map == null) {
+            methodWeightMap.putIfAbsent(key, new ConcurrentHashMap<String, WeightedRoundRobin>());
+            map = methodWeightMap.get(key);
         }
-        AtomicPositiveInteger sequence = sequences.get(key);
-        if (sequence == null) {
-            sequences.putIfAbsent(key, new AtomicPositiveInteger());
-            sequence = sequences.get(key);
+        int totalWeight = 0;
+        long maxCurrent = Long.MIN_VALUE;
+        long now = System.currentTimeMillis();
+        Invoker<T> selectedInvoker = null;
+        WeightedRoundRobin selectedWRR = null;
+        for (Invoker<T> invoker : invokers) {
+            String identifyString = invoker.getUrl().toIdentityString();
+            WeightedRoundRobin weightedRoundRobin = map.get(identifyString);
+            int weight = getWeight(invoker, invocation);
+            if (weight < 0) {
+                weight = 0;
+            }
+            if (weightedRoundRobin == null) {
+                weightedRoundRobin = new WeightedRoundRobin();
+                weightedRoundRobin.setWeight(weight);
+                map.put(identifyString, weightedRoundRobin);
+            }
+            if (weight != weightedRoundRobin.getWeight()) {
+                //weight changed
+                weightedRoundRobin.setWeight(weight);
+            }
+            long cur = weightedRoundRobin.increaseCurrent();
+            weightedRoundRobin.setLastUpdate(now);
+            if (cur > maxCurrent) {
+                maxCurrent = cur;
+                selectedInvoker = invoker;
+                selectedWRR = weightedRoundRobin;
+            }
+            totalWeight += weight;
         }
-        int currentSequence = sequence.getAndIncrement();
-        if (maxWeight > 0 && minWeight < maxWeight) {
-            int mod = currentSequence % weightSum;
-            for (int i = 0; i < maxWeight; i++) {
-                for (Map.Entry<Invoker<T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) {
-                    final Invoker<T> k = each.getKey();
-                    final IntegerWrapper v = each.getValue();
-                    if (mod == 0 && v.getValue() > 0) {
-                        return k;
-                    }
-                    if (v.getValue() > 0) {
-                        v.decrement();
-                        mod--;
+        if (!updateLock.get() && invokers.size() != map.size()) {
+            if (updateLock.compareAndSet(false, true)) {
+                try {
+                    // copy -> modify -> update reference
+                    HashMap<String, WeightedRoundRobin> newMap = new HashMap<String, WeightedRoundRobin>();
+                    newMap.putAll(map);
+                    Iterator<Entry<String, WeightedRoundRobin>> it = newMap.entrySet().iterator();
+                    while (it.hasNext()) {
+                        Entry<String, WeightedRoundRobin> item = it.next();
+                        if (now - item.getValue().getLastUpdate() > RECYCLE_PERIOD) {
+                            it.remove();
+                        }
                     }
+                    methodWeightMap.put(key, newMap);
+                } finally {
+                    updateLock.set(false);
                 }
             }
         }
-        // Round robin
-        return invokers.get(currentSequence % length);
-    }
-
-    private static final class IntegerWrapper {
-        private int value;
-
-        public IntegerWrapper(int value) {
-            this.value = value;
-        }
-
-        public int getValue() {
-            return value;
-        }
-
-        public void setValue(int value) {
-            this.value = value;
-        }
-
-        public void decrement() {
-            this.value--;
+        if (selectedInvoker != null) {
+            selectedWRR.sel(totalWeight);
+            return selectedInvoker;
         }
+        return null;","[{'comment': 'one more thing, should we fall back to `random` here?', 'commenter': 'beiwei30'}]"
2647,dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java,"@@ -17,87 +17,142 @@
 package com.alibaba.dubbo.rpc.cluster.loadbalance;
 
 import com.alibaba.dubbo.common.URL;
-import com.alibaba.dubbo.common.utils.AtomicPositiveInteger;
 import com.alibaba.dubbo.rpc.Invocation;
 import com.alibaba.dubbo.rpc.Invoker;
 
-import java.util.LinkedHashMap;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * Round robin load balance.
+ * 
+ * Smoothly round robin's implementation @since 2.6.5 
+ * @author jason
  *
  */
 public class RoundRobinLoadBalance extends AbstractLoadBalance {
-
     public static final String NAME = ""roundrobin"";
+    
+    private static int RECYCLE_PERIOD = 60000;
+    
+    protected static class WeightedRoundRobin {
+        private int weight;
+        private AtomicLong current = new AtomicLong(0);
+        private long lastUpdate;
+        public int getWeight() {
+            return weight;
+        }
+        public void setWeight(int weight) {
+            this.weight = weight;
+            current.set(0);
+        }
+        public long increaseCurrent() {
+            return current.addAndGet(weight);
+        }
+        public void sel(int total) {
+            current.addAndGet(-1 * total);
+        }
+        public long getLastUpdate() {
+            return lastUpdate;
+        }
+        public void setLastUpdate(long lastUpdate) {
+            this.lastUpdate = lastUpdate;
+        }
+    }
 
-    private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();
-
+    private ConcurrentMap<String, Map<String, WeightedRoundRobin>> methodWeightMap = new ConcurrentHashMap<String, Map<String, WeightedRoundRobin>>();
+    private AtomicBoolean updateLock = new AtomicBoolean();
+    
+    /**
+     * get invoker addr list cached for specified invocation
+     * <p>
+     * <b>for unit test only</b>
+     * 
+     * @param invokers
+     * @param invocation
+     * @return
+     */
+    protected <T> Collection<String> getInvokerAddrList(List<Invoker<T>> invokers, Invocation invocation) {
+        String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map != null) {
+            return map.keySet();
+        }
+        return null;
+    }
+    
     @Override
     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
         String key = invokers.get(0).getUrl().getServiceKey() + ""."" + invocation.getMethodName();
-        int length = invokers.size(); // Number of invokers
-        int maxWeight = 0; // The maximum weight
-        int minWeight = Integer.MAX_VALUE; // The minimum weight
-        final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();
-        int weightSum = 0;
-        for (int i = 0; i < length; i++) {
-            int weight = getWeight(invokers.get(i), invocation);
-            maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight
-            minWeight = Math.min(minWeight, weight); // Choose the minimum weight
-            if (weight > 0) {
-                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));
-                weightSum += weight;
-            }
+        Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+        if (map == null) {
+            methodWeightMap.putIfAbsent(key, new ConcurrentHashMap<String, WeightedRoundRobin>());
+            map = methodWeightMap.get(key);
         }
-        AtomicPositiveInteger sequence = sequences.get(key);
-        if (sequence == null) {
-            sequences.putIfAbsent(key, new AtomicPositiveInteger());
-            sequence = sequences.get(key);
+        int totalWeight = 0;
+        long maxCurrent = Long.MIN_VALUE;
+        long now = System.currentTimeMillis();
+        Invoker<T> selectedInvoker = null;
+        WeightedRoundRobin selectedWRR = null;
+        for (Invoker<T> invoker : invokers) {
+            String identifyString = invoker.getUrl().toIdentityString();
+            WeightedRoundRobin weightedRoundRobin = map.get(identifyString);
+            int weight = getWeight(invoker, invocation);
+            if (weight < 0) {
+                weight = 0;
+            }
+            if (weightedRoundRobin == null) {
+                weightedRoundRobin = new WeightedRoundRobin();
+                weightedRoundRobin.setWeight(weight);
+                map.putIfAbsent(identifyString, weightedRoundRobin);","[{'comment': ""we cannot use Map's `putIfAbsent` here since it's a new API since 1.8. we need to make sure dubbo 1.6 works with java 1.6 and above."", 'commenter': 'beiwei30'}]"
2655,dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/ServiceBean.java,"@@ -16,23 +16,16 @@
  */
 package com.alibaba.dubbo.config.spring;
 
-import com.alibaba.dubbo.config.ApplicationConfig;
-import com.alibaba.dubbo.config.ModuleConfig;
-import com.alibaba.dubbo.config.MonitorConfig;
-import com.alibaba.dubbo.config.ProtocolConfig;
-import com.alibaba.dubbo.config.ProviderConfig;
-import com.alibaba.dubbo.config.RegistryConfig;
-import com.alibaba.dubbo.config.ServiceConfig;
+import com.alibaba.dubbo.config.*;","[{'comment': 'Maybe you should use dubbo code style here ?  you can found here : https://github.com/apache/incubator-dubbo/blob/master/codestyle/dubbo_codestyle_for_idea.xml\r\n\r\nremove `*` please.', 'commenter': 'zonghaishang'}]"
2655,dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/beans/factory/annotation/AbstractAnnotationConfigBeanBuilder.java,"@@ -16,11 +16,7 @@
  */
 package com.alibaba.dubbo.config.spring.beans.factory.annotation;
 
-import com.alibaba.dubbo.config.AbstractInterfaceConfig;
-import com.alibaba.dubbo.config.ApplicationConfig;
-import com.alibaba.dubbo.config.ModuleConfig;
-import com.alibaba.dubbo.config.MonitorConfig;
-import com.alibaba.dubbo.config.RegistryConfig;
+import com.alibaba.dubbo.config.*;","[{'comment': 'remove * please.', 'commenter': 'zonghaishang'}]"
2655,dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/util/AnnotationUtils.java,"@@ -86,4 +88,44 @@
 
     }
 
-}
+    public static String resolveInterfaceName(Service service, Class<?> defaultInterfaceClass)
+            throws IllegalStateException {
+
+        String interfaceName;
+        if (!"""".equals(service.interfaceName())) {","[{'comment': 'Use `StringUtils.isNotEmpty` maybe better.', 'commenter': 'zonghaishang'}]"
2655,dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/util/AnnotationUtils.java,"@@ -86,4 +88,44 @@
 
     }
 
-}
+    public static String resolveInterfaceName(Service service, Class<?> defaultInterfaceClass)
+            throws IllegalStateException {
+
+        String interfaceName;
+        if (!"""".equals(service.interfaceName())) {
+            interfaceName = service.interfaceName();
+        } else if (!void.class.equals(service.interfaceClass())) {
+            interfaceName = service.interfaceClass().getName();
+        } else if (defaultInterfaceClass.isInterface()) {
+            interfaceName = defaultInterfaceClass.getName();
+        } else {
+            throw new IllegalStateException(
+                    ""The @Service undefined interfaceClass or interfaceName, and the type ""
+                            + defaultInterfaceClass.getName() + "" is not a interface."");
+        }
+
+        return interfaceName;
+
+    }
+
+    public static String resolveInterfaceName(Reference reference, Class<?> defaultInterfaceClass)
+            throws IllegalStateException {
+
+        String interfaceName;
+        if (!"""".equals(reference.interfaceName())) {","[{'comment': 'Use `StringUtils.isNotEmpty` maybe better.', 'commenter': 'zonghaishang'}]"
2655,dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java,"@@ -18,488 +18,233 @@
 
 import com.alibaba.dubbo.config.annotation.Reference;
 import com.alibaba.dubbo.config.spring.ReferenceBean;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.springframework.beans.BeanUtils;
+import com.alibaba.dubbo.config.spring.ServiceBean;
+import com.alibaba.dubbo.config.spring.context.event.ServiceBeanExportedEvent;
+import com.alibaba.spring.beans.factory.annotation.AnnotationInjectedBeanPostProcessor;
 import org.springframework.beans.BeansException;
-import org.springframework.beans.PropertyValues;
-import org.springframework.beans.factory.BeanClassLoaderAware;
-import org.springframework.beans.factory.BeanCreationException;
-import org.springframework.beans.factory.DisposableBean;
 import org.springframework.beans.factory.annotation.InjectionMetadata;
-import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;
-import org.springframework.beans.factory.support.MergedBeanDefinitionPostProcessor;
-import org.springframework.beans.factory.support.RootBeanDefinition;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.ApplicationContextAware;
-import org.springframework.core.PriorityOrdered;
-import org.springframework.core.env.Environment;
-import org.springframework.util.ClassUtils;
-import org.springframework.util.ReflectionUtils;
-import org.springframework.util.StringUtils;
+import org.springframework.context.ApplicationEvent;
+import org.springframework.context.ApplicationListener;
+import org.springframework.context.event.ContextRefreshedEvent;
 
-import java.beans.PropertyDescriptor;
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
+import java.lang.reflect.Proxy;
 import java.util.Collection;
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.List;
+import java.util.Collections;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
-import static org.springframework.core.BridgeMethodResolver.findBridgedMethod;
-import static org.springframework.core.BridgeMethodResolver.isVisibilityBridgeMethodPair;
-import static org.springframework.core.annotation.AnnotationUtils.findAnnotation;
-import static org.springframework.core.annotation.AnnotationUtils.getAnnotation;
-
 /**
  * {@link org.springframework.beans.factory.config.BeanPostProcessor} implementation
  * that Consumer service {@link Reference} annotated fields
  *
  * @since 2.5.7
  */
-public class ReferenceAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter
-        implements MergedBeanDefinitionPostProcessor, PriorityOrdered, ApplicationContextAware, BeanClassLoaderAware,
-        DisposableBean {
+public class ReferenceAnnotationBeanPostProcessor extends AnnotationInjectedBeanPostProcessor<Reference>
+        implements ApplicationContextAware, ApplicationListener {
 
     /**
      * The bean name of {@link ReferenceAnnotationBeanPostProcessor}
      */
     public static final String BEAN_NAME = ""referenceAnnotationBeanPostProcessor"";
 
-    private final Log logger = LogFactory.getLog(getClass());
-
-    private ApplicationContext applicationContext;
+    /**
+     * Cache size
+     */
+    private static final int CACHE_SIZE = Integer.getInteger(BEAN_NAME + "".cache.size"", 32);
 
-    private ClassLoader classLoader;
+    private final ConcurrentMap<String, ReferenceBean<?>> referenceBeanCache =
+            new ConcurrentHashMap<String, ReferenceBean<?>>(CACHE_SIZE);
 
-    private final ConcurrentMap<String, ReferenceInjectionMetadata> injectionMetadataCache =
-            new ConcurrentHashMap<String, ReferenceInjectionMetadata>(256);
+    private final ConcurrentHashMap<String, ReferenceBeanInvocationHandler> localReferenceBeanInvocationHandlerCache =
+            new ConcurrentHashMap<String, ReferenceBeanInvocationHandler>(CACHE_SIZE);
 
-    private final ConcurrentMap<String, ReferenceBean<?>> referenceBeansCache =
-            new ConcurrentHashMap<String, ReferenceBean<?>>();
+    private final ConcurrentMap<InjectionMetadata.InjectedElement, ReferenceBean<?>> injectedFieldReferenceBeanCache =
+            new ConcurrentHashMap<InjectionMetadata.InjectedElement, ReferenceBean<?>>(CACHE_SIZE);
 
-    @Override
-    public PropertyValues postProcessPropertyValues(
-            PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException {
-
-        InjectionMetadata metadata = findReferenceMetadata(beanName, bean.getClass(), pvs);
-        try {
-            metadata.inject(bean, beanName, pvs);
-        } catch (BeanCreationException ex) {
-            throw ex;
-        } catch (Throwable ex) {
-            throw new BeanCreationException(beanName, ""Injection of @Reference dependencies failed"", ex);
-        }
-        return pvs;
-    }
+    private final ConcurrentMap<InjectionMetadata.InjectedElement, ReferenceBean<?>> injectedMethodReferenceBeanCache =
+            new ConcurrentHashMap<InjectionMetadata.InjectedElement, ReferenceBean<?>>(CACHE_SIZE);
 
+    private ApplicationContext applicationContext;
 
     /**
-     * Finds {@link InjectionMetadata.InjectedElement} Metadata from annotated {@link Reference @Reference} fields
+     * Gets all beans of {@link ReferenceBean}
      *
-     * @param beanClass The {@link Class} of Bean
-     * @return non-null {@link List}
+     * @return non-null read-only {@link Collection}
+     * @since 2.5.9
      */
-    private List<ReferenceFieldElement> findFieldReferenceMetadata(final Class<?> beanClass) {
-
-        final List<ReferenceFieldElement> elements = new LinkedList<ReferenceFieldElement>();
-
-        ReflectionUtils.doWithFields(beanClass, new ReflectionUtils.FieldCallback() {
-            @Override
-            public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {
-
-                Reference reference = getAnnotation(field, Reference.class);
-
-                if (reference != null) {
-
-                    if (Modifier.isStatic(field.getModifiers())) {
-                        if (logger.isWarnEnabled()) {
-                            logger.warn(""@Reference annotation is not supported on static fields: "" + field);
-                        }
-                        return;
-                    }
-
-                    elements.add(new ReferenceFieldElement(field, reference));
-                }
-
-            }
-        });
-
-        return elements;
-
+    public Collection<ReferenceBean<?>> getReferenceBeans() {
+        return referenceBeanCache.values();
     }
 
     /**
-     * Finds {@link InjectionMetadata.InjectedElement} Metadata from annotated {@link Reference @Reference} methods
+     * Get {@link ReferenceBean} {@link Map} in injected field.
      *
-     * @param beanClass The {@link Class} of Bean
-     * @return non-null {@link List}
+     * @return non-null {@link Map}
+     * @since 2.5.11
      */
-    private List<ReferenceMethodElement> findMethodReferenceMetadata(final Class<?> beanClass) {
-
-        final List<ReferenceMethodElement> elements = new LinkedList<ReferenceMethodElement>();
-
-        ReflectionUtils.doWithMethods(beanClass, new ReflectionUtils.MethodCallback() {
-            @Override
-            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
-
-                Method bridgedMethod = findBridgedMethod(method);
-
-                if (!isVisibilityBridgeMethodPair(method, bridgedMethod)) {
-                    return;
-                }
-
-                Reference reference = findAnnotation(bridgedMethod, Reference.class);
-
-                if (reference != null && method.equals(ClassUtils.getMostSpecificMethod(method, beanClass))) {
-                    if (Modifier.isStatic(method.getModifiers())) {
-                        if (logger.isWarnEnabled()) {
-                            logger.warn(""@Reference annotation is not supported on static methods: "" + method);
-                        }
-                        return;
-                    }
-                    if (method.getParameterTypes().length == 0) {
-                        if (logger.isWarnEnabled()) {
-                            logger.warn(""@Reference  annotation should only be used on methods with parameters: "" +
-                                    method);
-                        }
-                    }
-                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, beanClass);
-                    elements.add(new ReferenceMethodElement(method, pd, reference));
-                }
-            }
-        });
-
-        return elements;
-
+    public Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> getInjectedFieldReferenceBeanMap() {
+        return Collections.unmodifiableMap(injectedFieldReferenceBeanCache);
     }
 
-
     /**
-     * @param beanClass
-     * @return
+     * Get {@link ReferenceBean} {@link Map} in injected method.
+     *
+     * @return non-null {@link Map}
+     * @since 2.5.11
      */
-    private ReferenceInjectionMetadata buildReferenceMetadata(final Class<?> beanClass) {
-        Collection<ReferenceFieldElement> fieldElements = findFieldReferenceMetadata(beanClass);
-        Collection<ReferenceMethodElement> methodElements = findMethodReferenceMetadata(beanClass);
-        return new ReferenceInjectionMetadata(beanClass, fieldElements, methodElements);
-
-    }
-
-    private InjectionMetadata findReferenceMetadata(String beanName, Class<?> clazz, PropertyValues pvs) {
-        // Fall back to class name as cache key, for backwards compatibility with custom callers.
-        String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
-        // Quick check on the concurrent map first, with minimal locking.
-        ReferenceInjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
-        if (InjectionMetadata.needsRefresh(metadata, clazz)) {
-            synchronized (this.injectionMetadataCache) {
-                metadata = this.injectionMetadataCache.get(cacheKey);
-                if (InjectionMetadata.needsRefresh(metadata, clazz)) {
-                    if (metadata != null) {
-                        metadata.clear(pvs);
-                    }
-                    try {
-                        metadata = buildReferenceMetadata(clazz);
-                        this.injectionMetadataCache.put(cacheKey, metadata);
-                    } catch (NoClassDefFoundError err) {
-                        throw new IllegalStateException(""Failed to introspect bean class ["" + clazz.getName() +
-                                ""] for reference metadata: could not find class that it depends on"", err);
-                    }
-                }
-            }
-        }
-        return metadata;
-    }
-
-    @Override
-    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
-        this.applicationContext = applicationContext;
-    }
-
-    @Override
-    public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
-        if (beanType != null) {
-            InjectionMetadata metadata = findReferenceMetadata(beanName, beanType, null);
-            metadata.checkConfigMembers(beanDefinition);
-        }
-    }
-
-    @Override
-    public int getOrder() {
-        return LOWEST_PRECEDENCE;
+    public Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> getInjectedMethodReferenceBeanMap() {
+        return Collections.unmodifiableMap(injectedMethodReferenceBeanCache);
     }
 
     @Override
-    public void destroy() throws Exception {
+    protected Object doGetInjectedBean(Reference reference, Object bean, String beanName, Class<?> injectedType,
+                                       InjectionMetadata.InjectedElement injectedElement) throws Exception {
 
-        for (ReferenceBean referenceBean : referenceBeansCache.values()) {
-            if (logger.isInfoEnabled()) {
-                logger.info(referenceBean + "" was destroying!"");
-            }
-            referenceBean.destroy();
-        }
+        String referencedBeanName = buildReferencedBeanName(reference, injectedType);","[{'comment': 'Multiple services referencing the same field here will cause a bug， see: https://github.com/apache/incubator-dubbo/commit/d8282fe1b8075a453c7b44b4ae7982a4285df7b7', 'commenter': 'zonghaishang'}]"
2655,dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java,"@@ -18,488 +18,233 @@
 
 import com.alibaba.dubbo.config.annotation.Reference;
 import com.alibaba.dubbo.config.spring.ReferenceBean;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.springframework.beans.BeanUtils;
+import com.alibaba.dubbo.config.spring.ServiceBean;
+import com.alibaba.dubbo.config.spring.context.event.ServiceBeanExportedEvent;
+import com.alibaba.spring.beans.factory.annotation.AnnotationInjectedBeanPostProcessor;
 import org.springframework.beans.BeansException;
-import org.springframework.beans.PropertyValues;
-import org.springframework.beans.factory.BeanClassLoaderAware;
-import org.springframework.beans.factory.BeanCreationException;
-import org.springframework.beans.factory.DisposableBean;
 import org.springframework.beans.factory.annotation.InjectionMetadata;
-import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;
-import org.springframework.beans.factory.support.MergedBeanDefinitionPostProcessor;
-import org.springframework.beans.factory.support.RootBeanDefinition;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.ApplicationContextAware;
-import org.springframework.core.PriorityOrdered;
-import org.springframework.core.env.Environment;
-import org.springframework.util.ClassUtils;
-import org.springframework.util.ReflectionUtils;
-import org.springframework.util.StringUtils;
+import org.springframework.context.ApplicationEvent;
+import org.springframework.context.ApplicationListener;
+import org.springframework.context.event.ContextRefreshedEvent;
 
-import java.beans.PropertyDescriptor;
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
+import java.lang.reflect.Proxy;
 import java.util.Collection;
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.List;
+import java.util.Collections;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
-import static org.springframework.core.BridgeMethodResolver.findBridgedMethod;
-import static org.springframework.core.BridgeMethodResolver.isVisibilityBridgeMethodPair;
-import static org.springframework.core.annotation.AnnotationUtils.findAnnotation;
-import static org.springframework.core.annotation.AnnotationUtils.getAnnotation;
-
 /**
  * {@link org.springframework.beans.factory.config.BeanPostProcessor} implementation
  * that Consumer service {@link Reference} annotated fields
  *
  * @since 2.5.7
  */
-public class ReferenceAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter
-        implements MergedBeanDefinitionPostProcessor, PriorityOrdered, ApplicationContextAware, BeanClassLoaderAware,
-        DisposableBean {
+public class ReferenceAnnotationBeanPostProcessor extends AnnotationInjectedBeanPostProcessor<Reference>
+        implements ApplicationContextAware, ApplicationListener {
 
     /**
      * The bean name of {@link ReferenceAnnotationBeanPostProcessor}
      */
     public static final String BEAN_NAME = ""referenceAnnotationBeanPostProcessor"";
 
-    private final Log logger = LogFactory.getLog(getClass());
-
-    private ApplicationContext applicationContext;
+    /**
+     * Cache size
+     */
+    private static final int CACHE_SIZE = Integer.getInteger(BEAN_NAME + "".cache.size"", 32);
 
-    private ClassLoader classLoader;
+    private final ConcurrentMap<String, ReferenceBean<?>> referenceBeanCache =
+            new ConcurrentHashMap<String, ReferenceBean<?>>(CACHE_SIZE);
 
-    private final ConcurrentMap<String, ReferenceInjectionMetadata> injectionMetadataCache =
-            new ConcurrentHashMap<String, ReferenceInjectionMetadata>(256);
+    private final ConcurrentHashMap<String, ReferenceBeanInvocationHandler> localReferenceBeanInvocationHandlerCache =
+            new ConcurrentHashMap<String, ReferenceBeanInvocationHandler>(CACHE_SIZE);
 
-    private final ConcurrentMap<String, ReferenceBean<?>> referenceBeansCache =
-            new ConcurrentHashMap<String, ReferenceBean<?>>();
+    private final ConcurrentMap<InjectionMetadata.InjectedElement, ReferenceBean<?>> injectedFieldReferenceBeanCache =
+            new ConcurrentHashMap<InjectionMetadata.InjectedElement, ReferenceBean<?>>(CACHE_SIZE);
 
-    @Override
-    public PropertyValues postProcessPropertyValues(
-            PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException {
-
-        InjectionMetadata metadata = findReferenceMetadata(beanName, bean.getClass(), pvs);
-        try {
-            metadata.inject(bean, beanName, pvs);
-        } catch (BeanCreationException ex) {
-            throw ex;
-        } catch (Throwable ex) {
-            throw new BeanCreationException(beanName, ""Injection of @Reference dependencies failed"", ex);
-        }
-        return pvs;
-    }
+    private final ConcurrentMap<InjectionMetadata.InjectedElement, ReferenceBean<?>> injectedMethodReferenceBeanCache =
+            new ConcurrentHashMap<InjectionMetadata.InjectedElement, ReferenceBean<?>>(CACHE_SIZE);
 
+    private ApplicationContext applicationContext;
 
     /**
-     * Finds {@link InjectionMetadata.InjectedElement} Metadata from annotated {@link Reference @Reference} fields
+     * Gets all beans of {@link ReferenceBean}
      *
-     * @param beanClass The {@link Class} of Bean
-     * @return non-null {@link List}
+     * @return non-null read-only {@link Collection}
+     * @since 2.5.9
      */
-    private List<ReferenceFieldElement> findFieldReferenceMetadata(final Class<?> beanClass) {
-
-        final List<ReferenceFieldElement> elements = new LinkedList<ReferenceFieldElement>();
-
-        ReflectionUtils.doWithFields(beanClass, new ReflectionUtils.FieldCallback() {
-            @Override
-            public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {
-
-                Reference reference = getAnnotation(field, Reference.class);
-
-                if (reference != null) {
-
-                    if (Modifier.isStatic(field.getModifiers())) {
-                        if (logger.isWarnEnabled()) {
-                            logger.warn(""@Reference annotation is not supported on static fields: "" + field);
-                        }
-                        return;
-                    }
-
-                    elements.add(new ReferenceFieldElement(field, reference));
-                }
-
-            }
-        });
-
-        return elements;
-
+    public Collection<ReferenceBean<?>> getReferenceBeans() {
+        return referenceBeanCache.values();
     }
 
     /**
-     * Finds {@link InjectionMetadata.InjectedElement} Metadata from annotated {@link Reference @Reference} methods
+     * Get {@link ReferenceBean} {@link Map} in injected field.
      *
-     * @param beanClass The {@link Class} of Bean
-     * @return non-null {@link List}
+     * @return non-null {@link Map}
+     * @since 2.5.11
      */
-    private List<ReferenceMethodElement> findMethodReferenceMetadata(final Class<?> beanClass) {
-
-        final List<ReferenceMethodElement> elements = new LinkedList<ReferenceMethodElement>();
-
-        ReflectionUtils.doWithMethods(beanClass, new ReflectionUtils.MethodCallback() {
-            @Override
-            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
-
-                Method bridgedMethod = findBridgedMethod(method);
-
-                if (!isVisibilityBridgeMethodPair(method, bridgedMethod)) {
-                    return;
-                }
-
-                Reference reference = findAnnotation(bridgedMethod, Reference.class);
-
-                if (reference != null && method.equals(ClassUtils.getMostSpecificMethod(method, beanClass))) {
-                    if (Modifier.isStatic(method.getModifiers())) {
-                        if (logger.isWarnEnabled()) {
-                            logger.warn(""@Reference annotation is not supported on static methods: "" + method);
-                        }
-                        return;
-                    }
-                    if (method.getParameterTypes().length == 0) {
-                        if (logger.isWarnEnabled()) {
-                            logger.warn(""@Reference  annotation should only be used on methods with parameters: "" +
-                                    method);
-                        }
-                    }
-                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, beanClass);
-                    elements.add(new ReferenceMethodElement(method, pd, reference));
-                }
-            }
-        });
-
-        return elements;
-
+    public Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> getInjectedFieldReferenceBeanMap() {
+        return Collections.unmodifiableMap(injectedFieldReferenceBeanCache);
     }
 
-
     /**
-     * @param beanClass
-     * @return
+     * Get {@link ReferenceBean} {@link Map} in injected method.
+     *
+     * @return non-null {@link Map}
+     * @since 2.5.11
      */
-    private ReferenceInjectionMetadata buildReferenceMetadata(final Class<?> beanClass) {
-        Collection<ReferenceFieldElement> fieldElements = findFieldReferenceMetadata(beanClass);
-        Collection<ReferenceMethodElement> methodElements = findMethodReferenceMetadata(beanClass);
-        return new ReferenceInjectionMetadata(beanClass, fieldElements, methodElements);
-
-    }
-
-    private InjectionMetadata findReferenceMetadata(String beanName, Class<?> clazz, PropertyValues pvs) {
-        // Fall back to class name as cache key, for backwards compatibility with custom callers.
-        String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
-        // Quick check on the concurrent map first, with minimal locking.
-        ReferenceInjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
-        if (InjectionMetadata.needsRefresh(metadata, clazz)) {
-            synchronized (this.injectionMetadataCache) {
-                metadata = this.injectionMetadataCache.get(cacheKey);
-                if (InjectionMetadata.needsRefresh(metadata, clazz)) {
-                    if (metadata != null) {
-                        metadata.clear(pvs);
-                    }
-                    try {
-                        metadata = buildReferenceMetadata(clazz);
-                        this.injectionMetadataCache.put(cacheKey, metadata);
-                    } catch (NoClassDefFoundError err) {
-                        throw new IllegalStateException(""Failed to introspect bean class ["" + clazz.getName() +
-                                ""] for reference metadata: could not find class that it depends on"", err);
-                    }
-                }
-            }
-        }
-        return metadata;
-    }
-
-    @Override
-    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
-        this.applicationContext = applicationContext;
-    }
-
-    @Override
-    public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
-        if (beanType != null) {
-            InjectionMetadata metadata = findReferenceMetadata(beanName, beanType, null);
-            metadata.checkConfigMembers(beanDefinition);
-        }
-    }
-
-    @Override
-    public int getOrder() {
-        return LOWEST_PRECEDENCE;
+    public Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> getInjectedMethodReferenceBeanMap() {
+        return Collections.unmodifiableMap(injectedMethodReferenceBeanCache);
     }
 
     @Override
-    public void destroy() throws Exception {
+    protected Object doGetInjectedBean(Reference reference, Object bean, String beanName, Class<?> injectedType,
+                                       InjectionMetadata.InjectedElement injectedElement) throws Exception {
 
-        for (ReferenceBean referenceBean : referenceBeansCache.values()) {
-            if (logger.isInfoEnabled()) {
-                logger.info(referenceBean + "" was destroying!"");
-            }
-            referenceBean.destroy();
-        }
+        String referencedBeanName = buildReferencedBeanName(reference, injectedType);
 
-        injectionMetadataCache.clear();
-        referenceBeansCache.clear();
+        ReferenceBean referenceBean = buildReferenceBeanIfAbsent(referencedBeanName, reference, injectedType, getClassLoader());
 
-        if (logger.isInfoEnabled()) {
-            logger.info(getClass() + "" was destroying!"");
-        }
+        cacheInjectedReferenceBean(referenceBean, injectedElement);
 
-    }
+        Object proxy = buildProxy(referencedBeanName, referenceBean, injectedType);
 
-    @Override
-    public void setBeanClassLoader(ClassLoader classLoader) {
-        this.classLoader = classLoader;
+        return proxy;
     }
 
-
-    /**
-     * Gets all beans of {@link ReferenceBean}
-     *
-     * @return non-null {@link Collection}
-     * @since 2.5.9
-     */
-    public Collection<ReferenceBean<?>> getReferenceBeans() {
-        return this.referenceBeansCache.values();
+    private Object buildProxy(String referencedBeanName, ReferenceBean referenceBean, Class<?> injectedType) {
+        InvocationHandler handler = buildInvocationHandler(referencedBeanName, referenceBean);
+        Object proxy = Proxy.newProxyInstance(getClassLoader(), new Class[]{injectedType}, handler);
+        return proxy;
     }
 
+    private InvocationHandler buildInvocationHandler(String referencedBeanName, ReferenceBean referenceBean) {
 
-    /**
-     * {@link Reference} {@link InjectionMetadata} implementation
-     *
-     * @since 2.5.11
-     */
-    private static class ReferenceInjectionMetadata extends InjectionMetadata {
-
-        private final Collection<ReferenceFieldElement> fieldElements;
+        ReferenceBeanInvocationHandler handler = localReferenceBeanInvocationHandlerCache.get(referencedBeanName);
 
-        private final Collection<ReferenceMethodElement> methodElements;
-
-
-        public ReferenceInjectionMetadata(Class<?> targetClass, Collection<ReferenceFieldElement> fieldElements,
-                                          Collection<ReferenceMethodElement> methodElements) {
-            super(targetClass, combine(fieldElements, methodElements));
-            this.fieldElements = fieldElements;
-            this.methodElements = methodElements;
+        if (handler == null) {
+            handler = new ReferenceBeanInvocationHandler(referenceBean);
         }
 
-        private static <T> Collection<T> combine(Collection<? extends T>... elements) {
-            List<T> allElements = new ArrayList<T>();
-            for (Collection<? extends T> e : elements) {
-                allElements.addAll(e);
-            }
-            return allElements;
-        }
-
-        public Collection<ReferenceFieldElement> getFieldElements() {
-            return fieldElements;
+        if (applicationContext.containsBean(referencedBeanName)) { // Is local @Service Bean or not ?
+            // ReferenceBeanInvocationHandler's initialization has to wait for current local @Service Bean has been exported.
+            localReferenceBeanInvocationHandlerCache.put(referencedBeanName, handler);
+        } else {
+            // Remote Reference Bean should initialize immediately
+            handler.init();
         }
 
-        public Collection<ReferenceMethodElement> getMethodElements() {
-            return methodElements;
-        }
+        return handler;
     }
 
-    /**
-     * {@link Reference} {@link Method} {@link InjectionMetadata.InjectedElement}
-     */
-    private class ReferenceMethodElement extends InjectionMetadata.InjectedElement {
+    private static class ReferenceBeanInvocationHandler implements InvocationHandler {
 
-        private final Method method;
+        private final ReferenceBean referenceBean;
 
-        private final Reference reference;
+        private Object bean;
 
-        private volatile ReferenceBean<?> referenceBean;
-
-        protected ReferenceMethodElement(Method method, PropertyDescriptor pd, Reference reference) {
-            super(method, pd);
-            this.method = method;
-            this.reference = reference;
+        private ReferenceBeanInvocationHandler(ReferenceBean referenceBean) {
+            this.referenceBean = referenceBean;
         }
 
         @Override
-        protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable {
-
-            Class<?> referenceClass = pd.getPropertyType();
-
-            referenceBean = buildReferenceBean(reference, referenceClass);
-
-            ReflectionUtils.makeAccessible(method);
-
-            method.invoke(bean, referenceBean.getObject());
-
+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+            return method.invoke(bean, args);
         }
 
-    }
-
-    /**
-     * {@link Reference} {@link Field} {@link InjectionMetadata.InjectedElement}
-     */
-    private class ReferenceFieldElement extends InjectionMetadata.InjectedElement {
-
-        private final Field field;
-
-        private final Reference reference;
-
-        private volatile ReferenceBean<?> referenceBean;
-
-        protected ReferenceFieldElement(Field field, Reference reference) {
-            super(field, null);
-            this.field = field;
-            this.reference = reference;
+        private void init() {
+            this.bean = referenceBean.get();
         }
+    }
 
-        @Override
-        protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable {
-
-            Class<?> referenceClass = field.getType();
+    @Override
+    protected String buildInjectedObjectCacheKey(Reference reference, Object bean, String beanName,","[{'comment': 'Multiple services referencing the same field here will cause a bug， see:  https://github.com/apache/incubator-dubbo/commit/d8282fe1b8075a453c7b44b4ae7982a4285df7b7', 'commenter': 'zonghaishang'}]"
2658,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java,"@@ -181,37 +177,40 @@ public boolean hasAttribute(String key) {
     }
 
     private void startHeartbeatTimer() {
-        stopHeartbeatTimer();
-        if (heartbeat > 0) {
-            heartbeatTimer = scheduled.scheduleWithFixedDelay(
-                    new HeartBeatTask(new HeartBeatTask.ChannelProvider() {
-                        @Override
-                        public Collection<Channel> getChannels() {
-                            return Collections.<Channel>singletonList(HeaderExchangeClient.this);
-                        }
-                    }, heartbeat, heartbeatTimeout),
-                    heartbeat, heartbeat, TimeUnit.MILLISECONDS);
-        }
+        AbstractTimerTask.ChannelProvider cp = () -> Collections.singletonList(HeaderExchangeClient.this);
+
+        long heartbeatTick = calcLeastTick(heartbeat);
+        long heartbeatTimeoutTick = calcLeastTick(heartbeatTimeout);
+        HeartbeatTimerTask heartBeatTimerTask = new HeartbeatTimerTask(cp, heartbeatTick, heartbeat);
+        ReconnectTimerTask reconnectTimerTask = new ReconnectTimerTask(cp, heartbeatTimeoutTick, heartbeatTimeout);
+
+        // init task and start timer.
+        heartbeatTimer.newTimeout(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS);
+        heartbeatTimer.newTimeout(reconnectTimerTask, heartbeatTimeoutTick, TimeUnit.MILLISECONDS);
     }
 
     private void stopHeartbeatTimer() {
-        if (heartbeatTimer != null && !heartbeatTimer.isCancelled()) {
-            try {
-                heartbeatTimer.cancel(true);
-                scheduled.purge();
-            } catch (Throwable e) {
-                if (logger.isWarnEnabled()) {
-                    logger.warn(e.getMessage(), e);
-                }
-            }
+        if (heartbeatTimer != null) {
+            heartbeatTimer.stop();
+            heartbeatTimer = null;
         }
-        heartbeatTimer = null;
     }
 
     private void doClose() {
         stopHeartbeatTimer();
     }
 
+    /**
+     * Each interval cannot be less than 1000ms.
+     */
+    private long calcLeastTick(int time) {
+        if (time / Constants.HEARTBEAT_TICK <= 0) {
+            return Constants.LEAST_HEARTBEAT_TICK;
+        } else {
+            return time / Constants.HEARTBEAT_TICK;","[{'comment': 'I am little confused why `time/Constants.HEARTBEAT_TICK` is necessary.', 'commenter': 'beiwei30'}, {'comment': 'I increased the rate of checks to make those free pipes checked as quickly as possible and send heartbeats as quickly as possible.\r\nThat is why I use time/Constants.HEARTBEAT_TICK.', 'commenter': 'carryxyh'}]"
2670,dubbo-serialization/dubbo-serialization-gson/main/java/org/apache/dubbo/common/serialize/gson/GsonSerialization.java,"@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.serialize.gson;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.serialize.ObjectInput;
+import org.apache.dubbo.common.serialize.ObjectOutput;
+import org.apache.dubbo.common.serialize.Serialization;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+/**
+ * Created by cr on 2018/10/23.
+ */
+public class GsonSerialization   implements Serialization {
+
+
+    @Override
+    public byte getContentTypeId() {
+        return 26;
+    }
+
+    @Override
+    public String getContentType() {
+        return ""text/json"";","[{'comment': 'seems it should be `gson` instead of `json`?', 'commenter': 'kun-song'}, {'comment': 'already fix   ""text/gson""    , why this  commit  build failed???         please tell me ', 'commenter': 'a2833986889'}]"
2670,dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/gson/GsonJsonObjectInputTest.java,"@@ -0,0 +1,145 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.serialize.gson;
+
+import com.google.gson.JsonObject;
+import org.apache.dubbo.common.serialize.model.Person;
+import org.junit.Test;
+import java.io.ByteArrayInputStream;
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.StringReader;
+import static org.hamcrest.CoreMatchers.not;
+import static org.hamcrest.CoreMatchers.nullValue;
+import static org.hamcrest.core.Is.is;
+import static org.junit.Assert.assertThat;
+
+public class GsonJsonObjectInputTest {","[{'comment': 'We should use the common unit test for all serialization implementations.', 'commenter': 'kun-song'}, {'comment': 'GsonJsonObjectInputTest  test same as FastJsonObjectInputTest   ,please compare~', 'commenter': 'a2833986889'}]"
2676,dubbo-config/dubbo-config-spring/src/main/resources/META-INF/compat/dubbo.xsd,"@@ -1153,31 +1153,6 @@
         </xsd:complexContent>
     </xsd:complexType>
 
-    <xsd:complexType name=""annotationType"">","[{'comment': 'why remove it from compat xsd? I think we cannot remove AnnotationBean, instead, it should be moved into compat package', 'commenter': 'beiwei30'}, {'comment': 'I think `AnnotationBean` has been completely replaced by @EnableDubbo and @DubboComponentScan, so everything related to `AnnotationBean` can be removed now.\r\n\r\nWe need @mercyblitz to confirm if the new mechanism can work without AnnotationBean.', 'commenter': 'chickenlj'}, {'comment': 'This schema file could be removed safely', 'commenter': 'mercyblitz'}]"
2681,dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/Inject.java,"@@ -0,0 +1,30 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.alibaba.dubbo.common.extension;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.TYPE, ElementType.METHOD})
+public @interface Inject {
+    boolean autoinject() default true;","[{'comment': 'should it be `autoInject`?', 'commenter': 'htynkn'}, {'comment': ""Since Dubbo's default behavior is always injecting on setter, why don't we name this annotation as `@DisableInject`?"", 'commenter': 'beiwei30'}, {'comment': 'Changed to `@DisableInject`.', 'commenter': 'chickenlj'}]"
2681,dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/DisableInject.java,"@@ -0,0 +1,30 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.alibaba.dubbo.common.extension;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.TYPE, ElementType.METHOD})
+public @interface DisableInject {
+    boolean disable() default true;","[{'comment': 'I think an marker annotation should work fine, no need to introduce `disable`. what do you think?', 'commenter': 'beiwei30'}, {'comment': 'Good point, `disable` removed.', 'commenter': 'chickenlj'}]"
2687,dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/context/annotation/DubboConfigBindingRegistrar.java,"@@ -85,7 +86,7 @@ private void registerDubboConfigBeans(String prefix,
                                           boolean multiple,
                                           BeanDefinitionRegistry registry) {
 
-        Map<String, String> properties = getSubProperties(environment.getPropertySources(), prefix);
+        Map<String, Object> properties = getSubProperties(environment.getPropertySources(), prefix);","[{'comment': 'why modify type?', 'commenter': 'kimmking'}, {'comment': ""It's better for binding, `PropertySource` and `PropertyValue` both depend on `Map<String,Object>`"", 'commenter': 'mercyblitz'}]"
2687,dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/beans/factory/annotation/AbstractAnnotationConfigBeanBuilder.java,"@@ -30,8 +30,8 @@
 import java.lang.annotation.Annotation;
 import java.util.List;
 
-import static com.alibaba.dubbo.config.spring.util.BeanFactoryUtils.getBeans;
-import static com.alibaba.dubbo.config.spring.util.BeanFactoryUtils.getOptionalBean;
+import static com.alibaba.spring.util.BeanFactoryUtils.getBeans;
+import static com.alibaba.spring.util.BeanFactoryUtils.getOptionalBean;","[{'comment': ""is it possible to not depend on alibaba's spring-context-support, or consider to directly include its source in Dubbo."", 'commenter': 'beiwei30'}]"
2688,dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java,"@@ -537,17 +537,17 @@
 
     public static final String ON_DISCONNECT_KEY = ""ondisconnect"";
 
-    public static final String ON_INVOKE_METHOD_KEY = ""oninvoke.method"";
+    public static final String ON_INVOKE_METHOD_KEY = ""oninvokeMethod"";","[{'comment': ""I think the original value is more reasonable since it's used in URL."", 'commenter': 'beiwei30'}, {'comment': 'agree with beiwei30', 'commenter': 'chickenlj'}, {'comment': 'Actually, those constants value is not references any more. Formerly, it was used for the mapping between annatation of parameter and the key of Map. Now, this mapping is no need any more.', 'commenter': 'Jeff-Lv'}]"
2688,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java,"@@ -1,487 +1,535 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.extension.ExtensionLoader;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.CollectionUtils;
-import org.apache.dubbo.common.utils.ConfigUtils;
-import org.apache.dubbo.common.utils.ReflectUtils;
-import org.apache.dubbo.common.utils.StringUtils;
-import org.apache.dubbo.config.support.Parameter;
-
-import java.io.Serializable;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * Utility methods and public methods for parsing configuration
- *
- * @export
- */
-public abstract class AbstractConfig implements Serializable {
-
-    protected static final Logger logger = LoggerFactory.getLogger(AbstractConfig.class);
-    private static final long serialVersionUID = 4267533505537413570L;
-    private static final int MAX_LENGTH = 200;
-
-    private static final int MAX_PATH_LENGTH = 200;
-
-    private static final Pattern PATTERN_NAME = Pattern.compile(""[\\-._0-9a-zA-Z]+"");
-
-    private static final Pattern PATTERN_MULTI_NAME = Pattern.compile(""[,\\-._0-9a-zA-Z]+"");
-
-    private static final Pattern PATTERN_METHOD_NAME = Pattern.compile(""[a-zA-Z][0-9a-zA-Z]*"");
-
-    private static final Pattern PATTERN_PATH = Pattern.compile(""[/\\-$._0-9a-zA-Z]+"");
-
-    private static final Pattern PATTERN_NAME_HAS_SYMBOL = Pattern.compile(""[:*,/\\-._0-9a-zA-Z]+"");
-
-    private static final Pattern PATTERN_KEY = Pattern.compile(""[*,\\-._0-9a-zA-Z]+"");
-    private static final Map<String, String> legacyProperties = new HashMap<String, String>();
-    private static final String[] SUFFIXES = new String[]{""Config"", ""Bean""};
-
-    static {
-        legacyProperties.put(""dubbo.protocol.name"", ""dubbo.service.protocol"");
-        legacyProperties.put(""dubbo.protocol.host"", ""dubbo.service.server.host"");
-        legacyProperties.put(""dubbo.protocol.port"", ""dubbo.service.server.port"");
-        legacyProperties.put(""dubbo.protocol.threads"", ""dubbo.service.max.thread.pool.size"");
-        legacyProperties.put(""dubbo.consumer.timeout"", ""dubbo.service.invoke.timeout"");
-        legacyProperties.put(""dubbo.consumer.retries"", ""dubbo.service.max.retry.providers"");
-        legacyProperties.put(""dubbo.consumer.check"", ""dubbo.service.allow.no.provider"");
-        legacyProperties.put(""dubbo.service.url"", ""dubbo.service.address"");
-
-        // this is only for compatibility
-        Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());
-    }
-
-    protected String id;
-
-    private static String convertLegacyValue(String key, String value) {
-        if (value != null && value.length() > 0) {
-            if (""dubbo.service.max.retry.providers"".equals(key)) {
-                return String.valueOf(Integer.parseInt(value) - 1);
-            } else if (""dubbo.service.allow.no.provider"".equals(key)) {
-                return String.valueOf(!Boolean.parseBoolean(value));
-            }
-        }
-        return value;
-    }
-
-    protected static void appendProperties(AbstractConfig config) {
-        if (config == null) {
-            return;
-        }
-        String prefix = ""dubbo."" + getTagName(config.getClass()) + ""."";
-        Method[] methods = config.getClass().getMethods();
-        for (Method method : methods) {
-            try {
-                String name = method.getName();
-                if (name.length() > 3 && name.startsWith(""set"") && Modifier.isPublic(method.getModifiers())
-                        && method.getParameterTypes().length == 1 && isPrimitive(method.getParameterTypes()[0])) {
-                    String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), ""."");
-
-                    String value = null;
-                    if (config.getId() != null && config.getId().length() > 0) {
-                        String pn = prefix + config.getId() + ""."" + property;
-                        value = System.getProperty(pn);
-                        if (!StringUtils.isBlank(value)) {
-                            logger.info(""Use System Property "" + pn + "" to config dubbo"");
-                        }
-                    }
-                    if (value == null || value.length() == 0) {
-                        String pn = prefix + property;
-                        value = System.getProperty(pn);
-                        if (!StringUtils.isBlank(value)) {
-                            logger.info(""Use System Property "" + pn + "" to config dubbo"");
-                        }
-                    }
-                    if (value == null || value.length() == 0) {
-                        Method getter;
-                        try {
-                            getter = config.getClass().getMethod(""get"" + name.substring(3));
-                        } catch (NoSuchMethodException e) {
-                            try {
-                                getter = config.getClass().getMethod(""is"" + name.substring(3));
-                            } catch (NoSuchMethodException e2) {
-                                getter = null;
-                            }
-                        }
-                        if (getter != null) {
-                            if (getter.invoke(config) == null) {
-                                if (config.getId() != null && config.getId().length() > 0) {
-                                    value = ConfigUtils.getProperty(prefix + config.getId() + ""."" + property);
-                                }
-                                if (value == null || value.length() == 0) {
-                                    value = ConfigUtils.getProperty(prefix + property);
-                                }
-                                if (value == null || value.length() == 0) {
-                                    String legacyKey = legacyProperties.get(prefix + property);
-                                    if (legacyKey != null && legacyKey.length() > 0) {
-                                        value = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey));
-                                    }
-                                }
-
-                            }
-                        }
-                    }
-                    if (value != null && value.length() > 0) {
-                        method.invoke(config, convertPrimitive(method.getParameterTypes()[0], value));
-                    }
-                }
-            } catch (Exception e) {
-                logger.error(e.getMessage(), e);
-            }
-        }
-    }
-
-    private static String getTagName(Class<?> cls) {
-        String tag = cls.getSimpleName();
-        for (String suffix : SUFFIXES) {
-            if (tag.endsWith(suffix)) {
-                tag = tag.substring(0, tag.length() - suffix.length());
-                break;
-            }
-        }
-        tag = tag.toLowerCase();
-        return tag;
-    }
-
-    protected static void appendParameters(Map<String, String> parameters, Object config) {
-        appendParameters(parameters, config, null);
-    }
-
-    @SuppressWarnings(""unchecked"")
-    protected static void appendParameters(Map<String, String> parameters, Object config, String prefix) {
-        if (config == null) {
-            return;
-        }
-        Method[] methods = config.getClass().getMethods();
-        for (Method method : methods) {
-            try {
-                String name = method.getName();
-                if ((name.startsWith(""get"") || name.startsWith(""is""))
-                        && !""getClass"".equals(name)
-                        && Modifier.isPublic(method.getModifiers())
-                        && method.getParameterTypes().length == 0
-                        && isPrimitive(method.getReturnType())) {
-                    Parameter parameter = method.getAnnotation(Parameter.class);
-                    if (method.getReturnType() == Object.class || parameter != null && parameter.excluded()) {
-                        continue;
-                    }
-                    int i = name.startsWith(""get"") ? 3 : 2;
-                    String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), ""."");
-                    String key;
-                    if (parameter != null && parameter.key().length() > 0) {
-                        key = parameter.key();
-                    } else {
-                        key = prop;
-                    }
-                    Object value = method.invoke(config);
-                    String str = String.valueOf(value).trim();
-                    if (value != null && str.length() > 0) {
-                        if (parameter != null && parameter.escaped()) {
-                            str = URL.encode(str);
-                        }
-                        if (parameter != null && parameter.append()) {
-                            String pre = parameters.get(Constants.DEFAULT_KEY + ""."" + key);
-                            if (pre != null && pre.length() > 0) {
-                                str = pre + "","" + str;
-                            }
-                            pre = parameters.get(key);
-                            if (pre != null && pre.length() > 0) {
-                                str = pre + "","" + str;
-                            }
-                        }
-                        if (prefix != null && prefix.length() > 0) {
-                            key = prefix + ""."" + key;
-                        }
-                        parameters.put(key, str);
-                    } else if (parameter != null && parameter.required()) {
-                        throw new IllegalStateException(config.getClass().getSimpleName() + ""."" + key + "" == null"");
-                    }
-                } else if (""getParameters"".equals(name)
-                        && Modifier.isPublic(method.getModifiers())
-                        && method.getParameterTypes().length == 0
-                        && method.getReturnType() == Map.class) {
-                    Map<String, String> map = (Map<String, String>) method.invoke(config, new Object[0]);
-                    if (map != null && map.size() > 0) {
-                        String pre = (prefix != null && prefix.length() > 0 ? prefix + ""."" : """");
-                        for (Map.Entry<String, String> entry : map.entrySet()) {
-                            parameters.put(pre + entry.getKey().replace('-', '.'), entry.getValue());
-                        }
-                    }
-                }
-            } catch (Exception e) {
-                throw new IllegalStateException(e.getMessage(), e);
-            }
-        }
-    }
-
-    protected static void appendAttributes(Map<Object, Object> parameters, Object config) {
-        appendAttributes(parameters, config, null);
-    }
-
-    protected static void appendAttributes(Map<Object, Object> parameters, Object config, String prefix) {
-        if (config == null) {
-            return;
-        }
-        Method[] methods = config.getClass().getMethods();
-        for (Method method : methods) {
-            try {
-                String name = method.getName();
-                if ((name.startsWith(""get"") || name.startsWith(""is""))
-                        && !""getClass"".equals(name)
-                        && Modifier.isPublic(method.getModifiers())
-                        && method.getParameterTypes().length == 0
-                        && isPrimitive(method.getReturnType())) {
-                    Parameter parameter = method.getAnnotation(Parameter.class);
-                    if (parameter == null || !parameter.attribute()) {
-                        continue;
-                    }
-                    String key;
-                    if (parameter.key().length() > 0) {
-                        key = parameter.key();
-                    } else {
-                        int i = name.startsWith(""get"") ? 3 : 2;
-                        key = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1);
-                    }
-                    Object value = method.invoke(config);
-                    if (value != null) {
-                        if (prefix != null && prefix.length() > 0) {
-                            key = prefix + ""."" + key;
-                        }
-                        parameters.put(key, value);
-                    }
-                }
-            } catch (Exception e) {
-                throw new IllegalStateException(e.getMessage(), e);
-            }
-        }
-    }
-
-    private static boolean isPrimitive(Class<?> type) {
-        return type.isPrimitive()
-                || type == String.class
-                || type == Character.class
-                || type == Boolean.class
-                || type == Byte.class
-                || type == Short.class
-                || type == Integer.class
-                || type == Long.class
-                || type == Float.class
-                || type == Double.class
-                || type == Object.class;
-    }
-
-    private static Object convertPrimitive(Class<?> type, String value) {
-        if (type == char.class || type == Character.class) {
-            return value.length() > 0 ? value.charAt(0) : '\0';
-        } else if (type == boolean.class || type == Boolean.class) {
-            return Boolean.valueOf(value);
-        } else if (type == byte.class || type == Byte.class) {
-            return Byte.valueOf(value);
-        } else if (type == short.class || type == Short.class) {
-            return Short.valueOf(value);
-        } else if (type == int.class || type == Integer.class) {
-            return Integer.valueOf(value);
-        } else if (type == long.class || type == Long.class) {
-            return Long.valueOf(value);
-        } else if (type == float.class || type == Float.class) {
-            return Float.valueOf(value);
-        } else if (type == double.class || type == Double.class) {
-            return Double.valueOf(value);
-        }
-        return value;
-    }
-
-    protected static void checkExtension(Class<?> type, String property, String value) {
-        checkName(property, value);
-        if (value != null && value.length() > 0
-                && !ExtensionLoader.getExtensionLoader(type).hasExtension(value)) {
-            throw new IllegalStateException(""No such extension "" + value + "" for "" + property + ""/"" + type.getName());
-        }
-    }
-
-    protected static void checkMultiExtension(Class<?> type, String property, String value) {
-        checkMultiName(property, value);
-        if (value != null && value.length() > 0) {
-            String[] values = value.split(""\\s*[,]+\\s*"");
-            for (String v : values) {
-                if (v.startsWith(Constants.REMOVE_VALUE_PREFIX)) {
-                    v = v.substring(1);
-                }
-                if (Constants.DEFAULT_KEY.equals(v)) {
-                    continue;
-                }
-                if (!ExtensionLoader.getExtensionLoader(type).hasExtension(v)) {
-                    throw new IllegalStateException(""No such extension "" + v + "" for "" + property + ""/"" + type.getName());
-                }
-            }
-        }
-    }
-
-    protected static void checkLength(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, null);
-    }
-
-    protected static void checkPathLength(String property, String value) {
-        checkProperty(property, value, MAX_PATH_LENGTH, null);
-    }
-
-    protected static void checkName(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_NAME);
-    }
-
-    protected static void checkNameHasSymbol(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_NAME_HAS_SYMBOL);
-    }
-
-    protected static void checkKey(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_KEY);
-    }
-
-    protected static void checkMultiName(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_MULTI_NAME);
-    }
-
-    protected static void checkPathName(String property, String value) {
-        checkProperty(property, value, MAX_PATH_LENGTH, PATTERN_PATH);
-    }
-
-    protected static void checkMethodName(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_METHOD_NAME);
-    }
-
-    protected static void checkParameterName(Map<String, String> parameters) {
-        if (parameters == null || parameters.size() == 0) {
-            return;
-        }
-        for (Map.Entry<String, String> entry : parameters.entrySet()) {
-            checkNameHasSymbol(entry.getKey(), entry.getValue());
-        }
-    }
-
-    protected static void checkProperty(String property, String value, int maxlength, Pattern pattern) {
-        if (value == null || value.length() == 0) {
-            return;
-        }
-        if (value.length() > maxlength) {
-            throw new IllegalStateException(""Invalid "" + property + ""=\"""" + value + ""\"" is longer than "" + maxlength);
-        }
-        if (pattern != null) {
-            Matcher matcher = pattern.matcher(value);
-            if (!matcher.matches()) {
-                throw new IllegalStateException(""Invalid "" + property + ""=\"""" + value + ""\"" contains illegal "" +
-                        ""character, only digit, letter, '-', '_' or '.' is legal."");
-            }
-        }
-    }
-
-    @Parameter(excluded = true)
-    public String getId() {
-        return id;
-    }
-
-    public void setId(String id) {
-        this.id = id;
-    }
-
-    protected void appendAnnotation(Class<?> annotationClass, Object annotation) {
-        Method[] methods = annotationClass.getMethods();
-        for (Method method : methods) {
-            if (method.getDeclaringClass() != Object.class
-                    && method.getReturnType() != void.class
-                    && method.getParameterTypes().length == 0
-                    && Modifier.isPublic(method.getModifiers())
-                    && !Modifier.isStatic(method.getModifiers())) {
-                try {
-                    String property = method.getName();
-                    if (""interfaceClass"".equals(property) || ""interfaceName"".equals(property)) {
-                        property = ""interface"";
-                    }
-                    String setter = ""set"" + property.substring(0, 1).toUpperCase() + property.substring(1);
-                    Object value = method.invoke(annotation);
-                    if (value != null && !value.equals(method.getDefaultValue())) {
-                        Class<?> parameterType = ReflectUtils.getBoxedClass(method.getReturnType());
-                        if (""filter"".equals(property) || ""listener"".equals(property)) {
-                            parameterType = String.class;
-                            value = StringUtils.join((String[]) value, "","");
-                        } else if (""parameters"".equals(property)) {
-                            parameterType = Map.class;
-                            value = CollectionUtils.toStringMap((String[]) value);
-                        }
-                        try {
-                            Method setterMethod = getClass().getMethod(setter, parameterType);
-                            setterMethod.invoke(this, value);
-                        } catch (NoSuchMethodException e) {
-                            // ignore
-                        }
-                    }
-                } catch (Throwable e) {
-                    logger.error(e.getMessage(), e);
-                }
-            }
-        }
-    }
-
-    @Override
-    public String toString() {
-        try {
-            StringBuilder buf = new StringBuilder();
-            buf.append(""<dubbo:"");
-            buf.append(getTagName(getClass()));
-            Method[] methods = getClass().getMethods();
-            for (Method method : methods) {
-                try {
-                    String name = method.getName();
-                    if ((name.startsWith(""get"") || name.startsWith(""is""))
-                            && !""getClass"".equals(name) && !""get"".equals(name) && !""is"".equals(name)
-                            && Modifier.isPublic(method.getModifiers())
-                            && method.getParameterTypes().length == 0
-                            && isPrimitive(method.getReturnType())) {
-                        int i = name.startsWith(""get"") ? 3 : 2;
-                        String key = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1);
-                        Object value = method.invoke(this);
-                        if (value != null) {
-                            buf.append("" "");
-                            buf.append(key);
-                            buf.append(""=\"""");
-                            buf.append(value);
-                            buf.append(""\"""");
-                        }
-                    }
-                } catch (Exception e) {
-                    logger.warn(e.getMessage(), e);
-                }
-            }
-            buf.append("" />"");
-            return buf.toString();
-        } catch (Throwable t) {
-            logger.warn(t.getMessage(), t);
-            return super.toString();
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.config;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.ConfigUtils;
+import org.apache.dubbo.common.utils.ReflectUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.config.DubboShutdownHook;","[{'comment': 'unused imports.', 'commenter': 'beiwei30'}]"
2688,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java,"@@ -1,487 +1,535 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.extension.ExtensionLoader;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.CollectionUtils;
-import org.apache.dubbo.common.utils.ConfigUtils;
-import org.apache.dubbo.common.utils.ReflectUtils;
-import org.apache.dubbo.common.utils.StringUtils;
-import org.apache.dubbo.config.support.Parameter;
-
-import java.io.Serializable;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * Utility methods and public methods for parsing configuration
- *
- * @export
- */
-public abstract class AbstractConfig implements Serializable {
-
-    protected static final Logger logger = LoggerFactory.getLogger(AbstractConfig.class);
-    private static final long serialVersionUID = 4267533505537413570L;
-    private static final int MAX_LENGTH = 200;
-
-    private static final int MAX_PATH_LENGTH = 200;
-
-    private static final Pattern PATTERN_NAME = Pattern.compile(""[\\-._0-9a-zA-Z]+"");
-
-    private static final Pattern PATTERN_MULTI_NAME = Pattern.compile(""[,\\-._0-9a-zA-Z]+"");
-
-    private static final Pattern PATTERN_METHOD_NAME = Pattern.compile(""[a-zA-Z][0-9a-zA-Z]*"");
-
-    private static final Pattern PATTERN_PATH = Pattern.compile(""[/\\-$._0-9a-zA-Z]+"");
-
-    private static final Pattern PATTERN_NAME_HAS_SYMBOL = Pattern.compile(""[:*,/\\-._0-9a-zA-Z]+"");
-
-    private static final Pattern PATTERN_KEY = Pattern.compile(""[*,\\-._0-9a-zA-Z]+"");
-    private static final Map<String, String> legacyProperties = new HashMap<String, String>();
-    private static final String[] SUFFIXES = new String[]{""Config"", ""Bean""};
-
-    static {
-        legacyProperties.put(""dubbo.protocol.name"", ""dubbo.service.protocol"");
-        legacyProperties.put(""dubbo.protocol.host"", ""dubbo.service.server.host"");
-        legacyProperties.put(""dubbo.protocol.port"", ""dubbo.service.server.port"");
-        legacyProperties.put(""dubbo.protocol.threads"", ""dubbo.service.max.thread.pool.size"");
-        legacyProperties.put(""dubbo.consumer.timeout"", ""dubbo.service.invoke.timeout"");
-        legacyProperties.put(""dubbo.consumer.retries"", ""dubbo.service.max.retry.providers"");
-        legacyProperties.put(""dubbo.consumer.check"", ""dubbo.service.allow.no.provider"");
-        legacyProperties.put(""dubbo.service.url"", ""dubbo.service.address"");
-
-        // this is only for compatibility
-        Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());
-    }
-
-    protected String id;
-
-    private static String convertLegacyValue(String key, String value) {
-        if (value != null && value.length() > 0) {
-            if (""dubbo.service.max.retry.providers"".equals(key)) {
-                return String.valueOf(Integer.parseInt(value) - 1);
-            } else if (""dubbo.service.allow.no.provider"".equals(key)) {
-                return String.valueOf(!Boolean.parseBoolean(value));
-            }
-        }
-        return value;
-    }
-
-    protected static void appendProperties(AbstractConfig config) {
-        if (config == null) {
-            return;
-        }
-        String prefix = ""dubbo."" + getTagName(config.getClass()) + ""."";
-        Method[] methods = config.getClass().getMethods();
-        for (Method method : methods) {
-            try {
-                String name = method.getName();
-                if (name.length() > 3 && name.startsWith(""set"") && Modifier.isPublic(method.getModifiers())
-                        && method.getParameterTypes().length == 1 && isPrimitive(method.getParameterTypes()[0])) {
-                    String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), ""."");
-
-                    String value = null;
-                    if (config.getId() != null && config.getId().length() > 0) {
-                        String pn = prefix + config.getId() + ""."" + property;
-                        value = System.getProperty(pn);
-                        if (!StringUtils.isBlank(value)) {
-                            logger.info(""Use System Property "" + pn + "" to config dubbo"");
-                        }
-                    }
-                    if (value == null || value.length() == 0) {
-                        String pn = prefix + property;
-                        value = System.getProperty(pn);
-                        if (!StringUtils.isBlank(value)) {
-                            logger.info(""Use System Property "" + pn + "" to config dubbo"");
-                        }
-                    }
-                    if (value == null || value.length() == 0) {
-                        Method getter;
-                        try {
-                            getter = config.getClass().getMethod(""get"" + name.substring(3));
-                        } catch (NoSuchMethodException e) {
-                            try {
-                                getter = config.getClass().getMethod(""is"" + name.substring(3));
-                            } catch (NoSuchMethodException e2) {
-                                getter = null;
-                            }
-                        }
-                        if (getter != null) {
-                            if (getter.invoke(config) == null) {
-                                if (config.getId() != null && config.getId().length() > 0) {
-                                    value = ConfigUtils.getProperty(prefix + config.getId() + ""."" + property);
-                                }
-                                if (value == null || value.length() == 0) {
-                                    value = ConfigUtils.getProperty(prefix + property);
-                                }
-                                if (value == null || value.length() == 0) {
-                                    String legacyKey = legacyProperties.get(prefix + property);
-                                    if (legacyKey != null && legacyKey.length() > 0) {
-                                        value = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey));
-                                    }
-                                }
-
-                            }
-                        }
-                    }
-                    if (value != null && value.length() > 0) {
-                        method.invoke(config, convertPrimitive(method.getParameterTypes()[0], value));
-                    }
-                }
-            } catch (Exception e) {
-                logger.error(e.getMessage(), e);
-            }
-        }
-    }
-
-    private static String getTagName(Class<?> cls) {
-        String tag = cls.getSimpleName();
-        for (String suffix : SUFFIXES) {
-            if (tag.endsWith(suffix)) {
-                tag = tag.substring(0, tag.length() - suffix.length());
-                break;
-            }
-        }
-        tag = tag.toLowerCase();
-        return tag;
-    }
-
-    protected static void appendParameters(Map<String, String> parameters, Object config) {
-        appendParameters(parameters, config, null);
-    }
-
-    @SuppressWarnings(""unchecked"")
-    protected static void appendParameters(Map<String, String> parameters, Object config, String prefix) {
-        if (config == null) {
-            return;
-        }
-        Method[] methods = config.getClass().getMethods();
-        for (Method method : methods) {
-            try {
-                String name = method.getName();
-                if ((name.startsWith(""get"") || name.startsWith(""is""))
-                        && !""getClass"".equals(name)
-                        && Modifier.isPublic(method.getModifiers())
-                        && method.getParameterTypes().length == 0
-                        && isPrimitive(method.getReturnType())) {
-                    Parameter parameter = method.getAnnotation(Parameter.class);
-                    if (method.getReturnType() == Object.class || parameter != null && parameter.excluded()) {
-                        continue;
-                    }
-                    int i = name.startsWith(""get"") ? 3 : 2;
-                    String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), ""."");
-                    String key;
-                    if (parameter != null && parameter.key().length() > 0) {
-                        key = parameter.key();
-                    } else {
-                        key = prop;
-                    }
-                    Object value = method.invoke(config);
-                    String str = String.valueOf(value).trim();
-                    if (value != null && str.length() > 0) {
-                        if (parameter != null && parameter.escaped()) {
-                            str = URL.encode(str);
-                        }
-                        if (parameter != null && parameter.append()) {
-                            String pre = parameters.get(Constants.DEFAULT_KEY + ""."" + key);
-                            if (pre != null && pre.length() > 0) {
-                                str = pre + "","" + str;
-                            }
-                            pre = parameters.get(key);
-                            if (pre != null && pre.length() > 0) {
-                                str = pre + "","" + str;
-                            }
-                        }
-                        if (prefix != null && prefix.length() > 0) {
-                            key = prefix + ""."" + key;
-                        }
-                        parameters.put(key, str);
-                    } else if (parameter != null && parameter.required()) {
-                        throw new IllegalStateException(config.getClass().getSimpleName() + ""."" + key + "" == null"");
-                    }
-                } else if (""getParameters"".equals(name)
-                        && Modifier.isPublic(method.getModifiers())
-                        && method.getParameterTypes().length == 0
-                        && method.getReturnType() == Map.class) {
-                    Map<String, String> map = (Map<String, String>) method.invoke(config, new Object[0]);
-                    if (map != null && map.size() > 0) {
-                        String pre = (prefix != null && prefix.length() > 0 ? prefix + ""."" : """");
-                        for (Map.Entry<String, String> entry : map.entrySet()) {
-                            parameters.put(pre + entry.getKey().replace('-', '.'), entry.getValue());
-                        }
-                    }
-                }
-            } catch (Exception e) {
-                throw new IllegalStateException(e.getMessage(), e);
-            }
-        }
-    }
-
-    protected static void appendAttributes(Map<Object, Object> parameters, Object config) {
-        appendAttributes(parameters, config, null);
-    }
-
-    protected static void appendAttributes(Map<Object, Object> parameters, Object config, String prefix) {
-        if (config == null) {
-            return;
-        }
-        Method[] methods = config.getClass().getMethods();
-        for (Method method : methods) {
-            try {
-                String name = method.getName();
-                if ((name.startsWith(""get"") || name.startsWith(""is""))
-                        && !""getClass"".equals(name)
-                        && Modifier.isPublic(method.getModifiers())
-                        && method.getParameterTypes().length == 0
-                        && isPrimitive(method.getReturnType())) {
-                    Parameter parameter = method.getAnnotation(Parameter.class);
-                    if (parameter == null || !parameter.attribute()) {
-                        continue;
-                    }
-                    String key;
-                    if (parameter.key().length() > 0) {
-                        key = parameter.key();
-                    } else {
-                        int i = name.startsWith(""get"") ? 3 : 2;
-                        key = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1);
-                    }
-                    Object value = method.invoke(config);
-                    if (value != null) {
-                        if (prefix != null && prefix.length() > 0) {
-                            key = prefix + ""."" + key;
-                        }
-                        parameters.put(key, value);
-                    }
-                }
-            } catch (Exception e) {
-                throw new IllegalStateException(e.getMessage(), e);
-            }
-        }
-    }
-
-    private static boolean isPrimitive(Class<?> type) {
-        return type.isPrimitive()
-                || type == String.class
-                || type == Character.class
-                || type == Boolean.class
-                || type == Byte.class
-                || type == Short.class
-                || type == Integer.class
-                || type == Long.class
-                || type == Float.class
-                || type == Double.class
-                || type == Object.class;
-    }
-
-    private static Object convertPrimitive(Class<?> type, String value) {
-        if (type == char.class || type == Character.class) {
-            return value.length() > 0 ? value.charAt(0) : '\0';
-        } else if (type == boolean.class || type == Boolean.class) {
-            return Boolean.valueOf(value);
-        } else if (type == byte.class || type == Byte.class) {
-            return Byte.valueOf(value);
-        } else if (type == short.class || type == Short.class) {
-            return Short.valueOf(value);
-        } else if (type == int.class || type == Integer.class) {
-            return Integer.valueOf(value);
-        } else if (type == long.class || type == Long.class) {
-            return Long.valueOf(value);
-        } else if (type == float.class || type == Float.class) {
-            return Float.valueOf(value);
-        } else if (type == double.class || type == Double.class) {
-            return Double.valueOf(value);
-        }
-        return value;
-    }
-
-    protected static void checkExtension(Class<?> type, String property, String value) {
-        checkName(property, value);
-        if (value != null && value.length() > 0
-                && !ExtensionLoader.getExtensionLoader(type).hasExtension(value)) {
-            throw new IllegalStateException(""No such extension "" + value + "" for "" + property + ""/"" + type.getName());
-        }
-    }
-
-    protected static void checkMultiExtension(Class<?> type, String property, String value) {
-        checkMultiName(property, value);
-        if (value != null && value.length() > 0) {
-            String[] values = value.split(""\\s*[,]+\\s*"");
-            for (String v : values) {
-                if (v.startsWith(Constants.REMOVE_VALUE_PREFIX)) {
-                    v = v.substring(1);
-                }
-                if (Constants.DEFAULT_KEY.equals(v)) {
-                    continue;
-                }
-                if (!ExtensionLoader.getExtensionLoader(type).hasExtension(v)) {
-                    throw new IllegalStateException(""No such extension "" + v + "" for "" + property + ""/"" + type.getName());
-                }
-            }
-        }
-    }
-
-    protected static void checkLength(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, null);
-    }
-
-    protected static void checkPathLength(String property, String value) {
-        checkProperty(property, value, MAX_PATH_LENGTH, null);
-    }
-
-    protected static void checkName(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_NAME);
-    }
-
-    protected static void checkNameHasSymbol(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_NAME_HAS_SYMBOL);
-    }
-
-    protected static void checkKey(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_KEY);
-    }
-
-    protected static void checkMultiName(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_MULTI_NAME);
-    }
-
-    protected static void checkPathName(String property, String value) {
-        checkProperty(property, value, MAX_PATH_LENGTH, PATTERN_PATH);
-    }
-
-    protected static void checkMethodName(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_METHOD_NAME);
-    }
-
-    protected static void checkParameterName(Map<String, String> parameters) {
-        if (parameters == null || parameters.size() == 0) {
-            return;
-        }
-        for (Map.Entry<String, String> entry : parameters.entrySet()) {
-            checkNameHasSymbol(entry.getKey(), entry.getValue());
-        }
-    }
-
-    protected static void checkProperty(String property, String value, int maxlength, Pattern pattern) {
-        if (value == null || value.length() == 0) {
-            return;
-        }
-        if (value.length() > maxlength) {
-            throw new IllegalStateException(""Invalid "" + property + ""=\"""" + value + ""\"" is longer than "" + maxlength);
-        }
-        if (pattern != null) {
-            Matcher matcher = pattern.matcher(value);
-            if (!matcher.matches()) {
-                throw new IllegalStateException(""Invalid "" + property + ""=\"""" + value + ""\"" contains illegal "" +
-                        ""character, only digit, letter, '-', '_' or '.' is legal."");
-            }
-        }
-    }
-
-    @Parameter(excluded = true)
-    public String getId() {
-        return id;
-    }
-
-    public void setId(String id) {
-        this.id = id;
-    }
-
-    protected void appendAnnotation(Class<?> annotationClass, Object annotation) {
-        Method[] methods = annotationClass.getMethods();
-        for (Method method : methods) {
-            if (method.getDeclaringClass() != Object.class
-                    && method.getReturnType() != void.class
-                    && method.getParameterTypes().length == 0
-                    && Modifier.isPublic(method.getModifiers())
-                    && !Modifier.isStatic(method.getModifiers())) {
-                try {
-                    String property = method.getName();
-                    if (""interfaceClass"".equals(property) || ""interfaceName"".equals(property)) {
-                        property = ""interface"";
-                    }
-                    String setter = ""set"" + property.substring(0, 1).toUpperCase() + property.substring(1);
-                    Object value = method.invoke(annotation);
-                    if (value != null && !value.equals(method.getDefaultValue())) {
-                        Class<?> parameterType = ReflectUtils.getBoxedClass(method.getReturnType());
-                        if (""filter"".equals(property) || ""listener"".equals(property)) {
-                            parameterType = String.class;
-                            value = StringUtils.join((String[]) value, "","");
-                        } else if (""parameters"".equals(property)) {
-                            parameterType = Map.class;
-                            value = CollectionUtils.toStringMap((String[]) value);
-                        }
-                        try {
-                            Method setterMethod = getClass().getMethod(setter, parameterType);
-                            setterMethod.invoke(this, value);
-                        } catch (NoSuchMethodException e) {
-                            // ignore
-                        }
-                    }
-                } catch (Throwable e) {
-                    logger.error(e.getMessage(), e);
-                }
-            }
-        }
-    }
-
-    @Override
-    public String toString() {
-        try {
-            StringBuilder buf = new StringBuilder();
-            buf.append(""<dubbo:"");
-            buf.append(getTagName(getClass()));
-            Method[] methods = getClass().getMethods();
-            for (Method method : methods) {
-                try {
-                    String name = method.getName();
-                    if ((name.startsWith(""get"") || name.startsWith(""is""))
-                            && !""getClass"".equals(name) && !""get"".equals(name) && !""is"".equals(name)
-                            && Modifier.isPublic(method.getModifiers())
-                            && method.getParameterTypes().length == 0
-                            && isPrimitive(method.getReturnType())) {
-                        int i = name.startsWith(""get"") ? 3 : 2;
-                        String key = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1);
-                        Object value = method.invoke(this);
-                        if (value != null) {
-                            buf.append("" "");
-                            buf.append(key);
-                            buf.append(""=\"""");
-                            buf.append(value);
-                            buf.append(""\"""");
-                        }
-                    }
-                } catch (Exception e) {
-                    logger.warn(e.getMessage(), e);
-                }
-            }
-            buf.append("" />"");
-            return buf.toString();
-        } catch (Throwable t) {
-            logger.warn(t.getMessage(), t);
-            return super.toString();
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.config;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.ConfigUtils;
+import org.apache.dubbo.common.utils.ReflectUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.config.DubboShutdownHook;
+import org.apache.dubbo.config.MethodConfig;
+import org.apache.dubbo.config.support.Parameter;
+import org.apache.dubbo.rpc.model.ConsumerMethodModel;
+
+import java.io.Serializable;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Utility methods and public methods for parsing configuration
+ *
+ * @export
+ */
+public abstract class AbstractConfig implements Serializable {
+
+    protected static final Logger logger = LoggerFactory.getLogger(AbstractConfig.class);
+    private static final long serialVersionUID = 4267533505537413570L;
+    private static final int MAX_LENGTH = 200;
+
+    private static final int MAX_PATH_LENGTH = 200;
+
+    private static final Pattern PATTERN_NAME = Pattern.compile(""[\\-._0-9a-zA-Z]+"");
+
+    private static final Pattern PATTERN_MULTI_NAME = Pattern.compile(""[,\\-._0-9a-zA-Z]+"");
+
+    private static final Pattern PATTERN_METHOD_NAME = Pattern.compile(""[a-zA-Z][0-9a-zA-Z]*"");
+
+    private static final Pattern PATTERN_PATH = Pattern.compile(""[/\\-$._0-9a-zA-Z]+"");
+
+    private static final Pattern PATTERN_NAME_HAS_SYMBOL = Pattern.compile(""[:*,/\\-._0-9a-zA-Z]+"");
+
+    private static final Pattern PATTERN_KEY = Pattern.compile(""[*,\\-._0-9a-zA-Z]+"");
+    private static final Map<String, String> legacyProperties = new HashMap<String, String>();
+    private static final String[] SUFFIXES = new String[]{""Config"", ""Bean""};
+
+    static {
+        legacyProperties.put(""dubbo.protocol.name"", ""dubbo.service.protocol"");
+        legacyProperties.put(""dubbo.protocol.host"", ""dubbo.service.server.host"");
+        legacyProperties.put(""dubbo.protocol.port"", ""dubbo.service.server.port"");
+        legacyProperties.put(""dubbo.protocol.threads"", ""dubbo.service.max.thread.pool.size"");
+        legacyProperties.put(""dubbo.consumer.timeout"", ""dubbo.service.invoke.timeout"");
+        legacyProperties.put(""dubbo.consumer.retries"", ""dubbo.service.max.retry.providers"");
+        legacyProperties.put(""dubbo.consumer.check"", ""dubbo.service.allow.no.provider"");
+        legacyProperties.put(""dubbo.service.url"", ""dubbo.service.address"");
+
+        // this is only for compatibility
+        Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());
+    }
+
+    protected String id;
+
+    private static String convertLegacyValue(String key, String value) {
+        if (value != null && value.length() > 0) {
+            if (""dubbo.service.max.retry.providers"".equals(key)) {
+                return String.valueOf(Integer.parseInt(value) - 1);
+            } else if (""dubbo.service.allow.no.provider"".equals(key)) {
+                return String.valueOf(!Boolean.parseBoolean(value));
+            }
+        }
+        return value;
+    }
+
+    protected static void appendProperties(AbstractConfig config) {
+        if (config == null) {
+            return;
+        }
+        String prefix = ""dubbo."" + getTagName(config.getClass()) + ""."";
+        Method[] methods = config.getClass().getMethods();
+        for (Method method : methods) {
+            try {
+                String name = method.getName();
+                if (name.length() > 3 && name.startsWith(""set"") && Modifier.isPublic(method.getModifiers())
+                        && method.getParameterTypes().length == 1 && isPrimitive(method.getParameterTypes()[0])) {
+                    String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), ""."");
+
+                    String value = null;
+                    if (config.getId() != null && config.getId().length() > 0) {
+                        String pn = prefix + config.getId() + ""."" + property;
+                        value = System.getProperty(pn);
+                        if (!StringUtils.isBlank(value)) {
+                            logger.info(""Use System Property "" + pn + "" to config dubbo"");
+                        }
+                    }
+                    if (value == null || value.length() == 0) {
+                        String pn = prefix + property;
+                        value = System.getProperty(pn);
+                        if (!StringUtils.isBlank(value)) {
+                            logger.info(""Use System Property "" + pn + "" to config dubbo"");
+                        }
+                    }
+                    if (value == null || value.length() == 0) {
+                        Method getter;
+                        try {
+                            getter = config.getClass().getMethod(""get"" + name.substring(3));
+                        } catch (NoSuchMethodException e) {
+                            try {
+                                getter = config.getClass().getMethod(""is"" + name.substring(3));
+                            } catch (NoSuchMethodException e2) {
+                                getter = null;
+                            }
+                        }
+                        if (getter != null) {
+                            if (getter.invoke(config) == null) {
+                                if (config.getId() != null && config.getId().length() > 0) {
+                                    value = ConfigUtils.getProperty(prefix + config.getId() + ""."" + property);
+                                }
+                                if (value == null || value.length() == 0) {
+                                    value = ConfigUtils.getProperty(prefix + property);
+                                }
+                                if (value == null || value.length() == 0) {
+                                    String legacyKey = legacyProperties.get(prefix + property);
+                                    if (legacyKey != null && legacyKey.length() > 0) {
+                                        value = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey));
+                                    }
+                                }
+
+                            }
+                        }
+                    }
+                    if (value != null && value.length() > 0) {
+                        method.invoke(config, convertPrimitive(method.getParameterTypes()[0], value));
+                    }
+                }
+            } catch (Exception e) {
+                logger.error(e.getMessage(), e);
+            }
+        }
+    }
+
+    private static String getTagName(Class<?> cls) {
+        String tag = cls.getSimpleName();
+        for (String suffix : SUFFIXES) {
+            if (tag.endsWith(suffix)) {
+                tag = tag.substring(0, tag.length() - suffix.length());
+                break;
+            }
+        }
+        tag = tag.toLowerCase();
+        return tag;
+    }
+
+    protected static void appendParameters(Map<String, String> parameters, Object config) {
+        appendParameters(parameters, config, null);
+    }
+
+    @SuppressWarnings(""unchecked"")
+    protected static void appendParameters(Map<String, String> parameters, Object config, String prefix) {
+        if (config == null) {
+            return;
+        }
+        Method[] methods = config.getClass().getMethods();
+        for (Method method : methods) {
+            try {
+                String name = method.getName();
+                if ((name.startsWith(""get"") || name.startsWith(""is""))
+                        && !""getClass"".equals(name)
+                        && Modifier.isPublic(method.getModifiers())
+                        && method.getParameterTypes().length == 0
+                        && isPrimitive(method.getReturnType())) {
+                    Parameter parameter = method.getAnnotation(Parameter.class);
+                    if (method.getReturnType() == Object.class || parameter != null && parameter.excluded()) {
+                        continue;
+                    }
+                    int i = name.startsWith(""get"") ? 3 : 2;
+                    String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), ""."");
+                    String key;
+                    if (parameter != null && parameter.key().length() > 0) {
+                        key = parameter.key();
+                    } else {
+                        key = prop;
+                    }
+                    Object value = method.invoke(config);
+                    String str = String.valueOf(value).trim();
+                    if (value != null && str.length() > 0) {
+                        if (parameter != null && parameter.escaped()) {
+                            str = URL.encode(str);
+                        }
+                        if (parameter != null && parameter.append()) {
+                            String pre = parameters.get(Constants.DEFAULT_KEY + ""."" + key);
+                            if (pre != null && pre.length() > 0) {
+                                str = pre + "","" + str;
+                            }
+                            pre = parameters.get(key);
+                            if (pre != null && pre.length() > 0) {
+                                str = pre + "","" + str;
+                            }
+                        }
+                        if (prefix != null && prefix.length() > 0) {
+                            key = prefix + ""."" + key;
+                        }
+                        parameters.put(key, str);
+                    } else if (parameter != null && parameter.required()) {
+                        throw new IllegalStateException(config.getClass().getSimpleName() + ""."" + key + "" == null"");
+                    }
+                } else if (""getParameters"".equals(name)
+                        && Modifier.isPublic(method.getModifiers())
+                        && method.getParameterTypes().length == 0
+                        && method.getReturnType() == Map.class) {
+                    Map<String, String> map = (Map<String, String>) method.invoke(config, new Object[0]);
+                    if (map != null && map.size() > 0) {
+                        String pre = (prefix != null && prefix.length() > 0 ? prefix + ""."" : """");
+                        for (Map.Entry<String, String> entry : map.entrySet()) {
+                            parameters.put(pre + entry.getKey().replace('-', '.'), entry.getValue());
+                        }
+                    }
+                }
+            } catch (Exception e) {
+                throw new IllegalStateException(e.getMessage(), e);
+            }
+        }
+    }
+
+    protected static void appendAttributes(Map<String, Object> parameters, Object config) {
+        appendAttributes(parameters, config, null);
+    }
+
+    protected static void appendAttributes(Map<String, Object> parameters, Object config, String prefix) {
+        if (config == null) {
+            return;
+        }
+        Method[] methods = config.getClass().getMethods();
+        for (Method method : methods) {
+            try {
+                Parameter parameter = method.getAnnotation(Parameter.class);
+                if (parameter == null || !parameter.attribute())","[{'comment': 'pls. use `{...}`', 'commenter': 'beiwei30'}]"
2688,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java,"@@ -1,487 +1,535 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.extension.ExtensionLoader;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.CollectionUtils;
-import org.apache.dubbo.common.utils.ConfigUtils;
-import org.apache.dubbo.common.utils.ReflectUtils;
-import org.apache.dubbo.common.utils.StringUtils;
-import org.apache.dubbo.config.support.Parameter;
-
-import java.io.Serializable;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * Utility methods and public methods for parsing configuration
- *
- * @export
- */
-public abstract class AbstractConfig implements Serializable {
-
-    protected static final Logger logger = LoggerFactory.getLogger(AbstractConfig.class);
-    private static final long serialVersionUID = 4267533505537413570L;
-    private static final int MAX_LENGTH = 200;
-
-    private static final int MAX_PATH_LENGTH = 200;
-
-    private static final Pattern PATTERN_NAME = Pattern.compile(""[\\-._0-9a-zA-Z]+"");
-
-    private static final Pattern PATTERN_MULTI_NAME = Pattern.compile(""[,\\-._0-9a-zA-Z]+"");
-
-    private static final Pattern PATTERN_METHOD_NAME = Pattern.compile(""[a-zA-Z][0-9a-zA-Z]*"");
-
-    private static final Pattern PATTERN_PATH = Pattern.compile(""[/\\-$._0-9a-zA-Z]+"");
-
-    private static final Pattern PATTERN_NAME_HAS_SYMBOL = Pattern.compile(""[:*,/\\-._0-9a-zA-Z]+"");
-
-    private static final Pattern PATTERN_KEY = Pattern.compile(""[*,\\-._0-9a-zA-Z]+"");
-    private static final Map<String, String> legacyProperties = new HashMap<String, String>();
-    private static final String[] SUFFIXES = new String[]{""Config"", ""Bean""};
-
-    static {
-        legacyProperties.put(""dubbo.protocol.name"", ""dubbo.service.protocol"");
-        legacyProperties.put(""dubbo.protocol.host"", ""dubbo.service.server.host"");
-        legacyProperties.put(""dubbo.protocol.port"", ""dubbo.service.server.port"");
-        legacyProperties.put(""dubbo.protocol.threads"", ""dubbo.service.max.thread.pool.size"");
-        legacyProperties.put(""dubbo.consumer.timeout"", ""dubbo.service.invoke.timeout"");
-        legacyProperties.put(""dubbo.consumer.retries"", ""dubbo.service.max.retry.providers"");
-        legacyProperties.put(""dubbo.consumer.check"", ""dubbo.service.allow.no.provider"");
-        legacyProperties.put(""dubbo.service.url"", ""dubbo.service.address"");
-
-        // this is only for compatibility
-        Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());
-    }
-
-    protected String id;
-
-    private static String convertLegacyValue(String key, String value) {
-        if (value != null && value.length() > 0) {
-            if (""dubbo.service.max.retry.providers"".equals(key)) {
-                return String.valueOf(Integer.parseInt(value) - 1);
-            } else if (""dubbo.service.allow.no.provider"".equals(key)) {
-                return String.valueOf(!Boolean.parseBoolean(value));
-            }
-        }
-        return value;
-    }
-
-    protected static void appendProperties(AbstractConfig config) {
-        if (config == null) {
-            return;
-        }
-        String prefix = ""dubbo."" + getTagName(config.getClass()) + ""."";
-        Method[] methods = config.getClass().getMethods();
-        for (Method method : methods) {
-            try {
-                String name = method.getName();
-                if (name.length() > 3 && name.startsWith(""set"") && Modifier.isPublic(method.getModifiers())
-                        && method.getParameterTypes().length == 1 && isPrimitive(method.getParameterTypes()[0])) {
-                    String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), ""."");
-
-                    String value = null;
-                    if (config.getId() != null && config.getId().length() > 0) {
-                        String pn = prefix + config.getId() + ""."" + property;
-                        value = System.getProperty(pn);
-                        if (!StringUtils.isBlank(value)) {
-                            logger.info(""Use System Property "" + pn + "" to config dubbo"");
-                        }
-                    }
-                    if (value == null || value.length() == 0) {
-                        String pn = prefix + property;
-                        value = System.getProperty(pn);
-                        if (!StringUtils.isBlank(value)) {
-                            logger.info(""Use System Property "" + pn + "" to config dubbo"");
-                        }
-                    }
-                    if (value == null || value.length() == 0) {
-                        Method getter;
-                        try {
-                            getter = config.getClass().getMethod(""get"" + name.substring(3));
-                        } catch (NoSuchMethodException e) {
-                            try {
-                                getter = config.getClass().getMethod(""is"" + name.substring(3));
-                            } catch (NoSuchMethodException e2) {
-                                getter = null;
-                            }
-                        }
-                        if (getter != null) {
-                            if (getter.invoke(config) == null) {
-                                if (config.getId() != null && config.getId().length() > 0) {
-                                    value = ConfigUtils.getProperty(prefix + config.getId() + ""."" + property);
-                                }
-                                if (value == null || value.length() == 0) {
-                                    value = ConfigUtils.getProperty(prefix + property);
-                                }
-                                if (value == null || value.length() == 0) {
-                                    String legacyKey = legacyProperties.get(prefix + property);
-                                    if (legacyKey != null && legacyKey.length() > 0) {
-                                        value = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey));
-                                    }
-                                }
-
-                            }
-                        }
-                    }
-                    if (value != null && value.length() > 0) {
-                        method.invoke(config, convertPrimitive(method.getParameterTypes()[0], value));
-                    }
-                }
-            } catch (Exception e) {
-                logger.error(e.getMessage(), e);
-            }
-        }
-    }
-
-    private static String getTagName(Class<?> cls) {
-        String tag = cls.getSimpleName();
-        for (String suffix : SUFFIXES) {
-            if (tag.endsWith(suffix)) {
-                tag = tag.substring(0, tag.length() - suffix.length());
-                break;
-            }
-        }
-        tag = tag.toLowerCase();
-        return tag;
-    }
-
-    protected static void appendParameters(Map<String, String> parameters, Object config) {
-        appendParameters(parameters, config, null);
-    }
-
-    @SuppressWarnings(""unchecked"")
-    protected static void appendParameters(Map<String, String> parameters, Object config, String prefix) {
-        if (config == null) {
-            return;
-        }
-        Method[] methods = config.getClass().getMethods();
-        for (Method method : methods) {
-            try {
-                String name = method.getName();
-                if ((name.startsWith(""get"") || name.startsWith(""is""))
-                        && !""getClass"".equals(name)
-                        && Modifier.isPublic(method.getModifiers())
-                        && method.getParameterTypes().length == 0
-                        && isPrimitive(method.getReturnType())) {
-                    Parameter parameter = method.getAnnotation(Parameter.class);
-                    if (method.getReturnType() == Object.class || parameter != null && parameter.excluded()) {
-                        continue;
-                    }
-                    int i = name.startsWith(""get"") ? 3 : 2;
-                    String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), ""."");
-                    String key;
-                    if (parameter != null && parameter.key().length() > 0) {
-                        key = parameter.key();
-                    } else {
-                        key = prop;
-                    }
-                    Object value = method.invoke(config);
-                    String str = String.valueOf(value).trim();
-                    if (value != null && str.length() > 0) {
-                        if (parameter != null && parameter.escaped()) {
-                            str = URL.encode(str);
-                        }
-                        if (parameter != null && parameter.append()) {
-                            String pre = parameters.get(Constants.DEFAULT_KEY + ""."" + key);
-                            if (pre != null && pre.length() > 0) {
-                                str = pre + "","" + str;
-                            }
-                            pre = parameters.get(key);
-                            if (pre != null && pre.length() > 0) {
-                                str = pre + "","" + str;
-                            }
-                        }
-                        if (prefix != null && prefix.length() > 0) {
-                            key = prefix + ""."" + key;
-                        }
-                        parameters.put(key, str);
-                    } else if (parameter != null && parameter.required()) {
-                        throw new IllegalStateException(config.getClass().getSimpleName() + ""."" + key + "" == null"");
-                    }
-                } else if (""getParameters"".equals(name)
-                        && Modifier.isPublic(method.getModifiers())
-                        && method.getParameterTypes().length == 0
-                        && method.getReturnType() == Map.class) {
-                    Map<String, String> map = (Map<String, String>) method.invoke(config, new Object[0]);
-                    if (map != null && map.size() > 0) {
-                        String pre = (prefix != null && prefix.length() > 0 ? prefix + ""."" : """");
-                        for (Map.Entry<String, String> entry : map.entrySet()) {
-                            parameters.put(pre + entry.getKey().replace('-', '.'), entry.getValue());
-                        }
-                    }
-                }
-            } catch (Exception e) {
-                throw new IllegalStateException(e.getMessage(), e);
-            }
-        }
-    }
-
-    protected static void appendAttributes(Map<Object, Object> parameters, Object config) {
-        appendAttributes(parameters, config, null);
-    }
-
-    protected static void appendAttributes(Map<Object, Object> parameters, Object config, String prefix) {
-        if (config == null) {
-            return;
-        }
-        Method[] methods = config.getClass().getMethods();
-        for (Method method : methods) {
-            try {
-                String name = method.getName();
-                if ((name.startsWith(""get"") || name.startsWith(""is""))
-                        && !""getClass"".equals(name)
-                        && Modifier.isPublic(method.getModifiers())
-                        && method.getParameterTypes().length == 0
-                        && isPrimitive(method.getReturnType())) {
-                    Parameter parameter = method.getAnnotation(Parameter.class);
-                    if (parameter == null || !parameter.attribute()) {
-                        continue;
-                    }
-                    String key;
-                    if (parameter.key().length() > 0) {
-                        key = parameter.key();
-                    } else {
-                        int i = name.startsWith(""get"") ? 3 : 2;
-                        key = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1);
-                    }
-                    Object value = method.invoke(config);
-                    if (value != null) {
-                        if (prefix != null && prefix.length() > 0) {
-                            key = prefix + ""."" + key;
-                        }
-                        parameters.put(key, value);
-                    }
-                }
-            } catch (Exception e) {
-                throw new IllegalStateException(e.getMessage(), e);
-            }
-        }
-    }
-
-    private static boolean isPrimitive(Class<?> type) {
-        return type.isPrimitive()
-                || type == String.class
-                || type == Character.class
-                || type == Boolean.class
-                || type == Byte.class
-                || type == Short.class
-                || type == Integer.class
-                || type == Long.class
-                || type == Float.class
-                || type == Double.class
-                || type == Object.class;
-    }
-
-    private static Object convertPrimitive(Class<?> type, String value) {
-        if (type == char.class || type == Character.class) {
-            return value.length() > 0 ? value.charAt(0) : '\0';
-        } else if (type == boolean.class || type == Boolean.class) {
-            return Boolean.valueOf(value);
-        } else if (type == byte.class || type == Byte.class) {
-            return Byte.valueOf(value);
-        } else if (type == short.class || type == Short.class) {
-            return Short.valueOf(value);
-        } else if (type == int.class || type == Integer.class) {
-            return Integer.valueOf(value);
-        } else if (type == long.class || type == Long.class) {
-            return Long.valueOf(value);
-        } else if (type == float.class || type == Float.class) {
-            return Float.valueOf(value);
-        } else if (type == double.class || type == Double.class) {
-            return Double.valueOf(value);
-        }
-        return value;
-    }
-
-    protected static void checkExtension(Class<?> type, String property, String value) {
-        checkName(property, value);
-        if (value != null && value.length() > 0
-                && !ExtensionLoader.getExtensionLoader(type).hasExtension(value)) {
-            throw new IllegalStateException(""No such extension "" + value + "" for "" + property + ""/"" + type.getName());
-        }
-    }
-
-    protected static void checkMultiExtension(Class<?> type, String property, String value) {
-        checkMultiName(property, value);
-        if (value != null && value.length() > 0) {
-            String[] values = value.split(""\\s*[,]+\\s*"");
-            for (String v : values) {
-                if (v.startsWith(Constants.REMOVE_VALUE_PREFIX)) {
-                    v = v.substring(1);
-                }
-                if (Constants.DEFAULT_KEY.equals(v)) {
-                    continue;
-                }
-                if (!ExtensionLoader.getExtensionLoader(type).hasExtension(v)) {
-                    throw new IllegalStateException(""No such extension "" + v + "" for "" + property + ""/"" + type.getName());
-                }
-            }
-        }
-    }
-
-    protected static void checkLength(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, null);
-    }
-
-    protected static void checkPathLength(String property, String value) {
-        checkProperty(property, value, MAX_PATH_LENGTH, null);
-    }
-
-    protected static void checkName(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_NAME);
-    }
-
-    protected static void checkNameHasSymbol(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_NAME_HAS_SYMBOL);
-    }
-
-    protected static void checkKey(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_KEY);
-    }
-
-    protected static void checkMultiName(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_MULTI_NAME);
-    }
-
-    protected static void checkPathName(String property, String value) {
-        checkProperty(property, value, MAX_PATH_LENGTH, PATTERN_PATH);
-    }
-
-    protected static void checkMethodName(String property, String value) {
-        checkProperty(property, value, MAX_LENGTH, PATTERN_METHOD_NAME);
-    }
-
-    protected static void checkParameterName(Map<String, String> parameters) {
-        if (parameters == null || parameters.size() == 0) {
-            return;
-        }
-        for (Map.Entry<String, String> entry : parameters.entrySet()) {
-            checkNameHasSymbol(entry.getKey(), entry.getValue());
-        }
-    }
-
-    protected static void checkProperty(String property, String value, int maxlength, Pattern pattern) {
-        if (value == null || value.length() == 0) {
-            return;
-        }
-        if (value.length() > maxlength) {
-            throw new IllegalStateException(""Invalid "" + property + ""=\"""" + value + ""\"" is longer than "" + maxlength);
-        }
-        if (pattern != null) {
-            Matcher matcher = pattern.matcher(value);
-            if (!matcher.matches()) {
-                throw new IllegalStateException(""Invalid "" + property + ""=\"""" + value + ""\"" contains illegal "" +
-                        ""character, only digit, letter, '-', '_' or '.' is legal."");
-            }
-        }
-    }
-
-    @Parameter(excluded = true)
-    public String getId() {
-        return id;
-    }
-
-    public void setId(String id) {
-        this.id = id;
-    }
-
-    protected void appendAnnotation(Class<?> annotationClass, Object annotation) {
-        Method[] methods = annotationClass.getMethods();
-        for (Method method : methods) {
-            if (method.getDeclaringClass() != Object.class
-                    && method.getReturnType() != void.class
-                    && method.getParameterTypes().length == 0
-                    && Modifier.isPublic(method.getModifiers())
-                    && !Modifier.isStatic(method.getModifiers())) {
-                try {
-                    String property = method.getName();
-                    if (""interfaceClass"".equals(property) || ""interfaceName"".equals(property)) {
-                        property = ""interface"";
-                    }
-                    String setter = ""set"" + property.substring(0, 1).toUpperCase() + property.substring(1);
-                    Object value = method.invoke(annotation);
-                    if (value != null && !value.equals(method.getDefaultValue())) {
-                        Class<?> parameterType = ReflectUtils.getBoxedClass(method.getReturnType());
-                        if (""filter"".equals(property) || ""listener"".equals(property)) {
-                            parameterType = String.class;
-                            value = StringUtils.join((String[]) value, "","");
-                        } else if (""parameters"".equals(property)) {
-                            parameterType = Map.class;
-                            value = CollectionUtils.toStringMap((String[]) value);
-                        }
-                        try {
-                            Method setterMethod = getClass().getMethod(setter, parameterType);
-                            setterMethod.invoke(this, value);
-                        } catch (NoSuchMethodException e) {
-                            // ignore
-                        }
-                    }
-                } catch (Throwable e) {
-                    logger.error(e.getMessage(), e);
-                }
-            }
-        }
-    }
-
-    @Override
-    public String toString() {
-        try {
-            StringBuilder buf = new StringBuilder();
-            buf.append(""<dubbo:"");
-            buf.append(getTagName(getClass()));
-            Method[] methods = getClass().getMethods();
-            for (Method method : methods) {
-                try {
-                    String name = method.getName();
-                    if ((name.startsWith(""get"") || name.startsWith(""is""))
-                            && !""getClass"".equals(name) && !""get"".equals(name) && !""is"".equals(name)
-                            && Modifier.isPublic(method.getModifiers())
-                            && method.getParameterTypes().length == 0
-                            && isPrimitive(method.getReturnType())) {
-                        int i = name.startsWith(""get"") ? 3 : 2;
-                        String key = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1);
-                        Object value = method.invoke(this);
-                        if (value != null) {
-                            buf.append("" "");
-                            buf.append(key);
-                            buf.append(""=\"""");
-                            buf.append(value);
-                            buf.append(""\"""");
-                        }
-                    }
-                } catch (Exception e) {
-                    logger.warn(e.getMessage(), e);
-                }
-            }
-            buf.append("" />"");
-            return buf.toString();
-        } catch (Throwable t) {
-            logger.warn(t.getMessage(), t);
-            return super.toString();
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.config;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.ConfigUtils;
+import org.apache.dubbo.common.utils.ReflectUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.config.DubboShutdownHook;
+import org.apache.dubbo.config.MethodConfig;
+import org.apache.dubbo.config.support.Parameter;
+import org.apache.dubbo.rpc.model.ConsumerMethodModel;
+
+import java.io.Serializable;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Utility methods and public methods for parsing configuration
+ *
+ * @export
+ */
+public abstract class AbstractConfig implements Serializable {
+
+    protected static final Logger logger = LoggerFactory.getLogger(AbstractConfig.class);
+    private static final long serialVersionUID = 4267533505537413570L;
+    private static final int MAX_LENGTH = 200;
+
+    private static final int MAX_PATH_LENGTH = 200;
+
+    private static final Pattern PATTERN_NAME = Pattern.compile(""[\\-._0-9a-zA-Z]+"");
+
+    private static final Pattern PATTERN_MULTI_NAME = Pattern.compile(""[,\\-._0-9a-zA-Z]+"");
+
+    private static final Pattern PATTERN_METHOD_NAME = Pattern.compile(""[a-zA-Z][0-9a-zA-Z]*"");
+
+    private static final Pattern PATTERN_PATH = Pattern.compile(""[/\\-$._0-9a-zA-Z]+"");
+
+    private static final Pattern PATTERN_NAME_HAS_SYMBOL = Pattern.compile(""[:*,/\\-._0-9a-zA-Z]+"");
+
+    private static final Pattern PATTERN_KEY = Pattern.compile(""[*,\\-._0-9a-zA-Z]+"");
+    private static final Map<String, String> legacyProperties = new HashMap<String, String>();
+    private static final String[] SUFFIXES = new String[]{""Config"", ""Bean""};
+
+    static {
+        legacyProperties.put(""dubbo.protocol.name"", ""dubbo.service.protocol"");
+        legacyProperties.put(""dubbo.protocol.host"", ""dubbo.service.server.host"");
+        legacyProperties.put(""dubbo.protocol.port"", ""dubbo.service.server.port"");
+        legacyProperties.put(""dubbo.protocol.threads"", ""dubbo.service.max.thread.pool.size"");
+        legacyProperties.put(""dubbo.consumer.timeout"", ""dubbo.service.invoke.timeout"");
+        legacyProperties.put(""dubbo.consumer.retries"", ""dubbo.service.max.retry.providers"");
+        legacyProperties.put(""dubbo.consumer.check"", ""dubbo.service.allow.no.provider"");
+        legacyProperties.put(""dubbo.service.url"", ""dubbo.service.address"");
+
+        // this is only for compatibility
+        Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());
+    }
+
+    protected String id;
+
+    private static String convertLegacyValue(String key, String value) {
+        if (value != null && value.length() > 0) {
+            if (""dubbo.service.max.retry.providers"".equals(key)) {
+                return String.valueOf(Integer.parseInt(value) - 1);
+            } else if (""dubbo.service.allow.no.provider"".equals(key)) {
+                return String.valueOf(!Boolean.parseBoolean(value));
+            }
+        }
+        return value;
+    }
+
+    protected static void appendProperties(AbstractConfig config) {
+        if (config == null) {
+            return;
+        }
+        String prefix = ""dubbo."" + getTagName(config.getClass()) + ""."";
+        Method[] methods = config.getClass().getMethods();
+        for (Method method : methods) {
+            try {
+                String name = method.getName();
+                if (name.length() > 3 && name.startsWith(""set"") && Modifier.isPublic(method.getModifiers())
+                        && method.getParameterTypes().length == 1 && isPrimitive(method.getParameterTypes()[0])) {
+                    String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), ""."");
+
+                    String value = null;
+                    if (config.getId() != null && config.getId().length() > 0) {
+                        String pn = prefix + config.getId() + ""."" + property;
+                        value = System.getProperty(pn);
+                        if (!StringUtils.isBlank(value)) {
+                            logger.info(""Use System Property "" + pn + "" to config dubbo"");
+                        }
+                    }
+                    if (value == null || value.length() == 0) {
+                        String pn = prefix + property;
+                        value = System.getProperty(pn);
+                        if (!StringUtils.isBlank(value)) {
+                            logger.info(""Use System Property "" + pn + "" to config dubbo"");
+                        }
+                    }
+                    if (value == null || value.length() == 0) {
+                        Method getter;
+                        try {
+                            getter = config.getClass().getMethod(""get"" + name.substring(3));
+                        } catch (NoSuchMethodException e) {
+                            try {
+                                getter = config.getClass().getMethod(""is"" + name.substring(3));
+                            } catch (NoSuchMethodException e2) {
+                                getter = null;
+                            }
+                        }
+                        if (getter != null) {
+                            if (getter.invoke(config) == null) {
+                                if (config.getId() != null && config.getId().length() > 0) {
+                                    value = ConfigUtils.getProperty(prefix + config.getId() + ""."" + property);
+                                }
+                                if (value == null || value.length() == 0) {
+                                    value = ConfigUtils.getProperty(prefix + property);
+                                }
+                                if (value == null || value.length() == 0) {
+                                    String legacyKey = legacyProperties.get(prefix + property);
+                                    if (legacyKey != null && legacyKey.length() > 0) {
+                                        value = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey));
+                                    }
+                                }
+
+                            }
+                        }
+                    }
+                    if (value != null && value.length() > 0) {
+                        method.invoke(config, convertPrimitive(method.getParameterTypes()[0], value));
+                    }
+                }
+            } catch (Exception e) {
+                logger.error(e.getMessage(), e);
+            }
+        }
+    }
+
+    private static String getTagName(Class<?> cls) {
+        String tag = cls.getSimpleName();
+        for (String suffix : SUFFIXES) {
+            if (tag.endsWith(suffix)) {
+                tag = tag.substring(0, tag.length() - suffix.length());
+                break;
+            }
+        }
+        tag = tag.toLowerCase();
+        return tag;
+    }
+
+    protected static void appendParameters(Map<String, String> parameters, Object config) {
+        appendParameters(parameters, config, null);
+    }
+
+    @SuppressWarnings(""unchecked"")
+    protected static void appendParameters(Map<String, String> parameters, Object config, String prefix) {
+        if (config == null) {
+            return;
+        }
+        Method[] methods = config.getClass().getMethods();
+        for (Method method : methods) {
+            try {
+                String name = method.getName();
+                if ((name.startsWith(""get"") || name.startsWith(""is""))
+                        && !""getClass"".equals(name)
+                        && Modifier.isPublic(method.getModifiers())
+                        && method.getParameterTypes().length == 0
+                        && isPrimitive(method.getReturnType())) {
+                    Parameter parameter = method.getAnnotation(Parameter.class);
+                    if (method.getReturnType() == Object.class || parameter != null && parameter.excluded()) {
+                        continue;
+                    }
+                    int i = name.startsWith(""get"") ? 3 : 2;
+                    String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), ""."");
+                    String key;
+                    if (parameter != null && parameter.key().length() > 0) {
+                        key = parameter.key();
+                    } else {
+                        key = prop;
+                    }
+                    Object value = method.invoke(config);
+                    String str = String.valueOf(value).trim();
+                    if (value != null && str.length() > 0) {
+                        if (parameter != null && parameter.escaped()) {
+                            str = URL.encode(str);
+                        }
+                        if (parameter != null && parameter.append()) {
+                            String pre = parameters.get(Constants.DEFAULT_KEY + ""."" + key);
+                            if (pre != null && pre.length() > 0) {
+                                str = pre + "","" + str;
+                            }
+                            pre = parameters.get(key);
+                            if (pre != null && pre.length() > 0) {
+                                str = pre + "","" + str;
+                            }
+                        }
+                        if (prefix != null && prefix.length() > 0) {
+                            key = prefix + ""."" + key;
+                        }
+                        parameters.put(key, str);
+                    } else if (parameter != null && parameter.required()) {
+                        throw new IllegalStateException(config.getClass().getSimpleName() + ""."" + key + "" == null"");
+                    }
+                } else if (""getParameters"".equals(name)
+                        && Modifier.isPublic(method.getModifiers())
+                        && method.getParameterTypes().length == 0
+                        && method.getReturnType() == Map.class) {
+                    Map<String, String> map = (Map<String, String>) method.invoke(config, new Object[0]);
+                    if (map != null && map.size() > 0) {
+                        String pre = (prefix != null && prefix.length() > 0 ? prefix + ""."" : """");
+                        for (Map.Entry<String, String> entry : map.entrySet()) {
+                            parameters.put(pre + entry.getKey().replace('-', '.'), entry.getValue());
+                        }
+                    }
+                }
+            } catch (Exception e) {
+                throw new IllegalStateException(e.getMessage(), e);
+            }
+        }
+    }
+
+    protected static void appendAttributes(Map<String, Object> parameters, Object config) {
+        appendAttributes(parameters, config, null);
+    }
+
+    protected static void appendAttributes(Map<String, Object> parameters, Object config, String prefix) {
+        if (config == null) {
+            return;
+        }
+        Method[] methods = config.getClass().getMethods();
+        for (Method method : methods) {
+            try {
+                Parameter parameter = method.getAnnotation(Parameter.class);
+                if (parameter == null || !parameter.attribute())
+                    continue;
+                String name = method.getName();
+                if ((name.startsWith(""get"") || name.startsWith(""is""))
+                        && !""getClass"".equals(name)
+                        && Modifier.isPublic(method.getModifiers())
+                        && method.getParameterTypes().length == 0
+                        && isPrimitive(method.getReturnType())) {
+                    String key;
+                    if (parameter.key().length() > 0) {
+                        key = parameter.key();
+                    } else {
+                        int i = name.startsWith(""get"") ? 3 : 2;
+                        key = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1);
+                    }
+                    Object value = method.invoke(config);
+                    if (value != null) {
+                        if (prefix != null && prefix.length() > 0) {
+                            key = prefix + ""."" + key;
+                        }
+                        parameters.put(key, value);
+                    }
+                }
+            } catch (Exception e) {
+                throw new IllegalStateException(e.getMessage(), e);
+            }
+        }
+    }
+
+    protected static ConsumerMethodModel.AsyncMethodInfo convertMethodConfig2AyncInfo(MethodConfig methodConfig) {
+        if (methodConfig == null || (methodConfig.getOninvoke() == null && methodConfig.getOnreturn() == null && methodConfig.getOnthrow() == null)) {
+            return null;
+        }
+
+        //check config conflict
+        if (Boolean.FALSE.equals(methodConfig.isReturn()) && (methodConfig.getOnreturn() != null || methodConfig.getOnthrow() != null)) {
+            throw new IllegalStateException(""method config error : return attribute must be set true when onreturn or onthrow has been setted."");","[{'comment': '`setted` is typo', 'commenter': 'beiwei30'}]"
2688,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -309,23 +273,20 @@ private void init() {
         appendParameters(map, module);
         appendParameters(map, consumer, Constants.DEFAULT_KEY);
         appendParameters(map, this);
-        String prefix = StringUtils.getServiceKey(map);
+        Map<String, Object> attributes = null;
         if (methods != null && !methods.isEmpty()) {
-            Map<Object, Object> attributes = new HashMap<Object, Object>();
-            for (MethodConfig method : methods) {
-                appendParameters(map, method, method.getName());
-                String retryKey = method.getName() + "".retry"";
+            attributes = new HashMap<String, Object>();
+            for (MethodConfig methodConfig : methods) {
+                appendParameters(map, methodConfig, methodConfig.getName());
+                String retryKey = methodConfig.getName() + "".retry"";
                 if (map.containsKey(retryKey)) {
                     String retryValue = map.remove(retryKey);
                     if (""false"".equals(retryValue)) {
-                        map.put(method.getName() + "".retries"", ""0"");
+                        map.put(methodConfig.getName() + "".retries"", ""0"");
                     }
                 }
-                appendAttributes(attributes, method, prefix + ""."" + method.getName());
-                checkAndConvertImplicitConfig(method, map, attributes);
+                attributes.put(methodConfig.getName(), convertMethodConfig2AyncInfo(methodConfig));","[{'comment': 'why remove `appendAttributes(attributes, method, prefix + ""."" + method.getName());`', 'commenter': 'beiwei30'}, {'comment': '```\r\nappendAttributes(attributes, method, prefix + ""."" + method.getName());\r\ncheckAndConvertImplicitConfig(method, map, attributes);\r\n```\r\nThose above methods is only for the storing async attributes to StaticContext.\r\n', 'commenter': 'Jeff-Lv'}]"
2688,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java,"@@ -53,6 +57,17 @@ public ConsumerMethodModel getMethodModel(Method method) {
         return methodModels.get(method);
     }
 
+    /**
+     * Return method model for the given method on consumer side
+     *
+     * @param method method object
+     * @return method model
+     */
+    public ConsumerMethodModel getMethodModel(String method) {
+        Optional<Map.Entry<Method, ConsumerMethodModel>> consumerMethodModelEntry = methodModels.entrySet().stream().filter(entry -> entry.getKey().getName().equals(method)).findFirst();
+        return consumerMethodModelEntry.isPresent() ? consumerMethodModelEntry.get().getValue() : null;","[{'comment': 'IDE hint: \r\n\r\n```java\r\nreturn consumerMethodModelEntry.map(Map.Entry::getValue).orElse(null);\r\n```', 'commenter': 'beiwei30'}, {'comment': 'yeh, this hint is good. ', 'commenter': 'Jeff-Lv'}]"
2688,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/filter/FutureFilter.java,"@@ -79,14 +81,16 @@ private void asyncCallback(final Invoker<?> invoker, final Invocation invocation
     }
 
     private void fireInvokeCallback(final Invoker<?> invoker, final Invocation invocation) {
-        final Method onInvokeMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_INVOKE_METHOD_KEY));
-        final Object onInvokeInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_INVOKE_INSTANCE_KEY));
+        final ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo = getAsyncMethodInfo(invoker, invocation);
+        if (asyncMethodInfo == null) return;","[{'comment': 'pls. consider to use `{...}`.', 'commenter': 'beiwei30'}]"
2688,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/filter/FutureFilter.java,"@@ -103,8 +107,11 @@ private void fireInvokeCallback(final Invoker<?> invoker, final Invocation invoc
     }
 
     private void fireReturnCallback(final Invoker<?> invoker, final Invocation invocation, final Object result) {
-        final Method onReturnMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_RETURN_METHOD_KEY));
-        final Object onReturnInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_RETURN_INSTANCE_KEY));
+        final ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo = getAsyncMethodInfo(invoker, invocation);
+        if (asyncMethodInfo == null) return;","[{'comment': 'consider to use `{...}`', 'commenter': 'beiwei30'}]"
2688,dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java,"@@ -537,17 +537,17 @@
 
     public static final String ON_DISCONNECT_KEY = ""ondisconnect"";
 
-    public static final String ON_INVOKE_METHOD_KEY = ""oninvoke.method"";
+    public static final String ON_INVOKE_METHOD_KEY = ""oninvokeMethod"";
 
-    public static final String ON_RETURN_METHOD_KEY = ""onreturn.method"";","[{'comment': 'why rename?', 'commenter': 'kimmking'}]"
2688,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/filter/FutureFilter.java,"@@ -144,8 +151,11 @@ private void fireReturnCallback(final Invoker<?> invoker, final Invocation invoc
     }
 
     private void fireThrowCallback(final Invoker<?> invoker, final Invocation invocation, final Throwable exception) {
-        final Method onthrowMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_THROW_METHOD_KEY));
-        final Object onthrowInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_THROW_INSTANCE_KEY));
+        final ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo = getAsyncMethodInfo(invoker, invocation);
+        if (asyncMethodInfo == null) return;","[{'comment': '{}\r\n', 'commenter': 'kimmking'}]"
2699,dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java,"@@ -647,6 +647,9 @@
 
     public static final String REQUEST_TAG_KEY = ""request.tag"";
 
+","[{'comment': 'remove blank lines', 'commenter': 'kimmking'}]"
2699,dubbo-serialization/dubbo-serialization-gson/main/java/org/apache/dubbo/common/serialize/gson/GsonJsonObjectInput.java,"@@ -0,0 +1,116 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.serialize.gson;
+
+import com.alibaba.fastjson.JSON;
+import com.google.gson.Gson;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import org.apache.dubbo.common.serialize.ObjectInput;
+import org.apache.dubbo.common.utils.PojoUtils;
+
+import java.io.*;
+import java.lang.reflect.Type;
+/**
+ * Created by cr on 2018/10/23.","[{'comment': 'remove author info', 'commenter': 'kimmking'}]"
2703,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java,"@@ -26,6 +26,7 @@
 
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;","[{'comment': 'remove unused imports', 'commenter': 'carryxyh'}, {'comment': 'ok,i will remove  it.but I do not know why all checks have failed.could you tell me reason? I have never used travis CI before.', 'commenter': 'jingui123'}]"
2729,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java,"@@ -253,11 +253,19 @@ private void refreshInvoker(List<URL> invokerUrls) {
             }
             Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map
             Map<String, List<Invoker<T>>> newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); // Change method name to map Invoker Map
-            // state change
-            // If the calculation is wrong, it is not processed.
-            if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {
-                logger.error(new IllegalStateException(""urls to invokers error .invokerUrls.size :"" + invokerUrls.size() + "", invoker.size :0. urls :"" + invokerUrls.toString()));
-                return;
+
+            /**
+             *
+             * If there is no service, the service list is refreshed normally.
+             * For example, the service is disabled. If it is not refreshed at this time,
+             * it will be called to the invalid service provider.
+             *
+             * issues:
+             *   1. https://github.com/apache/incubator-dubbo/issues/2724
+             *   2. https://github.com/apache/incubator-dubbo-ops/issues/90
+             */
+            if (newUrlInvokerMap.isEmpty()) {","[{'comment': 'we cannot do this, this is empty-protection feature.', 'commenter': 'beiwei30'}]"
2763,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/AbstractRetryTask.java,"@@ -0,0 +1,84 @@
+package org.apache.dubbo.registry.retry;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.timer.Timeout;
+import org.apache.dubbo.common.timer.Timer;
+import org.apache.dubbo.common.timer.TimerTask;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.registry.support.FailbackRegistry;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * AbstractRetryTask
+ */
+public abstract class AbstractRetryTask implements TimerTask {
+
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+
+    /**
+     * url for retry task
+     */
+    protected final URL url;
+
+    /**
+     * registry for this task
+     */
+    protected final FailbackRegistry registry;
+
+    /**
+     * retry period
+     */
+    private final long retryPeriod;
+
+    /**
+     * task name for this task
+     */
+    private final String taskName;
+
+    AbstractRetryTask(URL url, FailbackRegistry registry, String taskName) {
+        if (url == null || registry == null || StringUtils.isBlank(taskName)) {
+            throw new IllegalArgumentException();
+        }
+        this.url = url;
+        this.registry = registry;
+        this.taskName = taskName;
+        this.retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD);
+    }
+
+    private void reput(Timeout timeout, Long tick) {
+        if (timeout == null || tick == null) {
+            throw new IllegalArgumentException();
+        }
+
+        Timer timer = timeout.timer();
+        if (timer.isStop() || timeout.isCancelled()) {
+            return;
+        }
+
+        timer.newTimeout(timeout.task(), tick, TimeUnit.MILLISECONDS);
+    }
+
+    @Override
+    public void run(Timeout timeout) throws Exception {
+        if (timeout.isCancelled()) {
+            // other thread cancel this timeout.
+            return;
+        }
+        if (logger.isInfoEnabled()) {","[{'comment': 'Please remove it , maybe print too many log.', 'commenter': 'zonghaishang'}, {'comment': '\r\nThis info log exists in the previous old version. This log is still useful in the test environment. Do we need to optimize it', 'commenter': 'carryxyh'}, {'comment': '```\r\nif (!recoverRegistered.isEmpty()) {\r\n    if (logger.isInfoEnabled()) {\r\n        logger.info(""Recover register url "" + recoverRegistered);\r\n    }\r\n}\r\n```\r\n\r\nBut I found that the original log output is conditional, such as the collection is not empty', 'commenter': 'zonghaishang'}, {'comment': 'In older versions, a log was printed if a failed collection was not empty. Now our logic is not in units of collections, but in the specific url of a failed. Entering this run method indicates that we are about to retry, so the log is printed here.', 'commenter': 'carryxyh'}]"
2763,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/AbstractRetryTask.java,"@@ -0,0 +1,84 @@
+package org.apache.dubbo.registry.retry;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.timer.Timeout;
+import org.apache.dubbo.common.timer.Timer;
+import org.apache.dubbo.common.timer.TimerTask;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.registry.support.FailbackRegistry;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * AbstractRetryTask
+ */
+public abstract class AbstractRetryTask implements TimerTask {
+
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+
+    /**
+     * url for retry task
+     */
+    protected final URL url;
+
+    /**
+     * registry for this task
+     */
+    protected final FailbackRegistry registry;
+
+    /**
+     * retry period
+     */
+    private final long retryPeriod;
+
+    /**
+     * task name for this task
+     */
+    private final String taskName;
+
+    AbstractRetryTask(URL url, FailbackRegistry registry, String taskName) {
+        if (url == null || registry == null || StringUtils.isBlank(taskName)) {
+            throw new IllegalArgumentException();
+        }
+        this.url = url;
+        this.registry = registry;
+        this.taskName = taskName;
+        this.retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD);
+    }
+
+    private void reput(Timeout timeout, Long tick) {
+        if (timeout == null || tick == null) {
+            throw new IllegalArgumentException();
+        }
+
+        Timer timer = timeout.timer();
+        if (timer.isStop() || timeout.isCancelled()) {
+            return;
+        }
+
+        timer.newTimeout(timeout.task(), tick, TimeUnit.MILLISECONDS);
+    }
+
+    @Override
+    public void run(Timeout timeout) throws Exception {
+        if (timeout.isCancelled()) {
+            // other thread cancel this timeout.
+            return;
+        }
+        if (logger.isInfoEnabled()) {
+            logger.info(taskName + "" : "" + url);
+        }
+        try {
+            doRetry(url, registry);
+        } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry
+            logger.warn(""Failed to "" + taskName + url + "", waiting for again, cause:"" + t.getMessage(), t);","[{'comment': 'Rename to `""Failed to execute task "" + taskName  + "", url: "" + url + "": waiting for again, cause:"" + t.getMessage()`', 'commenter': 'zonghaishang'}, {'comment': 'Ok, that is fine!\r\n', 'commenter': 'carryxyh'}]"
2763,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedNotifiedTask.java,"@@ -0,0 +1,66 @@
+package org.apache.dubbo.registry.retry;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.timer.Timeout;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.registry.NotifyListener;
+import org.apache.dubbo.registry.support.FailbackRegistry;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+/**
+ * FailedNotifiedTask
+ */
+public final class FailedNotifiedTask extends AbstractRetryTask {
+
+    private static final String NAME = ""retry subscribe"";
+
+    private final NotifyListener listener;
+
+    private final List<URL> urls = new CopyOnWriteArrayList<>();
+
+    public FailedNotifiedTask(URL url, NotifyListener listener) {
+        super(url, null, NAME);
+        if (listener == null) {
+            throw new IllegalArgumentException();
+        }
+        this.listener = listener;
+    }
+
+    public void addUrlToRetry(List<URL> urls) {
+        if (CollectionUtils.isEmpty(urls)) {
+            return;
+        }
+        this.urls.addAll(urls);
+    }
+
+    public void removeRetryUrl(List<URL> urls) {
+        this.urls.removeAll(urls);
+    }
+
+    @Override
+    public void run(Timeout timeout) throws Exception {
+        if (timeout.isCancelled() || timeout.timer().isStop() || isCancel()) {
+            // other thread cancel this timeout or stop the timer or cancel the task.
+            return;
+        }
+        if (logger.isInfoEnabled()) {
+            logger.info(taskName + "" : "" + url);
+        }
+        try {
+            listener.notify(urls);
+            urls.clear();
+        } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry
+            logger.warn(""Failed to "" + taskName + url + "", waiting for again, cause:"" + t.getMessage(), t);","[{'comment': 'again', 'commenter': 'zonghaishang'}]"
2763,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/AbstractRetryTask.java,"@@ -0,0 +1,84 @@
+package org.apache.dubbo.registry.retry;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.timer.Timeout;
+import org.apache.dubbo.common.timer.Timer;
+import org.apache.dubbo.common.timer.TimerTask;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.registry.support.FailbackRegistry;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * AbstractRetryTask
+ */
+public abstract class AbstractRetryTask implements TimerTask {
+
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+
+    /**
+     * url for retry task
+     */
+    protected final URL url;
+
+    /**
+     * registry for this task
+     */
+    protected final FailbackRegistry registry;
+
+    /**
+     * retry period
+     */
+    private final long retryPeriod;
+
+    /**
+     * task name for this task
+     */
+    private final String taskName;
+
+    AbstractRetryTask(URL url, FailbackRegistry registry, String taskName) {
+        if (url == null || registry == null || StringUtils.isBlank(taskName)) {
+            throw new IllegalArgumentException();
+        }
+        this.url = url;
+        this.registry = registry;
+        this.taskName = taskName;
+        this.retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD);
+    }
+
+    private void reput(Timeout timeout, Long tick) {
+        if (timeout == null || tick == null) {
+            throw new IllegalArgumentException();
+        }
+
+        Timer timer = timeout.timer();
+        if (timer.isStop() || timeout.isCancelled()) {
+            return;
+        }
+
+        timer.newTimeout(timeout.task(), tick, TimeUnit.MILLISECONDS);
+    }
+
+    @Override
+    public void run(Timeout timeout) throws Exception {","[{'comment': '```\r\npublic void run(Timeout timeout) throws Exception {\r\n    if (timeout.isCancelled() || timeout.timer().isStop() || isCancel()) {\r\n        // other thread cancel this timeout or stop the timer or cancel the task.\r\n        return;\r\n    }\r\n\r\n    try {\r\n        doRun(url, registry);\r\n    } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\r\n        logger.xxx\r\n\r\n        // reput this task when catch exception.\r\n        reput(timeout, retryPeriod);\r\n    }\r\n}\r\n```       \r\nwhat do to you think ? ', 'commenter': 'zonghaishang'}, {'comment': 'Seems like the info logger is needed.\r\nIt is useful in test env.', 'commenter': 'carryxyh'}]"
2763,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedNotifiedTask.java,"@@ -0,0 +1,83 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.registry.retry;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.timer.Timeout;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.registry.NotifyListener;
+import org.apache.dubbo.registry.support.FailbackRegistry;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+/**
+ * FailedNotifiedTask
+ */
+public final class FailedNotifiedTask extends AbstractRetryTask {
+
+    private static final String NAME = ""retry subscribe"";
+
+    private final NotifyListener listener;
+
+    private final List<URL> urls = new CopyOnWriteArrayList<>();
+
+    public FailedNotifiedTask(URL url, NotifyListener listener) {
+        super(url, null, NAME);
+        if (listener == null) {
+            throw new IllegalArgumentException();
+        }
+        this.listener = listener;
+    }
+
+    public void addUrlToRetry(List<URL> urls) {
+        if (CollectionUtils.isEmpty(urls)) {
+            return;
+        }
+        this.urls.addAll(urls);
+    }
+
+    public void removeRetryUrl(List<URL> urls) {
+        this.urls.removeAll(urls);
+    }
+
+    @Override
+    public void run(Timeout timeout) throws Exception {","[{'comment': 'just override `doRetry` or `doRun` is enough. I think doRun is better(more general)', 'commenter': 'zonghaishang'}, {'comment': 'agree, I took a glance and this is the only comments I have so far. We should not re-implement run(), instead, to implement retry().', 'commenter': 'beiwei30'}, {'comment': 'This is my mistake. According to the previous logic, failedNotify needs to be retried until the URL-NotifyListener key-value pair is removed.\r\n\r\nSo the logic of failedNotify is to reput to timer and retry no matter what the situation. After reading your review, I found that I can guarantee the above logic by reputing after doRetry. I will fix it as soon as possible.', 'commenter': 'carryxyh'}]"
2763,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/retry/FailedNotifiedTask.java,"@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.registry.retry;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.timer.Timeout;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.registry.NotifyListener;
+import org.apache.dubbo.registry.support.FailbackRegistry;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+/**
+ * FailedNotifiedTask
+ */
+public final class FailedNotifiedTask extends AbstractRetryTask {
+
+    private static final String NAME = ""retry subscribe"";
+
+    private final NotifyListener listener;
+
+    private final List<URL> urls = new CopyOnWriteArrayList<>();
+
+    public FailedNotifiedTask(URL url, NotifyListener listener) {
+        super(url, null, NAME);
+        if (listener == null) {
+            throw new IllegalArgumentException();","[{'comment': '`throw new IllegalArgumentException(""listener == null"")` maybe a little better.', 'commenter': 'kun-song'}, {'comment': 'never null. just a check.', 'commenter': 'carryxyh'}]"
2797,dubbo-rpc/dubbo-rpc-dubbo/pom.xml,"@@ -60,6 +60,12 @@
             <version>${project.parent.version}</version>
             <scope>test</scope>
         </dependency>
+        <dependency>","[{'comment': '\r\nIt seems that only adding dependencies does not make the test cover mina.\r\nWe still need some modifications to the UT. Both the server and the client have a cache. The cached key is the address (127.0.0.1:9000). In order to create a different Client or Server instance, we need to modify the port number of the UT.', 'commenter': 'carryxyh'}, {'comment': 'I have changed the port used for testDubboProtocolWithMina to a different one from testDubboProtocol, as to ensure a different server/client. Let me know if we should change every test to have a unique port number in the URL.', 'commenter': 'OrDTesters'}, {'comment': 'Personally think that different port numbers are better.', 'commenter': 'carryxyh'}, {'comment': 'Just to be clear, should I make the change to make every test have a unique port number in the URL before the PR can be merged? Right now, the PR only concerns testDubboProtocolWithMina, should changing port numbers for all other tests be put in a separate PR?', 'commenter': 'OrDTesters'}, {'comment': 'Since most of the ut is stable, I think it is not necessary to change every port.', 'commenter': 'carryxyh'}]"
2803,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java,"@@ -75,6 +76,14 @@ private static boolean isMatch(Class<?>[] types, List<Object> args) {
             }
 
             if (ReflectUtils.isPrimitive(arg.getClass())) {
+                if (arg instanceof String && type.isEnum()) {","[{'comment': 'I think it is not necessary to call `CompatibleTypeUtils.compatibleTypeConvert(arg, type`, this logic can be simplified as below, since we know arg is always a String type in this case.\r\n\r\n```java\r\n            if (ReflectUtils.isPrimitive(arg.getClass())) {\r\n                if (!ReflectUtils.isPrimitive(type) && !type.isEnum()) {\r\n                    return false;\r\n                }\r\n            }\r\n```', 'commenter': 'beiwei30'}]"
2807,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/StickyTest.java,"@@ -68,6 +69,8 @@ public void setUp() throws Exception {
         invokers.add(invoker2);
 
         clusterinvoker = new StickyClusterInvoker<StickyTest>(dic);
+
+        ExtensionLoader.resetExtensionLoader(LoadBalance.class);","[{'comment': 'I am not convinced either. Why we need to reset extension loader here?', 'commenter': 'beiwei30'}, {'comment': ""When either testStickyForceCheck or testStickyNoCheck runs, they eventually end up using an instance of RoundRobinLoadBalance, which is obtained and shared between the two tests through the ExtensionLoader, accessed using the LoadBalance.class as key. In between the two runs, one of the shared RoundRobinLoadBalance instance's internal map fields changes. The change is such that if testStickyNoCheck runs after testStickyForceCheck, the assertion for testStickyNoCheck fails. The goal of resetting is to make sure the two tests do not end up using the same RoundRobinLoadBalance instance when they run.\r\n\r\nI would be happy to discuss any other ways of approaching this problem."", 'commenter': 'OrDTesters'}, {'comment': 'I think I understand what happens now, agree with your change.', 'commenter': 'beiwei30'}]"
2815,dubbo-serialization/dubbo-serialization-test/src/test/java/org/apache/dubbo/common/serialize/fst/FstObjectOutputTest.java,"@@ -41,6 +42,11 @@ public void setUp() {
         this.fstObjectOutput = new FstObjectOutput(byteArrayOutputStream);
     }
 
+    @After
+    public void tearDown() throws IOException {
+        new FstObjectInput(new ByteArrayInputStream(new byte[]{0}));","[{'comment': 'why a `new FstObjectInput()` is necessary in tearDown method?', 'commenter': 'beiwei30'}, {'comment': 'not sure whether `org.nustaq.serialization.FSTConfiguration#clearGlobalCaches` and `org.nustaq.serialization.FSTConfiguration#clearCaches` do the tricks.', 'commenter': 'beiwei30'}, {'comment': 'Thank you for the suggestions. Unfortunately, calling neither of the two methods helped here, the command still fails when using these two methods in the tearDown. It seems there is still some other state that these clear methods do not help reset.', 'commenter': 'OrDTesters'}]"
2820,dubbo-common/src/main/java/org/apache/dubbo/common/config/AbstractPrefixConfiguration.java,"@@ -38,12 +38,11 @@ public AbstractPrefixConfiguration(String prefix, String id) {
     @Override
     public Object getProperty(String key, Object defaultValue) {
         Object value = null;
-        if (StringUtils.isNotEmpty(prefix) && StringUtils.isNotEmpty(id)) {
-            value = getInternalProperty(prefix + id + ""."" + key);
-        }
-        if (value == null && StringUtils.isNotEmpty(prefix)) {
+        String prefix = Environment.calculatePrefix(this.prefix, this.id);","[{'comment': 'I think caculatePrefix cannot be used here because the previous snippet will possibly try 2 times in the case when both neither and id are not empty. But with the new logic applies, it will only try once with the prefix returned in caculatePrefix.', 'commenter': 'chickenlj'}]"
2822,dubbo-config/dubbo-config-spring/src/main/resources/META-INF/dubbo.xsd,"@@ -25,6 +25,11 @@
                 <xsd:documentation><![CDATA[ The method retry times. ]]></xsd:documentation>
             </xsd:annotation>
         </xsd:attribute>
+        <xsd:attribute name=""failcapacity"" type=""xsd:string"">","[{'comment': 'Hi,\r\nwe have two files named dubbo.xsd.\r\nPls bring this config to both of them.\r\n:)', 'commenter': 'carryxyh'}, {'comment': ""Good idea. I've changed it"", 'commenter': 'wangweiufofly'}]"
2822,dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java,"@@ -139,6 +139,10 @@
 
     public static final int DEFAULT_RETRIES = 2;
 
+    public static final int DEFAULT_FAIL_CAPACITY_SIZE = 1000;","[{'comment': '1. DEFAULT_FAIL_CAPACITY_SIZE maybe changed to DEFAULT_FAILBACK_TASKS\r\n2.1000 is to large to us. maybe 100 is enough.\r\n:)', 'commenter': 'carryxyh'}, {'comment': ""Good idea. I've changed it."", 'commenter': 'wangweiufofly'}]"
2822,dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java,"@@ -139,6 +139,10 @@
 
     public static final int DEFAULT_RETRIES = 2;
 
+    public static final int DEFAULT_FAIL_CAPACITY_SIZE = 1000;
+
+    public static final int DEFAULT_FAIL_RETRY_SIZE = 100;","[{'comment': '1. DEFAULT_FAIL_RETRY_SIZE maybe changed to DEFAULT_FAILBACK_TIMES\r\n2. 100 is also too large. maybe 3 is enough.', 'commenter': 'carryxyh'}, {'comment': ""Good idea. I've changed it."", 'commenter': 'wangweiufofly'}]"
2822,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvoker.java,"@@ -16,90 +16,75 @@
  */
 package org.apache.dubbo.rpc.cluster.support;
 
+import org.apache.dubbo.common.Constants;
 import org.apache.dubbo.common.logger.Logger;
 import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;
+import org.apache.dubbo.common.timer.HashedWheelTimer;
+import org.apache.dubbo.common.timer.Timeout;
+import org.apache.dubbo.common.timer.Timer;
+import org.apache.dubbo.common.timer.TimerTask;
+import org.apache.dubbo.common.utils.NamedThreadFactory;
 import org.apache.dubbo.rpc.Invocation;
 import org.apache.dubbo.rpc.Invoker;
 import org.apache.dubbo.rpc.Result;
 import org.apache.dubbo.rpc.RpcException;
 import org.apache.dubbo.rpc.RpcResult;
-import org.apache.dubbo.rpc.RpcContext;
 import org.apache.dubbo.rpc.cluster.Directory;
 import org.apache.dubbo.rpc.cluster.LoadBalance;
 
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * When fails, record failure requests and schedule for retry on a regular interval.
  * Especially useful for services of notification.
  *
  * <a href=""http://en.wikipedia.org/wiki/Failback"">Failback</a>
- *
  */
 public class FailbackClusterInvoker<T> extends AbstractClusterInvoker<T> {
 
     private static final Logger logger = LoggerFactory.getLogger(FailbackClusterInvoker.class);
 
-    private static final long RETRY_FAILED_PERIOD = 5 * 1000;
+    private static final long RETRY_FAILED_PERIOD = 5;
 
-    /**
-     * Use {@link NamedInternalThreadFactory} to produce {@link org.apache.dubbo.common.threadlocal.InternalThread}
-     * which with the use of {@link org.apache.dubbo.common.threadlocal.InternalThreadLocal} in {@link RpcContext}.
-     */
-    private final ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2,
-            new NamedInternalThreadFactory(""failback-cluster-timer"", true));
+    private final int retries;
 
-    private final ConcurrentMap<Invocation, AbstractClusterInvoker<?>> failed = new ConcurrentHashMap<>();
-    private volatile ScheduledFuture<?> retryFuture;
+    private final int failCapacitySize;","[{'comment': ""maybe 'failbackTasks'"", 'commenter': 'carryxyh'}, {'comment': ""Good idea. I've changed it."", 'commenter': 'wangweiufofly'}]"
2822,dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java,"@@ -272,6 +276,8 @@
 
     public static final String RETRIES_KEY = ""retries"";
 
+    public static final String FAIL_CAPACITY_KEY = ""failcapacity"";","[{'comment': ""maybe 'failbacktasks' or sth"", 'commenter': 'carryxyh'}, {'comment': ""Good idea. I've changed it."", 'commenter': 'wangweiufofly'}]"
2822,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvokerTest.java,"@@ -118,15 +120,21 @@ public void testNoInvoke() {
     }
 
     @Test()
-    public void testRetryFailed() {
+    public void testRetryFailed() throws Exception{
+        //Test retries and
 
         resetInvokerToException();
 
         FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<FailbackClusterInvokerTest>(
                 dic);
         invoker.invoke(invocation);
+        invoker.invoke(invocation);
+        invoker.invoke(invocation);
         Assert.assertNull(RpcContext.getContext().getInvoker());
-        invoker.retryFailed();// when retry the invoker which get from failed map already is not the mocked invoker,so
+//        invoker.retryFailed();// when retry the invoker which get from failed map already is not the mocked invoker,so
+        //Ensure that the main thread is online
+        CountDownLatch countDown = new CountDownLatch(1);","[{'comment': 'I think u should assert that the logger contains the specific msg.', 'commenter': 'carryxyh'}]"
2822,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailbackClusterInvokerTest.java,"@@ -112,21 +119,34 @@ public void testNoInvoke() {
         FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<FailbackClusterInvokerTest>(
                 dic);
         LogUtil.start();
+        DubboAppender.clear();
         invoker.invoke(invocation);
         assertEquals(1, LogUtil.findMessage(""Failback to invoke""));
         LogUtil.stop();
     }
 
     @Test()
-    public void testRetryFailed() {
+    public void testARetryFailed() throws Exception {","[{'comment': 'Could u pls tell us why u rename the method and why u add the FixMethodOrder annotation?\r\n:)', 'commenter': 'carryxyh'}]"
2831,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java,"@@ -177,18 +177,29 @@ else if ("","".equals(separator)) { // Should be seperateed by ','
         return invokers;
     }
 
+    @Override
+    public Integer getPriority() {
+        return priority;
+    }
+
     @Override
     public URL getUrl() {
         return url;
     }
 
     @Override
     public int compareTo(Router o) {
-        if (o == null || o.getClass() != ConditionRouter.class) {
-            return 1;
+        if (o == null) {
+            throw new IllegalArgumentException();
+        }
+        if(o.getUrl()==null){","[{'comment': 'format your code\r\n:)', 'commenter': 'carryxyh'}]"
2831,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java,"@@ -177,18 +177,29 @@ else if ("","".equals(separator)) { // Should be seperateed by ','
         return invokers;
     }
 
+    @Override
+    public Integer getPriority() {
+        return priority;
+    }
+
     @Override
     public URL getUrl() {
         return url;
     }
 
     @Override
     public int compareTo(Router o) {
-        if (o == null || o.getClass() != ConditionRouter.class) {
-            return 1;
+        if (o == null) {
+            throw new IllegalArgumentException();
+        }
+        if(o.getUrl()==null){
+            return -1;
+        }
+        if (this.priority == o.getPriority()){
+            return url.toFullString().compareTo(o.getUrl().toFullString());
+        }else{
+            return (this.priority > o.getPriority() ? 1 : -1) ;","[{'comment': ""maybe the outsite '(' and ')' is not necessary"", 'commenter': 'carryxyh'}]"
2831,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/script/ScriptRouter.java,"@@ -26,12 +26,7 @@
 import org.apache.dubbo.rpc.RpcException;
 import org.apache.dubbo.rpc.cluster.Router;
 
-import javax.script.Bindings;
-import javax.script.Compilable;
-import javax.script.CompiledScript;
-import javax.script.ScriptEngine;
-import javax.script.ScriptEngineManager;
-import javax.script.ScriptException;
+import javax.script.*;","[{'comment': ""don't use 'import ...*'"", 'commenter': 'carryxyh'}]"
2831,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java,"@@ -177,18 +177,29 @@ else if ("","".equals(separator)) { // Should be seperateed by ','
         return invokers;
     }
 
+    @Override
+    public Integer getPriority() {
+        return priority;
+    }
+
     @Override
     public URL getUrl() {
         return url;
     }
 
     @Override
     public int compareTo(Router o) {
-        if (o == null || o.getClass() != ConditionRouter.class) {
-            return 1;
+        if (o == null) {
+            throw new IllegalArgumentException();
+        }
+        if(o.getUrl()==null){
+            return -1;
+        }
+        if (this.priority == o.getPriority()){
+            return url.toFullString().compareTo(o.getUrl().toFullString());","[{'comment': ""maybe you should check the NullPointerException of this 'o.getUrl.toFullString'"", 'commenter': 'carryxyh'}]"
2909,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/script/ScriptRouter.java,"@@ -114,13 +113,24 @@ public URL getUrl() {
         }
     }
 
+    @Override
+    public Integer getPriority() {
+        return priority;
+    }
+
     @Override
     public int compareTo(Router o) {
-        if (o == null || o.getClass() != ScriptRouter.class) {
-            return 1;
+        if (o == null) {","[{'comment': ""shouldn't we call super first, and do extra logic when super return 0 instead?"", 'commenter': 'beiwei30'}, {'comment': ""This does not match the old logic.\r\nThe old logic is: If the priorities are equal, compare the rules.\r\n\r\nIf you call super first and the priority is equal, continue to compare the url. If the url returns not 0, it will return directly.\r\n\r\nOld logic doesn't compare to url and url would not effect result."", 'commenter': 'carryxyh'}, {'comment': 'Simply,\r\nSometimes the url compare(super method) return 1. But the rule compare return -1.\r\nIf we call super first, it will return 1.\r\nBut in the old logic, it will return -1.', 'commenter': 'carryxyh'}]"
2909,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Router.java,"@@ -51,4 +51,31 @@
      */
     <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;
 
+    /**
+     * priority
+     *
+     * @return
+     */
+    Integer getPriority();","[{'comment': ""I think `int` is better, let's rely on auto-boxing."", 'commenter': 'beiwei30'}, {'comment': 'Ok, modified, thank you\r\n', 'commenter': 'Leishunyu'}]"
2929,dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationPropertyValuesAdapterTest.java,"@@ -66,19 +65,9 @@ public void test() {
 
         DefaultConversionService conversionService = new DefaultConversionService();
 
-        conversionService.addConverter(new Converter<String[], String>() {
-            @Override
-            public String convert(String[] source) {
-                return arrayToCommaDelimitedString(source);
-            }
-        });
-
-        conversionService.addConverter(new Converter<String[], Map<String, String>>() {
-            @Override
-            public Map<String, String> convert(String[] source) {
-                return CollectionUtils.toStringMap(source);
-            }
-        });
+        conversionService.addConverter((Converter<String[], String>) StringUtils::arrayToCommaDelimitedString);","[{'comment': '@igor-suhorukov, this change leads to CI failure. It looks like lambda lost generic info (actualTypeArguments).\r\n\r\npls. check org.springframework.core.SerializableTypeWrapper#forGenericInterfaces\r\n\r\n```java\r\n\tpublic static Type[] forGenericInterfaces(final Class<?> type) {\r\n\t\tType[] result = new Type[type.getGenericInterfaces().length];\r\n\t\tfor (int i = 0; i < result.length; i++) {\r\n\t\t\tfinal int index = i;\r\n\t\t\tresult[i] = forTypeProvider(new SimpleTypeProvider() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic Type getType() {\r\n\t\t\t\t\treturn type.getGenericInterfaces()[index];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n```', 'commenter': 'beiwei30'}, {'comment': '@beiwei30 thank you for assistance', 'commenter': 'igor-suhorukov'}]"
2932,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java,"@@ -86,12 +86,12 @@ public Result invoke(Invocation invocation) throws RpcException {
             } catch (RpcException e) {
                 if (e.isBiz()) {
                     throw e;
-                } else {
-                    if (logger.isWarnEnabled()) {
-                        logger.warn(""fail-mock: "" + invocation.getMethodName() + "" fail-mock enabled , url : "" + directory.getUrl(), e);
-                    }
-                    result = doMockInvoke(invocation, e);
                 }
+                
+                if (logger.isWarnEnabled()) {","[{'comment': ""I don't think this has some differences with the old way.."", 'commenter': 'carryxyh'}, {'comment': ""yes，there is no functional difference，I think it's a little bit cleaner to take this logic out"", 'commenter': 'lixiaojiee'}, {'comment': 'OK, that is all right.\r\nI will approve this pr.', 'commenter': 'carryxyh'}]"
2936,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/merger/MergerFactory.java,"@@ -49,6 +53,11 @@
                 result = mergerCache.get(returnType);
             }
         }
+
+        if (result == null) {","[{'comment': ""I don't think we should throw an exception, let's just return null."", 'commenter': 'beiwei30'}, {'comment': 'May be we can add some comments about this NullPointerException', 'commenter': 'luchy0120'}, {'comment': 'I still think it is ok to return null.', 'commenter': 'beiwei30'}]"
2936,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/merger/MapMerger.java,"@@ -25,8 +26,8 @@
 
     @Override
     public Map<?, ?> merge(Map<?, ?>... items) {
-        if (items.length == 0) {
-            return null;
+        if (ArrayUtils.isEmpty(items)) {
+            return new HashMap<Object, Object>();","[{'comment': 'pls. use Collections.emptyMap() instead.', 'commenter': 'beiwei30'}, {'comment': 'Ok', 'commenter': 'luchy0120'}]"
2936,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/merger/ListMerger.java,"@@ -26,6 +27,9 @@
 
     @Override
     public List<Object> merge(List<?>... items) {
+        if (ArrayUtils.isEmpty(items)) {
+            return new ArrayList<Object>();","[{'comment': 'Pls. use Collections.emptyList() instead.', 'commenter': 'beiwei30'}, {'comment': 'Ok', 'commenter': 'luchy0120'}]"
2936,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/merger/SetMerger.java,"@@ -25,7 +26,9 @@
 
     @Override
     public Set<Object> merge(Set<?>... items) {
-
+        if (ArrayUtils.isEmpty(items)) {
+            return new HashSet<Object>();","[{'comment': 'pls. use Collections.emptySet()', 'commenter': 'beiwei30'}, {'comment': 'Ok', 'commenter': 'luchy0120'}]"
2936,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/merger/ArrayMerger.java,"@@ -25,34 +26,48 @@
     public static final ArrayMerger INSTANCE = new ArrayMerger();
 
     @Override
-    public Object[] merge(Object[]... others) {
-        if (others.length == 0) {
-            return null;
+    public Object[] merge(Object[]... items) {
+        if (ArrayUtils.isEmpty(items)) {
+            return new Object[0];
         }
+
+        int i = 0;
+        while (i < items.length && items[i] == null) {
+            i++;
+        }
+
+        if (i == items.length) {
+            return new Object[0];
+        }
+
+        Class<?> type = items[i].getClass().getComponentType();
+
         int totalLen = 0;
-        for (int i = 0; i < others.length; i++) {
-            Object item = others[i];
-            if (item != null && item.getClass().isArray()) {
-                totalLen += Array.getLength(item);
-            } else {
-                throw new IllegalArgumentException((i + 1) + ""th argument is not an array"");
+        for (; i < items.length; i++) {
+            if (items[i] == null) {
+                continue;
+            }
+            Class<?> itemType = items[i].getClass().getComponentType();
+            if (itemType != type) {
+                throw new IllegalArgumentException(""Arguments' types are different"");
             }
+            totalLen += items[i].length;
         }
 
         if (totalLen == 0) {
-            return null;
+            return new Object[0];
         }
 
-        Class<?> type = others[0].getClass().getComponentType();
-
         Object result = Array.newInstance(type, totalLen);
+
         int index = 0;
-        for (Object array : others) {
-            for (int i = 0; i < Array.getLength(array); i++) {
-                Array.set(result, index++, Array.get(array, i));
+        for (Object[] array : items) {
+            if (array != null) {
+                for (int j = 0; j < array.length; j++) {
+                    Array.set(result, index++, array[j]);","[{'comment': 'array[index++] =result?', 'commenter': 'kimmking'}, {'comment': 'This is not wrong . It means ""result[index++] = array[j]""', 'commenter': 'luchy0120'}]"
2936,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/merger/ArrayMerger.java,"@@ -25,34 +26,48 @@
     public static final ArrayMerger INSTANCE = new ArrayMerger();
 
     @Override
-    public Object[] merge(Object[]... others) {
-        if (others.length == 0) {
-            return null;
+    public Object[] merge(Object[]... items) {
+        if (ArrayUtils.isEmpty(items)) {
+            return new Object[0];
         }
+
+        int i = 0;","[{'comment': 'why check this?', 'commenter': 'kimmking'}, {'comment': 'Because if the user pass in (   null ,null , new String[]{""abs"",""edf""} , null   ) ,  we need to find out the  String.class  , so we need to skip the null objects . ', 'commenter': 'luchy0120'}]"
2936,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/merger/ArrayMerger.java,"@@ -25,34 +26,48 @@
     public static final ArrayMerger INSTANCE = new ArrayMerger();
 
     @Override
-    public Object[] merge(Object[]... others) {
-        if (others.length == 0) {
-            return null;
+    public Object[] merge(Object[]... items) {
+        if (ArrayUtils.isEmpty(items)) {
+            return new Object[0];
         }
+
+        int i = 0;
+        while (i < items.length && items[i] == null) {
+            i++;
+        }
+
+        if (i == items.length) {
+            return new Object[0];
+        }
+
+        Class<?> type = items[i].getClass().getComponentType();
+
         int totalLen = 0;
-        for (int i = 0; i < others.length; i++) {
-            Object item = others[i];
-            if (item != null && item.getClass().isArray()) {
-                totalLen += Array.getLength(item);
-            } else {
-                throw new IllegalArgumentException((i + 1) + ""th argument is not an array"");
+        for (; i < items.length; i++) {
+            if (items[i] == null) {","[{'comment': 'use if !=null then ...', 'commenter': 'kimmking'}, {'comment': 'if I use ""if != null "",  there may be too much {{}} ,  会形成嵌套的if语句', 'commenter': 'luchy0120'}]"
2975,dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java,"@@ -487,6 +487,12 @@
      */
     public static final String REGISTRY_RETRY_PERIOD_KEY = ""retry.period"";
 
+    /**
+     * Period of checkZk for providers retry interval
+     */
+    public static final String  REGISTRY_CHECK_ZK_PERIOD_KEY  = ""checkzk.period"";","[{'comment': 'pls. reuse `REGISTRY_RECONNECT_PERIOD_KEY` instead of introducing a new constants.', 'commenter': 'beiwei30'}, {'comment': 'ok.... i will solve it', 'commenter': 'notlate'}]"
2975,dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java,"@@ -126,6 +151,41 @@ public void doUnregister(URL url) {
         }
     }
 
+    private void checkZkProvider(){","[{'comment': ""One second thought, I am wondering why the following code in org.apache.dubbo.registry.zookeeper.ZookeeperRegistry doesn't work:\r\n\r\n```java\r\n        zkClient.addStateListener(new StateListener() {\r\n            @Override\r\n            public void stateChanged(int state) {\r\n                if (state == RECONNECTED) {\r\n                    try {\r\n                        recover();\r\n                    } catch (Exception e) {\r\n                        logger.error(e.getMessage(), e);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n```\r\n\r\nWould you mind to take a look?"", 'commenter': 'beiwei30'}, {'comment': 'as it is a private method should we move to the place where private methods start.', 'commenter': 'khanimteyaz'}]"
2975,dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java,"@@ -126,6 +151,41 @@ public void doUnregister(URL url) {
         }
     }
 
+    private void checkZkProvider(){
+        Set<URL> registeredURLSet = new HashSet<URL>(getRegistered());
+        for (URL registeredURL: registeredURLSet){
+            if(registeredURL.getProtocol().equalsIgnoreCase(Constants.CONSUMER))
+                continue;
+
+            String host = registeredURL.getHost();
+            int port = registeredURL.getPort();
+            String interfaceName = registeredURL.getServiceInterface();
+            List<String> childPath = zkClient.getChildren(Constants.PATH_SEPARATOR + DEFAULT_ROOT + Constants.PATH_SEPARATOR
+                    + interfaceName + Constants.PATH_SEPARATOR + Constants.PROVIDERS_CATEGORY);","[{'comment': 'can be refactored to a new method\r\n\r\nList<String> childPath = zkClient.getChildren(registeredURL.getServiceInterface());\r\nprivate String getZKKey(String interfaceName) {\r\n   return Constants.PATH_SEPARATOR + DEFAULT_ROOT + Constants.PATH_SEPARATOR\r\n                    + interfaceName + Constants.PATH_SEPARATOR + Constants.PROVIDERS_CATEGORY;\r\n}', 'commenter': 'khanimteyaz'}]"
2975,dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java,"@@ -126,6 +151,41 @@ public void doUnregister(URL url) {
         }
     }
 
+    private void checkZkProvider(){
+        Set<URL> registeredURLSet = new HashSet<URL>(getRegistered());
+        for (URL registeredURL: registeredURLSet){
+            if(registeredURL.getProtocol().equalsIgnoreCase(Constants.CONSUMER))
+                continue;
+
+            String host = registeredURL.getHost();
+            int port = registeredURL.getPort();
+            String interfaceName = registeredURL.getServiceInterface();
+            List<String> childPath = zkClient.getChildren(Constants.PATH_SEPARATOR + DEFAULT_ROOT + Constants.PATH_SEPARATOR
+                    + interfaceName + Constants.PATH_SEPARATOR + Constants.PROVIDERS_CATEGORY);
+
+            boolean serviceExist = false;
+            for(String child : childPath) {
+                URL providerURL = URL.valueOf(URL.decode(child));
+                if(providerURL != null && providerURL.getHost().equalsIgnoreCase(host) && providerURL.getPort() == port){","[{'comment': 'I think providerURL is never going to be null, if given child is null then URL.valueOf is going to throws a IllegalArgumentException exception. ', 'commenter': 'khanimteyaz'}, {'comment': 'Just as an thought, can be rewritten as \r\n\r\n boolean serviceExist= childPath.stream()\r\n                .map(path->URL.valueOf(URL.decode(path)))\r\n                .anyMatch(url->url.getHost().equalsIgnoreCase(host) && url.getPort()==port);\r\n        ', 'commenter': 'khanimteyaz'}, {'comment': 'good idea', 'commenter': 'notlate'}]"
2975,dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java,"@@ -126,6 +151,41 @@ public void doUnregister(URL url) {
         }
     }
 
+    private void checkZkProvider(){
+        Set<URL> registeredURLSet = new HashSet<URL>(getRegistered());
+        for (URL registeredURL: registeredURLSet){
+            if(registeredURL.getProtocol().equalsIgnoreCase(Constants.CONSUMER))
+                continue;
+
+            String host = registeredURL.getHost();
+            int port = registeredURL.getPort();
+            String interfaceName = registeredURL.getServiceInterface();
+            List<String> childPath = zkClient.getChildren(Constants.PATH_SEPARATOR + DEFAULT_ROOT + Constants.PATH_SEPARATOR
+                    + interfaceName + Constants.PATH_SEPARATOR + Constants.PROVIDERS_CATEGORY);
+
+            boolean serviceExist = false;
+            for(String child : childPath) {
+                URL providerURL = URL.valueOf(URL.decode(child));
+                if(providerURL != null && providerURL.getHost().equalsIgnoreCase(host) && providerURL.getPort() == port){
+                    serviceExist = true;
+                    break;
+                }
+            }
+
+            if(!serviceExist){
+                try {
+                    logger.error(""found some interface"" + interfaceName + "" does not exists in zk provider path, do recover"");
+                    recover();
+                } catch (Exception t) {
+                    logger.error(""Unexpected error occur at failed checkZk, cause: "" + t.getMessage(), t);
+                }
+                return;","[{'comment': 'Sorry for asking this question (as I am new to dubbo at this part). Is it expected that if a single service (from group of services) does not exists then we will stop the recovery for remaining services, as I see ""return"" statement in the code?\r\n\r\n**Note: I see there is **recover** call, so assuming a single recover call should be good enough to recover for connection reestablishment , but just wanted to check with you, we are not missing any thing.', 'commenter': 'khanimteyaz'}]"
3017,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java,"@@ -151,6 +149,14 @@ public Result invoke(Invocation inv) throws RpcException {
         }
         RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
 
+        // If we have attachment, refresh the attachment to ensure that the last invoke's attach does not affect this call.
+        // In most cases, attachments contains interface, timeout, group, and token.
+        // These info should be refreshed in each invoke.
+        //
+        // See https://github.com/apache/incubator-dubbo/issues/2981
+        if (attachment != null && attachment.size() > 0) {
+            invocation.addAttachments(attachment);","[{'comment': 'Just curious to know, as comment indicates refreshing timeout, group, and token. Do we need any place to be also refresh other than invocation?', 'commenter': 'khanimteyaz'}, {'comment': 'Hey, maybe the description here is a bit problematic. We are not refreshing but covering. I will modify it later.\r\n\r\nThe global attachment here is information such as interface and timeout obtained from the URL. We want to make sure that the interface and timeout used for each call are in the url of the current invoker, not the other way. Other ways such as: RpcContext.getContext.setAttachment\r\nSo, before invoke, we should override these info.\r\n:)', 'commenter': 'carryxyh'}, {'comment': '@carryxyh thanks for the info.', 'commenter': 'khanimteyaz'}, {'comment': 'What if user has overridden the `timeout` or `token` value in RpcContext/Invocation, if you put replace `addAttachmentsIfAbsent ` with `addAttachments` and put it at the last place,  the user will never has a chance to override the keys listed here https://github.com/apache/incubator-dubbo/blob/e07038b00e057bb3cd6989252534b581039916f9/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java#L78', 'commenter': 'chickenlj'}, {'comment': 'Cannot we just remove  or replace the INTERFACE_KEY with the right one? ', 'commenter': 'chickenlj'}, {'comment': 'I even find that the INTERFACE_KEY useless on the wire.  Instead `path` was used instead:\r\nhttps://github.com/apache/incubator-dubbo/blob/e07038b00e057bb3cd6989252534b581039916f9/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java#L215', 'commenter': 'chickenlj'}, {'comment': '> What if user has overridden the timeout or token value in RpcContext/Invocation, if you put replace addAttachmentsIfAbsent with addAttachments and put it at the last place, the user will never has a chance to override the keys listed here\r\n\r\nI have previously considered using RpcContext to modify the timeout (group) scenario. I personally are not sure if there is a intention to leave a back door or a design flaw. But I rarely encounter the need to use RpcContext to modify the timeout, so the overlay is used directly.\r\n\r\nI have previously considered using RpcContext to modify the timeout (token) scenario. I personally are not sure if there is a intention to leave a back door or a design flaw. But I rarely encounter the need to use RpcContext to modify the timeout, so the overlay is used directly.\r\n\r\n> Cannot we just remove or replace the INTERFACE_KEY with the right one?\r\n\r\nYes, we can. \r\nBut it seems that `timeout` and `group` may have the same problem as interface. For example, in the link of `A -> B -> C`, `B` receives the `timeout` from `A`. At this time, in the link where `B` calls `C`, it is possible to use the timeout of `A -> B` instead of the timeout of `B -> C`. Should we try to avoid this risk?\r\n\r\n> I even find that the INTERFACE_KEY useless on the wire.\r\n\r\nI see that there are still many places that quote INTERFACE_KEY. Is it my understanding of what you mean wrong?', 'commenter': 'carryxyh'}, {'comment': '> I even find that the INTERFACE_KEY useless on the wire.\r\n> \r\n> I see that there are still many places that quote INTERFACE_KEY. Is it my understanding of what you mean wrong?\r\n\r\nI mean the necessity of passing INTERFACE_KEY from consumer to provider. Does provider ever uses the INTERFACE_KEY received from consumer?', 'commenter': 'chickenlj'}, {'comment': ""https://github.com/apache/incubator-dubbo/blob/33f1726713a4c5f2ce5880613acf2320ae2a4502/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java#L46\r\n\r\nI am simply thinking of remove INTERFACE_KEY in here. GROUP_KEY, TOKEN_KEY and TIMEOUT_KEY would not have this problem because they've already been removed."", 'commenter': 'chickenlj'}, {'comment': ""Ok!\r\ni haven't notice it yet..."", 'commenter': 'carryxyh'}, {'comment': 'The only place to use INTERFACE_KEY is in ThriftProtocol:\r\nhttps://github.com/apache/incubator-dubbo/blob/4d78772fc8c20c8404406444b32d6a9aed92204f/dubbo-rpc/dubbo-rpc-thrift/src/main/java/org/apache/dubbo/rpc/protocol/thrift/ThriftProtocol.java#L66', 'commenter': 'chickenlj'}, {'comment': 'yes.\r\nThis problem does happen in the process of using Thrift.', 'commenter': 'carryxyh'}]"
3038,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/TraceTelnetHandler.java,"@@ -45,17 +45,18 @@ public String telnet(Channel channel, String message) {
         String[] parts = message.split(""\\s+"");
         String method;
         String times;
+        // message like : XxxService , XxxService 10 , XxxService xxxMethod , XxxService xxxMethod 10
         if (service == null || service.length() == 0) {","[{'comment': 'I think \r\n`if (StringUtils.isEmpty(service))`\r\nbe better.', 'commenter': 'khanimteyaz'}]"
3038,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/TraceTelnetHandler.java,"@@ -45,17 +45,18 @@ public String telnet(Channel channel, String message) {
         String[] parts = message.split(""\\s+"");
         String method;
         String times;
+        // message like : XxxService , XxxService 10 , XxxService xxxMethod , XxxService xxxMethod 10
         if (service == null || service.length() == 0) {
             service = parts.length > 0 ? parts[0] : null;
             method = parts.length > 1 ? parts[1] : null;
-        } else {
+            times = parts.length > 2 ? parts[2] : ""1"";","[{'comment': 'is there any chance parts[2] can be having non numeric number?', 'commenter': 'khanimteyaz'}]"
3038,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java,"@@ -99,13 +97,10 @@ private static boolean isMatch(Method method,List<Object> args, Class<?>[] param
                 if (!ReflectUtils.isCompatible(type, arg)) {
                     return false;
                 }
-            } else if (arg instanceof Map) {
-                String name = (String) ((Map<?, ?>) arg).get(""class"");
-                Class<?> cls = arg.getClass();
-                if (name != null && name.length() > 0) {
-                    cls = ReflectUtils.forName(name);
-                }
-                if (!type.isAssignableFrom(cls)) {
+            } else if (arg instanceof JSONObject) {
+                try {
+                    ((JSONObject) arg).toJavaObject(type);","[{'comment': '```java\r\n@Data\r\npublic class User1 implements Serializable {\r\n    private static final long serialVersionUID = -4729079781904156102L;\r\n    private String name;\r\n}\r\n```\r\n```java\r\n@Data\r\npublic class User2 implements Serializable {\r\n    private static final long serialVersionUID = -2112637973209566052L;\r\n    private String name;\r\n}\r\n```\r\n```java\r\npublic interface XXXService{\r\nString hello(User1 user);\r\nString hello(User2 user);\r\n\r\n}\r\n```\r\nMay find not the correct overload method; I think  must **class** param when the method is overloaded.\r\ntelnet: invoke xxxService.hello({""name"":""xxxx""})', 'commenter': 'gudegg'}, {'comment': 'I have fix it', 'commenter': 'LiZhenNet'}]"
3038,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java,"@@ -101,12 +100,19 @@ private static boolean isMatch(Method method,List<Object> args, Class<?>[] param
                 }
             } else if (arg instanceof Map) {
                 String name = (String) ((Map<?, ?>) arg).get(""class"");
-                Class<?> cls = arg.getClass();
-                if (name != null && name.length() > 0) {
-                    cls = ReflectUtils.forName(name);
-                }
-                if (!type.isAssignableFrom(cls)) {
-                    return false;
+                if (StringUtils.isNotEmpty(name)) {","[{'comment': '这里校验是不是太严格了，我觉得简单一点，没有 `class` 的时候返回 `true` 就 好了。', 'commenter': 'beiwei30'}]"
3043,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/codec/ExchangeCodec.java,"@@ -175,25 +172,35 @@ protected Object decodeBody(Channel channel, InputStream is, byte[] header) thro
             Request req = new Request(id);
             req.setVersion(Version.getProtocolVersion());
             req.setTwoWay((flag & FLAG_TWOWAY) != 0);
-            if ((flag & FLAG_EVENT) != 0) {
-                req.setEvent(Request.HEARTBEAT_EVENT);
-            }
+            Object data = null;","[{'comment': 'For the shake of mine understanding `if(flag & FLAG_REQUEST) == 0) ` true, then it is response scenario and if it is false means a request has been made to the service(which can be normal request, heartbeat or event received ). Is this understanding of mine correct?', 'commenter': 'khanimteyaz'}, {'comment': 'Yes, your understanding is correct.', 'commenter': 'CrazyHZM'}, {'comment': '@CrazyHZM  thanks this.', 'commenter': 'khanimteyaz'}, {'comment': ""I don't think we can remove this, since we will decode event data later. In my opinion we should do this:\r\n\r\n```java\r\nif ((flag & FLAG_EVENT) != 0) {\r\n    request.setEvent(true);\r\n}\r\n\r\ntry {\r\n    if (req.isEvent()) {\r\n        data = decodeEventData(channel, in);\r\n    } else {\r\n        data = decodeRequestData(channel, in);\r\n   }\r\n\r\n   request.setData(data);\r\n}\r\n```\r\n\r\nI don't think we should distinguish event type any longer"", 'commenter': 'beiwei30'}]"
3043,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/codec/ExchangeCodec.java,"@@ -175,25 +172,35 @@ protected Object decodeBody(Channel channel, InputStream is, byte[] header) thro
             Request req = new Request(id);
             req.setVersion(Version.getProtocolVersion());
             req.setTwoWay((flag & FLAG_TWOWAY) != 0);
-            if ((flag & FLAG_EVENT) != 0) {
-                req.setEvent(Request.HEARTBEAT_EVENT);
-            }
+            Object data = null;
             try {
                 ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);
-                Object data;
                 if (req.isHeartbeat()) {
                     data = decodeHeartbeatData(channel, in);
                 } else if (req.isEvent()) {
                     data = decodeEventData(channel, in);
                 } else {
                     data = decodeRequestData(channel, in);
                 }
-                req.setData(data);
             } catch (Throwable t) {
                 // bad request
                 req.setBroken(true);
                 req.setData(t);
             }
+            if (!req.isBroken()) {
+                if ((flag & FLAG_EVENT) != 0) {
+                    if (data != null && data.equals(Request.READONLY_EVENT)) {","[{'comment': '`if(Request.READONLY_EVENT.equals(data)` would be more simplified i think.', 'commenter': 'khanimteyaz'}, {'comment': 'If this is bad request，`req.setData(t);` will be executed，so I think `if (!req.isBroken())` is necessary.\r\nAbout `if ((flag & FLAG_EVENT) != 0)` , I think that plus him is just for insurance .\r\nfor example value of data  is ""R"" but it is not an event.', 'commenter': 'CrazyHZM'}, {'comment': 'Thanks for explaining this. but what I was saying is for line no 192, is \r\ninstead of having `if (data != null && data.equals(Request.READONLY_EVENT))`  we could simplify this by just having\r\n`if(Request.READONLY_EVENT.equals(data))`', 'commenter': 'khanimteyaz'}, {'comment': 'Thank you,It seems that you are right now, but if the value of READONLY_EVENT becomes empty in the future, this will be a hidden danger. Of course, this does not change much from the current point of view.\r\nWhat are the advantages of removing the judgment?', 'commenter': 'CrazyHZM'}, {'comment': 'It is always preferable to have more simplified code if can make it 😄 . In this case if READONLY_EVENT  value become empty which is big change because it might involve changes of user code so then we can still add the judgement back (in future we might even have to add more conditions to judgement). ', 'commenter': 'khanimteyaz'}]"
3043,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/codec/ExchangeCodec.java,"@@ -175,25 +172,35 @@ protected Object decodeBody(Channel channel, InputStream is, byte[] header) thro
             Request req = new Request(id);
             req.setVersion(Version.getProtocolVersion());
             req.setTwoWay((flag & FLAG_TWOWAY) != 0);
-            if ((flag & FLAG_EVENT) != 0) {
-                req.setEvent(Request.HEARTBEAT_EVENT);
-            }
+            Object data = null;
             try {
                 ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);
-                Object data;
                 if (req.isHeartbeat()) {
                     data = decodeHeartbeatData(channel, in);
                 } else if (req.isEvent()) {
                     data = decodeEventData(channel, in);
                 } else {
                     data = decodeRequestData(channel, in);
                 }
-                req.setData(data);
             } catch (Throwable t) {
                 // bad request
                 req.setBroken(true);
                 req.setData(t);
             }
+            if (!req.isBroken()) {
+                if ((flag & FLAG_EVENT) != 0) {","[{'comment': 'In case if the condition `if ((flag & FLAG_EVENT) != 0)` does not gets satisfied then, what will be the event value of request object? Is there any default event type?', 'commenter': 'khanimteyaz'}, {'comment': 'There are currently only two events here, and the value of READONLY_EVENT is empty by default, so when this is an event and the data is empty, this is a READONLY_EVENT.\r\nIt has no default event.', 'commenter': 'CrazyHZM'}, {'comment': 'With the limited knowledege about this part (so @chickenlj  @carryxyh @beiwei30  correct me if I am not correct). I think we should either have a default event type if noting is passed in data(more informative way and declaring a default behaviour) or we should reject the request if no default behaviour is spported.  It will make the easy to debug and reason about the issue. \r\n\r\nIf we provide some default behaviour (event type) and which is not communicated, for user it might be confusiong (because it is not documented or communicated to them).', 'commenter': 'khanimteyaz'}]"
3043,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/codec/ExchangeCodec.java,"@@ -175,25 +172,35 @@ protected Object decodeBody(Channel channel, InputStream is, byte[] header) thro
             Request req = new Request(id);
             req.setVersion(Version.getProtocolVersion());
             req.setTwoWay((flag & FLAG_TWOWAY) != 0);
-            if ((flag & FLAG_EVENT) != 0) {
-                req.setEvent(Request.HEARTBEAT_EVENT);
-            }
+            Object data = null;
             try {
                 ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);
-                Object data;
                 if (req.isHeartbeat()) {
                     data = decodeHeartbeatData(channel, in);
                 } else if (req.isEvent()) {
                     data = decodeEventData(channel, in);
                 } else {
                     data = decodeRequestData(channel, in);
                 }
-                req.setData(data);
             } catch (Throwable t) {
                 // bad request
                 req.setBroken(true);","[{'comment': 'Just for my curiosity wanted to know, in case if request is broken (I am guessing if we encounter exception and at the catch block means request is broken) then still we are proceeding and bulding the request object ?Is this understanding of my is correct?', 'commenter': 'khanimteyaz'}, {'comment': 'Yes, as far as I know, dubbo has a timeout retry mechanism', 'commenter': 'CrazyHZM'}, {'comment': '@CrazyHZM thanks for info. \r\nIn the scenario if the request broken then still we are proceeding with building the request object and setting flag to indicate broken request (req.setBroken(true)). Just trying to understand (thinking loud 😄 ), after setting `req.setBroken(true)` where and how we are going to leverage this info?', 'commenter': 'khanimteyaz'}, {'comment': 'It was used in handleRequest method of HeaderExchangeHandler.java', 'commenter': 'CrazyHZM'}, {'comment': 'thanks', 'commenter': 'khanimteyaz'}]"
3043,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/Request.java,"@@ -99,6 +99,10 @@ public void setEvent(String event) {
         mData = event;
     }
 
+    public void setEvent(boolean mEvent) {","[{'comment': 'looks like we should remove\r\n\r\n```java\r\n   public void setEvent(String event) {\r\n        mEvent = true;\r\n        mData = event;\r\n    }\r\n```', 'commenter': 'beiwei30'}, {'comment': 'now I see why the original setEvent() is necessary, pls. keep it. Sorry about this.', 'commenter': 'beiwei30'}, {'comment': 'Setting only the mEvent indicate that there an event but it does tell what kind of event it was. So should we set just set single value? I beleive setting only boolean may not provide complete information what do you say?', 'commenter': 'khanimteyaz'}, {'comment': '> Setting only the mEvent indicate that there an event but it does tell what kind of event it was. So should we set just set single value? I beleive setting only boolean may not provide complete information what do you say?\r\n\r\nBecause mData will carry the relevant value, so here is simply to mark whether the request is an event', 'commenter': 'CrazyHZM'}]"
3043,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeServer.java,"@@ -128,7 +128,8 @@ public void startClose() {
 
     private void sendChannelReadOnlyEvent() {
         Request request = new Request();
-        request.setEvent(Request.READONLY_EVENT);
+        request.setEvent(true);","[{'comment': 'the original `setEvent` is necessary to keep, so we will end up with two `setEvent` methods:\r\n\r\n```java\r\nvoid setEvent(bool);\r\nvoid setEvent(String);\r\n```', 'commenter': 'beiwei30'}]"
3090,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java,"@@ -67,139 +67,143 @@
 
     private static final String ACCESS_LOG_KEY = ""dubbo.accesslog"";
 
-    private static final String FILE_DATE_FORMAT = ""yyyyMMdd"";
-
-    private static final String MESSAGE_DATE_FORMAT = ""yyyy-MM-dd HH:mm:ss"";
-
     private static final int LOG_MAX_BUFFER = 5000;
 
     private static final long LOG_OUTPUT_INTERVAL = 5000;
 
-    private final ConcurrentMap<String, Set<String>> logQueue = new ConcurrentHashMap<String, Set<String>>();
+    private static final SimpleDateFormat FILE_DATE_FORMATTER = new SimpleDateFormat(""yyyyMMdd"");
 
-    private final ScheduledExecutorService logScheduled = Executors.newScheduledThreadPool(2, new NamedThreadFactory(""Dubbo-Access-Log"", true));
+    private static final SimpleDateFormat MESSAGE_DATE_FORMATTER = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
 
-    private volatile ScheduledFuture<?> logFuture = null;
+    private final ConcurrentMap<String, Set<AccessLogData>> logQueue = new ConcurrentHashMap<String, Set<AccessLogData>>();
 
-    private void init() {
-        if (logFuture == null) {
-            synchronized (logScheduled) {
-                if (logFuture == null) {
-                    logFuture = logScheduled.scheduleWithFixedDelay(new LogTask(), LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);
-                }
-            }
-        }
-    }
+    private static final ScheduledExecutorService logScheduled = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(""Dubbo-Access-Log"", true));
 
-    private void log(String accesslog, String logmessage) {
-        init();
-        Set<String> logSet = logQueue.get(accesslog);
-        if (logSet == null) {
-            logQueue.putIfAbsent(accesslog, new ConcurrentHashSet<String>());
-            logSet = logQueue.get(accesslog);
-        }
-        if (logSet.size() < LOG_MAX_BUFFER) {
-            logSet.add(logmessage);
+    private static final InternalThreadLocal<SimpleDateFormat> INLINE_MESSAGE_DATE_FORMATTER = new InternalThreadLocal<SimpleDateFormat>() {","[{'comment': 'Seems like this filed is never used.', 'commenter': 'carryxyh'}, {'comment': 'yes. I will remove it.', 'commenter': 'khanimteyaz'}, {'comment': 'done', 'commenter': 'khanimteyaz'}]"
3090,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java,"@@ -67,139 +67,143 @@
 
     private static final String ACCESS_LOG_KEY = ""dubbo.accesslog"";
 
-    private static final String FILE_DATE_FORMAT = ""yyyyMMdd"";
-
-    private static final String MESSAGE_DATE_FORMAT = ""yyyy-MM-dd HH:mm:ss"";
-
     private static final int LOG_MAX_BUFFER = 5000;
 
     private static final long LOG_OUTPUT_INTERVAL = 5000;
 
-    private final ConcurrentMap<String, Set<String>> logQueue = new ConcurrentHashMap<String, Set<String>>();
+    private static final SimpleDateFormat FILE_DATE_FORMATTER = new SimpleDateFormat(""yyyyMMdd"");
 
-    private final ScheduledExecutorService logScheduled = Executors.newScheduledThreadPool(2, new NamedThreadFactory(""Dubbo-Access-Log"", true));
+    private static final SimpleDateFormat MESSAGE_DATE_FORMATTER = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
 
-    private volatile ScheduledFuture<?> logFuture = null;
+    private final ConcurrentMap<String, Set<AccessLogData>> logQueue = new ConcurrentHashMap<String, Set<AccessLogData>>();","[{'comment': 'Can this field be static?', 'commenter': 'carryxyh'}, {'comment': ""I think it make sense now to make it static as it is now bound to single thread. \r\n\r\nIn addition to this, I was thinking (correct me If I am wrong), instead of defining the logQueue as a member of this class, we can it get through a factory (although factory will supply single queue only), so that in future even if we have change it based on our defined we don't have to touch this class. May be we can do this as part of separate PR. What do you say? "", 'commenter': 'khanimteyaz'}, {'comment': ""emmm...\r\nWhat is this factory produce? Maybe I haven't get your point~ Can u give more details?"", 'commenter': 'carryxyh'}, {'comment': 'it provide the storage object which its consumer object, \r\n\r\ne.g.   \r\n   ```\r\nStore store= InMemoryQueueStorageFactory.getInstance().getStore();\r\n   store.add(accessLog);\r\n```\r\n\r\nsomething like above. The above example what I hvae given may not be very intuitive itself for explaination, but  for high level understanding it might help. If you want I might create a sample branch to demonestrate in more detail way by having some implementation. What do you say?', 'commenter': 'khanimteyaz'}, {'comment': 'Personally think that it is not necessary, because it will make the code more complicated. I think that the current structure is relatively simple, haha.', 'commenter': 'carryxyh'}, {'comment': '😄 ', 'commenter': 'khanimteyaz'}]"
3090,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java,"@@ -67,139 +67,143 @@
 
     private static final String ACCESS_LOG_KEY = ""dubbo.accesslog"";
 
-    private static final String FILE_DATE_FORMAT = ""yyyyMMdd"";
-
-    private static final String MESSAGE_DATE_FORMAT = ""yyyy-MM-dd HH:mm:ss"";
-
     private static final int LOG_MAX_BUFFER = 5000;
 
     private static final long LOG_OUTPUT_INTERVAL = 5000;
 
-    private final ConcurrentMap<String, Set<String>> logQueue = new ConcurrentHashMap<String, Set<String>>();
+    private static final SimpleDateFormat FILE_DATE_FORMATTER = new SimpleDateFormat(""yyyyMMdd"");
 
-    private final ScheduledExecutorService logScheduled = Executors.newScheduledThreadPool(2, new NamedThreadFactory(""Dubbo-Access-Log"", true));
+    private static final SimpleDateFormat MESSAGE_DATE_FORMATTER = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
 
-    private volatile ScheduledFuture<?> logFuture = null;
+    private final ConcurrentMap<String, Set<AccessLogData>> logQueue = new ConcurrentHashMap<String, Set<AccessLogData>>();
 
-    private void init() {
-        if (logFuture == null) {
-            synchronized (logScheduled) {
-                if (logFuture == null) {
-                    logFuture = logScheduled.scheduleWithFixedDelay(new LogTask(), LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);
-                }
-            }
-        }
-    }
+    private static final ScheduledExecutorService logScheduled = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(""Dubbo-Access-Log"", true));
 
-    private void log(String accesslog, String logmessage) {
-        init();
-        Set<String> logSet = logQueue.get(accesslog);
-        if (logSet == null) {
-            logQueue.putIfAbsent(accesslog, new ConcurrentHashSet<String>());
-            logSet = logQueue.get(accesslog);
-        }
-        if (logSet.size() < LOG_MAX_BUFFER) {
-            logSet.add(logmessage);
+    private static final InternalThreadLocal<SimpleDateFormat> INLINE_MESSAGE_DATE_FORMATTER = new InternalThreadLocal<SimpleDateFormat>() {
+        @Override
+        protected SimpleDateFormat initialValue() {
+            return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
         }
+    };
+
+    /**
+     * Default constructor initialize demon thread for writing into access log file with names with access log key
+     * defined in url <b>accesslog</b>
+     */
+    public AccessLogFilter() {
+        logScheduled.scheduleWithFixedDelay(this::writeLogToFile, LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);
     }
 
+    /**
+     * This method logs the access log for service method invocation call.
+     *
+     * @param invoker service
+     * @param inv     Invocation service method.
+     * @return Result from service method.
+     * @throws RpcException
+     */
+","[{'comment': 'remove this line.\r\n:)', 'commenter': 'carryxyh'}, {'comment': 'I think, I did not understand this one. Which line you wanted me to remove?', 'commenter': 'khanimteyaz'}, {'comment': '105，seems like this line separate the doc and the code?\r\n:)', 'commenter': 'carryxyh'}, {'comment': 'ok. got it.', 'commenter': 'khanimteyaz'}, {'comment': 'Done.', 'commenter': 'khanimteyaz'}]"
3090,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java,"@@ -67,139 +67,143 @@
 
     private static final String ACCESS_LOG_KEY = ""dubbo.accesslog"";
 
-    private static final String FILE_DATE_FORMAT = ""yyyyMMdd"";
-
-    private static final String MESSAGE_DATE_FORMAT = ""yyyy-MM-dd HH:mm:ss"";
-
     private static final int LOG_MAX_BUFFER = 5000;
 
     private static final long LOG_OUTPUT_INTERVAL = 5000;
 
-    private final ConcurrentMap<String, Set<String>> logQueue = new ConcurrentHashMap<String, Set<String>>();
+    private static final SimpleDateFormat FILE_DATE_FORMATTER = new SimpleDateFormat(""yyyyMMdd"");
 
-    private final ScheduledExecutorService logScheduled = Executors.newScheduledThreadPool(2, new NamedThreadFactory(""Dubbo-Access-Log"", true));
+    private static final SimpleDateFormat MESSAGE_DATE_FORMATTER = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
 
-    private volatile ScheduledFuture<?> logFuture = null;
+    private final ConcurrentMap<String, Set<AccessLogData>> logQueue = new ConcurrentHashMap<String, Set<AccessLogData>>();
 
-    private void init() {
-        if (logFuture == null) {
-            synchronized (logScheduled) {
-                if (logFuture == null) {
-                    logFuture = logScheduled.scheduleWithFixedDelay(new LogTask(), LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);
-                }
-            }
-        }
-    }
+    private static final ScheduledExecutorService logScheduled = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(""Dubbo-Access-Log"", true));
 
-    private void log(String accesslog, String logmessage) {
-        init();
-        Set<String> logSet = logQueue.get(accesslog);
-        if (logSet == null) {
-            logQueue.putIfAbsent(accesslog, new ConcurrentHashSet<String>());
-            logSet = logQueue.get(accesslog);
-        }
-        if (logSet.size() < LOG_MAX_BUFFER) {
-            logSet.add(logmessage);
+    private static final InternalThreadLocal<SimpleDateFormat> INLINE_MESSAGE_DATE_FORMATTER = new InternalThreadLocal<SimpleDateFormat>() {
+        @Override
+        protected SimpleDateFormat initialValue() {
+            return new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
         }
+    };
+
+    /**
+     * Default constructor initialize demon thread for writing into access log file with names with access log key
+     * defined in url <b>accesslog</b>
+     */
+    public AccessLogFilter() {
+        logScheduled.scheduleWithFixedDelay(this::writeLogToFile, LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);
     }
 
+    /**
+     * This method logs the access log for service method invocation call.
+     *
+     * @param invoker service
+     * @param inv     Invocation service method.
+     * @return Result from service method.
+     * @throws RpcException
+     */
+
     @Override
     public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
         try {
-            String accesslog = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);
-            if (ConfigUtils.isNotEmpty(accesslog)) {
-                RpcContext context = RpcContext.getContext();
-                String serviceName = invoker.getInterface().getName();
-                String version = invoker.getUrl().getParameter(Constants.VERSION_KEY);
-                String group = invoker.getUrl().getParameter(Constants.GROUP_KEY);
-                StringBuilder sn = new StringBuilder();
-                sn.append(""["").append(new SimpleDateFormat(MESSAGE_DATE_FORMAT).format(new Date())).append(""] "").append(context.getRemoteHost()).append("":"").append(context.getRemotePort())
-                        .append("" -> "").append(context.getLocalHost()).append("":"").append(context.getLocalPort())
-                        .append("" - "");
-                if (null != group && group.length() > 0) {
-                    sn.append(group).append(""/"");
-                }
-                sn.append(serviceName);
-                if (null != version && version.length() > 0) {
-                    sn.append("":"").append(version);
-                }
-                sn.append("" "");
-                sn.append(inv.getMethodName());
-                sn.append(""("");
-                Class<?>[] types = inv.getParameterTypes();
-                if (types != null && types.length > 0) {
-                    boolean first = true;
-                    for (Class<?> type : types) {
-                        if (first) {
-                            first = false;
-                        } else {
-                            sn.append("","");
-                        }
-                        sn.append(type.getName());
-                    }
-                }
-                sn.append("") "");
-                Object[] args = inv.getArguments();
-                if (args != null && args.length > 0) {
-                    sn.append(JSON.toJSONString(args));
-                }
-                String msg = sn.toString();
-                if (ConfigUtils.isDefault(accesslog)) {
-                    LoggerFactory.getLogger(ACCESS_LOG_KEY + ""."" + invoker.getInterface().getName()).info(msg);
-                } else {
-                    log(accesslog, msg);
-                }
+            String accessLogKey = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);
+            if (ConfigUtils.isNotEmpty(accessLogKey)) {
+                AccessLogData logData = buildAccessLogData(invoker, inv);
+                log(accessLogKey, logData);
             }
         } catch (Throwable t) {
             logger.warn(""Exception in AcessLogFilter of service("" + invoker + "" -> "" + inv + "")"", t);
         }
         return invoker.invoke(inv);
     }
 
-    private class LogTask implements Runnable {
-        @Override
-        public void run() {
-            try {
-                if (logQueue != null && logQueue.size() > 0) {
-                    for (Map.Entry<String, Set<String>> entry : logQueue.entrySet()) {
-                        try {
-                            String accesslog = entry.getKey();
-                            Set<String> logSet = entry.getValue();
-                            File file = new File(accesslog);
-                            File dir = file.getParentFile();
-                            if (null != dir && !dir.exists()) {
-                                dir.mkdirs();
-                            }
-                            if (logger.isDebugEnabled()) {
-                                logger.debug(""Append log to "" + accesslog);
-                            }
-                            if (file.exists()) {
-                                String now = new SimpleDateFormat(FILE_DATE_FORMAT).format(new Date());
-                                String last = new SimpleDateFormat(FILE_DATE_FORMAT).format(new Date(file.lastModified()));
-                                if (!now.equals(last)) {
-                                    File archive = new File(file.getAbsolutePath() + ""."" + last);
-                                    file.renameTo(archive);
-                                }
-                            }
-                            FileWriter writer = new FileWriter(file, true);
-                            try {
-                                for (Iterator<String> iterator = logSet.iterator();
-                                     iterator.hasNext();
-                                     iterator.remove()) {
-                                    writer.write(iterator.next());
-                                    writer.write(""\r\n"");
-                                }
-                                writer.flush();
-                            } finally {
-                                writer.close();
-                            }
-                        } catch (Exception e) {
-                            logger.error(e.getMessage(), e);
+    private void log(String accessLog, AccessLogData accessLogData) {
+        Set<AccessLogData> logSet = logQueue.get(accessLog);","[{'comment': 'Can we use computeIfAbsent to optimize this?', 'commenter': 'carryxyh'}, {'comment': 'Done.', 'commenter': 'khanimteyaz'}]"
3090,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/AccessLogData.java,"@@ -0,0 +1,255 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.support;
+
+import com.alibaba.fastjson.JSON;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.RpcContext;
+
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * AccessLogData is a container for log event data. In internally uses map and store each filed of log as value. It does not generate any
+ * dynamic value e.g. time stamp, local jmv machine host address etc. It does not allow any null or empty key.
+ */
+public final class AccessLogData {
+    /**
+     * Access log keys
+     */
+    private enum KEYS {
+        VERSION, GROUP, SERVICE, METHOD_NAME, INVOCATION_TIME, TYPES","[{'comment': 'Why not make this to be fileds like:\r\n```\r\nprivate String group;\r\nprivate String version;\r\n...\r\n```', 'commenter': 'carryxyh'}, {'comment': 'Yes we make. The only reason I avoid it was, double type one for defining variable and second for value of the variable, e.g. \r\nprivate String group=""group"" \r\n\r\nwhere using enum, the enum filed it self serve the both.\r\nI will modify it.', 'commenter': 'khanimteyaz'}, {'comment': 'Done', 'commenter': 'khanimteyaz'}]"
3093,dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassHelper.java,"@@ -265,26 +264,33 @@ public static boolean isPrimitive(Class<?> type) {
     }
 
     public static Object convertPrimitive(Class<?> type, String value) {
-        if (type == char.class || type == Character.class) {
+        if (value == null) {","[{'comment': 'I think \r\n```\r\nif(value==null || !isNumber(value)) { \r\n    return null;\r\n}\r\n```\r\n\r\nshould be good enough for all these, is it it?', 'commenter': 'khanimteyaz'}, {'comment': 'If you do this, values \u200b\u200bthat are not numeric will also return null. \r\nfor example `value = “true”`', 'commenter': 'CrazyHZM'}, {'comment': 'ok', 'commenter': 'khanimteyaz'}]"
3093,dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassHelper.java,"@@ -265,26 +264,33 @@ public static boolean isPrimitive(Class<?> type) {
     }
 
     public static Object convertPrimitive(Class<?> type, String value) {
-        if (type == char.class || type == Character.class) {
+        if (value == null) {
+            return null;
+        } else if (type == char.class || type == Character.class) {
             return value.length() > 0 ? value.charAt(0) : '\0';
         } else if (type == boolean.class || type == Boolean.class) {
             return Boolean.valueOf(value);
         } else if (type == byte.class || type == Byte.class) {
-            return Byte.valueOf(value);
+            return isNumber(value) ? Byte.valueOf(value) : null;
         } else if (type == short.class || type == Short.class) {
-            return Short.valueOf(value);
+            return isNumber(value) ? Short.valueOf(value) : null;
         } else if (type == int.class || type == Integer.class) {
-            return Integer.valueOf(value);
+            return isNumber(value) ? Integer.valueOf(value) : null;
         } else if (type == long.class || type == Long.class) {
-            return Long.valueOf(value);
+            return isNumber(value) ? Long.valueOf(value) : null;
         } else if (type == float.class || type == Float.class) {
-            return Float.valueOf(value);
+            return isNumber(value) ? Float.valueOf(value) : null;
         } else if (type == double.class || type == Double.class) {
-            return Double.valueOf(value);
+            return isNumber(value) ? Double.valueOf(value) : null;
         }
         return value;
     }
 
+    public static boolean isNumber(String str) {
+        String reg = ""^[0-9]+(.[0-9]+)?$"";","[{'comment': 'Personally, I think that variables like this can be moved into Constants class.', 'commenter': 'lixiaojiee'}, {'comment': 'Thanks, this is a good idea. I will modify it.', 'commenter': 'CrazyHZM'}, {'comment': '@CrazyHZM are you planning to move this to Constants file?', 'commenter': 'khanimteyaz'}, {'comment': '> @CrazyHZM are you planning to move this to Constants file?\r\nI have removed it since the last change.', 'commenter': 'CrazyHZM'}, {'comment': 'I can still see `^[0-9]+(.[0-9]+)?$` here, is there any thing which I am missing?', 'commenter': 'khanimteyaz'}]"
3093,dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassHelper.java,"@@ -265,26 +266,38 @@ public static boolean isPrimitive(Class<?> type) {
     }
 
     public static Object convertPrimitive(Class<?> type, String value) {
-        if (type == char.class || type == Character.class) {
+        if (value == null) {
+            return null;
+        } else if (type == char.class || type == Character.class) {
             return value.length() > 0 ? value.charAt(0) : '\0';
         } else if (type == boolean.class || type == Boolean.class) {
             return Boolean.valueOf(value);
         } else if (type == byte.class || type == Byte.class) {
-            return Byte.valueOf(value);
+            return isNumber(value) ? Byte.valueOf(value) : null;","[{'comment': ""I don't think it is a good way to use regular express to check whether it is a number before doing the conversion, which is quite expensive. Please take a look at org.apache.dubbo.common.utils.StringUtils#isNumeric()"", 'commenter': 'ralf0131'}, {'comment': 'This method cannot exclude numbers with decimal points.', 'commenter': 'CrazyHZM'}, {'comment': 'Maybe you can enhance it based on the logic provided in `org.apache.dubbo.common.utils.StringUtils#isNumeric()`', 'commenter': 'ralf0131'}, {'comment': 'thanks,I will modify it.', 'commenter': 'CrazyHZM'}]"
3093,dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java,"@@ -491,6 +490,25 @@ public static boolean isNumeric(String str) {
         return true;
     }
 
+    public static boolean isNumber(String str) {","[{'comment': ""How about something like this:\r\n\r\n```java\r\npublic static boolean isNumeric(String str, boolean allowDot) {\r\n        if (str == null) {\r\n            return false;\r\n        }\r\n        int sz = str.length();\r\n        for (int i = 0; i < sz; i++) {\r\n            if ((!allowDot && str.charAt(i) == '.') || !Character.isDigit(str.charAt(i))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n```\r\n\r\nNot tested yet. Just for your information. In this way we can unify the logic into one method.\r\nAnd call isNumeric(value, true) from ClassHelper."", 'commenter': 'ralf0131'}, {'comment': 'I have modified it.', 'commenter': 'CrazyHZM'}]"
3093,dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassHelper.java,"@@ -265,26 +265,29 @@ public static boolean isPrimitive(Class<?> type) {
     }
 
     public static Object convertPrimitive(Class<?> type, String value) {
-        if (type == char.class || type == Character.class) {
+        if (value == null) {
+            return null;
+        } else if (type == char.class || type == Character.class) {
             return value.length() > 0 ? value.charAt(0) : '\0';
         } else if (type == boolean.class || type == Boolean.class) {
             return Boolean.valueOf(value);
         } else if (type == byte.class || type == Byte.class) {
-            return Byte.valueOf(value);
+            return StringUtils.isNumber(value) ? Byte.valueOf(value) : null;","[{'comment': 'No need to call `StringUtils.isNumber(value)` every time. We can put it in front.', 'commenter': 'ralf0131'}, {'comment': 'It may not be these eight types, if it is placed in front, exporterMethodConfigUrlTest will not pass', 'commenter': 'CrazyHZM'}]"
3093,dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java,"@@ -478,10 +477,23 @@ public static boolean isContains(String[] values, String value) {
         return false;
     }
 
-    public static boolean isNumeric(String str) {
-        if (str == null) {
+    public static boolean isNumeric(String str, boolean allowDot) {
+        if (str == null || str.isEmpty()) {
             return false;
         }
+        if (allowDot) {","[{'comment': 'Can handle something like "".1"" or not?', 'commenter': 'kun-song'}, {'comment': 'StringUtils.isNumeric(left, false) && StringUtils.isNumeric(right, false)', 'commenter': 'CrazyHZM'}, {'comment': '```\r\nint index = str.indexOf(""."");\r\nif (index > 0) { ... }\r\n```\r\n\r\nWhen faced with .1, it would not go into `StringUtils.isNumeric(left, false) && StringUtils.isNumeric(right, false)`.', 'commenter': 'kun-song'}, {'comment': ""That's no problem, it will go to the logic below and it will return false."", 'commenter': 'CrazyHZM'}, {'comment': '`Double.valueOf("".1""))` will produce 0.1, so I personally think it\'s better to support this pattern.', 'commenter': 'kun-song'}, {'comment': 'Hi,\r\n\r\nI am not a fan of recursive call, especially for such a small function. I think this can be implemented by at most 2 for loops.\r\n\r\nCan you replace it by a non-recursive call?', 'commenter': 'ralf0131'}, {'comment': 'I have modified it.', 'commenter': 'CrazyHZM'}, {'comment': 'Hi, \r\n\r\nHow about this:\r\n\r\n```java\r\npublic static boolean isNumeric(String str, boolean allowDot) {\r\n        if (str == null || str.isEmpty()) {\r\n            return false;\r\n        }\r\n        int dotCount = 0;\r\n        for (int i = 0; i < str.length(); i++) {\r\n            if (str.charAt(i) == \'.\') {\r\n                if (allowDot && dotCount == 0) {\r\n                    dotCount++;\r\n                    continue;\r\n                } else {\r\n                    return false;\r\n                }\r\n            }\r\n            if (!Character.isDigit(str.charAt(i))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n```\r\n\r\nThis only need 1 loop. And also support something like ""1."" as a numeric.\r\n\r\n```\r\njshell> Double.valueOf(""1."")\r\n$1 ==> 1.0\r\n```\r\n\r\nI also add some more unit test\r\n\r\n```java\r\nassertThat(StringUtils.isNumeric(""123.3.3"", true), is(false));\r\nassertThat(StringUtils.isNumeric(""123."", true), is(true));\r\n```\r\n', 'commenter': 'ralf0131'}, {'comment': 'So is there a support for “.1”?', 'commenter': 'CrazyHZM'}, {'comment': 'Definitely yes. You can add it to the UT.', 'commenter': 'ralf0131'}, {'comment': 'I have modified it .', 'commenter': 'CrazyHZM'}, {'comment': 'Still not convinced yet. Why are you need an extra call to String.indexOf? Why should we separate the logic into if-else? There is no need to do that, we can do that in only one for loop. Your implementation need at lease 2 for loop (one is String.indexOf, the other is the for loop you write), which is not every elegant from my point of view.', 'commenter': 'ralf0131'}]"
3093,dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassHelper.java,"@@ -265,26 +265,29 @@ public static boolean isPrimitive(Class<?> type) {
     }
 
     public static Object convertPrimitive(Class<?> type, String value) {
-        if (type == char.class || type == Character.class) {
+        if (value == null) {
+            return null;
+        } else if (type == char.class || type == Character.class) {
             return value.length() > 0 ? value.charAt(0) : '\0';
         } else if (type == boolean.class || type == Boolean.class) {
             return Boolean.valueOf(value);
         } else if (type == byte.class || type == Byte.class) {
-            return Byte.valueOf(value);
+            return StringUtils.isNumeric(value, false) ? Byte.valueOf(value) : null;","[{'comment': ""I am not persuaded that 'StringUtils.isNumeric()' is required here. In my opinion, JDK has already offered the nice API and we should stick to it. What we need to do is to catch **NumberFormatException** and return 'null' if necessary."", 'commenter': 'beiwei30'}, {'comment': 'I think this is good, but I think the function enhancement of `StringUtils.isNumeric()` is not necessary to delete it. What do you think?', 'commenter': 'CrazyHZM'}]"
3102,dubbo-registry/dubbo-registry-api/src/test/java/org/apache/dubbo/registry/support/AbstractRegistryTest.java,"@@ -18,20 +18,14 @@
 
 import org.apache.dubbo.common.Constants;
 import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.utils.NetUtils;
 import org.apache.dubbo.registry.NotifyListener;
 import org.hamcrest.Matchers;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
+import java.util.*;","[{'comment': 'It is better to keep the specified class rather that importing everything.', 'commenter': 'ralf0131'}, {'comment': 'Resonable!', 'commenter': 'kezhenxu94'}]"
3102,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"@@ -1,501 +1,491 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.registry.support;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.ConcurrentHashSet;
-import org.apache.dubbo.common.utils.ConfigUtils;
-import org.apache.dubbo.common.utils.NamedThreadFactory;
-import org.apache.dubbo.common.utils.UrlUtils;
-import org.apache.dubbo.registry.NotifyListener;
-import org.apache.dubbo.registry.Registry;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.RandomAccessFile;
-import java.nio.channels.FileChannel;
-import java.nio.channels.FileLock;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicReference;
-
-/**
- * AbstractRegistry. (SPI, Prototype, ThreadSafe)
- *
- */
-public abstract class AbstractRegistry implements Registry {
-
-    // URL address separator, used in file cache, service provider URL separation
-    private static final char URL_SEPARATOR = ' ';
-    // URL address separated regular expression for parsing the service provider URL list in the file cache
-    private static final String URL_SPLIT = ""\\s+"";
-    // Log output
-    protected final Logger logger = LoggerFactory.getLogger(getClass());
-    // Local disk cache, where the special key value.registies records the list of registry centers, and the others are the list of notified service providers
-    private final Properties properties = new Properties();
-    // File cache timing writing
-    private final ExecutorService registryCacheExecutor = Executors.newFixedThreadPool(1, new NamedThreadFactory(""DubboSaveRegistryCache"", true));
-    // Is it synchronized to save the file
-    private final boolean syncSaveFile;
-    private final AtomicLong lastCacheChanged = new AtomicLong();
-    private final Set<URL> registered = new ConcurrentHashSet<URL>();
-    private final ConcurrentMap<URL, Set<NotifyListener>> subscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();
-    private final ConcurrentMap<URL, Map<String, List<URL>>> notified = new ConcurrentHashMap<URL, Map<String, List<URL>>>();
-    private URL registryUrl;
-    // Local disk cache file
-    private File file;
-
-    public AbstractRegistry(URL url) {
-        setUrl(url);
-        // Start file save timer
-        syncSaveFile = url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, false);
-        String filename = url.getParameter(Constants.FILE_KEY, System.getProperty(""user.home"") + ""/.dubbo/dubbo-registry-"" + url.getParameter(Constants.APPLICATION_KEY) + ""-"" + url.getAddress() + "".cache"");
-        File file = null;
-        if (ConfigUtils.isNotEmpty(filename)) {
-            file = new File(filename);
-            if (!file.exists() && file.getParentFile() != null && !file.getParentFile().exists()) {
-                if (!file.getParentFile().mkdirs()) {
-                    throw new IllegalArgumentException(""Invalid registry store file "" + file + "", cause: Failed to create directory "" + file.getParentFile() + ""!"");
-                }
-            }
-        }
-        this.file = file;
-        loadProperties();
-        notify(url.getBackupUrls());
-    }
-
-    protected static List<URL> filterEmpty(URL url, List<URL> urls) {
-        if (urls == null || urls.isEmpty()) {
-            List<URL> result = new ArrayList<URL>(1);
-            result.add(url.setProtocol(Constants.EMPTY_PROTOCOL));
-            return result;
-        }
-        return urls;
-    }
-
-    @Override
-    public URL getUrl() {
-        return registryUrl;
-    }
-
-    protected void setUrl(URL url) {
-        if (url == null) {
-            throw new IllegalArgumentException(""registry url == null"");
-        }
-        this.registryUrl = url;
-    }
-
-    public Set<URL> getRegistered() {
-        return registered;
-    }
-
-    public Map<URL, Set<NotifyListener>> getSubscribed() {
-        return subscribed;
-    }
-
-    public Map<URL, Map<String, List<URL>>> getNotified() {
-        return notified;
-    }
-
-    public File getCacheFile() {
-        return file;
-    }
-
-    public Properties getCacheProperties() {
-        return properties;
-    }
-
-    public AtomicLong getLastCacheChanged() {
-        return lastCacheChanged;
-    }
-
-    public void doSaveProperties(long version) {
-        if (version < lastCacheChanged.get()) {
-            return;
-        }
-        if (file == null) {
-            return;
-        }
-        // Save
-        try {
-            File lockfile = new File(file.getAbsolutePath() + "".lock"");
-            if (!lockfile.exists()) {
-                lockfile.createNewFile();
-            }
-            RandomAccessFile raf = new RandomAccessFile(lockfile, ""rw"");
-            try {
-                FileChannel channel = raf.getChannel();
-                try {
-                    FileLock lock = channel.tryLock();
-                    if (lock == null) {
-                        throw new IOException(""Can not lock the registry cache file "" + file.getAbsolutePath() + "", ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties"");
-                    }
-                    // Save
-                    try {
-                        if (!file.exists()) {
-                            file.createNewFile();
-                        }
-                        FileOutputStream outputFile = new FileOutputStream(file);
-                        try {
-                            properties.store(outputFile, ""Dubbo Registry Cache"");
-                        } finally {
-                            outputFile.close();
-                        }
-                    } finally {
-                        lock.release();
-                    }
-                } finally {
-                    channel.close();
-                }
-            } finally {
-                raf.close();
-            }
-        } catch (Throwable e) {
-            if (version < lastCacheChanged.get()) {
-                return;
-            } else {
-                registryCacheExecutor.execute(new SaveProperties(lastCacheChanged.incrementAndGet()));
-            }
-            logger.warn(""Failed to save registry store file, cause: "" + e.getMessage(), e);
-        }
-    }
-
-    private void loadProperties() {
-        if (file != null && file.exists()) {
-            InputStream in = null;
-            try {
-                in = new FileInputStream(file);
-                properties.load(in);
-                if (logger.isInfoEnabled()) {
-                    logger.info(""Load registry store file "" + file + "", data: "" + properties);
-                }
-            } catch (Throwable e) {
-                logger.warn(""Failed to load registry store file "" + file, e);
-            } finally {
-                if (in != null) {
-                    try {
-                        in.close();
-                    } catch (IOException e) {
-                        logger.warn(e.getMessage(), e);
-                    }
-                }
-            }
-        }
-    }
-
-    public List<URL> getCacheUrls(URL url) {
-        for (Map.Entry<Object, Object> entry : properties.entrySet()) {
-            String key = (String) entry.getKey();
-            String value = (String) entry.getValue();
-            if (key != null && key.length() > 0 && key.equals(url.getServiceKey())
-                    && (Character.isLetter(key.charAt(0)) || key.charAt(0) == '_')
-                    && value != null && value.length() > 0) {
-                String[] arr = value.trim().split(URL_SPLIT);
-                List<URL> urls = new ArrayList<URL>();
-                for (String u : arr) {
-                    urls.add(URL.valueOf(u));
-                }
-                return urls;
-            }
-        }
-        return null;
-    }
-
-    @Override
-    public List<URL> lookup(URL url) {
-        List<URL> result = new ArrayList<URL>();
-        Map<String, List<URL>> notifiedUrls = getNotified().get(url);
-        if (notifiedUrls != null && notifiedUrls.size() > 0) {
-            for (List<URL> urls : notifiedUrls.values()) {
-                for (URL u : urls) {
-                    if (!Constants.EMPTY_PROTOCOL.equals(u.getProtocol())) {
-                        result.add(u);
-                    }
-                }
-            }
-        } else {
-            final AtomicReference<List<URL>> reference = new AtomicReference<List<URL>>();
-            NotifyListener listener = reference::set;
-            subscribe(url, listener); // Subscribe logic guarantees the first notify to return
-            List<URL> urls = reference.get();
-            if (urls != null && !urls.isEmpty()) {
-                for (URL u : urls) {
-                    if (!Constants.EMPTY_PROTOCOL.equals(u.getProtocol())) {
-                        result.add(u);
-                    }
-                }
-            }
-        }
-        return result;
-    }
-
-    @Override
-    public void register(URL url) {
-        if (url == null) {
-            throw new IllegalArgumentException(""register url == null"");
-        }
-        if (logger.isInfoEnabled()) {
-            logger.info(""Register: "" + url);
-        }
-        registered.add(url);
-    }
-
-    @Override
-    public void unregister(URL url) {
-        if (url == null) {
-            throw new IllegalArgumentException(""unregister url == null"");
-        }
-        if (logger.isInfoEnabled()) {
-            logger.info(""Unregister: "" + url);
-        }
-        registered.remove(url);
-    }
-
-    @Override
-    public void subscribe(URL url, NotifyListener listener) {
-        if (url == null) {
-            throw new IllegalArgumentException(""subscribe url == null"");
-        }
-        if (listener == null) {
-            throw new IllegalArgumentException(""subscribe listener == null"");
-        }
-        if (logger.isInfoEnabled()) {
-            logger.info(""Subscribe: "" + url);
-        }
-        Set<NotifyListener> listeners = subscribed.get(url);
-        if (listeners == null) {
-            subscribed.putIfAbsent(url, new ConcurrentHashSet<NotifyListener>());
-            listeners = subscribed.get(url);
-        }
-        listeners.add(listener);
-    }
-
-    @Override
-    public void unsubscribe(URL url, NotifyListener listener) {
-        if (url == null) {
-            throw new IllegalArgumentException(""unsubscribe url == null"");
-        }
-        if (listener == null) {
-            throw new IllegalArgumentException(""unsubscribe listener == null"");
-        }
-        if (logger.isInfoEnabled()) {
-            logger.info(""Unsubscribe: "" + url);
-        }
-        Set<NotifyListener> listeners = subscribed.get(url);
-        if (listeners != null) {
-            listeners.remove(listener);
-        }
-    }
-
-    protected void recover() throws Exception {
-        // register
-        Set<URL> recoverRegistered = new HashSet<URL>(getRegistered());
-        if (!recoverRegistered.isEmpty()) {
-            if (logger.isInfoEnabled()) {
-                logger.info(""Recover register url "" + recoverRegistered);
-            }
-            for (URL url : recoverRegistered) {
-                register(url);
-            }
-        }
-        // subscribe
-        Map<URL, Set<NotifyListener>> recoverSubscribed = new HashMap<URL, Set<NotifyListener>>(getSubscribed());
-        if (!recoverSubscribed.isEmpty()) {
-            if (logger.isInfoEnabled()) {
-                logger.info(""Recover subscribe url "" + recoverSubscribed.keySet());
-            }
-            for (Map.Entry<URL, Set<NotifyListener>> entry : recoverSubscribed.entrySet()) {
-                URL url = entry.getKey();
-                for (NotifyListener listener : entry.getValue()) {
-                    subscribe(url, listener);
-                }
-            }
-        }
-    }
-
-    protected void notify(List<URL> urls) {
-        if (urls == null || urls.isEmpty()) {
-            return;
-        }
-
-        for (Map.Entry<URL, Set<NotifyListener>> entry : getSubscribed().entrySet()) {
-            URL url = entry.getKey();
-
-            if (!UrlUtils.isMatch(url, urls.get(0))) {
-                continue;
-            }
-
-            Set<NotifyListener> listeners = entry.getValue();
-            if (listeners != null) {
-                for (NotifyListener listener : listeners) {
-                    try {
-                        notify(url, listener, filterEmpty(url, urls));
-                    } catch (Throwable t) {
-                        logger.error(""Failed to notify registry event, urls: "" + urls + "", cause: "" + t.getMessage(), t);
-                    }
-                }
-            }
-        }
-    }
-
-    protected void notify(URL url, NotifyListener listener, List<URL> urls) {
-        if (url == null) {
-            throw new IllegalArgumentException(""notify url == null"");
-        }
-        if (listener == null) {
-            throw new IllegalArgumentException(""notify listener == null"");
-        }
-        if ((urls == null || urls.isEmpty())
-                && !Constants.ANY_VALUE.equals(url.getServiceInterface())) {
-            logger.warn(""Ignore empty notify urls for subscribe url "" + url);
-            return;
-        }
-        if (logger.isInfoEnabled()) {
-            logger.info(""Notify urls for subscribe url "" + url + "", urls: "" + urls);
-        }
-        Map<String, List<URL>> result = new HashMap<String, List<URL>>();
-        for (URL u : urls) {
-            if (UrlUtils.isMatch(url, u)) {
-                String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);
-                List<URL> categoryList = result.get(category);
-                if (categoryList == null) {
-                    categoryList = new ArrayList<URL>();
-                    result.put(category, categoryList);
-                }
-                categoryList.add(u);
-            }
-        }
-        if (result.size() == 0) {
-            return;
-        }
-        Map<String, List<URL>> categoryNotified = notified.get(url);
-        if (categoryNotified == null) {
-            notified.putIfAbsent(url, new ConcurrentHashMap<String, List<URL>>());
-            categoryNotified = notified.get(url);
-        }
-        for (Map.Entry<String, List<URL>> entry : result.entrySet()) {
-            String category = entry.getKey();
-            List<URL> categoryList = entry.getValue();
-            categoryNotified.put(category, categoryList);
-            saveProperties(url);
-            listener.notify(categoryList);
-        }
-    }
-
-    private void saveProperties(URL url) {
-        if (file == null) {
-            return;
-        }
-
-        try {
-            StringBuilder buf = new StringBuilder();
-            Map<String, List<URL>> categoryNotified = notified.get(url);
-            if (categoryNotified != null) {
-                for (List<URL> us : categoryNotified.values()) {
-                    for (URL u : us) {
-                        if (buf.length() > 0) {
-                            buf.append(URL_SEPARATOR);
-                        }
-                        buf.append(u.toFullString());
-                    }
-                }
-            }
-            properties.setProperty(url.getServiceKey(), buf.toString());
-            long version = lastCacheChanged.incrementAndGet();
-            if (syncSaveFile) {
-                doSaveProperties(version);
-            } else {
-                registryCacheExecutor.execute(new SaveProperties(version));
-            }
-        } catch (Throwable t) {
-            logger.warn(t.getMessage(), t);
-        }
-    }
-
-    @Override
-    public void destroy() {
-        if (logger.isInfoEnabled()) {
-            logger.info(""Destroy registry:"" + getUrl());
-        }
-        Set<URL> destroyRegistered = new HashSet<URL>(getRegistered());
-        if (!destroyRegistered.isEmpty()) {
-            for (URL url : new HashSet<URL>(getRegistered())) {
-                if (url.getParameter(Constants.DYNAMIC_KEY, true)) {
-                    try {
-                        unregister(url);
-                        if (logger.isInfoEnabled()) {
-                            logger.info(""Destroy unregister url "" + url);
-                        }
-                    } catch (Throwable t) {
-                        logger.warn(""Failed to unregister url "" + url + "" to registry "" + getUrl() + "" on destroy, cause: "" + t.getMessage(), t);
-                    }
-                }
-            }
-        }
-        Map<URL, Set<NotifyListener>> destroySubscribed = new HashMap<URL, Set<NotifyListener>>(getSubscribed());
-        if (!destroySubscribed.isEmpty()) {
-            for (Map.Entry<URL, Set<NotifyListener>> entry : destroySubscribed.entrySet()) {
-                URL url = entry.getKey();
-                for (NotifyListener listener : entry.getValue()) {
-                    try {
-                        unsubscribe(url, listener);
-                        if (logger.isInfoEnabled()) {
-                            logger.info(""Destroy unsubscribe url "" + url);
-                        }
-                    } catch (Throwable t) {
-                        logger.warn(""Failed to unsubscribe url "" + url + "" to registry "" + getUrl() + "" on destroy, cause: "" + t.getMessage(), t);
-                    }
-                }
-            }
-        }
-    }
-
-    @Override
-    public String toString() {
-        return getUrl().toString();
-    }
-
-    private class SaveProperties implements Runnable {
-        private long version;
-
-        private SaveProperties(long version) {
-            this.version = version;
-        }
-
-        @Override
-        public void run() {
-            doSaveProperties(version);
-        }
-    }
-
-}
+/*","[{'comment': 'Why are you changing the entire file?', 'commenter': 'ralf0131'}, {'comment': ""It's likely the behaviours of the IDE, I'll update to avoid this"", 'commenter': 'kezhenxu94'}, {'comment': 'Hi, I am still seeing this. All the lines has been changed. Please take a look.', 'commenter': 'ralf0131'}, {'comment': '@kezhenxu94  could you please check what has changed here? ', 'commenter': 'khanimteyaz'}, {'comment': ""@khanimteyaz That's wired, I check it in the GitHub diff page and there is no such problem, are you sure you are looking at the [latest commit](https://github.com/apache/incubator-dubbo/commit/e0d3757d301797c054a9f7f142d1df4fd1303ac8)."", 'commenter': 'kezhenxu94'}, {'comment': '@kezhenxu94 Please check https://github.com/apache/incubator-dubbo/pull/3102/files , this issue still exist. All the lines of AbstractRegistry has been changed.', 'commenter': 'ralf0131'}, {'comment': ""@ralf0131 Thanks, I've updated again, now I saw `+98 −125` and it should be fixed now."", 'commenter': 'kezhenxu94'}]"
3102,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"@@ -383,15 +374,14 @@ protected void notify(URL url, NotifyListener listener, List<URL> urls) {
         if (logger.isInfoEnabled()) {
             logger.info(""Notify urls for subscribe url "" + url + "", urls: "" + urls);
         }
-        Map<String, List<URL>> result = new HashMap<String, List<URL>>();
+        if (urls == null) {","[{'comment': 'It is better to put these line before Line 374, and log warn message before return.', 'commenter': 'ralf0131'}, {'comment': 'Done as requested', 'commenter': 'kezhenxu94'}]"
3102,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"@@ -96,7 +96,7 @@ public AbstractRegistry(URL url) {
 
     protected static List<URL> filterEmpty(URL url, List<URL> urls) {
         if (urls == null || urls.isEmpty()) {
-            List<URL> result = new ArrayList<URL>(1);
+            List<URL> result = new ArrayList<>(1);
             result.add(url.setProtocol(Constants.EMPTY_PROTOCOL));","[{'comment': 'curious to know why we to change the protocol type?', 'commenter': 'khanimteyaz'}, {'comment': ""I didn't change the protocol type here"", 'commenter': 'kezhenxu94'}, {'comment': 'I might be wrong but just to be see sure we are not missing any thing. I was saying about the line no 100\r\n`result.add(**url.setProtocol(Constants.EMPTY_PROTOCOL)**);`', 'commenter': 'khanimteyaz'}, {'comment': ""Yes I know that, I didn't even change line 100, and the git diff show nothing changed in this line"", 'commenter': 'kezhenxu94'}, {'comment': 'No problem.', 'commenter': 'khanimteyaz'}]"
3102,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"@@ -152,10 +152,8 @@ public void doSaveProperties(long version) {
             if (!lockfile.exists()) {
                 lockfile.createNewFile();
             }
-            RandomAccessFile raf = new RandomAccessFile(lockfile, ""rw"");
-            try {
-                FileChannel channel = raf.getChannel();
-                try {
+            try (RandomAccessFile raf = new RandomAccessFile(lockfile, ""rw"")) {","[{'comment': 'As there are multiple nested try block, I would recommend to refactor this to individual method for better visibility and navigation.\r\n', 'commenter': 'khanimteyaz'}, {'comment': ""Thanks for commenting, I'll try to refactor this to make it more readable."", 'commenter': 'kezhenxu94'}, {'comment': ""I've used multiple auto resources management to reduce `try-catch` blocks, please have a look, if any changes should be done, please let me know"", 'commenter': 'kezhenxu94'}]"
3102,dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java,"@@ -133,21 +130,18 @@ public void doSubscribe(final URL url, final NotifyListener listener) {
                 String root = toRootPath();
                 ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);
                 if (listeners == null) {
-                    zkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());
+                    zkListeners.putIfAbsent(url, new ConcurrentHashMap<>());","[{'comment': 'I think the whole can be replace by in line no 133 with below code \r\n`ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.computeIfAbsent(url,k-> new ConcurrentHashMap<>());`\r\n\r\nwhat do you say?', 'commenter': 'khanimteyaz'}, {'comment': 'Sure.', 'commenter': 'kezhenxu94'}]"
3102,dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java,"@@ -133,21 +130,18 @@ public void doSubscribe(final URL url, final NotifyListener listener) {
                 String root = toRootPath();
                 ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);
                 if (listeners == null) {
-                    zkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());
+                    zkListeners.putIfAbsent(url, new ConcurrentHashMap<>());
                     listeners = zkListeners.get(url);
                 }
                 ChildListener zkListener = listeners.get(listener);
                 if (zkListener == null) {
-                    listeners.putIfAbsent(listener, new ChildListener() {
-                        @Override
-                        public void childChanged(String parentPath, List<String> currentChilds) {
-                            for (String child : currentChilds) {
-                                child = URL.decode(child);
-                                if (!anyServices.contains(child)) {
-                                    anyServices.add(child);
-                                    subscribe(url.setPath(child).addParameters(Constants.INTERFACE_KEY, child,
-                                            Constants.CHECK_KEY, String.valueOf(false)), listener);
-                                }
+                    listeners.putIfAbsent(listener, (parentPath, currentChildren) -> {
+                        for (String child : currentChildren) {","[{'comment': 'should we care to extract this to a method so that for readability point of view it could help ltr if some one reading the code?', 'commenter': 'khanimteyaz'}, {'comment': 'Done as requested', 'commenter': 'kezhenxu94'}]"
3108,dubbo-common/src/main/java/org/apache/dubbo/common/EnvironmentConstants.java,"@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.","[{'comment': ""suggest to put all constants in Constants, and make it an interface. After that, let's revisit this class to consider if it is possible to split. What do you think?"", 'commenter': 'beiwei30'}, {'comment': 'On it. One quick check, if I change the Constants to an interface and dubbo ecosystem projects(outside of incubator-dubbo) are using this class by extending then they might start failing. Do you know any one of them using it? If no one is using then we can change it to interface now. ', 'commenter': 'khanimteyaz'}, {'comment': 'Leaving the changing of java class to interface change. Or if you feel we should go ahead and make change please let the comment I will make the changes as part of this PR only.', 'commenter': 'khanimteyaz'}]"
3108,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ApplicationConfig.java,"@@ -150,10 +151,18 @@ public String getEnvironment() {
     }
 
     public void setEnvironment(String environment) {
-        checkName(""environment"", environment);
+        checkName(EnvironmentConstants.ENVIRONMENT, environment);
         if (environment != null) {
-            if (!(""develop"".equals(environment) || ""test"".equals(environment) || ""product"".equals(environment))) {
-                throw new IllegalStateException(""Unsupported environment: "" + environment + "", only support develop/test/product, default is product."");
+            if (!(EnvironmentConstants.DEVELOPMENT_ENVIRONMENT.equals(environment)
+                    || EnvironmentConstants.TEST_ENVIRONMENT.equals(environment)
+                    || EnvironmentConstants.PRODUCTION_ENVIRONMENT.equals(environment))) {
+
+                throw new IllegalStateException(String.format(""Unsupported environment: %s, only support %s/%s/%s, default is %s."",
+                         environment","[{'comment': 'Hi, this code style looks a bit strange, I suggest writing the comma after the variable, like this:\r\n\r\n```java\r\nthrow new IllegalStateException(String.format(""Unsupported environment: %s, only support %s/%s/%s, default is %s."",\r\n        environment,\r\n        EnvironmentConstants.DEVELOPMENT_ENVIRONMENT,\r\n        EnvironmentConstants.TEST_ENVIRONMENT,\r\n        EnvironmentConstants.PRODUCTION_ENVIRONMENT,\r\n        EnvironmentConstants.PRODUCTION_ENVIRONMENT));\r\n```\r\n\r\nWhat do you think?', 'commenter': 'code4wt'}, {'comment': 'sure.', 'commenter': 'khanimteyaz'}]"
3135,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java,"@@ -478,7 +477,7 @@ private void convertRegistryIdsToRegistries() {
             }
             Arrays.stream(arr).forEach(id -> {
                 if (registries.stream().noneMatch(reg -> reg.getId().equals(id))) {
-                    RegistryConfig registryConfig = new RegistryConfig();
+                    RegistryConfig registryConfig = new RegistryConfig(RegistryConfig.NO_AVAILABLE);","[{'comment': ""I don't think we can give RegistryConfig a default value `RegistryConfig.NO_AVAILABLE`, instead we should leave it empty. We will try to `refresh` this RegistryConfig later, if the user fails to set the right item for RegistryConfig, it will receive an Exception then when checking `isValid`. But if we give it this default value, it will always pass `isValid` and does register URL to Registry Center which can be unexpected behaviour."", 'commenter': 'chickenlj'}]"
3135,dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractInterfaceConfigTest.java,"@@ -118,6 +118,8 @@ public void checkApplication2() throws Exception {
     public void testLoadRegistries() throws Exception {
         System.setProperty(""dubbo.registry.address"", ""addr1"");
         InterfaceConfig interfaceConfig = new InterfaceConfig();
+        // FIXME: now we need to check first, then load
+        interfaceConfig.checkRegistry();","[{'comment': 'Maybe we should give `loadRegistries` another name that can better reflect what it does. It is misleading since it loads nothing except for converts RegistryConfigs to URLs.', 'commenter': 'chickenlj'}]"
3139,dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java,"@@ -813,6 +816,29 @@
      * Production environment key.
      */
     public static final String PRODUCTION_ENVIRONMENT = ""product"";
+
+    public static final String DUBBO_NAMESPACE_APPLICATION = APPLICATION_KEY;
+
+    public static final String DUBBO_NAMESPACE_MODULE = ""module"";
+
+    public static final String DUBBO_NAMESPACE_REGISTRY = REGISTRY_PROTOCOL;;","[{'comment': 'Duplicate semicolons.', 'commenter': 'ralf0131'}]"
3139,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java,"@@ -308,4 +253,89 @@ protected Class getServiceClass(T ref) {
         }
         return super.getServiceClass(ref);
     }
+
+    private void setupModule() {
+        Map<String, ModuleConfig> moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false);
+        if (moduleConfigMap != null && moduleConfigMap.size() > 0) {
+            ModuleConfig moduleConfig = null;
+            for (ModuleConfig config : moduleConfigMap.values()) {
+                if (config.isDefault() == null || config.isDefault()) {
+                    if (moduleConfig != null) {
+                        throw new IllegalStateException(""Duplicate module configs: "" + moduleConfig + "" and "" + config);
+                    }
+                    moduleConfig = config;
+                }
+            }
+            if (moduleConfig != null) {
+                setModule(moduleConfig);
+            }
+        }
+    }
+
+    private void setupApplication() {
+        Map<String, ApplicationConfig> applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);
+        if (applicationConfigMap != null && applicationConfigMap.size() > 0) {
+            ApplicationConfig applicationConfig = null;
+            for (ApplicationConfig config : applicationConfigMap.values()) {
+                if (config.isDefault() == null || config.isDefault()) {
+                    if (applicationConfig != null) {
+                        throw new IllegalStateException(""Duplicate application configs: "" + applicationConfig + "" and "" + config);
+                    }
+                    applicationConfig = config;
+                }
+            }
+            if (applicationConfig != null) {
+                setApplication(applicationConfig);
+            }
+        }
+    }
+
+    private void setupProvider(Map<String, ProviderConfig> providerConfigMap) {
+        Map<String, ProtocolConfig> protocolConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false);
+        if ((protocolConfigMap == null || protocolConfigMap.size() == 0)
+                && providerConfigMap.size() > 1) { // backward compatibility
+            List<ProviderConfig> providerConfigs = new ArrayList<ProviderConfig>();
+            for (ProviderConfig config : providerConfigMap.values()) {
+                if (config.isDefault() != null && config.isDefault()) {
+                    providerConfigs.add(config);
+                }
+            }
+            if (!providerConfigs.isEmpty()) {
+                setProviders(providerConfigs);
+            }
+        } else {
+            ProviderConfig providerConfig = null;
+            for (ProviderConfig config : providerConfigMap.values()) {
+                if (config.isDefault() == null || config.isDefault()) {
+                    if (providerConfig != null) {
+                        throw new IllegalStateException(""Duplicate provider configs: "" + providerConfig + "" and "" + config);
+                    }
+                    providerConfig = config;
+                }
+            }
+            if (providerConfig != null) {
+                setProvider(providerConfig);
+            }
+        }
+    }
+
+    private boolean hasApplicationRegistry() {
+        return getApplication() != null && getApplication().getRegistries() != null && !getApplication().getRegistries().isEmpty();
+    }
+
+    private boolean hasProviderRegistry() {
+        return getProvider() != null && getProvider().getRegistries() != null && !getProvider().getRegistries().isEmpty();
+    }
+
+    private boolean hasRegistry() {
+        return getRegistries() != null && !getRegistries().isEmpty();
+    }
+
+    private boolean hasProviderProtocol() {
+        return getProvider() != null && getProvider().getProtocols() != null && getProvider().getProtocols().isEmpty();","[{'comment': 'should be `!getProvider().getProtocols().isEmpty()`', 'commenter': 'ralf0131'}, {'comment': 'Thanks for catching this. I will add a UT for same too, so that in future it can catched .', 'commenter': 'khanimteyaz'}, {'comment': 'Great! I was thinking of adding unit test.', 'commenter': 'ralf0131'}]"
3139,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java,"@@ -255,8 +200,8 @@ public void afterPropertiesSet() throws Exception {
             }
         }
 
-        if ((getProtocols() == null || getProtocols().isEmpty())
-                && (getProvider() == null || getProvider().getProtocols() == null || getProvider().getProtocols().isEmpty())) {
+        if ( !hasProtocol()","[{'comment': 'It is better to place it in one line.', 'commenter': 'ralf0131'}]"
3141,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java,"@@ -78,27 +76,35 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         }
     }
 
-
     @Override
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
         super.write(ctx, msg, promise);
-        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
-        try {
-            // if error happens from write, mock a BAD_REQUEST response so that invoker can return immediately without
-            // waiting until timeout. FIXME: not sure if this is the right approach, but exceptionCaught doesn't work
-            // as expected.
-            if (promise.cause() != null && msg instanceof Request) {
+        final NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
+        final boolean isMsg = msg instanceof Request;","[{'comment': ""would it be better to name it 'isRequest'?"", 'commenter': 'lixiaojiee'}, {'comment': 'my bad\r\nI will fix it. Thanks for your suggestion.', 'commenter': 'carryxyh'}]"
3141,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java,"@@ -78,27 +76,35 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         }
     }
 
-
     @Override
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
         super.write(ctx, msg, promise);
-        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
-        try {
-            // if error happens from write, mock a BAD_REQUEST response so that invoker can return immediately without
-            // waiting until timeout. FIXME: not sure if this is the right approach, but exceptionCaught doesn't work
-            // as expected.
-            if (promise.cause() != null && msg instanceof Request) {
+        final NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
+        final boolean isMsg = msg instanceof Request;
+
+        // We add listeners to make sure our out bound event is correct.
+        // If our out bound event has an error (in most cases the encoder fails),
+        // we need to have the request return directly instead of blocking the invoke process.
+        promise.addListener(future -> {
+            if (future.isSuccess()) {
+                // if our future is success, mark the future to sent.
+                try {
+                    handler.sent(channel, msg);
+                } finally {
+                    NettyChannel.removeChannelIfDisconnected(ctx.channel());
+                }
+                return;
+            }
+
+            Throwable t = future.cause();
+            if (t != null && isMsg) {
                 Request request = (Request) msg;
                 Response response = new Response(request.getId(), request.getVersion());","[{'comment': 'Should we refactore this by extrating to a method to make it reusable and more readable e.g. \r\n\r\n```\r\nhandler.received(channel,buildErrorResponse((Request)msg,t);\r\n\r\nprivate static Response buildErrorResponse(Request request,Throwable t) {\r\n   Response response = new Response(request.getId(), request.getVersion());\r\n   response.setStatus(Response.BAD_REQUEST);\r\n   response.setErrorMessage(StringUtils.toString(t));\r\n   return response;\r\n}\r\n```\r\n\r\nIs the something do you feel should be good ?', 'commenter': 'khanimteyaz'}, {'comment': ""Agree with u.\r\nThis will make code clear.\r\nI'd like fix it soon."", 'commenter': 'carryxyh'}, {'comment': 'thanks.', 'commenter': 'khanimteyaz'}]"
3141,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java,"@@ -78,27 +76,33 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         }
     }
 
-
     @Override
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
         super.write(ctx, msg, promise);
-        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
-        try {
-            // if error happens from write, mock a BAD_REQUEST response so that invoker can return immediately without
-            // waiting until timeout. FIXME: not sure if this is the right approach, but exceptionCaught doesn't work
-            // as expected.
-            if (promise.cause() != null && msg instanceof Request) {
+        final NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
+        final boolean isRequest = msg instanceof Request;
+
+        // We add listeners to make sure our out bound event is correct.
+        // If our out bound event has an error (in most cases the encoder fails),
+        // we need to have the request return directly instead of blocking the invoke process.
+        promise.addListener(future -> {
+            if (future.isSuccess()) {
+                // if our future is success, mark the future to sent.
+                try {
+                    handler.sent(channel, msg);
+                } finally {
+                    NettyChannel.removeChannelIfDisconnected(ctx.channel());
+                }","[{'comment': 'The `finally` scope has shrank compared to before.\r\n\r\nI think it should also cover \r\n\r\n```java\r\nhandler.received(channel, response);\r\n```\r\n', 'commenter': 'chickenlj'}, {'comment': ""That's my only concern with this PR."", 'commenter': 'chickenlj'}, {'comment': 'My bad.\r\nI will fix it..', 'commenter': 'carryxyh'}]"
3159,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java,"@@ -344,14 +363,14 @@ public void reconnect() throws RemotingException {
     @Override
     public void close() {
         try {
-            if (executor != null) {
-                ExecutorUtil.shutdownNow(executor, 100);
-            }
+            super.close();","[{'comment': '`reconnectExecutorService.shutdownNow();`\r\nHow about shutdown the scheduler here.\r\n', 'commenter': 'chickenlj'}, {'comment': '1. `reconnectExecutorService` is a shared instance, this can not be closed, used to handle other client reconnection\r\n2. If it is shutdown, the reconnection caused by network jitter will be invalid.', 'commenter': 'zonghaishang'}]"
3159,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java,"@@ -152,6 +152,25 @@ private synchronized void initConnectStatusCheckCommand() {
                 @Override
                 public void run() {
                     try {
+
+                        /**
+                         * If the provider service is detected offline,
+                         * the client should not attempt to connect again.
+                         *
+                         * issue: https://github.com/apache/incubator-dubbo/issues/3158
+                         */
+                        if(isClosed()) {","[{'comment': 'do you feel that refactoring by extracting to a method may increase the readability of code \r\n\r\n```\r\n/**\r\n                         * If the provider service is detected offline,\r\n                         * the client should not attempt to connect again.\r\n                         *\r\n                         * issue: https://github.com/apache/incubator-dubbo/issues/3158\r\n  */\r\nif(cancelFutureIfClientIsOffline(reconnectExecutorFuture)) {\r\n     reconnectExecutorFuture.cancel(true);\r\n}\r\n\r\nprivate boolean cancelFutureIfClientIsOffline(ScheduledFuture future) {\r\n       return isClosed()) ?  (future != null && !future.isCancelled()) :false;\r\n}\r\n```', 'commenter': 'khanimteyaz'}, {'comment': '@khanimteyaz nice, I will fix that, :-)', 'commenter': 'zonghaishang'}, {'comment': 'thanks.', 'commenter': 'khanimteyaz'}]"
3159,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractClient.java,"@@ -172,7 +174,29 @@ public void run() {
                         }
                     }
                 }
+
+                private boolean cancelFutureIfOffline() {
+                    /**
+                     * If the provider service is detected offline,
+                     * the client should not attempt to connect again.
+                     *
+                     * issue: https://github.com/apache/incubator-dubbo/issues/3158
+                     */
+                    if(isClosed()) {
+                        ScheduledFuture<?> future = reconnectExecutorFuture;
+                        if(future != null && !future.isCancelled()){
+                            /**
+                             *  Client has been destroyed and
+                             *  scheduled task should be cancelled.
+                             */
+                            future.cancel(true);","[{'comment': 'Will `cancel()` really able to stop the reconnect task? I did not see any point where the interrupt can work.', 'commenter': 'chickenlj'}, {'comment': 'Never mind, looks like inside the `connect()`, there must be some point like `wait` that will allow interruption.', 'commenter': 'chickenlj'}, {'comment': ""when AbstractClient closed, `destroy` status will be update.\r\n\r\n1. We just check client destroy and should't reconnect to server, `cancel()` help cancel scheduling job.\r\n\r\n"", 'commenter': 'zonghaishang'}]"
3174,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java,"@@ -36,21 +36,34 @@
 
     private static final Logger logger = LoggerFactory.getLogger(TimeoutFilter.class);
 
+    private static final String TIMEOUT_FILTER_START_TIME = ""timeout_filter_start_time"";
+
     @Override
     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
-        long start = System.currentTimeMillis();
-        Result result = invoker.invoke(invocation);
-        long elapsed = System.currentTimeMillis() - start;
-        if (invoker.getUrl() != null
-                && elapsed > invoker.getUrl().getMethodParameter(invocation.getMethodName(),
-                ""timeout"", Integer.MAX_VALUE)) {
-            if (logger.isWarnEnabled()) {
-                logger.warn(""invoke time out. method: "" + invocation.getMethodName()
-                        + "" arguments: "" + Arrays.toString(invocation.getArguments()) + "" , url is ""
-                        + invoker.getUrl() + "", invoke elapsed "" + elapsed + "" ms."");
+        if (invocation.getAttachments() != null) {","[{'comment': 'If there is no attachement for invocation, to handle fix timeout should we care to create a attachment and set TIMEOUT_FILTER_START_TIME ? What do you say?', 'commenter': 'khanimteyaz'}, {'comment': 'Seems like you are right...\r\nGreat suggestion, I will fix it.\r\n👍 ', 'commenter': 'carryxyh'}, {'comment': 'I have fix this place.\r\nSeems like only RpcInvocation can set attachments.', 'commenter': 'carryxyh'}, {'comment': '@carryxyh \r\nI was thinking to have the responsibility of assigning a default TIMEOUT_FILTER_START_TIME  in RpcInvocation, but then realized that, I am going in wrong direction and it will landed up mixing  RpcInvocation Responsibility with TimerFilter. \r\n\r\nJust thinking loud here (please bear with me 😄 ), should we create a FilterWrapper and use it to store framework code related internal properties here, it may give us better way of separating object information. e.g\r\n\r\n```\r\nClass FilterWrapper {\r\n  private Invocation target;\r\n  private Map<String,Object> properties = new HashMap<>();\r\n   FilterWrapper (Invocation invocation)  {\r\n      this.target = invocation;\r\n  }\r\n  public void addProperties(String key,Object value) {\r\n   properties.put(key,value);\r\n} \r\n   public Map<String,Object> getProperties() {\r\n     return this.properties;\r\n }\r\n   public Map<String,Object> getAttachment() {\r\n      this.target.getAttachment();\r\n  }\r\n  ..........\r\n_more getter and setter or deleter as per needs_\r\n  ....\r\n}\r\nwrapper=FilterWrapper.of(invocation); \r\nwrapper.addProperties(TIMEOUT_FILTER_START_TIME, String.valueOf(start));\r\n```\r\n\r\nSo even in future we need to keep add internal properties we may not be landed up overriding user propvided values.\r\nWhat do you say?', 'commenter': 'khanimteyaz'}, {'comment': ""@khanimteyaz That's interesting, but if we add an extra `properties` just like you did in FilterWrapper, we need to further figure out how to pass the `properties` onto the wire. But at present `invocation` is the only carrier, so everything needs to finally go into `invocation` to get transferred."", 'commenter': 'chickenlj'}]"
3174,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java,"@@ -36,21 +36,34 @@
 
     private static final Logger logger = LoggerFactory.getLogger(TimeoutFilter.class);
 
+    private static final String TIMEOUT_FILTER_START_TIME = ""timeout_filter_start_time"";
+
     @Override
     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
-        long start = System.currentTimeMillis();
-        Result result = invoker.invoke(invocation);
-        long elapsed = System.currentTimeMillis() - start;
-        if (invoker.getUrl() != null
-                && elapsed > invoker.getUrl().getMethodParameter(invocation.getMethodName(),
-                ""timeout"", Integer.MAX_VALUE)) {
-            if (logger.isWarnEnabled()) {
-                logger.warn(""invoke time out. method: "" + invocation.getMethodName()
-                        + "" arguments: "" + Arrays.toString(invocation.getArguments()) + "" , url is ""
-                        + invoker.getUrl() + "", invoke elapsed "" + elapsed + "" ms."");
+        if (invocation.getAttachments() != null) {
+            long start = System.currentTimeMillis();
+            invocation.getAttachments().put(TIMEOUT_FILTER_START_TIME, String.valueOf(start));
+        }
+        return invoker.invoke(invocation);
+    }
+
+    @Override
+    public Result onResponse(Result result, Invoker<?> invoker, Invocation invocation) {
+        String startAttach = invocation.getAttachment(TIMEOUT_FILTER_START_TIME);
+        if (startAttach != null) {
+            long elapsed = System.currentTimeMillis() - Long.valueOf(startAttach);
+            if (invoker.getUrl() != null
+                    && elapsed > invoker.getUrl().getMethodParameter(invocation.getMethodName(),
+                    ""timeout"", Integer.MAX_VALUE)) {
+                if (logger.isWarnEnabled()) {
+                    logger.warn(""invoke time out. method: "" + invocation.getMethodName()
+                            + "" arguments: "" + Arrays.toString(invocation.getArguments()) + "" , url is ""
+                            + invoker.getUrl() + "", invoke elapsed "" + elapsed + "" ms."");
+                }
             }
+            // we should not change the attachments of the invocation.
+            invocation.getAttachments().remove(TIMEOUT_FILTER_START_TIME);","[{'comment': 'I am not sure should we care about the scenario here, where in case of exception while executing _invoker.invoke(invocation)_ , should we remove TIMEOUT_FILTER_START_TIME from attacchment ? I think this piece of code should take care of removing TIMEOUT_FILTER_START_TIME even in case of exception. What do you say?', 'commenter': 'khanimteyaz'}, {'comment': 'Agree.\r\nI will fix it.', 'commenter': 'carryxyh'}, {'comment': 'Hi, @khanimteyaz \r\nAfter check the code, seems like it would throw any exception..\r\nSo I keep this code.', 'commenter': 'carryxyh'}, {'comment': '> Hi, @khanimteyaz\r\n> After check the code, seems like it would throw any exception..\r\n> So I keep this code.\r\n\r\nIn this case would we be missing the chance to remove TIMEOUT_FILTER_START_TIME  from attachment? ', 'commenter': 'khanimteyaz'}, {'comment': ""Won't miss remove TIMEOUT_FILTER_START_TIME unless there is a bug.\r\nBut in bug case, we need fix our code but not add a try catch..I think.\r\nWhat do u  think about it?\r\n:)"", 'commenter': 'carryxyh'}, {'comment': 'If there are bug we any how need to fix it :). \r\n\r\nI think it is fine, as I was worring about whether we are missing to remove it or not, but on our known path we are removing.\r\n\r\nI have created a issue to write a UT for specific this scenario and will take it \r\nhttps://github.com/apache/incubator-dubbo/issues/3234\r\n', 'commenter': 'khanimteyaz'}, {'comment': ""I think it's already of no importance of caring about removing the attachment or not in here.\r\n\r\nThe Invocation is going to the end of its lifecycle because RPC call has finished."", 'commenter': 'chickenlj'}]"
3174,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java,"@@ -36,21 +37,40 @@
 
     private static final Logger logger = LoggerFactory.getLogger(TimeoutFilter.class);
 
+    private static final String TIMEOUT_FILTER_START_TIME = ""timeout_filter_start_time"";
+
     @Override
     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
-        long start = System.currentTimeMillis();","[{'comment': '`System.currentTimeMillis();` is not good choice for interval measurement.\r\nhttp://sangsoonam.github.io/2017/03/01/do-not-use-curenttimemillis-for-time-interval.html\r\nhttps://github.com/openshift/jenkins-plugin/issues/76\r\nhttp://pzemtsov.github.io/2017/07/23/the-slow-currenttimemillis.html', 'commenter': 'Kiddinglife'}, {'comment': 'I know.\r\nI have read an article and it seems that it is better to start another thread to get time regularly? But I think this is not a bottleneck right now.', 'commenter': 'carryxyh'}, {'comment': ""Let's keep it easy, functionality then performance."", 'commenter': 'chickenlj'}]"
3174,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TimeoutFilter.java,"@@ -36,21 +37,40 @@
 
     private static final Logger logger = LoggerFactory.getLogger(TimeoutFilter.class);
 
+    private static final String TIMEOUT_FILTER_START_TIME = ""timeout_filter_start_time"";
+
     @Override
     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
-        long start = System.currentTimeMillis();
-        Result result = invoker.invoke(invocation);
-        long elapsed = System.currentTimeMillis() - start;
-        if (invoker.getUrl() != null
-                && elapsed > invoker.getUrl().getMethodParameter(invocation.getMethodName(),
-                ""timeout"", Integer.MAX_VALUE)) {
-            if (logger.isWarnEnabled()) {
-                logger.warn(""invoke time out. method: "" + invocation.getMethodName()
-                        + "" arguments: "" + Arrays.toString(invocation.getArguments()) + "" , url is ""
-                        + invoker.getUrl() + "", invoke elapsed "" + elapsed + "" ms."");
+        if (invocation.getAttachments() != null) {
+            long start = System.currentTimeMillis();
+            invocation.getAttachments().put(TIMEOUT_FILTER_START_TIME, String.valueOf(start));","[{'comment': 'Be careful that this attachment `TIMEOUT_FILTER_START_TIME ` will be passed throughout the RPC chain because of the drawback of RpcContext. #3017 ', 'commenter': 'chickenlj'}, {'comment': ""It is indeed a problem. I personally think that my revision is rather stubborn. But haven't found a better way to pass the start time. . .\r\n\r\nMaybe using a DataStore or sth else?"", 'commenter': 'carryxyh'}, {'comment': 'Now I think the previous way you give is better, please see my comments below. \r\nSo what do you think now? Would you please revert the code?', 'commenter': 'chickenlj'}, {'comment': 'I have checked the code.\r\nAs you said, the timeoutfilter does not affect the RpcContext, nor does it affect the invocation downstream of the call chain. I have reverted the code.', 'commenter': 'carryxyh'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperClient.java,"@@ -41,13 +42,25 @@
 
     private volatile boolean closed = false;
 
+    private Set<URL> sourceURLs;
+
     public AbstractZookeeperClient(URL url) {
         this.url = url;","[{'comment': 'I think `this(url,new HashSet<>());` would be better. What do you say?', 'commenter': 'khanimteyaz'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java,"@@ -74,6 +74,10 @@ public void stateChanged(CuratorFramework client, ConnectionState state) {
         }
     }
 
+    public CuratorZookeeperClient(URL url) {","[{'comment': 'I this `this(url,new HashSet<>());` would better. What do you say?', 'commenter': 'khanimteyaz'}, {'comment': 'Order wise less parameters constructor better to come before then more once. Should we place single argument before two parameters constructor for better visibility.', 'commenter': 'khanimteyaz'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java,"@@ -156,7 +161,7 @@ public boolean isConnected() {
     public String doGetContent(String path) {
         try {
             byte[] dataBytes = client.getData().forPath(path);
-            if(dataBytes == null || dataBytes.length == 0){
+            if (dataBytes == null || dataBytes.length == 0) {
                 return null;
             }
             return new String(dataBytes, charset);","[{'comment': 'can be rewritten as `return (dataBytes == null || dataBytes.length == 0) ? null : new String(dataBytes, charset);`', 'commenter': 'khanimteyaz'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java,"@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.zookeeper.support;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * 2019/1/10
+ */
+public abstract class AbstractZookeeperTransporter implements ZookeeperTransporter {
+    static final Logger logger = LoggerFactory.getLogger(ZookeeperTransporter.class);
+    Map<String, ZookeeperClientData> zookeeperClientMap = new HashMap<String, ZookeeperClientData>();","[{'comment': 'Is zookeeperClientMap will be used by only same package class?', 'commenter': 'khanimteyaz'}, {'comment': 'I think only dimond operator should be good enough `**new HashMap<>();**`', 'commenter': 'khanimteyaz'}, {'comment': 'just cache', 'commenter': 'cvictory'}, {'comment': '> just cache\r\n\r\n Then I think better to provide a access specifier.', 'commenter': 'khanimteyaz'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java,"@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.zookeeper.support;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * 2019/1/10
+ */
+public abstract class AbstractZookeeperTransporter implements ZookeeperTransporter {
+    static final Logger logger = LoggerFactory.getLogger(ZookeeperTransporter.class);
+    Map<String, ZookeeperClientData> zookeeperClientMap = new HashMap<String, ZookeeperClientData>();
+
+    /**
+     * share connnect for registry, metadata, etc..
+     *
+     * @param url
+     * @return
+     */
+    public ZookeeperClient connect(URL url) {
+        ZookeeperClientData clientData;
+        List<String> addressList = getURLBackupAddress(url);
+        // The field define the zookeeper server , including protocol, host, port, username, password
+        if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {
+            logger.info(""ZookeeperTransporter.connnect result from map:"" + clientData);
+            return clientData.getZookeeperClient();
+        }
+        ZookeeperClient zookeeperClient = null;
+        synchronized (zookeeperClientMap) {
+            if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {
+                logger.info(""ZookeeperTransporter.connnect result from map2:"" + clientData);
+                return clientData.getZookeeperClient();
+            }
+
+            Set<URL> originalURLs = new HashSet<>(2);
+            originalURLs.add(url);
+            zookeeperClient = createZookeeperClient(createServerURL(url), originalURLs);
+
+            ZookeeperClientData zookeeperClientData = new ZookeeperClientData(zookeeperClient, originalURLs);
+            logger.info(""ZookeeperTransporter.connnect result from new connection. "" + clientData);
+
+            writeToClientMap(addressList, zookeeperClientData);
+        }
+        return zookeeperClient;
+    }
+
+    protected abstract ZookeeperClient createZookeeperClient(URL url, Set<URL> originalURLs);
+
+    ZookeeperClientData fetchAndUpdateZookeeperClientCache(URL url, List<String> addressList) {","[{'comment': 'method access specifier plz.', 'commenter': 'khanimteyaz'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java,"@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.zookeeper.support;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * 2019/1/10
+ */
+public abstract class AbstractZookeeperTransporter implements ZookeeperTransporter {
+    static final Logger logger = LoggerFactory.getLogger(ZookeeperTransporter.class);
+    Map<String, ZookeeperClientData> zookeeperClientMap = new HashMap<String, ZookeeperClientData>();
+
+    /**
+     * share connnect for registry, metadata, etc..
+     *
+     * @param url
+     * @return
+     */
+    public ZookeeperClient connect(URL url) {
+        ZookeeperClientData clientData;
+        List<String> addressList = getURLBackupAddress(url);
+        // The field define the zookeeper server , including protocol, host, port, username, password
+        if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {","[{'comment': 'is method **fetchAndUpdateZookeeperClientCache** is thread safe. In the defintion of method **fetchAndUpdateZookeeperClientCache** it uses global cache **zookeeperClientMap**  and if multiple client calls the constructor concurrency issue might come. What do you say?', 'commenter': 'khanimteyaz'}, {'comment': 'Yes, you are right.  I have modified HashMap to ConcurrentHashMap.\r\n', 'commenter': 'cvictory'}, {'comment': 'It seems below the code is duplicate, is this requires here. If requires then can we refactor this by extracting to a new method. What do you say? \r\n\r\n', 'commenter': 'khanimteyaz'}, {'comment': '> Yes, you are right. I have modified HashMap to ConcurrentHashMap.\r\n\r\nAs you have change the HashMap to ConcurrentHashMap do we still need map level lock?', 'commenter': 'khanimteyaz'}, {'comment': '> Yes, you are right. I have modified HashMap to ConcurrentHashMap.\r\n\r\nthanks', 'commenter': 'khanimteyaz'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java,"@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.zookeeper.support;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * 2019/1/10
+ */
+public abstract class AbstractZookeeperTransporter implements ZookeeperTransporter {
+    static final Logger logger = LoggerFactory.getLogger(ZookeeperTransporter.class);
+    Map<String, ZookeeperClientData> zookeeperClientMap = new HashMap<String, ZookeeperClientData>();
+
+    /**
+     * share connnect for registry, metadata, etc..
+     *
+     * @param url
+     * @return
+     */
+    public ZookeeperClient connect(URL url) {
+        ZookeeperClientData clientData;
+        List<String> addressList = getURLBackupAddress(url);
+        // The field define the zookeeper server , including protocol, host, port, username, password
+        if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {
+            logger.info(""ZookeeperTransporter.connnect result from map:"" + clientData);
+            return clientData.getZookeeperClient();
+        }
+        ZookeeperClient zookeeperClient = null;
+        synchronized (zookeeperClientMap) {","[{'comment': 'Above calls uses method **fetchAndUpdateZookeeperClientCache** to get zookeeper client which internally use **zookeeperClientMap ** and here we are trying to get lock on zookeeperClientMap, is there any reason in one place to have lock and another avoid lock? Is there I am missing anything ?', 'commenter': 'khanimteyaz'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java,"@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.zookeeper.support;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * 2019/1/10
+ */
+public abstract class AbstractZookeeperTransporter implements ZookeeperTransporter {
+    static final Logger logger = LoggerFactory.getLogger(ZookeeperTransporter.class);
+    Map<String, ZookeeperClientData> zookeeperClientMap = new HashMap<String, ZookeeperClientData>();
+
+    /**
+     * share connnect for registry, metadata, etc..
+     *
+     * @param url
+     * @return
+     */
+    public ZookeeperClient connect(URL url) {
+        ZookeeperClientData clientData;
+        List<String> addressList = getURLBackupAddress(url);
+        // The field define the zookeeper server , including protocol, host, port, username, password
+        if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {
+            logger.info(""ZookeeperTransporter.connnect result from map:"" + clientData);
+            return clientData.getZookeeperClient();
+        }
+        ZookeeperClient zookeeperClient = null;
+        synchronized (zookeeperClientMap) {
+            if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {","[{'comment': 'Is there any different between above if condition block to get **clientData** and this synchronize block to get **clientData** ?', 'commenter': 'khanimteyaz'}, {'comment': 'For avoding creating more connections, so I add this synchronized lock.', 'commenter': 'cvictory'}, {'comment': 'as you created a consurrent hash map I think now we can remove it? what do you say?', 'commenter': 'khanimteyaz'}]"
3182,dubbo-common/src/main/java/org/apache/dubbo/common/URL.java,"@@ -70,7 +70,8 @@
  * @see java.net.URL
  * @see java.net.URI
  */
-public /**final**/ class URL implements Serializable {
+public /**final**/","[{'comment': ""don't change this, keep it in one line."", 'commenter': 'beiwei30'}, {'comment': 'or simply remove **final**. ', 'commenter': 'beiwei30'}]"
3182,dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/support/AbstractMetadataReport.java,"@@ -377,7 +378,7 @@ public void run() {
                                 // Check and connect to the registry
                                 try {
                                     int times = retryCounter.incrementAndGet();
-                                    logger.info(""start to retry task for metadata report. retry times:"" + times);
+                                    logger.error(""start to retry task for metadata report. retry times:"" + times);","[{'comment': '**info** is better, in my opinion.', 'commenter': 'beiwei30'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java,"@@ -16,35 +16,41 @@
  */
 package org.apache.dubbo.remoting.zookeeper.curator;
 
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.utils.StringUtils;
-import org.apache.dubbo.remoting.zookeeper.ChildListener;
-import org.apache.dubbo.remoting.zookeeper.StateListener;
-import org.apache.dubbo.remoting.zookeeper.support.AbstractZookeeperClient;
-
 import org.apache.curator.framework.CuratorFramework;
 import org.apache.curator.framework.CuratorFrameworkFactory;
 import org.apache.curator.framework.api.CuratorWatcher;
 import org.apache.curator.framework.state.ConnectionState;
 import org.apache.curator.framework.state.ConnectionStateListener;
 import org.apache.curator.retry.RetryNTimes;
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.remoting.zookeeper.ChildListener;
+import org.apache.dubbo.remoting.zookeeper.StateListener;
+import org.apache.dubbo.remoting.zookeeper.support.AbstractZookeeperClient;
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.KeeperException.NoNodeException;
 import org.apache.zookeeper.KeeperException.NodeExistsException;
 import org.apache.zookeeper.WatchedEvent;
 
 import java.nio.charset.Charset;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 
 public class CuratorZookeeperClient extends AbstractZookeeperClient<CuratorWatcher> {
 
     private final Charset charset = Charset.forName(""UTF-8"");
     private final CuratorFramework client;
 
+
     public CuratorZookeeperClient(URL url) {
-        super(url);
+        this(url, new HashSet<URL>());","[{'comment': '`Collections.emptySet()` is better.', 'commenter': 'beiwei30'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java,"@@ -156,10 +163,7 @@ public boolean isConnected() {
     public String doGetContent(String path) {
         try {
             byte[] dataBytes = client.getData().forPath(path);
-            if(dataBytes == null || dataBytes.length == 0){
-                return null;
-            }
-            return new String(dataBytes, charset);
+            return (dataBytes == null || dataBytes.length == 0) ? null : new String(dataBytes, charset);
         } catch (NodeExistsException e) {","[{'comment': 'pls. add `// ignore`', 'commenter': 'beiwei30'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.zookeeper.support;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * AbstractZookeeperTransporter is abstract implements of ZookeeperTransporter.
+ * <p>
+ * If you want to extends this, implements createZookeeperClient.
+ */
+public abstract class AbstractZookeeperTransporter implements ZookeeperTransporter {
+    private static final Logger logger = LoggerFactory.getLogger(ZookeeperTransporter.class);
+    private final Map<String, ZookeeperClient> zookeeperClientMap = new ConcurrentHashMap<>();
+
+    /**
+     * share connnect for registry, metadata, etc..
+     *
+     * @param url
+     * @return
+     */
+    public ZookeeperClient connect(URL url) {
+        ZookeeperClient clientData;
+        List<String> addressList = getURLBackupAddress(url);
+        // The field define the zookeeper server , including protocol, host, port, username, password
+        if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {
+            logger.info(""Get result from map for the first time when invoking zookeeperTransporter.connnect"");
+            return clientData;
+        }
+        ZookeeperClient zookeeperClient = null;
+        // avoid creating too many connections， so add lock
+        synchronized (zookeeperClientMap) {
+            if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {
+                logger.info(""Get result from map for the second time when invoking zookeeperTransporter.connnect"");
+                return clientData;
+            }
+
+            zookeeperClient = createZookeeperClient(createServerURL(url));
+            logger.info(""Get result by creating new connection when invoking zookeeperTransporter.connnect. "");
+            writeToClientMap(addressList, zookeeperClient);
+        }
+        return zookeeperClient;
+    }
+
+    /**
+     * @param url the url that will create zookeeper connection .
+     *            The url in AbstractZookeeperTransporter#connect parameter is rewritten by this one.
+     *            such as: zookeeper://127.0.0.1:2181/org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter
+     * @return
+     */
+    protected abstract ZookeeperClient createZookeeperClient(URL url);
+
+    ZookeeperClient fetchAndUpdateZookeeperClientCache(URL url, List<String> addressList) {
+
+        ZookeeperClient zookeeperClientData = null;
+        for (String address : addressList) {
+            if ((zookeeperClientData = zookeeperClientMap.get(address)) != null) {
+                break;
+            }
+        }
+        if (zookeeperClientData != null) {
+            writeToClientMap(addressList, zookeeperClientData);
+        }
+        return zookeeperClientData;
+    }
+
+    List<String> getURLBackupAddress(URL url) {
+        List<String> addressList = new ArrayList<String>();
+        addressList.add(url.getAddress());
+
+        String[] backups = url.getParameter(Constants.BACKUP_KEY, new String[0]);
+        addressList.addAll(Arrays.asList(backups));
+        return addressList;
+    }
+
+    /**
+     * write address-ZookeeperClient relationship to Map
+     *
+     * @param addressList
+     * @param ZookeeperClient
+     */
+    void writeToClientMap(List<String> addressList, ZookeeperClient ZookeeperClient) {
+        for (String address : addressList) {
+            zookeeperClientMap.put(address, ZookeeperClient);
+        }
+    }
+
+    /**
+     * redefine the url for zookeeper. just keep protocol, username, password, host, port, and individual parameter.
+     *
+     * @param url
+     * @return
+     */
+    URL createServerURL(URL url) {
+        Map<String, String> parameterMap = new HashMap<>();
+        // for CuratorZookeeperClient
+        if (url.getParameter(Constants.TIMEOUT_KEY) != null) {
+            parameterMap.put(Constants.TIMEOUT_KEY, url.getParameter(Constants.TIMEOUT_KEY));
+        }
+        if (url.getParameter(Constants.BACKUP_KEY) != null) {
+            parameterMap.put(Constants.BACKUP_KEY, url.getParameter(Constants.BACKUP_KEY));
+        }
+        return new URL(url.getProtocol(), url.getUsername(), url.getPassword(), url.getHost(), url.getPort(),
+                ZookeeperTransporter.class.getName(), parameterMap);
+    }
+
+    /**
+     * for unit test
+     *
+     * @return
+     */
+    Map<String, ZookeeperClient> getZookeeperClientMap() {","[{'comment': 'access specifier plz.', 'commenter': 'khanimteyaz'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.zookeeper.support;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * AbstractZookeeperTransporter is abstract implements of ZookeeperTransporter.
+ * <p>
+ * If you want to extends this, implements createZookeeperClient.
+ */
+public abstract class AbstractZookeeperTransporter implements ZookeeperTransporter {
+    private static final Logger logger = LoggerFactory.getLogger(ZookeeperTransporter.class);
+    private final Map<String, ZookeeperClient> zookeeperClientMap = new ConcurrentHashMap<>();
+
+    /**
+     * share connnect for registry, metadata, etc..
+     *
+     * @param url
+     * @return
+     */
+    public ZookeeperClient connect(URL url) {
+        ZookeeperClient clientData;
+        List<String> addressList = getURLBackupAddress(url);
+        // The field define the zookeeper server , including protocol, host, port, username, password
+        if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {
+            logger.info(""Get result from map for the first time when invoking zookeeperTransporter.connnect"");
+            return clientData;
+        }
+        ZookeeperClient zookeeperClient = null;
+        // avoid creating too many connections， so add lock
+        synchronized (zookeeperClientMap) {
+            if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {
+                logger.info(""Get result from map for the second time when invoking zookeeperTransporter.connnect"");
+                return clientData;
+            }
+
+            zookeeperClient = createZookeeperClient(createServerURL(url));
+            logger.info(""Get result by creating new connection when invoking zookeeperTransporter.connnect. "");
+            writeToClientMap(addressList, zookeeperClient);
+        }
+        return zookeeperClient;
+    }
+
+    /**
+     * @param url the url that will create zookeeper connection .
+     *            The url in AbstractZookeeperTransporter#connect parameter is rewritten by this one.
+     *            such as: zookeeper://127.0.0.1:2181/org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter
+     * @return
+     */
+    protected abstract ZookeeperClient createZookeeperClient(URL url);
+
+    ZookeeperClient fetchAndUpdateZookeeperClientCache(URL url, List<String> addressList) {","[{'comment': 'method access specifier plz.', 'commenter': 'khanimteyaz'}, {'comment': 'It seems method parameter **url** is not getting used within this method. If we it is not getting used then should we care to remove it?', 'commenter': 'khanimteyaz'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.zookeeper.support;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * AbstractZookeeperTransporter is abstract implements of ZookeeperTransporter.
+ * <p>
+ * If you want to extends this, implements createZookeeperClient.
+ */
+public abstract class AbstractZookeeperTransporter implements ZookeeperTransporter {
+    private static final Logger logger = LoggerFactory.getLogger(ZookeeperTransporter.class);
+    private final Map<String, ZookeeperClient> zookeeperClientMap = new ConcurrentHashMap<>();
+
+    /**
+     * share connnect for registry, metadata, etc..
+     *
+     * @param url
+     * @return
+     */
+    public ZookeeperClient connect(URL url) {","[{'comment': 'URL is not immutable object **parameters**, **numbers** etc member variables are accessable by caller of **URL** class and make cause unwanted side effect if caller later modified it. It is better to have first create copy of it and then use. What do you say?', 'commenter': 'khanimteyaz'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.zookeeper.support;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * AbstractZookeeperTransporter is abstract implements of ZookeeperTransporter.
+ * <p>
+ * If you want to extends this, implements createZookeeperClient.
+ */
+public abstract class AbstractZookeeperTransporter implements ZookeeperTransporter {
+    private static final Logger logger = LoggerFactory.getLogger(ZookeeperTransporter.class);
+    private final Map<String, ZookeeperClient> zookeeperClientMap = new ConcurrentHashMap<>();
+
+    /**
+     * share connnect for registry, metadata, etc..
+     *
+     * @param url
+     * @return
+     */
+    public ZookeeperClient connect(URL url) {
+        ZookeeperClient clientData;
+        List<String> addressList = getURLBackupAddress(url);
+        // The field define the zookeeper server , including protocol, host, port, username, password
+        if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {
+            logger.info(""Get result from map for the first time when invoking zookeeperTransporter.connnect"");
+            return clientData;
+        }
+        ZookeeperClient zookeeperClient = null;
+        // avoid creating too many connections， so add lock
+        synchronized (zookeeperClientMap) {
+            if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {
+                logger.info(""Get result from map for the second time when invoking zookeeperTransporter.connnect"");
+                return clientData;
+            }
+
+            zookeeperClient = createZookeeperClient(createServerURL(url));
+            logger.info(""Get result by creating new connection when invoking zookeeperTransporter.connnect. "");
+            writeToClientMap(addressList, zookeeperClient);
+        }
+        return zookeeperClient;
+    }
+
+    /**
+     * @param url the url that will create zookeeper connection .
+     *            The url in AbstractZookeeperTransporter#connect parameter is rewritten by this one.
+     *            such as: zookeeper://127.0.0.1:2181/org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter
+     * @return
+     */
+    protected abstract ZookeeperClient createZookeeperClient(URL url);
+
+    ZookeeperClient fetchAndUpdateZookeeperClientCache(URL url, List<String> addressList) {
+
+        ZookeeperClient zookeeperClientData = null;
+        for (String address : addressList) {
+            if ((zookeeperClientData = zookeeperClientMap.get(address)) != null) {
+                break;
+            }
+        }
+        if (zookeeperClientData != null) {
+            writeToClientMap(addressList, zookeeperClientData);
+        }
+        return zookeeperClientData;
+    }
+
+    List<String> getURLBackupAddress(URL url) {","[{'comment': 'method access specifier plz.', 'commenter': 'khanimteyaz'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.zookeeper.support;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * AbstractZookeeperTransporter is abstract implements of ZookeeperTransporter.
+ * <p>
+ * If you want to extends this, implements createZookeeperClient.
+ */
+public abstract class AbstractZookeeperTransporter implements ZookeeperTransporter {
+    private static final Logger logger = LoggerFactory.getLogger(ZookeeperTransporter.class);
+    private final Map<String, ZookeeperClient> zookeeperClientMap = new ConcurrentHashMap<>();
+
+    /**
+     * share connnect for registry, metadata, etc..
+     *
+     * @param url
+     * @return
+     */
+    public ZookeeperClient connect(URL url) {
+        ZookeeperClient clientData;
+        List<String> addressList = getURLBackupAddress(url);
+        // The field define the zookeeper server , including protocol, host, port, username, password
+        if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {
+            logger.info(""Get result from map for the first time when invoking zookeeperTransporter.connnect"");
+            return clientData;
+        }
+        ZookeeperClient zookeeperClient = null;
+        // avoid creating too many connections， so add lock
+        synchronized (zookeeperClientMap) {
+            if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {
+                logger.info(""Get result from map for the second time when invoking zookeeperTransporter.connnect"");
+                return clientData;
+            }
+
+            zookeeperClient = createZookeeperClient(createServerURL(url));
+            logger.info(""Get result by creating new connection when invoking zookeeperTransporter.connnect. "");
+            writeToClientMap(addressList, zookeeperClient);
+        }
+        return zookeeperClient;
+    }
+
+    /**
+     * @param url the url that will create zookeeper connection .
+     *            The url in AbstractZookeeperTransporter#connect parameter is rewritten by this one.
+     *            such as: zookeeper://127.0.0.1:2181/org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter
+     * @return
+     */
+    protected abstract ZookeeperClient createZookeeperClient(URL url);
+
+    ZookeeperClient fetchAndUpdateZookeeperClientCache(URL url, List<String> addressList) {
+
+        ZookeeperClient zookeeperClientData = null;
+        for (String address : addressList) {
+            if ((zookeeperClientData = zookeeperClientMap.get(address)) != null) {
+                break;
+            }
+        }
+        if (zookeeperClientData != null) {
+            writeToClientMap(addressList, zookeeperClientData);
+        }
+        return zookeeperClientData;
+    }
+
+    List<String> getURLBackupAddress(URL url) {
+        List<String> addressList = new ArrayList<String>();
+        addressList.add(url.getAddress());
+
+        String[] backups = url.getParameter(Constants.BACKUP_KEY, new String[0]);
+        addressList.addAll(Arrays.asList(backups));
+        return addressList;
+    }
+
+    /**
+     * write address-ZookeeperClient relationship to Map
+     *
+     * @param addressList
+     * @param ZookeeperClient
+     */
+    void writeToClientMap(List<String> addressList, ZookeeperClient ZookeeperClient) {
+        for (String address : addressList) {
+            zookeeperClientMap.put(address, ZookeeperClient);
+        }
+    }
+
+    /**
+     * redefine the url for zookeeper. just keep protocol, username, password, host, port, and individual parameter.
+     *
+     * @param url
+     * @return
+     */
+    URL createServerURL(URL url) {","[{'comment': 'method access specifier plz', 'commenter': 'khanimteyaz'}]"
3182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.zookeeper.support;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;
+import org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * AbstractZookeeperTransporter is abstract implements of ZookeeperTransporter.
+ * <p>
+ * If you want to extends this, implements createZookeeperClient.
+ */
+public abstract class AbstractZookeeperTransporter implements ZookeeperTransporter {
+    private static final Logger logger = LoggerFactory.getLogger(ZookeeperTransporter.class);
+    private final Map<String, ZookeeperClient> zookeeperClientMap = new ConcurrentHashMap<>();
+
+    /**
+     * share connnect for registry, metadata, etc..
+     *
+     * @param url
+     * @return
+     */
+    public ZookeeperClient connect(URL url) {
+        ZookeeperClient clientData;
+        List<String> addressList = getURLBackupAddress(url);
+        // The field define the zookeeper server , including protocol, host, port, username, password
+        if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {
+            logger.info(""Get result from map for the first time when invoking zookeeperTransporter.connnect"");
+            return clientData;
+        }
+        ZookeeperClient zookeeperClient = null;
+        // avoid creating too many connections， so add lock
+        synchronized (zookeeperClientMap) {
+            if ((clientData = fetchAndUpdateZookeeperClientCache(url, addressList)) != null) {
+                logger.info(""Get result from map for the second time when invoking zookeeperTransporter.connnect"");
+                return clientData;
+            }
+
+            zookeeperClient = createZookeeperClient(createServerURL(url));
+            logger.info(""Get result by creating new connection when invoking zookeeperTransporter.connnect. "");
+            writeToClientMap(addressList, zookeeperClient);
+        }
+        return zookeeperClient;
+    }
+
+    /**
+     * @param url the url that will create zookeeper connection .
+     *            The url in AbstractZookeeperTransporter#connect parameter is rewritten by this one.
+     *            such as: zookeeper://127.0.0.1:2181/org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter
+     * @return
+     */
+    protected abstract ZookeeperClient createZookeeperClient(URL url);
+
+    ZookeeperClient fetchAndUpdateZookeeperClientCache(URL url, List<String> addressList) {
+
+        ZookeeperClient zookeeperClientData = null;
+        for (String address : addressList) {","[{'comment': 'This can written as \r\n```\r\npriavte ZookeeperClient fetchAndUpdateZookeeperClientCache(URL url, List<String> addressList) {\r\nOptional<ZookeeperClient> record=addressList.stream().filter(zookeeperClientMap::containsKey).findFirst();\r\nif(record.isPresent()) {\r\n    writeToClientMap(addressList, record.get());\r\n}\r\nreturn null;\r\n}\r\n```\r\n', 'commenter': 'khanimteyaz'}]"
3197,dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java,"@@ -515,7 +515,7 @@ private static Object newInstance(Class<?> cls) {
         } catch (Throwable t) {
             try {
                 Constructor<?>[] constructors = cls.getDeclaredConstructors();
-                if (constructors != null && constructors.length == 0) {
+                if (constructors == null && constructors.length == 0) {","[{'comment': '`&&` should be replaced with `||`', 'commenter': 'CrazyHZM'}, {'comment': 'right, I also missed out here.\r\n\r\n', 'commenter': 'lixiaojiee'}, {'comment': '@CrazyHZM  nice', 'commenter': 'zhaoyuguang'}, {'comment': 'i has fix it', 'commenter': 'zhaoyuguang'}]"
3197,dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java,"@@ -515,7 +515,7 @@ private static Object newInstance(Class<?> cls) {
         } catch (Throwable t) {
             try {
                 Constructor<?>[] constructors = cls.getDeclaredConstructors();
-                if (constructors == null || constructors.length == 0) {
+                if (constructors.length == 0) {","[{'comment': 'Please add a comment here, why the null check has been removed.', 'commenter': 'ralf0131'}, {'comment': 'Rogar~', 'commenter': 'zhaoyuguang'}, {'comment': ""I think we'd better to remove `So I removed the logical judgment of 'constructors == null'.`, because it's less relevant to why we use `constructors.length == 0`."", 'commenter': 'kun-song'}, {'comment': '@satansk Agree! Line 524 should be removed.', 'commenter': 'ralf0131'}, {'comment': 'Yes, this is better.', 'commenter': 'zhaoyuguang'}]"
3199,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java,"@@ -77,49 +77,49 @@ private static byte isCallBack(URL url, String methodName, int argIndex) {
      * @throws IOException
      */
     @SuppressWarnings({""unchecked"", ""rawtypes""})
-    private static String exportOrunexportCallbackService(Channel channel, URL url, Class clazz, Object inst, Boolean export) throws IOException {
+    private static String exportOrUnexportCallbackService(Channel channel, URL url, Class clazz, Object inst, Boolean export) throws IOException {
         int instid = System.identityHashCode(inst);
 
         Map<String, String> params = new HashMap<String, String>(3);
         // no need to new client again
         params.put(Constants.IS_SERVER_KEY, Boolean.FALSE.toString());
         // mark it's a callback, for troubleshooting
         params.put(Constants.IS_CALLBACK_SERVICE, Boolean.TRUE.toString());
-        String group = url.getParameter(Constants.GROUP_KEY);
+        String group = (url == null ? null : url.getParameter(Constants.GROUP_KEY));
         if (group != null && group.length() > 0) {
             params.put(Constants.GROUP_KEY, group);
         }
         // add method, for verifying against method, automatic fallback (see dubbo protocol)
         params.put(Constants.METHODS_KEY, StringUtils.join(Wrapper.getWrapper(clazz).getDeclaredMethodNames(), "",""));
 
-        Map<String, String> tmpmap = new HashMap<String, String>(url.getParameters());
-        tmpmap.putAll(params);
-        tmpmap.remove(Constants.VERSION_KEY);// doesn't need to distinguish version for callback
-        tmpmap.put(Constants.INTERFACE_KEY, clazz.getName());
-        URL exporturl = new URL(DubboProtocol.NAME, channel.getLocalAddress().getAddress().getHostAddress(), channel.getLocalAddress().getPort(), clazz.getName() + ""."" + instid, tmpmap);
+        Map<String, String> tmpMap = new HashMap<String, String>(url.getParameters());
+        tmpMap.putAll(params);
+        tmpMap.remove(Constants.VERSION_KEY);// doesn't need to distinguish version for callback
+        tmpMap.put(Constants.INTERFACE_KEY, clazz.getName());
+        URL exportUrl = new URL(DubboProtocol.NAME, channel.getLocalAddress().getAddress().getHostAddress(), channel.getLocalAddress().getPort(), clazz.getName() + ""."" + instid, tmpMap);
 
         // no need to generate multiple exporters for different channel in the same JVM, cache key cannot collide.
         String cacheKey = getClientSideCallbackServiceCacheKey(instid);
-        String countkey = getClientSideCountKey(clazz.getName());
+        String countKey = getClientSideCountKey(clazz.getName());
         if (export) {
             // one channel can have multiple callback instances, no need to re-export for different instance.
             if (!channel.hasAttribute(cacheKey)) {
                 if (!isInstancesOverLimit(channel, url, clazz.getName(), instid, false)) {
-                    Invoker<?> invoker = proxyFactory.getInvoker(inst, clazz, exporturl);
+                    Invoker<?> invoker = proxyFactory.getInvoker(inst, clazz, exportUrl);
                     // should destroy resource?
                     Exporter<?> exporter = protocol.export(invoker);
                     // this is used for tracing if instid has published service or not.
                     channel.setAttribute(cacheKey, exporter);
-                    logger.info(""export a callback service :"" + exporturl + "", on "" + channel + "", url is: "" + url);
-                    increaseInstanceCount(channel, countkey);
+                    logger.info(""export a callback service :"" + exportUrl + "", on "" + channel + "", url is: "" + url);","[{'comment': ""would you please change 'exporter' of line 113 to 'Exporter' by the way?"", 'commenter': 'lixiaojiee'}, {'comment': 'why not', 'commenter': 'zhaoyuguang'}, {'comment': 'i has fix it.', 'commenter': 'zhaoyuguang'}]"
3199,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java,"@@ -77,49 +77,49 @@ private static byte isCallBack(URL url, String methodName, int argIndex) {
      * @throws IOException
      */
     @SuppressWarnings({""unchecked"", ""rawtypes""})
-    private static String exportOrunexportCallbackService(Channel channel, URL url, Class clazz, Object inst, Boolean export) throws IOException {
+    private static String exportOrUnexportCallbackService(Channel channel, URL url, Class clazz, Object inst, Boolean export) throws IOException {
         int instid = System.identityHashCode(inst);
 
         Map<String, String> params = new HashMap<String, String>(3);
         // no need to new client again
         params.put(Constants.IS_SERVER_KEY, Boolean.FALSE.toString());
         // mark it's a callback, for troubleshooting
         params.put(Constants.IS_CALLBACK_SERVICE, Boolean.TRUE.toString());
-        String group = url.getParameter(Constants.GROUP_KEY);
+        String group = (url == null ? null : url.getParameter(Constants.GROUP_KEY));
         if (group != null && group.length() > 0) {
             params.put(Constants.GROUP_KEY, group);
         }
         // add method, for verifying against method, automatic fallback (see dubbo protocol)
         params.put(Constants.METHODS_KEY, StringUtils.join(Wrapper.getWrapper(clazz).getDeclaredMethodNames(), "",""));
 
-        Map<String, String> tmpmap = new HashMap<String, String>(url.getParameters());
-        tmpmap.putAll(params);
-        tmpmap.remove(Constants.VERSION_KEY);// doesn't need to distinguish version for callback
-        tmpmap.put(Constants.INTERFACE_KEY, clazz.getName());
-        URL exporturl = new URL(DubboProtocol.NAME, channel.getLocalAddress().getAddress().getHostAddress(), channel.getLocalAddress().getPort(), clazz.getName() + ""."" + instid, tmpmap);
+        Map<String, String> tmpMap = new HashMap<String, String>(url.getParameters());
+        tmpMap.putAll(params);
+        tmpMap.remove(Constants.VERSION_KEY);// doesn't need to distinguish version for callback
+        tmpMap.put(Constants.INTERFACE_KEY, clazz.getName());
+        URL exportUrl = new URL(DubboProtocol.NAME, channel.getLocalAddress().getAddress().getHostAddress(), channel.getLocalAddress().getPort(), clazz.getName() + ""."" + instid, tmpMap);
 
         // no need to generate multiple exporters for different channel in the same JVM, cache key cannot collide.
         String cacheKey = getClientSideCallbackServiceCacheKey(instid);
-        String countkey = getClientSideCountKey(clazz.getName());
+        String countKey = getClientSideCountKey(clazz.getName());
         if (export) {
             // one channel can have multiple callback instances, no need to re-export for different instance.
             if (!channel.hasAttribute(cacheKey)) {
                 if (!isInstancesOverLimit(channel, url, clazz.getName(), instid, false)) {
-                    Invoker<?> invoker = proxyFactory.getInvoker(inst, clazz, exporturl);
+                    Invoker<?> invoker = proxyFactory.getInvoker(inst, clazz, exportUrl);
                     // should destroy resource?
                     Exporter<?> exporter = protocol.export(invoker);
                     // this is used for tracing if instid has published service or not.
                     channel.setAttribute(cacheKey, exporter);
-                    logger.info(""export a callback service :"" + exporturl + "", on "" + channel + "", url is: "" + url);
-                    increaseInstanceCount(channel, countkey);
+                    logger.info(""Exporter a callback service :"" + exportUrl + "", on "" + channel + "", url is: "" + url);","[{'comment': 'Exporter is a noun, we should use a verb here, like `Export`', 'commenter': 'ralf0131'}, {'comment': 'Haha,my fault', 'commenter': 'lixiaojiee'}]"
3199,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java,"@@ -77,49 +77,49 @@ private static byte isCallBack(URL url, String methodName, int argIndex) {
      * @throws IOException
      */
     @SuppressWarnings({""unchecked"", ""rawtypes""})
-    private static String exportOrunexportCallbackService(Channel channel, URL url, Class clazz, Object inst, Boolean export) throws IOException {
+    private static String exportOrUnexportCallbackService(Channel channel, URL url, Class clazz, Object inst, Boolean export) throws IOException {
         int instid = System.identityHashCode(inst);
 
         Map<String, String> params = new HashMap<String, String>(3);
         // no need to new client again
         params.put(Constants.IS_SERVER_KEY, Boolean.FALSE.toString());
         // mark it's a callback, for troubleshooting
         params.put(Constants.IS_CALLBACK_SERVICE, Boolean.TRUE.toString());
-        String group = url.getParameter(Constants.GROUP_KEY);
+        String group = (url == null ? null : url.getParameter(Constants.GROUP_KEY));
         if (group != null && group.length() > 0) {
             params.put(Constants.GROUP_KEY, group);
         }
         // add method, for verifying against method, automatic fallback (see dubbo protocol)
         params.put(Constants.METHODS_KEY, StringUtils.join(Wrapper.getWrapper(clazz).getDeclaredMethodNames(), "",""));
 
-        Map<String, String> tmpmap = new HashMap<String, String>(url.getParameters());
-        tmpmap.putAll(params);
-        tmpmap.remove(Constants.VERSION_KEY);// doesn't need to distinguish version for callback
-        tmpmap.put(Constants.INTERFACE_KEY, clazz.getName());
-        URL exporturl = new URL(DubboProtocol.NAME, channel.getLocalAddress().getAddress().getHostAddress(), channel.getLocalAddress().getPort(), clazz.getName() + ""."" + instid, tmpmap);
+        Map<String, String> tmpMap = new HashMap<String, String>(url.getParameters());","[{'comment': '`new HashMap<>(...)` seems more concise to me.', 'commenter': 'kun-song'}, {'comment': 'Yes, the generics that can be inferred automatically are also deleted.', 'commenter': 'zhaoyuguang'}]"
3199,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java,"@@ -77,49 +77,49 @@ private static byte isCallBack(URL url, String methodName, int argIndex) {
      * @throws IOException
      */
     @SuppressWarnings({""unchecked"", ""rawtypes""})
-    private static String exportOrunexportCallbackService(Channel channel, URL url, Class clazz, Object inst, Boolean export) throws IOException {
+    private static String exportOrUnexportCallbackService(Channel channel, URL url, Class clazz, Object inst, Boolean export) throws IOException {
         int instid = System.identityHashCode(inst);
 
-        Map<String, String> params = new HashMap<String, String>(3);
+        Map<String, String> params = new HashMap<>(3);
         // no need to new client again
         params.put(Constants.IS_SERVER_KEY, Boolean.FALSE.toString());
         // mark it's a callback, for troubleshooting
         params.put(Constants.IS_CALLBACK_SERVICE, Boolean.TRUE.toString());
-        String group = url.getParameter(Constants.GROUP_KEY);
+        String group = (url == null ? null : url.getParameter(Constants.GROUP_KEY));","[{'comment': 'I check the code, it is possible for url to be null. So nice job here!', 'commenter': 'ralf0131'}]"
3207,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java,"@@ -24,13 +24,9 @@
 
 import java.io.File;
 import java.io.FileOutputStream;
-import java.io.IOException;
 import java.text.SimpleDateFormat;
 import java.util.Date;
-import java.util.concurrent.Executors;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.*;","[{'comment': ""Don't use import *"", 'commenter': 'carryxyh'}]"
3207,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java,"@@ -78,43 +74,34 @@ private void dumpJStack() {
             return;
         }
 
-        Executors.newSingleThreadExecutor().execute(new Runnable() {
-            @Override
-            public void run() {
-                String dumpPath = url.getParameter(Constants.DUMP_DIRECTORY, System.getProperty(""user.home""));
-
-                SimpleDateFormat sdf;
-
-                String OS = System.getProperty(""os.name"").toLowerCase();
-
-                // window system don't support "":"" in file name
-                if(OS.contains(""win"")){
-                    sdf = new SimpleDateFormat(""yyyy-MM-dd_HH-mm-ss"");
-                }else {
-                    sdf = new SimpleDateFormat(""yyyy-MM-dd_HH:mm:ss"");
-                }
-
-                String dateStr = sdf.format(new Date());
-                FileOutputStream jstackStream = null;
-                try {
-                    jstackStream = new FileOutputStream(new File(dumpPath, ""Dubbo_JStack.log"" + ""."" + dateStr));
-                    JVMUtil.jstack(jstackStream);
-                } catch (Throwable t) {
-                    logger.error(""dump jstack error"", t);
-                } finally {
-                    guard.release();
-                    if (jstackStream != null) {
-                        try {
-                            jstackStream.flush();
-                            jstackStream.close();
-                        } catch (IOException e) {
-                        }
-                    }
-                }
-
-                lastPrintTime = System.currentTimeMillis();
+        ExecutorService pool = Executors.newSingleThreadExecutor();
+        pool.execute(() -> {
+            String dumpPath = url.getParameter(Constants.DUMP_DIRECTORY, System.getProperty(""user.home""));
+
+            SimpleDateFormat sdf;
+
+            String os = System.getProperty(""os.name"").toLowerCase();
+
+            // window system don't support "":"" in file name
+            if (os.contains(""win"")) {
+                sdf = new SimpleDateFormat(""yyyy-MM-dd_HH-mm-ss"");
+            } else {
+                sdf = new SimpleDateFormat(""yyyy-MM-dd_HH:mm:ss"");
+            }
+
+            String dateStr = sdf.format(new Date());
+            //try-with-resources
+            try (FileOutputStream jStackStream = new FileOutputStream(new File(dumpPath, ""Dubbo_JStack.log"" + ""."" + dateStr))) {
+                JVMUtil.jstack(jStackStream);
+            } catch (Throwable t) {
+                logger.error(""dump jStack error"", t);
+            } finally {
+                guard.release();
             }
+            lastPrintTime = System.currentTimeMillis();
         });
+        //must shutdown thread pool ,if not will lead to OOM
+        pool.shutdown();","[{'comment': 'How do we determine that the dump work has been completed?\r\nThe best practice should be to close the thread pool after the dump ends.', 'commenter': 'carryxyh'}, {'comment': 'Use the shutdown method instead of the shutdownnow method. Tasks previously submitted are executed, even in queues', 'commenter': 'scxwhite'}]"
3211,pom.xml,"@@ -98,7 +98,7 @@
         <cglib_version>2.2</cglib_version>
         <mockito_version>2.23.4</mockito_version>
         <!-- Build args -->
-        <argline>-server -Xms256m -Xmx512m -XX:PermSize=64m -XX:MaxPermSize=128m -Dfile.encoding=UTF-8
+        <argline>-server -Xms256m -XX:PermSize=64m -XX:MaxPermSize=128m -Dfile.encoding=UTF-8","[{'comment': 'Dubbo 2.7 runs on Java 8, in Java 8 we need Metaspace and MaxMetaspace.', 'commenter': 'ralf0131'}, {'comment': 'Thanks for reviewing, changes are made as requested.', 'commenter': 'kezhenxu94'}, {'comment': 'Hi, this is not resolved yet.\r\n\r\nWe need  `-XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=128m` here.', 'commenter': 'ralf0131'}, {'comment': 'Thanks, if any further changes are required, please let me know', 'commenter': 'kezhenxu94'}]"
3211,pom.xml,"@@ -99,7 +99,7 @@
         <mockito_version>2.23.4</mockito_version>
         <!-- Build args -->
         <argline>-server -Xms256m -Xmx512m -XX:PermSize=64m -XX:MaxPermSize=128m -Dfile.encoding=UTF-8","[{'comment': 'Please remove `-XX:PermSize=64m -XX:MaxPermSize=128m`, there is no need to keep it.', 'commenter': 'ralf0131'}]"
3213,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/AbstractTimerTask.java,"@@ -22,24 +22,24 @@
 import org.apache.dubbo.common.timer.TimerTask;
 import org.apache.dubbo.remoting.Channel;
 
-import java.util.Collection;
 import java.util.concurrent.TimeUnit;
 
 /**
  * AbstractTimerTask
  */
 public abstract class AbstractTimerTask implements TimerTask {
 
-    private final ChannelProvider channelProvider;
+
+    private final Channel channel;
 
     private final Long tick;
 
-    AbstractTimerTask(ChannelProvider channelProvider, Long tick) {
-        if (channelProvider == null || tick == null) {
+    AbstractTimerTask(Channel channel, Long tick) {
+        if (channel == null || tick == null) {","[{'comment': 'I think putting both the null check together make it defficult to trace for which this exception has been raised.\r\n\r\nI think we should refactor this to \r\n\r\n```\r\nAssert.notNull(channel,""Channel can\'t be null\');\r\nAssert.notNull(tick,""Tick can\'t be null"");\r\n```\r\n\r\nAssert is under package of org.apache.dubbo.common.utils. They way it works is, if the given first argument is null then it throws IllegalArgumentException with messaged getting passed here as second argument. \r\n\r\nWhat do you say?', 'commenter': 'khanimteyaz'}]"
3213,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/AbstractTimerTask.java,"@@ -54,7 +54,7 @@ static Long now() {
         return System.currentTimeMillis();
     }
 
-    private void reput(Timeout timeout, Long tick) {
+    protected void reput(Timeout timeout, Long tick) {
         if (timeout == null || tick == null) {","[{'comment': 'Same as above, separate Assert check with specific message.', 'commenter': 'khanimteyaz'}, {'comment': 'Are we expecting reput to be gets overriden by subclass. If getting overridern then expectation of not having null value in timeout may break, because subclass may allow it be null. EIther we sould explicity document to be not null value or make it final method so that sub class may not override it. ', 'commenter': 'khanimteyaz'}]"
3213,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeartbeatHandler.java,"@@ -35,6 +39,12 @@
 
     public static String KEY_WRITE_TIMESTAMP = ""WRITE_TIMESTAMP"";
 
+    // The whole dubbo service use only one hashedWheelTimer for heartbeat task and reconnect task
+    private static HashedWheelTimer hashedWheelTimer = new HashedWheelTimer(new NamedThreadFactory(""dubbo-heartbeat"", true),
+            1000,","[{'comment': 'I think 1000 (second argument) we can defined as constant as DEFAULT_TICK_DURATION=1000; and use it. It will provide a better readability. What do you say?', 'commenter': 'khanimteyaz'}]"
3213,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/AbstractTimerTask.java,"@@ -69,19 +69,13 @@ private void reput(Timeout timeout, Long tick) {
 
     @Override
     public void run(Timeout timeout) throws Exception {
-        Collection<Channel> c = channelProvider.getChannels();
-        for (Channel channel : c) {
-            if (channel.isClosed()) {
-                continue;
-            }
-            doTask(channel);
-        }
-        reput(timeout, tick);
+            doTask(channel, timeout);
     }
 
-    protected abstract void doTask(Channel channel);
+    protected abstract void doTask(Channel channel, Timeout timeout);
 
-    interface ChannelProvider {
-        Collection<Channel> getChannels();
+    protected Long getTick() {","[{'comment': 'I think we should not allowed to override getTick, if sub class implement this and set value as zero then we might cause issue where we are using tick value for reput , e.g see HeartbeatTimerTask.java doTask method where we are checking whether heart beat value is > getTick and then creating request.\r\n\r\nCould you double check this one, I might be wrong.', 'commenter': 'khanimteyaz'}]"
3238,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/merger/MapMerger.java,"@@ -31,11 +33,7 @@
             return Collections.emptyMap();
         }
         Map<Object, Object> result = new HashMap<Object, Object>();
-        for (Map<?, ?> item : items) {
-            if (item != null) {
-                result.putAll(item);
-            }
-        }
+        Arrays.stream(items).filter(Objects::nonNull).forEach(item -> result.putAll(item));","[{'comment': '`forEach` is designed for side effect, a chained stream seems better to me.', 'commenter': 'kun-song'}, {'comment': 'I have a doubt that if the flatMap of a HashMap will change the order of iteration of iterator ?', 'commenter': 'tswstarplanet'}, {'comment': ""> I have a doubt that if the flatMap of a HashMap will change the order of iteration of iterator ?\r\n\r\n`HashMap` has no guarantee about its mappings' order, so I think it's not a problem even if `flatMap` will change the order."", 'commenter': 'kun-song'}]"
3238,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/merger/SetMerger.java,"@@ -31,13 +33,7 @@
             return Collections.emptySet();
         }
         Set<Object> result = new HashSet<Object>();
-
-        for (Set<?> item : items) {
-            if (item != null) {
-                result.addAll(item);
-            }
-        }
-
+        Arrays.stream(items).filter(Objects::nonNull).forEach(item -> result.addAll(item));","[{'comment': 'same as above.', 'commenter': 'kun-song'}]"
3238,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/merger/ListMerger.java,"@@ -31,12 +33,8 @@
         if (ArrayUtils.isEmpty(items)) {
             return Collections.emptyList();
         }
-        List<Object> result = new ArrayList<Object>();
-        for (List<?> item : items) {
-            if (item != null) {
-                result.addAll(item);
-            }
-        }
+        List<Object> result = Arrays.stream(items).filter(Objects::nonNull)
+                .flatMap(item -> item.stream()).collect(Collectors.toList());","[{'comment': ""One more thing, it's customary to statically import functions such as `toList/toSet` from `Collectors`, since this will make the code more readable."", 'commenter': 'kun-song'}, {'comment': 'I think static import can make code clearer, but it can not help code more readable because I don’t  know where the method comes from unless I trace to the class that declares the method.', 'commenter': 'tswstarplanet'}, {'comment': 'I think static import can make code clearer, but it can not help code more readable because I don’t  know where the method comes from unless I trace to the class that declares the method.', 'commenter': 'tswstarplanet'}]"
3238,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/merger/MapMerger.java,"@@ -30,12 +33,8 @@
         if (ArrayUtils.isEmpty(items)) {
             return Collections.emptyMap();
         }
-        Map<Object, Object> result = new HashMap<Object, Object>();
-        for (Map<?, ?> item : items) {
-            if (item != null) {
-                result.putAll(item);
-            }
-        }
+        Map<Object, Object> result = Arrays.stream(items).filter(Objects::nonNull).map(Map::entrySet)
+                .flatMap(Set::stream).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));","[{'comment': 'Same as above.', 'commenter': 'kun-song'}, {'comment': 'Can these items have same elements? If so, we should provide a merge function here, or it will throws duplicated keys exception when encounter key-value mapping with same key.', 'commenter': 'kun-song'}]"
3238,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/merger/SetMerger.java,"@@ -30,14 +32,8 @@
         if (ArrayUtils.isEmpty(items)) {
             return Collections.emptySet();
         }
-        Set<Object> result = new HashSet<Object>();
-
-        for (Set<?> item : items) {
-            if (item != null) {
-                result.addAll(item);
-            }
-        }
-
+        Set<Object> result = Arrays.stream(items).filter(Objects::nonNull)
+                .flatMap(Set::stream).collect(Collectors.toSet());","[{'comment': 'Same as above.', 'commenter': 'kun-song'}]"
3274,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java,"@@ -68,141 +67,134 @@
 
     private static final String ACCESS_LOG_KEY = ""dubbo.accesslog"";
 
-    private static final String FILE_DATE_FORMAT = ""yyyyMMdd"";
-
-    private static final String MESSAGE_DATE_FORMAT = ""yyyy-MM-dd HH:mm:ss"";
-
     private static final int LOG_MAX_BUFFER = 5000;
 
     private static final long LOG_OUTPUT_INTERVAL = 5000;
 
-    private final ConcurrentMap<String, Set<String>> logQueue = new ConcurrentHashMap<String, Set<String>>();
-
-    private final ScheduledExecutorService logScheduled = Executors.newScheduledThreadPool(2, new NamedThreadFactory(""Dubbo-Access-Log"", true));
+    private static final String FILE_DATE_FORMAT = ""yyyyMMdd"";
 
-    private volatile ScheduledFuture<?> logFuture = null;
+    private static final ConcurrentMap<String, Set<AccessLogData>> logQueue = new ConcurrentHashMap<String, Set<AccessLogData>>();
 
-    private void init() {
-        if (logFuture == null) {
-            synchronized (logScheduled) {
-                if (logFuture == null) {
-                    logFuture = logScheduled.scheduleWithFixedDelay(new LogTask(), LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);
-                }
-            }
-        }
-    }
+    private static final ScheduledExecutorService logScheduled = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(""Dubbo-Access-Log"", true));
 
-    private void log(String accesslog, String logmessage) {
-        init();
-        Set<String> logSet = logQueue.get(accesslog);
-        if (logSet == null) {
-            logQueue.putIfAbsent(accesslog, new ConcurrentHashSet<String>());
-            logSet = logQueue.get(accesslog);
-        }
-        if (logSet.size() < LOG_MAX_BUFFER) {
-            logSet.add(logmessage);
-        }
+    /**
+     * Default constructor initialize demon thread for writing into access log file with names with access log key
+     * defined in url <b>accesslog</b>
+     */
+    public AccessLogFilter() {
+        logScheduled.scheduleWithFixedDelay(this::writeLogToFile, LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);
     }
 
+    /**
+     * This method logs the access log for service method invocation call.
+     *
+     * @param invoker service
+     * @param inv     Invocation service method.
+     * @return Result from service method.
+     * @throws RpcException
+     */
     @Override
     public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
         try {
-            String accesslog = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);
-            if (ConfigUtils.isNotEmpty(accesslog)) {
-                RpcContext context = RpcContext.getContext();
-                String serviceName = invoker.getInterface().getName();
-                String version = invoker.getUrl().getParameter(Constants.VERSION_KEY);
-                String group = invoker.getUrl().getParameter(Constants.GROUP_KEY);
-                StringBuilder sn = new StringBuilder();
-                sn.append(""["").append(new SimpleDateFormat(MESSAGE_DATE_FORMAT).format(new Date())).append(""] "").append(context.getRemoteHost()).append("":"").append(context.getRemotePort())
-                        .append("" -> "").append(context.getLocalHost()).append("":"").append(context.getLocalPort())
-                        .append("" - "");
-                if (null != group && group.length() > 0) {
-                    sn.append(group).append(""/"");
-                }
-                sn.append(serviceName);
-                if (null != version && version.length() > 0) {
-                    sn.append("":"").append(version);
-                }
-                sn.append("" "");
-                sn.append(inv.getMethodName());
-                sn.append(""("");
-                Class<?>[] types = inv.getParameterTypes();
-                if (types != null && types.length > 0) {
-                    boolean first = true;
-                    for (Class<?> type : types) {
-                        if (first) {
-                            first = false;
-                        } else {
-                            sn.append("","");
-                        }
-                        sn.append(type.getName());
-                    }
-                }
-                sn.append("") "");
-                Object[] args = inv.getArguments();
-                if (ArrayUtils.isNotEmpty(args)) {
-                    sn.append(JSON.toJSONString(args));
-                }
-                String msg = sn.toString();
-                if (ConfigUtils.isDefault(accesslog)) {
-                    LoggerFactory.getLogger(ACCESS_LOG_KEY + ""."" + invoker.getInterface().getName()).info(msg);
-                } else {
-                    log(accesslog, msg);
-                }
+            String accessLogKey = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);
+            if (ConfigUtils.isNotEmpty(accessLogKey)) {
+                AccessLogData logData = buildAccessLogData(invoker, inv);
+                log(accessLogKey, logData);
             }
         } catch (Throwable t) {
             logger.warn(""Exception in AcessLogFilter of service("" + invoker + "" -> "" + inv + "")"", t);
         }
         return invoker.invoke(inv);
     }
 
-    private class LogTask implements Runnable {
-        @Override
-        public void run() {
-            try {
-                if (logQueue != null && logQueue.size() > 0) {
-                    for (Map.Entry<String, Set<String>> entry : logQueue.entrySet()) {
-                        try {
-                            String accesslog = entry.getKey();
-                            Set<String> logSet = entry.getValue();
-                            File file = new File(accesslog);
-                            File dir = file.getParentFile();
-                            if (null != dir && !dir.exists()) {
-                                dir.mkdirs();
-                            }
-                            if (logger.isDebugEnabled()) {
-                                logger.debug(""Append log to "" + accesslog);
-                            }
-                            if (file.exists()) {
-                                String now = new SimpleDateFormat(FILE_DATE_FORMAT).format(new Date());
-                                String last = new SimpleDateFormat(FILE_DATE_FORMAT).format(new Date(file.lastModified()));
-                                if (!now.equals(last)) {
-                                    File archive = new File(file.getAbsolutePath() + ""."" + last);
-                                    file.renameTo(archive);
-                                }
-                            }
-                            FileWriter writer = new FileWriter(file, true);
-                            try {
-                                for (Iterator<String> iterator = logSet.iterator();
-                                     iterator.hasNext();
-                                     iterator.remove()) {
-                                    writer.write(iterator.next());
-                                    writer.write(""\r\n"");
-                                }
-                                writer.flush();
-                            } finally {
-                                writer.close();
-                            }
-                        } catch (Exception e) {
-                            logger.error(e.getMessage(), e);
+    private void log(String accessLog, AccessLogData accessLogData) {
+        Set<AccessLogData> logSet = logQueue.computeIfAbsent(accessLog, k -> new ConcurrentHashSet<>());
+
+        if (logSet.size() < LOG_MAX_BUFFER) {
+            logSet.add(accessLogData);
+        } else {
+            //TODO we needs use force writing to file so that buffer gets clear and new log can be written.
+            logger.warn(""AccessLog buffer is full skipping buffer "");
+        }
+    }
+
+    private void writeLogToFile() {
+        if (!logQueue.isEmpty()) {
+            for (Map.Entry<String, Set<AccessLogData>> entry : logQueue.entrySet()) {
+                try {
+                    String accessLog = entry.getKey();
+                    Set<AccessLogData> logSet = entry.getValue();
+                    if (ConfigUtils.isDefault(accessLog)) {
+                        processWithServiceLogger(logSet);
+                    } else {
+                        File file = new File(accessLog);
+                        createIfLogDirAbsent(file);
+                        if (logger.isDebugEnabled()) {
+                            logger.debug(""Append log to "" + accessLog);
                         }
+                        renameFile(file);
+                        processWithAccessKeyLogger(logSet, file);
                     }
+
+                } catch (Exception e) {
+                    logger.error(e.getMessage(), e);
                 }
-            } catch (Exception e) {
-                logger.error(e.getMessage(), e);
             }
         }
     }
 
-}
+    private void processWithAccessKeyLogger(Set<AccessLogData> logSet, File file) throws IOException {
+        FileWriter writer = new FileWriter(file, true);
+        try {
+            for (Iterator<AccessLogData> iterator = logSet.iterator();
+                 iterator.hasNext();
+                 iterator.remove()) {","[{'comment': 'need formation here.', 'commenter': 'kun-song'}, {'comment': 'Here we have list of access log, which we are writting and then removing entry.\r\n\r\nIf you would provide more specific question then may be I can answer those.', 'commenter': 'khanimteyaz'}]"
3274,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java,"@@ -68,141 +67,134 @@
 
     private static final String ACCESS_LOG_KEY = ""dubbo.accesslog"";
 
-    private static final String FILE_DATE_FORMAT = ""yyyyMMdd"";
-
-    private static final String MESSAGE_DATE_FORMAT = ""yyyy-MM-dd HH:mm:ss"";
-
     private static final int LOG_MAX_BUFFER = 5000;
 
     private static final long LOG_OUTPUT_INTERVAL = 5000;
 
-    private final ConcurrentMap<String, Set<String>> logQueue = new ConcurrentHashMap<String, Set<String>>();
-
-    private final ScheduledExecutorService logScheduled = Executors.newScheduledThreadPool(2, new NamedThreadFactory(""Dubbo-Access-Log"", true));
+    private static final String FILE_DATE_FORMAT = ""yyyyMMdd"";
 
-    private volatile ScheduledFuture<?> logFuture = null;
+    private static final ConcurrentMap<String, Set<AccessLogData>> logQueue = new ConcurrentHashMap<String, Set<AccessLogData>>();
 
-    private void init() {
-        if (logFuture == null) {
-            synchronized (logScheduled) {
-                if (logFuture == null) {
-                    logFuture = logScheduled.scheduleWithFixedDelay(new LogTask(), LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);
-                }
-            }
-        }
-    }
+    private static final ScheduledExecutorService logScheduled = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(""Dubbo-Access-Log"", true));
 
-    private void log(String accesslog, String logmessage) {
-        init();
-        Set<String> logSet = logQueue.get(accesslog);
-        if (logSet == null) {
-            logQueue.putIfAbsent(accesslog, new ConcurrentHashSet<String>());
-            logSet = logQueue.get(accesslog);
-        }
-        if (logSet.size() < LOG_MAX_BUFFER) {
-            logSet.add(logmessage);
-        }
+    /**
+     * Default constructor initialize demon thread for writing into access log file with names with access log key
+     * defined in url <b>accesslog</b>
+     */
+    public AccessLogFilter() {
+        logScheduled.scheduleWithFixedDelay(this::writeLogToFile, LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);
     }
 
+    /**
+     * This method logs the access log for service method invocation call.
+     *
+     * @param invoker service
+     * @param inv     Invocation service method.
+     * @return Result from service method.
+     * @throws RpcException
+     */
     @Override
     public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
         try {
-            String accesslog = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);
-            if (ConfigUtils.isNotEmpty(accesslog)) {
-                RpcContext context = RpcContext.getContext();
-                String serviceName = invoker.getInterface().getName();
-                String version = invoker.getUrl().getParameter(Constants.VERSION_KEY);
-                String group = invoker.getUrl().getParameter(Constants.GROUP_KEY);
-                StringBuilder sn = new StringBuilder();
-                sn.append(""["").append(new SimpleDateFormat(MESSAGE_DATE_FORMAT).format(new Date())).append(""] "").append(context.getRemoteHost()).append("":"").append(context.getRemotePort())
-                        .append("" -> "").append(context.getLocalHost()).append("":"").append(context.getLocalPort())
-                        .append("" - "");
-                if (null != group && group.length() > 0) {
-                    sn.append(group).append(""/"");
-                }
-                sn.append(serviceName);
-                if (null != version && version.length() > 0) {
-                    sn.append("":"").append(version);
-                }
-                sn.append("" "");
-                sn.append(inv.getMethodName());
-                sn.append(""("");
-                Class<?>[] types = inv.getParameterTypes();
-                if (types != null && types.length > 0) {
-                    boolean first = true;
-                    for (Class<?> type : types) {
-                        if (first) {
-                            first = false;
-                        } else {
-                            sn.append("","");
-                        }
-                        sn.append(type.getName());
-                    }
-                }
-                sn.append("") "");
-                Object[] args = inv.getArguments();
-                if (ArrayUtils.isNotEmpty(args)) {
-                    sn.append(JSON.toJSONString(args));
-                }
-                String msg = sn.toString();
-                if (ConfigUtils.isDefault(accesslog)) {
-                    LoggerFactory.getLogger(ACCESS_LOG_KEY + ""."" + invoker.getInterface().getName()).info(msg);
-                } else {
-                    log(accesslog, msg);
-                }
+            String accessLogKey = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);
+            if (ConfigUtils.isNotEmpty(accessLogKey)) {
+                AccessLogData logData = buildAccessLogData(invoker, inv);
+                log(accessLogKey, logData);
             }
         } catch (Throwable t) {
             logger.warn(""Exception in AcessLogFilter of service("" + invoker + "" -> "" + inv + "")"", t);
         }
         return invoker.invoke(inv);
     }
 
-    private class LogTask implements Runnable {
-        @Override
-        public void run() {
-            try {
-                if (logQueue != null && logQueue.size() > 0) {
-                    for (Map.Entry<String, Set<String>> entry : logQueue.entrySet()) {
-                        try {
-                            String accesslog = entry.getKey();
-                            Set<String> logSet = entry.getValue();
-                            File file = new File(accesslog);
-                            File dir = file.getParentFile();
-                            if (null != dir && !dir.exists()) {
-                                dir.mkdirs();
-                            }
-                            if (logger.isDebugEnabled()) {
-                                logger.debug(""Append log to "" + accesslog);
-                            }
-                            if (file.exists()) {
-                                String now = new SimpleDateFormat(FILE_DATE_FORMAT).format(new Date());
-                                String last = new SimpleDateFormat(FILE_DATE_FORMAT).format(new Date(file.lastModified()));
-                                if (!now.equals(last)) {
-                                    File archive = new File(file.getAbsolutePath() + ""."" + last);
-                                    file.renameTo(archive);
-                                }
-                            }
-                            FileWriter writer = new FileWriter(file, true);
-                            try {
-                                for (Iterator<String> iterator = logSet.iterator();
-                                     iterator.hasNext();
-                                     iterator.remove()) {
-                                    writer.write(iterator.next());
-                                    writer.write(""\r\n"");
-                                }
-                                writer.flush();
-                            } finally {
-                                writer.close();
-                            }
-                        } catch (Exception e) {
-                            logger.error(e.getMessage(), e);
+    private void log(String accessLog, AccessLogData accessLogData) {
+        Set<AccessLogData> logSet = logQueue.computeIfAbsent(accessLog, k -> new ConcurrentHashSet<>());
+
+        if (logSet.size() < LOG_MAX_BUFFER) {
+            logSet.add(accessLogData);
+        } else {
+            //TODO we needs use force writing to file so that buffer gets clear and new log can be written.
+            logger.warn(""AccessLog buffer is full skipping buffer "");
+        }
+    }
+
+    private void writeLogToFile() {
+        if (!logQueue.isEmpty()) {
+            for (Map.Entry<String, Set<AccessLogData>> entry : logQueue.entrySet()) {
+                try {
+                    String accessLog = entry.getKey();
+                    Set<AccessLogData> logSet = entry.getValue();
+                    if (ConfigUtils.isDefault(accessLog)) {
+                        processWithServiceLogger(logSet);
+                    } else {
+                        File file = new File(accessLog);
+                        createIfLogDirAbsent(file);
+                        if (logger.isDebugEnabled()) {
+                            logger.debug(""Append log to "" + accessLog);
                         }
+                        renameFile(file);
+                        processWithAccessKeyLogger(logSet, file);
                     }
+
+                } catch (Exception e) {
+                    logger.error(e.getMessage(), e);
                 }
-            } catch (Exception e) {
-                logger.error(e.getMessage(), e);
             }
         }
     }
 
-}
+    private void processWithAccessKeyLogger(Set<AccessLogData> logSet, File file) throws IOException {
+        FileWriter writer = new FileWriter(file, true);
+        try {
+            for (Iterator<AccessLogData> iterator = logSet.iterator();
+                 iterator.hasNext();
+                 iterator.remove()) {
+                writer.write(iterator.next().getLogMessage());
+                writer.write(""\r\n"");
+            }
+            writer.flush();
+        } finally {
+            writer.close();","[{'comment': '`FileWriter` can be used in try-with-resource, which is better.', 'commenter': 'kun-song'}, {'comment': 'done.', 'commenter': 'khanimteyaz'}]"
3274,dubbo-common/src/main/java/org/apache/dubbo/common/utils/DateUtil.java,"@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.utils;
+
+import org.apache.commons.lang3.time.FastDateFormat;
+
+import java.util.Date;
+
+/**
+ * This class is utility to provide dubbo date formatting and parsing.
+ */
+public final class DateUtil {
+
+    private DateUtil() {
+
+    };
+
+    /**
+     *  This method used to return a formatted string of a given date object.
+     * @param date Input data object
+     * @param format format of data.
+     * @return
+     */
+    public static String format(Date date,String format) {
+        Assert.notNull(date,""Given date can't be null"");
+        Assert.notEmptyString(format,""Given date format can't be null or empty"");","[{'comment': 'Need space here, such as between `format,` and `""Given date format can\'t be null or empty""`.', 'commenter': 'kun-song'}, {'comment': 'Done.', 'commenter': 'khanimteyaz'}]"
3274,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java,"@@ -68,141 +67,134 @@
 
     private static final String ACCESS_LOG_KEY = ""dubbo.accesslog"";
 
-    private static final String FILE_DATE_FORMAT = ""yyyyMMdd"";
-
-    private static final String MESSAGE_DATE_FORMAT = ""yyyy-MM-dd HH:mm:ss"";
-
     private static final int LOG_MAX_BUFFER = 5000;
 
     private static final long LOG_OUTPUT_INTERVAL = 5000;
 
-    private final ConcurrentMap<String, Set<String>> logQueue = new ConcurrentHashMap<String, Set<String>>();
-
-    private final ScheduledExecutorService logScheduled = Executors.newScheduledThreadPool(2, new NamedThreadFactory(""Dubbo-Access-Log"", true));
+    private static final String FILE_DATE_FORMAT = ""yyyyMMdd"";
 
-    private volatile ScheduledFuture<?> logFuture = null;
+    private static final ConcurrentMap<String, Set<AccessLogData>> logQueue = new ConcurrentHashMap<String, Set<AccessLogData>>();","[{'comment': 'We can use type inference which is better than explicit parameters.', 'commenter': 'kun-song'}, {'comment': ""And one more thing, why call it `logQueue`, but it's not a queue at all?"", 'commenter': 'kun-song'}, {'comment': '> We can use type inference which is better than explicit parameters.\r\n\r\nAgree.', 'commenter': 'khanimteyaz'}, {'comment': ""> And one more thing, why call it `logQueue`, but it's not a queue at all?\r\n\r\nYup. Changes to **logEntries**"", 'commenter': 'khanimteyaz'}, {'comment': 'Done.', 'commenter': 'khanimteyaz'}]"
3274,dubbo-common/pom.xml,"@@ -39,6 +39,10 @@
             <groupId>commons-logging</groupId>
             <artifactId>commons-logging</artifactId>
         </dependency>
+        <dependency>","[{'comment': ""Let's avoid of introducing new dependency into the distribution. In this case, it looks like FastDateFormat doesn't help us much, since we are using the same instance in single thread to format all.\r\n\r\nIf I am wrong, try to include FastDataFormat's source code in Dubbo project, and update LICENSE file."", 'commenter': 'beiwei30'}, {'comment': 'As FasDataFormat has better performance then other as a sample performance check was done by @lixiaojiee  [here](https://github.com/apache/incubator-dubbo/pull/3090#issuecomment-453394557). \r\n\r\nAs you suggested we can add the source code of FastDataFormat in dubbo project it self, would you help me by guiding what is the approach of doing it.  Is that we can copy code of FastDataFormat and adding a license file? Any help would be appreciated.', 'commenter': 'khanimteyaz'}, {'comment': ""@khanimteyaz \r\nI think u should copy the code of the class. I saw that the common-langs use apache lisence, so don't forget copy the license header (pls use FastDateFormtat's license header not dubbo's).\r\n\r\nAfter copy the code, u should modify dubbo-parent file (pom file). U should add a apache-rat-plugin's exclude line like `<exclude>**/org/apache/dubbo/common/threadlocal/InternalThreadLocalMap.java</exclude>`. \r\n\r\nFinally, u should modify the LICENSE file. In the tail of the file, it can also find some examples."", 'commenter': 'carryxyh'}, {'comment': '@carryxyh and @beiwei30 thanks for guidance. I have made the requires changes. Could you have a look.', 'commenter': 'khanimteyaz'}]"
3276,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/CloseTimerTask.java,"@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.remoting.exchange.support.header;
+
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.Channel;
+
+/**
+ * CloseTimerTask
+ */
+public class CloseTimerTask extends AbstractTimerTask {
+
+    private static final Logger logger = LoggerFactory.getLogger(CloseTimerTask.class);
+
+    private final int idleTimeout;
+
+    public CloseTimerTask(ChannelProvider channelProvider, Long heartbeatTimeoutTick, int idleTimeout) {
+        super(channelProvider, heartbeatTimeoutTick);
+        this.idleTimeout = idleTimeout;
+    }
+
+    @Override
+    protected void doTask(Channel channel) {
+        try {
+            Long lastRead = lastRead(channel);
+            Long lastWrite = lastWrite(channel);
+            Long now = now();
+            // check ping & pong at server
+            if ((lastRead != null && now - lastRead > idleTimeout)","[{'comment': 'I could be wrong here, but just wanted to understand and would love to gets wrong myself 😄 .  In the scenario where channel has received data but have not perform any write or vice versa should we consider as timeout  (as we have OR condition based check).\r\n ', 'commenter': 'khanimteyaz'}, {'comment': 'In **HeaderExchangeHandler.java** disconnect method we are setting KEY_READ_TIMESTAMP and KEY_WRITE_TIMESTAMP with the value of System.currentTimeMillis() , will these impact this detection here? Should we also consider whether a given channel has already been closed or not? What do you say?', 'commenter': 'khanimteyaz'}, {'comment': 'invocation can be divided into two kinds: normal, heartbeat. Both of them should update the  KEY_READ_TIMESTAMP and KEY_WRITE_TIMESTAMP. This is a deliberate design, which means IDLE CHECK.', 'commenter': 'lexburner'}]"
3276,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java,"@@ -39,11 +39,10 @@
 
     private final Client client;
     private final ExchangeChannel channel;
-    // heartbeat(ms), default value is 0 , won't execute a heartbeat.
     private int heartbeat;
-    private int heartbeatTimeout;
+    private int idleTimeout;
 
-    private HashedWheelTimer heartbeatTimer;
+    private HashedWheelTimer idleCheckTimer;
 
     public HeaderExchangeClient(Client client, boolean needHeartbeat) {
         if (client == null) {","[{'comment': 'Can be replace with \r\n`Assert.notNull(client, ""Client can\'t be null"");`\r\n\r\nas already dubbo already have a util for this.', 'commenter': 'khanimteyaz'}]"
3276,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java,"@@ -55,16 +54,16 @@ public HeaderExchangeClient(Client client, boolean needHeartbeat) {
 
         this.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != null &&
                 dubbo.startsWith(""1.0."") ? Constants.DEFAULT_HEARTBEAT : 0);","[{'comment': '`private final int NO_HEARTBEAT = 0;`\r\ncan we replace **0** in case if **dubbo** does not start with **1.0** with NO_HEARTBEAT for better readability.', 'commenter': 'khanimteyaz'}, {'comment': ""The magic number is indeed troublesome, but it isn't related to this pull request. Let us change them in other pr."", 'commenter': 'lexburner'}]"
3276,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeServer.java,"@@ -48,25 +48,24 @@
     protected final Logger logger = LoggerFactory.getLogger(getClass());
 
     private final Server server;
-    // heartbeat timeout (ms), default value is 0 , won't execute a heartbeat.
     private int heartbeat;
-    private int heartbeatTimeout;
+    private int idleTimeout;
     private AtomicBoolean closed = new AtomicBoolean(false);
 
-    private HashedWheelTimer heartbeatTimer;
+    private HashedWheelTimer idleCheckTimer;
 
     public HeaderExchangeServer(Server server) {
         if (server == null) {","[{'comment': 'can be replace with \r\n\r\nCan be replace with\r\nAssert.notNull(server, ""Server can\'t be null"");\r\n\r\nas already dubbo already have a util for this.', 'commenter': 'khanimteyaz'}]"
3276,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeServer.java,"@@ -210,14 +209,14 @@ public void reset(URL url) {
                 int h = url.getParameter(Constants.HEARTBEAT_KEY, heartbeat);","[{'comment': '**h** can be rename to **urlHeartBeatKey** what do you say?', 'commenter': 'khanimteyaz'}]"
3276,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeServer.java,"@@ -210,14 +209,14 @@ public void reset(URL url) {
                 int h = url.getParameter(Constants.HEARTBEAT_KEY, heartbeat);
                 int t = url.getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, h * 3);","[{'comment': 'can be renamed to **urlTimeoutKey**. What do you say?', 'commenter': 'khanimteyaz'}, {'comment': 'These variable names are named by other people. In my opinion, stay the same is also OK.', 'commenter': 'lexburner'}]"
3276,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java,"@@ -178,28 +174,20 @@ public boolean hasAttribute(String key) {
         return channel.hasAttribute(key);
     }
 
-    private void startHeartbeatTimer() {
+    private void startIdleCheckTask() {
         AbstractTimerTask.ChannelProvider cp = () -> Collections.singletonList(HeaderExchangeClient.this);
 
         long heartbeatTick = calculateLeastDuration(heartbeat);
-        long heartbeatTimeoutTick = calculateLeastDuration(heartbeatTimeout);
+        long heartbeatTimeoutTick = calculateLeastDuration(idleTimeout);
         HeartbeatTimerTask heartBeatTimerTask = new HeartbeatTimerTask(cp, heartbeatTick, heartbeat);
-        ReconnectTimerTask reconnectTimerTask = new ReconnectTimerTask(cp, heartbeatTimeoutTick, heartbeatTimeout);
+        ReconnectTimerTask reconnectTimerTask = new ReconnectTimerTask(cp, heartbeatTimeoutTick, idleTimeout);
 
         // init task and start timer.
-        heartbeatTimer.newTimeout(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS);
-        heartbeatTimer.newTimeout(reconnectTimerTask, heartbeatTimeoutTick, TimeUnit.MILLISECONDS);
-    }
-
-    private void stopHeartbeatTimer() {","[{'comment': 'why can we remove `stopHeartbeatTimer()`?', 'commenter': 'beiwei30'}, {'comment': 'The timer to send heartbeat was an instance of every `Connection` before this change, I have changed the scope of `Timer` to `static`, so we could not close the heartbeat timer by non-static method. ', 'commenter': 'lexburner'}, {'comment': 'i see.', 'commenter': 'beiwei30'}]"
3276,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java,"@@ -39,32 +40,27 @@
 
     private final Client client;
     private final ExchangeChannel channel;
-    // heartbeat(ms), default value is 0 , won't execute a heartbeat.
     private int heartbeat;
-    private int heartbeatTimeout;
+    private int idleTimeout;
 
-    private HashedWheelTimer heartbeatTimer;
+    private static HashedWheelTimer idleCheckTimer = new HashedWheelTimer(new NamedThreadFactory(""dubbo-client-idleCheck"", true), 1,","[{'comment': '\r\nI think we should establish a mapping relationship between client and task.\r\n\r\nSince we are using the global Timer at the moment, when any client is closed, we should cancel the task corresponding to this client. In this way, we can guarantee that our tasks will not be too much.', 'commenter': 'carryxyh'}]"
3280,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/ShutDownTelnetHandler.java,"@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.dubbo.telnet;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.config.DubboShutdownHook;
+import org.apache.dubbo.remoting.Channel;
+import org.apache.dubbo.remoting.RemotingException;
+import org.apache.dubbo.remoting.telnet.TelnetHandler;
+import org.apache.dubbo.remoting.telnet.support.Help;
+
+/**
+ * ShutDownTelnetHandler
+ */
+@Activate
+@Help(parameter = ""[-t <milliseconds>]"", summary = ""Shutdown Dubbo Application."", detail = ""Shutdown Dubbo Application."")
+public class ShutDownTelnetHandler implements TelnetHandler {","[{'comment': '```suggestion\r\npublic class ShutdownTelnetHandler implements TelnetHandler {\r\n```\r\nShould this name be like this?', 'commenter': 'lixiaojiee'}, {'comment': '> Suggested change Beta \r\n> [Give us feedback](https://www.research.net/r/SuggestedChanges)\r\n> public class ShutDownTelnetHandler implements TelnetHandler {\r\n> public class ShutdownTelnetHandler implements TelnetHandler {\r\n> Commit suggestion  Add suggestion to batch\r\n> Should this name be like this?\r\n\r\nsame as DubboShutdownHook', 'commenter': 'LiZhenNet'}, {'comment': 'I have renamed it.', 'commenter': 'LiZhenNet'}]"
3280,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java,"@@ -85,6 +85,8 @@ public void doDestroy() {
         if (!destroyed.compareAndSet(false, true)) {
             return;
         }
+        // unregister the shutdownHook
+        unregister();","[{'comment': 'don\'t call `unregister` here. When shutdown hook runs, it will lead to IllegalStateException if we try to remove the hook.\r\n\r\n```java\r\n    static synchronized void add(Thread hook) {\r\n        if(hooks == null)\r\n            throw new IllegalStateException(""Shutdown in progress"");\r\n\r\n        if (hook.isAlive())\r\n            throw new IllegalArgumentException(""Hook already running"");\r\n\r\n        if (hooks.containsKey(hook))\r\n            throw new IllegalArgumentException(""Hook previously registered"");\r\n\r\n        hooks.put(hook, hook);\r\n    }\r\n```', 'commenter': 'beiwei30'}, {'comment': '> don\'t call `unregister` here. When shutdown hook runs, it will lead to IllegalStateException if we try to remove the hook.\r\n> \r\n> ```java\r\n>     static synchronized void add(Thread hook) {\r\n>         if(hooks == null)\r\n>             throw new IllegalStateException(""Shutdown in progress"");\r\n> \r\n>         if (hook.isAlive())\r\n>             throw new IllegalArgumentException(""Hook already running"");\r\n> \r\n>         if (hooks.containsKey(hook))\r\n>             throw new IllegalArgumentException(""Hook previously registered"");\r\n> \r\n>         hooks.put(hook, hook);\r\n>     }\r\n> ```\r\n\r\nI remove it', 'commenter': 'LiZhenNet'}]"
3283,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/DubboConfigBindingBeanPostProcessor.java,"@@ -126,8 +128,7 @@ public void setApplicationContext(ApplicationContext applicationContext) throws
         this.applicationContext = applicationContext;
     }
 
-    @Override
-    public void afterPropertiesSet() throws Exception {
+    public void init() {","[{'comment': 'If we allow to create sub class of this **DubboConfigBindingBeanPostProcessor ** and some **init method** get override then it might cause issue. So better to make init final or provide. What do you say?', 'commenter': 'khanimteyaz'}, {'comment': 'Yep, agree with u. So how about make it pirate?', 'commenter': 'zhuchao941'}, {'comment': 'That should work. Thanks for your consideration.', 'commenter': 'khanimteyaz'}]"
3291,dubbo-registry/dubbo-registry-redis/src/main/java/org/apache/dubbo/registry/redis/RedisRegistry.java,"@@ -428,7 +428,7 @@ private void doNotify(Jedis jedis, Collection<String> keys, URL url, Collection<
             }
             List<URL> urls = new ArrayList<>();
             Map<String, String> values = jedis.hgetAll(key);
-            if (CollectionUtils.isEmptyMap(values)) {
+            if (!CollectionUtils.isEmptyMap(values)) {","[{'comment': 'Thanks for this PR. Could you add a UT for this?', 'commenter': 'khanimteyaz'}, {'comment': ""Is it necessary? This is my first PR，I don't know much about。"", 'commenter': 'dadadadudu'}, {'comment': '@boomblog no worries I will add that on behalf of you 😃 and will guide you on this . As a practice we follow to add UT if there is conditional changes. \r\n\r\nFYI I have created an [issue ](https://github.com/apache/incubator-dubbo/issues/3312) for the same.\r\n\r\nThanks for raising this PR and the contribution. Welcome.', 'commenter': 'khanimteyaz'}, {'comment': '`CollectionUtils.isNotEmptyMap(values)` seems better to me :)', 'commenter': 'kun-song'}, {'comment': '@boomblog This suggestion is good, please modify it.', 'commenter': 'CrazyHZM'}]"
3299,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeServer.java,"@@ -53,9 +57,11 @@
     private int idleTimeout;
     private AtomicBoolean closed = new AtomicBoolean(false);
 
-    private static HashedWheelTimer idleCheckTimer = new HashedWheelTimer(new NamedThreadFactory(""dubbo-server-idleCheck"", true), 1,
+    private static final HashedWheelTimer IDLE_CHECK_TIMER = new HashedWheelTimer(new NamedThreadFactory(""dubbo-server-idleCheck"", true), 1,
             TimeUnit.SECONDS, Constants.TICKS_PER_WHEEL);
 
+    private static final Map<ExchangeServer, List<Timeout>> SERVER_TASKS = new ConcurrentHashMap<>();","[{'comment': 'should we simply keep **Timeout** instance (instead of keeping it in a map)?', 'commenter': 'beiwei30'}]"
3299,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java,"@@ -43,9 +49,11 @@
     private int heartbeat;
     private int idleTimeout;
 
-    private static HashedWheelTimer idleCheckTimer = new HashedWheelTimer(new NamedThreadFactory(""dubbo-client-idleCheck"", true), 1,
+    private static final HashedWheelTimer IDLE_CHECK_TIMER = new HashedWheelTimer(new NamedThreadFactory(""dubbo-client-idleCheck"", true), 1,
             TimeUnit.SECONDS, Constants.TICKS_PER_WHEEL);
 
+    private static final Map<ExchangeClient, List<Timeout>> CLIENT_TASKS = new ConcurrentHashMap<>();","[{'comment': 'should we simply keep Timeout instance (instead of keeping it in a map)?', 'commenter': 'beiwei30'}]"
3299,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java,"@@ -43,9 +47,11 @@
     private int heartbeat;
     private int idleTimeout;
 
-    private static HashedWheelTimer idleCheckTimer = new HashedWheelTimer(new NamedThreadFactory(""dubbo-client-idleCheck"", true), 1,
+    private static final HashedWheelTimer IDLE_CHECK_TIMER = new HashedWheelTimer(new NamedThreadFactory(""dubbo-client-idleCheck"", true), 1,
             TimeUnit.SECONDS, Constants.TICKS_PER_WHEEL);
 
+    private List<Timeout> tasks = new ArrayList<>();","[{'comment': 'is an array list here a little bit over-kill?', 'commenter': 'beiwei30'}]"
3299,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeServer.java,"@@ -53,9 +55,11 @@
     private int idleTimeout;
     private AtomicBoolean closed = new AtomicBoolean(false);
 
-    private static HashedWheelTimer idleCheckTimer = new HashedWheelTimer(new NamedThreadFactory(""dubbo-server-idleCheck"", true), 1,
+    private static final HashedWheelTimer IDLE_CHECK_TIMER = new HashedWheelTimer(new NamedThreadFactory(""dubbo-server-idleCheck"", true), 1,
             TimeUnit.SECONDS, Constants.TICKS_PER_WHEEL);
 
+    private List<Timeout> tasks = new ArrayList<>();","[{'comment': 'is an array list here a little bit over-kill?', 'commenter': 'beiwei30'}]"
3299,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java,"@@ -183,11 +189,20 @@ private void startIdleCheckTask() {
         ReconnectTimerTask reconnectTimerTask = new ReconnectTimerTask(cp, heartbeatTimeoutTick, idleTimeout);
 
         // init task and start timer.
-        idleCheckTimer.newTimeout(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS);
-        idleCheckTimer.newTimeout(reconnectTimerTask, heartbeatTimeoutTick, TimeUnit.MILLISECONDS);
+        Timeout heartBeatTimeout = IDLE_CHECK_TIMER.newTimeout(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS);
+        Timeout reconnectTimeout = IDLE_CHECK_TIMER.newTimeout(reconnectTimerTask, heartbeatTimeoutTick, TimeUnit.MILLISECONDS);
+
+        tasks.add(heartBeatTimeout);
+        tasks.add(reconnectTimeout);
     }
 
     private void doClose() {
+        if (CollectionUtils.isNotEmpty(tasks)) {
+            for (Timeout timeout : tasks) {
+                timeout.cancel();","[{'comment': ""timeout.cancel will never success when the task has expired once,because in this case it's status will be ST_EXPIRED , and in this case, based on org.apache.dubbo.common.timer.HashedWheelTimer.HashedWheelTimeout#cancel method code as following\r\n```\r\npublic boolean cancel() {\r\n            // only update the state it will be removed from HashedWheelBucket on next tick.\r\n            if (!compareAndSetState(ST_INIT, ST_CANCELLED)) {\r\n                return false;\r\n            }\r\n            // If a task should be canceled we put this to another queue which will be processed on each tick.\r\n            // So this means that we will have a GC latency of max. 1 tick duration which is good enough. This way\r\n            // we can make again use of our MpscLinkedQueue and so minimize the locking / overhead as much as possible.\r\n            timer.cancelledTimeouts.add(this);\r\n            return true;\r\n        }\r\n```\r\ncompareAndSetState will always reture false. Am I right?"", 'commenter': 'kexianjun'}]"
3301,dubbo-compatible/src/test/java/org/apache/dubbo/generic/GenericServiceTest.java,"@@ -108,7 +107,7 @@ public void testGenericComplexCompute4FullServiceMetadata() {
 
         FullServiceDefinition fullServiceDefinition = ServiceDefinitionBuilder.buildFullDefinition(DemoService.class);
         MethodDefinition methodDefinition = getMethod(""complexCompute"", fullServiceDefinition.getMethods());
-        Map parm2= createComplextObject(fullServiceDefinition,var1, var2, l, var3, var4, testEnum);
+        Map parm2= createComplexObject(fullServiceDefinition,var1, var2, l, var3, var4, testEnum);","[{'comment': 'The name `parm2` looks weird to me. Could you improve it? And there should be a space before the equal sign.', 'commenter': 'ralf0131'}]"
3333,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationInjectedBeanPostProcessor.java,"@@ -46,13 +42,7 @@
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
+import java.util.*;","[{'comment': ""Don't use import * pls."", 'commenter': 'carryxyh'}, {'comment': ""> Don't use import * pls.\r\nI have fix it . It change by Idea's optimize import\r\n"", 'commenter': 'LiZhenNet'}]"
3341,dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java,"@@ -467,6 +467,31 @@ public static boolean isProvider(URL url) {
                 PROVIDERS_CATEGORY.equals(url.getParameter(CATEGORY_KEY, PROVIDERS_CATEGORY));
     }
 
+    public static int getHeartbeat(URL url) {
+        String dubbo = url.getParameter(Constants.DUBBO_VERSION_KEY);
+        return url.getParameter(Constants.HEARTBEAT_KEY, dubbo != null &&
+                dubbo.startsWith(""1.0."") ? Constants.DEFAULT_HEARTBEAT : 0);","[{'comment': 'Since `2.0.x` has been widely adopted, keep the `1.0.x` compatible code may be unnecessary and remove it may make code cleaner. What do you think?', 'commenter': 'chickenlj'}]"
3341,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java,"@@ -210,6 +215,38 @@ private long calculateLeastDuration(int time) {
         }
     }
 
+    private boolean shouldHeartbeat(URL url) {
+        String transporter = url.getParameter(CLIENT_KEY, url.getParameter(TRANSPORTER_KEY, ""netty""));
+        return !transporter.equalsIgnoreCase(""netty"") && !transporter.equalsIgnoreCase(""netty4"");
+    }
+
+    private boolean shouldReconnect(URL url) {
+        boolean reconnect = url.getParameter(Constants.SEND_RECONNECT_KEY, false);
+        if (!reconnect) {
+            String param = url.getParameter(Constants.RECONNECT_KEY, ""true"");
+            if (""false"".equalsIgnoreCase(param)) {","[{'comment': '`RECONNECT_KEY`\r\nIs RECONNECT_KEY a boolean type or string? I am a little confused.\r\nhttps://github.com/apache/incubator-dubbo/pull/3341/files#diff-db21f00081f086cb06625a6fad1c2e6aR486', 'commenter': 'chickenlj'}, {'comment': ""Seems like it's designed to accept both boolean an integer."", 'commenter': 'chickenlj'}, {'comment': ""yes, it's correct. Check the code in https://github.com/apache/incubator-dubbo/pull/3341#issuecomment-457987238"", 'commenter': 'beiwei30'}]"
3341,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java,"@@ -102,6 +106,20 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
         }
     }
 
+    @Override
+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
+        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
+        try {
+            if (evt instanceof IdleStateEvent) {","[{'comment': 'Seems like we should keep the logic same with NettyClientHandler. We can call `NettyChannel.getOrAddChannel` after `if (evt instanceof IdleStateEvent)`', 'commenter': 'carryxyh'}, {'comment': ""I got another question here.\r\nIdleStateEvent will happen for every `heartbeat` write&read idle, but shouldn't we only close the channel for n times of IdleStateEvent (n*heartbeat)?"", 'commenter': 'chickenlj'}, {'comment': 'Can simply use `int heartbeatInterval = UrlUtils.getHeartbeat(getUrl()) * 3;` to fix this problem? @chickenlj ', 'commenter': 'carryxyh'}, {'comment': 'Yes, I notice @beiwei30 has just fixed it using getIdleTimeout.', 'commenter': 'chickenlj'}, {'comment': ""> I got another question here.\r\nIdleStateEvent will happen for every heartbeat write&read idle, but shouldn't we only close the channel for n times of IdleStateEvent (n*heartbeat)?\r\n\r\nchange to use **idle timeout**."", 'commenter': 'beiwei30'}, {'comment': '> Seems like we should keep the logic same with NettyClientHandler. We can call NettyChannel.getOrAddChannel after if (evt instanceof IdleStateEvent)\r\n\r\ndone.', 'commenter': 'beiwei30'}]"
3341,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeServer.java,"@@ -266,15 +255,21 @@ private long calculateLeastDuration(int time) {
         }
     }
 
-    private void startIdleCheckTask() {
-        AbstractTimerTask.ChannelProvider cp = () -> unmodifiableCollection(HeaderExchangeServer.this.getChannels());
-
-        long idleTimeoutTick = calculateLeastDuration(idleTimeout);
-        CloseTimerTask closeTimerTask = new CloseTimerTask(cp, idleTimeoutTick, idleTimeout);
-        this.closeTimerTask = closeTimerTask;
+    private void startIdleCheckTask(URL url) {
+        if (shouldStartCloseTimer(url)) {
+            AbstractTimerTask.ChannelProvider cp = () -> unmodifiableCollection(HeaderExchangeServer.this.getChannels());
+            int idleTimeout = UrlUtils.getIdleTimeout(url);
+            long idleTimeoutTick = calculateLeastDuration(idleTimeout);
+            CloseTimerTask closeTimerTask = new CloseTimerTask(cp, idleTimeoutTick, idleTimeout);
+            this.closeTimerTask = closeTimerTask;
 
-        // init task and start timer.
-        IDLE_CHECK_TIMER.newTimeout(closeTimerTask, idleTimeoutTick, TimeUnit.MILLISECONDS);
+            // init task and start timer.
+            IDLE_CHECK_TIMER.newTimeout(closeTimerTask, idleTimeoutTick, TimeUnit.MILLISECONDS);
+        }
     }
 
+    private boolean shouldStartCloseTimer(URL url) {","[{'comment': 'Seems like this move this method into URLUtils is better?', 'commenter': 'carryxyh'}, {'comment': ""I am hesitate to move it since I don't think this method is the most appropriate approach. Let's keep it there as a workaround. In my opinion, we should add a new interface **HealthCheckCapatable**, and let both server and client to implement it to avoid hardcode 'netty' in HeaderExchangeServer and HeaderExchangeClient:\r\n\r\n```java\r\npublic interface Server extends Endpoint, Resetable, HeartbeatCapatable {\r\n\r\n}\r\n```\r\n\r\nI didn't do it since I cannot be able to come up a good interface name."", 'commenter': 'beiwei30'}]"
3341,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java,"@@ -210,6 +215,38 @@ private long calculateLeastDuration(int time) {
         }
     }
 
+    private boolean shouldHeartbeat(URL url) {","[{'comment': 'Same with shouldStartCloseTimer.\r\nSeems like these two methods can be merged into one method which named like `isNettyTransport` or sth...', 'commenter': 'carryxyh'}, {'comment': 'ditto, same reason, check above.', 'commenter': 'beiwei30'}]"
3341,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/ReconnectTimerTask.java,"@@ -41,9 +41,18 @@ protected void doTask(Channel channel) {
         try {
             Long lastRead = lastRead(channel);
             Long now = now();
+
+            // Rely on reconnect timer to reconnect when AbstractClient.doConnect fails to init the connection
+            if (!channel.isConnected()) {","[{'comment': ""A channel may still keep connected but has not read/write for `n*heartbeat`, which means `channel.isConnect` may always return true. I don't see you ever try to close the channel on receiving say n times of `IdleStateEvent `."", 'commenter': 'chickenlj'}, {'comment': ""Never mind, it's ok to go. Now I understand that `!channel.isConnected()` here is used to guarantee initial connection."", 'commenter': 'chickenlj'}, {'comment': 'server will close the channel.', 'commenter': 'beiwei30'}]"
3344,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java,"@@ -230,22 +230,15 @@ public void register(URL url) {
             // Sending a registration request to the server side
             doRegister(url);
         } catch (Exception e) {
-            Throwable t = e;
-
             // If the startup detection is opened, the Exception is thrown directly.
             boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)
                     && url.getParameter(Constants.CHECK_KEY, true)
                     && !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());
-            boolean skipFailback = t instanceof SkipFailbackWrapperException;
-            if (check || skipFailback) {
-                if (skipFailback) {
-                    t = t.getCause();
-                }
-                throw new IllegalStateException(""Failed to register "" + url + "" to registry "" + getUrl().getAddress() + "", cause: "" + t.getMessage(), t);
+            if (check ) {","[{'comment': 'There is an extra space here:\r\n\r\n```Java\r\nif (check )\r\n```', 'commenter': 'kun-song'}]"
3350,dubbo-compatible/src/main/java/com/alibaba/dubbo/common/URL.java,"@@ -26,6 +26,10 @@
 @Deprecated
 public class URL extends org.apache.dubbo.common.URL {
 
+    protected URL() {","[{'comment': 'seems like public is better.', 'commenter': 'carryxyh'}, {'comment': ""@carryxyh  I don't think so. Because a good URL must have basic information, such as protocol, host, port."", 'commenter': 'chenlushun'}, {'comment': 'emmm...\r\nMaybe u are right. Seems like a protected constructor can fix this problem, too.', 'commenter': 'carryxyh'}]"
3363,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProxyProtocol.java,"@@ -67,7 +67,11 @@ public void setProxyFactory(ProxyFactory proxyFactory) {
         Exporter<T> exporter = (Exporter<T>) exporterMap.get(uri);
         if (exporter != null) {
             // When modifying the configuration through override, you need to re-expose the newly modified service.
-            if (exporter.getInvoker().getUrl().equals(invoker.getUrl())) {
+            if (""hessian"".equals(invoker.getUrl().getProtocol())) {
+                if (exporter.getInvoker().getUrl().equals(invoker.getUrl())) {","[{'comment': 'Could `getUrl` return null here? If so, `Objects.equals` might be better.', 'commenter': 'kun-song'}, {'comment': 'You are right, I will modify it.', 'commenter': 'CrazyHZM'}]"
3363,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProxyProtocol.java,"@@ -66,7 +67,14 @@ public void setProxyFactory(ProxyFactory proxyFactory) {
         final String uri = serviceKey(invoker.getUrl());
         Exporter<T> exporter = (Exporter<T>) exporterMap.get(uri);
         if (exporter != null) {
-            return exporter;
+            // When modifying the configuration through override, you need to re-expose the newly modified service.
+            if (""hessian"".equals(invoker.getUrl().getProtocol())) {","[{'comment': 'We should not add special check for ""hessian"". It looks like we should compare URL for all proxy protocol when the cache is hit.', 'commenter': 'beiwei30'}]"
3387,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java,"@@ -149,13 +151,27 @@ private InvocationHandler buildInvocationHandler(String referencedBeanName, Refe
 
         private Object bean;
 
+        private final Logger logger = LoggerFactory.getLogger(ReferenceBeanInvocationHandler.class);
+
+
         private ReferenceBeanInvocationHandler(ReferenceBean referenceBean) {
             this.referenceBean = referenceBean;
         }
 
         @Override
         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-            return method.invoke(bean, args);
+            try {
+                return method.invoke(bean, args);
+            } catch (Throwable e) {
+                logger.error(""Convert RpcException to real exception"");
+
+                Throwable t;
+                while ((t = e.getCause()) != null) {","[{'comment': 'Why not use `if`', 'commenter': 'CrazyHZM'}, {'comment': ""see #3386 and https://github.com/apache/incubator-dubbo/blob/master/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ExceptionFilter.java\r\n\r\nWe don't know depth of the exception, but we want to get the Innermost cause."", 'commenter': 'eachcan'}, {'comment': 'Yes, this process can solve this problem.\r\nBut a small opinion, you can add comments, do not need to print a log of error', 'commenter': 'CrazyHZM'}]"
3387,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java,"@@ -149,13 +151,27 @@ private InvocationHandler buildInvocationHandler(String referencedBeanName, Refe
 
         private Object bean;
 
+        private final Logger logger = LoggerFactory.getLogger(ReferenceBeanInvocationHandler.class);
+
+
         private ReferenceBeanInvocationHandler(ReferenceBean referenceBean) {
             this.referenceBean = referenceBean;
         }
 
         @Override
         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-            return method.invoke(bean, args);
+            try {
+                return method.invoke(bean, args);
+            } catch (Throwable e) {
+                logger.error(""Convert RpcException to real exception"");
+
+                Throwable t;
+                while ((t = e.getCause()) != null) {
+                    e = t;
+                }
+
+                throw e;","[{'comment': 'It can be thrown directly here, it does not need to judge, what do you think?', 'commenter': 'CrazyHZM'}, {'comment': '接口声明中 throws 的异常是 `ValidationException`，但是消费者捕获到的却是 `UndeclaredThrowableException`，此处通过解析出最内层的 `Throwable`，来符合接口声明。\r\n\r\n', 'commenter': 'eachcan'}, {'comment': '为何最内层的 Throwable 可以符合接口声明呢？\r\n1. 在我们使用了 `ExceptionFilter` 的情况下，将会由 ExceptionFilter 构造出同 Provider 中抛出的相同的 `Exception `(`{""error"": { ""data"": {""name"": ""....""}}}`)，此时可以捕获到相同的异常（Stacktrace不相同，此处暂时忽略，需要其他解决方案）。\r\n2. 在没有使用 `ExceptionFilter` 的情况下，将会由 `com.googlecode.jsonrpc4j.DefaultExceptionResolver` 抛出一个可以由消费者使用的异常\r\n3. 以上两种情况抛出的异常均是消费者感兴趣的，但是由于通过 `Proxy` 调用 invoker，invoker 抛出的所有异常均会包装为 `UndeclaredThrowableException`，故我们需要在 handler 中将此异常还原为 invoker 中的异常。', 'commenter': 'eachcan'}, {'comment': 'Hi, @CrazyHZM.\r\n\r\nWill this pr be merge into master branch? Or else be refused?\r\n\r\nEnglish version of previous answer:\r\n\r\n**Why does it need to judge?**\r\n\r\nService interface defines `throws ValidationException`, but `try { ... } catch (ValidationException e) { }` in consumer side do not work.\r\n\r\nConsumer side gets `UndeclaredThrowableException` instead. So I add this pr to convert this Exception to the expected one.\r\n\r\n**How to do this**\r\n\r\n`DefaultExceptionResolver` or `ExceptionFilter` will repackage the exception from provider side, so we go inside and re-throw the innermost one.\r\n\r\nThis works.', 'commenter': 'eachcan'}, {'comment': 'Looks good to me. \r\n@beiwei30\r\nPlease you review this PR.', 'commenter': 'CrazyHZM'}]"
3387,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java,"@@ -149,13 +151,27 @@ private InvocationHandler buildInvocationHandler(String referencedBeanName, Refe
 
         private Object bean;
 
+        private final Logger logger = LoggerFactory.getLogger(ReferenceBeanInvocationHandler.class);
+
+
         private ReferenceBeanInvocationHandler(ReferenceBean referenceBean) {
             this.referenceBean = referenceBean;
         }
 
         @Override
         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-            return method.invoke(bean, args);
+            try {
+                return method.invoke(bean, args);
+            } catch (Throwable e) {
+                logger.error(""Convert RpcException to real exception"");","[{'comment': 'i think better to log throwable also e.g. `logger.error(""Convert RpcException to real exception"",t);`', 'commenter': 'khanimteyaz'}]"
3389,dubbo-common/src/main/java/org/apache/dubbo/common/logger/LoggerFactory.java,"@@ -34,40 +36,44 @@
  */
 public class LoggerFactory {
 
-    private static final ConcurrentMap<String, FailsafeLogger> LOGGERS = new ConcurrentHashMap<String, FailsafeLogger>();
+    private static final ConcurrentMap<String, FailsafeLogger> LOGGERS = new ConcurrentHashMap<>();
     private static volatile LoggerAdapter LOGGER_ADAPTER;
 
     // search common-used logging frameworks
     static {
-        String logger = System.getProperty(""dubbo.application.logger"");
-        if (""slf4j"".equals(logger)) {
-            setLoggerAdapter(new Slf4jLoggerAdapter());
-        } else if (""jcl"".equals(logger)) {
-            setLoggerAdapter(new JclLoggerAdapter());
-        } else if (""log4j"".equals(logger)) {
-            setLoggerAdapter(new Log4jLoggerAdapter());
-        } else if (""jdk"".equals(logger)) {
-            setLoggerAdapter(new JdkLoggerAdapter());
-        } else if (""log4j2"".equals(logger)) {
-            setLoggerAdapter(new Log4j2LoggerAdapter());
-        } else {
-            try {
+        String logger = System.getProperty(""dubbo.application.logger"", """");
+        switch (logger) {
+            case ""slf4j"":
+                setLoggerAdapter(new Slf4jLoggerAdapter());
+                break;
+            case ""jcl"":
+                setLoggerAdapter(new JclLoggerAdapter());
+                break;
+            case ""log4j"":
                 setLoggerAdapter(new Log4jLoggerAdapter());
-            } catch (Throwable e1) {
-                try {
-                    setLoggerAdapter(new Slf4jLoggerAdapter());
-                } catch (Throwable e2) {
+                break;
+            case ""jdk"":
+                setLoggerAdapter(new JdkLoggerAdapter());
+                break;
+            case ""log4j2"":
+                setLoggerAdapter(new Log4j2LoggerAdapter());
+                break;
+            default:
+                List<Class<? extends LoggerAdapter>> candidates = Arrays.asList(
+                        Log4jLoggerAdapter.class,
+                        Slf4jLoggerAdapter.class,
+                        Log4j2LoggerAdapter.class,
+                        JclLoggerAdapter.class,
+                        JdkLoggerAdapter.class
+                );
+                for (Class<? extends LoggerAdapter> clazz : candidates) {
                     try {
-                        setLoggerAdapter(new Log4j2LoggerAdapter());
-                    } catch (Throwable e3) {
-                        try {
-                            setLoggerAdapter(new JclLoggerAdapter());
-                        } catch (Throwable e4) {
-                            setLoggerAdapter(new JdkLoggerAdapter());
-                        }
+                        setLoggerAdapter(clazz.newInstance());
+                        break;
+                    } catch (Throwable ignored) {
                     }
                 }
-            }
+                break;","[{'comment': 'Seems no need to `break` in default ?', 'commenter': 'kun-song'}, {'comment': ""yes, just a personal habit, I've removed it"", 'commenter': 'kezhenxu94'}]"
3389,dubbo-common/src/main/java/org/apache/dubbo/common/logger/LoggerFactory.java,"@@ -34,40 +36,43 @@
  */
 public class LoggerFactory {
 
-    private static final ConcurrentMap<String, FailsafeLogger> LOGGERS = new ConcurrentHashMap<String, FailsafeLogger>();
+    private static final ConcurrentMap<String, FailsafeLogger> LOGGERS = new ConcurrentHashMap<>();
     private static volatile LoggerAdapter LOGGER_ADAPTER;
 
     // search common-used logging frameworks
     static {
-        String logger = System.getProperty(""dubbo.application.logger"");
-        if (""slf4j"".equals(logger)) {
-            setLoggerAdapter(new Slf4jLoggerAdapter());
-        } else if (""jcl"".equals(logger)) {
-            setLoggerAdapter(new JclLoggerAdapter());
-        } else if (""log4j"".equals(logger)) {
-            setLoggerAdapter(new Log4jLoggerAdapter());
-        } else if (""jdk"".equals(logger)) {
-            setLoggerAdapter(new JdkLoggerAdapter());
-        } else if (""log4j2"".equals(logger)) {
-            setLoggerAdapter(new Log4j2LoggerAdapter());
-        } else {
-            try {
+        String logger = System.getProperty(""dubbo.application.logger"", """");
+        switch (logger) {
+            case ""slf4j"":
+                setLoggerAdapter(new Slf4jLoggerAdapter());
+                break;
+            case ""jcl"":
+                setLoggerAdapter(new JclLoggerAdapter());
+                break;
+            case ""log4j"":
                 setLoggerAdapter(new Log4jLoggerAdapter());
-            } catch (Throwable e1) {
-                try {
-                    setLoggerAdapter(new Slf4jLoggerAdapter());
-                } catch (Throwable e2) {
+                break;
+            case ""jdk"":
+                setLoggerAdapter(new JdkLoggerAdapter());
+                break;
+            case ""log4j2"":
+                setLoggerAdapter(new Log4j2LoggerAdapter());
+                break;
+            default:
+                List<Class<? extends LoggerAdapter>> candidates = Arrays.asList(
+                        Log4jLoggerAdapter.class,
+                        Slf4jLoggerAdapter.class,
+                        Log4j2LoggerAdapter.class,","[{'comment': 'Is it need 3 other log class:  Log4j2LoggerAdapter, JclLoggerAdapter, JdkLoggerAdapter.', 'commenter': 'cvictory'}, {'comment': '![image](https://user-images.githubusercontent.com/15965696/51969315-0c8db100-24af-11e9-9bf7-eedaa1f69729.png)\r\n@cvictory  What do you mean, did I miss anything out?', 'commenter': 'kezhenxu94'}]"
3389,dubbo-common/src/main/java/org/apache/dubbo/common/logger/LoggerFactory.java,"@@ -103,12 +108,7 @@ public static void setLoggerAdapter(LoggerAdapter loggerAdapter) {
      * @return logger
      */
     public static Logger getLogger(Class<?> key) {
-        FailsafeLogger logger = LOGGERS.get(key.getName());
-        if (logger == null) {
-            LOGGERS.putIfAbsent(key.getName(), new FailsafeLogger(LOGGER_ADAPTER.getLogger(key)));
-            logger = LOGGERS.get(key.getName());
-        }
-        return logger;
+        return LOGGERS.computeIfAbsent(key.getName(), name -> new FailsafeLogger(LOGGER_ADAPTER.getLogger(key)));","[{'comment': 'I would suggest :\r\n\r\n```java\r\nreturn LOGGERS.computeIfAbsent(key.getName(), name -> new FailsafeLogger(LOGGER_ADAPTER.getLogger(name)));\r\n```\r\nfor a better readability.\r\nNote parameter for `getLogger` has been changed from `key` to `name`.\r\n', 'commenter': 'ralf0131'}, {'comment': ""@ralf0131 If that's the case, why not just call the overloaded version `public static Logger getLogger(String key)`, `return getLogger(key.getName())`"", 'commenter': 'kezhenxu94'}, {'comment': ""When you are writing lambda x -> f(x) , `x` is just a placeholder, but in the function f(x) you treat  x as input parameters. \r\n\r\nEquivalently, in your case, it should be `name -> new FailsafeLogger(LOGGER_ADAPTER.getLogger(name))`, and `key` will be passed to the function at runtime.\r\n\r\nYou've implemented the same logic at Line 121.\r\n\r\nWhen you are writing `name -> new FailsafeLogger(LOGGER_ADAPTER.getLogger(key))`, you are treating the function as zero parameter function, where `key` is a constant in this case."", 'commenter': 'ralf0131'}, {'comment': ""I know what you meant, I'll update this patch to show what I meant"", 'commenter': 'kezhenxu94'}, {'comment': '@ralf0131 Updated.', 'commenter': 'kezhenxu94'}, {'comment': ""No, I didn't mean to call the overloaded method. Instead, I prefer your initial implementation. Call the overloaded method will introduce more overhead.\r\n\r\nYour initial implementation is logically correct, what I mean is a minor change to improve the readability. You just need to replace `key` to `name`."", 'commenter': 'ralf0131'}, {'comment': '> You just need to replace key to name\r\n\r\nThat will also change the logic before this patch, it assumes that `org.apache.dubbo.common.logger.LoggerAdapter#getLogger(java.lang.Class<?>)` and `org.apache.dubbo.common.logger.LoggerAdapter#getLogger(java.lang.String)` return the same logger(which may be true in this case).\r\n\r\nMy thought was that `org.apache.dubbo.common.logger.LoggerFactory#getLogger(java.lang.Class<?>)` will get the logger via the key which is type of `Class` and, if I ""replace key with name"", the actual logger is got via name(which is type of `String`), anyway, it\'s the same in this situation, I\'ll update it soon', 'commenter': 'kezhenxu94'}, {'comment': '@ralf0131 updated', 'commenter': 'kezhenxu94'}]"
3410,dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java,"@@ -714,33 +703,87 @@ private void loadClass(Map<String, Class<?>> extensionClasses, java.net.URL reso
                     throw new IllegalStateException(""No such extension name for the class "" + clazz.getName() + "" in the config "" + resourceURL);
                 }
             }
+            
             String[] names = NAME_SEPARATOR.split(name);
-            if (names != null && names.length > 0) {
-                Activate activate = clazz.getAnnotation(Activate.class);
-                if (activate != null) {
-                    cachedActivates.put(names[0], activate);
-                } else {
-                    // support com.alibaba.dubbo.common.extension.Activate
-                    com.alibaba.dubbo.common.extension.Activate oldActivate = clazz.getAnnotation(com.alibaba.dubbo.common.extension.Activate.class);
-                    if (oldActivate != null) {
-                        cachedActivates.put(names[0], oldActivate);
-                    }
-                }
-                for (String n : names) {
-                    if (!cachedNames.containsKey(clazz)) {
-                        cachedNames.put(clazz, n);
-                    }
-                    Class<?> c = extensionClasses.get(n);
-                    if (c == null) {
-                        extensionClasses.put(n, clazz);
-                    } else if (c != clazz) {
-                        throw new IllegalStateException(""Duplicate extension "" + type.getName() + "" name "" + n + "" on "" + c.getName() + "" and "" + clazz.getName());
-                    }
-                }
+            cacheActivateClass(clazz, names[0]);","[{'comment': ""We should use defensive programming to judge **names** is not either null or empty, plus, I suggest we should loop **names** once and only once, see below:\r\n\r\n\r\n```suggestion\r\n            String[] names = NAME_SEPARATOR.split(name);\r\n            if (ArrayUtils.isNotEmpty(names)) {\r\n                cacheActivateClass(clazz, names[0]);\r\n                for (String n : names) {\r\n                    cacheName(clazz, n);\r\n                    saveInExtensionClass(extensionClasses, clazz, name);\r\n                }\r\n            }\r\n```\r\n\r\nLet's loop outside, and change cacheNames to cacheName, and change saveInExtensionClasses to saveInExtensionClass"", 'commenter': 'beiwei30'}]"
3410,dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java,"@@ -714,33 +704,87 @@ private void loadClass(Map<String, Class<?>> extensionClasses, java.net.URL reso
                     throw new IllegalStateException(""No such extension name for the class "" + clazz.getName() + "" in the config "" + resourceURL);
                 }
             }
+            
             String[] names = NAME_SEPARATOR.split(name);
-            if (names != null && names.length > 0) {
-                Activate activate = clazz.getAnnotation(Activate.class);
-                if (activate != null) {
-                    cachedActivates.put(names[0], activate);
-                } else {
-                    // support com.alibaba.dubbo.common.extension.Activate
-                    com.alibaba.dubbo.common.extension.Activate oldActivate = clazz.getAnnotation(com.alibaba.dubbo.common.extension.Activate.class);
-                    if (oldActivate != null) {
-                        cachedActivates.put(names[0], oldActivate);
-                    }
-                }
+            if (ArrayUtils.isNotEmpty(names)) {
+                cacheActivateClass(clazz, names[0]);
                 for (String n : names) {
-                    if (!cachedNames.containsKey(clazz)) {
-                        cachedNames.put(clazz, n);
-                    }
-                    Class<?> c = extensionClasses.get(n);
-                    if (c == null) {
-                        extensionClasses.put(n, clazz);
-                    } else if (c != clazz) {
-                        throw new IllegalStateException(""Duplicate extension "" + type.getName() + "" name "" + n + "" on "" + c.getName() + "" and "" + clazz.getName());
-                    }
+                    cacheName(clazz, n);
+                    saveInExtensionClass(extensionClasses, clazz, name);
                 }
             }
         }
     }
 
+    /**
+     * cache name
+     */
+    private void cacheName(Class<?> clazz, String name) {
+        if (!cachedNames.containsKey(clazz)) {
+            cachedNames.put(clazz, name);","[{'comment': 'This can be simplified as:\r\n\r\n```Java\r\ncachedNames.putIfAbsent(clazz, name);\r\n```\r\n\r\nwhich is an atomic operation.', 'commenter': 'kun-song'}, {'comment': 'thank you', 'commenter': 'wanghbxxxx'}]"
3412,dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/support/ActivateComparator.java,"@@ -1,86 +1,94 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.alibaba.dubbo.common.extension.support;
-
-import com.alibaba.dubbo.common.extension.Activate;
-import com.alibaba.dubbo.common.extension.ExtensionLoader;
-import com.alibaba.dubbo.common.extension.SPI;
-
-import java.util.Comparator;
-
-/**
- * OrderComparetor
- */
-public class ActivateComparator implements Comparator<Object> {
-
-    public static final Comparator<Object> COMPARATOR = new ActivateComparator();
-
-    @Override
-    public int compare(Object o1, Object o2) {
-        if (o1 == null && o2 == null) {
-            return 0;
-        }
-        if (o1 == null) {
-            return -1;
-        }
-        if (o2 == null) {
-            return 1;
-        }
-        if (o1.equals(o2)) {
-            return 0;
-        }
-        Activate a1 = o1.getClass().getAnnotation(Activate.class);
-        Activate a2 = o2.getClass().getAnnotation(Activate.class);
-        if ((a1.before().length > 0 || a1.after().length > 0
-                || a2.before().length > 0 || a2.after().length > 0)
-                && o1.getClass().getInterfaces().length > 0
-                && o1.getClass().getInterfaces()[0].isAnnotationPresent(SPI.class)) {
-            ExtensionLoader<?> extensionLoader = ExtensionLoader.getExtensionLoader(o1.getClass().getInterfaces()[0]);
-            if (a1.before().length > 0 || a1.after().length > 0) {
-                String n2 = extensionLoader.getExtensionName(o2.getClass());
-                for (String before : a1.before()) {
-                    if (before.equals(n2)) {
-                        return -1;
-                    }
-                }
-                for (String after : a1.after()) {
-                    if (after.equals(n2)) {
-                        return 1;
-                    }
-                }
-            }
-            if (a2.before().length > 0 || a2.after().length > 0) {
-                String n1 = extensionLoader.getExtensionName(o1.getClass());
-                for (String before : a2.before()) {
-                    if (before.equals(n1)) {
-                        return 1;
-                    }
-                }
-                for (String after : a2.after()) {
-                    if (after.equals(n1)) {
-                        return -1;
-                    }
-                }
-            }
-        }
-        int n1 = a1 == null ? 0 : a1.order();
-        int n2 = a2 == null ? 0 : a2.order();
-        // never return 0 even if n1 equals n2, otherwise, o1 and o2 will override each other in collection like HashSet
-        return n1 > n2 ? 1 : -1;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.alibaba.dubbo.common.extension.support;
+
+import com.alibaba.dubbo.common.extension.Activate;
+import com.alibaba.dubbo.common.extension.ExtensionLoader;
+import com.alibaba.dubbo.common.extension.SPI;
+
+import java.util.Comparator;
+
+/**
+ * OrderComparetor
+ */
+public class ActivateComparator implements Comparator<Object> {
+
+    public static final Comparator<Object> COMPARATOR = new ActivateComparator();
+
+    @Override
+    public int compare(Object o1, Object o2) {
+        if (o1 == null && o2 == null) {
+            return 0;
+        }
+        if (o1 == null) {
+            return -1;
+        }
+        if (o2 == null) {
+            return 1;
+        }
+        if (o1.equals(o2)) {
+            return 0;
+        }
+        Activate a1 = o1.getClass().getAnnotation(Activate.class);
+        Activate a2 = o2.getClass().getAnnotation(Activate.class);
+        Class<?> spiClass = null;
+        if(o1.getClass().getInterfaces().length > 0){","[{'comment': 'pay attention to the code style: \r\n```suggestion\r\n        if (o1.getClass().getInterfaces().length > 0) {\r\n```', 'commenter': 'beiwei30'}, {'comment': 'thanks！！', 'commenter': 'dongYES'}]"
3425,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"@@ -119,15 +121,15 @@ protected void setUrl(URL url) {
     }
 
     public Set<URL> getRegistered() {
-        return registered;
+        return Collections.unmodifiableSet(registered);","[{'comment': '@kezhenxu94  thanks for this PR. As you are returning the copy of collection, i think you can avoid making it unmodifiable. ', 'commenter': 'khanimteyaz'}, {'comment': ""Hi @khanimteyaz , it's just a wrapper, not a copy, so it's OK here :)"", 'commenter': 'kun-song'}]"
3425,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"@@ -50,6 +51,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.stream.Collectors;","[{'comment': 'This line should be removed.', 'commenter': 'kun-song'}]"
3430,dubbo-registry/dubbo-registry-multicast/src/main/java/com/alibaba/dubbo/registry/multicast/MulticastRegistry.java,"@@ -83,19 +84,20 @@ public MulticastRegistry(URL url) {
             throw new IllegalArgumentException(""Invalid multicast address "" + url.getHost() + "", scope: 224.0.0.0 - 239.255.255.255"");","[{'comment': 'L82-L84 can be removed, since it is already included in `checkMulticastAddress`', 'commenter': 'ralf0131'}]"
3437,dubbo-container/dubbo-container-api/src/main/java/org/apache/dubbo/container/Main.java,"@@ -33,6 +33,8 @@
 
 /**
  * Main. (API, Static, ThreadSafe)
+ *
+ * This class is entry point loading containers.","[{'comment': 'Is this saying better? ""This class is an entry point to load containers.""', 'commenter': 'kezhenxu94'}, {'comment': ""I think it's fine."", 'commenter': 'beiwei30'}]"
3447,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -341,7 +333,15 @@ public synchronized void export() {
         }
 
         if (delay != null && delay > 0) {
-            delayExportExecutor.schedule(this::doExport, delay, TimeUnit.MILLISECONDS);","[{'comment': 'can we call `delayExportExecutor.shutdown()` method after the delay task add work queue?', 'commenter': 'scxwhite'}, {'comment': 'Yes,This is another way to fix this . ', 'commenter': 'LiZhenNet'}, {'comment': ""Don't think so.\r\nIf I want to export the service at runtime(use `ServiceConfig`), turning off `delayExportExecutor` will cause problems."", 'commenter': 'carryxyh'}, {'comment': ""> Don't think so.\r\n> If I want to export the service at runtime(use `ServiceConfig`), turning off `delayExportExecutor` will cause problems.\r\n\r\nyou are right"", 'commenter': 'LiZhenNet'}, {'comment': ""> Don't think so.\r\n> If I want to export the service at runtime(use `ServiceConfig`), turning off `delayExportExecutor` will cause problems.\r\n\r\nyes."", 'commenter': 'scxwhite'}]"
3447,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -102,11 +99,6 @@
      */
     private static final Map<String, Integer> RANDOM_PORT_MAP = new HashMap<String, Integer>();
 
-    /**
-     * A delayed exposure service timer
-     */
-    private static final ScheduledExecutorService delayExportExecutor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(""DubboServiceDelayExporter"", true));","[{'comment': ""It seems that this delayExportExecutor is a global delay exposed component. I don't think we can delete this field.\r\n\r\nSince `ServiceConfig` exists, we can export the service at runtime, so we can't determine if `delayExportExecutor` will still be used. In addition, maintaining an object in memory does not have a big impact."", 'commenter': 'carryxyh'}, {'comment': '> Each ServerConfig instance holds its own delayExportExecutor and delayExportExecutor only used for delay exporting,I feel it is unnecessary to use it.\r\n\r\nagree with @carryxyh , all ServiceConfig holds the same delayExportExecutor', 'commenter': 'kexianjun'}, {'comment': ""My fault,  I didn't notice that it was static.\r\n\r\n"", 'commenter': 'LiZhenNet'}]"
3447,dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java,"@@ -143,6 +151,15 @@ public void testProxy() throws Exception {
         assertEquals(2, TestProxyFactory.count); // local injvm and registry protocol, so expected is 2
     }
 
+
+    @Test
+    public void testDelayExport() throws Exception {
+        delayService.export();
+        //add 300ms to ensure that the delayService has been exported","[{'comment': 'It looks like it would be nice to add an assert here.', 'commenter': 'lixiaojiee'}]"
3456,dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java,"@@ -624,6 +624,22 @@ private boolean isSetter(Method method) {
 
     // synchronized in getExtensionClasses
     private Map<String, Class<?>> loadExtensionClasses() {
+        cacheDefaultExtensionName();
+
+        Map<String, Class<?>> extensionClasses = new HashMap<String, Class<?>>();","[{'comment': '```suggestion\r\n        Map<String, Class<?>> extensionClasses = new HashMap<>();\r\n```\r\nIt looks better like this.', 'commenter': 'lixiaojiee'}]"
3490,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java,"@@ -189,21 +188,29 @@ public void destroy() {
 
     @Override
     public synchronized void notify(List<URL> urls) {
-        List<URL> categoryUrls = urls.stream()
+        Map<String, List<URL>> categoryUrls = urls.stream()","[{'comment': 'could you add filter for url not null as well. In case if caller is providing null url, this is just to be safer. In case if you are already doing then ignore my comment.', 'commenter': 'khanimteyaz'}, {'comment': '@khanimteyaz done', 'commenter': 'kezhenxu94'}]"
3490,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java,"@@ -426,7 +435,7 @@ private URL mergeUrl(URL providerUrl) {
         this.overrideDirectoryUrl = this.overrideDirectoryUrl.addParametersIfAbsent(providerUrl.getParameters()); // Merge the provider side parameters
 
         if ((providerUrl.getPath() == null || providerUrl.getPath()
-                .length() == 0) && ""dubbo"".equals(providerUrl.getProtocol())) { // Compatible version 1.0
+                .length() == 0) && Constants.DOBBO_PROTOCOL.equals(providerUrl.getProtocol())) { // Compatible version 1.0","[{'comment': 'The pr #3491  which has been merged into the main branch has changed this constant name. \r\nWould you please update the latest code and change it here?', 'commenter': 'lixiaojiee'}, {'comment': '@lixiaojiee done', 'commenter': 'kezhenxu94'}]"
3497,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/annotation/Reference.java,"@@ -1,265 +1,270 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config.annotation;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.rpc.ExporterListener;
-import org.apache.dubbo.rpc.Filter;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * Reference
- *
- * @export
- */
-@Documented
-@Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE})
-public @interface Reference {
-    /**
-     * Interface class, default value is void.class
-     */
-    Class<?> interfaceClass() default void.class;
-
-    /**
-     * Interface class name, default value is empty string
-     */
-    String interfaceName() default """";
-
-    /**
-     * Service version, default value is empty string
-     */
-    String version() default """";
-
-    /**
-     * Service group, default value is empty string
-     */
-    String group() default """";
-
-    /**
-     * Service target URL for direct invocation, if this is specified, then registry center takes no effect.
-     */
-    String url() default """";
-
-    /**
-     * Client transport type, default value is ""netty""
-     */
-    String client() default """";
-
-    /**
-     * Whether to enable generic invocation, default value is false
-     */
-    boolean generic() default false;
-
-    /**
-     * When enable, prefer to call local service in the same JVM if it's present, default value is true
-     */
-    boolean injvm() default true;
-
-    /**
-     * Check if service provider is available during boot up, default value is true
-     */
-    boolean check() default true;
-
-    /**
-     * Whether eager initialize the reference bean when all properties are set, default value is false
-     */
-    boolean init() default false;
-
-    /**
-     * Whether to make connection when the client is created, the default value is false
-     */
-    boolean lazy() default false;
-
-    /**
-     * Export an stub service for event dispatch, default value is false.
-     *
-     * @see Constants#STUB_EVENT_METHODS_KEY
-     */
-    boolean stubevent() default false;
-
-    /**
-     * Whether to reconnect if connection is lost, if not specify, reconnect is enabled by default, and the interval
-     * for retry connecting is 2000 ms
-     *
-     * @see Constants#DEFAULT_RECONNECT_PERIOD
-     */
-    String reconnect() default """";
-
-    /**
-     * Whether to stick to the same node in the cluster, the default value is false
-     *
-     * @see Constants#DEFAULT_CLUSTER_STICKY
-     */
-    boolean sticky() default false;
-
-    /**
-     * How the proxy is generated, legal values include: jdk, javassist
-     */
-    String proxy() default """";
-
-    /**
-     * Service stub name, use interface name + Local if not set
-     */
-    String stub() default """";
-
-    /**
-     * Cluster strategy, legal values include: failover, failfast, failsafe, failback, forking
-     */
-    String cluster() default """";
-
-    /**
-     * Maximum connections service provider can accept, default value is 0 - connection is shared
-     */
-    int connections() default 0;
-
-    /**
-     * The callback instance limit peer connection
-     *
-     * @see Constants#DEFAULT_CALLBACK_INSTANCES
-     */
-    int callbacks() default 0;
-
-    /**
-     * Callback method name when connected, default value is empty string
-     */
-    String onconnect() default """";
-
-    /**
-     * Callback method name when disconnected, default value is empty string
-     */
-    String ondisconnect() default """";
-
-    /**
-     * Service owner, default value is empty string
-     */
-    String owner() default """";
-
-    /**
-     * Service layer, default value is empty string
-     */
-    String layer() default """";
-
-    /**
-     * Service invocation retry times
-     *
-     * @see Constants#DEFAULT_RETRIES
-     */
-    int retries() default 2;
-
-    /**
-     * Load balance strategy, legal values include: random, roundrobin, leastactive
-     *
-     * @see Constants#DEFAULT_LOADBALANCE
-     */
-    String loadbalance() default """";
-
-    /**
-     * Whether to enable async invocation, default value is false
-     */
-    boolean async() default false;
-
-    /**
-     * Maximum active requests allowed, default value is 0
-     */
-    int actives() default 0;
-
-    /**
-     * Whether the async request has already been sent, the default value is false
-     */
-    boolean sent() default false;
-
-    /**
-     * Service mock name, use interface name + Mock if not set
-     */
-    String mock() default """";
-
-    /**
-     * Whether to use JSR303 validation, legal values are: true, false
-     */
-    String validation() default """";
-
-    /**
-     * Timeout value for service invocation, default value is 0
-     */
-    int timeout() default 0;
-
-    /**
-     * Specify cache implementation for service invocation, legal values include: lru, threadlocal, jcache
-     */
-    String cache() default """";
-
-    /**
-     * Filters for service invocation
-     *
-     * @see Filter
-     */
-    String[] filter() default {};
-
-    /**
-     * Listeners for service exporting and unexporting
-     *
-     * @see ExporterListener
-     */
-    String[] listener() default {};
-
-    /**
-     * Customized parameter key-value pair, for example: {key1, value1, key2, value2}
-     */
-    String[] parameters() default {};
-
-    /**
-     * Application spring bean name
-     */
-    String application() default """";
-
-    /**
-     * Module spring bean name
-     */
-    String module() default """";
-
-    /**
-     * Consumer spring bean name
-     */
-    String consumer() default """";
-
-    /**
-     * Monitor spring bean name
-     */
-    String monitor() default """";
-
-    /**
-     * Registry spring bean name
-     */
-    String[] registry() default {};
-
-    /**
-     * Protocol spring bean names
-     */
-    String protocol() default """";
-
-    /**
-     * methods support
-     * @return
-     */
-    Method[] methods() default {};
-}
+/*","[{'comment': 'pls recover end-line format of this file', 'commenter': 'AlbumenJ'}]"
3500,dubbo-common/src/main/java/org/apache/dubbo/common/URLBuilder.java,"@@ -0,0 +1,342 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common;
+
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
+public final class URLBuilder {
+    private String protocol;
+
+    private String username;
+
+    private String password;
+
+    // by default, host to registry
+    private String host;
+
+    // by default, port to registry
+    private int port;
+
+    private String path;
+
+    private Map<String, String> parameters;
+
+    public URLBuilder() {
+        protocol = null;
+        username = null;
+        password = null;
+        host = null;
+        port = 0;
+        path = null;
+        parameters = new HashMap<>();
+    }
+
+    public URLBuilder(String protocol, String host, int port) {
+        this(protocol, null, null, host, port, null, null);
+    }
+
+    public URLBuilder(String protocol, String host, int port, String[] pairs) { // varargs ... conflict with the following path argument, use array instead.
+        this(protocol, null, null, host, port, null, CollectionUtils.toStringMap(pairs));
+    }
+
+    public URLBuilder(String protocol, String host, int port, Map<String, String> parameters) {
+        this(protocol, null, null, host, port, null, parameters);
+    }
+
+    public URLBuilder(String protocol, String host, int port, String path) {
+        this(protocol, null, null, host, port, path, null);
+    }
+
+    public URLBuilder(String protocol, String host, int port, String path, String... pairs) {
+        this(protocol, null, null, host, port, path, CollectionUtils.toStringMap(pairs));
+    }
+
+    public URLBuilder(String protocol, String host, int port, String path, Map<String, String> parameters) {
+        this(protocol, null, null, host, port, path, parameters);
+    }
+
+    public URLBuilder(String protocol, String username, String password, String host, int port, String path, Map<String, String> parameters) {
+        this.protocol = protocol;
+        this.username = username;
+        this.password = password;
+        this.host = host;
+        this.port = port;
+        this.path = path;
+        this.parameters = parameters != null ? parameters : new HashMap<>();
+    }
+
+    public URLBuilder(URL url) {
+        protocol = url.getProtocol();
+        username = url.getUsername();
+        password = url.getPassword();
+        host = url.getHost();
+        port = url.getPort();
+        path = url.getPath();
+        parameters = new HashMap<>(url.getParameters());
+    }","[{'comment': 'I think providing a method like`URLBuilder.from(url)` would be better than using a constructor directly.\r\n\r\nWhat do you think?', 'commenter': 'chickenlj'}, {'comment': 'updated as requested', 'commenter': 'kezhenxu94'}]"
3500,dubbo-common/src/main/java/org/apache/dubbo/common/URLBuilder.java,"@@ -0,0 +1,342 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common;
+
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
+public final class URLBuilder {
+    private String protocol;
+
+    private String username;
+
+    private String password;
+
+    // by default, host to registry
+    private String host;
+
+    // by default, port to registry
+    private int port;
+
+    private String path;
+
+    private Map<String, String> parameters;
+
+    public URLBuilder() {
+        protocol = null;
+        username = null;
+        password = null;
+        host = null;
+        port = 0;
+        path = null;
+        parameters = new HashMap<>();
+    }
+
+    public URLBuilder(String protocol, String host, int port) {
+        this(protocol, null, null, host, port, null, null);
+    }
+
+    public URLBuilder(String protocol, String host, int port, String[] pairs) { // varargs ... conflict with the following path argument, use array instead.
+        this(protocol, null, null, host, port, null, CollectionUtils.toStringMap(pairs));
+    }
+
+    public URLBuilder(String protocol, String host, int port, Map<String, String> parameters) {
+        this(protocol, null, null, host, port, null, parameters);
+    }
+
+    public URLBuilder(String protocol, String host, int port, String path) {
+        this(protocol, null, null, host, port, path, null);
+    }
+
+    public URLBuilder(String protocol, String host, int port, String path, String... pairs) {
+        this(protocol, null, null, host, port, path, CollectionUtils.toStringMap(pairs));
+    }
+
+    public URLBuilder(String protocol, String host, int port, String path, Map<String, String> parameters) {
+        this(protocol, null, null, host, port, path, parameters);
+    }
+
+    public URLBuilder(String protocol, String username, String password, String host, int port, String path, Map<String, String> parameters) {
+        this.protocol = protocol;
+        this.username = username;
+        this.password = password;
+        this.host = host;
+        this.port = port;
+        this.path = path;
+        this.parameters = parameters != null ? parameters : new HashMap<>();
+    }
+
+    public URLBuilder(URL url) {
+        protocol = url.getProtocol();
+        username = url.getUsername();
+        password = url.getPassword();
+        host = url.getHost();
+        port = url.getPort();
+        path = url.getPath();
+        parameters = new HashMap<>(url.getParameters());
+    }
+
+    public URL build() {
+        if (StringUtils.isEmpty(username) && StringUtils.isNotEmpty(password)) {
+            throw new IllegalArgumentException(""Invalid url, password without username!"");
+        }
+        port = port < 0 ? 0 : port;
+        // trim the leading ""/""
+        int firstNonSlash = 0;
+        if (path != null) {
+            while (firstNonSlash < path.length() && path.charAt(firstNonSlash) == '/') {
+                firstNonSlash++;
+            }
+            if (firstNonSlash >= path.length()) {
+                path = """";
+            } else if (firstNonSlash > 0) {
+                path = path.substring(firstNonSlash);
+            }
+        }
+        return new URL(protocol, username, password, host, port, path, parameters);
+    }
+
+
+    public URLBuilder setProtocol(String protocol) {
+        this.protocol = protocol;
+        return this;
+    }
+
+    public URLBuilder setUsername(String username) {
+        this.username = username;
+        return this;
+    }
+
+    public URLBuilder setPassword(String password) {
+        this.password = password;
+        return this;
+    }
+
+    public URLBuilder setHost(String host) {
+        this.host = host;
+        return this;
+    }
+
+    public URLBuilder setPort(int port) {
+        this.port = port;
+        return this;
+    }
+
+    public URLBuilder setAddress(String address) {
+        int i = address.lastIndexOf(':');
+        String host;
+        int port = this.port;
+        if (i >= 0) {
+            host = address.substring(0, i);
+            port = Integer.parseInt(address.substring(i + 1));
+        } else {
+            host = address;
+        }
+        this.host = host;
+        this.port = port;
+        return this;
+    }
+
+    public URLBuilder setPath(String path) {
+        this.path = path;
+        return this;
+    }
+
+    public URLBuilder addParameterAndEncoded(String key, String value) {
+        if (StringUtils.isEmpty(value)) {
+            return this;
+        }
+        return addParameter(key, URL.encode(value));
+    }
+
+    public URLBuilder addParameter(String key, boolean value) {
+        return addParameter(key, String.valueOf(value));
+    }
+
+    public URLBuilder addParameter(String key, char value) {
+        return addParameter(key, String.valueOf(value));
+    }
+
+    public URLBuilder addParameter(String key, byte value) {
+        return addParameter(key, String.valueOf(value));
+    }
+
+    public URLBuilder addParameter(String key, short value) {
+        return addParameter(key, String.valueOf(value));
+    }
+
+    public URLBuilder addParameter(String key, int value) {
+        return addParameter(key, String.valueOf(value));
+    }
+
+    public URLBuilder addParameter(String key, long value) {
+        return addParameter(key, String.valueOf(value));
+    }
+
+    public URLBuilder addParameter(String key, float value) {
+        return addParameter(key, String.valueOf(value));
+    }
+
+    public URLBuilder addParameter(String key, double value) {
+        return addParameter(key, String.valueOf(value));
+    }
+
+    public URLBuilder addParameter(String key, Enum<?> value) {
+        if (value == null) {
+            return this;
+        }
+        return addParameter(key, String.valueOf(value));
+    }
+
+    public URLBuilder addParameter(String key, Number value) {
+        if (value == null) {
+            return this;
+        }
+        return addParameter(key, String.valueOf(value));
+    }
+
+    public URLBuilder addParameter(String key, CharSequence value) {
+        if (value == null || value.length() == 0) {
+            return this;
+        }
+        return addParameter(key, String.valueOf(value));
+    }
+
+    public URLBuilder addParameter(String key, String value) {
+        if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value)) {
+            return this;
+        }
+        // if value doesn't change, return immediately
+        if (value.equals(parameters.get(key))) { // value != null
+            return this;
+        }
+
+        parameters.put(key, value);
+        return this;
+    }
+
+    public URLBuilder addParameterIfAbsent(String key, String value) {
+        if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value)) {
+            return this;
+        }
+        if (hasParameter(key)) {
+            return this;
+        }
+        parameters.put(key, value);
+        return this;
+    }
+
+    public URLBuilder addParameters(Map<String, String> parameters) {
+        if (CollectionUtils.isEmptyMap(parameters)) {
+            return this;
+        }
+
+        boolean hasAndEqual = true;
+        for (Map.Entry<String, String> entry : parameters.entrySet()) {
+            String oldValue = this.parameters.get(entry.getKey());
+            String newValue = entry.getValue();
+            if (!Objects.equals(oldValue, newValue)) {
+                hasAndEqual = false;
+                break;
+            }
+        }
+        // return immediately if there's no change
+        if (hasAndEqual) {
+            return this;
+        }
+
+        this.parameters.putAll(parameters);
+        return this;
+    }
+
+    public URLBuilder addParametersIfAbsent(Map<String, String> parameters) {
+        if (CollectionUtils.isEmptyMap(parameters)) {
+            return this;
+        }
+        this.parameters.putAll(parameters);
+        return this;
+    }
+
+    public URLBuilder addParameters(String... pairs) {
+        if (pairs == null || pairs.length == 0) {
+            return this;
+        }
+        if (pairs.length % 2 != 0) {
+            throw new IllegalArgumentException(""Map pairs can not be odd number."");
+        }
+        Map<String, String> map = new HashMap<>();
+        int len = pairs.length / 2;
+        for (int i = 0; i < len; i++) {
+            map.put(pairs[2 * i], pairs[2 * i + 1]);
+        }
+        return addParameters(map);
+    }
+
+    public URLBuilder addParameterString(String query) {
+        if (StringUtils.isEmpty(query)) {
+            return this;
+        }
+        return addParameters(StringUtils.parseQueryString(query));
+    }
+
+    public URLBuilder removeParameter(String key) {
+        if (StringUtils.isEmpty(key)) {
+            return this;
+        }
+        return removeParameters(key);
+    }
+
+    public URLBuilder removeParameters(Collection<String> keys) {
+        if (CollectionUtils.isEmpty(keys)) {
+            return this;
+        }
+        return removeParameters(keys.toArray(new String[0]));
+    }
+
+    public URLBuilder removeParameters(String... keys) {
+        if (keys == null || keys.length == 0) {
+            return this;
+        }
+        for (String key : keys) {
+            parameters.remove(key);
+        }
+        return this;
+    }
+
+    public URLBuilder clearParameters() {
+        parameters.clear();
+        return this;
+    }
+
+    public boolean hasParameter(String key) {
+        String value = getParameter(key);
+        return value != null && value.length() > 0;
+    }
+
+    public String getParameter(String key) {
+        String value = parameters.get(key);
+        if (StringUtils.isEmpty(value)) {
+            value = parameters.get(Constants.DEFAULT_KEY_PREFIX + key);
+        }
+        return value;
+    }
+}","[{'comment': 'Does these two reading methods `hasParameter` `hasParameter` necessary for a Builder?', 'commenter': 'chickenlj'}, {'comment': 'The two methods are used inside the builder, and I just made them public because I think it\'s necessary because there are cases where we want to write code like this:\r\n```java\r\nURLBuilder builder = ...;\r\nif (builder.hasParameter(""serverSideProp"")) {\r\n    builder.addParameter(""someServerSideProp1"", v2);\r\n    builder.addParameter(""someServerSideProp2"", v3);\r\n}\r\n```\r\nwithout these methods we have to (again) create `URL`s just for calling the methods, what do you think', 'commenter': 'kezhenxu94'}, {'comment': 'Got it.', 'commenter': 'chickenlj'}]"
3500,dubbo-common/src/main/java/org/apache/dubbo/common/URLBuilder.java,"@@ -0,0 +1,350 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common;
+
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
+public final class URLBuilder {
+    private String protocol;
+
+    private String username;
+
+    private String password;
+
+    // by default, host to registry
+    private String host;
+
+    // by default, port to registry
+    private int port;
+
+    private String path;
+
+    private Map<String, String> parameters;
+
+    public URLBuilder() {
+        protocol = null;
+        username = null;
+        password = null;
+        host = null;
+        port = 0;
+        path = null;
+        parameters = new HashMap<>();
+    }
+
+    public URLBuilder(String protocol, String host, int port) {
+        this(protocol, null, null, host, port, null, null);
+    }
+
+    public URLBuilder(String protocol, String host, int port, String[] pairs) { // varargs ... conflict with the following path argument, use array instead.","[{'comment': 'this comments looks unnecessary to me.', 'commenter': 'beiwei30'}]"
3500,dubbo-common/src/main/java/org/apache/dubbo/common/URLBuilder.java,"@@ -0,0 +1,350 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common;
+
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
+public final class URLBuilder {
+    private String protocol;
+
+    private String username;
+
+    private String password;
+
+    // by default, host to registry
+    private String host;
+
+    // by default, port to registry
+    private int port;
+
+    private String path;
+
+    private Map<String, String> parameters;
+
+    public URLBuilder() {
+        protocol = null;
+        username = null;
+        password = null;
+        host = null;
+        port = 0;
+        path = null;
+        parameters = new HashMap<>();
+    }
+
+    public URLBuilder(String protocol, String host, int port) {
+        this(protocol, null, null, host, port, null, null);
+    }
+
+    public URLBuilder(String protocol, String host, int port, String[] pairs) { // varargs ... conflict with the following path argument, use array instead.
+        this(protocol, null, null, host, port, null, CollectionUtils.toStringMap(pairs));
+    }
+
+    public URLBuilder(String protocol, String host, int port, Map<String, String> parameters) {
+        this(protocol, null, null, host, port, null, parameters);
+    }
+
+    public URLBuilder(String protocol, String host, int port, String path) {
+        this(protocol, null, null, host, port, path, null);
+    }
+
+    public URLBuilder(String protocol, String host, int port, String path, String... pairs) {
+        this(protocol, null, null, host, port, path, CollectionUtils.toStringMap(pairs));
+    }
+
+    public URLBuilder(String protocol, String host, int port, String path, Map<String, String> parameters) {","[{'comment': ""since it's builder, we should make all constructor **private**"", 'commenter': 'beiwei30'}, {'comment': ""> since it's builder, we should make all constructor **private**\r\n\r\nI don't think the constructor of the builder itself should be `private`, it is the constructor of the class that the builder is to build(the `URL` class) should be `private` to prevent client code from creating the (`URL`) objects without using the builder. But for compatibility, the constructor of `URL` should not be private at this moment.\r\n\r\nAbout the visibilities of the constructors, please refer to [this thread](https://stackoverflow.com/a/37028913)\r\n\r\n> This looks a bit strange because usually a builder uses private constructor to totally avoid the creation of the instance by the client code without using the builder.\r\n\r\nand [this post](https://dzone.com/articles/design-patterns-the-builder-pattern):\r\n\r\n> The Pattern\r\nThe Builder pattern allows us to write readable, understandable code to set up complex objects. It is often implemented with a fluent interface, which you may have seen in tools like Apache Camel or Hamcrest. The builder will contain all of the fields that exist on the BankAccount class itself. We will configure all of the fields that we want on the builder, and then we'll use the builder to create accounts. At the same time, we'll remove the public constructor from the BankAccount class and replace it with a private constructor so that accounts can only be created via the builder."", 'commenter': 'kezhenxu94'}, {'comment': '@beiwei30 what do you think', 'commenter': 'kezhenxu94'}]"
3503,dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/telnet/support/TelnetHandlerAdapter.java,"@@ -49,6 +51,7 @@ public String telnet(Channel channel, String message) throws RemotingException {
         }
         if (command.length() > 0) {
             if (extensionLoader.hasExtension(command)) {
+                if (commandEnabled(channel.getUrl(), command)) {
                 try {","[{'comment': 'This code looks a bit indented', 'commenter': 'lixiaojiee'}]"
3520,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -602,43 +599,20 @@ private String findConfigedHosts(ProtocolConfig protocolConfig, List<URL> regist
         boolean anyhost = false;
 
         String hostToBind = getValueFromConfig(protocolConfig, Constants.DUBBO_IP_TO_BIND);
-        if (hostToBind != null && hostToBind.length() > 0 && isInvalidLocalHost(hostToBind)) {
-            throw new IllegalArgumentException(""Specified invalid bind ip from property:"" + Constants.DUBBO_IP_TO_BIND + "", value:"" + hostToBind);
-        }
 
         // if bind ip is not found in environment, keep looking up
         if (StringUtils.isEmpty(hostToBind)) {
             hostToBind = protocolConfig.getHost();
             if (provider != null && StringUtils.isEmpty(hostToBind)) {
                 hostToBind = provider.getHost();
             }
-            if (isInvalidLocalHost(hostToBind)) {
+
+            if (StringUtils.isEmpty(hostToBind)) {
                 anyhost = true;
-                try {
-                    hostToBind = InetAddress.getLocalHost().getHostAddress();
-                } catch (UnknownHostException e) {
-                    logger.warn(e.getMessage(), e);
-                }
-                if (isInvalidLocalHost(hostToBind)) {
-                    if (CollectionUtils.isNotEmpty(registryURLs)) {
-                        for (URL registryURL : registryURLs) {
-                            if (Constants.MULTICAST.equalsIgnoreCase(registryURL.getParameter(""registry""))) {
-                                // skip multicast registry since we cannot connect to it via Socket
-                                continue;
-                            }
-                            try (Socket socket = new Socket()) {
-                                SocketAddress addr = new InetSocketAddress(registryURL.getHost(), registryURL.getPort());
-                                socket.connect(addr, 1000);
-                                hostToBind = socket.getLocalAddress().getHostAddress();
-                                break;
-                            } catch (Exception e) {
-                                logger.warn(e.getMessage(), e);
-                            }
-                        }
-                    }
-                    if (isInvalidLocalHost(hostToBind)) {
-                        hostToBind = getLocalHost();
-                    }
+                hostToBind = getLocalHost();
+
+                if (StringUtils.isEmpty(hostToBind)) {
+                    hostToBind = findHostToBindByConnectRegistries(registryURLs);","[{'comment': '`hostToBind` can be empty after looking up from `findHostToBindByConnectRegistries `.', 'commenter': 'chickenlj'}, {'comment': 'in fact, it will not be empty, pls. check getLocalHost().', 'commenter': 'beiwei30'}, {'comment': ""Yes, you are right, it's not a concern."", 'commenter': 'chickenlj'}]"
3520,dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java,"@@ -102,6 +102,7 @@ public static boolean isAnyHost(String host) {
         return Constants.ANYHOST_VALUE.equals(host);
     }
 
+    // FIXME: should remove this method completely","[{'comment': 'If the method is to be removed in the future, I would suggest annotate it with `@Deprecated` and direct users to the replacement in case that users want to use it', 'commenter': 'kezhenxu94'}, {'comment': ""it's not been decided yet, so **//FIXME** should be fine for now :)"", 'commenter': 'beiwei30'}]"
3521,dubbo-monitor/dubbo-monitor-default/src/main/java/org/apache/dubbo/monitor/dubbo/DubboMonitor.java,"@@ -91,7 +91,13 @@ public void send() {
             // get statistics data
             Statistics statistics = entry.getKey();
             AtomicReference<long[]> reference = entry.getValue();
-            long[] numbers = reference.get();
+            long[] numbers;
+            long[] update = new long[LENGTH];
+            //
+            do {
+                numbers = reference.get();
+            } while (!reference.compareAndSet(numbers, update));","[{'comment': ""I don't think simply replacing `numbers` with `update` is right. You should see how `collect(URL url)` update statistics first."", 'commenter': 'chickenlj'}, {'comment': ""Can you describe it clearly? I just modified the logic of the reset here, I don't know where there is a problem."", 'commenter': 'CrazyHZM'}]"
3558,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ClusterUtils.java,"@@ -84,7 +84,9 @@ public static URL mergeUrl(URL remoteUrl, Map<String, String> localMap) {
             String remoteGroup = map.get(Constants.GROUP_KEY);
             String remoteRelease = map.get(Constants.RELEASE_KEY);
             map.putAll(localMap);
-            map.put(Constants.GROUP_KEY, remoteGroup);
+            if (!map.containsKey(Constants.GROUP_KEY) || StringUtils.isNotEmpty(remoteGroup)) {","[{'comment': 'I think we should only check `StringUtils.isNotEmpty(remoteGroup)` but not `!map.containsKey(Constants.GROUP_KEY)`', 'commenter': 'chickenlj'}]"
3578,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java,"@@ -199,11 +201,26 @@ private boolean isForceUseTag(Invocation invocation) {
     }
 
     private boolean addressMatches(URL url, List<String> addresses) {
-        return addresses != null && addresses.contains(url.getAddress());
+        return addresses != null && checkAddressMatch(addresses, url.getAddress());
     }
 
     private boolean addressNotMatches(URL url, List<String> addresses) {
-        return addresses == null || !addresses.contains(url.getAddress());
+        return addresses == null || !checkAddressMatch(addresses, url.getAddress());
+    }
+
+    private boolean checkAddressMatch(List<String> addresses, String targetAddress) {
+        for (String address : addresses) {
+            try {
+                if (NetUtils.matchIpExpression(address, targetAddress)) {","[{'comment': 'The address here is expected to have port included: `127.0.0.1:20880`, but `NetUtils.matchIpExpression` can only handle raw IP.', 'commenter': 'chickenlj'}, {'comment': 'I have fixed this one to support port configuration.', 'commenter': 'cvictory'}]"
3579,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java,"@@ -78,7 +78,7 @@ protected void doOpen() throws Throwable {
 
             @Override
             protected void initChannel(Channel ch) throws Exception {
-                int heartbeatInterval = UrlUtils.getIdleTimeout(getUrl());
+                int heartbeatInterval = UrlUtils.getHeartbeat(getUrl());","[{'comment': 'looks like we still should call `getIdleTimeout` instead, would you mind to check the old logic?', 'commenter': 'beiwei30'}, {'comment': 'Since the current server does not return a heartbeat request, if you use getIdleTimeout(3 * heartbeat), the heartbeat send period will be 3 * heartbeat. Will this be a long time?', 'commenter': 'carryxyh'}, {'comment': 'I think @carryxyh is right. This value tells `IdleStateHandler` the interval of sending a heartbeat package.', 'commenter': 'chickenlj'}]"
3591,dubbo-test/dubbo-test-integration/README.md,"@@ -0,0 +1,29 @@
+## 具体介绍
+Dubbo-example，是基于PelicanDT实现dubbo环境准备，禁止端口网络访问，执行接口调用验证端口是否禁用示例
+    
+## 前期准备
+1. 本示例程序是基于阿里云ECS或远程Linux服务器完成，只需[购买](https://ecs-buy.aliyun.com/wizard?spm=5176.8789780.1092585.1.520157a8WqaKjA#/prepay/cn-zhangjiakou)阿里云机器，或者选定已准备好的远程服务器即可","[{'comment': 'Please remove this. No promotion for Alibaba Cloud.', 'commenter': 'ralf0131'}]"
3591,dubbo-test/dubbo-test-integration/src/test/java/org/apache/dubbo/test/DubboLoadBalanceTest.java,"@@ -0,0 +1,58 @@
+package org.apache.dubbo.test;
+
+import com.alibaba.pelican.chaos.client.impl.RemoteCmdClient;
+import com.alibaba.pelican.deployment.junit.AbstractJUnit4PelicanTests;
+import io.restassured.response.Response;
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
+import static io.restassured.RestAssured.given;
+
+/**","[{'comment': 'Please remove the author name.', 'commenter': 'ralf0131'}]"
3591,dubbo-test/dubbo-test-integration/src/test/java/org/apache/dubbo/test/DubboLoadBalanceTest.java,"@@ -0,0 +1,58 @@
+package org.apache.dubbo.test;
+
+import com.alibaba.pelican.chaos.client.impl.RemoteCmdClient;
+import com.alibaba.pelican.deployment.junit.AbstractJUnit4PelicanTests;
+import io.restassured.response.Response;
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
+import static io.restassured.RestAssured.given;
+
+/**
+ * @author moyun@middleware
+ */
+
+@Slf4j
+public class DubboLoadBalanceTest extends AbstractJUnit4PelicanTests {","[{'comment': 'Why it is DubboLoadBalanceTest?', 'commenter': 'ralf0131'}]"
3591,dubbo-test/dubbo-test-integration/README.md,"@@ -0,0 +1,29 @@
+## 具体介绍
+Dubbo-example，是基于PelicanDT实现dubbo环境准备，禁止端口网络访问，执行接口调用验证端口是否禁用示例
+    
+## 前期准备
+1. 本示例程序是基于阿里云ECS或远程Linux服务器完成，只需[购买](https://ecs-buy.aliyun.com/wizard?spm=5176.8789780.1092585.1.520157a8WqaKjA#/prepay/cn-zhangjiakou)阿里云机器，或者选定已准备好的远程服务器即可
+2. 下载[Dubbo-example](https://github.com/alibaba/PelicanDT/tree/master/Dubbo-example)代码
+
+## 快速入门
+
+### 修改配置
+1. 打开dubbo.properties配置文件，具体路径：Dubbo-example/src/test/resources/env/func/dubbo.properties
+2. 填写ip，userName，password
+
+### 运行示例
+
+本地代码控制远程服务器执行Dubbo验证：
+1. 打开TestDubboNetwork.java，具体路径：Dubbo-example/src/test/java/com/alibaba/pelican/rocketmq/TestDubboNetwork.java","[{'comment': 'Why there is rocketmq?', 'commenter': 'ralf0131'}]"
3591,dubbo-test/dubbo-test-integration/src/test/resources/dubbo.sh,"@@ -0,0 +1,84 @@
+#!/bin/bash
+cd /root
+yum -y install wget
+yum -y install unzip
+
+if [ ! -f ""/root/jdk-8u141-linux-x64.tar.gz"" ];then
+    wget http://moyuns.oss-cn-hangzhou.aliyuncs.com/jdk-8u141-linux-x64.tar.gz","[{'comment': 'It is better to download via official channel, rather that a personal link.', 'commenter': 'ralf0131'}]"
3593,dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java,"@@ -0,0 +1,300 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.registry.consul;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.NamedThreadFactory;
+import org.apache.dubbo.registry.NotifyListener;
+import org.apache.dubbo.registry.support.FailbackRegistry;
+
+import com.ecwid.consul.v1.ConsulClient;
+import com.ecwid.consul.v1.QueryParams;
+import com.ecwid.consul.v1.Response;
+import com.ecwid.consul.v1.agent.model.NewService;
+import com.ecwid.consul.v1.catalog.CatalogServicesRequest;
+import com.ecwid.consul.v1.health.HealthServicesRequest;
+import com.ecwid.consul.v1.health.model.HealthService;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ExecutorService;
+import java.util.stream.Collectors;
+
+import static java.util.concurrent.Executors.newCachedThreadPool;
+import static org.apache.dubbo.common.Constants.ANY_VALUE;
+
+/**
+ * registry center implementation for consul
+ */
+public class ConsulRegistry extends FailbackRegistry {
+    private static final Logger logger = LoggerFactory.getLogger(ConsulRegistry.class);
+
+    private static final String SERVICE_TAG = ""dubbo"";
+    private static final String URL_META_KEY = ""url"";
+    private static final String WATCH_TIMEOUT = ""consul-watch-timeout"";
+    private static final String CHECK_INTERVAL = ""consul-check-interval"";
+    private static final String CHECK_TIMEOUT = ""consul-check-timeout"";
+    private static final String DEREGISTER_AFTER = ""consul-deregister-critical-service-after"";
+
+    private static final int DEFAULT_PORT = 8500;
+    // default watch timeout in millisecond
+    private static final int DEFAULT_WATCH_TIMEOUT = 60 * 1000;
+    // default tcp check interval
+    private static final String DEFAULT_CHECK_INTERVAL = ""10s"";
+    // default tcp check timeout
+    private static final String DEFAULT_CHECK_TIMEOUT = ""1s"";
+    // default deregister critical server after
+    private static final String DEFAULT_DEREGISTER_TIME = ""20s"";
+
+    private ConsulClient client;
+
+    private ExecutorService notifierExecutor = newCachedThreadPool(
+            new NamedThreadFactory(""dubbo-consul-notifier"", true));
+    private ConcurrentMap<URL, ConsulNotifier> notifiers = new ConcurrentHashMap<>();
+
+    public ConsulRegistry(URL url) {
+        super(url);
+        String host = url.getHost();
+        int port = url.getPort() != 0 ? url.getPort() : DEFAULT_PORT;
+        client = new ConsulClient(host, port);
+    }
+
+    @Override
+    public void register(URL url) {
+        if (isConsumerSide(url)) {
+            return;
+        }
+
+        super.register(url);
+    }
+
+    @Override
+    public void doRegister(URL url) {
+        client.agentServiceRegister(buildService(url));
+    }
+
+    @Override
+    public void unregister(URL url) {
+        if (isConsumerSide(url)) {
+            return;
+        }
+
+        super.unregister(url);
+    }
+
+    @Override
+    public void doUnregister(URL url) {
+        client.agentServiceDeregister(buildId(url));
+    }
+
+    @Override
+    public void subscribe(URL url, NotifyListener listener) {
+        if (isProviderSide(url)) {
+            return;
+        }
+
+        super.subscribe(url, listener);
+    }
+
+    @Override
+    public void doSubscribe(URL url, NotifyListener listener) {
+        Long index;
+        List<URL> urls;
+        if (ANY_VALUE.equals(url.getServiceInterface())) {
+            Response<Map<String, List<String>>> response = getAllServices(-1, buildWatchTimeout(url));
+            index = response.getConsulIndex();
+            List<HealthService> services = getHealthServices(response.getValue());
+            urls = convert(services);
+        } else {
+            String service = url.getServiceKey();
+            Response<List<HealthService>> response = getHealthServices(service, -1, buildWatchTimeout(url));
+            index = response.getConsulIndex();
+            urls = convert(response.getValue());
+        }
+
+        notify(url, listener, urls);
+        ConsulNotifier notifier = notifiers.computeIfAbsent(url, k -> new ConsulNotifier(url, index));
+        notifierExecutor.submit(notifier);","[{'comment': 'I think the thread model here can be optimized, two potential problems:\r\n1. busy looping will cost too much cpu.\r\n2. One-thread-per-service will generate too many threads.', 'commenter': 'chickenlj'}, {'comment': '![aaaaa](https://user-images.githubusercontent.com/18097545/54019981-9bd16700-41c7-11e9-9efa-3d694509598b.jpg)\r\n', 'commenter': 'chickenlj'}, {'comment': 'Above is the thread dump when subscribing to 2 services.\r\n```xml\r\n <dubbo:reference id=""demoService"" check=""false"" interface=""org.apache.dubbo.demo.DemoService""/>\r\n    <dubbo:reference id=""consulService"" check=""false"" interface=""org.apache.dubbo.demo.ConsulService""/>\r\n```', 'commenter': 'chickenlj'}, {'comment': ""Since consul's fetch API is pull-based  and with a blocking model, I think it's ok to keep the current thread model."", 'commenter': 'chickenlj'}]"
3601,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java,"@@ -689,7 +689,10 @@ public ApplicationConfig getApplication() {
     }
 
     public void setApplication(ApplicationConfig application) {
-        ConfigManager.getInstance().setApplication(application);
+        if (!ConfigManager.getInstance().getApplication().isPresent() ||
+                !ConfigManager.getInstance().getApplication().get().equals(application)) {
+            ConfigManager.getInstance().setApplication(application);
+        }","[{'comment': 'Why should we need this logic? The logic, including the null check and duplicate check have  implemented in org.apache.dubbo.config.context.ConfigManager#setApplication.  Why should be added it again?\r\n\r\nSo as the other change in this file.', 'commenter': 'ralf0131'}, {'comment': 'such as AbstractInterfaceConfig#createApplicationIfAbsent , if `this.application` is null and the `ApplicationConfig` in `ConfigManager`  is not null , it will reset   `ApplicationConfig` variable，that always causes an error in `ConfigManager#checkDuplicate`', 'commenter': 'saltyx'}, {'comment': 'Still do not quite get it. in AbstractInterfaceConfig#createApplicationIfAbsent , if `this.application` is null, it will directly return.\r\nCan you write a unit test to reproduce the error? ', 'commenter': 'ralf0131'}, {'comment': 'I thought about it again, this code seems to be doing this deliberately. my logic is duplicate check and block the IllegalStateException, i should remove them . \r\n\r\nAnd  because `ConfigManager#checkDuplicate` is logically wrong, it will cause some unit test errors which is  the purpose of changing this logic at the beginning...', 'commenter': 'saltyx'}]"
3601,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/context/ConfigManager.java,"@@ -310,7 +310,7 @@ public void refreshAll() {
     }
 
     private void checkDuplicate(AbstractConfig oldOne, AbstractConfig newOne) {
-        if (oldOne != null && !oldOne.equals(newOne)) {
+        if (oldOne != null && oldOne.equals(newOne)) {","[{'comment': 'I notice the UT is missing here, could you add a unit test for this change?', 'commenter': 'ralf0131'}, {'comment': 'ok', 'commenter': 'saltyx'}, {'comment': 'please check `AbstractInterfaceConfigTest#checkDuplicateApplication`', 'commenter': 'saltyx'}]"
3603,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/ZookeeperClient.java,"@@ -30,6 +31,19 @@
 
     List<String> addChildListener(String path, ChildListener listener);
 
+    /**
+     * @param path:    directory. All of child of path will be listened.
+     * @param listener
+     */
+    void addDataListener(String path, DataListener listener);
+
+    /**
+     * @param path:    directory. All of child of path will be listened.
+     * @param listener
+     * @param executor another thread
+     */
+    void addDataListener(String path, DataListener listener, Executor executor);
+","[{'comment': 'Do we need `removeDataListener`?', 'commenter': 'chickenlj'}]"
3603,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/DataListener.java,"@@ -14,16 +14,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.dubbo.remoting.zookeeper.zkclient;
+package org.apache.dubbo.remoting.zookeeper;
 
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.remoting.zookeeper.ZookeeperClient;
-import org.apache.dubbo.remoting.zookeeper.support.AbstractZookeeperTransporter;
-
-public class ZkclientZookeeperTransporter extends AbstractZookeeperTransporter {
-    @Override
-    public ZookeeperClient createZookeeperClient(URL url) {
-        return new ZkclientZookeeperClient(url);
-    }
+/**
+ * @author cvictory ON 2019-02-26","[{'comment': 'No necessary to keep author info.', 'commenter': 'chickenlj'}]"
3603,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java,"@@ -188,27 +205,65 @@ public CuratorWatcher createTargetChildListener(String path, ChildListener liste
     }
 
     @Override
-    public void removeTargetChildListener(String path, CuratorWatcher listener) {
-        ((CuratorWatcherImpl) listener).unwatch();
+    protected TreeCacheListener createTargetDataListener(String path, DataListener listener) {
+        return new CuratorWatcherImpl(client, listener);
     }
 
-    private class CuratorWatcherImpl implements CuratorWatcher {
+    @Override
+    protected void addTargetDataListener(String path, TreeCacheListener treeCacheListener) {
+        try {
+            TreeCache treeCache = new TreeCache(client, path);","[{'comment': 'Will we have too much `TreeCache` instance created? One instance should be enough.', 'commenter': 'chickenlj'}, {'comment': 'It creates one instance in ZookeeperDynamicConfiguration. \r\nYou can check it again.', 'commenter': 'cvictory'}, {'comment': ""Ok, I got it, it's guaranteed by the number of ZookeeperDynamicConfiguration instance."", 'commenter': 'chickenlj'}]"
3603,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java,"@@ -36,10 +42,11 @@
 import java.nio.charset.Charset;
 import java.util.Collections;
 import java.util.List;
+import java.util.concurrent.Executor;
 
-public class CuratorZookeeperClient extends AbstractZookeeperClient<CuratorWatcher> {
+public class CuratorZookeeperClient extends AbstractZookeeperClient<TreeCacheListener, CuratorZookeeperClient.CuratorWatcherImpl> {","[{'comment': 'Since `CuratorWatcherImpl` implements both TreeCacheListener and CuraorWatcher, can we use CuratorWatcherImpl directly?', 'commenter': 'chickenlj'}]"
3624,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java,"@@ -85,6 +94,12 @@ protected void initChannel(Channel ch) throws Exception {
                         .addLast(""encoder"", adapter.getEncoder())
                         .addLast(""client-idle-handler"", new IdleStateHandler(heartbeatInterval, 0, 0, MILLISECONDS))
                         .addLast(""handler"", nettyClientHandler);
+                String socksProxyHost = System.getProperty(SOCKS_PROXY_HOST);
+                if(socksProxyHost != null) {
+                    Integer socksProxyPort = Integer.getInteger(SOCKS_PROXY_PORT, DEFAULT_SOCKS_PROXY_PORT);","[{'comment': 'Should be use System.getProperty(SOCKS_PROXY_PORT) ???', 'commenter': 'zonghaishang'}, {'comment': 'replace by ConfigUtils.getProperty', 'commenter': 'nihongye'}]"
3634,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcResult.java,"@@ -109,4 +92,32 @@ public boolean hasException() {
     public String toString() {
         return ""RpcResult [result="" + result + "", exception="" + exception + ""]"";
     }
+
+    /**
+     * fix issue#619","[{'comment': 'Can you provide some more valuable docs?', 'commenter': 'carryxyh'}, {'comment': 'this pr is just optimization for #2956 , and the docs for #2956 : https://www.yuque.com/fa902k/id5z6r/sr041v', 'commenter': 'zhaixiaoxiang'}, {'comment': 'Sorry, there is a problem with my expression, I mean a comment like this:\r\n\r\n```\r\n// Process string to char array for generic invoke\r\n// See\r\n// - https://github.com/apache/incubator-dubbo/issues/2003\r\n```\r\n\r\nMake it easier for developers to know the reason for this change.', 'commenter': 'carryxyh'}, {'comment': '@carryxyh Any suggestions to my following docs?', 'commenter': 'zhaixiaoxiang'}, {'comment': 'Hi, xiang\r\nI mean a java comment like this:\r\n\r\n```\r\n    /**\r\n     * we need deal the stack trace to avoid NullPointerException\r\n     * <p>\r\n     * see https://github.com/apache/incubator-dubbo/pull/2956\r\n     * and https://github.com/apache/incubator-dubbo/issues/619\r\n     *\r\n     * @param e exception\r\n     * @return exception after deal with stack trace\r\n     */\r\n```\r\n\r\nWhat do u think?', 'commenter': 'carryxyh'}, {'comment': 'ok', 'commenter': 'zhaixiaoxiang'}]"
3654,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/tps/StatItem.java,"@@ -39,32 +39,35 @@
         this.rate = rate;
         this.interval = interval;
         this.lastResetTime = System.currentTimeMillis();
-        this.token = new AtomicInteger(rate);
+        this.token = buildLongAdder(rate);
     }
 
     public boolean isAllowable() {
         long now = System.currentTimeMillis();
         if (now > lastResetTime + interval) {
-            token.set(rate);
+            token = buildLongAdder(rate);
             lastResetTime = now;
         }
 
-        int value = token.get();
         boolean flag = false;
-        while (value > 0 && !flag) {
-            flag = token.compareAndSet(value, value - 1);
-            value = token.get();
+        while (token.sum() > 0 && !flag) {","[{'comment': '  `token.sum()` can be replaced with `getToken()`', 'commenter': 'CrazyHZM'}]"
3654,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/tps/StatItem.java,"@@ -39,32 +39,35 @@
         this.rate = rate;
         this.interval = interval;
         this.lastResetTime = System.currentTimeMillis();
-        this.token = new AtomicInteger(rate);
+        this.token = buildLongAdder(rate);
     }
 
     public boolean isAllowable() {
         long now = System.currentTimeMillis();
         if (now > lastResetTime + interval) {
-            token.set(rate);
+            token = buildLongAdder(rate);
             lastResetTime = now;
         }
 
-        int value = token.get();
         boolean flag = false;
-        while (value > 0 && !flag) {
-            flag = token.compareAndSet(value, value - 1);
-            value = token.get();
+        while (getToken() > 0 && !flag) {","[{'comment': 'There is no need to use while any more, since the loop body will only be executed once.', 'commenter': 'ralf0131'}]"
3664,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java,"@@ -80,14 +80,14 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept
         } finally {
             // IMPORTANT! For async scenario, we must remove context from current thread, so we always create a new RpcContext for the next invoke for the same thread.","[{'comment': ""Didn't you see this comment?\r\n\r\nWe must remove the context at the end of the invoke. So I think your pr will cause new problems."", 'commenter': 'carryxyh'}, {'comment': ""How about use a local variable to store the async identifier, and in the finally block, we can check if it is a async invoke, the servercontext will be removed. If not, we donnot remove it. Doesn't this impact the asyn invoke ?"", 'commenter': 'tswstarplanet'}]"
3680,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java,"@@ -329,9 +329,7 @@ private void doReceived(Response res) {
         lock.lock();
         try {
             response = res;
-            if (done != null) {
-                done.signal();
-            }
+            done.signalAll();","[{'comment': 'Hi, this change is irrelevant.  And is addressed in #3681 . Please rebase with the master and send the pull request again.', 'commenter': 'ralf0131'}, {'comment': 'OK，I will send the pull request again.', 'commenter': 'John-Smile'}]"
3680,dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java,"@@ -89,7 +89,8 @@ public void dataChanged(String path, Object value, EventType eventType) {
         // TODO We limit the notification of config changes to a specific path level, for example
         //  /dubbo/config/service/configurators, other config changes not in this level will not get notified,
         //  say /dubbo/config/dubbo.properties
-        if (path.split(""/"").length >= 5) {
+        final int MIN_PATH_ARRAY_LENGTH = 5;","[{'comment': 'It is better to make it static.', 'commenter': 'ralf0131'}, {'comment': 'It is better to be local, because it is only used in one method.', 'commenter': 'John-Smile'}, {'comment': ""No, it is not. As a local constant, it will be allocated every time the method is invoked. I don't think it should be local. "", 'commenter': 'ralf0131'}, {'comment': ""I make an experiment.\r\n```\r\npublic class Test {\r\n    private static final int CLZ_FIELD = 65535;\r\n    public static void main(String[] args) {\r\n        final int localVariable = 65536;\r\n        System.out.println(localVariable);\r\n        System.out.println(CLZ_FIELD);\r\n    }\r\n}\r\n```\r\nAfter decompilation， I got\r\n```\r\npublic static void main(java.lang.String[]);\r\n  Code:\r\n     0: ldc           #2                  // int 65536\r\n     2: istore_1\r\n     3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\r\n     6: ldc           #2                  // int 65536\r\n     8: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V\r\n    11: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\r\n    14: ldc           #6                  // int 65535\r\n    16: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V\r\n    19: return\r\n```\r\nEvery time the local constant need one more step ('`0: ldc #2`') and one more stack space than static constant.\r\nSo you are right, I will make it static."", 'commenter': 'John-Smile'}]"
3685,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"@@ -171,6 +171,9 @@ public void unregister(URL registryUrl, URL registeredProviderUrl) {
         // url to export locally
         URL providerUrl = getProviderUrl(originInvoker);
 
+        //export invoker
+        final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker, providerUrl);","[{'comment': 'Hi, this change looks break the logic, I got the following exception during start. I use Dubbo 2.7 + Nacos. The service is not register to Nacos.\r\n\r\n```\r\njava.lang.NullPointerException\r\n\tat org.apache.dubbo.registry.integration.RegistryProtocol$OverrideListener.doOverrideIfNecessary(RegistryProtocol.java:561)\r\n\tat org.apache.dubbo.registry.integration.RegistryProtocol$ServiceConfigurationListener.notifyOverrides(RegistryProtocol.java:604)\r\n\tat org.apache.dubbo.registry.integration.AbstractConfiguratorListener.process(AbstractConfiguratorListener.java:72)\r\n\tat org.apache.dubbo.configcenter.support.nacos.NacosDynamicConfiguration$NacosConfigListener.lambda$innerReceive$0(NacosDynamicConfiguration.java:244)\r\n\tat java.base/java.util.concurrent.CopyOnWriteArrayList.forEach(CopyOnWriteArrayList.java:803)\r\n\tat java.base/java.util.concurrent.CopyOnWriteArraySet.forEach(CopyOnWriteArraySet.java:425)\r\n\tat org.apache.dubbo.configcenter.support.nacos.NacosDynamicConfiguration$NacosConfigListener.innerReceive(NacosDynamicConfiguration.java:244)\r\n\tat com.alibaba.nacos.api.config.listener.AbstractSharedListener.receiveConfigInfo(AbstractSharedListener.java:37)\r\n\tat com.alibaba.nacos.client.config.impl.CacheData$1.run(CacheData.java:188)\r\n\tat com.alibaba.nacos.client.config.impl.CacheData.safeNotifyListener(CacheData.java:209)\r\n\tat com.alibaba.nacos.client.config.impl.CacheData.checkListenerMd5(CacheData.java:160)\r\n\tat com.alibaba.nacos.client.config.impl.ClientWorker$LongPollingRunnable.run(ClientWorker.java:505)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\n```', 'commenter': 'ralf0131'}]"
3714,dubbo-serialization/dubbo-serialization-gson/pom.xml,"@@ -0,0 +1,42 @@
+<!--
+Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the ""License""); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+  -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <artifactId>dubbo-serialization</artifactId>
+        <groupId>org.apache.dubbo</groupId>
+        <version>2.7.1-SNAPSHOT</version>","[{'comment': 'Hi, since 2.7.1 has been released, could you update it to 2.7.2-SNAPSHOT?', 'commenter': 'CrazyHZM'}, {'comment': 'OK, I will do it tonight !', 'commenter': 'tswstarplanet'}]"
3714,dubbo-common/pom.xml,"@@ -77,5 +77,9 @@
             <groupId>de.ruedigermoeller</groupId>
             <artifactId>fst</artifactId>
         </dependency>
+        <dependency>","[{'comment': 'dubbo-common is the most basic module that all the other modules might depend on, I think it should be depend on nacos-client here. It looks weird.', 'commenter': 'ralf0131'}]"
3714,dubbo-serialization/dubbo-serialization-api/pom.xml,"@@ -55,5 +55,9 @@ limitations under the License.
             <groupId>de.ruedigermoeller</groupId>
             <artifactId>fst</artifactId>
         </dependency>
+        <dependency>
+            <groupId>com.google.code.gson</groupId>","[{'comment': 'What is the dependencies of gson? Are all the licenses compatible with Apache? ', 'commenter': 'ralf0131'}, {'comment': ""This package is copy from the project dubbo/dubbo-serialization-gson. I think it's OK ?"", 'commenter': 'tswstarplanet'}, {'comment': 'It has not been checked before. When merging into Apache repo, we need to be careful to the dependencies.\r\nCould you list all the dependencies of gson and their licenses?', 'commenter': 'ralf0131'}, {'comment': 'Hi, I just checked that the gson library has already been added before this pull request. So I think there is no issue here. ', 'commenter': 'ralf0131'}]"
3717,dubbo-serialization/dubbo-serialization-avro/pom.xml,"@@ -0,0 +1,44 @@
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the ""License""); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+  -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>org.apache.dubbo</groupId>
+        <artifactId>dubbo-serialization</artifactId>
+        <version>2.7.1-SNAPSHOT</version>","[{'comment': 'Hi, since 2.7.1 has been released, could you update it to 2.7.2-SNAPSHOT?', 'commenter': 'ralf0131'}, {'comment': 'completed.', 'commenter': 'CrazyHZM'}]"
3717,dubbo-serialization/dubbo-serialization-avro/src/main/java/org/apache/dubbo/common/serialize/avro/AvroObjectInput.java,"@@ -0,0 +1,116 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.serialize.avro;
+
+import org.apache.avro.io.BinaryDecoder;
+import org.apache.avro.io.DecoderFactory;
+import org.apache.avro.reflect.ReflectDatumReader;
+import org.apache.avro.util.Utf8;
+import org.apache.dubbo.common.serialize.ObjectInput;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Type;
+import java.util.HashMap;
+import java.util.Map;
+
+public class AvroObjectInput implements ObjectInput{
+	private DecoderFactory decoderFactory=DecoderFactory.get();;","[{'comment': 'can we make decoderFactory as a static field?', 'commenter': 'kexianjun'}, {'comment': 'It is fixed.', 'commenter': 'ralf0131'}]"
3717,dubbo-serialization/dubbo-serialization-avro/src/main/java/org/apache/dubbo/common/serialize/avro/AvroObjectOutput.java,"@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.serialize.avro;
+
+import org.apache.avro.io.BinaryEncoder;
+import org.apache.avro.io.EncoderFactory;
+import org.apache.avro.reflect.ReflectDatumWriter;
+import org.apache.avro.util.Utf8;
+import org.apache.dubbo.common.serialize.ObjectOutput;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Arrays;
+
+public class AvroObjectOutput implements ObjectOutput {
+    private EncoderFactory encoderFactory = EncoderFactory.get();","[{'comment': 'encoderFactory also as above', 'commenter': 'kexianjun'}, {'comment': 'Fixed.', 'commenter': 'ralf0131'}]"
3717,dubbo-serialization/dubbo-serialization-api/pom.xml,"@@ -55,5 +55,9 @@ limitations under the License.
             <groupId>de.ruedigermoeller</groupId>
             <artifactId>fst</artifactId>
         </dependency>
+        <dependency>","[{'comment': 'There is no need to depend avro here.', 'commenter': 'ralf0131'}, {'comment': 'Fixed.', 'commenter': 'CrazyHZM'}]"
3748,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"@@ -174,6 +174,10 @@ public void doSaveProperties(long version) {
                 }
             }
         } catch (Throwable e) {
+            if (e instanceof IOException) { // may not be recoverable when IOException throws, give up retrying","[{'comment': 'Why not catch IOException directly?', 'commenter': 'ralf0131'}]"
3748,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"@@ -60,6 +61,8 @@
     private static final char URL_SEPARATOR = ' ';
     // URL address separated regular expression for parsing the service provider URL list in the file cache
     private static final String URL_SPLIT = ""\\s+"";
+    // Max times to retry to save properties to local cache file
+    private static final int MAX_RETRY_TIMES_SAVE_PROPERTIES = 3;","[{'comment': 'I have some doubts about the retry scenario. In what scenario do we need to try again when the save file fails? Or what scenario has the first save failure, the second time may be successful?', 'commenter': 'carryxyh'}, {'comment': '@ralf0131 \r\nWould u pls also check this point? Thx\r\n:)', 'commenter': 'carryxyh'}, {'comment': ""Er.. I'd say I am not quite sure why it is designed like this. One scenario I can think is that multiple process try to write to the same file, if other process is holding the file lock and this process might failed.  Does that sound reasonable? "", 'commenter': 'ralf0131'}, {'comment': 'Hi,huxing\r\nThank you for your reply.\r\n\r\nAs far as I know, if multiple processes try to write data to the same file, `acquire FD` will be called at the bottom, and this operation is usually a lock operation, so I personally think that if this happens, actually will cause queuing instead of writing failure.\r\n\r\nBut I am not very sure about this point of view. We may need a local test to ensure the rigor of the logic? \r\nHow do u think about it?\r\n:)', 'commenter': 'carryxyh'}, {'comment': 'Yes, you can try it.', 'commenter': 'ralf0131'}, {'comment': 'Hi @carryxyh , do you have any conclusion? If not, I think I can have a try with it. :)', 'commenter': 'kezhenxu94'}]"
3775,dubbo-rpc/dubbo-rpc-xml/NOTICE,"@@ -0,0 +1,65 @@
+Copyright 2015-2020 Qianmi.com Group.","[{'comment': 'This file should be deleted since the main repo have one ', 'commenter': 'lovepoem'}]"
3775,dubbo-rpc/dubbo-rpc-xml/LICENSE,"@@ -0,0 +1,203 @@
+","[{'comment': 'This file should be deleted since the main repo have one ', 'commenter': 'lovepoem'}]"
3775,dubbo-all/pom.xml,"@@ -499,6 +506,7 @@
                                     <include>org.apache.dubbo:dubbo-rpc-memcached</include>
                                     <include>org.apache.dubbo:dubbo-rpc-redis</include>
                                     <include>org.apache.dubbo:dubbo-rpc-rest</include>
+                                    <include>org.apache.dubbo:dubbo-rpc-xmlrpc</include>","[{'comment': 'update  `org.apache.dubbo:dubbo-rpc-xmlrpc` to `org.apache.dubbo:dubbo-rpc-xml`', 'commenter': 'lovepoem'}]"
3775,dubbo-rpc/dubbo-rpc-xml/src/main/java/org/apache/dubbo/xml/remoting/http/jetty/JettyHttpBinder.java,"@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.xml.remoting.http.jetty;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.remoting.http.HttpBinder;
+import org.apache.dubbo.remoting.http.HttpHandler;
+import org.apache.dubbo.remoting.http.HttpServer;
+
+/**
+ * @author sdcuike","[{'comment': 'Please remove author', 'commenter': 'lovepoem'}]"
3775,dubbo-rpc/dubbo-rpc-xml/src/main/java/org/apache/dubbo/xml/remoting/http/jetty/JettyHttpServer.java,"@@ -0,0 +1,89 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.xml.remoting.http.jetty;
+
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.servlet.ServletHandler;
+import org.eclipse.jetty.servlet.ServletHolder;
+import org.eclipse.jetty.util.thread.QueuedThreadPool;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.remoting.http.HttpHandler;
+import org.apache.dubbo.remoting.http.servlet.DispatcherServlet;
+import org.apache.dubbo.remoting.http.support.AbstractHttpServer;
+
+/**
+ * @author sdcuike","[{'comment': 'Please remove author', 'commenter': 'lovepoem'}]"
3775,dubbo-rpc/dubbo-rpc-xml/src/main/java/org/apache/dubbo/xml/rpc/protocol/xmlrpc/XmlRpcProtocol.java,"@@ -0,0 +1,192 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.xml.rpc.protocol.xmlrpc;
+
+import java.io.IOException;
+import java.net.SocketTimeoutException;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.remoting.http.HttpBinder;
+import org.apache.dubbo.remoting.http.HttpHandler;
+import org.apache.dubbo.remoting.http.HttpServer;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.protocol.AbstractProxyProtocol;
+import org.apache.xmlrpc.XmlRpcException;
+import org.apache.xmlrpc.XmlRpcRequest;
+import org.apache.xmlrpc.server.PropertyHandlerMapping;
+import org.apache.xmlrpc.server.RequestProcessorFactoryFactory;
+import org.apache.xmlrpc.server.XmlRpcServerConfigImpl;
+import org.apache.xmlrpc.webserver.XmlRpcServletServer;
+import org.springframework.remoting.RemoteAccessException;
+
+
+/**
+ * Created by wuwen on 15/4/1.","[{'comment': 'Please remove author', 'commenter': 'lovepoem'}]"
3775,dubbo-rpc/dubbo-rpc-xml/src/main/java/org/apache/dubbo/xml/rpc/protocol/xmlrpc/XmlRpcProxyFactoryBean.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.xml.rpc.protocol.xmlrpc;
+
+import org.apache.dubbo.rpc.RpcException;
+
+import org.aopalliance.intercept.MethodInterceptor;
+import org.aopalliance.intercept.MethodInvocation;
+import org.apache.xmlrpc.client.XmlRpcClient;
+import org.apache.xmlrpc.client.XmlRpcClientConfigImpl;
+import org.springframework.aop.framework.ProxyFactory;
+import org.springframework.beans.factory.FactoryBean;
+import org.springframework.beans.factory.InitializingBean;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.ApplicationContextAware;
+import org.springframework.remoting.support.UrlBasedRemoteAccessor;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.net.MalformedURLException;
+import java.net.URL;
+
+
+/**
+ * Created by kimmking(kimmking@163.com) on 2018/3/28.","[{'comment': 'Please remove author', 'commenter': 'lovepoem'}]"
3775,dubbo-rpc/dubbo-rpc-xml/src/test/java/org/apache/dubbo/xml/rpc/protocol/xmlrpc/XmlRpcServiceImpl.java,"@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.xml.rpc.protocol.xmlrpc;
+
+/**
+ * XmlRpcServiceImpl
+ * Created by kimmking(kimmking@163.com) on 2018/3/28.","[{'comment': 'remove author', 'commenter': 'lovepoem'}]"
3775,dubbo-rpc/dubbo-rpc-xml/src/test/java/org/apache/dubbo/xml/rpc/protocol/xmlrpc/XmlRpcService.java,"@@ -0,0 +1,28 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.xml.rpc.protocol.xmlrpc;
+
+/**
+ * Created by kimmking(kimmking@163.com) on 2018/3/28.","[{'comment': 'remove author', 'commenter': 'lovepoem'}]"
3775,dubbo-rpc/dubbo-rpc-xml/src/test/java/org/apache/dubbo/xml/rpc/protocol/xmlrpc/XmlRpcProtocolTest.java,"@@ -0,0 +1,88 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.xml.rpc.protocol.xmlrpc;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.junit.Assert;
+import org.junit.Ignore;
+import org.junit.Test;
+
+
+import org.apache.dubbo.rpc.*;
+
+
+/**
+ * Created by kimmking(kimmking@163.com) on 2018/3/28.","[{'comment': 'remove author', 'commenter': 'lovepoem'}]"
3775,dubbo-rpc/dubbo-rpc-xml/src/test/java/org/apache/dubbo/xml/rpc/protocol/xmlrpc/XmlRpcProtocolTest.java,"@@ -0,0 +1,88 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.xml.rpc.protocol.xmlrpc;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.junit.Assert;
+import org.junit.Ignore;
+import org.junit.Test;
+
+
+import org.apache.dubbo.rpc.*;","[{'comment': '.*  is an incorrect type', 'commenter': 'lovepoem'}]"
3775,dubbo-rpc/dubbo-rpc-xml/pom.xml,"@@ -0,0 +1,177 @@
+<!--
+    - Copyright 1999-2011 Alibaba Group.
+    -
+    - Licensed under the Apache License, Version 2.0 (the ""License"");
+    - you may not use this file except in compliance with the License.
+    - You may obtain a copy of the License at
+    -
+    - http://www.apache.org/licenses/LICENSE-2.0
+    -
+    - Unless required by applicable law or agreed to in writing, software
+    - distributed under the License is distributed on an ""AS IS"" BASIS,
+    - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    - See the License for the specific language governing permissions and
+    - limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.dubbo</groupId>
+        <artifactId>dubbo-rpc</artifactId>
+        <version>2.7.2-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>dubbo-rpc-xml</artifactId>
+    <packaging>jar</packaging>
+    <name>${project.artifactId}</name>
+    <description>The xml rpc module of dubbo project</description>
+    <properties>
+        <jetty_version>9.3.24.v20180605</jetty_version>
+        <mortbay_jetty_version>6.1.26</mortbay_jetty_version>
+        <xmlrpc_version>3.1.3</xmlrpc_version>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <skip_maven_deploy>false</skip_maven_deploy>
+    </properties>
+    <url>https://github.com/apache/incubator-dubbo</url>
+
+    <licenses>
+        <license>
+            <name>Apache License, Version 2.0</name>
+            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+            <distribution>repo</distribution>
+            <comments>A business-friendly OSS license</comments>
+        </license>
+    </licenses>
+
+    <developers>
+        <developer>
+            <name>kimmking</name>
+            <email>kimmking@163.com</email>","[{'comment': 'remove author', 'commenter': 'lovepoem'}]"
3775,dubbo-rpc/dubbo-rpc-xml/README.md,"@@ -0,0 +1,88 @@
+
+dubbo-rpc-xmlrpc
+=====================
+A RPC Extension for XML-RPC(http://ws.apache.org/xmlrpc)
+
+## Maven dependency：
+```xml
+<dependency>
+    <groupId>io.github.kimmking</groupId>","[{'comment': 'Could you please update this?', 'commenter': 'ralf0131'}]"
3775,dubbo-rpc/dubbo-rpc-xml/README.md,"@@ -0,0 +1,88 @@
+
+dubbo-rpc-xmlrpc
+=====================
+A RPC Extension for XML-RPC(http://ws.apache.org/xmlrpc)
+
+## Maven dependency：
+```xml
+<dependency>
+    <groupId>io.github.kimmking</groupId>
+    <artifactId>dubbo-rpc-xmlrpc</artifactId>
+    <version>1.0.2-SNAPSHOT</version>","[{'comment': 'As well as the version number', 'commenter': 'ralf0131'}]"
3775,dubbo-rpc/dubbo-rpc-xml/README.md,"@@ -0,0 +1,88 @@
+
+dubbo-rpc-xmlrpc
+=====================
+A RPC Extension for XML-RPC(http://ws.apache.org/xmlrpc)
+
+## Maven dependency：
+```xml
+<dependency>
+    <groupId>io.github.kimmking</groupId>
+    <artifactId>dubbo-rpc-xmlrpc</artifactId>
+    <version>1.0.2-SNAPSHOT</version>
+</dependency>
+
+```
+
+## Configure：
+Define xmlrpc protocol:
+```xml
+ <dubbo:protocol name=""xmlrpc"" port=""8080"" server=""jetty"" />
+```
+
+Set default protocol:
+```xml
+<dubbo:provider protocol=""xmlrpc"" />
+```
+
+Set service protocol:
+```xml
+<dubbo:service protocol=""xmlrpc"" />
+```
+
+Multi port:
+```xml
+<dubbo:protocol id=""xmlrpc1"" name=""xmlrpc"" port=""8080"" />
+<dubbo:protocol id=""xmlrpc2"" name=""xmlrpc"" port=""8081"" />
+```
+Multi protocol:
+```xml
+<dubbo:protocol name=""dubbo"" port=""20880"" />
+<dubbo:protocol name=""xmlrpc"" port=""8080"" />
+```
+<!-- multi protocols -->
+```xml
+<dubbo:service id=""helloService"" interface=""com.alibaba.hello.api.HelloService"" version=""1.0.0"" protocol=""dubbo,xmlrpc"" />","[{'comment': 'The package name should be changed to org.apache.', 'commenter': 'ralf0131'}]"
3775,dubbo-rpc/dubbo-rpc-xml/pom.xml,"@@ -0,0 +1,170 @@
+<!--
+    - Copyright 1999-2011 Alibaba Group.","[{'comment': 'Use the standard Apache license should be fine.', 'commenter': 'ralf0131'}]"
3775,dubbo-rpc/dubbo-rpc-xml/pom.xml,"@@ -0,0 +1,170 @@
+<!--
+    - Copyright 1999-2011 Alibaba Group.
+    -
+    - Licensed under the Apache License, Version 2.0 (the ""License"");
+    - you may not use this file except in compliance with the License.
+    - You may obtain a copy of the License at
+    -
+    - http://www.apache.org/licenses/LICENSE-2.0
+    -
+    - Unless required by applicable law or agreed to in writing, software
+    - distributed under the License is distributed on an ""AS IS"" BASIS,
+    - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    - See the License for the specific language governing permissions and
+    - limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.dubbo</groupId>
+        <artifactId>dubbo-rpc</artifactId>
+        <version>2.7.2-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>dubbo-rpc-xml</artifactId>
+    <packaging>jar</packaging>
+    <name>${project.artifactId}</name>
+    <description>The xml rpc module of dubbo project</description>
+    <properties>
+        <jetty_version>9.3.24.v20180605</jetty_version>
+        <mortbay_jetty_version>6.1.26</mortbay_jetty_version>
+        <xmlrpc_version>3.1.3</xmlrpc_version>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <skip_maven_deploy>false</skip_maven_deploy>
+    </properties>
+    <url>https://github.com/apache/incubator-dubbo</url>
+
+    <licenses>","[{'comment': 'The license part can be removed, as it has been described in the root pom.', 'commenter': 'ralf0131'}]"
3775,dubbo-rpc/dubbo-rpc-xml/pom.xml,"@@ -0,0 +1,170 @@
+<!--
+    - Copyright 1999-2011 Alibaba Group.
+    -
+    - Licensed under the Apache License, Version 2.0 (the ""License"");
+    - you may not use this file except in compliance with the License.
+    - You may obtain a copy of the License at
+    -
+    - http://www.apache.org/licenses/LICENSE-2.0
+    -
+    - Unless required by applicable law or agreed to in writing, software
+    - distributed under the License is distributed on an ""AS IS"" BASIS,
+    - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    - See the License for the specific language governing permissions and
+    - limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.dubbo</groupId>
+        <artifactId>dubbo-rpc</artifactId>
+        <version>2.7.2-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>dubbo-rpc-xml</artifactId>
+    <packaging>jar</packaging>
+    <name>${project.artifactId}</name>
+    <description>The xml rpc module of dubbo project</description>
+    <properties>
+        <jetty_version>9.3.24.v20180605</jetty_version>
+        <mortbay_jetty_version>6.1.26</mortbay_jetty_version>
+        <xmlrpc_version>3.1.3</xmlrpc_version>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <skip_maven_deploy>false</skip_maven_deploy>
+    </properties>
+    <url>https://github.com/apache/incubator-dubbo</url>
+
+    <licenses>
+        <license>
+            <name>Apache License, Version 2.0</name>
+            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+            <distribution>repo</distribution>
+            <comments>A business-friendly OSS license</comments>
+        </license>
+    </licenses>
+
+    <dependencies>
+        <dependency>
+            <groupId>javax.servlet</groupId>
+            <artifactId>javax.servlet-api</artifactId>
+            <version>3.1.0</version>
+            <scope>provided</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>javax.portlet</groupId>
+            <artifactId>portlet-api</artifactId>
+            <version>2.0</version>
+            <optional>true</optional>
+            <scope>provided</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.xmlrpc</groupId>
+            <artifactId>xmlrpc-server</artifactId>
+            <version>${xmlrpc_version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.xmlrpc</groupId>
+            <artifactId>xmlrpc-client</artifactId>
+            <version>${xmlrpc_version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>4.12</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-server</artifactId>
+            <version>${jetty_version}</version>
+            <optional>true</optional>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-servlet</artifactId>
+            <version>${jetty_version}</version>
+            <optional>true</optional>
+        </dependency>
+        <dependency>
+            <groupId>org.mortbay.jetty</groupId>
+            <artifactId>jetty</artifactId>
+            <version>${mortbay_jetty_version}</version>
+            <optional>true</optional>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-compatible</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+    </dependencies>
+
+    <build>","[{'comment': 'So as this section, it can be removed. You can refer to other modules under dubbo-rpc.', 'commenter': 'ralf0131'}]"
3775,dubbo-rpc/dubbo-rpc-xml/pom.xml,"@@ -0,0 +1,170 @@
+<!--
+    - Copyright 1999-2011 Alibaba Group.
+    -
+    - Licensed under the Apache License, Version 2.0 (the ""License"");
+    - you may not use this file except in compliance with the License.
+    - You may obtain a copy of the License at
+    -
+    - http://www.apache.org/licenses/LICENSE-2.0
+    -
+    - Unless required by applicable law or agreed to in writing, software
+    - distributed under the License is distributed on an ""AS IS"" BASIS,
+    - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    - See the License for the specific language governing permissions and
+    - limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.dubbo</groupId>
+        <artifactId>dubbo-rpc</artifactId>
+        <version>2.7.2-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>dubbo-rpc-xml</artifactId>
+    <packaging>jar</packaging>
+    <name>${project.artifactId}</name>
+    <description>The xml rpc module of dubbo project</description>
+    <properties>
+        <jetty_version>9.3.24.v20180605</jetty_version>
+        <mortbay_jetty_version>6.1.26</mortbay_jetty_version>
+        <xmlrpc_version>3.1.3</xmlrpc_version>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <skip_maven_deploy>false</skip_maven_deploy>
+    </properties>
+    <url>https://github.com/apache/incubator-dubbo</url>
+
+    <licenses>
+        <license>
+            <name>Apache License, Version 2.0</name>
+            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+            <distribution>repo</distribution>
+            <comments>A business-friendly OSS license</comments>
+        </license>
+    </licenses>
+
+    <dependencies>
+        <dependency>
+            <groupId>javax.servlet</groupId>
+            <artifactId>javax.servlet-api</artifactId>
+            <version>3.1.0</version>
+            <scope>provided</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>javax.portlet</groupId>
+            <artifactId>portlet-api</artifactId>
+            <version>2.0</version>
+            <optional>true</optional>
+            <scope>provided</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.xmlrpc</groupId>
+            <artifactId>xmlrpc-server</artifactId>
+            <version>${xmlrpc_version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.xmlrpc</groupId>
+            <artifactId>xmlrpc-client</artifactId>
+            <version>${xmlrpc_version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>4.12</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-server</artifactId>
+            <version>${jetty_version}</version>
+            <optional>true</optional>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-servlet</artifactId>
+            <version>${jetty_version}</version>
+            <optional>true</optional>
+        </dependency>
+        <dependency>
+            <groupId>org.mortbay.jetty</groupId>
+            <artifactId>jetty</artifactId>
+            <version>${mortbay_jetty_version}</version>
+            <optional>true</optional>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-compatible</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-source-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>attach-sources</id>
+                        <goals>
+                            <goal>jar</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-javadoc-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>attach-javadocs</id>
+                        <goals>
+                            <goal>jar</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+        </plugins>
+    </build>
+
+    <profiles>","[{'comment': 'And so as this section.', 'commenter': 'ralf0131'}]"
3775,dubbo-rpc/dubbo-rpc-xml/pom.xml,"@@ -0,0 +1,170 @@
+<!--
+    - Copyright 1999-2011 Alibaba Group.
+    -
+    - Licensed under the Apache License, Version 2.0 (the ""License"");
+    - you may not use this file except in compliance with the License.
+    - You may obtain a copy of the License at
+    -
+    - http://www.apache.org/licenses/LICENSE-2.0
+    -
+    - Unless required by applicable law or agreed to in writing, software
+    - distributed under the License is distributed on an ""AS IS"" BASIS,
+    - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    - See the License for the specific language governing permissions and
+    - limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.dubbo</groupId>
+        <artifactId>dubbo-rpc</artifactId>
+        <version>2.7.2-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>dubbo-rpc-xml</artifactId>
+    <packaging>jar</packaging>
+    <name>${project.artifactId}</name>
+    <description>The xml rpc module of dubbo project</description>
+    <properties>
+        <jetty_version>9.3.24.v20180605</jetty_version>
+        <mortbay_jetty_version>6.1.26</mortbay_jetty_version>
+        <xmlrpc_version>3.1.3</xmlrpc_version>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <skip_maven_deploy>false</skip_maven_deploy>
+    </properties>
+    <url>https://github.com/apache/incubator-dubbo</url>
+
+    <licenses>
+        <license>
+            <name>Apache License, Version 2.0</name>
+            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+            <distribution>repo</distribution>
+            <comments>A business-friendly OSS license</comments>
+        </license>
+    </licenses>
+
+    <dependencies>
+        <dependency>
+            <groupId>javax.servlet</groupId>
+            <artifactId>javax.servlet-api</artifactId>
+            <version>3.1.0</version>
+            <scope>provided</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>javax.portlet</groupId>","[{'comment': 'The external dependencies should go into dubbo-dependency-bom.', 'commenter': 'ralf0131'}, {'comment': 'Agree with raft0131', 'commenter': 'chickenlj'}, {'comment': ""I moved to dubbo-dependency-bom everything that isn't an org.apache dependency"", 'commenter': 'danielamorais'}]"
3775,dubbo-rpc/dubbo-rpc-xml/src/main/java/org/apache/dubbo/xml/remoting/http/jetty/JettyHttpServer.java,"@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.xml.remoting.http.jetty;
+
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.servlet.ServletHandler;
+import org.eclipse.jetty.servlet.ServletHolder;
+import org.eclipse.jetty.util.thread.QueuedThreadPool;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.remoting.http.HttpHandler;
+import org.apache.dubbo.remoting.http.servlet.DispatcherServlet;
+import org.apache.dubbo.remoting.http.support.AbstractHttpServer;
+
+public class JettyHttpServer extends AbstractHttpServer {","[{'comment': ""I remember there's already one JettyHttpServer in one of the `remoting` module, could you please see the possibilities of reuse that one?"", 'commenter': 'chickenlj'}, {'comment': 'JettyHttpServer and JettyHttpBinder are duplicate files, thank u ', 'commenter': 'danielamorais'}]"
3775,dubbo-rpc/dubbo-rpc-xml/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.remoting.http.HttpBinder,"@@ -0,0 +1 @@
+jetty9=JettyHttpBinder","[{'comment': 'It should be `jetty9= org.apache.dubbo.xml.remoting.http.jetty.JettyHttpBinder`', 'commenter': 'chickenlj'}]"
3775,dubbo-rpc/dubbo-rpc-xml/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.rpc.Protocol,"@@ -0,0 +1 @@
+xmlrpc=XmlRpcProtocol","[{'comment': 'The same problem as JettyHttpBinder', 'commenter': 'chickenlj'}]"
3775,dubbo-rpc/dubbo-rpc-xml/src/main/java/org/apache/dubbo/xml/rpc/protocol/xmlrpc/XmlRpcProtocol.java,"@@ -0,0 +1,188 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.xml.rpc.protocol.xmlrpc;
+
+import java.io.IOException;
+import java.net.SocketTimeoutException;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.remoting.http.HttpBinder;
+import org.apache.dubbo.remoting.http.HttpHandler;
+import org.apache.dubbo.remoting.http.HttpServer;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.protocol.AbstractProxyProtocol;
+import org.apache.xmlrpc.XmlRpcException;
+import org.apache.xmlrpc.XmlRpcRequest;
+import org.apache.xmlrpc.server.PropertyHandlerMapping;
+import org.apache.xmlrpc.server.RequestProcessorFactoryFactory;
+import org.apache.xmlrpc.server.XmlRpcServerConfigImpl;
+import org.apache.xmlrpc.webserver.XmlRpcServletServer;
+import org.springframework.remoting.RemoteAccessException;
+
+public class XmlRpcProtocol extends AbstractProxyProtocol {
+    
+    public static final String ACCESS_CONTROL_ALLOW_ORIGIN_HEADER = ""Access-Control-Allow-Origin"";
+    public static final String ACCESS_CONTROL_ALLOW_METHODS_HEADER = ""Access-Control-Allow-Methods"";
+    public static final String ACCESS_CONTROL_ALLOW_HEADERS_HEADER = ""Access-Control-Allow-Headers"";
+
+    private final Map<String, HttpServer> serverMap = new ConcurrentHashMap<>();
+
+    private final Map<String, XmlRpcServletServer> skeletonMap = new ConcurrentHashMap<>();
+
+    private HttpBinder httpBinder;
+
+    public XmlRpcProtocol() {
+        super(XmlRpcException.class);
+    }
+
+    public void setHttpBinder(HttpBinder httpBinder) {
+        this.httpBinder = httpBinder;
+    }
+
+    public int getDefaultPort() {
+        return 80;
+    }
+
+    private class InternalHandler implements HttpHandler {
+    	
+        private boolean cors;
+
+        public InternalHandler(boolean cors) {
+            this.cors = cors;
+        }
+
+        public void handle(HttpServletRequest request, HttpServletResponse response)
+                throws IOException, ServletException {
+            String uri = request.getRequestURI();
+            XmlRpcServletServer xmlrpc = skeletonMap.get(uri);
+            if (cors) {
+                response.setHeader(ACCESS_CONTROL_ALLOW_ORIGIN_HEADER, ""*"");
+                response.setHeader(ACCESS_CONTROL_ALLOW_METHODS_HEADER, ""POST"");
+                response.setHeader(ACCESS_CONTROL_ALLOW_HEADERS_HEADER, ""*"");
+            }
+            if (request.getMethod().equalsIgnoreCase(""OPTIONS"")) {
+                response.setStatus(200);
+            } else if (request.getMethod().equalsIgnoreCase(""POST"")) {
+
+                RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());
+                try {
+                    xmlrpc.execute (request,response);
+                } catch (Throwable e) {
+                    throw new ServletException(e);
+                }
+            } else {
+                response.setStatus(500);
+            }
+        }
+
+    }
+
+    protected <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException {
+        final URL http_url = url.setProtocol(""http"");","[{'comment': ""Why do we need to change protocol to 'http', what is the original protocol passed in?"", 'commenter': 'chickenlj'}, {'comment': 'Is ""xmlrpc"" ', 'commenter': 'danielamorais'}]"
3786,dubbo-rpc/dubbo-rpc-jsonrpc/pom.xml,"@@ -0,0 +1,63 @@
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the ""License""); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+  -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <parent>
+        <artifactId>dubbo-rpc</artifactId>
+        <groupId>org.apache.dubbo</groupId>
+        <version>2.7.2-SNAPSHOT</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>dubbo-rpc-jsonrpc</artifactId>
+
+    <description>The JSON-RPC module of dubbo project</description>
+
+    <properties>
+        <skip_maven_deploy>false</skip_maven_deploy>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-rpc-api</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-remoting-http</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+        <!--google-jsonrpc依赖spring-->
+        <dependency>
+            <groupId>org.springframework</groupId>
+            <artifactId>spring-context</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.github.briandilley.jsonrpc4j</groupId>
+            <artifactId>jsonrpc4j</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>javax.portlet</groupId>","[{'comment': 'This should go to  dubbo-dependencies-bom.', 'commenter': 'ralf0131'}, {'comment': 'I have moved the version declaration of `javax.portlet` to `dubbo-dependencies-bom`.', 'commenter': 'lexburner'}]"
3798,dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/ListTelnetHandler.java,"@@ -61,10 +64,16 @@ public String telnet(Channel channel, String message) {
                 if (buf.length() > 0) {
                     buf.append(""\r\n"");
                 }
+                URL exportUrl = exporter.getInvoker().getUrl();
+                Map<String, String> params = StringUtils.parseQueryString(exportUrl.toFullString());","[{'comment': 'You can use org.apache.dubbo.common.URL#getParameter(java.lang.String) instead of this.', 'commenter': 'ralf0131'}]"
3798,dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/telnet/ListTelnetHandler.java,"@@ -61,10 +64,16 @@ public String telnet(Channel channel, String message) {
                 if (buf.length() > 0) {
                     buf.append(""\r\n"");
                 }
+                URL exportUrl = exporter.getInvoker().getUrl();
+                Map<String, String> params = StringUtils.parseQueryString(exportUrl.toFullString());
+                String group = params.get(""group"");
+                if (StringUtils.isNotEmpty(group)) {
+                    buf.append(group.concat(""/""));","[{'comment': 'Use `buf.append(group).append(""/"")` instead, which saves to create an extra String object.', 'commenter': 'ralf0131'}]"
3825,dubbo-common/src/main/java/org/apache/dubbo/common/utils/ProtobufUtils.java,"@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.utils;
+
+import java.lang.reflect.Method;
+
+import com.google.protobuf.GeneratedMessageV3;
+import com.google.protobuf.GeneratedMessageV3.Builder;
+import com.google.protobuf.MessageOrBuilder;
+import com.google.protobuf.util.JsonFormat;
+import com.google.protobuf.util.JsonFormat.Parser;
+import com.google.protobuf.util.JsonFormat.Printer;
+
+/**
+ * 2019/4/4","[{'comment': 'pls. remove this header.', 'commenter': 'beiwei30'}, {'comment': 'Done', 'commenter': 'vio-lin'}]"
3825,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java,"@@ -107,6 +108,16 @@ public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
                                             args[i].getClass().getName());
                         }
                     }
+                }else if (ProtocolUtils.isProtobufGenericSerialization(generic)) {","[{'comment': 'pay more attention to code style. You should import https://github.com/apache/incubator-dubbo/tree/master/codestyle and go through your change thoroughly.', 'commenter': 'beiwei30'}, {'comment': 'done， test by format another file,it works well', 'commenter': 'vio-lin'}]"
3825,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java,"@@ -125,7 +136,9 @@ public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
                     }
                 } else if (ProtocolUtils.isBeanGenericSerialization(generic)) {
                     return new RpcResult(JavaBeanSerializeUtil.serialize(result.getValue(), JavaBeanAccessor.METHOD));
-                } else {
+                } else if(ProtocolUtils.isProtobufGenericSerialization(generic)) {","[{'comment': 'Even move ProtobufUtils into dubbo-rpc-api, it is still a little bit heavier to let dubbo-rpc-api to depend on Protobuf. \r\n\r\nAt least we need to file a new issue to track down this work, to refactor this filter to use extension loader to load generic serializations to avoid introduce unnecessary dependencies in this module.', 'commenter': 'beiwei30'}]"
3825,dubbo-demo/dubbo-demo-protobuf/dubbo-demo-protobuf-consumer/pom.xml,"@@ -0,0 +1,78 @@
+<!--","[{'comment': 'we should move this demo into [dubbo-samples](https://github.com/apache/incubator-dubbo-samples)', 'commenter': 'beiwei30'}, {'comment': 'remove these demos.And these will be added in a pull request to dubbo-samples.', 'commenter': 'vio-lin'}]"
3833,dubbo-monitor/dubbo-monitor-default/src/main/java/org/apache/dubbo/monitor/dubbo/MetricsFilter.java,"@@ -0,0 +1,251 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.monitor.dubbo;
+
+import com.alibaba.fastjson.JSON;
+import com.alibaba.metrics.FastCompass;
+import com.alibaba.metrics.MetricLevel;
+import com.alibaba.metrics.MetricManager;
+import com.alibaba.metrics.MetricName;
+import com.alibaba.metrics.MetricRegistry;
+import com.alibaba.metrics.common.CollectLevel;
+import com.alibaba.metrics.common.MetricObject;
+import com.alibaba.metrics.common.MetricsCollector;
+import com.alibaba.metrics.common.MetricsCollectorFactory;
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.store.DataStore;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.monitor.MetricsService;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.RpcResult;
+import org.apache.dubbo.rpc.support.RpcUtils;
+import java.util.Collections;
+import java.util.SortedMap;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class MetricsFilter implements Filter {
+
+    private static final Logger logger = LoggerFactory.getLogger(MetricsFilter.class);
+    private static volatile AtomicBoolean exported = new AtomicBoolean(false);
+    private Integer port = 20880;
+    private String protocolName = Constants.DEFAULT_PROTOCOL;
+    private Invoker<MetricsService> metricsInvoker;
+
+    @Override
+    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
+        this.port = invoker.getUrl().getParameter(Constants.METRICS_PORT) == null ?
+                20880 : Integer.valueOf(invoker.getUrl().getParameter(Constants.METRICS_PORT));
+
+        this.protocolName = invoker.getUrl().getParameter(Constants.METRICS_PROTOCOL) == null ?
+                Constants.DEFAULT_PROTOCOL : invoker.getUrl().getParameter(Constants.METRICS_PROTOCOL);
+        initMetricsInvoker();","[{'comment': 'this will create a new object every time', 'commenter': 'nzomkxia'}]"
3833,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -426,6 +426,7 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r
 
         Map<String, String> map = new HashMap<String, String>();
         map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);
+        MetricsConfig.addMetricsDataToMap(map);","[{'comment': 'Why not use `appendParameters(map, metricsConfig);` directly as the other Configs do?', 'commenter': 'chickenlj'}]"
3833,dubbo-monitor/dubbo-monitor-default/src/main/java/org/apache/dubbo/monitor/dubbo/MetricsFilter.java,"@@ -0,0 +1,251 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.monitor.dubbo;
+
+import com.alibaba.fastjson.JSON;
+import com.alibaba.metrics.FastCompass;
+import com.alibaba.metrics.MetricLevel;
+import com.alibaba.metrics.MetricManager;
+import com.alibaba.metrics.MetricName;
+import com.alibaba.metrics.MetricRegistry;
+import com.alibaba.metrics.common.CollectLevel;
+import com.alibaba.metrics.common.MetricObject;
+import com.alibaba.metrics.common.MetricsCollector;
+import com.alibaba.metrics.common.MetricsCollectorFactory;
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.store.DataStore;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.monitor.MetricsService;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.RpcResult;
+import org.apache.dubbo.rpc.support.RpcUtils;
+import java.util.Collections;
+import java.util.SortedMap;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class MetricsFilter implements Filter {
+
+    private static final Logger logger = LoggerFactory.getLogger(MetricsFilter.class);
+    private static volatile AtomicBoolean exported = new AtomicBoolean(false);
+    private Integer port = 20880;
+    private String protocolName = Constants.DEFAULT_PROTOCOL;
+    private Invoker<MetricsService> metricsInvoker;
+
+    @Override
+    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
+        this.port = invoker.getUrl().getParameter(Constants.METRICS_PORT) == null ?
+                20880 : Integer.valueOf(invoker.getUrl().getParameter(Constants.METRICS_PORT));
+
+        this.protocolName = invoker.getUrl().getParameter(Constants.METRICS_PROTOCOL) == null ?
+                Constants.DEFAULT_PROTOCOL : invoker.getUrl().getParameter(Constants.METRICS_PROTOCOL);
+
+        if (exported.compareAndSet(false, true)) {
+            initMetricsInvoker();
+            Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(protocolName);
+            try {
+                protocol.export(metricsInvoker);","[{'comment': ""`metricsInvoker` is only used in here,  it can be a local variable instead of defined as MetricsFilter's property."", 'commenter': 'chickenlj'}]"
3833,dubbo-monitor/dubbo-monitor-default/src/main/java/org/apache/dubbo/monitor/dubbo/MetricsFilter.java,"@@ -0,0 +1,251 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.monitor.dubbo;
+
+import com.alibaba.fastjson.JSON;
+import com.alibaba.metrics.FastCompass;
+import com.alibaba.metrics.MetricLevel;
+import com.alibaba.metrics.MetricManager;
+import com.alibaba.metrics.MetricName;
+import com.alibaba.metrics.MetricRegistry;
+import com.alibaba.metrics.common.CollectLevel;
+import com.alibaba.metrics.common.MetricObject;
+import com.alibaba.metrics.common.MetricsCollector;
+import com.alibaba.metrics.common.MetricsCollectorFactory;
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.store.DataStore;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.monitor.MetricsService;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.RpcResult;
+import org.apache.dubbo.rpc.support.RpcUtils;
+import java.util.Collections;
+import java.util.SortedMap;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class MetricsFilter implements Filter {
+
+    private static final Logger logger = LoggerFactory.getLogger(MetricsFilter.class);
+    private static volatile AtomicBoolean exported = new AtomicBoolean(false);
+    private Integer port = 20880;","[{'comment': ""I find Protocol has a `getDefaultPort()` method to get each Protocol's default port. So maybe there's no need to define a default port here? How about following each protocol's default port. \r\n\r\nOne thing to notice is that you may need to create a separate connection for metrics service, this can be helpful in isolating from normal RPC calls especially when they are working on the same port."", 'commenter': 'chickenlj'}]"
3833,dubbo-monitor/dubbo-monitor-default/src/main/java/org/apache/dubbo/monitor/dubbo/MetricsFilter.java,"@@ -0,0 +1,251 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.monitor.dubbo;
+
+import com.alibaba.fastjson.JSON;
+import com.alibaba.metrics.FastCompass;
+import com.alibaba.metrics.MetricLevel;
+import com.alibaba.metrics.MetricManager;
+import com.alibaba.metrics.MetricName;
+import com.alibaba.metrics.MetricRegistry;
+import com.alibaba.metrics.common.CollectLevel;
+import com.alibaba.metrics.common.MetricObject;
+import com.alibaba.metrics.common.MetricsCollector;
+import com.alibaba.metrics.common.MetricsCollectorFactory;
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.store.DataStore;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.monitor.MetricsService;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.RpcResult;
+import org.apache.dubbo.rpc.support.RpcUtils;
+import java.util.Collections;
+import java.util.SortedMap;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class MetricsFilter implements Filter {
+
+    private static final Logger logger = LoggerFactory.getLogger(MetricsFilter.class);
+    private static volatile AtomicBoolean exported = new AtomicBoolean(false);
+    private Integer port = 20880;
+    private String protocolName = Constants.DEFAULT_PROTOCOL;
+    private Invoker<MetricsService> metricsInvoker;
+
+    @Override
+    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
+        this.port = invoker.getUrl().getParameter(Constants.METRICS_PORT) == null ?
+                20880 : Integer.valueOf(invoker.getUrl().getParameter(Constants.METRICS_PORT));
+
+        this.protocolName = invoker.getUrl().getParameter(Constants.METRICS_PROTOCOL) == null ?
+                Constants.DEFAULT_PROTOCOL : invoker.getUrl().getParameter(Constants.METRICS_PROTOCOL);
+
+        if (exported.compareAndSet(false, true)) {
+            initMetricsInvoker();
+            Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(protocolName);
+            try {
+                protocol.export(metricsInvoker);
+            } catch (RuntimeException e) {
+                logger.error(""Metrics Service need to be configured"" +
+                        "" when multiple processes are running on a host"" + e.getMessage());
+            }
+        }
+
+        RpcContext context = RpcContext.getContext();
+        boolean isProvider = context.isProviderSide();
+        long start = System.currentTimeMillis();
+        try {
+            Result result = invoker.invoke(invocation); // proceed invocation chain
+            long duration = System.currentTimeMillis() - start;
+            reportMetrics(invoker, invocation, duration, ""success"", isProvider);
+            return result;
+        } catch (RpcException e) {
+            long duration = System.currentTimeMillis() - start;
+            String result = ""error"";
+            if (e.isTimeout()) {
+                result = ""timeoutError"";
+            }
+            if (e.isBiz()) {
+                result = ""bisError"";
+            }
+            if (e.isNetwork()) {
+                result = ""networkError"";
+            }
+            if (e.isSerialization()) {
+                result = ""serializationError"";
+            }
+            reportMetrics(invoker, invocation, duration, result, isProvider);
+            throw e;
+        }
+    }
+
+    private String buildMethodName(Invocation invocation) {
+        String methodName = RpcUtils.getMethodName(invocation);
+        StringBuilder method = new StringBuilder(methodName);
+        Class<?>[] argTypes = RpcUtils.getParameterTypes(invocation);
+
+        method.append(""("");
+
+        for (int i = 0; i < argTypes.length; i++) {
+            method.append((i == 0 ? """" : "", "") + argTypes[i].getSimpleName());
+        }
+        method.append("")"");
+        Class<?> returnType = RpcUtils.getReturnType(invocation);
+        String typeName = null;
+        if(returnType != null) {
+            typeName = returnType.getTypeName();
+            typeName = typeName.substring(typeName.lastIndexOf(""."") + 1);
+        }
+
+        return (typeName == null ? ""void"" : typeName) + "" "" + method;
+    }
+
+    private void reportMetrics(Invoker<?> invoker, Invocation invocation, long duration, String result, boolean isProvider) {
+        String serviceName = invoker.getInterface().getName();
+        String methodName = buildMethodName(invocation);
+        MetricName global;
+        MetricName method;
+        if (isProvider) {
+            global = new MetricName(Constants.DUBBO_PROVIDER, MetricLevel.MAJOR);
+            method = new MetricName(Constants.DUBBO_PROVIDER_METHOD, new HashMap<String, String>(4) {
+                {
+                    put(Constants.SERVICE, serviceName);
+                    put(Constants.METHOD, methodName);
+                }
+            }, MetricLevel.NORMAL);
+        } else {
+            global = new MetricName(Constants.DUBBO_CONSUMER, MetricLevel.MAJOR);
+            method = new MetricName(Constants.DUBBO_CONSUMER_METHOD, new HashMap<String, String>(4) {
+                {
+                    put(Constants.SERVICE, serviceName);
+                    put(Constants.METHOD, methodName);
+                }
+            }, MetricLevel.NORMAL);
+        }
+        setCompassQuantity(Constants.DUBBO_GROUP, result, duration, global, method);
+    }
+
+    private void setCompassQuantity(String groupName, String result, long duration, MetricName... metricNames) {
+        for (MetricName metricName : metricNames) {
+            FastCompass compass = MetricManager.getFastCompass(groupName, metricName);
+            compass.record(duration, result);
+        }
+    }
+
+    private List<MetricObject> getThreadPoolMessage() {
+        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();
+        Map<String, Object> executors = dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY);
+
+        List<MetricObject> threadPoolMtricList = new ArrayList<>();
+        for (Map.Entry<String, Object> entry : executors.entrySet()) {
+            String port = entry.getKey();
+            ExecutorService executor = (ExecutorService) entry.getValue();
+            if (executor instanceof ThreadPoolExecutor) {
+                ThreadPoolExecutor tp = (ThreadPoolExecutor) executor;
+                // ignore metrcis service
+                if (port.equals(this.port + """")) {
+                    continue;
+                }
+
+                threadPoolMtricList.add(value2MetricObject(""threadPool.active"", tp.getActiveCount(), MetricLevel.MAJOR));
+                threadPoolMtricList.add(value2MetricObject(""threadPool.core"", tp.getCorePoolSize(), MetricLevel.MAJOR));
+                threadPoolMtricList.add(value2MetricObject(""threadPool.max"", tp.getMaximumPoolSize(), MetricLevel.MAJOR));
+                threadPoolMtricList.add(value2MetricObject(""threadPool.current"", tp.getPoolSize(), MetricLevel.MAJOR));
+            }
+        }
+
+        return threadPoolMtricList;
+    }
+
+    private MetricObject value2MetricObject(String metric, Integer value, MetricLevel level) {
+        if (metric == null || value == null || level == null)
+            return null;
+
+        return new MetricObject
+                .Builder(metric)
+                .withValue(value)
+                .withLevel(level)
+                .build();
+    }
+
+    private void initMetricsInvoker() {
+        metricsInvoker = new Invoker<MetricsService>() {
+            @Override
+            public Class<MetricsService> getInterface() {
+                return MetricsService.class;
+            }
+
+            @Override
+            public Result invoke(Invocation invocation) throws RpcException {
+                String group = invocation.getArguments()[0].toString();
+                MetricRegistry registry = MetricManager.getIMetricManager().getMetricRegistryByGroup(group);
+
+                SortedMap<MetricName, FastCompass> fastCompasses = registry.getFastCompasses();
+
+                long timestamp = System.currentTimeMillis();
+                double rateFactor = TimeUnit.SECONDS.toSeconds(1);
+                double durationFactor = 1.0 / TimeUnit.MILLISECONDS.toNanos(1);
+
+
+                MetricsCollector collector = MetricsCollectorFactory.createNew(
+                        CollectLevel.NORMAL, Collections.EMPTY_MAP, rateFactor, durationFactor, null);
+
+                for (Map.Entry<MetricName, FastCompass> entry : fastCompasses.entrySet()) {
+                    collector.collect(entry.getKey(), entry.getValue(), timestamp);
+                }
+
+                RpcResult result = new RpcResult();
+
+                List res = collector.build();
+                res.addAll(getThreadPoolMessage());
+                result.setValue(JSON.toJSONString(res));
+                return result;
+            }
+
+            @Override
+            public URL getUrl() {
+                return URL.valueOf(protocolName + ""://"" + NetUtils.getLocalAddress().getHostName() + "":"" + port + ""/"" + MetricsService.class.getName());","[{'comment': ""`NetUtils.getLocalAddress().getHostName()`\r\n\r\nThe IP address used here may have a problem, we should think using a unified tool for getting outward IP, I remember there's one thread discussing the same topic. "", 'commenter': 'chickenlj'}]"
3833,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -276,6 +282,7 @@ private void init() {
             }
         }
         map.put(Constants.INTERFACE_KEY, interfaceName);
+        appendParameters(map, metrics, Constants.METRICS_KEY);","[{'comment': '`Constants.METRICS_KEY` should be removed', 'commenter': 'chickenlj'}]"
3833,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -145,6 +145,11 @@
      */
     private ProviderConfig provider;
 
+    /**
+     * The metrics configuration
+     */
+    private MetricsConfig metrics;","[{'comment': 'Both ServiceConfig and ReferenceConfig have this property, how about moving it to one shared superclass.', 'commenter': 'chickenlj'}]"
3833,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -426,7 +431,9 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r
 
         Map<String, String> map = new HashMap<String, String>();
         map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);
+
         appendRuntimeParameters(map);
+        appendParameters(map, metrics, Constants.METRICS_KEY);","[{'comment': ' Constants.METRICS_KEY should be removed.', 'commenter': 'chickenlj'}]"
3852,pom.xml,"@@ -120,10 +120,12 @@
         <maven_jetty_version>9.4.11.v20180605</maven_jetty_version>
         <maven_checkstyle_version>3.0.0</maven_checkstyle_version>
         <maven_jacoco_version>0.8.2</maven_jacoco_version>
+        <maven_flatten_version>1.1.0</maven_flatten_version>
         <apache-rat-plugin.version>0.12</apache-rat-plugin.version>
         <arguments/>
         <checkstyle.skip>true</checkstyle.skip>
         <rat.skip>true</rat.skip>
+        <revision>2.7.2-SNAPSHOT</revision>","[{'comment': 'It should be changed to 3.0.0-SNAPSHOT', 'commenter': 'ralf0131'}, {'comment': 'done.', 'commenter': 'chickenlj'}]"
3864,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ConsumerContextFilter.java,"@@ -54,7 +54,14 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept
             return invoker.invoke(invocation);
         } finally {
             // TODO removeContext? but we need to save future for RpcContext.getFuture() API. If clear attachments here, attachments will not available when postProcessResult is invoked.
+            String tag = null;
+            if (RpcContext.getContext().getAttachments() != null && RpcContext.getContext().getAttachment(Constants.TAG_KEY) != null) {
+                tag = RpcContext.getContext().getAttachment(Constants.TAG_KEY);
+            }
             RpcContext.getContext().clearAttachments();
+            if (tag != null) {
+                RpcContext.getContext().setAttachment(Constants.TAG_KEY, tag);","[{'comment': ""I don't think this default behavior should be changed.  We should clear the attachments each time to avoid effects on the following RPC calls. "", 'commenter': 'chickenlj'}]"
3869,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java,"@@ -210,7 +211,7 @@ public ProtocolConfig getProtocol() {
     }
 
     public void setProtocol(ProtocolConfig protocol) {
-        setProtocols(Arrays.asList(protocol));
+        setProtocols(new ArrayList<ProtocolConfig>(Arrays.asList(protocol)));","[{'comment': '`setProtocols(new ArrayList<>(protocol));` seems more concise to me.', 'commenter': 'kun-song'}, {'comment': ""We don't a constructor to receive one single element for ArrayList.class, do we?"", 'commenter': 'Moriadry-zz'}, {'comment': 'Yes, how can I make such a mistake :)', 'commenter': 'kun-song'}]"
3869,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProviderConfig.java,"@@ -157,7 +158,7 @@
 
     @Deprecated
     public void setProtocol(String protocol) {
-        this.protocols = Arrays.asList(new ProtocolConfig[]{new ProtocolConfig(protocol)});
+        this.protocols = new ArrayList<ProtocolConfig>(Arrays.asList(new ProtocolConfig[]{ new ProtocolConfig(protocol)}));","[{'comment': '`this.protocols = new ArrayList<>(new ProtocolConfig(protocol));` seems better to me', 'commenter': 'kun-song'}, {'comment': 'protocol is a string, we need to build a ProtocolConfig object to pass to ArrayList class, I believe this is just the way to use. Even though it seems a little bit hard to read :(', 'commenter': 'Moriadry-zz'}]"
3869,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -830,7 +830,7 @@ private void convertProtocolIdsToProtocols() {
                         .orElseGet(() -> {
                             ProtocolConfig protocolConfig = new ProtocolConfig();
                             protocolConfig.refresh();
-                            return Arrays.asList(protocolConfig);
+                            return new ArrayList<ProtocolConfig>(Arrays.asList(protocolConfig));","[{'comment': 'same as above', 'commenter': 'kun-song'}]"
3869,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractServiceConfig.java,"@@ -1,299 +1,300 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.config.context.ConfigManager;
-import org.apache.dubbo.common.utils.CollectionUtils;
-import org.apache.dubbo.config.support.Parameter;
-import org.apache.dubbo.rpc.ExporterListener;
-
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * AbstractServiceConfig
- *
- * @export
- */
-public abstract class AbstractServiceConfig extends AbstractInterfaceConfig {
-
-    private static final long serialVersionUID = 1L;
-
-    /**
-     * The service version
-     */
-    protected String version;
-
-    /**
-     * The service group
-     */
-    protected String group;
-
-    /**
-     * whether the service is deprecated
-     */
-    protected Boolean deprecated = false;
-
-    /**
-     * The time delay register service (milliseconds)
-     */
-    protected Integer delay;
-
-    /**
-     * Whether to export the service
-     */
-    protected Boolean export;
-
-    /**
-     * The service weight
-     */
-    protected Integer weight;
-
-    /**
-     * Document center
-     */
-    protected String document;
-
-    /**
-     * Whether to register as a dynamic service or not on register center, it the value is false, the status will be disabled
-     * after the service registered,and it needs to be enabled manually; if you want to disable the service, you also need
-     * manual processing
-     */
-    protected Boolean dynamic = true;
-
-    /**
-     * Whether to use token
-     */
-    protected String token;
-
-    /**
-     * Whether to export access logs to logs
-     */
-    protected String accesslog;
-
-    /**
-     * The protocol list the service will export with
-     */
-    protected List<ProtocolConfig> protocols;
-    protected String protocolIds;
-    // provider tag
-    protected String tag;
-    // max allowed execute times
-    private Integer executes;
-
-    /**
-     * Whether to register
-     */
-    private Boolean register = true;
-
-    /**
-     * Warm up period
-     */
-    private Integer warmup;
-
-    /**
-     * The serialization type
-     */
-    private String serialization;
-
-    public String getVersion() {
-        return version;
-    }
-
-    public void setVersion(String version) {
-        checkKey(Constants.VERSION_KEY, version);
-        this.version = version;
-    }
-
-    public String getGroup() {
-        return group;
-    }
-
-    public void setGroup(String group) {
-        checkKey(Constants.GROUP_KEY, group);
-        this.group = group;
-    }
-
-    public Integer getDelay() {
-        return delay;
-    }
-
-    public void setDelay(Integer delay) {
-        this.delay = delay;
-    }
-
-    public Boolean getExport() {
-        return export;
-    }
-
-    public void setExport(Boolean export) {
-        this.export = export;
-    }
-
-    public Integer getWeight() {
-        return weight;
-    }
-
-    public void setWeight(Integer weight) {
-        this.weight = weight;
-    }
-
-    @Parameter(escaped = true)
-    public String getDocument() {
-        return document;
-    }
-
-    public void setDocument(String document) {
-        this.document = document;
-    }
-
-    public String getToken() {
-        return token;
-    }
-
-    public void setToken(Boolean token) {
-        if (token == null) {
-            setToken((String) null);
-        } else {
-            setToken(String.valueOf(token));
-        }
-    }
-
-    public void setToken(String token) {
-        checkName(Constants.TOKEN_KEY, token);
-        this.token = token;
-    }
-
-    public Boolean isDeprecated() {
-        return deprecated;
-    }
-
-    public void setDeprecated(Boolean deprecated) {
-        this.deprecated = deprecated;
-    }
-
-    public Boolean isDynamic() {
-        return dynamic;
-    }
-
-    public void setDynamic(Boolean dynamic) {
-        this.dynamic = dynamic;
-    }
-
-    public List<ProtocolConfig> getProtocols() {
-        return protocols;
-    }
-
-    @SuppressWarnings({""unchecked""})
-    public void setProtocols(List<? extends ProtocolConfig> protocols) {
-        ConfigManager.getInstance().addProtocols((List<ProtocolConfig>) protocols);
-        this.protocols = (List<ProtocolConfig>) protocols;
-    }
-
-    public ProtocolConfig getProtocol() {
-        return CollectionUtils.isEmpty(protocols) ? null : protocols.get(0);
-    }
-
-    public void setProtocol(ProtocolConfig protocol) {
-        setProtocols(Arrays.asList(protocol));
-    }
-
-    @Parameter(excluded = true)
-    public String getProtocolIds() {
-        return protocolIds;
-    }
-
-    public void setProtocolIds(String protocolIds) {
-        this.protocolIds = protocolIds;
-    }
-
-    public String getAccesslog() {
-        return accesslog;
-    }
-
-    public void setAccesslog(Boolean accesslog) {
-        if (accesslog == null) {
-            setAccesslog((String) null);
-        } else {
-            setAccesslog(String.valueOf(accesslog));
-        }
-    }
-
-    public void setAccesslog(String accesslog) {
-        this.accesslog = accesslog;
-    }
-
-    public Integer getExecutes() {
-        return executes;
-    }
-
-    public void setExecutes(Integer executes) {
-        this.executes = executes;
-    }
-
-    @Override
-    @Parameter(key = Constants.SERVICE_FILTER_KEY, append = true)
-    public String getFilter() {
-        return super.getFilter();
-    }
-
-    @Override
-    @Parameter(key = Constants.EXPORTER_LISTENER_KEY, append = true)
-    public String getListener() {
-        return listener;
-    }
-
-    @Override
-    public void setListener(String listener) {
-        checkMultiExtension(ExporterListener.class, ""listener"", listener);
-        this.listener = listener;
-    }
-
-    public Boolean isRegister() {
-        return register;
-    }
-
-    public void setRegister(Boolean register) {
-        this.register = register;
-    }
-
-    public Integer getWarmup() {
-        return warmup;
-    }
-
-    public void setWarmup(Integer warmup) {
-        this.warmup = warmup;
-    }
-
-    public String getSerialization() {
-        return serialization;
-    }
-
-    public void setSerialization(String serialization) {
-        this.serialization = serialization;
-    }
-
-    @Parameter(key = Constants.TAG_KEY, useKeyAsProperty = false)
-    public String getTag() {
-        return tag;
-    }
-
-    public void setTag(String tag) {
-        this.tag = tag;
-    }
-}
+/*","[{'comment': 'Why are you changing all the lines? Please avoid changing the style, and keep only minimal necessary changes.', 'commenter': 'ralf0131'}, {'comment': 'This is wired, seems it changed code style automatically.. I will try to fix it!', 'commenter': 'Moriadry-zz'}]"
3869,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProviderConfig.java,"@@ -1,429 +1,430 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.status.StatusChecker;
-import org.apache.dubbo.common.threadpool.ThreadPool;
-import org.apache.dubbo.config.support.Parameter;
-import org.apache.dubbo.remoting.Dispatcher;
-import org.apache.dubbo.remoting.Transporter;
-import org.apache.dubbo.remoting.exchange.Exchanger;
-import org.apache.dubbo.remoting.telnet.TelnetHandler;
-
-import java.util.Arrays;
-
-/**
- * The service provider default configuration
- *
- * @export
- * @see org.apache.dubbo.config.ProtocolConfig
- * @see org.apache.dubbo.config.ServiceConfig
- */
-public class ProviderConfig extends AbstractServiceConfig {
-
-    private static final long serialVersionUID = 6913423882496634749L;
-
-    // ======== protocol default values, it'll take effect when protocol's attributes are not set ========
-
-    /**
-     * Service ip addresses (used when there are multiple network cards available)
-     */
-    private String host;
-
-    /**
-     * Service port
-     */
-    private Integer port;
-
-    /**
-     * Context path
-     */
-    private String contextpath;
-
-    /**
-     * Thread pool
-     */
-    private String threadpool;
-
-    /**
-     * Thread pool size (fixed size)
-     */
-    private Integer threads;
-
-    /**
-     * IO thread pool size (fixed size)
-     */
-    private Integer iothreads;
-
-    /**
-     * Thread pool queue length
-     */
-    private Integer queues;
-
-    /**
-     * Max acceptable connections
-     */
-    private Integer accepts;
-
-    /**
-     * Protocol codec
-     */
-    private String codec;
-
-    /**
-     * The serialization charset
-     */
-    private String charset;
-
-    /**
-     * Payload max length
-     */
-    private Integer payload;
-
-    /**
-     * The network io buffer size
-     */
-    private Integer buffer;
-
-    /**
-     * Transporter
-     */
-    private String transporter;
-
-    /**
-     * How information gets exchanged
-     */
-    private String exchanger;
-
-    /**
-     * Thread dispatching mode
-     */
-    private String dispatcher;
-
-    /**
-     * Networker
-     */
-    private String networker;
-
-    /**
-     * The server-side implementation model of the protocol
-     */
-    private String server;
-
-    /**
-     * The client-side implementation model of the protocol
-     */
-    private String client;
-
-    /**
-     * Supported telnet commands, separated with comma.
-     */
-    private String telnet;
-
-    /**
-     * Command line prompt
-     */
-    private String prompt;
-
-    /**
-     * Status check
-     */
-    private String status;
-
-    /**
-     * Wait time when stop
-     */
-    private Integer wait;
-
-    /**
-     * Whether to use the default protocol
-     */
-    private Boolean isDefault;
-
-    @Deprecated
-    public void setProtocol(String protocol) {
-        this.protocols = Arrays.asList(new ProtocolConfig[]{new ProtocolConfig(protocol)});
-    }
-
-    @Parameter(excluded = true)
-    public Boolean isDefault() {
-        return isDefault;
-    }
-
-    @Deprecated
-    public void setDefault(Boolean isDefault) {
-        this.isDefault = isDefault;
-    }
-
-    @Parameter(excluded = true)
-    public String getHost() {
-        return host;
-    }
-
-    public void setHost(String host) {
-        this.host = host;
-    }
-
-    @Parameter(excluded = true)
-    public Integer getPort() {
-        return port;
-    }
-
-    @Deprecated
-    public void setPort(Integer port) {
-        this.port = port;
-    }
-
-    @Deprecated
-    @Parameter(excluded = true)
-    public String getPath() {
-        return getContextpath();
-    }
-
-    @Deprecated
-    public void setPath(String path) {
-        setContextpath(path);
-    }
-
-    @Parameter(excluded = true)
-    public String getContextpath() {
-        return contextpath;
-    }
-
-    public void setContextpath(String contextpath) {
-        checkPathName(Constants.CONTEXTPATH_KEY, contextpath);
-        this.contextpath = contextpath;
-    }
-
-    public String getThreadpool() {
-        return threadpool;
-    }
-
-    public void setThreadpool(String threadpool) {
-        checkExtension(ThreadPool.class, Constants.THREADPOOL_KEY, threadpool);
-        this.threadpool = threadpool;
-    }
-
-    public Integer getThreads() {
-        return threads;
-    }
-
-    public void setThreads(Integer threads) {
-        this.threads = threads;
-    }
-
-    public Integer getIothreads() {
-        return iothreads;
-    }
-
-    public void setIothreads(Integer iothreads) {
-        this.iothreads = iothreads;
-    }
-
-    public Integer getQueues() {
-        return queues;
-    }
-
-    public void setQueues(Integer queues) {
-        this.queues = queues;
-    }
-
-    public Integer getAccepts() {
-        return accepts;
-    }
-
-    public void setAccepts(Integer accepts) {
-        this.accepts = accepts;
-    }
-
-    public String getCodec() {
-        return codec;
-    }
-
-    public void setCodec(String codec) {
-        this.codec = codec;
-    }
-
-    public String getCharset() {
-        return charset;
-    }
-
-    public void setCharset(String charset) {
-        this.charset = charset;
-    }
-
-    public Integer getPayload() {
-        return payload;
-    }
-
-    public void setPayload(Integer payload) {
-        this.payload = payload;
-    }
-
-    public Integer getBuffer() {
-        return buffer;
-    }
-
-    public void setBuffer(Integer buffer) {
-        this.buffer = buffer;
-    }
-
-    public String getServer() {
-        return server;
-    }
-
-    public void setServer(String server) {
-        this.server = server;
-    }
-
-    public String getClient() {
-        return client;
-    }
-
-    public void setClient(String client) {
-        this.client = client;
-    }
-
-    public String getTelnet() {
-        return telnet;
-    }
-
-    public void setTelnet(String telnet) {
-        checkMultiExtension(TelnetHandler.class, Constants.TELNET, telnet);
-        this.telnet = telnet;
-    }
-
-    @Parameter(escaped = true)
-    public String getPrompt() {
-        return prompt;
-    }
-
-    public void setPrompt(String prompt) {
-        this.prompt = prompt;
-    }
-
-    public String getStatus() {
-        return status;
-    }
-
-    public void setStatus(String status) {
-        checkMultiExtension(StatusChecker.class, Constants.STATUS_KEY, status);
-        this.status = status;
-    }
-
-    @Override
-    public String getCluster() {
-        return super.getCluster();
-    }
-
-    @Override
-    public Integer getConnections() {
-        return super.getConnections();
-    }
-
-    @Override
-    public Integer getTimeout() {
-        return super.getTimeout();
-    }
-
-    @Override
-    public Integer getRetries() {
-        return super.getRetries();
-    }
-
-    @Override
-    public String getLoadbalance() {
-        return super.getLoadbalance();
-    }
-
-    @Override
-    public Boolean isAsync() {
-        return super.isAsync();
-    }
-
-    @Override
-    public Integer getActives() {
-        return super.getActives();
-    }
-
-    public String getTransporter() {
-        return transporter;
-    }
-
-    public void setTransporter(String transporter) {
-        checkExtension(Transporter.class, Constants.TRANSPORTER_KEY, transporter);
-        this.transporter = transporter;
-    }
-
-    public String getExchanger() {
-        return exchanger;
-    }
-
-    public void setExchanger(String exchanger) {
-        checkExtension(Exchanger.class, Constants.EXCHANGER_KEY, exchanger);
-        this.exchanger = exchanger;
-    }
-
-    /**
-     * typo, switch to use {@link #getDispatcher()}
-     *
-     * @deprecated {@link #getDispatcher()}
-     */
-    @Deprecated
-    @Parameter(excluded = true)
-    public String getDispather() {
-        return getDispatcher();
-    }
-
-    /**
-     * typo, switch to use {@link #getDispatcher()}
-     *
-     * @deprecated {@link #setDispatcher(String)}
-     */
-    @Deprecated
-    public void setDispather(String dispather) {
-        setDispatcher(dispather);
-    }
-
-    public String getDispatcher() {
-        return dispatcher;
-    }
-
-    public void setDispatcher(String dispatcher) {
-        checkExtension(Dispatcher.class, Constants.DISPATCHER_KEY, dispatcher);
-        checkExtension(Dispatcher.class, ""dispather"", dispatcher);
-        this.dispatcher = dispatcher;
-    }
-
-    public String getNetworker() {
-        return networker;
-    }
-
-    public void setNetworker(String networker) {
-        this.networker = networker;
-    }
-
-    public Integer getWait() {
-        return wait;
-    }
-
-    public void setWait(Integer wait) {
-        this.wait = wait;
-    }
-
-}
+/*","[{'comment': 'So does this class.', 'commenter': 'ralf0131'}]"
3869,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -1,1001 +1,1001 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.config;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.URLBuilder;
-import org.apache.dubbo.common.Version;
-import org.apache.dubbo.common.bytecode.Wrapper;
-import org.apache.dubbo.common.config.Environment;
-import org.apache.dubbo.common.extension.ExtensionLoader;
-import org.apache.dubbo.common.utils.ClassHelper;
-import org.apache.dubbo.common.utils.CollectionUtils;
-import org.apache.dubbo.common.utils.ConfigUtils;
-import org.apache.dubbo.common.utils.NamedThreadFactory;
-import org.apache.dubbo.common.utils.StringUtils;
-import org.apache.dubbo.config.annotation.Service;
-import org.apache.dubbo.config.context.ConfigManager;
-import org.apache.dubbo.config.invoker.DelegateProviderMetaDataInvoker;
-import org.apache.dubbo.config.support.Parameter;
-import org.apache.dubbo.metadata.integration.MetadataReportService;
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Protocol;
-import org.apache.dubbo.rpc.ProxyFactory;
-import org.apache.dubbo.rpc.cluster.ConfiguratorFactory;
-import org.apache.dubbo.rpc.model.ApplicationModel;
-import org.apache.dubbo.rpc.model.ProviderModel;
-import org.apache.dubbo.rpc.service.GenericService;
-import org.apache.dubbo.rpc.support.ProtocolUtils;
-
-import java.lang.reflect.Method;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.UUID;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
-
-import static org.apache.dubbo.common.Constants.LOCALHOST_VALUE;
-import static org.apache.dubbo.common.utils.NetUtils.getAvailablePort;
-import static org.apache.dubbo.common.utils.NetUtils.getLocalHost;
-import static org.apache.dubbo.common.utils.NetUtils.isInvalidPort;
-
-/**
- * ServiceConfig
- *
- * @export
- */
-public class ServiceConfig<T> extends AbstractServiceConfig {
-
-    private static final long serialVersionUID = 3033787999037024738L;
-
-    /**
-     * The {@link Protocol} implementation with adaptive functionality,it will be different in different scenarios.
-     * A particular {@link Protocol} implementation is determined by the protocol attribute in the {@link URL}.
-     * For example:
-     *
-     * <li>when the url is registry://224.5.6.7:1234/org.apache.dubbo.registry.RegistryService?application=dubbo-sample,
-     * then the protocol is <b>RegistryProtocol</b></li>
-     *
-     * <li>when the url is dubbo://224.5.6.7:1234/org.apache.dubbo.config.api.DemoService?application=dubbo-sample, then
-     * the protocol is <b>DubboProtocol</b></li>
-     * <p>
-     * Actually，when the {@link ExtensionLoader} init the {@link Protocol} instants,it will automatically wraps two
-     * layers, and eventually will get a <b>ProtocolFilterWrapper</b> or <b>ProtocolListenerWrapper</b>
-     */
-    private static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();
-
-    /**
-     * A {@link ProxyFactory} implementation that will generate a exported service proxy,the JavassistProxyFactory is its
-     * default implementation
-     */
-    private static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();
-
-    /**
-     * A random port cache, the different protocols who has no port specified have different random port
-     */
-    private static final Map<String, Integer> RANDOM_PORT_MAP = new HashMap<String, Integer>();
-
-    /**
-     * A delayed exposure service timer
-     */
-    private static final ScheduledExecutorService delayExportExecutor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(""DubboServiceDelayExporter"", true));
-
-    /**
-     * The urls of the services exported
-     */
-    private final List<URL> urls = new ArrayList<URL>();
-
-    /**
-     * The exported services
-     */
-    private final List<Exporter<?>> exporters = new ArrayList<Exporter<?>>();
-
-    /**
-     * The interface name of the exported service
-     */
-    private String interfaceName;
-
-    /**
-     * The interface class of the exported service
-     */
-    private Class<?> interfaceClass;
-
-    /**
-     * The reference of the interface implementation
-     */
-    private T ref;
-
-    /**
-     * The service name
-     */
-    private String path;
-
-    /**
-     * The method configuration
-     */
-    private List<MethodConfig> methods;
-
-    /**
-     * The provider configuration
-     */
-    private ProviderConfig provider;
-
-    /**
-     * The providerIds
-     */
-    private String providerIds;
-
-    /**
-     * Whether the provider has been exported
-     */
-    private transient volatile boolean exported;
-
-    /**
-     * The flag whether a service has unexported ,if the method unexported is invoked, the value is true
-     */
-    private transient volatile boolean unexported;
-
-    /**
-     * whether it is a GenericService
-     */
-    private volatile String generic;
-
-    public ServiceConfig() {
-    }
-
-    public ServiceConfig(Service service) {
-        appendAnnotation(Service.class, service);
-        setMethods(MethodConfig.constructMethodConfig(service.methods()));
-    }
-
-    @Deprecated
-    private static List<ProtocolConfig> convertProviderToProtocol(List<ProviderConfig> providers) {
-        if (CollectionUtils.isEmpty(providers)) {
-            return null;
-        }
-        List<ProtocolConfig> protocols = new ArrayList<ProtocolConfig>(providers.size());
-        for (ProviderConfig provider : providers) {
-            protocols.add(convertProviderToProtocol(provider));
-        }
-        return protocols;
-    }
-
-    @Deprecated
-    private static List<ProviderConfig> convertProtocolToProvider(List<ProtocolConfig> protocols) {
-        if (CollectionUtils.isEmpty(protocols)) {
-            return null;
-        }
-        List<ProviderConfig> providers = new ArrayList<ProviderConfig>(protocols.size());
-        for (ProtocolConfig provider : protocols) {
-            providers.add(convertProtocolToProvider(provider));
-        }
-        return providers;
-    }
-
-    @Deprecated
-    private static ProtocolConfig convertProviderToProtocol(ProviderConfig provider) {
-        ProtocolConfig protocol = new ProtocolConfig();
-        protocol.setName(provider.getProtocol().getName());
-        protocol.setServer(provider.getServer());
-        protocol.setClient(provider.getClient());
-        protocol.setCodec(provider.getCodec());
-        protocol.setHost(provider.getHost());
-        protocol.setPort(provider.getPort());
-        protocol.setPath(provider.getPath());
-        protocol.setPayload(provider.getPayload());
-        protocol.setThreads(provider.getThreads());
-        protocol.setParameters(provider.getParameters());
-        return protocol;
-    }
-
-    @Deprecated
-    private static ProviderConfig convertProtocolToProvider(ProtocolConfig protocol) {
-        ProviderConfig provider = new ProviderConfig();
-        provider.setProtocol(protocol);
-        provider.setServer(protocol.getServer());
-        provider.setClient(protocol.getClient());
-        provider.setCodec(protocol.getCodec());
-        provider.setHost(protocol.getHost());
-        provider.setPort(protocol.getPort());
-        provider.setPath(protocol.getPath());
-        provider.setPayload(protocol.getPayload());
-        provider.setThreads(protocol.getThreads());
-        provider.setParameters(protocol.getParameters());
-        return provider;
-    }
-
-    private static Integer getRandomPort(String protocol) {
-        protocol = protocol.toLowerCase();
-        return RANDOM_PORT_MAP.getOrDefault(protocol, Integer.MIN_VALUE);
-    }
-
-    private static void putRandomPort(String protocol, Integer port) {
-        protocol = protocol.toLowerCase();
-        if (!RANDOM_PORT_MAP.containsKey(protocol)) {
-            RANDOM_PORT_MAP.put(protocol, port);
-            logger.warn(""Use random available port("" + port + "") for protocol "" + protocol);
-        }
-    }
-
-    public URL toUrl() {
-        return urls.isEmpty() ? null : urls.iterator().next();
-    }
-
-    public List<URL> toUrls() {
-        return urls;
-    }
-
-    @Parameter(excluded = true)
-    public boolean isExported() {
-        return exported;
-    }
-
-    @Parameter(excluded = true)
-    public boolean isUnexported() {
-        return unexported;
-    }
-
-    public void checkAndUpdateSubConfigs() {
-        // Use default configs defined explicitly on global configs
-        completeCompoundConfigs();
-        // Config Center should always being started first.
-        startConfigCenter();
-        checkDefault();
-        checkApplication();
-        checkRegistry();
-        checkProtocol();
-        this.refresh();
-        checkMetadataReport();
-
-        if (StringUtils.isEmpty(interfaceName)) {
-            throw new IllegalStateException(""<dubbo:service interface=\""\"" /> interface not allow null!"");
-        }
-
-        if (ref instanceof GenericService) {
-            interfaceClass = GenericService.class;
-            if (StringUtils.isEmpty(generic)) {
-                generic = Boolean.TRUE.toString();
-            }
-        } else {
-            try {
-                interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()
-                        .getContextClassLoader());
-            } catch (ClassNotFoundException e) {
-                throw new IllegalStateException(e.getMessage(), e);
-            }
-            checkInterfaceAndMethods(interfaceClass, methods);
-            checkRef();
-            generic = Boolean.FALSE.toString();
-        }
-        if (local != null) {
-            if (""true"".equals(local)) {
-                local = interfaceName + ""Local"";
-            }
-            Class<?> localClass;
-            try {
-                localClass = ClassHelper.forNameWithThreadContextClassLoader(local);
-            } catch (ClassNotFoundException e) {
-                throw new IllegalStateException(e.getMessage(), e);
-            }
-            if (!interfaceClass.isAssignableFrom(localClass)) {
-                throw new IllegalStateException(""The local implementation class "" + localClass.getName() + "" not implement interface "" + interfaceName);
-            }
-        }
-        if (stub != null) {
-            if (""true"".equals(stub)) {
-                stub = interfaceName + ""Stub"";
-            }
-            Class<?> stubClass;
-            try {
-                stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);
-            } catch (ClassNotFoundException e) {
-                throw new IllegalStateException(e.getMessage(), e);
-            }
-            if (!interfaceClass.isAssignableFrom(stubClass)) {
-                throw new IllegalStateException(""The stub implementation class "" + stubClass.getName() + "" not implement interface "" + interfaceName);
-            }
-        }
-        checkStubAndLocal(interfaceClass);
-        checkMock(interfaceClass);
-    }
-
-    public synchronized void export() {
-        checkAndUpdateSubConfigs();
-
-        if (!shouldExport()) {
-            return;
-        }
-
-        if (shouldDelay()) {
-            delayExportExecutor.schedule(this::doExport, delay, TimeUnit.MILLISECONDS);
-        } else {
-            doExport();
-        }
-    }
-
-    private boolean shouldExport() {
-        Boolean shouldExport = getExport();
-        if (shouldExport == null && provider != null) {
-            shouldExport = provider.getExport();
-        }
-
-        // default value is true
-        if (shouldExport == null) {
-            return true;
-        }
-
-        return shouldExport;
-    }
-
-    private boolean shouldDelay() {
-        Integer delay = getDelay();
-        if (delay == null && provider != null) {
-            delay = provider.getDelay();
-        }
-        return delay != null && delay > 0;
-    }
-
-    protected synchronized void doExport() {
-        if (unexported) {
-            throw new IllegalStateException(""The service "" + interfaceClass.getName() + "" has already unexported!"");
-        }
-        if (exported) {
-            return;
-        }
-        exported = true;
-
-        if (StringUtils.isEmpty(path)) {
-            path = interfaceName;
-        }
-        doExportUrls();
-    }
-
-    private void checkRef() {
-        // reference should not be null, and is the implementation of the given interface
-        if (ref == null) {
-            throw new IllegalStateException(""ref not allow null!"");
-        }
-        if (!interfaceClass.isInstance(ref)) {
-            throw new IllegalStateException(""The class ""
-                    + ref.getClass().getName() + "" unimplemented interface ""
-                    + interfaceClass + ""!"");
-        }
-    }
-
-    public synchronized void unexport() {
-        if (!exported) {
-            return;
-        }
-        if (unexported) {
-            return;
-        }
-        if (!exporters.isEmpty()) {
-            for (Exporter<?> exporter : exporters) {
-                try {
-                    exporter.unexport();
-                } catch (Throwable t) {
-                    logger.warn(""Unexpected error occured when unexport "" + exporter, t);
-                }
-            }
-            exporters.clear();
-        }
-        unexported = true;
-    }
-
-    @SuppressWarnings({""unchecked"", ""rawtypes""})
-    private void doExportUrls() {
-        List<URL> registryURLs = loadRegistries(true);
-        for (ProtocolConfig protocolConfig : protocols) {
-            String pathKey = URL.buildKey(getContextPath(protocolConfig).map(p -> p + ""/"" + path).orElse(path), group, version);
-            ProviderModel providerModel = new ProviderModel(pathKey, ref, interfaceClass);
-            ApplicationModel.initProviderModel(pathKey, providerModel);
-            doExportUrlsFor1Protocol(protocolConfig, registryURLs);
-        }
-    }
-
-    private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {
-        String name = protocolConfig.getName();
-        if (StringUtils.isEmpty(name)) {
-            name = Constants.DUBBO;
-        }
-
-        Map<String, String> map = new HashMap<String, String>();
-        map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);
-
-        appendRuntimeParameters(map);
-        appendParameters(map, metrics);
-        appendParameters(map, application);
-        appendParameters(map, module);
-        appendParameters(map, provider, Constants.DEFAULT_KEY);
-        appendParameters(map, protocolConfig);
-        appendParameters(map, this);
-        if (CollectionUtils.isNotEmpty(methods)) {
-            for (MethodConfig method : methods) {
-                appendParameters(map, method, method.getName());
-                String retryKey = method.getName() + "".retry"";
-                if (map.containsKey(retryKey)) {
-                    String retryValue = map.remove(retryKey);
-                    if (""false"".equals(retryValue)) {
-                        map.put(method.getName() + "".retries"", ""0"");
-                    }
-                }
-                List<ArgumentConfig> arguments = method.getArguments();
-                if (CollectionUtils.isNotEmpty(arguments)) {
-                    for (ArgumentConfig argument : arguments) {
-                        // convert argument type
-                        if (argument.getType() != null && argument.getType().length() > 0) {
-                            Method[] methods = interfaceClass.getMethods();
-                            // visit all methods
-                            if (methods != null && methods.length > 0) {
-                                for (int i = 0; i < methods.length; i++) {
-                                    String methodName = methods[i].getName();
-                                    // target the method, and get its signature
-                                    if (methodName.equals(method.getName())) {
-                                        Class<?>[] argtypes = methods[i].getParameterTypes();
-                                        // one callback in the method
-                                        if (argument.getIndex() != -1) {
-                                            if (argtypes[argument.getIndex()].getName().equals(argument.getType())) {
-                                                appendParameters(map, argument, method.getName() + ""."" + argument.getIndex());
-                                            } else {
-                                                throw new IllegalArgumentException(""Argument config error : the index attribute and type attribute not match :index :"" + argument.getIndex() + "", type:"" + argument.getType());
-                                            }
-                                        } else {
-                                            // multiple callbacks in the method
-                                            for (int j = 0; j < argtypes.length; j++) {
-                                                Class<?> argclazz = argtypes[j];
-                                                if (argclazz.getName().equals(argument.getType())) {
-                                                    appendParameters(map, argument, method.getName() + ""."" + j);
-                                                    if (argument.getIndex() != -1 && argument.getIndex() != j) {
-                                                        throw new IllegalArgumentException(""Argument config error : the index attribute and type attribute not match :index :"" + argument.getIndex() + "", type:"" + argument.getType());
-                                                    }
-                                                }
-                                            }
-                                        }
-                                    }
-                                }
-                            }
-                        } else if (argument.getIndex() != -1) {
-                            appendParameters(map, argument, method.getName() + ""."" + argument.getIndex());
-                        } else {
-                            throw new IllegalArgumentException(""Argument config must set index or type attribute.eg: <dubbo:argument index='0' .../> or <dubbo:argument type=xxx .../>"");
-                        }
-
-                    }
-                }
-            } // end of methods for
-        }
-
-        if (ProtocolUtils.isGeneric(generic)) {
-            map.put(Constants.GENERIC_KEY, generic);
-            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);
-        } else {
-            String revision = Version.getVersion(interfaceClass, version);
-            if (revision != null && revision.length() > 0) {
-                map.put(Constants.REVISION_KEY, revision);
-            }
-
-            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();
-            if (methods.length == 0) {
-                logger.warn(""No method found in service interface "" + interfaceClass.getName());
-                map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);
-            } else {
-                map.put(Constants.METHODS_KEY, StringUtils.join(new HashSet<String>(Arrays.asList(methods)), "",""));
-            }
-        }
-        if (!ConfigUtils.isEmpty(token)) {
-            if (ConfigUtils.isDefault(token)) {
-                map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());
-            } else {
-                map.put(Constants.TOKEN_KEY, token);
-            }
-        }
-        // export service
-        String host = this.findConfigedHosts(protocolConfig, registryURLs, map);
-        Integer port = this.findConfigedPorts(protocolConfig, name, map);
-        URL url = new URL(name, host, port, getContextPath(protocolConfig).map(p -> p + ""/"" + path).orElse(path), map);
-
-        if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
-                .hasExtension(url.getProtocol())) {
-            url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
-                    .getExtension(url.getProtocol()).getConfigurator(url).configure(url);
-        }
-
-        String scope = url.getParameter(Constants.SCOPE_KEY);
-        // don't export when none is configured
-        if (!Constants.SCOPE_NONE.equalsIgnoreCase(scope)) {
-
-            // export to local if the config is not remote (export to remote only when config is remote)
-            if (!Constants.SCOPE_REMOTE.equalsIgnoreCase(scope)) {
-                exportLocal(url);
-            }
-            // export to remote if the config is not local (export to local only when config is local)
-            if (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) {
-                if (logger.isInfoEnabled()) {
-                    logger.info(""Export dubbo service "" + interfaceClass.getName() + "" to url "" + url);
-                }
-                if (CollectionUtils.isNotEmpty(registryURLs)) {
-                    for (URL registryURL : registryURLs) {
-                        url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));
-                        URL monitorUrl = loadMonitor(registryURL);
-                        if (monitorUrl != null) {
-                            url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());
-                        }
-                        if (logger.isInfoEnabled()) {
-                            logger.info(""Register dubbo service "" + interfaceClass.getName() + "" url "" + url + "" to registry "" + registryURL);
-                        }
-
-                        // For providers, this is used to enable custom proxy to generate invoker
-                        String proxy = url.getParameter(Constants.PROXY_KEY);
-                        if (StringUtils.isNotEmpty(proxy)) {
-                            registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);
-                        }
-
-                        Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));
-                        DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
-
-                        Exporter<?> exporter = protocol.export(wrapperInvoker);
-                        exporters.add(exporter);
-                    }
-                } else {
-                    Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);
-                    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
-
-                    Exporter<?> exporter = protocol.export(wrapperInvoker);
-                    exporters.add(exporter);
-                }
-                /**
-                 * @since 2.7.0
-                 * ServiceData Store
-                 */
-                MetadataReportService metadataReportService = null;
-                if ((metadataReportService = getMetadataReportService()) != null) {
-                    metadataReportService.publishProvider(url);
-                }
-            }
-        }
-        this.urls.add(url);
-    }
-
-    @SuppressWarnings({""unchecked"", ""rawtypes""})
-    private void exportLocal(URL url) {
-        if (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {
-            URL local = URLBuilder.from(url)
-                    .setProtocol(Constants.LOCAL_PROTOCOL)
-                    .setHost(LOCALHOST_VALUE)
-                    .setPort(0)
-                    .build();
-            Exporter<?> exporter = protocol.export(
-                    proxyFactory.getInvoker(ref, (Class) interfaceClass, local));
-            exporters.add(exporter);
-            logger.info(""Export dubbo service "" + interfaceClass.getName() + "" to local registry"");
-        }
-    }
-
-    private Optional<String> getContextPath(ProtocolConfig protocolConfig) {
-        String contextPath = protocolConfig.getContextpath();
-        if (StringUtils.isEmpty(contextPath) && provider != null) {
-            contextPath = provider.getContextpath();
-        }
-        return Optional.ofNullable(contextPath);
-    }
-
-    protected Class getServiceClass(T ref) {
-        return ref.getClass();
-    }
-
-    /**
-     * Register & bind IP address for service provider, can be configured separately.
-     * Configuration priority: environment variables -> java system properties -> host property in config file ->
-     * /etc/hosts -> default network address -> first available network address
-     *
-     * @param protocolConfig
-     * @param registryURLs
-     * @param map
-     * @return
-     */
-    private String findConfigedHosts(ProtocolConfig protocolConfig, List<URL> registryURLs, Map<String, String> map) {
-        boolean anyhost = false;
-
-        String hostToBind = getValueFromConfig(protocolConfig, Constants.DUBBO_IP_TO_BIND);
-
-        // if bind ip is not found in environment, keep looking up
-        if (StringUtils.isEmpty(hostToBind)) {
-            hostToBind = protocolConfig.getHost();
-            if (provider != null && StringUtils.isEmpty(hostToBind)) {
-                hostToBind = provider.getHost();
-            }
-
-            if (StringUtils.isEmpty(hostToBind)) {
-                anyhost = true;
-                hostToBind = getLocalHost();
-
-                if (StringUtils.isEmpty(hostToBind)) {
-                    hostToBind = findHostToBindByConnectRegistries(registryURLs);
-                }
-            }
-        }
-
-        map.put(Constants.BIND_IP_KEY, hostToBind);
-
-        // registry ip is not used for bind ip by default
-        String hostToRegistry = getValueFromConfig(protocolConfig, Constants.DUBBO_IP_TO_REGISTRY);
-        if (StringUtils.isEmpty(hostToRegistry)) {
-            // bind ip is used as registry ip by default
-            hostToRegistry = hostToBind;
-        }
-
-        map.put(Constants.ANYHOST_KEY, String.valueOf(anyhost));
-
-        return hostToRegistry;
-    }
-
-    private String findHostToBindByConnectRegistries(List<URL> registryURLs) {
-        if (CollectionUtils.isNotEmpty(registryURLs)) {
-            for (URL registryURL : registryURLs) {
-                if (Constants.MULTICAST.equalsIgnoreCase(registryURL.getParameter(Constants.REGISTRY_KEY))) {
-                    // skip multicast registry since we cannot connect to it via Socket
-                    continue;
-                }
-                try (Socket socket = new Socket()) {
-                    SocketAddress addr = new InetSocketAddress(registryURL.getHost(), registryURL.getPort());
-                    socket.connect(addr, 1000);
-                    return socket.getLocalAddress().getHostAddress();
-                } catch (Exception e) {
-                    logger.warn(e.getMessage(), e);
-                }
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Register port and bind port for the provider, can be configured separately
-     * Configuration priority: environment variable -> java system properties -> port property in protocol config file
-     * -> protocol default port
-     *
-     * @param protocolConfig
-     * @param name
-     * @return
-     */
-    private Integer findConfigedPorts(ProtocolConfig protocolConfig, String name, Map<String, String> map) {
-        Integer portToBind = null;
-
-        // parse bind port from environment
-        String port = getValueFromConfig(protocolConfig, Constants.DUBBO_PORT_TO_BIND);
-        portToBind = parsePort(port);
-
-        // if there's no bind port found from environment, keep looking up.
-        if (portToBind == null) {
-            portToBind = protocolConfig.getPort();
-            if (provider != null && (portToBind == null || portToBind == 0)) {
-                portToBind = provider.getPort();
-            }
-            final int defaultPort = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name).getDefaultPort();
-            if (portToBind == null || portToBind == 0) {
-                portToBind = defaultPort;
-            }
-            if (portToBind == null || portToBind <= 0) {
-                portToBind = getRandomPort(name);
-                if (portToBind == null || portToBind < 0) {
-                    portToBind = getAvailablePort(defaultPort);
-                    putRandomPort(name, portToBind);
-                }
-            }
-        }
-
-        // save bind port, used as url's key later
-        map.put(Constants.BIND_PORT_KEY, String.valueOf(portToBind));
-
-        // registry port, not used as bind port by default
-        String portToRegistryStr = getValueFromConfig(protocolConfig, Constants.DUBBO_PORT_TO_REGISTRY);
-        Integer portToRegistry = parsePort(portToRegistryStr);
-        if (portToRegistry == null) {
-            portToRegistry = portToBind;
-        }
-
-        return portToRegistry;
-    }
-
-    private Integer parsePort(String configPort) {
-        Integer port = null;
-        if (configPort != null && configPort.length() > 0) {
-            try {
-                Integer intPort = Integer.parseInt(configPort);
-                if (isInvalidPort(intPort)) {
-                    throw new IllegalArgumentException(""Specified invalid port from env value:"" + configPort);
-                }
-                port = intPort;
-            } catch (Exception e) {
-                throw new IllegalArgumentException(""Specified invalid port from env value:"" + configPort);
-            }
-        }
-        return port;
-    }
-
-    private String getValueFromConfig(ProtocolConfig protocolConfig, String key) {
-        String protocolPrefix = protocolConfig.getName().toUpperCase() + ""_"";
-        String port = ConfigUtils.getSystemProperty(protocolPrefix + key);
-        if (StringUtils.isEmpty(port)) {
-            port = ConfigUtils.getSystemProperty(key);
-        }
-        return port;
-    }
-
-    private void completeCompoundConfigs() {
-        if (provider != null) {
-            if (application == null) {
-                setApplication(provider.getApplication());
-            }
-            if (module == null) {
-                setModule(provider.getModule());
-            }
-            if (registries == null) {
-                setRegistries(provider.getRegistries());
-            }
-            if (monitor == null) {
-                setMonitor(provider.getMonitor());
-            }
-            if (protocols == null) {
-                setProtocols(provider.getProtocols());
-            }
-            if (configCenter == null) {
-                setConfigCenter(provider.getConfigCenter());
-            }
-        }
-        if (module != null) {
-            if (registries == null) {
-                setRegistries(module.getRegistries());
-            }
-            if (monitor == null) {
-                setMonitor(module.getMonitor());
-            }
-        }
-        if (application != null) {
-            if (registries == null) {
-                setRegistries(application.getRegistries());
-            }
-            if (monitor == null) {
-                setMonitor(application.getMonitor());
-            }
-        }
-    }
-
-    private void checkDefault() {
-        createProviderIfAbsent();
-    }
-
-    private void createProviderIfAbsent() {
-        if (provider != null) {
-            return;
-        }
-        setProvider (
-                ConfigManager.getInstance()
-                        .getDefaultProvider()
-                        .orElseGet(() -> {
-                            ProviderConfig providerConfig = new ProviderConfig();
-                            providerConfig.refresh();
-                            return providerConfig;
-                        })
-        );
-    }
-
-    private void checkProtocol() {
-        if (CollectionUtils.isEmpty(protocols) && provider != null) {
-            setProtocols(provider.getProtocols());
-        }
-        convertProtocolIdsToProtocols();
-    }
-
-    private void convertProtocolIdsToProtocols() {
-        if (StringUtils.isEmpty(protocolIds) && CollectionUtils.isEmpty(protocols)) {
-            List<String> configedProtocols = new ArrayList<>();
-            configedProtocols.addAll(getSubProperties(Environment.getInstance()
-                    .getExternalConfigurationMap(), Constants.PROTOCOLS_SUFFIX));
-            configedProtocols.addAll(getSubProperties(Environment.getInstance()
-                    .getAppExternalConfigurationMap(), Constants.PROTOCOLS_SUFFIX));
-
-            protocolIds = String.join("","", configedProtocols);
-        }
-
-        if (StringUtils.isEmpty(protocolIds)) {
-            if (CollectionUtils.isEmpty(protocols)) {
-               setProtocols(
-                       ConfigManager.getInstance().getDefaultProtocols()
-                        .filter(CollectionUtils::isNotEmpty)
-                        .orElseGet(() -> {
-                            ProtocolConfig protocolConfig = new ProtocolConfig();
-                            protocolConfig.refresh();
-                            return Arrays.asList(protocolConfig);
-                        })
-               );
-            }
-        } else {
-            String[] arr = Constants.COMMA_SPLIT_PATTERN.split(protocolIds);
-            List<ProtocolConfig> tmpProtocols = CollectionUtils.isNotEmpty(protocols) ? protocols : new ArrayList<>();
-            Arrays.stream(arr).forEach(id -> {
-                if (tmpProtocols.stream().noneMatch(prot -> prot.getId().equals(id))) {
-                    tmpProtocols.add(ConfigManager.getInstance().getProtocol(id).orElseGet(() -> {
-                        ProtocolConfig protocolConfig = new ProtocolConfig();
-                        protocolConfig.setId(id);
-                        protocolConfig.refresh();
-                        return protocolConfig;
-                    }));
-                }
-            });
-            if (tmpProtocols.size() > arr.length) {
-                throw new IllegalStateException(""Too much protocols found, the protocols comply to this service are :"" + protocolIds + "" but got "" + protocols
-                        .size() + "" registries!"");
-            }
-            setProtocols(tmpProtocols);
-        }
-    }
-
-    public Class<?> getInterfaceClass() {
-        if (interfaceClass != null) {
-            return interfaceClass;
-        }
-        if (ref instanceof GenericService) {
-            return GenericService.class;
-        }
-        try {
-            if (interfaceName != null && interfaceName.length() > 0) {
-                this.interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()
-                        .getContextClassLoader());
-            }
-        } catch (ClassNotFoundException t) {
-            throw new IllegalStateException(t.getMessage(), t);
-        }
-        return interfaceClass;
-    }
-
-    /**
-     * @param interfaceClass
-     * @see #setInterface(Class)
-     * @deprecated
-     */
-    public void setInterfaceClass(Class<?> interfaceClass) {
-        setInterface(interfaceClass);
-    }
-
-    public String getInterface() {
-        return interfaceName;
-    }
-
-    public void setInterface(Class<?> interfaceClass) {
-        if (interfaceClass != null && !interfaceClass.isInterface()) {
-            throw new IllegalStateException(""The interface class "" + interfaceClass + "" is not a interface!"");
-        }
-        this.interfaceClass = interfaceClass;
-        setInterface(interfaceClass == null ? null : interfaceClass.getName());
-    }
-
-    public void setInterface(String interfaceName) {
-        this.interfaceName = interfaceName;
-        if (StringUtils.isEmpty(id)) {
-            id = interfaceName;
-        }
-    }
-
-    public T getRef() {
-        return ref;
-    }
-
-    public void setRef(T ref) {
-        this.ref = ref;
-    }
-
-    @Parameter(excluded = true)
-    public String getPath() {
-        return path;
-    }
-
-    public void setPath(String path) {
-        checkPathName(Constants.PATH_KEY, path);
-        this.path = path;
-    }
-
-    public List<MethodConfig> getMethods() {
-        return methods;
-    }
-
-    // ======== Deprecated ========
-
-    @SuppressWarnings(""unchecked"")
-    public void setMethods(List<? extends MethodConfig> methods) {
-        this.methods = (List<MethodConfig>) methods;
-    }
-
-    public ProviderConfig getProvider() {
-        return provider;
-    }
-
-    public void setProvider(ProviderConfig provider) {
-        ConfigManager.getInstance().addProvider(provider);
-        this.provider = provider;
-    }
-
-    @Parameter(excluded = true)
-    public String getProviderIds() {
-        return providerIds;
-    }
-
-    public void setProviderIds(String providerIds) {
-        this.providerIds = providerIds;
-    }
-
-    public String getGeneric() {
-        return generic;
-    }
-
-    public void setGeneric(String generic) {
-        if (StringUtils.isEmpty(generic)) {
-            return;
-        }
-        if (ProtocolUtils.isGeneric(generic)) {
-            this.generic = generic;
-        } else {
-            throw new IllegalArgumentException(""Unsupported generic type "" + generic);
-        }
-    }
-
-    @Override
-    public void setMock(Boolean mock) {
-        throw new IllegalArgumentException(""mock doesn't support on provider side"");
-    }
-
-    @Override
-    public void setMock(String mock) {
-        throw new IllegalArgumentException(""mock doesn't support on provider side"");
-    }
-
-    public List<URL> getExportedUrls() {
-        return urls;
-    }
-
-    /**
-     * @deprecated Replace to getProtocols()
-     */
-    @Deprecated
-    public List<ProviderConfig> getProviders() {
-        return convertProtocolToProvider(protocols);
-    }
-
-    /**
-     * @deprecated Replace to setProtocols()
-     */
-    @Deprecated
-    public void setProviders(List<ProviderConfig> providers) {
-        this.protocols = convertProviderToProtocol(providers);
-    }
-
-    @Override
-    @Parameter(excluded = true)
-    public String getPrefix() {
-        return Constants.DUBBO + "".service."" + interfaceName;
-    }
-}
+/*","[{'comment': 'And this.', 'commenter': 'ralf0131'}]"
3869,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ProviderConfig.java,"@@ -157,7 +158,7 @@
 
     @Deprecated
     public void setProtocol(String protocol) {
-        this.protocols = Arrays.asList(new ProtocolConfig[]{new ProtocolConfig(protocol)});
+        this.protocols = new ArrayList<>(Arrays.asList(new ProtocolConfig[]{new ProtocolConfig(protocol)}));","[{'comment': 'This can be simplified as `new ArrayList<>(Arrays.asList(new ProtocolConfig(protocol)))`', 'commenter': 'ralf0131'}]"
3869,dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/url/UrlTestBase.java,"@@ -154,8 +155,8 @@ protected void initServConf() {
         provConf.setRegistry(regConfForProvider);
         servConf.setRegistry(regConfForService);
 
-        provConf.setProtocols(Arrays.asList(new ProtocolConfig[]{protoConfForProvider}));
-        servConf.setProtocols(Arrays.asList(new ProtocolConfig[]{protoConfForService}));
+        provConf.setProtocols(new ArrayList<>(Arrays.asList(new ProtocolConfig[]{protoConfForProvider})));","[{'comment': 'So does this.', 'commenter': 'ralf0131'}]"
3886,dubbo-all/pom.xml,"@@ -254,6 +254,20 @@
             <scope>compile</scope>
             <optional>true</optional>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-registry-nacos</artifactId>","[{'comment': 'This is unnecessary to have. Please sync with the latest branch.', 'commenter': 'ralf0131'}]"
3886,dubbo-all/pom.xml,"@@ -530,6 +544,8 @@
                                     <include>org.apache.dubbo:dubbo-registry-redis</include>
                                     <include>org.apache.dubbo:dubbo-registry-consul</include>
                                     <include>org.apache.dubbo:dubbo-registry-etcd3</include>
+                                    <include>org.apache.dubbo:dubbo-registry-nacos</include>","[{'comment': 'So does this.', 'commenter': 'ralf0131'}]"
3886,dubbo-registry/dubbo-registry-sofa/pom.xml,"@@ -0,0 +1,157 @@
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the ""License""); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+  -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <parent>
+        <groupId>org.apache.dubbo</groupId>
+        <artifactId>dubbo-registry</artifactId>
+        <version>${revision}</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>dubbo-registry-sofa</artifactId>
+    <name>${project.artifactId}</name>
+    <description>The SOFARegistry module of Dubbo project</description>
+
+    <properties>
+        <sofa.registry.version>5.2.0</sofa.registry.version>
+        <jersey.version>2.26</jersey.version>
+        <javax.ws.rs.version>2.1</javax.ws.rs.version>
+    </properties>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-registry-api</artifactId>
+            <version>${project.version}</version>
+            <optional>true</optional>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-common</artifactId>
+            <version>${project.version}</version>
+            <optional>true</optional>
+        </dependency>
+
+        <dependency>
+            <groupId>com.alipay.sofa</groupId>","[{'comment': 'External dependency should go to dubbo-dependency-pom/pom.xml', 'commenter': 'ralf0131'}]"
3886,dubbo-registry/dubbo-registry-sofa/pom.xml,"@@ -0,0 +1,157 @@
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the ""License""); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+  -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <parent>
+        <groupId>org.apache.dubbo</groupId>
+        <artifactId>dubbo-registry</artifactId>
+        <version>${revision}</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>dubbo-registry-sofa</artifactId>
+    <name>${project.artifactId}</name>
+    <description>The SOFARegistry module of Dubbo project</description>
+
+    <properties>
+        <sofa.registry.version>5.2.0</sofa.registry.version>
+        <jersey.version>2.26</jersey.version>
+        <javax.ws.rs.version>2.1</javax.ws.rs.version>
+    </properties>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-registry-api</artifactId>
+            <version>${project.version}</version>
+            <optional>true</optional>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-common</artifactId>
+            <version>${project.version}</version>
+            <optional>true</optional>
+        </dependency>
+
+        <dependency>
+            <groupId>com.alipay.sofa</groupId>
+            <artifactId>registry-client-all</artifactId>
+            <version>${sofa.registry.version}</version>
+            <exclusions>
+                <exclusion>
+                    <groupId>com.alipay.sofa</groupId>
+                    <artifactId>sofa-common-tools</artifactId>
+                </exclusion>
+            </exclusions>
+        </dependency>
+
+        <!-- Test Libraries -->
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-config-api</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
+
+        <!-- test modules -->
+        <dependency>
+            <groupId>com.alipay.sofa</groupId>","[{'comment': 'So does this.', 'commenter': 'ralf0131'}]"
3886,dubbo-registry/dubbo-registry-sofa/src/main/java/org/apache/dubbo/registry/sofa/SofaRegistry.java,"@@ -0,0 +1,293 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.sofa;
+
+import com.alipay.sofa.registry.client.api.RegistryClient;
+import com.alipay.sofa.registry.client.api.RegistryClientConfig;
+import com.alipay.sofa.registry.client.api.Subscriber;
+import com.alipay.sofa.registry.client.api.model.RegistryType;
+import com.alipay.sofa.registry.client.api.model.UserData;
+import com.alipay.sofa.registry.client.api.registration.PublisherRegistration;
+import com.alipay.sofa.registry.client.api.registration.SubscriberRegistration;
+import com.alipay.sofa.registry.client.provider.DefaultRegistryClient;
+import com.alipay.sofa.registry.client.provider.DefaultRegistryClientConfigBuilder;
+import com.alipay.sofa.registry.core.model.ScopeEnum;
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.ConfigUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.registry.NotifyListener;
+import org.apache.dubbo.registry.support.FailbackRegistry;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.registry.sofa.SofaRegistryConstants.ADDRESS_WAIT_TIME_KEY;
+import static org.apache.dubbo.registry.sofa.SofaRegistryConstants.DEFAULT_GROUP;
+import static org.apache.dubbo.registry.sofa.SofaRegistryConstants.LOCAL_DATA_CENTER;
+import static org.apache.dubbo.registry.sofa.SofaRegistryConstants.LOCAL_REGION;
+
+/**
+ * The Sofa registry.
+ *
+ * @author <a href=""mailto:ujjboy@qq.com"">GengZhang</a>","[{'comment': 'Author name should be removed.', 'commenter': 'ralf0131'}]"
3886,dubbo-registry/dubbo-registry-sofa/src/main/java/org/apache/dubbo/registry/sofa/SofaRegistryConstants.java,"@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.sofa;
+
+/**
+ * @author <a href=""mailto:ujjboy@qq.com"">GengZhang</a>","[{'comment': 'Author name should be removed.', 'commenter': 'ralf0131'}]"
3886,dubbo-rpc/dubbo-rpc-thrift/pom.xml,"@@ -69,5 +69,10 @@
             <version>${project.parent.version}</version>
             <scope>test</scope>
         </dependency>
+        <dependency>","[{'comment': 'Why this change is needed?', 'commenter': 'ralf0131'}]"
3886,dubbo-dependencies-bom/pom.xml,"@@ -140,8 +140,9 @@
         <hessian_lite_version>3.2.5</hessian_lite_version>
         <swagger_version>1.5.19</swagger_version>
         <spring_test_version>4.3.16.RELEASE</spring_test_version>
-
+        <junit_version>4.12</junit_version>","[{'comment': 'Now the we use junit5 for unit case ', 'commenter': 'lovepoem'}]"
3886,dubbo-dependencies-bom/pom.xml,"@@ -511,8 +511,26 @@
                 <artifactId>metrics-rest</artifactId>
                 <version>${metrics_version}</version>
             </dependency>
+            
+            <!-- for dubbo-registry-sofa -->
+            <dependency>
+                <groupId>com.alipay.sofa</groupId>
+                <artifactId>registry-client-all</artifactId>
+                <version>${sofa_registry_version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.alipay.sofa</groupId>
+                <artifactId>registry-test</artifactId>
+                <version>${sofa_registry_version}</version>
+                <scope>test</scope>
+            </dependency>
 
             <!-- Test lib -->
+            <dependency>","[{'comment': 'Now the we use junit5 for unit case, please remove it ', 'commenter': 'lovepoem'}]"
3886,dubbo-registry/dubbo-registry-sofa/src/test/java/org/apache/dubbo/registry/sofa/SofaRegistryTest.java,"@@ -0,0 +1,148 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.sofa;
+
+import com.alipay.sofa.registry.server.test.TestRegistryMain;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.config.ApplicationConfig;
+import org.apache.dubbo.config.ProtocolConfig;
+import org.apache.dubbo.config.ReferenceConfig;
+import org.apache.dubbo.config.RegistryConfig;
+import org.apache.dubbo.config.ServiceConfig;
+import org.junit.AfterClass;","[{'comment': 'Please use junit5', 'commenter': 'lovepoem'}]"
3886,dubbo-config/dubbo-config-spring/pom.xml,"@@ -120,7 +120,6 @@
         <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
-            <version>4.12</version>","[{'comment': ""Now spring module still use `<version>4.12</version>` , it's a special usage . Please retain it "", 'commenter': 'lovepoem'}]"
3887,dubbo-configcenter/dubbo-configcenter-etcd/src/test/java/org/apache/dubbo/configcenter/support/etcd/EtcdDynamicConfigurationTest.java,"@@ -19,17 +19,17 @@
 
 import io.etcd.jetcd.ByteSequence;
 import io.etcd.jetcd.Client;
+import io.etcd.jetcd.launcher.EtcdCluster;
+import io.etcd.jetcd.launcher.EtcdClusterFactory;
 import org.apache.dubbo.common.Constants;
 import org.apache.dubbo.common.URL;
 import org.apache.dubbo.configcenter.ConfigChangeEvent;
 import org.apache.dubbo.configcenter.ConfigurationListener;
-import org.junit.jupiter.api.AfterAll;
-import org.junit.jupiter.api.Assertions;
-import org.junit.jupiter.api.BeforeAll;
-import org.junit.jupiter.api.Disabled;
-import org.junit.jupiter.api.Test;
+import org.junit.*;","[{'comment': ""It is not suggest to use `import *`. I'd like to keep them."", 'commenter': 'ralf0131'}]"
3887,dubbo-dependencies-bom/pom.xml,"@@ -478,6 +480,18 @@
                 <version>${activation_version}</version>
             </dependency>
 
+            <!-- for dubbo-configcenter-etcd -->","[{'comment': 'It is better to put all the modules to the `Test lib`. This make is clear that these are just for testing purpose.', 'commenter': 'ralf0131'}, {'comment': 'sorry, so where it should be? I found embedded-redis for test also placed in this dependencies-bom xml, and found no where else to put this dependency.', 'commenter': 'Moriadry-zz'}, {'comment': 'oh, I just got your idea!', 'commenter': 'Moriadry-zz'}]"
3888,dubbo-metadata-report/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java,"@@ -37,7 +38,7 @@
 
     public RedisMetadataReport(URL url) {
         super(url);
-        pool = new JedisPool(new JedisPoolConfig(), url.getHost(), url.getPort());
+        pool = new JedisPool(new JedisPoolConfig(), url.getHost(), url.getPort(), Protocol.DEFAULT_TIMEOUT, url.getPassword());","[{'comment': 'You can use `url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT)`. Get the timeout from url, if not present, use the default value.', 'commenter': 'ralf0131'}, {'comment': 'Right.', 'commenter': 'tomatofrommars'}]"
3906,dubbo-registry/dubbo-registry-consul/pom.xml,"@@ -36,6 +36,12 @@
             <groupId>com.ecwid.consul</groupId>
             <artifactId>consul-api</artifactId>
         </dependency>
+        <dependency>
+            <groupId>com.pszymczyk.consul</groupId>
+            <artifactId>embedded-consul</artifactId>
+            <version>1.1.0</version>","[{'comment': ""You've specified 2.0.0 in dubbo-dependencies-bom/pom.xml, why it is 1.1.0 here?"", 'commenter': 'ralf0131'}, {'comment': 'sorry for the mistake, I will fix this.', 'commenter': 'Moriadry-zz'}]"
3906,dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java,"@@ -154,6 +156,24 @@ public void doUnsubscribe(URL url, NotifyListener listener) {
         notifier.stop();
     }
 
+    @Override","[{'comment': 'What is the purpose of the change? I could not find any explanation in your pr description. ', 'commenter': 'ralf0131'}, {'comment': 'If we use lookUp method from parent class: AbstractRegistry, we cannot get our immediate provider list. I choose to implement this method like what we do in https://github.com/apache/incubator-dubbo/blob/9ce0676908adbb5d073727c47b5a32dda153230e/dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java#L195 to keep our public method  with consistent meaning. And you can check it in ConsulRegistryTest.testLookup()', 'commenter': 'Moriadry-zz'}]"
3906,dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java,"@@ -154,6 +156,24 @@ public void doUnsubscribe(URL url, NotifyListener listener) {
         notifier.stop();
     }
 
+    @Override
+    public List<URL> lookup(URL url) {
+        if (url == null) {
+            throw new IllegalArgumentException(""lookup url == null"");
+        }
+        try {
+            String service = url.getServiceKey();
+            Response<List<HealthService>> result = client.getHealthServices(service, HealthServicesRequest.newBuilder().setTag(SERVICE_TAG).build());","[{'comment': 'is it possible to reuse **getHealthServices(java.lang.String, long, int)**?', 'commenter': 'beiwei30'}, {'comment': 'It seems the tcp check never work correctly in consulRegistry. Is there a must that we use tcp check, instead of a http ttl check? I used ttl check, with onlyPass=true, then things went correct.', 'commenter': 'Moriadry-zz'}, {'comment': ""with this tcp Check  configuration,  client.getHealthService shows the check is critical. And is there really a greater performance with tcp check? I don't find it in consul performance benchmark, What's your opinion sir.  I can try to complete this tcp check, if you think is a must."", 'commenter': 'Moriadry-zz'}, {'comment': 'tcp check does work on my side. Using TCP check instead of others does have performance consideration in it.', 'commenter': 'beiwei30'}, {'comment': 'one more question, why this change is related to TCP check (I guess you mean health check by TCP, am I right?)', 'commenter': 'beiwei30'}, {'comment': 'yes, consul health check by TCP.  After we register consul service with tcp check, we cannot get  a passing=true HealthService response every time, even if Thread.sleep a few seconds. the ConsulRegistryTest.class now does not involve this logic actually.', 'commenter': 'Moriadry-zz'}, {'comment': 'I will spend more time on this :)', 'commenter': 'Moriadry-zz'}, {'comment': 'could u pls check this code(which is implement by me):  https://github.com/baidu/brpc-java/blob/97e6d71d8b83b061384afa9d139a2dc5da841451/brpc-java-naming-consul/src/main/java/com/baidu/brpc/naming/consul/ConsulNamingService.java#L126\r\n\r\nI believe we need to explicitly healthCheckPass the Check(by checkId) either. Then we can correctly getHealthServices(java.lang.String, long, int) by params: onlyPassing = true', 'commenter': 'Moriadry-zz'}, {'comment': ""my first version does use **agentCheckPass** instead of **setTcp**.  Not sure why TCP check doesn't work perfectly on your side, would you mind share me your demo app so that I could reproduce. \r\n\r\nIf you believe **agentCheckPass** is more robust, would you mind add it back? You could refer my original change: https://github.com/beiwei30/incubator-dubbo/commit/2f828965339176ef76ddb3b91fb74c90d3f3f051 and enhance it. Luckily I didn't delete it from my repo :)"", 'commenter': 'beiwei30'}, {'comment': '@Moriadry should I merge this pull request first? then you can submit another pull request to follow up with https://github.com/beiwei30/incubator-dubbo/commit/2f828965339176ef76ddb3b91fb74c90d3f3f051. What do you think?', 'commenter': 'beiwei30'}, {'comment': 'ok, you can merge this, another pr will be provided soon.', 'commenter': 'Moriadry-zz'}, {'comment': ""sure. I will merge it. Thanks for following up. I will add a new samples for consul to test consul TCP check, will ping you once it's ready."", 'commenter': 'beiwei30'}]"
3906,dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulRegistry.java,"@@ -154,6 +156,24 @@ public void doUnsubscribe(URL url, NotifyListener listener) {
         notifier.stop();
     }
 
+    @Override
+    public List<URL> lookup(URL url) {
+        if (url == null) {
+            throw new IllegalArgumentException(""lookup url == null"");
+        }
+        try {
+            String service = url.getServiceKey();
+            Response<List<HealthService>> result = client.getHealthServices(service, HealthServicesRequest.newBuilder().setTag(SERVICE_TAG).build());
+            if (result == null || result.getValue() == null || result.getValue().isEmpty()) {
+                return new ArrayList<>();","[{'comment': 'pls. consider to return Collections.emptyList()', 'commenter': 'beiwei30'}, {'comment': 'yes, will change this line.', 'commenter': 'Moriadry-zz'}]"
3966,dubbo-all/pom.xml,"@@ -331,6 +338,13 @@
             <scope>compile</scope>
             <optional>true</optional>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-serialization-native-hession</artifactId>
+            <version>${project.version}</version>
+            <scope>compile</scope>
+            <optional>true</optional>
+        </dependency>
         <dependency>
             <groupId>org.apache.dubbo</groupId>
             <artifactId>dubbo-serialization-jdk</artifactId>","[{'comment': 'you forgot this:\r\n\r\n```xml\r\n<include>org.apache.dubbo:dubbo-rpc-native-thrift</include>\r\n<include>org.apache.dubbo:dubbo-serialization-native-hession</include>\r\n```', 'commenter': 'beiwei30'}]"
3966,dubbo-all/pom.xml,"@@ -184,6 +184,13 @@
             <scope>compile</scope>
             <optional>true</optional>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-rpc-native-thrift</artifactId>","[{'comment': ""should we simply replace this into 'dubbo-rpc-thrift'?"", 'commenter': 'beiwei30'}]"
3966,dubbo-distribution/pom.xml,"@@ -140,6 +140,11 @@
             <artifactId>dubbo-rpc-thrift</artifactId>
             <version>${project.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-rpc-native-thrift</artifactId>
+            <version>${project.version}</version>
+        </dependency>","[{'comment': ""no 'dubbo-serialization-native-hession'?"", 'commenter': 'beiwei30'}, {'comment': 'Both are inside', 'commenter': 'Leishunyu'}]"
3966,dubbo-dependencies-bom/pom.xml,"@@ -106,7 +106,7 @@
         <consul_process_version>2.0.0</consul_process_version>
         <xmemcached_version>1.3.6</xmemcached_version>
         <cxf_version>3.1.15</cxf_version>
-        <thrift_version>0.8.0</thrift_version>
+        <thrift_version>0.11.0</thrift_version>","[{'comment': 'pls. use the latest version. this version has security issue.', 'commenter': 'beiwei30'}]"
3966,dubbo-all/pom.xml,"@@ -450,13 +457,6 @@
             <scope>compile</scope>
             <optional>true</optional>
         </dependency>
-        <dependency>
-            <groupId>org.apache.dubbo</groupId>
-            <artifactId>dubbo-metadata-report-etcd</artifactId>","[{'comment': 'should not remove this.', 'commenter': 'beiwei30'}, {'comment': 'get', 'commenter': 'Leishunyu'}]"
3966,dubbo-rpc/dubbo-rpc-thrift/pom.xml,"@@ -52,6 +52,7 @@
         <dependency>
             <groupId>org.apache.thrift</groupId>
             <artifactId>libthrift</artifactId>
+            <version>0.8.0</version>","[{'comment': 'should not include thrift.', 'commenter': 'beiwei30'}, {'comment': 'ok, i remove it', 'commenter': 'Leishunyu'}]"
3967,dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java,"@@ -875,4 +875,18 @@
     public static final String METRICS_PROTOCOL = ""metrics.protocol"";
 
 
+    /**
+     * Serizlization ContentTypeId
+     */
+    public static final byte AVRO_SERIALIZATION_ID = 1;","[{'comment': 'this is wrong, avro is 10...', 'commenter': 'beiwei30'}, {'comment': '*public static final byte AVRO_SERIALIZATION_ID = 11* should be better', 'commenter': 'beiwei30'}, {'comment': '> _public static final byte AVRO_SERIALIZATION_ID = 11_ should be better\r\n\r\nWhat are the uses of 1 and 5 here?', 'commenter': 'CrazyHZM'}, {'comment': ""let's simply leave it as is. I believe the original intention is: 1, 2, 4, 8, 16..."", 'commenter': 'beiwei30'}, {'comment': 'I have modified it.', 'commenter': 'CrazyHZM'}]"
3967,dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java,"@@ -875,4 +875,18 @@
     public static final String METRICS_PROTOCOL = ""metrics.protocol"";
 
 
+    /**
+     * Serizlization ContentTypeId
+     */
+    public static final byte HESSIAN2_SERIALIZATION_ID = 2;
+    public static final byte JAVA_SERIALIZATION_ID = 3;
+    public static final byte COMPACTED_JAVA_SERIALIZATION_ID = 4;
+    public static final byte FASTJSON_SERIALIZATION_ID = 6;
+    public static final byte NATIVE_JAVA_SERIALIZATION_ID = 7;
+    public static final byte KRYO_SERIALIZATION_ID = 8;
+    public static final byte FST_SERIALIZATION_ID = 9;
+    public static final byte PROTOSTUFF_SERIALIZATION_ID = 10;
+    public static final byte AVRO_SERIALIZATION_ID = 11;
+    public static final byte GSON_SERIALIZATION_ID = 16;
+","[{'comment': 'Maybe you can define a sub-constant class. What do you think?', 'commenter': 'cvictory'}, {'comment': '+1 for a specific constants class', 'commenter': 'kun-song'}, {'comment': 'I think this suggestion is good, I will modify it later.', 'commenter': 'CrazyHZM'}]"
3975,dubbo-all/pom.xml,"@@ -387,6 +387,13 @@
             <scope>compile</scope>
             <optional>true</optional>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-serialization-googlePb</artifactId>","[{'comment': ""let's call it 'dubbo-serialization-protobuf-json'"", 'commenter': 'beiwei30'}, {'comment': 'done.', 'commenter': 'vio-lin'}]"
3975,dubbo-bom/pom.xml,"@@ -342,6 +342,11 @@
                 <artifactId>dubbo-serialization-gson</artifactId>
                 <version>${project.version}</version>
             </dependency>
+            <dependency>
+                <groupId>org.apache.dubbo</groupId>
+                <artifactId>dubbo-serialization-googlePb</artifactId>","[{'comment': ""rename to 'dubbo-serialization-protobuf-json'"", 'commenter': 'beiwei30'}, {'comment': 'OK', 'commenter': 'vio-lin'}]"
3975,dubbo-common/src/main/java/org/apache/dubbo/common/Constants.java,"@@ -727,6 +727,8 @@
 
     public static final String GENERIC_SERIALIZATION_BEAN = ""bean"";
 
+    public static final String GENERIC_SERIALIZATION_PROTOBUF = ""gernericprotobuf"";","[{'comment': ""rename to 'protobuf-json'"", 'commenter': 'beiwei30'}, {'comment': 'OK', 'commenter': 'vio-lin'}]"
3975,dubbo-dependencies-bom/pom.xml,"@@ -108,6 +108,8 @@
         <cxf_version>3.1.15</cxf_version>
         <thrift_version>0.12.0</thrift_version>
         <hessian_version>4.0.38</hessian_version>
+        <protobuf-java>3.6.0</protobuf-java>","[{'comment': ""simply use one property for both protobuf-java and protobuf-java-util, and name it 'protobuf-java_version'"", 'commenter': 'beiwei30'}, {'comment': 'OK\r\n', 'commenter': 'vio-lin'}]"
3975,dubbo-distribution/pom.xml,"@@ -335,6 +335,11 @@
             <artifactId>dubbo-serialization-gson</artifactId>
             <version>${project.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-serialization-googlePb</artifactId>","[{'comment': ""rename to 'dubbo-serialization-protobuf-json'"", 'commenter': 'beiwei30'}]"
3975,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java,"@@ -107,6 +107,22 @@ public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
                                             args[i].getClass().getName());
                         }
                     }
+                } else if (ProtocolUtils.isProtobufGenericSerialization(generic)) {","[{'comment': ""make sure line width doesn't exceed 120 columns."", 'commenter': 'beiwei30'}]"
3975,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java,"@@ -107,6 +107,22 @@ public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
                                             args[i].getClass().getName());
                         }
                     }
+                } else if (ProtocolUtils.isProtobufGenericSerialization(generic)) {
+                    // as proto3 only accept one protobuf parameter
+                    if (args.length == 1 && args[0] instanceof String) {
+                        try (UnsafeByteArrayInputStream is = new UnsafeByteArrayInputStream(((String) args[0]).getBytes())) {
+                            args[0] = ExtensionLoader.getExtensionLoader(Serialization.class)
+                                    .getExtension("""" + Constants.GENERIC_SERIALIZATION_PROTOBUF)
+                                    .deserialize(null, is).readObject(method.getParameterTypes()[0]);
+                        } catch (Exception e) {
+                            throw new RpcException(""Deserialize argument failed."", e);
+                        }
+                    } else {
+                        throw new RpcException(
+                                new StringBuilder(""Generic serialization ["").append(Constants.GENERIC_SERIALIZATION_PROTOBUF)","[{'comment': 'no necessary to use StringBuilder I think.', 'commenter': 'beiwei30'}, {'comment': 'Done .  Use ""string"" + ""string""  ', 'commenter': 'vio-lin'}]"
3975,dubbo-serialization/dubbo-serialization-googlePb/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.common.serialize.Serialization,"@@ -0,0 +1 @@
+gernericprotobuf=org.apache.dubbo.common.serialize.protobuf.support.GenericProtobufSerialization","[{'comment': ""use 'protobuf-json'"", 'commenter': 'beiwei30'}, {'comment': 'Done', 'commenter': 'vio-lin'}]"
3977,dubbo-rpc/dubbo-rpc-native-thrift/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.rpc.Protocol,"@@ -0,0 +1 @@
+nthrift=org.apache.dubbo.rpc.protocol.nativethrift.ThriftProtocol","[{'comment': 'should **native-thrift** better?', 'commenter': 'beiwei30'}, {'comment': '👍  i do it', 'commenter': 'Leishunyu'}]"
3977,dubbo-test/pom.xml,"@@ -126,6 +126,10 @@
             <groupId>org.apache.dubbo</groupId>
             <artifactId>dubbo-rpc-thrift</artifactId>
         </dependency>
+        <dependency>","[{'comment': 'why do we need this?', 'commenter': 'beiwei30'}, {'comment': 'no,i remove it', 'commenter': 'Leishunyu'}]"
3977,dubbo-compatible/pom.xml,"@@ -62,11 +62,26 @@
             <artifactId>dubbo-rpc-rest</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-rpc-dubbo</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-remoting-netty4</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
         <dependency>
             <groupId>org.apache.dubbo</groupId>
             <artifactId>dubbo-rpc-thrift</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
+        <dependency>","[{'comment': 'why do we need this?', 'commenter': 'beiwei30'}, {'comment': 'no,i remove it\r\n\r\n', 'commenter': 'Leishunyu'}]"
3988,dubbo-configcenter/dubbo-configcenter-nacos/pom.xml,"@@ -0,0 +1,61 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <parent>
+        <artifactId>dubbo-configcenter</artifactId>
+        <groupId>org.apache.dubbo</groupId>
+        <version>${revision}</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>dubbo-configcenter-nacos</artifactId>
+    <packaging>jar</packaging>
+    <name>${project.artifactId}</name>
+    <description>The nacos implementation of the config-center api</description>
+
+    <properties>
+        <nacos.version>1.0.0-RC3</nacos.version>","[{'comment': 'This is unnecessary. The nacos version has been defined in dubbo-dependencies-bom/pom.xml.', 'commenter': 'ralf0131'}]"
3988,dubbo-configcenter/dubbo-configcenter-nacos/pom.xml,"@@ -0,0 +1,61 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <parent>
+        <artifactId>dubbo-configcenter</artifactId>
+        <groupId>org.apache.dubbo</groupId>
+        <version>${revision}</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>dubbo-configcenter-nacos</artifactId>
+    <packaging>jar</packaging>
+    <name>${project.artifactId}</name>
+    <description>The nacos implementation of the config-center api</description>
+
+    <properties>
+        <nacos.version>1.0.0-RC3</nacos.version>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-configcenter-api</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.alibaba.nacos</groupId>
+            <artifactId>nacos-client</artifactId>
+            <version>${nacos.version}</version>","[{'comment': 'This line can be removed.', 'commenter': 'ralf0131'}]"
3988,dubbo-configcenter/dubbo-configcenter-nacos/pom.xml,"@@ -0,0 +1,61 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <parent>
+        <artifactId>dubbo-configcenter</artifactId>
+        <groupId>org.apache.dubbo</groupId>
+        <version>${revision}</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>dubbo-configcenter-nacos</artifactId>
+    <packaging>jar</packaging>
+    <name>${project.artifactId}</name>
+    <description>The nacos implementation of the config-center api</description>
+
+    <properties>
+        <nacos.version>1.0.0-RC3</nacos.version>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-configcenter-api</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.alibaba.nacos</groupId>
+            <artifactId>nacos-client</artifactId>
+            <version>${nacos.version}</version>
+            <optional>true</optional>
+        </dependency>
+        <dependency>
+            <groupId>org.testcontainers</groupId>
+            <artifactId>testcontainers</artifactId>","[{'comment': 'Why do we need testcontainers?', 'commenter': 'ralf0131'}]"
3988,dubbo-configcenter/dubbo-configcenter-nacos/pom.xml,"@@ -0,0 +1,61 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <parent>
+        <artifactId>dubbo-configcenter</artifactId>
+        <groupId>org.apache.dubbo</groupId>
+        <version>${revision}</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>dubbo-configcenter-nacos</artifactId>
+    <packaging>jar</packaging>
+    <name>${project.artifactId}</name>
+    <description>The nacos implementation of the config-center api</description>
+
+    <properties>
+        <nacos.version>1.0.0-RC3</nacos.version>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-configcenter-api</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.alibaba.nacos</groupId>
+            <artifactId>nacos-client</artifactId>
+            <version>${nacos.version}</version>
+            <optional>true</optional>
+        </dependency>
+        <dependency>
+            <groupId>org.testcontainers</groupId>
+            <artifactId>testcontainers</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-remoting-etcd3</artifactId>","[{'comment': 'This is apparently unnecessary.', 'commenter': 'ralf0131'}]"
3988,dubbo-configcenter/dubbo-configcenter-nacos/src/main/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfiguration.java,"@@ -0,0 +1,253 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.configcenter.support.nacos;
+
+import com.alibaba.nacos.api.NacosFactory;
+import com.alibaba.nacos.api.config.ConfigService;
+import com.alibaba.nacos.api.config.listener.AbstractSharedListener;
+import com.alibaba.nacos.api.exception.NacosException;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.configcenter.ConfigChangeEvent;
+import org.apache.dubbo.configcenter.ConfigChangeType;
+import org.apache.dubbo.configcenter.ConfigurationListener;
+import org.apache.dubbo.configcenter.DynamicConfiguration;
+
+import java.util.Map;
+import java.util.Properties;
+import java.util.Set;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArraySet;
+import static com.alibaba.nacos.api.PropertyKeyConst.ACCESS_KEY;
+import static com.alibaba.nacos.api.PropertyKeyConst.CLUSTER_NAME;
+import static com.alibaba.nacos.api.PropertyKeyConst.ENDPOINT;
+import static com.alibaba.nacos.api.PropertyKeyConst.SECRET_KEY;
+import static com.alibaba.nacos.api.PropertyKeyConst.SERVER_ADDR;
+import static com.alibaba.nacos.api.PropertyKeyConst.NAMESPACE;
+import static com.alibaba.nacos.client.naming.utils.UtilAndComs.NACOS_NAMING_LOG_NAME;
+import static org.apache.dubbo.common.Constants.BACKUP_KEY;
+import static org.apache.dubbo.common.Constants.CONFIG_NAMESPACE_KEY;
+import static org.apache.dubbo.common.Constants.GROUP_CHAR_SEPERATOR;
+import static org.apache.dubbo.common.Constants.PROPERTIES_CHAR_SEPERATOR;
+
+/**
+ * The nacos implementation of {@link DynamicConfiguration}
+ */
+public class NacosDynamicConfiguration implements DynamicConfiguration {
+
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+
+    /**
+     * The final root path would be: /$NAME_SPACE/config
+     */
+    private String rootPath;
+
+    /**
+     * The nacos configService
+     */
+
+    private ConfigService configService;
+
+    /**
+     * The map store the key to {@link NacosConfigListener} mapping
+     */
+    private final ConcurrentMap<String, NacosConfigListener> watchListenerMap;
+
+    NacosDynamicConfiguration(URL url) {
+        rootPath = url.getParameter(CONFIG_NAMESPACE_KEY, DEFAULT_GROUP) + ""-config"";
+        buildConfigService(url);
+        watchListenerMap = new ConcurrentHashMap<>();
+    }
+
+    private ConfigService buildConfigService(URL url) {
+        Properties nacosProperties = buildNacosProperties(url);
+        try {
+            configService = NacosFactory.createConfigService(nacosProperties);
+        } catch (NacosException e) {
+            if (logger.isErrorEnabled()) {
+                logger.error(e.getErrMsg(), e);
+            }
+            throw new IllegalStateException(e);
+        }
+        return configService;
+    }
+
+    public void publishNacosConfig(String key, String value) {
+        try {
+            String[] keyAndGroup = getKeyAndGroup(key);
+            configService.publishConfig(keyAndGroup[0], keyAndGroup[1], value);
+        } catch (NacosException e) {
+            logger.error(e.getErrMsg());
+        }
+    }
+
+    private String[] getKeyAndGroup(String key) {
+        int i = key.lastIndexOf(GROUP_CHAR_SEPERATOR);
+        if (i < 0) {
+            return new String[]{key, null};
+        } else {
+            return new String[]{key.substring(0, i), key.substring(i+1)};
+        }
+    }
+
+    private Properties buildNacosProperties(URL url) {
+        Properties properties = new Properties();
+        setServerAddr(url, properties);
+        setProperties(url, properties);
+        return properties;
+    }
+
+    private void setServerAddr(URL url, Properties properties) {
+        StringBuilder serverAddrBuilder =
+                new StringBuilder(url.getHost()) // Host
+                        .append("":"")
+                        .append(url.getPort()); // Port
+
+        // Append backup parameter as other servers
+        String backup = url.getParameter(BACKUP_KEY);
+        if (backup != null) {
+            serverAddrBuilder.append("","").append(backup);
+        }
+        String serverAddr = serverAddrBuilder.toString();
+        properties.put(SERVER_ADDR, serverAddr);
+    }
+
+    private void setProperties(URL url, Properties properties) {
+        putPropertyIfAbsent(url, properties, NAMESPACE);
+        putPropertyIfAbsent(url, properties, NACOS_NAMING_LOG_NAME);
+        putPropertyIfAbsent(url, properties, ENDPOINT);
+        putPropertyIfAbsent(url, properties, ACCESS_KEY);
+        putPropertyIfAbsent(url, properties, SECRET_KEY);
+        putPropertyIfAbsent(url, properties, CLUSTER_NAME);
+    }
+
+    private void putPropertyIfAbsent(URL url, Properties properties, String propertyName) {
+        String propertyValue = url.getParameter(propertyName);
+        if (StringUtils.isNotEmpty(propertyValue)) {
+            properties.setProperty(propertyName, propertyValue);
+        }
+    }
+
+    /**
+     * Ignores the group parameter.
+     *
+     * @param key   property key the native listener will listen on
+     * @param group to distinguish different set of properties
+     * @return
+     */
+    private NacosConfigListener createTargetListener(String key, String group) {","[{'comment': 'The input parameters are never used. Is it necessary to keep it?', 'commenter': 'ralf0131'}]"
3988,dubbo-configcenter/dubbo-configcenter-nacos/pom.xml,"@@ -0,0 +1,61 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <parent>
+        <artifactId>dubbo-configcenter</artifactId>
+        <groupId>org.apache.dubbo</groupId>
+        <version>${revision}</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>dubbo-configcenter-nacos</artifactId>
+    <packaging>jar</packaging>
+    <name>${project.artifactId}</name>
+    <description>The nacos implementation of the config-center api</description>
+
+    <properties>
+        <nacos.version>1.0.0-RC3</nacos.version>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-configcenter-api</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.alibaba.nacos</groupId>
+            <artifactId>nacos-client</artifactId>
+            <version>${nacos.version}</version>
+            <optional>true</optional>","[{'comment': 'The nacos-client dependency should not be optional.', 'commenter': 'ralf0131'}]"
3988,dubbo-configcenter/dubbo-configcenter-nacos/src/main/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfiguration.java,"@@ -0,0 +1,255 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.configcenter.support.nacos;
+
+import com.alibaba.nacos.api.NacosFactory;
+import com.alibaba.nacos.api.config.ConfigService;
+import com.alibaba.nacos.api.config.listener.AbstractSharedListener;
+import com.alibaba.nacos.api.exception.NacosException;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.configcenter.ConfigChangeEvent;
+import org.apache.dubbo.configcenter.ConfigChangeType;
+import org.apache.dubbo.configcenter.ConfigurationListener;
+import org.apache.dubbo.configcenter.DynamicConfiguration;
+
+import java.util.Map;
+import java.util.Properties;
+import java.util.Set;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArraySet;
+import static com.alibaba.nacos.api.PropertyKeyConst.ACCESS_KEY;
+import static com.alibaba.nacos.api.PropertyKeyConst.CLUSTER_NAME;
+import static com.alibaba.nacos.api.PropertyKeyConst.ENDPOINT;
+import static com.alibaba.nacos.api.PropertyKeyConst.SECRET_KEY;
+import static com.alibaba.nacos.api.PropertyKeyConst.SERVER_ADDR;
+import static com.alibaba.nacos.api.PropertyKeyConst.NAMESPACE;
+import static com.alibaba.nacos.client.naming.utils.UtilAndComs.NACOS_NAMING_LOG_NAME;
+import static org.apache.dubbo.common.Constants.BACKUP_KEY;
+import static org.apache.dubbo.common.Constants.CONFIG_NAMESPACE_KEY;
+import static org.apache.dubbo.common.Constants.GROUP_CHAR_SEPERATOR;
+import static org.apache.dubbo.common.Constants.PROPERTIES_CHAR_SEPERATOR;
+
+/**
+ * The nacos implementation of {@link DynamicConfiguration}
+ */
+public class NacosDynamicConfiguration implements DynamicConfiguration {
+
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+
+    /**
+     * The final root path would be: /$NAME_SPACE/config
+     */
+    private String rootPath;
+
+    /**
+     * The nacos configService
+     */
+
+    private ConfigService configService;
+
+    /**
+     * The map store the key to {@link NacosConfigListener} mapping
+     */
+    private final ConcurrentMap<String, NacosConfigListener> watchListenerMap;
+
+    NacosDynamicConfiguration(URL url) {
+        rootPath = url.getParameter(CONFIG_NAMESPACE_KEY, DEFAULT_GROUP) + ""-config"";
+        buildConfigService(url);
+        watchListenerMap = new ConcurrentHashMap<>();
+    }
+
+    private ConfigService buildConfigService(URL url) {
+        Properties nacosProperties = buildNacosProperties(url);
+        try {
+            configService = NacosFactory.createConfigService(nacosProperties);
+        } catch (NacosException e) {
+            if (logger.isErrorEnabled()) {
+                logger.error(e.getErrMsg(), e);
+            }
+            throw new IllegalStateException(e);
+        }
+        return configService;
+    }
+
+    public void publishNacosConfig(String key, String value) {
+        try {
+            String[] keyAndGroup = getKeyAndGroup(key);
+            configService.publishConfig(keyAndGroup[0], keyAndGroup[1], value);
+        } catch (NacosException e) {
+            logger.error(e.getErrMsg());
+        }
+    }
+
+    private String[] getKeyAndGroup(String key) {
+        int i = key.lastIndexOf(GROUP_CHAR_SEPERATOR);
+        if (i < 0) {
+            return new String[]{key, null};
+        } else {
+            return new String[]{key.substring(0, i), key.substring(i+1)};
+        }
+    }
+
+    private Properties buildNacosProperties(URL url) {
+        Properties properties = new Properties();
+        setServerAddr(url, properties);
+        setProperties(url, properties);
+        return properties;
+    }
+
+    private void setServerAddr(URL url, Properties properties) {
+        StringBuilder serverAddrBuilder =
+                new StringBuilder(url.getHost()) // Host
+                        .append("":"")
+                        .append(url.getPort()); // Port
+
+        // Append backup parameter as other servers
+        String backup = url.getParameter(BACKUP_KEY);
+        if (backup != null) {
+            serverAddrBuilder.append("","").append(backup);
+        }
+        String serverAddr = serverAddrBuilder.toString();
+        properties.put(SERVER_ADDR, serverAddr);
+    }
+
+    private void setProperties(URL url, Properties properties) {
+        putPropertyIfAbsent(url, properties, NAMESPACE);
+        putPropertyIfAbsent(url, properties, NACOS_NAMING_LOG_NAME);
+        putPropertyIfAbsent(url, properties, ENDPOINT);
+        putPropertyIfAbsent(url, properties, ACCESS_KEY);
+        putPropertyIfAbsent(url, properties, SECRET_KEY);
+        putPropertyIfAbsent(url, properties, CLUSTER_NAME);
+    }
+
+    private void putPropertyIfAbsent(URL url, Properties properties, String propertyName) {
+        String propertyValue = url.getParameter(propertyName);
+        if (StringUtils.isNotEmpty(propertyValue)) {
+            properties.setProperty(propertyName, propertyValue);
+        }
+    }
+
+    /**
+     * Ignores the group parameter.
+     *
+     * @param key   property key the native listener will listen on
+     * @param group to distinguish different set of properties
+     * @return
+     */
+    private NacosConfigListener createTargetListener(String key, String group) {
+        NacosConfigListener configListener = new NacosConfigListener();
+        configListener.fillContext(key, group);
+        return configListener;
+    }
+
+    @Override
+    public void addListener(String key, String group, ConfigurationListener listener) {
+        NacosConfigListener nacosConfigListener = watchListenerMap.computeIfAbsent(generateKey(key, group), k -> createTargetListener(key, group));
+        String keyInNacos = rootPath + PROPERTIES_CHAR_SEPERATOR + key;
+        nacosConfigListener.addListener(listener);
+        try {
+            configService.addListener(keyInNacos, null, nacosConfigListener);","[{'comment': 'should be `configService.addListener(keyInNacos, group, nacosConfigListener)`', 'commenter': 'ralf0131'}]"
3988,dubbo-configcenter/dubbo-configcenter-nacos/src/main/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfiguration.java,"@@ -0,0 +1,255 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.configcenter.support.nacos;
+
+import com.alibaba.nacos.api.NacosFactory;
+import com.alibaba.nacos.api.config.ConfigService;
+import com.alibaba.nacos.api.config.listener.AbstractSharedListener;
+import com.alibaba.nacos.api.exception.NacosException;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.configcenter.ConfigChangeEvent;
+import org.apache.dubbo.configcenter.ConfigChangeType;
+import org.apache.dubbo.configcenter.ConfigurationListener;
+import org.apache.dubbo.configcenter.DynamicConfiguration;
+
+import java.util.Map;
+import java.util.Properties;
+import java.util.Set;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArraySet;
+import static com.alibaba.nacos.api.PropertyKeyConst.ACCESS_KEY;
+import static com.alibaba.nacos.api.PropertyKeyConst.CLUSTER_NAME;
+import static com.alibaba.nacos.api.PropertyKeyConst.ENDPOINT;
+import static com.alibaba.nacos.api.PropertyKeyConst.SECRET_KEY;
+import static com.alibaba.nacos.api.PropertyKeyConst.SERVER_ADDR;
+import static com.alibaba.nacos.api.PropertyKeyConst.NAMESPACE;
+import static com.alibaba.nacos.client.naming.utils.UtilAndComs.NACOS_NAMING_LOG_NAME;
+import static org.apache.dubbo.common.Constants.BACKUP_KEY;
+import static org.apache.dubbo.common.Constants.CONFIG_NAMESPACE_KEY;
+import static org.apache.dubbo.common.Constants.GROUP_CHAR_SEPERATOR;
+import static org.apache.dubbo.common.Constants.PROPERTIES_CHAR_SEPERATOR;
+
+/**
+ * The nacos implementation of {@link DynamicConfiguration}
+ */
+public class NacosDynamicConfiguration implements DynamicConfiguration {
+
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+
+    /**
+     * The final root path would be: /$NAME_SPACE/config
+     */
+    private String rootPath;
+
+    /**
+     * The nacos configService
+     */
+
+    private ConfigService configService;
+
+    /**
+     * The map store the key to {@link NacosConfigListener} mapping
+     */
+    private final ConcurrentMap<String, NacosConfigListener> watchListenerMap;
+
+    NacosDynamicConfiguration(URL url) {
+        rootPath = url.getParameter(CONFIG_NAMESPACE_KEY, DEFAULT_GROUP) + ""-config"";
+        buildConfigService(url);
+        watchListenerMap = new ConcurrentHashMap<>();
+    }
+
+    private ConfigService buildConfigService(URL url) {
+        Properties nacosProperties = buildNacosProperties(url);
+        try {
+            configService = NacosFactory.createConfigService(nacosProperties);
+        } catch (NacosException e) {
+            if (logger.isErrorEnabled()) {
+                logger.error(e.getErrMsg(), e);
+            }
+            throw new IllegalStateException(e);
+        }
+        return configService;
+    }
+
+    public void publishNacosConfig(String key, String value) {
+        try {
+            String[] keyAndGroup = getKeyAndGroup(key);
+            configService.publishConfig(keyAndGroup[0], keyAndGroup[1], value);
+        } catch (NacosException e) {
+            logger.error(e.getErrMsg());
+        }
+    }
+
+    private String[] getKeyAndGroup(String key) {
+        int i = key.lastIndexOf(GROUP_CHAR_SEPERATOR);
+        if (i < 0) {
+            return new String[]{key, null};
+        } else {
+            return new String[]{key.substring(0, i), key.substring(i+1)};
+        }
+    }
+
+    private Properties buildNacosProperties(URL url) {
+        Properties properties = new Properties();
+        setServerAddr(url, properties);
+        setProperties(url, properties);
+        return properties;
+    }
+
+    private void setServerAddr(URL url, Properties properties) {
+        StringBuilder serverAddrBuilder =
+                new StringBuilder(url.getHost()) // Host
+                        .append("":"")
+                        .append(url.getPort()); // Port
+
+        // Append backup parameter as other servers
+        String backup = url.getParameter(BACKUP_KEY);
+        if (backup != null) {
+            serverAddrBuilder.append("","").append(backup);
+        }
+        String serverAddr = serverAddrBuilder.toString();
+        properties.put(SERVER_ADDR, serverAddr);
+    }
+
+    private void setProperties(URL url, Properties properties) {
+        putPropertyIfAbsent(url, properties, NAMESPACE);
+        putPropertyIfAbsent(url, properties, NACOS_NAMING_LOG_NAME);
+        putPropertyIfAbsent(url, properties, ENDPOINT);
+        putPropertyIfAbsent(url, properties, ACCESS_KEY);
+        putPropertyIfAbsent(url, properties, SECRET_KEY);
+        putPropertyIfAbsent(url, properties, CLUSTER_NAME);
+    }
+
+    private void putPropertyIfAbsent(URL url, Properties properties, String propertyName) {
+        String propertyValue = url.getParameter(propertyName);
+        if (StringUtils.isNotEmpty(propertyValue)) {
+            properties.setProperty(propertyName, propertyValue);
+        }
+    }
+
+    /**
+     * Ignores the group parameter.
+     *
+     * @param key   property key the native listener will listen on
+     * @param group to distinguish different set of properties
+     * @return
+     */
+    private NacosConfigListener createTargetListener(String key, String group) {
+        NacosConfigListener configListener = new NacosConfigListener();
+        configListener.fillContext(key, group);
+        return configListener;
+    }
+
+    @Override
+    public void addListener(String key, String group, ConfigurationListener listener) {
+        NacosConfigListener nacosConfigListener = watchListenerMap.computeIfAbsent(generateKey(key, group), k -> createTargetListener(key, group));
+        String keyInNacos = rootPath + PROPERTIES_CHAR_SEPERATOR + key;
+        nacosConfigListener.addListener(listener);
+        try {
+            configService.addListener(keyInNacos, null, nacosConfigListener);
+        } catch (NacosException e) {
+            logger.error(e.getMessage());
+        }
+    }
+
+    private String generateKey(String key, String group) {
+        if (StringUtils.isNotEmpty(group)) {
+            key = key + GROUP_CHAR_SEPERATOR + group;
+        }
+        return key;
+    }
+
+    @Override
+    public void removeListener(String key, String group, ConfigurationListener listener) {
+        NacosConfigListener eventListener = watchListenerMap.get(generateKey(key, group));
+        if (eventListener != null) {
+            eventListener.removeListener(listener);
+        }
+    }
+
+    @Override
+    public String getConfig(String key, String group, long timeout) throws IllegalStateException {
+        key = generateKey(key, group);
+        return (String) getInternalProperty(rootPath + PROPERTIES_CHAR_SEPERATOR + key);
+    }
+
+    @Override
+    public Object getInternalProperty(String key) {
+        try {
+            String[] keyAndGroup = getKeyAndGroup(key);
+            return configService.getConfig(keyAndGroup[0], keyAndGroup[1], 5000L);
+        } catch (NacosException e) {
+            logger.error(e.getMessage());
+        }
+        return null;
+    }
+
+    public class NacosConfigListener extends AbstractSharedListener {
+
+        private Set<ConfigurationListener> listeners = new CopyOnWriteArraySet<>();
+        /**
+         * cache data to store old value
+         */
+        private Map<String, String> cacheData = new ConcurrentHashMap<>();
+
+        @Override
+        public Executor getExecutor() {
+            return null;
+        }
+
+        /**
+         * receive
+         *
+         * @param dataId     data ID
+         * @param group      group
+         * @param configInfo content
+         */
+        @Override
+        public void innerReceive(String dataId, String group, String configInfo) {
+            String oldValue = cacheData.get(dataId);
+            ConfigChangeEvent event = new ConfigChangeEvent(dataId, configInfo, getChangeType(configInfo, oldValue));
+            cacheData.put(dataId, configInfo);","[{'comment': 'if `configInfo` is null, which means a config has been deleted. This line will throw NPE:\r\n\r\n```java\r\n        java.lang.NullPointerException\r\n\tat java.base/java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1011)\r\n\tat java.base/java.util.concurrent.ConcurrentHashMap.put(ConcurrentHashMap.java:1006)\r\n\tat org.apache.dubbo.configcenter.support.nacos.NacosDynamicConfiguration$NacosConfigListener.innerReceive(NacosDynamicConfiguration.java:229)\r\n\tat com.alibaba.nacos.api.config.listener.AbstractSharedListener.receiveConfigInfo(AbstractSharedListener.java:37)\r\n\tat com.alibaba.nacos.client.config.impl.CacheData$1.run(CacheData.java:188)\r\n\tat com.alibaba.nacos.client.config.impl.CacheData.safeNotifyListener(CacheData.java:209)\r\n\tat com.alibaba.nacos.client.config.impl.CacheData.checkListenerMd5(CacheData.java:160)\r\n\tat com.alibaba.nacos.client.config.impl.ClientWorker$LongPollingRunnable.run(ClientWorker.java:505)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\n```\r\n\r\nIn order to avoid that, it is necessary to remove the dataID from cacheDate.', 'commenter': 'ralf0131'}]"
4015,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java,"@@ -201,23 +201,53 @@ private void removeFailedNotified(URL url, NotifyListener listener) {
         }
     }
 
-    public ConcurrentMap<URL, FailedRegisteredTask> getFailedRegistered() {
+    /**
+     * remove public modifier.
+     *
+     * @return
+     * @since 2.7.2
+     */
+    ConcurrentMap<URL, FailedRegisteredTask> getFailedRegistered() {
         return failedRegistered;
     }
 
-    public ConcurrentMap<URL, FailedUnregisteredTask> getFailedUnregistered() {
+    /**
+     * remove public modifier.
+     *
+     * @return
+     * @since 2.7.2
+     */
+    ConcurrentMap<URL, FailedUnregisteredTask> getFailedUnregistered() {
         return failedUnregistered;
     }
 
-    public ConcurrentMap<Holder, FailedSubscribedTask> getFailedSubscribed() {
+    /**
+     * remove public modifier.
+     *
+     * @return
+     * @since 2.7.2
+     */
+    ConcurrentMap<Holder, FailedSubscribedTask> getFailedSubscribed() {
         return failedSubscribed;
     }
 
-    public ConcurrentMap<Holder, FailedUnsubscribedTask> getFailedUnsubscribed() {
+    /**
+     * remove public modifier.
+     *
+     * @return
+     * @since 2.7.2
+     */
+    ConcurrentMap<Holder, FailedUnsubscribedTask> getFailedUnsubscribed() {
         return failedUnsubscribed;
     }
 
-    public ConcurrentMap<Holder, FailedNotifiedTask> getFailedNotified() {
+    /**
+     * remove public modifier.
+     *
+     * @return
+     * @since 2.7.2","[{'comment': '注释，晚点我去下。', 'commenter': 'cvictory'}]"
4015,dubbo-compatible/src/main/java/com/alibaba/dubbo/common/utils/UrlUtils.java,"@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.alibaba.dubbo.common.utils;
+
+import com.alibaba.dubbo.common.URL;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/**
+ * @author cvictory ON 2019-04-17","[{'comment': 'should we keep away from `author` in apache project?', 'commenter': 'Moriadry-zz'}, {'comment': 'Ok', 'commenter': 'cvictory'}]"
4015,dubbo-compatible/src/main/java/com/alibaba/dubbo/registry/support/FailbackRegistry.java,"@@ -0,0 +1,187 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.alibaba.dubbo.registry.support;
+
+import com.alibaba.dubbo.common.URL;
+import com.alibaba.dubbo.registry.NotifyListener;
+import com.alibaba.dubbo.registry.Registry;
+
+import java.util.List;
+import java.util.stream.Collectors;
+
+/**
+ * @author cvictory ON 2019-04-17","[{'comment': 'same on the above.', 'commenter': 'Moriadry-zz'}, {'comment': 'ok\r\n', 'commenter': 'cvictory'}]"
4015,dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java,"@@ -48,7 +48,7 @@
     private static final Pattern INT_PATTERN = Pattern.compile(""^\\d+$"");
     private static final int PAD_LIMIT = 8192;
 
-    private StringUtils() {
+    protected StringUtils() {","[{'comment': 'Just curious, why do we need to change the access qualifier to protected?', 'commenter': 'chickenlj'}, {'comment': 'I will revert to older version.  Because some extension class used com.alibaba.dubbo.common.utils.StringUtils, I want write a class Name com.alibaba.dubbo.common.utils.StringUtils and extend the StringUtils.  Finally I found it can not fix issue.  ', 'commenter': 'cvictory'}]"
4015,dubbo-compatible/src/main/java/com/alibaba/dubbo/common/utils/UrlUtils.java,"@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.alibaba.dubbo.common.utils;
+
+import com.alibaba.dubbo.common.URL;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/**
+ * @author cvictory ON 2019-04-17
+ */
+@Deprecated
+public class UrlUtils {
+
+    public static URL parseURL(String address, Map<String, String> defaults) {
+        return new URL(UrlUtils.parseURL(address, defaults));
+    }
+
+    public static List<URL> parseURLs(String address, Map<String, String> defaults) {
+        return UrlUtils.parseURLs(address, defaults).stream().map(e -> new URL(e)).collect(Collectors.toList());","[{'comment': 'endless recursion?\r\nshould it be `org.apache.dubbo.common.utils.UrlUtils.parseURLs(address, defaults).stream()`?', 'commenter': 'chickenlj'}]"
4015,dubbo-compatible/src/main/java/com/alibaba/dubbo/common/utils/UrlUtils.java,"@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.alibaba.dubbo.common.utils;
+
+import com.alibaba.dubbo.common.URL;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/**
+ * 2019-04-17
+ */
+@Deprecated
+public class UrlUtils {
+
+    public static URL parseURL(String address, Map<String, String> defaults) {
+        return new URL(UrlUtils.parseURL(address, defaults));","[{'comment': 'Here should also be `org.apache.dubbo.xxx.UrlUtils `', 'commenter': 'chickenlj'}]"
4025,dubbo-metadata-report/dubbo-metadata-report-nacos/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.metadata.store.MetadataReportFactory,"@@ -0,0 +1 @@
+consul=org.apache.dubbo.metadata.store.consul.ConsulMetadataReportFactory","[{'comment': 'Should be change to nacos', 'commenter': 'ralf0131'}]"
4025,dubbo-common/src/main/java/org/apache/dubbo/common/utils/NacosUtils.java,"@@ -0,0 +1,91 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.utils;
+
+import org.apache.dubbo.common.URL;
+
+import java.util.Properties;
+import static com.alibaba.nacos.api.PropertyKeyConst.SERVER_ADDR;
+import static com.alibaba.nacos.api.PropertyKeyConst.SECRET_KEY;
+import static com.alibaba.nacos.api.PropertyKeyConst.ACCESS_KEY;
+import static com.alibaba.nacos.api.PropertyKeyConst.ENDPOINT;
+import static com.alibaba.nacos.api.PropertyKeyConst.NAMESPACE;
+import static com.alibaba.nacos.api.PropertyKeyConst.CLUSTER_NAME;
+import static com.alibaba.nacos.client.naming.utils.UtilAndComs.NACOS_NAMING_LOG_NAME;
+
+import static org.apache.dubbo.common.Constants.BACKUP_KEY;
+
+/**
+ * NacosUtils
+ */
+public class NacosUtils {","[{'comment': 'I could not find a better location to put this class. Maybe we should put this class into nacos-client. Before that I think it is ok to keep it duplicated. How do you think?', 'commenter': 'ralf0131'}, {'comment': 'yeah, your right. Let me fix this.', 'commenter': 'Moriadry-zz'}]"
4026,dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java,"@@ -541,6 +549,26 @@ private static Object newInstance(Class<?> cls) {
         }
     }
 
+    /**
+     * return init value when type is primitive
+     * @param parameterType
+     * @return
+     */
+    private static Object getPrimitiveDefaultValue(Class<?> parameterType) {
+        if (parameterType.getName().equals(""int"") || parameterType.getName().equals(""short"")","[{'comment': 'java.lang.Class provides a method call isPrimitive(). I think it can be used here:\r\n\r\n```\r\nif (parameterType is char) return Character.MINVALUE;\r\nif (parameterType is primitive) return 0;\r\nreturn null\r\n```\r\n\r\nDoes that look simpler?', 'commenter': 'ralf0131'}, {'comment': 'yes , make this method become simple and general', 'commenter': 'fibbery'}]"
4032,dubbo-rpc/dubbo-rpc-jms/src/main/java/org/apache/dubbo/rpc/protocol/jms/JmsRpcExporter.java,"@@ -0,0 +1,105 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.jms;
+
+import javax.jms.*;","[{'comment': 'Do not import  .*', 'commenter': 'CrazyHZM'}]"
4032,dubbo-rpc/dubbo-rpc-jms/src/main/java/org/apache/dubbo/rpc/protocol/jms/JmsRpcInvoker.java,"@@ -0,0 +1,114 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.jms;
+
+import java.io.Serializable;
+import java.net.SocketTimeoutException;
+
+import javax.jms.*;","[{'comment': 'The same as above.', 'commenter': 'CrazyHZM'}]"
4032,dubbo-rpc/dubbo-rpc-jms/LICENSE,"@@ -0,0 +1,201 @@
+                                 Apache License","[{'comment': 'I think there is no need to include this incense, we can use the one under the root directory.', 'commenter': 'ralf0131'}]"
4032,dubbo-rpc/dubbo-rpc-jms-implementor-activemq/src/main/java/org/apache/dubbo/rpc/protocol/jms/implementor/activemq/ActivemqJmsImplementor.java,"@@ -0,0 +1,32 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.jms.implementor.activemq;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.protocol.jms.implementor.JmsImplementor;
+import org.apache.activemq.ActiveMQConnectionFactory;
+
+import javax.jms.QueueConnectionFactory;
+
+/**
+ * @author ding.lid","[{'comment': 'Please remove the author name.', 'commenter': 'ralf0131'}]"
4032,dubbo-rpc/dubbo-rpc-jms-implementor-activemq/pom.xml,"@@ -0,0 +1,48 @@
+<!--
+ - Copyright 1999-2011 Alibaba Group.","[{'comment': 'Please update the license header to standard Apache license.', 'commenter': 'ralf0131'}]"
4032,dubbo-all/pom.xml,"@@ -219,6 +219,20 @@
             <scope>compile</scope>
             <optional>true</optional>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-rpc-jms</artifactId>
+            <version>${project.version}</version>
+            <scope>compile</scope>
+            <optional>true</optional>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-rpc-jms-implementor-activemq</artifactId>","[{'comment': ""Following dubbo's naming convention, I think dubbo-rpc-jms-activemq is better? What do you think?"", 'commenter': 'ralf0131'}]"
4032,dubbo-rpc/dubbo-rpc-jms-implementor-activemq/src/test/java/org/apache/dubbo/rpc/protocol/jms/JmsProtocolTest.java,"@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.jms;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.rpc.Exporter;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.ProxyFactory;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.protocol.jms.JmsServiceImpl.MyException;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+/**
+ * @author Kimmking","[{'comment': 'Remove the author name.', 'commenter': 'ralf0131'}, {'comment': 'Remove author.', 'commenter': 'ralf0131'}]"
4032,dubbo-rpc/dubbo-rpc-jms-implementor-activemq/src/test/java/org/apache/dubbo/rpc/protocol/jms/JmsService.java,"@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.jms;
+
+
+/**
+ * @author Kimmking","[{'comment': 'Remove author.', 'commenter': 'ralf0131'}, {'comment': 'Remove author.', 'commenter': 'ralf0131'}]"
4032,dubbo-rpc/dubbo-rpc-jms-implementor-activemq/src/test/java/org/apache/dubbo/rpc/protocol/jms/JmsServiceImpl.java,"@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.jms;
+
+/**
+ * @author Kimmking","[{'comment': 'Remove author.', 'commenter': 'ralf0131'}, {'comment': 'Remove author.', 'commenter': 'ralf0131'}]"
4032,dubbo-rpc/dubbo-rpc-jms/README.md,"@@ -0,0 +1,2 @@
+# incubator-dubbo-rpc-jms
+incubator-dubbo-rpc-jms","[{'comment': ""This file is unnecessary to have, isn't it?"", 'commenter': 'ralf0131'}]"
4032,dubbo-rpc/dubbo-rpc-jms/pom.xml,"@@ -0,0 +1,43 @@
+<!--
+ - Copyright 1999-2011 Alibaba Group.","[{'comment': 'Use standard Apache license.', 'commenter': 'ralf0131'}]"
4032,dubbo-rpc/dubbo-rpc-jms/src/main/java/org/apache/dubbo/rpc/protocol/jms/JmsRpcExporter.java,"@@ -0,0 +1,113 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.jms;
+
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.protocol.jms.implementor.JmsImplementor;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.protocol.AbstractExporter;
+
+import javax.jms.Message;
+import javax.jms.MessageConsumer;
+import javax.jms.MessageListener;
+import javax.jms.ObjectMessage;
+import javax.jms.Queue;
+import javax.jms.QueueConnection;
+import javax.jms.QueueConnectionFactory;
+import javax.jms.QueueSession;
+import javax.jms.Session;
+
+/**
+ * @author Kimmking","[{'comment': 'Remove author.', 'commenter': 'ralf0131'}]"
4032,dubbo-rpc/dubbo-rpc-jms/src/main/java/org/apache/dubbo/rpc/protocol/jms/JmsProtocol.java,"@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.jms;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.Exporter;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.ProxyFactory;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.protocol.AbstractProtocol;
+
+/**
+ * @author Kimmking","[{'comment': 'Remove author.', 'commenter': 'ralf0131'}]"
4032,dubbo-rpc/dubbo-rpc-jms/src/main/java/org/apache/dubbo/rpc/protocol/jms/JmsRpcInvoker.java,"@@ -0,0 +1,121 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.jms;
+
+import java.io.Serializable;
+import java.net.SocketTimeoutException;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.rpc.AppResponse;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.ProxyFactory;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.protocol.AbstractInvoker;
+import org.apache.dubbo.rpc.protocol.jms.implementor.JmsImplementor;
+
+import javax.jms.JMSException;
+import javax.jms.Message;
+import javax.jms.Queue;
+import javax.jms.QueueConnection;
+import javax.jms.QueueConnectionFactory;
+import javax.jms.QueueSender;
+import javax.jms.QueueSession;
+import javax.jms.Session;
+
+/**
+ * @author Kimmking","[{'comment': 'Remove author', 'commenter': 'ralf0131'}]"
4032,dubbo-rpc/dubbo-rpc-jms/src/main/java/org/apache/dubbo/rpc/protocol/jms/implementor/JmsImplementor.java,"@@ -0,0 +1,30 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.jms.implementor;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.SPI;
+
+import javax.jms.QueueConnectionFactory;
+
+/**
+ * @author ding.lid","[{'comment': 'Remove author.', 'commenter': 'ralf0131'}]"
4033,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java,"@@ -1,167 +1,167 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.rpc.cluster.support.wrapper;
-
-import org.apache.dubbo.common.Constants;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.CollectionUtils;
-import org.apache.dubbo.common.utils.StringUtils;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.RpcInvocation;
-import org.apache.dubbo.rpc.RpcResult;
-import org.apache.dubbo.rpc.cluster.Directory;
-import org.apache.dubbo.rpc.support.MockInvoker;
-
-import java.util.List;
-
-public class MockClusterInvoker<T> implements Invoker<T> {
-
-    private static final Logger logger = LoggerFactory.getLogger(MockClusterInvoker.class);
-
-    private final Directory<T> directory;
-
-    private final Invoker<T> invoker;
-
-    public MockClusterInvoker(Directory<T> directory, Invoker<T> invoker) {
-        this.directory = directory;
-        this.invoker = invoker;
-    }
-
-    @Override
-    public URL getUrl() {
-        return directory.getUrl();
-    }
-
-    @Override
-    public boolean isAvailable() {
-        return directory.isAvailable();
-    }
-
-    @Override
-    public void destroy() {
-        this.invoker.destroy();
-    }
-
-    @Override
-    public Class<T> getInterface() {
-        return directory.getInterface();
-    }
-
-    @Override
-    public Result invoke(Invocation invocation) throws RpcException {
-        Result result = null;
-
-        String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();
-        if (value.length() == 0 || value.equalsIgnoreCase(""false"")) {
-            //no mock
-            result = this.invoker.invoke(invocation);
-        } else if (value.startsWith(""force"")) {
-            if (logger.isWarnEnabled()) {
-                logger.warn(""force-mock: "" + invocation.getMethodName() + "" force-mock enabled , url : "" + directory.getUrl());
-            }
-            //force:direct mock
-            result = doMockInvoke(invocation, null);
-        } else {
-            //fail-mock
-            try {
-                result = this.invoker.invoke(invocation);
-            } catch (RpcException e) {
-                if (e.isBiz()) {
-                    throw e;
-                }
-
-                if (logger.isWarnEnabled()) {
-                    logger.warn(""fail-mock: "" + invocation.getMethodName() + "" fail-mock enabled , url : "" + directory.getUrl(), e);
-                }
-                result = doMockInvoke(invocation, e);
-            }
-        }
-        return result;
-    }
-
-    @SuppressWarnings({""unchecked"", ""rawtypes""})
-    private Result doMockInvoke(Invocation invocation, RpcException e) {
-        Result result = null;
-        Invoker<T> minvoker;
-
-        List<Invoker<T>> mockInvokers = selectMockInvoker(invocation);
-        if (CollectionUtils.isEmpty(mockInvokers)) {
-            minvoker = (Invoker<T>) new MockInvoker(directory.getUrl(), directory.getInterface());
-        } else {
-            minvoker = mockInvokers.get(0);
-        }
-        try {
-            result = minvoker.invoke(invocation);
-        } catch (RpcException me) {
-            if (me.isBiz()) {
-                result = new RpcResult(me.getCause());
-            } else {
-                throw new RpcException(me.getCode(), getMockExceptionMessage(e, me), me.getCause());
-            }
-        } catch (Throwable me) {
-            throw new RpcException(getMockExceptionMessage(e, me), me.getCause());
-        }
-        return result;
-    }
-
-    private String getMockExceptionMessage(Throwable t, Throwable mt) {
-        String msg = ""mock error : "" + mt.getMessage();
-        if (t != null) {
-            msg = msg + "", invoke error is :"" + StringUtils.toString(t);
-        }
-        return msg;
-    }
-
-    /**
-     * Return MockInvoker
-     * Contract：
-     * directory.list() will return a list of normal invokers if Constants.INVOCATION_NEED_MOCK is present in invocation, otherwise, a list of mock invokers will return.
-     * if directory.list() returns more than one mock invoker, only one of them will be used.
-     *
-     * @param invocation
-     * @return
-     */
-    private List<Invoker<T>> selectMockInvoker(Invocation invocation) {
-        List<Invoker<T>> invokers = null;
-        //TODO generic invoker？
-        if (invocation instanceof RpcInvocation) {
-            //Note the implicit contract (although the description is added to the interface declaration, but extensibility is a problem. The practice placed in the attachment needs to be improved)
-            ((RpcInvocation) invocation).setAttachment(Constants.INVOCATION_NEED_MOCK, Boolean.TRUE.toString());
-            //directory will return a list of normal invokers if Constants.INVOCATION_NEED_MOCK is present in invocation, otherwise, a list of mock invokers will return.
-            try {
-                invokers = directory.list(invocation);
-            } catch (RpcException e) {
-                if (logger.isInfoEnabled()) {
-                    logger.info(""Exception when try to invoke mock. Get mock invokers error for service:""
-                            + directory.getUrl().getServiceInterface() + "", method:"" + invocation.getMethodName()
-                            + "", will contruct a new mock with 'new MockInvoker()'."", e);
-                }
-            }
-        }
-        return invokers;
-    }
-
-    @Override
-    public String toString() {
-        return ""invoker :"" + this.invoker + "",directory: "" + this.directory;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.support.wrapper;
+
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.RpcInvocation;
+import org.apache.dubbo.rpc.RpcResult;
+import org.apache.dubbo.rpc.cluster.Directory;
+import org.apache.dubbo.rpc.support.MockInvoker;
+
+import java.util.List;
+
+public class MockClusterInvoker<T> implements Invoker<T> {
+
+    private static final Logger logger = LoggerFactory.getLogger(MockClusterInvoker.class);
+
+    private final Directory<T> directory;
+
+    private final Invoker<T> invoker;
+
+    public MockClusterInvoker(Directory<T> directory, Invoker<T> invoker) {
+        this.directory = directory;
+        this.invoker = invoker;
+    }
+
+    @Override
+    public URL getUrl() {
+        return directory.getUrl();
+    }
+
+    @Override
+    public boolean isAvailable() {
+        return directory.isAvailable();
+    }
+
+    @Override
+    public void destroy() {
+        this.invoker.destroy();
+    }
+
+    @Override
+    public Class<T> getInterface() {
+        return directory.getInterface();
+    }
+
+    @Override
+    public Result invoke(Invocation invocation) throws RpcException {
+        Result result = null;
+
+        String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();
+        if (value.length() == 0 || ""false"".equalsIgnoreCase(value)) {","[{'comment': 'I think it is better to define a constant here.', 'commenter': 'Leishunyu'}]"
4033,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java,"@@ -1,169 +1,169 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.rpc.cluster.support.wrapper;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.CollectionUtils;
-import org.apache.dubbo.common.utils.StringUtils;
-import org.apache.dubbo.rpc.AsyncRpcResult;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.RpcInvocation;
-import org.apache.dubbo.rpc.cluster.Directory;
-import org.apache.dubbo.rpc.support.MockInvoker;
-
-import java.util.List;
-
-import static org.apache.dubbo.rpc.cluster.Constants.INVOCATION_NEED_MOCK;
-import static org.apache.dubbo.rpc.Constants.MOCK_KEY;
-
-public class MockClusterInvoker<T> implements Invoker<T> {
-
-    private static final Logger logger = LoggerFactory.getLogger(MockClusterInvoker.class);
-
-    private final Directory<T> directory;
-
-    private final Invoker<T> invoker;
-
-    public MockClusterInvoker(Directory<T> directory, Invoker<T> invoker) {
-        this.directory = directory;
-        this.invoker = invoker;
-    }
-
-    @Override
-    public URL getUrl() {
-        return directory.getUrl();
-    }
-
-    @Override
-    public boolean isAvailable() {
-        return directory.isAvailable();
-    }
-
-    @Override
-    public void destroy() {
-        this.invoker.destroy();
-    }
-
-    @Override
-    public Class<T> getInterface() {
-        return directory.getInterface();
-    }
-
-    @Override
-    public Result invoke(Invocation invocation) throws RpcException {
-        Result result = null;
-
-        String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), MOCK_KEY, Boolean.FALSE.toString()).trim();
-        if (value.length() == 0 || value.equalsIgnoreCase(""false"")) {
-            //no mock
-            result = this.invoker.invoke(invocation);
-        } else if (value.startsWith(""force"")) {
-            if (logger.isWarnEnabled()) {
-                logger.warn(""force-mock: "" + invocation.getMethodName() + "" force-mock enabled , url : "" + directory.getUrl());
-            }
-            //force:direct mock
-            result = doMockInvoke(invocation, null);
-        } else {
-            //fail-mock
-            try {
-                result = this.invoker.invoke(invocation);
-            } catch (RpcException e) {
-                if (e.isBiz()) {
-                    throw e;
-                }
-
-                if (logger.isWarnEnabled()) {
-                    logger.warn(""fail-mock: "" + invocation.getMethodName() + "" fail-mock enabled , url : "" + directory.getUrl(), e);
-                }
-                result = doMockInvoke(invocation, e);
-            }
-        }
-        return result;
-    }
-
-    @SuppressWarnings({""unchecked"", ""rawtypes""})
-    private Result doMockInvoke(Invocation invocation, RpcException e) {
-        Result result = null;
-        Invoker<T> minvoker;
-
-        List<Invoker<T>> mockInvokers = selectMockInvoker(invocation);
-        if (CollectionUtils.isEmpty(mockInvokers)) {
-            minvoker = (Invoker<T>) new MockInvoker(directory.getUrl(), directory.getInterface());
-        } else {
-            minvoker = mockInvokers.get(0);
-        }
-        try {
-            result = minvoker.invoke(invocation);
-        } catch (RpcException me) {
-            if (me.isBiz()) {
-                result = AsyncRpcResult.newDefaultAsyncResult(me.getCause(), invocation);
-            } else {
-                throw new RpcException(me.getCode(), getMockExceptionMessage(e, me), me.getCause());
-            }
-        } catch (Throwable me) {
-            throw new RpcException(getMockExceptionMessage(e, me), me.getCause());
-        }
-        return result;
-    }
-
-    private String getMockExceptionMessage(Throwable t, Throwable mt) {
-        String msg = ""mock error : "" + mt.getMessage();
-        if (t != null) {
-            msg = msg + "", invoke error is :"" + StringUtils.toString(t);
-        }
-        return msg;
-    }
-
-    /**
-     * Return MockInvoker
-     * Contract：
-     * directory.list() will return a list of normal invokers if Constants.INVOCATION_NEED_MOCK is present in invocation, otherwise, a list of mock invokers will return.
-     * if directory.list() returns more than one mock invoker, only one of them will be used.
-     *
-     * @param invocation
-     * @return
-     */
-    private List<Invoker<T>> selectMockInvoker(Invocation invocation) {
-        List<Invoker<T>> invokers = null;
-        //TODO generic invoker？
-        if (invocation instanceof RpcInvocation) {
-            //Note the implicit contract (although the description is added to the interface declaration, but extensibility is a problem. The practice placed in the attachment needs to be improved)
-            ((RpcInvocation) invocation).setAttachment(INVOCATION_NEED_MOCK, Boolean.TRUE.toString());
-            //directory will return a list of normal invokers if Constants.INVOCATION_NEED_MOCK is present in invocation, otherwise, a list of mock invokers will return.
-            try {
-                invokers = directory.list(invocation);
-            } catch (RpcException e) {
-                if (logger.isInfoEnabled()) {
-                    logger.info(""Exception when try to invoke mock. Get mock invokers error for service:""
-                            + directory.getUrl().getServiceInterface() + "", method:"" + invocation.getMethodName()
-                            + "", will contruct a new mock with 'new MockInvoker()'."", e);
-                }
-            }
-        }
-        return invokers;
-    }
-
-    @Override
-    public String toString() {
-        return ""invoker :"" + this.invoker + "",directory: "" + this.directory;
-    }
-}
+/*","[{'comment': 'please leave file endline format not changed', 'commenter': 'AlbumenJ'}]"
4034,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/ClusterUtilsTest.java,"@@ -59,6 +59,7 @@ public void testMergeUrl() throws Exception {
                 .addParameter(DEFAULT_KEY_PREFIX + QUEUES_KEY, Integer.MAX_VALUE)
                 .addParameter(DEFAULT_KEY_PREFIX + ALIVE_KEY, Integer.MAX_VALUE)
                 .addParameter(DEFAULT_KEY_PREFIX + THREAD_NAME_KEY, ""test"")
+                .addParameter(""."" + Constants.ASYNC_KEY, ""test"")","[{'comment': 'use something like HIDE_KEY_PREFIX instead of "".""?', 'commenter': 'Moriadry-zz'}, {'comment': ""what's more,I doubt whether your test case  is correct, should not it be `key + HIDE_KEY_PREFIX  + Constants.ASYNC_KEY` ?"", 'commenter': 'Moriadry-zz'}, {'comment': '> 1. I prefer using  `cleaner` rather than `more clean` in your title;\r\n> 2. The logic of clusterUtils test is not that perfect, I try opposite conditional statements in mergeUrl method, both of them pass the test case. I believe it you can make it stronger.\r\n\r\nThank you for the review.\r\n1.Yes, I make a mistake on title.\r\n2.I just add test logic of the code I added, maybe there are other questions in the unit test code. You can submit a pr', 'commenter': 'tswstarplanet'}]"
4034,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ClusterUtils.java,"@@ -82,15 +81,9 @@ public static URL mergeUrl(URL remoteUrl, Map<String, String> localMap) {
             map.remove(DEFAULT_KEY_PREFIX + Constants.ASYNC_KEY);
 
             // remove method async entry.
-            Set<String> methodAsyncKey = new HashSet<>();
-            for (String key : map.keySet()) {
-                if (key != null && key.endsWith(""."" + Constants.ASYNC_KEY)) {
-                    methodAsyncKey.add(key);
-                }
-            }
-            for (String needRemove : methodAsyncKey) {
-                map.remove(needRemove);
-            }
+            map = map.entrySet().stream().filter(
+                    entry -> entry.getKey() == null || !entry.getKey().endsWith(""."" + Constants.ASYNC_KEY))
+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry:: getValue));","[{'comment': 'The logic is right, but this may cause the code hard to read. Let see what other reviewers say about this.', 'commenter': 'Moriadry-zz'}, {'comment': 'A helper function in filter will be more concise to me.', 'commenter': 'kun-song'}, {'comment': ""It's not hard to read if you are familiar with stream api of java\r\n> The logic is right, but this may cause the code hard to read. Let see what other reviewers say about this.\r\n\r\n"", 'commenter': 'tswstarplanet'}, {'comment': ""Yes you are right, I am considering this may confuses readers.. But it's okay then."", 'commenter': 'Moriadry-zz'}]"
4110,README.md,"@@ -10,7 +10,7 @@
 [![](https://img.shields.io/twitter/follow/ApacheDubbo.svg?label=Follow&style=social&logoWidth=0)](https://twitter.com/intent/follow?screen_name=ApacheDubbo)
 [![Gitter](https://badges.gitter.im/alibaba/dubbo.svg)](https://gitter.im/alibaba/dubbo?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)
 
-Apache Dubbo (incubating) is a high-performance, Java based open source RPC framework. Please visit [official site](http://dubbo.incubator.apache.org) for quick start and documentations, as well as [Wiki](https://github.com/apache/incubator-dubbo/wiki) for news, FAQ, and release notes.
+Apache Dubbo is a high-performance, Java based open source RPC framework. Please visit [official site](http://dubbo.incubator.apache.org) for quick start and documentations, as well as [Wiki](https://github.com/apache/incubator-dubbo/wiki) for news, FAQ, and release notes.","[{'comment': 'Please change  `dubbo.incubator.apache.org` to  `dubbo.apache.org`', 'commenter': 'lovepoem'}, {'comment': 'ok', 'commenter': 'Leishunyu'}]"
4129,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java,"@@ -140,15 +138,19 @@ public static void closeChannel(Channel channel) {
     }
 
     public static void received(Channel channel, Response response) {
+        received(channel, response, false);
+    }
+
+    public static void received(Channel channel, Response response, boolean timeout) {
         try {
             DefaultFuture future = FUTURES.remove(response.getId());
             if (future != null) {
-                future.doReceived(response);
-                Timeout t = PENDING_TASKS.remove(future.getId());
+                Timeout t = future.timeoutCheckTask;
                 if (t != null) {","[{'comment': '`if (t != null)` should be `if (!timeout) `', 'commenter': 'carryxyh'}, {'comment': 'done', 'commenter': 'chickenlj'}]"
4129,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java,"@@ -229,15 +231,16 @@ private String getTimeoutMessage(boolean scan) {
 
     private static class TimeoutCheckTask implements TimerTask {
 
-        private DefaultFuture future;
+        private final Long requestID;
 
-        TimeoutCheckTask(DefaultFuture future) {
-            this.future = future;
+        TimeoutCheckTask(Long requestID) {
+            this.requestID = requestID;
         }
 
         @Override
         public void run(Timeout timeout) {
-            if (future == null || future.isDone()) {
+            DefaultFuture future = FUTURES.remove(requestID);","[{'comment': 'Personal think that we should use `FUTURES.get` replace `FUTURES.remove`', 'commenter': 'carryxyh'}, {'comment': 'done', 'commenter': 'chickenlj'}]"
4129,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java,"@@ -229,15 +231,16 @@ private String getTimeoutMessage(boolean scan) {
 
     private static class TimeoutCheckTask implements TimerTask {
 
-        private DefaultFuture future;
+        private final Long requestID;
 
-        TimeoutCheckTask(DefaultFuture future) {
-            this.future = future;
+        TimeoutCheckTask(Long requestID) {
+            this.requestID = requestID;
         }
 
         @Override
         public void run(Timeout timeout) {
-            if (future == null || future.isDone()) {
+            DefaultFuture future = DefaultFuture.getFuture(requestID);
+            if (future.isDone()) {","[{'comment': 'Seems like we should judge null for future since the normal response will have called `DefaultFuture.remove`.', 'commenter': 'carryxyh'}, {'comment': 'good cache, done.', 'commenter': 'chickenlj'}]"
4146,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java,"@@ -125,6 +126,10 @@ public void decode() throws Exception {
 
     private void handleValue(ObjectInput in) throws IOException {
         try {
+            if (invocation instanceof RpcInvocation && serializationType == 2) {
+                setValue(in.readObject(((RpcInvocation) invocation).getReturnType()));","[{'comment': 'When the method signature is like `CompletableFuture<String> sayHello(String value);`,  `invocation.getReturnType()` will return `CompletableFuture.class` while `RpcUtils.getReturnType` will return `String.class`', 'commenter': 'chickenlj'}]"
4169,dubbo-registry/dubbo-registry-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesRegistry.java,"@@ -0,0 +1,302 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.kubernetes;
+
+import com.alibaba.fastjson.JSON;
+import com.alibaba.fastjson.JSONObject;
+import io.fabric8.kubernetes.api.model.Pod;
+import io.fabric8.kubernetes.client.KubernetesClient;
+import io.fabric8.kubernetes.client.KubernetesClientException;
+import io.fabric8.kubernetes.client.Watch;
+import io.fabric8.kubernetes.client.Watcher;
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.NamedThreadFactory;
+import org.apache.dubbo.registry.NotifyListener;
+import org.apache.dubbo.registry.support.FailbackRegistry;
+
+import java.util.*;","[{'comment': ""don't use import *"", 'commenter': 'Moriadry-zz'}, {'comment': ""thanks,I'll modify it."", 'commenter': 'fackee'}]"
4169,dubbo-registry/dubbo-registry-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesRegistry.java,"@@ -0,0 +1,302 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.kubernetes;
+
+import com.alibaba.fastjson.JSON;
+import com.alibaba.fastjson.JSONObject;
+import io.fabric8.kubernetes.api.model.Pod;
+import io.fabric8.kubernetes.client.KubernetesClient;
+import io.fabric8.kubernetes.client.KubernetesClientException;
+import io.fabric8.kubernetes.client.Watch;
+import io.fabric8.kubernetes.client.Watcher;
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.NamedThreadFactory;
+import org.apache.dubbo.registry.NotifyListener;
+import org.apache.dubbo.registry.support.FailbackRegistry;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+
+import static org.apache.dubbo.common.Constants.ANY_VALUE;
+
+/**
+ * registry center implementation for kubernetes
+ *
+ */
+public class KubernetesRegistry extends FailbackRegistry {
+
+    private static final Logger logger = LoggerFactory.getLogger(KubernetesRegistry.class);
+
+    private final String namespaces;
+
+    private final String podWithLabel;
+
+    private final KubernetesClient kubernetesClient;
+
+    private final static String FULL_URL = ""full_url"";
+
+    private static final String MARK = ""mark"";
+
+    private static final String APP_LABEL = ""app"";
+
+    private static final String SERVICE_KEY_PREFIX = ""dubbo_service_"";
+
+    private static final ScheduledExecutorService KUBERNETS_EVENT_EXECUTOR =
+            Executors.newScheduledThreadPool(8, new NamedThreadFactory(""kubernetes-event-thread""));
+","[{'comment': 'make this one single line.', 'commenter': 'Moriadry-zz'}, {'comment': ""thanks,I'll modify it."", 'commenter': 'fackee'}]"
4169,dubbo-registry/dubbo-registry-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesRegistry.java,"@@ -0,0 +1,302 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.kubernetes;
+
+import com.alibaba.fastjson.JSON;
+import com.alibaba.fastjson.JSONObject;
+import io.fabric8.kubernetes.api.model.Pod;
+import io.fabric8.kubernetes.client.KubernetesClient;
+import io.fabric8.kubernetes.client.KubernetesClientException;
+import io.fabric8.kubernetes.client.Watch;
+import io.fabric8.kubernetes.client.Watcher;
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.NamedThreadFactory;
+import org.apache.dubbo.registry.NotifyListener;
+import org.apache.dubbo.registry.support.FailbackRegistry;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+
+import static org.apache.dubbo.common.Constants.ANY_VALUE;
+
+/**
+ * registry center implementation for kubernetes
+ *
+ */
+public class KubernetesRegistry extends FailbackRegistry {
+
+    private static final Logger logger = LoggerFactory.getLogger(KubernetesRegistry.class);
+
+    private final String namespaces;
+
+    private final String podWithLabel;
+
+    private final KubernetesClient kubernetesClient;
+
+    private final static String FULL_URL = ""full_url"";
+
+    private static final String MARK = ""mark"";
+
+    private static final String APP_LABEL = ""app"";
+
+    private static final String SERVICE_KEY_PREFIX = ""dubbo_service_"";
+
+    private static final ScheduledExecutorService KUBERNETS_EVENT_EXECUTOR =
+            Executors.newScheduledThreadPool(8, new NamedThreadFactory(""kubernetes-event-thread""));
+
+
+    private final Map<URL, Watch> kubernetesWatcherMap = new ConcurrentHashMap<>(16);
+
+    public KubernetesRegistry(KubernetesClient kubernetesClient, URL url
+            , String namespaces, String podWithLabel) {
+        super(url);
+        this.kubernetesClient = kubernetesClient;
+        this.namespaces = namespaces;
+        this.podWithLabel = podWithLabel;
+    }
+","[{'comment': 'one single line.', 'commenter': 'Moriadry-zz'}, {'comment': ""thanks,I'll modify it."", 'commenter': 'fackee'}]"
4169,dubbo-registry/dubbo-registry-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesRegistryFactory.java,"@@ -0,0 +1,57 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.kubernetes;
+","[{'comment': 'one single line.', 'commenter': 'Moriadry-zz'}, {'comment': '> one single line.\r\n\r\nWhat can I do next?', 'commenter': 'fackee'}]"
4169,dubbo-registry/dubbo-registry-kubernetes/pom.xml,"@@ -0,0 +1,47 @@
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the ""License""); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+  -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <parent>
+        <artifactId>dubbo-registry</artifactId>
+        <groupId>org.apache.dubbo</groupId>
+        <version>${revision}</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>dubbo-registry-kubernetes</artifactId>
+
+    <properties>
+        <kubernetes.version>4.1.0</kubernetes.version>","[{'comment': 'This is better to be placed in dubbo-dependencies-bom/pom.xml', 'commenter': 'Moriadry-zz'}, {'comment': ""thanks,I'll modify it."", 'commenter': 'fackee'}]"
4169,dubbo-registry/dubbo-registry-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesRegistry.java,"@@ -0,0 +1,302 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.kubernetes;
+
+import com.alibaba.fastjson.JSON;
+import com.alibaba.fastjson.JSONObject;
+import io.fabric8.kubernetes.api.model.Pod;
+import io.fabric8.kubernetes.client.KubernetesClient;
+import io.fabric8.kubernetes.client.KubernetesClientException;
+import io.fabric8.kubernetes.client.Watch;
+import io.fabric8.kubernetes.client.Watcher;
+import org.apache.dubbo.common.Constants;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.NamedThreadFactory;
+import org.apache.dubbo.registry.NotifyListener;
+import org.apache.dubbo.registry.support.FailbackRegistry;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+
+import static org.apache.dubbo.common.Constants.ANY_VALUE;
+
+/**
+ * registry center implementation for kubernetes
+ *
+ */
+public class KubernetesRegistry extends FailbackRegistry {
+
+    private static final Logger logger = LoggerFactory.getLogger(KubernetesRegistry.class);
+
+    private final String namespaces;
+
+    private final String podWithLabel;
+
+    private final KubernetesClient kubernetesClient;
+
+    private final static String FULL_URL = ""full_url"";
+
+    private static final String MARK = ""mark"";
+
+    private static final String APP_LABEL = ""app"";
+
+    private static final String SERVICE_KEY_PREFIX = ""dubbo_service_"";
+
+    private static final ScheduledExecutorService KUBERNETS_EVENT_EXECUTOR =
+            Executors.newScheduledThreadPool(8, new NamedThreadFactory(""kubernetes-event-thread""));
+
+
+    private final Map<URL, Watch> kubernetesWatcherMap = new ConcurrentHashMap<>(16);
+
+    public KubernetesRegistry(KubernetesClient kubernetesClient, URL url
+            , String namespaces, String podWithLabel) {
+        super(url);
+        this.kubernetesClient = kubernetesClient;
+        this.namespaces = namespaces;
+        this.podWithLabel = podWithLabel;
+    }
+
+
+    @Override
+    public void register(URL url) {
+        if (isConsumerSide(url)) {
+            return;
+        }
+        super.register(url);
+    }
+
+    @Override
+    public void doRegister(URL url) {
+        List<Pod> pods = queryPodsByUnRegistryUrl(url);
+        if (pods != null && pods.size() > 0) {
+            pods.forEach(pod -> registry(url, pod));
+        }
+    }
+
+    @Override
+    public void unregister(URL url) {
+        if (isConsumerSide(url)) {
+            return;
+        }
+        super.unregister(url);
+    }
+
+    @Override
+    public void doUnregister(URL url) {
+        List<Pod> pods = queryPodNameByRegistriedUrl(url);
+        if (pods != null && pods.size() > 0) {
+            pods.forEach(pod -> unregistry(pod, url));
+        }
+    }
+
+    @Override
+    public void subscribe(URL url, NotifyListener listener) {
+        if (isProviderSide(url)) {
+            return;
+        }
+
+        super.subscribe(url, listener);
+    }
+
+    @Override
+    public void doSubscribe(URL url, NotifyListener notifyListener) {
+        final List<URL> urls = queryUrls(url);
+        this.notify(url, notifyListener, urls);
+
+        kubernetesWatcherMap.computeIfAbsent(url, k ->
+                kubernetesClient.pods().inNamespace(namespaces).withLabel(APP_LABEL, podWithLabel)
+                        .watch(new Watcher<Pod>() {
+                            @Override
+                            public void eventReceived(Action action, Pod pod) {
+                                if (action == Action.ADDED || action == Action.DELETED) {
+                                    KUBERNETS_EVENT_EXECUTOR.schedule(() -> {
+                                        final List<URL> urlList = queryUrls(url);
+                                        doNotify(url, notifyListener, urlList);
+                                    }, 5, TimeUnit.SECONDS);
+                                }
+                            }
+
+                            @Override
+                            public void onClose(KubernetesClientException e) {
+                                if (logger.isDebugEnabled()) {
+                                    logger.debug(""pod watch closed"");
+                                }
+                                if (e != null) {
+                                    logger.error(""watcher onClose exception"", e);
+                                }
+                            }
+                        }));
+    }
+
+    @Override
+    public void unsubscribe(URL url, NotifyListener listener) {
+        if (isProviderSide(url)) {
+            return;
+        }
+
+        super.unsubscribe(url, listener);
+    }
+
+    @Override
+    public void doUnsubscribe(URL url, NotifyListener notifyListener) {
+        Watch watch = kubernetesWatcherMap.remove(url);
+        watch.close();
+    }
+
+    @Override
+    public boolean isAvailable() {
+        return CollectionUtils.isNotEmpty(getAllRunningService());
+    }
+
+    @Override
+    public void destroy() {
+        super.destroy();
+        Collection<URL> urls = Collections.unmodifiableSet(kubernetesWatcherMap.keySet());
+        urls.forEach(url -> {
+            Watch watch = kubernetesWatcherMap.remove(url);
+            watch.close();
+        });
+        KUBERNETS_EVENT_EXECUTOR.shutdown();
+    }
+
+    private boolean isConsumerSide(URL url) {
+        return url.getProtocol().equals(Constants.CONSUMER_PROTOCOL);
+    }
+
+    private boolean isProviderSide(URL url) {
+        return url.getProtocol().equals(Constants.PROVIDER_PROTOCOL);
+    }
+
+    private void registry(URL url, Pod pod) {
+        JSONObject meta = new JSONObject() {{
+            put(Constants.INTERFACE_KEY, url.getServiceInterface());
+            put(FULL_URL, url.toFullString());
+            putAll(url.getParameters());
+        }};
+        kubernetesClient.pods().inNamespace(pod.getMetadata().getNamespace()).withName(pod.getMetadata().getName())
+                .edit()
+                .editMetadata()
+                .addToLabels(MARK, Constants.DEFAULT_PROTOCOL)
+                .addToAnnotations(serviceKey2UniqId(url.getServiceKey()), meta.toJSONString())
+                .and()
+                .done();
+    }
+
+    private String serviceKey2UniqId(String serviecKey) {
+        return SERVICE_KEY_PREFIX + Integer.toHexString(serviecKey.hashCode());
+    }
+
+    private void unregistry(Pod pod, URL url) {","[{'comment': 'registry is a noun. Use register(verb) or unregister(verb) instead.', 'commenter': 'leonliao'}, {'comment': ""thanks,I'll modify it."", 'commenter': 'fackee'}, {'comment': '> registry is a noun. Use register(verb) or unregister(verb) instead.\r\n\r\nWhat can I do next?', 'commenter': 'fackee'}]"
4180,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/utils/UrlUtils.java,"@@ -23,6 +23,7 @@
 public class UrlUtils {
     public static int getIdleTimeout(URL url) {
         int heartBeat = getHeartbeat(url);
+		// why the default value is heartBeat*3 ? because of the retry if client.","[{'comment': 'Pls format your doc.\r\nIt seems that your indentation is not standardized.\r\nIn addition, I suggest you explain the meaning of the code directly rather than asking yourself.', 'commenter': 'carryxyh'}]"
4180,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java,"@@ -116,7 +134,8 @@ protected void doConnect() throws Throwable {
                 Channel newChannel = future.channel();
                 try {
                     // Close old channel
-                    Channel oldChannel = NettyClient.this.channel; // copy reference
+					// copy reference","[{'comment': 'wrong format', 'commenter': 'carryxyh'}]"
4186,dubbo-dependencies-bom/pom.xml,"@@ -363,6 +363,12 @@
                 <groupId>org.jboss.resteasy</groupId>
                 <artifactId>resteasy-jaxrs</artifactId>
                 <version>${resteasy_version}</version>
+                <exclusions>
+                    <exclusion>
+                        <groupId>net.jcip</groupId>
+                        <artifactId>jcip-annotations</artifactId>","[{'comment': 'This is no longer needed to be excluded. See discussion on mailing list.', 'commenter': 'ralf0131'}, {'comment': 'I have revert it.', 'commenter': 'cvictory'}]"
4188,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ActiveLimitFilter.java,"@@ -1,120 +1,120 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.rpc.filter;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.extension.Activate;
-import org.apache.dubbo.common.utils.StringUtils;
-import org.apache.dubbo.rpc.Filter;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.ListenableFilter;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.RpcStatus;
-
-import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
-import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;
-import static org.apache.dubbo.rpc.Constants.ACTIVES_KEY;
-
-/**
- * ActiveLimitFilter restrict the concurrent client invocation for a service or service's method from client side.
- * To use active limit filter, configured url with <b>actives</b> and provide valid >0 integer value.
- * <pre>
- *     e.g. <dubbo:reference id=""demoService"" check=""false"" interface=""org.apache.dubbo.demo.DemoService"" ""actives""=""2""/>
- *      In the above example maximum 2 concurrent invocation is allowed.
- *      If there are more than configured (in this example 2) is trying to invoke remote method, then rest of invocation
- *      will wait for configured timeout(default is 0 second) before invocation gets kill by dubbo.
- * </pre>
- *
- * @see Filter
- */
-@Activate(group = CONSUMER, value = ACTIVES_KEY)
-public class ActiveLimitFilter extends ListenableFilter {
-
-    private static final String ACTIVELIMIT_FILTER_START_TIME = ""activelimit_filter_start_time"";
-
-    public ActiveLimitFilter() {
-        super.listener = new ActiveLimitListener();
-    }
-
-    @Override
-    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
-        URL url = invoker.getUrl();
-        String methodName = invocation.getMethodName();
-        int max = invoker.getUrl().getMethodParameter(methodName, ACTIVES_KEY, 0);
-        RpcStatus rpcStatus = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName());
-        if (!RpcStatus.beginCount(url, methodName, max)) {
-            long timeout = invoker.getUrl().getMethodParameter(invocation.getMethodName(), TIMEOUT_KEY, 0);
-            long start = System.currentTimeMillis();
-            long remain = timeout;
-            synchronized (rpcStatus) {
-                while (!RpcStatus.beginCount(url, methodName, max)) {
-                    try {
-                        rpcStatus.wait(remain);
-                    } catch (InterruptedException e) {
-                        // ignore
-                    }
-                    long elapsed = System.currentTimeMillis() - start;
-                    remain = timeout - elapsed;
-                    if (remain <= 0) {
-                        throw new RpcException(""Waiting concurrent invoke timeout in client-side for service:  "" + invoker.getInterface().getName() + "", method: "" + invocation.getMethodName() + "", elapsed: "" + elapsed + "", timeout: "" + timeout + "". concurrent invokes: "" + rpcStatus.getActive() + "". max concurrent invoke limit: "" + max);
-                    }
-                }
-            }
-        }
-
-        invocation.setAttachment(ACTIVELIMIT_FILTER_START_TIME, String.valueOf(System.currentTimeMillis()));
-
-        return invoker.invoke(invocation);
-    }
-
-    static class ActiveLimitListener implements Listener {
-        @Override
-        public void onResponse(Result appResponse, Invoker<?> invoker, Invocation invocation) {
-            String methodName = invocation.getMethodName();
-            URL url = invoker.getUrl();
-            int max = invoker.getUrl().getMethodParameter(methodName, ACTIVES_KEY, 0);
-
-            RpcStatus.endCount(url, methodName, getElapsed(invocation), true);
-            notifyFinish(RpcStatus.getStatus(url, methodName), max);
-        }
-
-        @Override
-        public void onError(Throwable t, Invoker<?> invoker, Invocation invocation) {
-            String methodName = invocation.getMethodName();
-            URL url = invoker.getUrl();
-            int max = invoker.getUrl().getMethodParameter(methodName, ACTIVES_KEY, 0);
-
-            RpcStatus.endCount(url, methodName, getElapsed(invocation), false);
-            notifyFinish(RpcStatus.getStatus(url, methodName), max);
-        }
-
-        private long getElapsed(Invocation invocation) {
-            String beginTime = invocation.getAttachment(ACTIVELIMIT_FILTER_START_TIME);
-            return StringUtils.isNotEmpty(beginTime) ? System.currentTimeMillis() - Long.parseLong(beginTime) : 0;
-        }
-
-        private void notifyFinish(RpcStatus rpcStatus, int max) {
-            if (max > 0) {
-                synchronized (rpcStatus) {
-                    rpcStatus.notifyAll();
-                }
-            }
-        }
-    }
-}
+/*","[{'comment': 'Is there something wrong with this file?', 'commenter': 'kexianjun'}]"
4188,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"@@ -1,708 +1,708 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.registry.integration;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.URLBuilder;
-import org.apache.dubbo.common.config.ConfigurationUtils;
-import org.apache.dubbo.common.extension.ExtensionLoader;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.CollectionUtils;
-import org.apache.dubbo.common.utils.NamedThreadFactory;
-import org.apache.dubbo.common.utils.StringUtils;
-import org.apache.dubbo.common.utils.UrlUtils;
-import org.apache.dubbo.configcenter.DynamicConfiguration;
-import org.apache.dubbo.registry.NotifyListener;
-import org.apache.dubbo.registry.Registry;
-import org.apache.dubbo.registry.RegistryFactory;
-import org.apache.dubbo.registry.RegistryService;
-import org.apache.dubbo.registry.support.ProviderConsumerRegTable;
-import org.apache.dubbo.registry.support.ProviderInvokerWrapper;
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Protocol;
-import org.apache.dubbo.rpc.ProxyFactory;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.cluster.Cluster;
-import org.apache.dubbo.rpc.cluster.Configurator;
-import org.apache.dubbo.rpc.model.ApplicationModel;
-import org.apache.dubbo.rpc.protocol.InvokerWrapper;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.ExecutorService;
-
-import static java.util.concurrent.Executors.newSingleThreadExecutor;
-import static org.apache.dubbo.rpc.cluster.Constants.LOADBALANCE_KEY;
-import static org.apache.dubbo.rpc.cluster.Constants.WARMUP_KEY;
-import static org.apache.dubbo.rpc.cluster.Constants.WEIGHT_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.ANY_VALUE;
-import static org.apache.dubbo.common.constants.CommonConstants.APPLICATION_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;
-import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.HIDE_KEY_PREFIX;
-import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.PATH_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.RELEASE_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;
-import static org.apache.dubbo.common.constants.QosConstants.ACCEPT_FOREIGN_IP;
-import static org.apache.dubbo.common.constants.CommonConstants.CLUSTER_KEY;
-import static org.apache.dubbo.rpc.cluster.Constants.EXPORT_KEY;
-import static org.apache.dubbo.common.constants.QosConstants.QOS_ENABLE;
-import static org.apache.dubbo.common.constants.QosConstants.QOS_PORT;
-import static org.apache.dubbo.rpc.cluster.Constants.REFER_KEY;
-import static org.apache.dubbo.registry.Constants.REGISTER_IP_KEY;
-import static org.apache.dubbo.common.constants.FilterConstants.VALIDATION_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.MONITOR_KEY;
-import static org.apache.dubbo.common.constants.RegistryConstants.CATEGORY_KEY;
-import static org.apache.dubbo.common.constants.RegistryConstants.CONFIGURATORS_CATEGORY;
-import static org.apache.dubbo.registry.Constants.CONFIGURATORS_SUFFIX;
-import static org.apache.dubbo.common.constants.RegistryConstants.CONSUMERS_CATEGORY;
-import static org.apache.dubbo.registry.Constants.CONSUMER_PROTOCOL;
-import static org.apache.dubbo.registry.Constants.DEFAULT_REGISTRY;
-import static org.apache.dubbo.registry.Constants.EXTRA_KEYS_KEY;
-import static org.apache.dubbo.common.constants.RegistryConstants.OVERRIDE_PROTOCOL;
-import static org.apache.dubbo.common.constants.RegistryConstants.PROVIDERS_CATEGORY;
-import static org.apache.dubbo.registry.Constants.PROVIDER_PROTOCOL;
-import static org.apache.dubbo.registry.Constants.REGISTER_KEY;
-import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_KEY;
-import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_PROTOCOL;
-import static org.apache.dubbo.common.constants.RegistryConstants.ROUTERS_CATEGORY;
-import static org.apache.dubbo.registry.Constants.SIMPLIFIED_KEY;
-import static org.apache.dubbo.remoting.Constants.BIND_IP_KEY;
-import static org.apache.dubbo.remoting.Constants.BIND_PORT_KEY;
-import static org.apache.dubbo.remoting.Constants.CHECK_KEY;
-import static org.apache.dubbo.remoting.Constants.CODEC_KEY;
-import static org.apache.dubbo.remoting.Constants.EXCHANGER_KEY;
-import static org.apache.dubbo.remoting.Constants.SERIALIZATION_KEY;
-import static org.apache.dubbo.remoting.Constants.CONNECTIONS_KEY;
-import static org.apache.dubbo.remoting.Constants.DUBBO_VERSION_KEY;
-import static org.apache.dubbo.rpc.Constants.DEPRECATED_KEY;
-import static org.apache.dubbo.rpc.Constants.INTERFACES;
-import static org.apache.dubbo.rpc.Constants.MOCK_KEY;
-import static org.apache.dubbo.rpc.Constants.TOKEN_KEY;
-import static org.apache.dubbo.common.utils.UrlUtils.classifyUrls;
-
-/**
- * RegistryProtocol
- */
-public class RegistryProtocol implements Protocol {
-    public static final String[] DEFAULT_REGISTER_PROVIDER_KEYS = {
-            APPLICATION_KEY, CODEC_KEY, EXCHANGER_KEY, SERIALIZATION_KEY, CLUSTER_KEY, CONNECTIONS_KEY, DEPRECATED_KEY,
-            GROUP_KEY, LOADBALANCE_KEY, MOCK_KEY, PATH_KEY, TIMEOUT_KEY, TOKEN_KEY, VERSION_KEY, WARMUP_KEY,
-            WEIGHT_KEY, TIMESTAMP_KEY, DUBBO_VERSION_KEY, RELEASE_KEY
-    };
-
-    public static final String[] DEFAULT_REGISTER_CONSUMER_KEYS = {
-            APPLICATION_KEY, VERSION_KEY, GROUP_KEY, DUBBO_VERSION_KEY, RELEASE_KEY
-    };
-
-    private final static Logger logger = LoggerFactory.getLogger(RegistryProtocol.class);
-    private static RegistryProtocol INSTANCE;
-    private final Map<URL, NotifyListener> overrideListeners = new ConcurrentHashMap<>();
-    private final Map<String, ServiceConfigurationListener> serviceConfigurationListeners = new ConcurrentHashMap<>();
-    private final ProviderConfigurationListener providerConfigurationListener = new ProviderConfigurationListener();
-    //To solve the problem of RMI repeated exposure port conflicts, the services that have been exposed are no longer exposed.
-    //providerurl <--> exporter
-    private final ConcurrentMap<String, ExporterChangeableWrapper<?>> bounds = new ConcurrentHashMap<>();
-    private Cluster cluster;
-    private Protocol protocol;
-    private RegistryFactory registryFactory;
-    private ProxyFactory proxyFactory;
-
-    public RegistryProtocol() {
-        INSTANCE = this;
-    }
-
-    public static RegistryProtocol getRegistryProtocol() {
-        if (INSTANCE == null) {
-            ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(REGISTRY_PROTOCOL); // load
-        }
-        return INSTANCE;
-    }
-
-    //Filter the parameters that do not need to be output in url(Starting with .)
-    private static String[] getFilteredKeys(URL url) {
-        Map<String, String> params = url.getParameters();
-        if (CollectionUtils.isNotEmptyMap(params)) {
-            return params.keySet().stream()
-                    .filter(k -> k.startsWith(HIDE_KEY_PREFIX))
-                    .toArray(String[]::new);
-        } else {
-            return new String[0];
-        }
-    }
-
-    public void setCluster(Cluster cluster) {
-        this.cluster = cluster;
-    }
-
-    public void setProtocol(Protocol protocol) {
-        this.protocol = protocol;
-    }
-
-    public void setRegistryFactory(RegistryFactory registryFactory) {
-        this.registryFactory = registryFactory;
-    }
-
-    public void setProxyFactory(ProxyFactory proxyFactory) {
-        this.proxyFactory = proxyFactory;
-    }
-
-    @Override
-    public int getDefaultPort() {
-        return 9090;
-    }
-
-    public Map<URL, NotifyListener> getOverrideListeners() {
-        return overrideListeners;
-    }
-
-    public void register(URL registryUrl, URL registeredProviderUrl) {
-        Registry registry = registryFactory.getRegistry(registryUrl);
-        registry.register(registeredProviderUrl);
-    }
-
-    public void unregister(URL registryUrl, URL registeredProviderUrl) {
-        Registry registry = registryFactory.getRegistry(registryUrl);
-        registry.unregister(registeredProviderUrl);
-    }
-
-    @Override
-    public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {
-        URL registryUrl = getRegistryUrl(originInvoker);
-        // url to export locally
-        URL providerUrl = getProviderUrl(originInvoker);
-
-        // Subscribe the override data
-        // FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call
-        //  the same service. Because the subscribed is cached key with the name of the service, it causes the
-        //  subscription information to cover.
-        final URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);
-        final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);
-        overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);
-
-        providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);
-        //export invoker
-        final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker, providerUrl);
-
-        // url to registry
-        final Registry registry = getRegistry(originInvoker);
-        final URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);
-        ProviderInvokerWrapper<T> providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,
-                registryUrl, registeredProviderUrl);
-        //to judge if we need to delay publish
-        boolean register = registeredProviderUrl.getParameter(""register"", true);
-        if (register) {
-            register(registryUrl, registeredProviderUrl);
-            providerInvokerWrapper.setReg(true);
-        }
-
-        // Deprecated! Subscribe to override rules in 2.6.x or before.
-        registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);
-
-        exporter.setRegisterUrl(registeredProviderUrl);
-        exporter.setSubscribeUrl(overrideSubscribeUrl);
-        //Ensure that a new exporter instance is returned every time export
-        return new DestroyableExporter<>(exporter);
-    }
-
-    private URL overrideUrlWithConfig(URL providerUrl, OverrideListener listener) {
-        providerUrl = providerConfigurationListener.overrideUrl(providerUrl);
-        ServiceConfigurationListener serviceConfigurationListener = new ServiceConfigurationListener(providerUrl, listener);
-        serviceConfigurationListeners.put(providerUrl.getServiceKey(), serviceConfigurationListener);
-        return serviceConfigurationListener.overrideUrl(providerUrl);
-    }
-
-    @SuppressWarnings(""unchecked"")
-    private <T> ExporterChangeableWrapper<T> doLocalExport(final Invoker<T> originInvoker, URL providerUrl) {
-        String key = getCacheKey(originInvoker);
-
-        return (ExporterChangeableWrapper<T>) bounds.computeIfAbsent(key, s -> {
-            Invoker<?> invokerDelegate = new InvokerDelegate<>(originInvoker, providerUrl);
-            return new ExporterChangeableWrapper<>((Exporter<T>) protocol.export(invokerDelegate), originInvoker);
-        });
-    }
-
-    public <T> void reExport(final Invoker<T> originInvoker, URL newInvokerUrl) {
-        // update local exporter
-        ExporterChangeableWrapper exporter = doChangeLocalExport(originInvoker, newInvokerUrl);
-        // update registry
-        URL registryUrl = getRegistryUrl(originInvoker);
-        final URL registeredProviderUrl = getRegisteredProviderUrl(newInvokerUrl, registryUrl);
-
-        //decide if we need to re-publish
-        ProviderInvokerWrapper<T> providerInvokerWrapper = ProviderConsumerRegTable.getProviderWrapper(registeredProviderUrl, originInvoker);
-        ProviderInvokerWrapper<T> newProviderInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);
-        /**
-         * Only if the new url going to Registry is different with the previous one should we do unregister and register.
-         */
-        if (providerInvokerWrapper.isReg() && !registeredProviderUrl.equals(providerInvokerWrapper.getProviderUrl())) {
-            unregister(registryUrl, providerInvokerWrapper.getProviderUrl());
-            register(registryUrl, registeredProviderUrl);
-            newProviderInvokerWrapper.setReg(true);
-        }
-
-        exporter.setRegisterUrl(registeredProviderUrl);
-    }
-
-    /**
-     * Reexport the invoker of the modified url
-     *
-     * @param originInvoker
-     * @param newInvokerUrl
-     */
-    @SuppressWarnings(""unchecked"")
-    private <T> ExporterChangeableWrapper doChangeLocalExport(final Invoker<T> originInvoker, URL newInvokerUrl) {
-        String key = getCacheKey(originInvoker);
-        final ExporterChangeableWrapper<T> exporter = (ExporterChangeableWrapper<T>) bounds.get(key);
-        if (exporter == null) {
-            logger.warn(new IllegalStateException(""error state, exporter should not be null""));
-        } else {
-            final Invoker<T> invokerDelegate = new InvokerDelegate<T>(originInvoker, newInvokerUrl);
-            exporter.setExporter(protocol.export(invokerDelegate));
-        }
-        return exporter;
-    }
-
-    /**
-     * Get an instance of registry based on the address of invoker
-     *
-     * @param originInvoker
-     * @return
-     */
-    private Registry getRegistry(final Invoker<?> originInvoker) {
-        URL registryUrl = getRegistryUrl(originInvoker);
-        return registryFactory.getRegistry(registryUrl);
-    }
-
-    private URL getRegistryUrl(Invoker<?> originInvoker) {
-        URL registryUrl = originInvoker.getUrl();
-        if (REGISTRY_PROTOCOL.equals(registryUrl.getProtocol())) {
-            String protocol = registryUrl.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY);
-            registryUrl = registryUrl.setProtocol(protocol).removeParameter(REGISTRY_KEY);
-        }
-        return registryUrl;
-    }
-
-
-    /**
-     * Return the url that is registered to the registry and filter the url parameter once
-     *
-     * @param providerUrl
-     * @return url to registry.
-     */
-    private URL getRegisteredProviderUrl(final URL providerUrl, final URL registryUrl) {
-        //The address you see at the registry
-        if (!registryUrl.getParameter(SIMPLIFIED_KEY, false)) {
-            return providerUrl.removeParameters(getFilteredKeys(providerUrl)).removeParameters(
-                    MONITOR_KEY, BIND_IP_KEY, BIND_PORT_KEY, QOS_ENABLE, QOS_PORT, ACCEPT_FOREIGN_IP, VALIDATION_KEY,
-                    INTERFACES);
-        } else {
-            String extraKeys = registryUrl.getParameter(EXTRA_KEYS_KEY, """");
-            // if path is not the same as interface name then we should keep INTERFACE_KEY,
-            // otherwise, the registry structure of zookeeper would be '/dubbo/path/providers',
-            // but what we expect is '/dubbo/interface/providers'
-            if (!providerUrl.getPath().equals(providerUrl.getParameter(INTERFACE_KEY))) {
-                if (StringUtils.isNotEmpty(extraKeys)) {
-                    extraKeys += "","";
-                }
-                extraKeys += INTERFACE_KEY;
-            }
-            String[] paramsToRegistry = getParamsToRegistry(DEFAULT_REGISTER_PROVIDER_KEYS
-                    , COMMA_SPLIT_PATTERN.split(extraKeys));
-            return URL.valueOf(providerUrl, paramsToRegistry, providerUrl.getParameter(METHODS_KEY, (String[]) null));
-        }
-
-    }
-
-    private URL getSubscribedOverrideUrl(URL registeredProviderUrl) {
-        return registeredProviderUrl.setProtocol(PROVIDER_PROTOCOL)
-                .addParameters(CATEGORY_KEY, CONFIGURATORS_CATEGORY, CHECK_KEY, String.valueOf(false));
-    }
-
-    /**
-     * Get the address of the providerUrl through the url of the invoker
-     *
-     * @param originInvoker
-     * @return
-     */
-    private URL getProviderUrl(final Invoker<?> originInvoker) {
-        String export = originInvoker.getUrl().getParameterAndDecoded(EXPORT_KEY);
-        if (export == null || export.length() == 0) {
-            throw new IllegalArgumentException(""The registry export url is null! registry: "" + originInvoker.getUrl());
-        }
-        return URL.valueOf(export);
-    }
-
-    /**
-     * Get the key cached in bounds by invoker
-     *
-     * @param originInvoker
-     * @return
-     */
-    private String getCacheKey(final Invoker<?> originInvoker) {
-        URL providerUrl = getProviderUrl(originInvoker);
-        String key = providerUrl.removeParameters(""dynamic"", ""enabled"").toFullString();
-        return key;
-    }
-
-    @Override
-    @SuppressWarnings(""unchecked"")
-    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
-        url = URLBuilder.from(url)
-                .setProtocol(url.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY))
-                .removeParameter(REGISTRY_KEY)
-                .build();
-        Registry registry = registryFactory.getRegistry(url);
-        if (RegistryService.class.equals(type)) {
-            return proxyFactory.getInvoker((T) registry, type, url);
-        }
-
-        // group=""a,b"" or group=""*""
-        Map<String, String> qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));
-        String group = qs.get(GROUP_KEY);
-        if (group != null && group.length() > 0) {
-            if ((COMMA_SPLIT_PATTERN.split(group)).length > 1 || ""*"".equals(group)) {
-                return doRefer(getMergeableCluster(), registry, type, url);
-            }
-        }
-        return doRefer(cluster, registry, type, url);
-    }
-
-    private Cluster getMergeableCluster() {
-        return ExtensionLoader.getExtensionLoader(Cluster.class).getExtension(""mergeable"");
-    }
-
-    private <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {
-        RegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);
-        directory.setRegistry(registry);
-        directory.setProtocol(protocol);
-        // all attributes of REFER_KEY
-        Map<String, String> parameters = new HashMap<String, String>(directory.getUrl().getParameters());
-        URL subscribeUrl = new URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);
-        if (!ANY_VALUE.equals(url.getServiceInterface()) && url.getParameter(REGISTER_KEY, true)) {
-            directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));
-            registry.register(directory.getRegisteredConsumerUrl());
-        }
-        directory.buildRouterChain(subscribeUrl);
-        directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,
-                PROVIDERS_CATEGORY + "","" + CONFIGURATORS_CATEGORY + "","" + ROUTERS_CATEGORY));
-
-        Invoker invoker = cluster.join(directory);
-        ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);
-        return invoker;
-    }
-
-    public URL getRegisteredConsumerUrl(final URL consumerUrl, URL registryUrl) {
-        if (!registryUrl.getParameter(SIMPLIFIED_KEY, false)) {
-            return consumerUrl.addParameters(CATEGORY_KEY, CONSUMERS_CATEGORY,
-                    CHECK_KEY, String.valueOf(false));
-        } else {
-            return URL.valueOf(consumerUrl, DEFAULT_REGISTER_CONSUMER_KEYS, null).addParameters(
-                    CATEGORY_KEY, CONSUMERS_CATEGORY, CHECK_KEY, String.valueOf(false));
-        }
-    }
-
-    // available to test
-    public String[] getParamsToRegistry(String[] defaultKeys, String[] additionalParameterKeys) {
-        int additionalLen = additionalParameterKeys.length;
-        String[] registryParams = new String[defaultKeys.length + additionalLen];
-        System.arraycopy(defaultKeys, 0, registryParams, 0, defaultKeys.length);
-        System.arraycopy(additionalParameterKeys, 0, registryParams, defaultKeys.length, additionalLen);
-        return registryParams;
-    }
-
-    @Override
-    public void destroy() {
-        List<Exporter<?>> exporters = new ArrayList<Exporter<?>>(bounds.values());
-        for (Exporter<?> exporter : exporters) {
-            exporter.unexport();
-        }
-        bounds.clear();
-
-        DynamicConfiguration.getDynamicConfiguration()
-                .removeListener(ApplicationModel.getApplication() + CONFIGURATORS_SUFFIX, providerConfigurationListener);
-    }
-
-    //Merge the urls of configurators
-    private static URL getConfigedInvokerUrl(List<Configurator> configurators, URL url) {
-        if (configurators != null && configurators.size() > 0) {
-            for (Configurator configurator : configurators) {
-                url = configurator.configure(url);
-            }
-        }
-        return url;
-    }
-
-    public static class InvokerDelegate<T> extends InvokerWrapper<T> {
-        private final Invoker<T> invoker;
-
-        /**
-         * @param invoker
-         * @param url     invoker.getUrl return this value
-         */
-        public InvokerDelegate(Invoker<T> invoker, URL url) {
-            super(invoker, url);
-            this.invoker = invoker;
-        }
-
-        public Invoker<T> getInvoker() {
-            if (invoker instanceof InvokerDelegate) {
-                return ((InvokerDelegate<T>) invoker).getInvoker();
-            } else {
-                return invoker;
-            }
-        }
-    }
-
-    static private class DestroyableExporter<T> implements Exporter<T> {
-
-        private Exporter<T> exporter;
-
-        public DestroyableExporter(Exporter<T> exporter) {
-            this.exporter = exporter;
-        }
-
-        @Override
-        public Invoker<T> getInvoker() {
-            return exporter.getInvoker();
-        }
-
-        @Override
-        public void unexport() {
-            exporter.unexport();
-        }
-    }
-
-    /**
-     * Reexport: the exporter destroy problem in protocol
-     * 1.Ensure that the exporter returned by registryprotocol can be normal destroyed
-     * 2.No need to re-register to the registry after notify
-     * 3.The invoker passed by the export method , would better to be the invoker of exporter
-     */
-    private class OverrideListener implements NotifyListener {
-        private final URL subscribeUrl;
-        private final Invoker originInvoker;
-
-
-        private List<Configurator> configurators;
-
-        public OverrideListener(URL subscribeUrl, Invoker originalInvoker) {
-            this.subscribeUrl = subscribeUrl;
-            this.originInvoker = originalInvoker;
-        }
-
-        /**
-         * @param urls The list of registered information, is always not empty, The meaning is the same as the
-         *             return value of {@link org.apache.dubbo.registry.RegistryService#lookup(URL)}.
-         */
-        @Override
-        public synchronized void notify(List<URL> urls) {
-            logger.debug(""original override urls: "" + urls);
-
-            List<URL> matchedUrls = getMatchedUrls(urls, subscribeUrl.addParameter(CATEGORY_KEY,
-                    CONFIGURATORS_CATEGORY));
-            logger.debug(""subscribe url: "" + subscribeUrl + "", override urls: "" + matchedUrls);
-
-            // No matching results
-            if (matchedUrls.isEmpty()) {
-                return;
-            }
-
-            this.configurators = Configurator.toConfigurators(classifyUrls(matchedUrls, UrlUtils::isConfigurator))
-                    .orElse(configurators);
-
-            doOverrideIfNecessary();
-        }
-
-        public synchronized void doOverrideIfNecessary() {
-            final Invoker<?> invoker;
-            if (originInvoker instanceof InvokerDelegate) {
-                invoker = ((InvokerDelegate<?>) originInvoker).getInvoker();
-            } else {
-                invoker = originInvoker;
-            }
-            //The origin invoker
-            URL originUrl = RegistryProtocol.this.getProviderUrl(invoker);
-            String key = getCacheKey(originInvoker);
-            ExporterChangeableWrapper<?> exporter = bounds.get(key);
-            if (exporter == null) {
-                logger.warn(new IllegalStateException(""error state, exporter should not be null""));
-                return;
-            }
-            //The current, may have been merged many times
-            URL currentUrl = exporter.getInvoker().getUrl();
-            //Merged with this configuration
-            URL newUrl = getConfigedInvokerUrl(configurators, originUrl);
-            newUrl = getConfigedInvokerUrl(serviceConfigurationListeners.get(originUrl.getServiceKey())
-                    .getConfigurators(), newUrl);
-            newUrl = getConfigedInvokerUrl(providerConfigurationListener.getConfigurators(), newUrl);
-            if (!currentUrl.equals(newUrl)) {
-                RegistryProtocol.this.reExport(originInvoker, newUrl);
-                logger.info(""exported provider url changed, origin url: "" + originUrl +
-                        "", old export url: "" + currentUrl + "", new export url: "" + newUrl);
-            }
-        }
-
-        private List<URL> getMatchedUrls(List<URL> configuratorUrls, URL currentSubscribe) {
-            List<URL> result = new ArrayList<URL>();
-            for (URL url : configuratorUrls) {
-                URL overrideUrl = url;
-                // Compatible with the old version
-                if (url.getParameter(CATEGORY_KEY) == null && OVERRIDE_PROTOCOL.equals(url.getProtocol())) {
-                    overrideUrl = url.addParameter(CATEGORY_KEY, CONFIGURATORS_CATEGORY);
-                }
-
-                // Check whether url is to be applied to the current service
-                if (UrlUtils.isMatch(currentSubscribe, overrideUrl)) {
-                    result.add(url);
-                }
-            }
-            return result;
-        }
-    }
-
-    private class ServiceConfigurationListener extends AbstractConfiguratorListener {
-        private URL providerUrl;
-        private OverrideListener notifyListener;
-
-        public ServiceConfigurationListener(URL providerUrl, OverrideListener notifyListener) {
-            this.providerUrl = providerUrl;
-            this.notifyListener = notifyListener;
-            this.initWith(providerUrl.getEncodedServiceKey() + CONFIGURATORS_SUFFIX);
-        }
-
-        private <T> URL overrideUrl(URL providerUrl) {
-            return RegistryProtocol.getConfigedInvokerUrl(configurators, providerUrl);
-        }
-
-        @Override
-        protected void notifyOverrides() {
-            notifyListener.doOverrideIfNecessary();
-        }
-    }
-
-    private class ProviderConfigurationListener extends AbstractConfiguratorListener {
-
-        public ProviderConfigurationListener() {
-            this.initWith(ApplicationModel.getApplication() + CONFIGURATORS_SUFFIX);
-        }
-
-        /**
-         * Get existing configuration rule and override provider url before exporting.
-         *
-         * @param providerUrl
-         * @param <T>
-         * @return
-         */
-        private <T> URL overrideUrl(URL providerUrl) {
-            return RegistryProtocol.getConfigedInvokerUrl(configurators, providerUrl);
-        }
-
-        @Override
-        protected void notifyOverrides() {
-            overrideListeners.values().forEach(listener -> ((OverrideListener) listener).doOverrideIfNecessary());
-        }
-    }
-
-    /**
-     * exporter proxy, establish the corresponding relationship between the returned exporter and the exporter
-     * exported by the protocol, and can modify the relationship at the time of override.
-     *
-     * @param <T>
-     */
-    private class ExporterChangeableWrapper<T> implements Exporter<T> {
-
-        private final ExecutorService executor = newSingleThreadExecutor(new NamedThreadFactory(""Exporter-Unexport"", true));
-
-        private final Invoker<T> originInvoker;
-        private Exporter<T> exporter;
-        private URL subscribeUrl;
-        private URL registerUrl;
-
-        public ExporterChangeableWrapper(Exporter<T> exporter, Invoker<T> originInvoker) {
-            this.exporter = exporter;
-            this.originInvoker = originInvoker;
-        }
-
-        public Invoker<T> getOriginInvoker() {
-            return originInvoker;
-        }
-
-        @Override
-        public Invoker<T> getInvoker() {
-            return exporter.getInvoker();
-        }
-
-        public void setExporter(Exporter<T> exporter) {
-            this.exporter = exporter;
-        }
-
-        @Override
-        public void unexport() {
-            String key = getCacheKey(this.originInvoker);
-            bounds.remove(key);
-
-            Registry registry = RegistryProtocol.INSTANCE.getRegistry(originInvoker);
-            try {
-                registry.unregister(registerUrl);
-            } catch (Throwable t) {
-                logger.warn(t.getMessage(), t);
-            }
-            try {
-                NotifyListener listener = RegistryProtocol.INSTANCE.overrideListeners.remove(subscribeUrl);
-                registry.unsubscribe(subscribeUrl, listener);
-                DynamicConfiguration.getDynamicConfiguration()
-                        .removeListener(subscribeUrl.getServiceKey() + CONFIGURATORS_SUFFIX,
-                                serviceConfigurationListeners.get(subscribeUrl.getServiceKey()));
-            } catch (Throwable t) {
-                logger.warn(t.getMessage(), t);
-            }
-
-            executor.submit(() -> {
-                try {
-                    int timeout = ConfigurationUtils.getServerShutdownTimeout();
-                    if (timeout > 0) {
-                        logger.info(""Waiting "" + timeout + ""ms for registry to notify all consumers before unexport. "" +
-                                ""Usually, this is called when you use dubbo API"");
-                        Thread.sleep(timeout);
-                    }
-                    exporter.unexport();
-                } catch (Throwable t) {
-                    logger.warn(t.getMessage(), t);
-                }
-            });
-        }
-
-        public void setSubscribeUrl(URL subscribeUrl) {
-            this.subscribeUrl = subscribeUrl;
-        }
-
-        public void setRegisterUrl(URL registerUrl) {
-            this.registerUrl = registerUrl;
-        }
-    }
-}
+/*","[{'comment': 'Please do not change the line ending. ', 'commenter': 'ralf0131'}]"
4195,dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/MetricsFilterTest.java,"@@ -16,72 +16,64 @@
  */
 package org.apache.dubbo.monitor.dubbo;
 
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.utils.NetUtils;
-import org.apache.dubbo.monitor.MetricsService;
-import org.apache.dubbo.monitor.dubbo.service.DemoService;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Protocol;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.RpcContext;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.RpcInvocation;
-import org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol;
-
 import com.alibaba.metrics.FastCompass;
+import com.alibaba.metrics.Gauge;
 import com.alibaba.metrics.IMetricManager;
+import com.alibaba.metrics.MetricFilter;
 import com.alibaba.metrics.MetricLevel;
 import com.alibaba.metrics.MetricManager;
 import com.alibaba.metrics.MetricName;
 import com.alibaba.metrics.common.MetricObject;
 import com.google.gson.Gson;
 import com.google.gson.reflect.TypeToken;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.monitor.MetricsService;
+import org.apache.dubbo.monitor.dubbo.service.DemoService;
+import org.apache.dubbo.rpc.*;
+import org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol;
+
 import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.mockito.Mockito;
 
+import java.io.IOException;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.SortedMap;
+import java.util.concurrent.atomic.AtomicLong;
 
-import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SIDE;
-import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER;
-import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;
-import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;
-import static org.apache.dubbo.monitor.Constants.DUBBO_CONSUMER;
-import static org.apache.dubbo.monitor.Constants.DUBBO_CONSUMER_METHOD;
-import static org.apache.dubbo.monitor.Constants.DUBBO_GROUP;
-import static org.apache.dubbo.monitor.Constants.DUBBO_PROVIDER;
-import static org.apache.dubbo.monitor.Constants.DUBBO_PROVIDER_METHOD;
-import static org.apache.dubbo.monitor.Constants.METHOD;
-import static org.apache.dubbo.monitor.Constants.SERVICE;
+import static org.apache.dubbo.common.constants.CommonConstants.*;","[{'comment': ""It is not recommended to import '*'"", 'commenter': 'ralf0131'}]"
4195,dubbo-monitor/dubbo-monitor-default/src/main/java/org/apache/dubbo/monitor/dubbo/MetricsFilter.java,"@@ -123,6 +127,26 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept
         }
     }
 
+    private void reportLbMetrics(Result result, Invoker<?> invoker, boolean isProvider) {","[{'comment': 'I think the logic of this method should be done in a dedicated thread, which will periodically update the cpu usage if necessary. \r\nWhat could be done here is just get the cpu.user data and put it into attachment.\r\nI also think it is no necessary to create CpuUsageGauge, just use com.alibaba.metrics.os.linux.CpuUsageGaugeSet, it has done almost everything for you. You just need to make sure the com.alibaba.metrics.CachedMetricSet#refreshIfNecessary is called periodically so that you can always get the latest data.\r\n', 'commenter': 'ralf0131'}]"
4195,dubbo-monitor/dubbo-monitor-default/src/test/java/org/apache/dubbo/monitor/dubbo/MetricsFilterTest.java,"@@ -56,32 +59,32 @@
 import static org.apache.dubbo.monitor.Constants.DUBBO_PROVIDER_METHOD;
 import static org.apache.dubbo.monitor.Constants.METHOD;
 import static org.apache.dubbo.monitor.Constants.SERVICE;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.mock;
 
 public class MetricsFilterTest {
 
-    private final Invoker<DemoService> serviceInvoker = new Invoker<DemoService>() {
-        @Override
-        public Class<DemoService> getInterface() {
-            return DemoService.class;
-        }
+    private Invoker<DemoService> serviceInvoker;
 
-        public URL getUrl() {
-            return URL.valueOf(""dubbo://"" + NetUtils.getLocalHost() + "":20880/org.apache.dubbo.monitor.dubbo.service.DemoService"");
-        }
+    @BeforeEach","[{'comment': '@ralf0131 In the first version of PR, I made these changes to make it easier to create new unit tests (is using Mockito).\r\n\r\nShould I remove this modification or open a new PR? ', 'commenter': 'danielamorais'}, {'comment': 'If it is un-related, it would be better to create a separate one.', 'commenter': 'ralf0131'}]"
4195,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/StatisticsLoadBalance.java,"@@ -0,0 +1,26 @@
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.monitor.dubbo.CpuUsageService;
+import org.apache.dubbo.monitor.dubbo.CpuUsageServiceImpl;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class StatisticsLoadBalance extends AbstractLoadBalance {
+
+    private Map<String, Float> cpuUsage = new HashMap<>();
+
+    public StatisticsLoadBalance() {
+        CpuUsageService cpuUsageService = new CpuUsageServiceImpl(100L, 500L);","[{'comment': '@ralf0131 Should I add these parameters as properties that could change in this PR?', 'commenter': 'danielamorais'}, {'comment': 'Hi, I think they should be configurable.', 'commenter': 'ralf0131'}]"
4195,dubbo-monitor/dubbo-monitor-default/src/main/java/org/apache/dubbo/monitor/dubbo/CpuUsageServiceImpl.java,"@@ -0,0 +1,42 @@
+package org.apache.dubbo.monitor.dubbo;","[{'comment': ""I'm not sure if should be at package org.apache.dubbo.monitor.dubbo; or move to dubbo-cluster"", 'commenter': 'danielamorais'}, {'comment': 'Hi, I think put it under dubbo-cluster is ok.  Maybe you can create a new package called `org.apache.dubbo.rpc.cluster.loadbalance.statistics`, and put it there.', 'commenter': 'ralf0131'}]"
4195,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/StatisticsLoadBalance.java,"@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.config.ConfigurationUtils;
+import org.apache.dubbo.rpc.cluster.loadbalance.statistics.CpuUsageService;
+import org.apache.dubbo.rpc.cluster.loadbalance.statistics.CpuUsageServiceImpl;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class StatisticsLoadBalance extends AbstractLoadBalance {
+
+    private Map<String, Float> cpuUsage = new HashMap<>();","[{'comment': 'There could be multi-threading invocations.\r\nChoose an another thread-safe collection instead of HashMap.', 'commenter': 'guohao'}]"
4195,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/StatisticsLoadBalance.java,"@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.config.ConfigurationUtils;
+import org.apache.dubbo.rpc.cluster.loadbalance.statistics.CpuUsageService;
+import org.apache.dubbo.rpc.cluster.loadbalance.statistics.CpuUsageServiceImpl;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class StatisticsLoadBalance extends AbstractLoadBalance {
+
+    private Map<String, Float> cpuUsage = new HashMap<>();
+
+    public StatisticsLoadBalance() {
+        long timeToLive = Long.parseLong(ConfigurationUtils.getProperty(""time.to.live""));
+        long collectCpuUsageInMill = Long.parseLong(ConfigurationUtils.getProperty(""mill.to.collect.cpu.usage""));
+        CpuUsageService cpuUsageService = new CpuUsageServiceImpl(timeToLive, collectCpuUsageInMill);","[{'comment': ""CpuUsageService should be created by dubbo as  a remote stub instead of 'new' directly."", 'commenter': 'guohao'}, {'comment': 'What do you think about using SPI mechanism? (http://dubbo.apache.org/en-us/blog/introduction-to-dubbo-spi.html)', 'commenter': 'danielamorais'}, {'comment': 'Hi, \r\n\r\nI did some local test, the proposed pull request could not work correctly. If you start two provider and a consumer, you can see that cpu usage is not being sent from provider to consumer.\r\n\r\nI agree with @guohao that, we need to call the CpuUsageService remotely to add listener rather that `new` directly, and if there are multiple providers, we have to call the addListener method for each provider. \r\n\r\nThe problem is the StatisticsLoadBalance is a bean managed by Spring, so it is impossible to get the provider ip addresses when initializing StatisticsLoadBalance class. So we have to delay the call the addListener to the `doSelect` method.\r\n\r\nTo obtain a proxy for remote service, you may checkout `org.apache.dubbo.monitor.dubbo.DubboMonitorFactory#createMonitor`, there are some example code.\r\n\r\nSince it is lazy to obtain the cpu usage, the load balance may not working very well during the initial period of time (lack of cpu usage stat), so there should be some fall back strategies, once the cpu stat are collected, the stat based load balance can be activated.', 'commenter': 'ralf0131'}]"
4195,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/statistics/CpuUsageListener.java,"@@ -0,0 +1,21 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.loadbalance.statistics;
+
+public interface CpuUsageListener {
+    void cpuChanged(String ip, Float cpu);","[{'comment': 'Consider a scenario that two dubbo application running on different nodes but share  same IP( NAT ). \r\nWhich cpu usage info will be used  here?  How to deal with this problem ?\r\n', 'commenter': 'guohao'}, {'comment': 'Good catch, thanks. I think it should use IP and the port to avoid this. ', 'commenter': 'danielamorais'}, {'comment': '@ralf0131 What do you think?', 'commenter': 'danielamorais'}, {'comment': 'Hi, \r\n\r\nip + port should be enough for this case.', 'commenter': 'ralf0131'}]"
4195,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/StatisticsLoadBalance.java,"@@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.config.ConfigurationUtils;
+import org.apache.dubbo.rpc.cluster.loadbalance.statistics.CpuUsageListener;
+import org.apache.dubbo.rpc.cluster.loadbalance.statistics.CpuUsageService;
+import org.apache.dubbo.rpc.cluster.loadbalance.statistics.CpuUsageServiceImpl;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.cluster.loadbalance.statistics.DubboCpuUsageFactory;
+
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class StatisticsLoadBalance extends AbstractLoadBalance {
+
+    private Map<String, Float> cpuUsage = new ConcurrentHashMap<>();
+    private DubboCpuUsageFactory dubboCpuUsageFactory;
+    private Map<String, CpuUsageListener> listeners = new ConcurrentHashMap<>();
+
+    public StatisticsLoadBalance() {
+        long timeToLive = Long.parseLong(ConfigurationUtils.getProperty(""time.to.live""));
+        long collectCpuUsageInMill = Long.parseLong(ConfigurationUtils.getProperty(""mill.to.collect.cpu.usage""));
+        CpuUsageService cpuUsageService = new CpuUsageServiceImpl(timeToLive, collectCpuUsageInMill);
+        cpuUsageService.addListener(""statisticsloadbalance"", (ip, cpu) -> cpuUsage.put(ip, cpu));
+    }
+
+    @Override
+    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
+        int index = (int)(invokers.size() * Math.random());
+        Invoker<T> invoker = invokers.get(index);
+        cpuUsage.computeIfAbsent(invoker.getUrl().getAddress(), value -> {","[{'comment': 'Listener will be  invalid when provider restart.  An address listener that  removes offline addresses may be needed.', 'commenter': 'guohao'}, {'comment': 'Good catch, thanks.', 'commenter': 'danielamorais'}]"
4195,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/statistics/DubboCpuUsageFactory.java,"@@ -0,0 +1,57 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.loadbalance.statistics;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.URLBuilder;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.ProxyFactory;
+import org.apache.dubbo.rpc.cluster.CpuUsageFactory;
+
+import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_PROTOCOL;
+import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_KEY;
+import static org.apache.dubbo.remoting.Constants.CHECK_KEY;
+import static org.apache.dubbo.rpc.Constants.REFERENCE_FILTER_KEY;
+
+public class DubboCpuUsageFactory implements CpuUsageFactory {
+
+    private Protocol protocol;
+
+    private ProxyFactory proxyFactory;
+
+    @Override
+    public CpuUsageService createCpuUsageService(URL url) {
+        URLBuilder urlBuilder = URLBuilder.from(url);
+        urlBuilder.setProtocol(url.getParameter(PROTOCOL_KEY, DUBBO_PROTOCOL));
+        urlBuilder.addParameters(CHECK_KEY, String.valueOf(false), REFERENCE_FILTER_KEY, """");
+        urlBuilder.addParameter(""addListener.1.callback"", true);
+        urlBuilder.setPath(CpuUsageService.class.getName());
+
+        Invoker<CpuUsageService> cpuUsageInvoker = protocol.refer(CpuUsageService.class, urlBuilder.build());
+        return proxyFactory.getProxy(cpuUsageInvoker);","[{'comment': '@ralf0131 The class which implements CpuUsageService has a default constructor that schedule the thread to collect CPU Usage. \r\nQuestions:\r\n1) Should I call the default constructor? Does the proxyFactory do it?\r\n2) In dubbo-provider.xml I added:\r\n```xml\r\n<bean id=""cpuUsageService"" class=""org.apache.dubbo.rpc.cluster.loadbalance.statistics.CpuUsageServiceImpl""/>\r\n```\r\nWill Spring/Dubbo call the factory class (DubboCpuUsageServiceFactory)? ', 'commenter': 'danielamorais'}, {'comment': 'Hi, why do you need to create CpuUsageFactory? I think right now it is ok to put the logic to `StatisticsLoadBalance` and refactor it later.', 'commenter': 'ralf0131'}]"
4196,licenseCheck.sh,"@@ -78,6 +82,12 @@ allowLicense=(
     ""MIT""
     ""The 3-Clause BSD License""
     ""Public domain""
+    ""JSR.*107""
+    ""Common Public License Version 1.0""
+    ""org.scijava:native-lib-loader""","[{'comment': ""This array is for allowed license, and some of new added content is for package/dependencies level, I'm ok with this change and it should work.\r\nbut the variable name may need change? or this array can split to two, one for allowLicense, one for allow pacakge"", 'commenter': 'htynkn'}, {'comment': ""I agree with it. let's improve it later."", 'commenter': 'ralf0131'}]"
4203,dubbo-configcenter/dubbo-configcenter-nacos/src/main/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfiguration.java,"@@ -209,8 +196,7 @@ public String getConfigs(String key, String group, long timeout) throws IllegalS
     @Override
     public Object getInternalProperty(String key) {
         try {
-            String[] keyAndGroup = getKeyAndGroup(key);
-            return configService.getConfig(keyAndGroup[0], keyAndGroup[1], 5000L);
+            return configService.getConfig(key, null, DEFAULT_TIMEOUT);","[{'comment': 'why ignore the  group specified by user', 'commenter': 'uglycow'}, {'comment': 'The null value should be change to ""dubbo"" instead.', 'commenter': 'ralf0131'}]"
4203,dubbo-configcenter/dubbo-configcenter-nacos/src/main/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfiguration.java,"@@ -93,24 +97,14 @@ private ConfigService buildConfigService(URL url) {
         return configService;
     }
 
-    public void publishNacosConfig(String key, String value) {
+    public void publishNacosConfig(String key, String group, String value) {","[{'comment': ""I don't find the usage of this method."", 'commenter': 'cvictory'}, {'comment': 'It is in test code, see `NacosDynamicConfigurationTest`', 'commenter': 'ralf0131'}]"
4203,dubbo-configcenter/dubbo-configcenter-nacos/src/main/java/org/apache/dubbo/configcenter/support/nacos/NacosDynamicConfiguration.java,"@@ -157,48 +134,68 @@ private void putPropertyIfAbsent(URL url, Properties properties, String property
      * @return
      */
     private NacosConfigListener createTargetListener(String key, String group) {
+        String normalizedKey = normalizedKey(key);","[{'comment': 'duplicate call of `normalizedKey(key)`, the caller of createTargetListener() has already called the same method, so the key passed in is a normalized one.', 'commenter': 'chickenlj'}, {'comment': 'Fixed.', 'commenter': 'ralf0131'}]"
4208,dubbo-common/src/test/java/org/apache/dubbo/common/config/EnvironmentConfigurationTest.java,"@@ -0,0 +1,50 @@
+package org.apache.dubbo.common.config;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+/**","[{'comment': ""don't record author in dubbo"", 'commenter': 'Moriadry-zz'}, {'comment': 'fixed', 'commenter': 'slievrly'}]"
4208,dubbo-common/src/test/java/org/apache/dubbo/common/config/EnvironmentConfigurationTest.java,"@@ -0,0 +1,50 @@
+package org.apache.dubbo.common.config;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+/**
+ * @author slievrly
+ */
+class EnvironmentConfigurationTest {
+
+    private static EnvironmentConfiguration environmentConfig;
+    private static final String MOCK_KEY = ""mockKey"";
+    private static final String MOCK_VALUE = ""mockValue"";
+    private static final String PATH_KEY=""PATH"";
+
+    @BeforeEach
+    public void init() {
+
+        environmentConfig = new EnvironmentConfiguration();
+    }
+
+    @Test
+    public void testGetInternalProperty(){
+        Assertions.assertNull(environmentConfig.getInternalProperty(MOCK_KEY));
+        Assertions.assertEquals(System.getenv(PATH_KEY),environmentConfig.getInternalProperty(PATH_KEY));
+
+    }
+
+    @Test
+    public void testContainsKey(){
+        Assertions.assertTrue(environmentConfig.containsKey(PATH_KEY));
+        Assertions.assertFalse(environmentConfig.containsKey(MOCK_KEY));
+    }
+
+    @Test
+    public void testGetString(){
+        Assertions.assertNull(environmentConfig.getString(MOCK_KEY));
+        Assertions.assertEquals(MOCK_VALUE,environmentConfig.getString(MOCK_KEY,MOCK_VALUE));
+    }
+
+    @Test
+    public void testGetProperty(){
+        Assertions.assertNull(environmentConfig.getProperty(MOCK_KEY));
+        Assertions.assertEquals(MOCK_VALUE,environmentConfig.getProperty(MOCK_KEY,MOCK_VALUE));
+    }
+
+","[{'comment': 'pls make this one single line.', 'commenter': 'Moriadry-zz'}, {'comment': 'fixed', 'commenter': 'slievrly'}]"
4208,dubbo-common/src/test/java/org/apache/dubbo/common/config/InmemoryConfigurationTest.java,"@@ -0,0 +1,60 @@
+package org.apache.dubbo.common.config;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+/**
+ * @author slievrly","[{'comment': 'remove this.', 'commenter': 'Moriadry-zz'}, {'comment': 'fixed', 'commenter': 'slievrly'}]"
4208,dubbo-common/src/test/java/org/apache/dubbo/common/config/SystemConfigurationTest.java,"@@ -0,0 +1,75 @@
+package org.apache.dubbo.common.config;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+/**
+ * @author slievrly","[{'comment': 'another useless lines.', 'commenter': 'Moriadry-zz'}, {'comment': 'fixed', 'commenter': 'slievrly'}]"
4208,dubbo-common/src/test/java/org/apache/dubbo/common/config/SystemConfigurationTest.java,"@@ -0,0 +1,75 @@
+package org.apache.dubbo.common.config;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+/**
+ * @author slievrly
+ */
+class SystemConfigurationTest {
+
+    private static SystemConfiguration sysConfig;
+    private static final String MOCK_KEY = ""mockKey"";
+    private static final String MOCK_STRING_VALUE = ""mockValue"";
+    private static final Boolean MOCK_BOOL_VALUE = Boolean.FALSE;
+    private static final Integer MOCK_INT_VALUE = Integer.MAX_VALUE;
+    private static final Long MOCK_LONG_VALUE = Long.MIN_VALUE;
+    private static final Short MOCK_SHORT_VALUE = Short.MIN_VALUE;
+    private static final Float MOCK_FLOAT_VALUE = Float.MIN_VALUE;
+    private static final Double MOCK_DOUBLE_VALUE = Double.MIN_VALUE;
+    private static final Byte MOCK_BYTE_VALUE = Byte.MIN_VALUE;
+    private static final String NOT_EXIST_KEY = ""NOTEXIST"";
+
+    @BeforeEach
+    public void init() {
+
+        sysConfig = new SystemConfiguration();
+    }
+
+    @Test
+    public void testGetSysProperty() {
+        Assertions.assertNull(sysConfig.getInternalProperty(MOCK_KEY));
+        Assertions.assertFalse(sysConfig.containsKey(MOCK_KEY));
+        Assertions.assertNull(sysConfig.getString(MOCK_KEY));
+        Assertions.assertNull(sysConfig.getProperty(MOCK_KEY));
+        System.setProperty(MOCK_KEY, MOCK_STRING_VALUE);
+        Assertions.assertTrue(sysConfig.containsKey(MOCK_KEY));
+        Assertions.assertEquals(MOCK_STRING_VALUE, sysConfig.getInternalProperty(MOCK_KEY));
+        Assertions.assertEquals(MOCK_STRING_VALUE, sysConfig.getString(MOCK_KEY, MOCK_STRING_VALUE));
+        Assertions.assertEquals(MOCK_STRING_VALUE, sysConfig.getProperty(MOCK_KEY, MOCK_STRING_VALUE));
+
+    }
+
+    @Test
+    public void testConvert() {
+        Assertions.assertEquals(
+            MOCK_STRING_VALUE, sysConfig.convert(String.class, NOT_EXIST_KEY, MOCK_STRING_VALUE));
+        System.setProperty(MOCK_KEY, String.valueOf(MOCK_BOOL_VALUE));
+        Assertions.assertEquals(MOCK_BOOL_VALUE, sysConfig.convert(Boolean.class, MOCK_KEY, null));
+        System.setProperty(MOCK_KEY, String.valueOf(MOCK_STRING_VALUE));
+        Assertions.assertEquals(MOCK_STRING_VALUE, sysConfig.convert(String.class, MOCK_KEY, null));
+        System.setProperty(MOCK_KEY, String.valueOf(MOCK_INT_VALUE));
+        Assertions.assertEquals(MOCK_INT_VALUE, sysConfig.convert(Integer.class, MOCK_KEY, null));
+        System.setProperty(MOCK_KEY, String.valueOf(MOCK_LONG_VALUE));
+        Assertions.assertEquals(MOCK_LONG_VALUE, sysConfig.convert(Long.class, MOCK_KEY, null));
+        System.setProperty(MOCK_KEY, String.valueOf(MOCK_SHORT_VALUE));
+        Assertions.assertEquals(MOCK_SHORT_VALUE, sysConfig.convert(Short.class, MOCK_KEY, null));
+        System.setProperty(MOCK_KEY, String.valueOf(MOCK_FLOAT_VALUE));
+        Assertions.assertEquals(MOCK_FLOAT_VALUE, sysConfig.convert(Float.class, MOCK_KEY, null));
+        System.setProperty(MOCK_KEY, String.valueOf(MOCK_DOUBLE_VALUE));
+        Assertions.assertEquals(MOCK_DOUBLE_VALUE, sysConfig.convert(Double.class, MOCK_KEY, null));
+        System.setProperty(MOCK_KEY, String.valueOf(MOCK_BYTE_VALUE));
+        Assertions.assertEquals(MOCK_BYTE_VALUE, sysConfig.convert(Byte.class, MOCK_KEY, null));
+        System.setProperty(MOCK_KEY, String.valueOf(ConfigMock.MockOne));
+        Assertions.assertEquals(ConfigMock.MockOne, sysConfig.convert(ConfigMock.class, MOCK_KEY, null));
+    }
+
+    enum ConfigMock {
+        MockOne,
+        MockTwo
+    }
+
+","[{'comment': 'make this one single line.', 'commenter': 'Moriadry-zz'}, {'comment': 'fixed', 'commenter': 'slievrly'}]"
4226,dubbo-metadata-report/dubbo-metadata-report-etcd/src/test/java/org/apache/dubbo/metadata/store/etcd/EtcdMetadataReportTest.java,"@@ -73,6 +74,7 @@ public void tearDown() throws Exception {
     }
 
     @Test
+    @Ignore(""Ignore because https://github.com/apache/dubbo/issues/4185"")","[{'comment': 'In junit5 ， `Ignore ` is  changed to `Disabled` ', 'commenter': 'lovepoem'}, {'comment': 'Fixed', 'commenter': 'htynkn'}]"
4293,dubbo-registry/dubbo-registry-api/src/test/java/com/alibaba/dubbo/registry/support/AbstractRegistryFactoryTest.java,"@@ -89,7 +89,7 @@ public void testRegistryFactoryCache() throws Exception {
     public void testRegistryFactoryIpCache() throws Exception {
         Registry registry1 = registryFactory.getRegistry(URL.valueOf(""dubbo://"" + NetUtils.getLocalAddress().getHostName() + "":2233""));
         Registry registry2 = registryFactory.getRegistry(URL.valueOf(""dubbo://"" + NetUtils.getLocalAddress().getHostAddress() + "":2233""));
-        Assert.assertEquals(registry1, registry2);
+        Assert.assertNotSame(registry1, registry2);","[{'comment': 'unit test fails, it should be:\r\n\r\n```java\r\n    public void testRegistryFactoryIpCache() throws Exception {\r\n        Registry registry1 = registryFactory.getRegistry(URL.valueOf(""dubbo://"" + NetUtils.getLocalAddress().getHostName() + "":2233""));\r\n        Registry registry2 = registryFactory.getRegistry(URL.valueOf(""dubbo://"" + NetUtils.getLocalAddress().getHostAddress() + "":2233""));\r\n        Assertions.assertEquals(registry1, registry2);\r\n    }\r\n```\r\n', 'commenter': 'beiwei30'}, {'comment': ""I think registry1 and registry2 should be two different instances, but still don't know why it failed."", 'commenter': 'chickenlj'}]"
4296,dubbo-common/src/main/java/org/apache/dubbo/common/annotations/GenericAlias.java,"@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.annotations;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicate alias for field when generic invoking. <br>
+ * <p>
+ *     sometimes you receive json string which contains non-camelcase key name,e.g. order_id,
+ *     but the java bean needs camelcase name,e.g orderId, you should convert manually each other,
+ *     basing GenericAlias annotation it could be converted automatically.
+ * </p>
+ *
+ * @author rolandhe","[{'comment': 'Hi, please remove the author name.', 'commenter': 'ralf0131'}, {'comment': 'done.tks.', 'commenter': 'rolandhe'}]"
4296,dubbo-demo/dubbo-generic-demo/dubbo-generic-demo-provider/src/main/java/org/apache/dubbo/demo/provider/RequestDemo.java,"@@ -0,0 +1,55 @@
+package org.apache.dubbo.demo.provider;
+
+import org.apache.dubbo.common.annotations.GenericFeature;
+
+import java.util.Map;
+
+/**
+ * @author hexiufeng
+ * @date 2019/6/11下午7:46
+ */
+public class RequestDemo {
+    @GenericFeature(alias = ""_name"")
+    private String name;
+    @GenericFeature(alias = ""_description"", ignore = true)
+    private String desc;
+
+    @GenericFeature(alias = ""_extra"")
+    private Map<String,String> extra;
+
+    @GenericFeature(alias = ""lValue"",longAsString = true)","[{'comment': 'GenericFeature does not have `longAsString`', 'commenter': 'lkj41110'}]"
4296,dubbo-demo/dubbo-generic-demo/dubbo-generic-demo-provider/src/main/java/org/apache/dubbo/demo/provider/ResponseDemo.java,"@@ -0,0 +1,74 @@
+package org.apache.dubbo.demo.provider;","[{'comment': 'Some files are missing `LICENSE `', 'commenter': 'lkj41110'}]"
4296,dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java,"@@ -1,628 +1,1012 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.common.utils;
-
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-
-import java.lang.reflect.Array;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Proxy;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Hashtable;
-import java.util.IdentityHashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.TreeMap;
-import java.util.WeakHashMap;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.ConcurrentSkipListMap;
-
-/**
- * PojoUtils. Travel object deeply, and convert complex type to simple type.
- * <p/>
- * Simple type below will be remained:
- * <ul>
- * <li> Primitive Type, also include <b>String</b>, <b>Number</b>(Integer, Long), <b>Date</b>
- * <li> Array of Primitive Type
- * <li> Collection, eg: List, Map, Set etc.
- * </ul>
- * <p/>
- * Other type will be covert to a map which contains the attributes and value pair of object.
- */
-public class PojoUtils {
-
-    private static final Logger logger = LoggerFactory.getLogger(PojoUtils.class);
-    private static final ConcurrentMap<String, Method> NAME_METHODS_CACHE = new ConcurrentHashMap<String, Method>();
-    private static final ConcurrentMap<Class<?>, ConcurrentMap<String, Field>> CLASS_FIELD_CACHE = new ConcurrentHashMap<Class<?>, ConcurrentMap<String, Field>>();
-
-    public static Object[] generalize(Object[] objs) {
-        Object[] dests = new Object[objs.length];
-        for (int i = 0; i < objs.length; i++) {
-            dests[i] = generalize(objs[i]);
-        }
-        return dests;
-    }
-
-    public static Object[] realize(Object[] objs, Class<?>[] types) {
-        if (objs.length != types.length) {
-            throw new IllegalArgumentException(""args.length != types.length"");
-        }
-
-        Object[] dests = new Object[objs.length];
-        for (int i = 0; i < objs.length; i++) {
-            dests[i] = realize(objs[i], types[i]);
-        }
-
-        return dests;
-    }
-
-    public static Object[] realize(Object[] objs, Class<?>[] types, Type[] gtypes) {
-        if (objs.length != types.length || objs.length != gtypes.length) {
-            throw new IllegalArgumentException(""args.length != types.length"");
-        }
-        Object[] dests = new Object[objs.length];
-        for (int i = 0; i < objs.length; i++) {
-            dests[i] = realize(objs[i], types[i], gtypes[i]);
-        }
-        return dests;
-    }
-
-    public static Object generalize(Object pojo) {
-        return generalize(pojo, new IdentityHashMap<Object, Object>());
-    }
-
-    @SuppressWarnings(""unchecked"")
-    private static Object generalize(Object pojo, Map<Object, Object> history) {
-        if (pojo == null) {
-            return null;
-        }
-
-        if (pojo instanceof Enum<?>) {
-            return ((Enum<?>) pojo).name();
-        }
-        if (pojo.getClass().isArray() && Enum.class.isAssignableFrom(pojo.getClass().getComponentType())) {
-            int len = Array.getLength(pojo);
-            String[] values = new String[len];
-            for (int i = 0; i < len; i++) {
-                values[i] = ((Enum<?>) Array.get(pojo, i)).name();
-            }
-            return values;
-        }
-
-        if (ReflectUtils.isPrimitives(pojo.getClass())) {
-            return pojo;
-        }
-
-        if (pojo instanceof Class) {
-            return ((Class) pojo).getName();
-        }
-
-        Object o = history.get(pojo);
-        if (o != null) {
-            return o;
-        }
-        history.put(pojo, pojo);
-
-        if (pojo.getClass().isArray()) {
-            int len = Array.getLength(pojo);
-            Object[] dest = new Object[len];
-            history.put(pojo, dest);
-            for (int i = 0; i < len; i++) {
-                Object obj = Array.get(pojo, i);
-                dest[i] = generalize(obj, history);
-            }
-            return dest;
-        }
-        if (pojo instanceof Collection<?>) {
-            Collection<Object> src = (Collection<Object>) pojo;
-            int len = src.size();
-            Collection<Object> dest = (pojo instanceof List<?>) ? new ArrayList<Object>(len) : new HashSet<Object>(len);
-            history.put(pojo, dest);
-            for (Object obj : src) {
-                dest.add(generalize(obj, history));
-            }
-            return dest;
-        }
-        if (pojo instanceof Map<?, ?>) {
-            Map<Object, Object> src = (Map<Object, Object>) pojo;
-            Map<Object, Object> dest = createMap(src);
-            history.put(pojo, dest);
-            for (Map.Entry<Object, Object> obj : src.entrySet()) {
-                dest.put(generalize(obj.getKey(), history), generalize(obj.getValue(), history));
-            }
-            return dest;
-        }
-        Map<String, Object> map = new HashMap<String, Object>();
-        history.put(pojo, map);
-        map.put(""class"", pojo.getClass().getName());
-        for (Method method : pojo.getClass().getMethods()) {
-            if (ReflectUtils.isBeanPropertyReadMethod(method)) {
-                try {
-                    map.put(ReflectUtils.getPropertyNameFromBeanReadMethod(method), generalize(method.invoke(pojo), history));
-                } catch (Exception e) {
-                    throw new RuntimeException(e.getMessage(), e);
-                }
-            }
-        }
-        // public field
-        for (Field field : pojo.getClass().getFields()) {
-            if (ReflectUtils.isPublicInstanceField(field)) {
-                try {
-                    Object fieldValue = field.get(pojo);
-                    if (history.containsKey(pojo)) {
-                        Object pojoGeneralizedValue = history.get(pojo);
-                        if (pojoGeneralizedValue instanceof Map
-                                && ((Map) pojoGeneralizedValue).containsKey(field.getName())) {
-                            continue;
-                        }
-                    }
-                    if (fieldValue != null) {
-                        map.put(field.getName(), generalize(fieldValue, history));
-                    }
-                } catch (Exception e) {
-                    throw new RuntimeException(e.getMessage(), e);
-                }
-            }
-        }
-        return map;
-    }
-
-    public static Object realize(Object pojo, Class<?> type) {
-        return realize0(pojo, type, null, new IdentityHashMap<Object, Object>());
-    }
-
-    public static Object realize(Object pojo, Class<?> type, Type genericType) {
-        return realize0(pojo, type, genericType, new IdentityHashMap<Object, Object>());
-    }
-
-    private static class PojoInvocationHandler implements InvocationHandler {
-
-        private Map<Object, Object> map;
-
-        public PojoInvocationHandler(Map<Object, Object> map) {
-            this.map = map;
-        }
-
-        @Override
-        @SuppressWarnings(""unchecked"")
-        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-            if (method.getDeclaringClass() == Object.class) {
-                return method.invoke(map, args);
-            }
-            String methodName = method.getName();
-            Object value = null;
-            if (methodName.length() > 3 && methodName.startsWith(""get"")) {
-                value = map.get(methodName.substring(3, 4).toLowerCase() + methodName.substring(4));
-            } else if (methodName.length() > 2 && methodName.startsWith(""is"")) {
-                value = map.get(methodName.substring(2, 3).toLowerCase() + methodName.substring(3));
-            } else {
-                value = map.get(methodName.substring(0, 1).toLowerCase() + methodName.substring(1));
-            }
-            if (value instanceof Map<?, ?> && !Map.class.isAssignableFrom(method.getReturnType())) {
-                value = realize0((Map<String, Object>) value, method.getReturnType(), null, new IdentityHashMap<Object, Object>());
-            }
-            return value;
-        }
-    }
-
-    @SuppressWarnings(""unchecked"")
-    private static Collection<Object> createCollection(Class<?> type, int len) {
-        if (type.isAssignableFrom(ArrayList.class)) {
-            return new ArrayList<Object>(len);
-        }
-        if (type.isAssignableFrom(HashSet.class)) {
-            return new HashSet<Object>(len);
-        }
-        if (!type.isInterface() && !Modifier.isAbstract(type.getModifiers())) {
-            try {
-                return (Collection<Object>) type.newInstance();
-            } catch (Exception e) {
-                // ignore
-            }
-        }
-        return new ArrayList<Object>();
-    }
-
-    private static Map createMap(Map src) {
-        Class<? extends Map> cl = src.getClass();
-        Map result = null;
-        if (HashMap.class == cl) {
-            result = new HashMap();
-        } else if (Hashtable.class == cl) {
-            result = new Hashtable();
-        } else if (IdentityHashMap.class == cl) {
-            result = new IdentityHashMap();
-        } else if (LinkedHashMap.class == cl) {
-            result = new LinkedHashMap();
-        } else if (Properties.class == cl) {
-            result = new Properties();
-        } else if (TreeMap.class == cl) {
-            result = new TreeMap();
-        } else if (WeakHashMap.class == cl) {
-            return new WeakHashMap();
-        } else if (ConcurrentHashMap.class == cl) {
-            result = new ConcurrentHashMap();
-        } else if (ConcurrentSkipListMap.class == cl) {
-            result = new ConcurrentSkipListMap();
-        } else {
-            try {
-                result = cl.newInstance();
-            } catch (Exception e) { /* ignore */ }
-
-            if (result == null) {
-                try {
-                    Constructor<?> constructor = cl.getConstructor(Map.class);
-                    result = (Map) constructor.newInstance(Collections.EMPTY_MAP);
-                } catch (Exception e) { /* ignore */ }
-            }
-        }
-
-        if (result == null) {
-            result = new HashMap<Object, Object>();
-        }
-
-        return result;
-    }
-
-    @SuppressWarnings({""unchecked"", ""rawtypes""})
-    private static Object realize0(Object pojo, Class<?> type, Type genericType, final Map<Object, Object> history) {
-        if (pojo == null) {
-            return null;
-        }
-
-        if (type != null && type.isEnum() && pojo.getClass() == String.class) {
-            return Enum.valueOf((Class<Enum>) type, (String) pojo);
-        }
-
-        if (ReflectUtils.isPrimitives(pojo.getClass())
-                && !(type != null && type.isArray()
-                && type.getComponentType().isEnum()
-                && pojo.getClass() == String[].class)) {
-            return CompatibleTypeUtils.compatibleTypeConvert(pojo, type);
-        }
-
-        Object o = history.get(pojo);
-
-        if (o != null) {
-            return o;
-        }
-
-        history.put(pojo, pojo);
-
-        if (pojo.getClass().isArray()) {
-            if (Collection.class.isAssignableFrom(type)) {
-                Class<?> ctype = pojo.getClass().getComponentType();
-                int len = Array.getLength(pojo);
-                Collection dest = createCollection(type, len);
-                history.put(pojo, dest);
-                for (int i = 0; i < len; i++) {
-                    Object obj = Array.get(pojo, i);
-                    Object value = realize0(obj, ctype, null, history);
-                    dest.add(value);
-                }
-                return dest;
-            } else {
-                Class<?> ctype = (type != null && type.isArray() ? type.getComponentType() : pojo.getClass().getComponentType());
-                int len = Array.getLength(pojo);
-                Object dest = Array.newInstance(ctype, len);
-                history.put(pojo, dest);
-                for (int i = 0; i < len; i++) {
-                    Object obj = Array.get(pojo, i);
-                    Object value = realize0(obj, ctype, null, history);
-                    Array.set(dest, i, value);
-                }
-                return dest;
-            }
-        }
-
-        if (pojo instanceof Collection<?>) {
-            if (type.isArray()) {
-                Class<?> ctype = type.getComponentType();
-                Collection<Object> src = (Collection<Object>) pojo;
-                int len = src.size();
-                Object dest = Array.newInstance(ctype, len);
-                history.put(pojo, dest);
-                int i = 0;
-                for (Object obj : src) {
-                    Object value = realize0(obj, ctype, null, history);
-                    Array.set(dest, i, value);
-                    i++;
-                }
-                return dest;
-            } else {
-                Collection<Object> src = (Collection<Object>) pojo;
-                int len = src.size();
-                Collection<Object> dest = createCollection(type, len);
-                history.put(pojo, dest);
-                for (Object obj : src) {
-                    Type keyType = getGenericClassByIndex(genericType, 0);
-                    Class<?> keyClazz = obj == null ? null : obj.getClass();
-                    if (keyType instanceof Class) {
-                        keyClazz = (Class<?>) keyType;
-                    }
-                    Object value = realize0(obj, keyClazz, keyType, history);
-                    dest.add(value);
-                }
-                return dest;
-            }
-        }
-
-        if (pojo instanceof Map<?, ?> && type != null) {
-            Object className = ((Map<Object, Object>) pojo).get(""class"");
-            if (className instanceof String) {
-                try {
-                    type = ClassUtils.forName((String) className);
-                } catch (ClassNotFoundException e) {
-                    // ignore
-                }
-            }
-
-            // special logic for enum
-            if (type.isEnum()) {
-                Object name = ((Map<Object, Object>) pojo).get(""name"");
-                if (name != null) {
-                    return Enum.valueOf((Class<Enum>) type, name.toString());
-                }
-            }
-            Map<Object, Object> map;
-            // when return type is not the subclass of return type from the signature and not an interface
-            if (!type.isInterface() && !type.isAssignableFrom(pojo.getClass())) {
-                try {
-                    map = (Map<Object, Object>) type.newInstance();
-                    Map<Object, Object> mapPojo = (Map<Object, Object>) pojo;
-                    map.putAll(mapPojo);
-                    map.remove(""class"");
-                } catch (Exception e) {
-                    //ignore error
-                    map = (Map<Object, Object>) pojo;
-                }
-            } else {
-                map = (Map<Object, Object>) pojo;
-            }
-
-            if (Map.class.isAssignableFrom(type) || type == Object.class) {
-                final Map<Object, Object> result = createMap(map);
-                history.put(pojo, result);
-                for (Map.Entry<Object, Object> entry : map.entrySet()) {
-                    Type keyType = getGenericClassByIndex(genericType, 0);
-                    Type valueType = getGenericClassByIndex(genericType, 1);
-                    Class<?> keyClazz;
-                    if (keyType instanceof Class) {
-                        keyClazz = (Class<?>) keyType;
-                    } else if (keyType instanceof ParameterizedType) {
-                        keyClazz = (Class<?>) ((ParameterizedType) keyType).getRawType();
-                    } else {
-                        keyClazz = entry.getKey() == null ? null : entry.getKey().getClass();
-                    }
-                    Class<?> valueClazz;
-                    if (valueType instanceof Class) {
-                        valueClazz = (Class<?>) valueType;
-                    } else if (valueType instanceof ParameterizedType) {
-                        valueClazz = (Class<?>) ((ParameterizedType) valueType).getRawType();
-                    } else {
-                        valueClazz = entry.getValue() == null ? null : entry.getValue().getClass();
-                    }
-
-                    Object key = keyClazz == null ? entry.getKey() : realize0(entry.getKey(), keyClazz, keyType, history);
-                    Object value = valueClazz == null ? entry.getValue() : realize0(entry.getValue(), valueClazz, valueType, history);
-                    result.put(key, value);
-                }
-                return result;
-            } else if (type.isInterface()) {
-                Object dest = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[]{type}, new PojoInvocationHandler(map));
-                history.put(pojo, dest);
-                return dest;
-            } else {
-                Object dest = newInstance(type);
-                history.put(pojo, dest);
-                for (Map.Entry<Object, Object> entry : map.entrySet()) {
-                    Object key = entry.getKey();
-                    if (key instanceof String) {
-                        String name = (String) key;
-                        Object value = entry.getValue();
-                        if (value != null) {
-                            Method method = getSetterMethod(dest.getClass(), name, value.getClass());
-                            Field field = getField(dest.getClass(), name);
-                            if (method != null) {
-                                if (!method.isAccessible()) {
-                                    method.setAccessible(true);
-                                }
-                                Type ptype = method.getGenericParameterTypes()[0];
-                                value = realize0(value, method.getParameterTypes()[0], ptype, history);
-                                try {
-                                    method.invoke(dest, value);
-                                } catch (Exception e) {
-                                    String exceptionDescription = ""Failed to set pojo "" + dest.getClass().getSimpleName() + "" property "" + name
-                                            + "" value "" + value + ""("" + value.getClass() + ""), cause: "" + e.getMessage();
-                                    logger.error(exceptionDescription, e);
-                                    throw new RuntimeException(exceptionDescription, e);
-                                }
-                            } else if (field != null) {
-                                value = realize0(value, field.getType(), field.getGenericType(), history);
-                                try {
-                                    field.set(dest, value);
-                                } catch (IllegalAccessException e) {
-                                    throw new RuntimeException(""Failed to set field "" + name + "" of pojo "" + dest.getClass().getName() + "" : "" + e.getMessage(), e);
-                                }
-                            }
-                        }
-                    }
-                }
-                if (dest instanceof Throwable) {
-                    Object message = map.get(""message"");
-                    if (message instanceof String) {
-                        try {
-                            Field field = Throwable.class.getDeclaredField(""detailMessage"");
-                            if (!field.isAccessible()) {
-                                field.setAccessible(true);
-                            }
-                            field.set(dest, message);
-                        } catch (Exception e) {
-                        }
-                    }
-                }
-                return dest;
-            }
-        }
-        return pojo;
-    }
-
-    /**
-     * Get parameterized type
-     *
-     * @param genericType generic type
-     * @param index       index of the target parameterized type
-     * @return Return Person.class for List<Person>, return Person.class for Map<String, Person> when index=0
-     */
-    private static Type getGenericClassByIndex(Type genericType, int index) {
-        Type clazz = null;
-        // find parameterized type
-        if (genericType instanceof ParameterizedType) {
-            ParameterizedType t = (ParameterizedType) genericType;
-            Type[] types = t.getActualTypeArguments();
-            clazz = types[index];
-        }
-        return clazz;
-    }
-
-    private static Object newInstance(Class<?> cls) {
-        try {
-            return cls.newInstance();
-        } catch (Throwable t) {
-            try {
-                Constructor<?>[] constructors = cls.getDeclaredConstructors();
-                /**
-                 * From Javadoc java.lang.Class#getDeclaredConstructors
-                 * This method returns an array of Constructor objects reflecting all the constructors
-                 * declared by the class represented by this Class object.
-                 * This method returns an array of length 0,
-                 * if this Class object represents an interface, a primitive type, an array class, or void.
-                 */
-                if (constructors.length == 0) {
-                    throw new RuntimeException(""Illegal constructor: "" + cls.getName());
-                }
-                Constructor<?> constructor = constructors[0];
-                if (constructor.getParameterTypes().length > 0) {
-                    for (Constructor<?> c : constructors) {
-                        if (c.getParameterTypes().length < constructor.getParameterTypes().length) {
-                            constructor = c;
-                            if (constructor.getParameterTypes().length == 0) {
-                                break;
-                            }
-                        }
-                    }
-                }
-                constructor.setAccessible(true);
-                Object[] parameters = Arrays.stream(constructor.getParameterTypes()).map(PojoUtils::getDefaultValue).toArray();
-                return constructor.newInstance(parameters);
-            } catch (InstantiationException e) {
-                throw new RuntimeException(e.getMessage(), e);
-            } catch (IllegalAccessException e) {
-                throw new RuntimeException(e.getMessage(), e);
-            } catch (InvocationTargetException e) {
-                throw new RuntimeException(e.getMessage(), e);
-            }
-        }
-    }
-
-    /**
-     * return init value
-     * @param parameterType
-     * @return
-     */
-    private static Object getDefaultValue(Class<?> parameterType) {
-        if (parameterType.getName().equals(""char"")) {
-            return Character.MIN_VALUE;
-        }
-        if (parameterType.getName().equals(""bool"")) {
-            return false;
-        }
-        return parameterType.isPrimitive() ? 0 : null;
-    }
-
-    private static Method getSetterMethod(Class<?> cls, String property, Class<?> valueCls) {
-        String name = ""set"" + property.substring(0, 1).toUpperCase() + property.substring(1);
-        Method method = NAME_METHODS_CACHE.get(cls.getName() + ""."" + name + ""("" + valueCls.getName() + "")"");
-        if (method == null) {
-            try {
-                method = cls.getMethod(name, valueCls);
-            } catch (NoSuchMethodException e) {
-                for (Method m : cls.getMethods()) {
-                    if (ReflectUtils.isBeanPropertyWriteMethod(m) && m.getName().equals(name)) {
-                        method = m;
-                        break;
-                    }
-                }
-            }
-            if (method != null) {
-                NAME_METHODS_CACHE.put(cls.getName() + ""."" + name + ""("" + valueCls.getName() + "")"", method);
-            }
-        }
-        return method;
-    }
-
-    private static Field getField(Class<?> cls, String fieldName) {
-        Field result = null;
-        if (CLASS_FIELD_CACHE.containsKey(cls) && CLASS_FIELD_CACHE.get(cls).containsKey(fieldName)) {
-            return CLASS_FIELD_CACHE.get(cls).get(fieldName);
-        }
-        try {
-            result = cls.getDeclaredField(fieldName);
-            result.setAccessible(true);
-        } catch (NoSuchFieldException e) {
-            for (Field field : cls.getFields()) {
-                if (fieldName.equals(field.getName()) && ReflectUtils.isPublicInstanceField(field)) {
-                    result = field;
-                    break;
-                }
-            }
-        }
-        if (result != null) {
-            ConcurrentMap<String, Field> fields = CLASS_FIELD_CACHE.get(cls);
-            if (fields == null) {
-                fields = new ConcurrentHashMap<String, Field>();
-                CLASS_FIELD_CACHE.putIfAbsent(cls, fields);
-            }
-            fields = CLASS_FIELD_CACHE.get(cls);
-            fields.putIfAbsent(fieldName, result);
-        }
-        return result;
-    }
-
-    public static boolean isPojo(Class<?> cls) {
-        return !ReflectUtils.isPrimitives(cls)
-                && !Collection.class.isAssignableFrom(cls)
-                && !Map.class.isAssignableFrom(cls);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.utils;
+
+import org.apache.dubbo.common.annotations.GenericFeature;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+
+import java.lang.reflect.Array;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Proxy;
+import java.lang.reflect.Type;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.format.DateTimeFormatter;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Hashtable;
+import java.util.IdentityHashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.WeakHashMap;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ConcurrentSkipListMap;
+
+/**
+ * PojoUtils. Travel object deeply, and convert complex type to simple type.
+ * <p/>
+ * Simple type below will be remained:
+ * <ul>
+ * <li> Primitive Type, also include <b>String</b>, <b>Number</b>(Integer, Long), <b>Date</b>
+ * <li> Array of Primitive Type
+ * <li> Collection, eg: List, Map, Set etc.
+ * </ul>
+ * <p/>
+ * Other type will be covert to a map which contains the attributes and value pair of object.
+ */
+public class PojoUtils {
+
+    private static final Logger logger = LoggerFactory.getLogger(PojoUtils.class);
+    private static final ConcurrentMap<String, Method> NAME_METHODS_CACHE = new ConcurrentHashMap<String, Method>();
+    private static final ConcurrentMap<Class<?>, ConcurrentMap<String, Field>> CLASS_FIELD_CACHE = new ConcurrentHashMap<Class<?>, ConcurrentMap<String, Field>>();
+
+    public static Object[] generalize(Object[] objs) {
+        Object[] dests = new Object[objs.length];
+        for (int i = 0; i < objs.length; i++) {
+            dests[i] = generalize(objs[i]);
+        }
+        return dests;
+    }
+
+    public static Object[] realize(Object[] objs, Class<?>[] types) {
+        if (objs.length != types.length) {
+            throw new IllegalArgumentException(""args.length != types.length"");
+        }
+
+        Object[] dests = new Object[objs.length];
+        for (int i = 0; i < objs.length; i++) {
+            dests[i] = realize(objs[i], types[i]);
+        }
+
+        return dests;
+    }
+
+    public static Object[] realize(Object[] objs, Class<?>[] types, Type[] gtypes) {
+        if (objs.length != types.length || objs.length != gtypes.length) {
+            throw new IllegalArgumentException(""args.length != types.length"");
+        }
+        Object[] dests = new Object[objs.length];
+        for (int i = 0; i < objs.length; i++) {
+            dests[i] = realize(objs[i], types[i], gtypes[i]);
+        }
+        return dests;
+    }
+
+    public static Object generalize(Object pojo) {
+        return generalize(pojo, new IdentityHashMap<Object, Object>());
+    }
+
+    @SuppressWarnings(""unchecked"")
+    private static Object generalize(Object pojo, Map<Object, Object> history) {
+        if (pojo == null) {
+            return null;
+        }
+
+        if (pojo instanceof Enum<?>) {
+            return ((Enum<?>) pojo).name();
+        }
+        if (pojo.getClass().isArray() && Enum.class.isAssignableFrom(pojo.getClass().getComponentType())) {
+            int len = Array.getLength(pojo);
+            String[] values = new String[len];
+            for (int i = 0; i < len; i++) {
+                values[i] = ((Enum<?>) Array.get(pojo, i)).name();
+            }
+            return values;
+        }
+
+        if (ReflectUtils.isPrimitives(pojo.getClass())) {
+            return pojo;
+        }
+
+        if (pojo instanceof Class) {
+            return ((Class) pojo).getName();
+        }
+
+        Object o = history.get(pojo);
+        if (o != null) {
+            return o;
+        }
+        history.put(pojo, pojo);
+
+        if (pojo.getClass().isArray()) {
+            int len = Array.getLength(pojo);
+            Object[] dest = new Object[len];
+            history.put(pojo, dest);
+            for (int i = 0; i < len; i++) {
+                Object obj = Array.get(pojo, i);
+                dest[i] = generalize(obj, history);
+            }
+            return dest;
+        }
+        if (pojo instanceof Collection<?>) {
+            Collection<Object> src = (Collection<Object>) pojo;
+            int len = src.size();
+            Collection<Object> dest = (pojo instanceof List<?>) ? new ArrayList<Object>(len) : new HashSet<Object>(len);
+            history.put(pojo, dest);
+            for (Object obj : src) {
+                dest.add(generalize(obj, history));
+            }
+            return dest;
+        }
+        if (pojo instanceof Map<?, ?>) {
+            Map<Object, Object> src = (Map<Object, Object>) pojo;
+            Map<Object, Object> dest = createMap(src);
+            history.put(pojo, dest);
+            for (Map.Entry<Object, Object> obj : src.entrySet()) {
+                dest.put(generalize(obj.getKey(), history), generalize(obj.getValue(), history));
+            }
+            return dest;
+        }
+        Map<String, Object> map = new HashMap<String, Object>();
+        history.put(pojo, map);
+        map.put(""class"", pojo.getClass().getName());
+        Set<String> annoFieldSet = new HashSet<>();
+        List<Field> allFieldList = getClassAllFields(pojo.getClass());
+        for (Field field : allFieldList) {
+            GenericFeature genericFeature = field.getAnnotation(GenericFeature.class);
+            if (ReflectUtils.isSpecialInstanceField(field) &&  genericFeature != null) {
+                String fieldAliasName = genericFeature.alias();
+                if (genericFeature.ignore()) {
+                    annoFieldSet.add(field.getName());
+                    annoFieldSet.add(fieldAliasName);
+                    continue;
+                }
+                try {
+
+                    if (history.containsKey(pojo)) {
+                        Object pojoGeneralizedValue = history.get(pojo);
+                        if (pojoGeneralizedValue instanceof Map
+                                && ((Map) pojoGeneralizedValue).containsKey(fieldAliasName)) {
+                            continue;
+                        }
+                    }
+                    Object rawValue = forceGetFieldValue(field,pojo);
+                    if(isNullDateAsZero(field.getType(),genericFeature,rawValue)){
+                        annoFieldSet.add(field.getName());
+                        annoFieldSet.add(fieldAliasName);
+                        map.put(fieldAliasName, isNullDateAsZero(field.getType(),genericFeature.dateFormatter()));
+                        continue;
+                    }
+                    if(genericFeature.nullNotGeneralize() && rawValue == null) {
+                        annoFieldSet.add(field.getName());
+                        annoFieldSet.add(fieldAliasName);
+                        continue;
+                    }
+                    Object fieldValue = toValueType(rawValue,field.getType(),genericFeature);
+                    annoFieldSet.add(field.getName());
+                    annoFieldSet.add(fieldAliasName);
+                    map.put(fieldAliasName, generalize(fieldValue, history));
+                } catch (Exception e) {
+                    throw new RuntimeException(e.getMessage(), e);
+                }
+            }
+        }
+        Set<String> methodNameSet = new HashSet<>();
+        for (Method method : pojo.getClass().getMethods()) {
+            if (ReflectUtils.isBeanPropertyReadMethod(method)) {
+                try {
+                    GenericFeature genericFeature = method.getAnnotation(GenericFeature.class);
+                    String methodAlias = genericFeature==null?null:genericFeature.alias();
+                    String propertyName = ReflectUtils.getPropertyNameFromBeanReadMethod(method);
+                    String uniqName = methodAlias == null?propertyName : methodAlias;
+                    if(!annoFieldSet.contains(propertyName) && (methodAlias == null || !annoFieldSet.contains(methodAlias))) {
+                        if(genericFeature != null && genericFeature.ignore()) {
+                            methodNameSet.add(propertyName);
+                            continue;
+                        }
+                        Object rawMethodValue = method.invoke(pojo);
+                        if (isNullDateAsZero(method.getReturnType(), genericFeature, rawMethodValue)) {
+                            methodNameSet.add(propertyName);
+                            map.put(uniqName, isNullDateAsZero(method.getReturnType(), genericFeature.dateFormatter()));
+                            continue;
+                        }
+                        if(genericFeature != null && genericFeature.nullNotGeneralize() && rawMethodValue == null) {
+                            methodNameSet.add(propertyName);
+                            continue;
+                        }
+                        Object mVal = toValueType(rawMethodValue,method.getReturnType(),genericFeature);
+                        map.put(uniqName, generalize(mVal, history));
+                        methodNameSet.add(propertyName);
+                    }
+                } catch (Exception e) {
+                    throw new RuntimeException(e.getMessage(), e);
+                }
+            }
+        }
+        // public field
+        for (Field field : pojo.getClass().getFields()) {
+            if (ReflectUtils.isPublicInstanceField(field)) {
+                if(methodNameSet.contains(field.getName()) || annoFieldSet.contains(field.getName())) {
+                    continue;
+                }
+                try {
+                    Object fieldValue = field.get(pojo);
+                    if (history.containsKey(pojo)) {
+                        Object pojoGeneralizedValue = history.get(pojo);
+                        if (pojoGeneralizedValue instanceof Map
+                                && ((Map) pojoGeneralizedValue).containsKey(field.getName())) {
+                            continue;
+                        }
+                    }
+                    if (fieldValue != null) {
+                        map.put(field.getName(), generalize(fieldValue, history));
+                    }
+                } catch (Exception e) {
+                    throw new RuntimeException(e.getMessage(), e);
+                }
+            }
+        }
+        return map;
+    }
+    private static boolean isNullDateAsZero(Class type,GenericFeature genericFeature, Object value) {
+        if (value != null || genericFeature == null || !genericFeature.nullDateAsZeroGeneralize()
+                || genericFeature.dateFormatter().length() == 0) {
+            return false;
+        }
+        if (type.equals(Date.class)) {
+            return true;
+        }
+        if (type.equals(LocalDateTime.class)) {
+            return true;
+        }
+        if (type.equals(LocalDate.class)) {
+            return true;
+        }
+        return false;
+    }
+    private static String isNullDateAsZero(Class type, String formatter) {
+        String dateZero = null;
+        if (type.equals(Date.class)) {
+            Calendar calendar = Calendar.getInstance();
+            calendar.set(1971, 0, 2, 3, 4, 5);
+            SimpleDateFormat dateFormat = new SimpleDateFormat(formatter);
+            dateZero = dateFormat.format(calendar.getTime());
+        }
+        if (type.equals(LocalDateTime.class)) {
+            LocalDateTime localDateTime = LocalDateTime.of(1971, 1, 2, 3, 4, 5);
+            dateZero = localDateTime.format(DateTimeFormatter.ofPattern(formatter));
+        }
+        if (type.equals(LocalDate.class)) {
+            LocalDate localDate = LocalDate.of(1971, 1, 2);
+            dateZero = localDate.format(DateTimeFormatter.ofPattern(formatter));
+        }
+        if (dateZero == null) {
+            throw new RuntimeException(type.getName() + "" is not support"");
+        }
+        dateZero = dateZero.replace(""1971"", ""0000"")
+                .replace(""01"", ""00"")
+                .replace(""02"", ""00"")
+                .replace(""03"", ""00"")
+                .replace(""04"", ""00"")
+                .replace(""05"", ""00"");
+        return dateZero;
+    }
+    private static Object toValueType(Object val, Class type, GenericFeature genericFeature) {
+        if(genericFeature == null){
+            return val;
+        }
+
+        if((type == Boolean.class || type == boolean.class) && genericFeature.numberAsString()) {
+            return val == null?"""":val.toString();
+        }
+
+        if((type == Byte.class || type == byte.class) && genericFeature.numberAsString()) {
+            return val == null?"""":val.toString();
+        }
+
+        if((type == Short.class || type == short.class) && genericFeature.numberAsString()) {
+            return val == null?"""":val.toString();
+        }
+        if((type == Integer.class || type == int.class) && genericFeature.numberAsString()) {
+            return val == null?"""":val.toString();
+        }
+        if((type == Long.class || type == long.class) && genericFeature.numberAsString()) {
+            return val == null?"""":val.toString();
+        }
+
+        if((type == Float.class || type == float.class) && genericFeature.numberAsString()) {
+            return val == null?"""":val.toString();
+        }
+
+        if((type == Double.class || type == double.class) && genericFeature.numberAsString()) {
+            return val == null?"""":val.toString();
+        }
+
+        if(type == BigDecimal.class && genericFeature.numberAsString()) {
+            return val == null?"""":((BigDecimal)val).toPlainString();
+        }
+
+        if(type == BigInteger.class && genericFeature.numberAsString()) {
+            return val == null?"""":val.toString();
+        }
+
+
+
+        if(type == LocalDateTime.class  && genericFeature.dateFormatter().length() > 0) {
+            LocalDateTime dateTime = (LocalDateTime)val;
+            return dateTime==null?"""":dateTime.format(DateTimeFormatter.ofPattern(genericFeature.dateFormatter()));
+        }
+
+        if(type == LocalDate.class  && genericFeature.dateFormatter().length() > 0) {
+            LocalDate date = (LocalDate)val;
+            return date==null?"""":date.format(DateTimeFormatter.ofPattern(genericFeature.dateFormatter()));
+        }
+        if(type == Date.class  && genericFeature.dateFormatter().length() > 0) {
+            Date date = (Date) val;
+            SimpleDateFormat format = new SimpleDateFormat(genericFeature.dateFormatter());
+            return date==null?"""":format.format(date);
+        }
+        return val;
+    }
+
+    private static Object fromValueType(Object val, Class type, GenericFeature genericFeature) {
+        if(genericFeature == null || val.getClass() != String.class){
+            return val;
+        }
+        String strValue = (String)val;
+        boolean isEmpty = strValue == null || strValue.length() == 0;
+
+        if (type == boolean.class && genericFeature.numberAsString()) {
+            return isEmpty ? false : Boolean.parseBoolean(strValue);
+        }
+
+        if (type == Boolean.class && genericFeature.numberAsString()) {
+            return isEmpty ? null : Boolean.parseBoolean(strValue);
+        }
+
+        if(type == byte.class && genericFeature.numberAsString()) {
+            return isEmpty?0:Byte.parseByte(strValue);
+        }
+
+        if(type == Byte.class && genericFeature.numberAsString()) {
+            return isEmpty?null:Byte.parseByte(strValue);
+        }
+
+        if(type == short.class && genericFeature.numberAsString()) {
+            return isEmpty?0:Short.parseShort(strValue);
+        }
+
+        if(type == Short.class && genericFeature.numberAsString()) {
+            return isEmpty?null:Short.parseShort(strValue);
+        }
+
+
+        if(type == int.class && genericFeature.numberAsString()) {
+            return isEmpty?0:Integer.parseInt(strValue);
+        }
+
+        if(type == Integer.class && genericFeature.numberAsString()) {
+            return isEmpty?null:Integer.parseInt(strValue);
+        }
+
+        if(type == long.class && genericFeature.numberAsString()) {
+            return isEmpty?0L:Long.parseLong(strValue);
+        }
+        if(type == Long.class && genericFeature.numberAsString()) {
+            return isEmpty?null:Long.parseLong(strValue);
+        }
+
+        if(type == float.class && genericFeature.numberAsString()) {
+            return isEmpty?0.0F:Float.parseFloat(strValue);
+        }
+
+        if(type == Float.class && genericFeature.numberAsString()) {
+            return isEmpty?null:Float.parseFloat(strValue);
+        }
+
+        if(type == double.class && genericFeature.numberAsString()) {
+            return isEmpty?0.0D:Double.parseDouble(strValue);
+        }
+
+        if(type == Double.class && genericFeature.numberAsString()) {
+            return isEmpty?null:Double.parseDouble(strValue);
+        }
+
+        if(type == BigInteger.class && genericFeature.numberAsString()) {
+            return isEmpty?null: new BigInteger(strValue);
+        }
+
+        if(type == BigDecimal.class && genericFeature.numberAsString()) {
+            return isEmpty?null: new BigDecimal(strValue);
+        }
+
+
+
+        if(type == LocalDateTime.class  && genericFeature.dateFormatter().length() > 0) {
+            return isEmpty?null:LocalDateTime.parse(strValue,DateTimeFormatter.ofPattern(genericFeature.dateFormatter()));
+        }
+
+        if(type == LocalDate.class  && genericFeature.dateFormatter().length() > 0) {
+            return isEmpty?null:LocalDate.parse(strValue,DateTimeFormatter.ofPattern(genericFeature.dateFormatter()));
+        }
+        if(type == Date.class  && genericFeature.dateFormatter().length() > 0) {
+            SimpleDateFormat format = new SimpleDateFormat(genericFeature.dateFormatter());
+            try {
+                return isEmpty?null:format.parse(strValue);
+            } catch (ParseException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return val;
+    }
+
+    private static Object forceGetFieldValue(Field field,Object pojo) throws IllegalAccessException {
+        boolean isPublic = Modifier.isPublic(field.getModifiers());
+        if(!isPublic) {
+            field.setAccessible(true);
+        }
+        try{
+            return   field.get(pojo);
+        } finally {
+            if(!isPublic) {
+                field.setAccessible(false);
+            }
+        }
+    }
+
+    public static Object realize(Object pojo, Class<?> type) {
+        return realize0(pojo, type, null, new IdentityHashMap<Object, Object>());
+    }
+
+    public static Object realize(Object pojo, Class<?> type, Type genericType) {
+        return realize0(pojo, type, genericType, new IdentityHashMap<Object, Object>());
+    }
+
+    private static class PojoInvocationHandler implements InvocationHandler {
+
+        private Map<Object, Object> map;
+
+        public PojoInvocationHandler(Map<Object, Object> map) {
+            this.map = map;
+        }
+
+        @Override
+        @SuppressWarnings(""unchecked"")
+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+            if (method.getDeclaringClass() == Object.class) {
+                return method.invoke(map, args);
+            }
+            String methodName = method.getName();
+            Object value = null;
+            if (methodName.length() > 3 && methodName.startsWith(""get"")) {
+                value = map.get(methodName.substring(3, 4).toLowerCase() + methodName.substring(4));
+            } else if (methodName.length() > 2 && methodName.startsWith(""is"")) {
+                value = map.get(methodName.substring(2, 3).toLowerCase() + methodName.substring(3));
+            } else {
+                value = map.get(methodName.substring(0, 1).toLowerCase() + methodName.substring(1));
+            }
+            if (value instanceof Map<?, ?> && !Map.class.isAssignableFrom(method.getReturnType())) {
+                value = realize0((Map<String, Object>) value, method.getReturnType(), null, new IdentityHashMap<Object, Object>());
+            }
+            return value;
+        }
+    }
+
+    @SuppressWarnings(""unchecked"")
+    private static Collection<Object> createCollection(Class<?> type, int len) {
+        if (type.isAssignableFrom(ArrayList.class)) {
+            return new ArrayList<Object>(len);
+        }
+        if (type.isAssignableFrom(HashSet.class)) {
+            return new HashSet<Object>(len);
+        }
+        if (!type.isInterface() && !Modifier.isAbstract(type.getModifiers())) {
+            try {
+                return (Collection<Object>) type.newInstance();
+            } catch (Exception e) {
+                // ignore
+            }
+        }
+        return new ArrayList<Object>();
+    }
+
+    private static Map createMap(Map src) {
+        Class<? extends Map> cl = src.getClass();
+        Map result = null;
+        if (HashMap.class == cl) {
+            result = new HashMap();
+        } else if (Hashtable.class == cl) {
+            result = new Hashtable();
+        } else if (IdentityHashMap.class == cl) {
+            result = new IdentityHashMap();
+        } else if (LinkedHashMap.class == cl) {
+            result = new LinkedHashMap();
+        } else if (Properties.class == cl) {
+            result = new Properties();
+        } else if (TreeMap.class == cl) {
+            result = new TreeMap();
+        } else if (WeakHashMap.class == cl) {
+            return new WeakHashMap();
+        } else if (ConcurrentHashMap.class == cl) {
+            result = new ConcurrentHashMap();
+        } else if (ConcurrentSkipListMap.class == cl) {
+            result = new ConcurrentSkipListMap();
+        } else {
+            try {
+                result = cl.newInstance();
+            } catch (Exception e) { /* ignore */ }
+
+            if (result == null) {
+                try {
+                    Constructor<?> constructor = cl.getConstructor(Map.class);
+                    result = (Map) constructor.newInstance(Collections.EMPTY_MAP);
+                } catch (Exception e) { /* ignore */ }
+            }
+        }
+
+        if (result == null) {
+            result = new HashMap<Object, Object>();
+        }
+
+        return result;
+    }
+
+    @SuppressWarnings({""unchecked"", ""rawtypes""})
+    private static Object realize0(Object pojo, Class<?> type, Type genericType, final Map<Object, Object> history) {
+        if (pojo == null) {
+            return null;
+        }
+
+        if (type != null && type.isEnum() && pojo.getClass() == String.class) {
+            return Enum.valueOf((Class<Enum>) type, (String) pojo);
+        }
+
+        if (ReflectUtils.isPrimitives(pojo.getClass())
+                && !(type != null && type.isArray()
+                && type.getComponentType().isEnum()
+                && pojo.getClass() == String[].class)) {
+            return CompatibleTypeUtils.compatibleTypeConvert(pojo, type);
+        }
+
+        Object o = history.get(pojo);
+
+        if (o != null) {
+            return o;
+        }
+
+        history.put(pojo, pojo);
+
+        if (pojo.getClass().isArray()) {
+            if (Collection.class.isAssignableFrom(type)) {
+                Class<?> ctype = pojo.getClass().getComponentType();
+                int len = Array.getLength(pojo);
+                Collection dest = createCollection(type, len);
+                history.put(pojo, dest);
+                for (int i = 0; i < len; i++) {
+                    Object obj = Array.get(pojo, i);
+                    Object value = realize0(obj, ctype, null, history);
+                    dest.add(value);
+                }
+                return dest;
+            } else {
+                Class<?> ctype = (type != null && type.isArray() ? type.getComponentType() : pojo.getClass().getComponentType());
+                int len = Array.getLength(pojo);
+                Object dest = Array.newInstance(ctype, len);
+                history.put(pojo, dest);
+                for (int i = 0; i < len; i++) {
+                    Object obj = Array.get(pojo, i);
+                    Object value = realize0(obj, ctype, null, history);
+                    Array.set(dest, i, value);
+                }
+                return dest;
+            }
+        }
+
+        if (pojo instanceof Collection<?>) {
+            if (type.isArray()) {
+                Class<?> ctype = type.getComponentType();
+                Collection<Object> src = (Collection<Object>) pojo;
+                int len = src.size();
+                Object dest = Array.newInstance(ctype, len);
+                history.put(pojo, dest);
+                int i = 0;
+                for (Object obj : src) {
+                    Object value = realize0(obj, ctype, null, history);
+                    Array.set(dest, i, value);
+                    i++;
+                }
+                return dest;
+            } else {
+                Collection<Object> src = (Collection<Object>) pojo;
+                int len = src.size();
+                Collection<Object> dest = createCollection(type, len);
+                history.put(pojo, dest);
+                for (Object obj : src) {
+                    Type keyType = getGenericClassByIndex(genericType, 0);
+                    Class<?> keyClazz = obj == null ? null : obj.getClass();
+                    if (keyType instanceof Class) {
+                        keyClazz = (Class<?>) keyType;
+                    }
+                    Object value = realize0(obj, keyClazz, keyType, history);
+                    dest.add(value);
+                }
+                return dest;
+            }
+        }
+
+        if (pojo instanceof Map<?, ?> && type != null) {
+            Object className = ((Map<Object, Object>) pojo).get(""class"");
+            if (className instanceof String) {
+                try {
+                    type = ClassUtils.forName((String) className);
+                } catch (ClassNotFoundException e) {
+                    // ignore
+                }
+            }
+
+            // special logic for enum
+            if (type.isEnum()) {
+                Object name = ((Map<Object, Object>) pojo).get(""name"");
+                if (name != null) {
+                    return Enum.valueOf((Class<Enum>) type, name.toString());
+                }
+            }
+            Map<Object, Object> map;
+            // when return type is not the subclass of return type from the signature and not an interface
+            if (!type.isInterface() && !type.isAssignableFrom(pojo.getClass())) {
+                try {
+                    map = (Map<Object, Object>) type.newInstance();
+                    Map<Object, Object> mapPojo = (Map<Object, Object>) pojo;
+                    map.putAll(mapPojo);
+                    map.remove(""class"");
+                } catch (Exception e) {
+                    //ignore error
+                    map = (Map<Object, Object>) pojo;
+                }
+            } else {
+                map = (Map<Object, Object>) pojo;
+            }
+
+            if (Map.class.isAssignableFrom(type) || type == Object.class) {
+                final Map<Object, Object> result = createMap(map);
+                history.put(pojo, result);
+                for (Map.Entry<Object, Object> entry : map.entrySet()) {
+                    Type keyType = getGenericClassByIndex(genericType, 0);
+                    Type valueType = getGenericClassByIndex(genericType, 1);
+                    Class<?> keyClazz;
+                    if (keyType instanceof Class) {
+                        keyClazz = (Class<?>) keyType;
+                    } else if (keyType instanceof ParameterizedType) {
+                        keyClazz = (Class<?>) ((ParameterizedType) keyType).getRawType();
+                    } else {
+                        keyClazz = entry.getKey() == null ? null : entry.getKey().getClass();
+                    }
+                    Class<?> valueClazz;
+                    if (valueType instanceof Class) {
+                        valueClazz = (Class<?>) valueType;
+                    } else if (valueType instanceof ParameterizedType) {
+                        valueClazz = (Class<?>) ((ParameterizedType) valueType).getRawType();
+                    } else {
+                        valueClazz = entry.getValue() == null ? null : entry.getValue().getClass();
+                    }
+
+                    Object key = keyClazz == null ? entry.getKey() : realize0(entry.getKey(), keyClazz, keyType, history);
+                    Object value = valueClazz == null ? entry.getValue() : realize0(entry.getValue(), valueClazz, valueType, history);
+                    result.put(key, value);
+                }
+                return result;
+            } else if (type.isInterface()) {
+                Object dest = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[]{type}, new PojoInvocationHandler(map));
+                history.put(pojo, dest);
+                return dest;
+            } else {
+                Object dest = newInstance(type);
+                history.put(pojo, dest);
+                for (Map.Entry<Object, Object> entry : map.entrySet()) {
+                    Object key = entry.getKey();
+                    if (key instanceof String) {
+                        String name = (String) key;
+                        Object value = entry.getValue();
+                        if (value != null) {
+                            Method method = getSetterMethod(dest.getClass(), name, value.getClass());
+                            Field field = getField(dest.getClass(), name);
+                            if(realizeGenericFeatures(method,field,value,dest,name,history)) {
+                                continue;
+                            }
+                            if (method != null) {
+                                if (!method.isAccessible()) {
+                                    method.setAccessible(true);
+                                }
+                                Type ptype = method.getGenericParameterTypes()[0];
+                                value = realize0(value, method.getParameterTypes()[0], ptype, history);
+
+                                try {
+                                    method.invoke(dest, fromValueType(value, method.getParameterTypes()[0], null));
+                                } catch (Exception e) {
+                                    String exceptionDescription = ""Failed to set pojo "" + dest.getClass().getSimpleName() + "" property "" + name
+                                            + "" value "" + value + ""("" + value.getClass() + ""), cause: "" + e.getMessage();
+                                    logger.error(exceptionDescription, e);
+                                    throw new RuntimeException(exceptionDescription, e);
+                                }
+                            } else if (field != null) {
+                                value = realize0(value, field.getType(), field.getGenericType(), history);
+                                try {
+                                    forceSetFieldValue(field, dest, fromValueType(value, field.getType(), null));
+                                } catch (IllegalAccessException e) {
+                                    throw new RuntimeException(""Failed to set field "" + name + "" of pojo "" + dest.getClass().getName() + "" : "" + e.getMessage(), e);
+                                }
+                            }
+                        }
+                    }
+                }
+                if (dest instanceof Throwable) {
+                    Object message = map.get(""message"");
+                    if (message instanceof String) {
+                        try {
+                            Field field = Throwable.class.getDeclaredField(""detailMessage"");
+                            if (!field.isAccessible()) {
+                                field.setAccessible(true);
+                            }
+                            field.set(dest, message);
+                        } catch (Exception e) {
+                        }
+                    }
+                }
+                return dest;
+            }
+        }
+        return pojo;
+    }
+
+    private static boolean realizeGenericFeatures(Method method,Field field,Object value,Object dest ,String name,final Map<Object, Object> history ) {
+        Object rawValue = value;
+        if(field != null) {
+            GenericFeature genericFeature = field.getAnnotation(GenericFeature.class);
+            if (genericFeature != null && genericFeature.ignore()) {
+                return true;
+            }
+
+            if(genericFeature != null) {
+                if(genericFeature.nullNotRealize() && value == null) {
+                    return true;
+                }
+                if(value instanceof String) {
+                    value = fromValueType(value, field.getType(), genericFeature);
+                }
+                if(rawValue == value) {
+                    value = realize0(value, field.getType(), field.getGenericType(), history);
+                }
+
+                try {
+                    forceSetFieldValue(field, dest, value);
+                } catch (IllegalAccessException e) {
+                    throw new RuntimeException(""Failed to set field "" + name + "" of pojo "" + dest.getClass().getName() + "" : "" + e.getMessage(), e);
+                }
+                return true;
+            }
+        }
+        if(method == null) {
+            return false;
+        }
+        GenericFeature genericFeature = method.getAnnotation(GenericFeature.class);
+        if(genericFeature == null) {
+            return false;
+        }
+        if (genericFeature.ignore()) {
+            return true;
+        }
+
+        if (!method.isAccessible()) {
+            method.setAccessible(true);
+        }
+        if(genericFeature.nullNotRealize() && value == null) {
+            return true;
+        }
+        if (value instanceof String) {
+            value = fromValueType(value, method.getParameterTypes()[0], genericFeature);
+        }
+        if(rawValue == value) {
+            Type ptype = method.getGenericParameterTypes()[0];
+            value = realize0(value, method.getParameterTypes()[0], ptype, history);
+        }
+
+        try {
+            method.invoke(dest, value);
+        } catch (Exception e) {
+            String exceptionDescription = ""Failed to set pojo "" + dest.getClass().getSimpleName() + "" property "" + name
+                    + "" value "" + value + ""("" + value.getClass() + ""), cause: "" + e.getMessage();
+            logger.error(exceptionDescription, e);
+            throw new RuntimeException(exceptionDescription, e);
+        }
+        return true;
+
+    }
+
+    private static void forceSetFieldValue(Field field,Object dest,Object value) throws IllegalAccessException {
+        boolean isNotPublic = Modifier.isPublic(field.getModifiers());
+        if(!isNotPublic) {
+            field.setAccessible(true);
+        }
+        try{
+            field.set(dest,value);
+        } finally {
+            if(!isNotPublic) {
+                field.setAccessible(false);
+            }
+        }
+    }
+
+    /**
+     * Get parameterized type
+     *
+     * @param genericType generic type
+     * @param index       index of the target parameterized type
+     * @return Return Person.class for List<Person>, return Person.class for Map<String, Person> when index=0
+     */
+    private static Type getGenericClassByIndex(Type genericType, int index) {
+        Type clazz = null;
+        // find parameterized type
+        if (genericType instanceof ParameterizedType) {
+            ParameterizedType t = (ParameterizedType) genericType;
+            Type[] types = t.getActualTypeArguments();
+            clazz = types[index];
+        }
+        return clazz;
+    }
+
+    private static Object newInstance(Class<?> cls) {
+        try {
+            return cls.newInstance();
+        } catch (Throwable t) {
+            try {
+                Constructor<?>[] constructors = cls.getDeclar","[{'comment': 'Is it better to have a cache for this method?And i think it is better in `ReflectUtils.class`', 'commenter': 'lkj41110'}]"
4296,dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java,"@@ -1,628 +1,1012 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.common.utils;
-
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-
-import java.lang.reflect.Array;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Proxy;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Hashtable;
-import java.util.IdentityHashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.TreeMap;
-import java.util.WeakHashMap;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.ConcurrentSkipListMap;
-
-/**
- * PojoUtils. Travel object deeply, and convert complex type to simple type.
- * <p/>
- * Simple type below will be remained:
- * <ul>
- * <li> Primitive Type, also include <b>String</b>, <b>Number</b>(Integer, Long), <b>Date</b>
- * <li> Array of Primitive Type
- * <li> Collection, eg: List, Map, Set etc.
- * </ul>
- * <p/>
- * Other type will be covert to a map which contains the attributes and value pair of object.
- */
-public class PojoUtils {
-
-    private static final Logger logger = LoggerFactory.getLogger(PojoUtils.class);
-    private static final ConcurrentMap<String, Method> NAME_METHODS_CACHE = new ConcurrentHashMap<String, Method>();
-    private static final ConcurrentMap<Class<?>, ConcurrentMap<String, Field>> CLASS_FIELD_CACHE = new ConcurrentHashMap<Class<?>, ConcurrentMap<String, Field>>();
-
-    public static Object[] generalize(Object[] objs) {
-        Object[] dests = new Object[objs.length];
-        for (int i = 0; i < objs.length; i++) {
-            dests[i] = generalize(objs[i]);
-        }
-        return dests;
-    }
-
-    public static Object[] realize(Object[] objs, Class<?>[] types) {
-        if (objs.length != types.length) {
-            throw new IllegalArgumentException(""args.length != types.length"");
-        }
-
-        Object[] dests = new Object[objs.length];
-        for (int i = 0; i < objs.length; i++) {
-            dests[i] = realize(objs[i], types[i]);
-        }
-
-        return dests;
-    }
-
-    public static Object[] realize(Object[] objs, Class<?>[] types, Type[] gtypes) {
-        if (objs.length != types.length || objs.length != gtypes.length) {
-            throw new IllegalArgumentException(""args.length != types.length"");
-        }
-        Object[] dests = new Object[objs.length];
-        for (int i = 0; i < objs.length; i++) {
-            dests[i] = realize(objs[i], types[i], gtypes[i]);
-        }
-        return dests;
-    }
-
-    public static Object generalize(Object pojo) {
-        return generalize(pojo, new IdentityHashMap<Object, Object>());
-    }
-
-    @SuppressWarnings(""unchecked"")
-    private static Object generalize(Object pojo, Map<Object, Object> history) {
-        if (pojo == null) {
-            return null;
-        }
-
-        if (pojo instanceof Enum<?>) {
-            return ((Enum<?>) pojo).name();
-        }
-        if (pojo.getClass().isArray() && Enum.class.isAssignableFrom(pojo.getClass().getComponentType())) {
-            int len = Array.getLength(pojo);
-            String[] values = new String[len];
-            for (int i = 0; i < len; i++) {
-                values[i] = ((Enum<?>) Array.get(pojo, i)).name();
-            }
-            return values;
-        }
-
-        if (ReflectUtils.isPrimitives(pojo.getClass())) {
-            return pojo;
-        }
-
-        if (pojo instanceof Class) {
-            return ((Class) pojo).getName();
-        }
-
-        Object o = history.get(pojo);
-        if (o != null) {
-            return o;
-        }
-        history.put(pojo, pojo);
-
-        if (pojo.getClass().isArray()) {
-            int len = Array.getLength(pojo);
-            Object[] dest = new Object[len];
-            history.put(pojo, dest);
-            for (int i = 0; i < len; i++) {
-                Object obj = Array.get(pojo, i);
-                dest[i] = generalize(obj, history);
-            }
-            return dest;
-        }
-        if (pojo instanceof Collection<?>) {
-            Collection<Object> src = (Collection<Object>) pojo;
-            int len = src.size();
-            Collection<Object> dest = (pojo instanceof List<?>) ? new ArrayList<Object>(len) : new HashSet<Object>(len);
-            history.put(pojo, dest);
-            for (Object obj : src) {
-                dest.add(generalize(obj, history));
-            }
-            return dest;
-        }
-        if (pojo instanceof Map<?, ?>) {
-            Map<Object, Object> src = (Map<Object, Object>) pojo;
-            Map<Object, Object> dest = createMap(src);
-            history.put(pojo, dest);
-            for (Map.Entry<Object, Object> obj : src.entrySet()) {
-                dest.put(generalize(obj.getKey(), history), generalize(obj.getValue(), history));
-            }
-            return dest;
-        }
-        Map<String, Object> map = new HashMap<String, Object>();
-        history.put(pojo, map);
-        map.put(""class"", pojo.getClass().getName());
-        for (Method method : pojo.getClass().getMethods()) {
-            if (ReflectUtils.isBeanPropertyReadMethod(method)) {
-                try {
-                    map.put(ReflectUtils.getPropertyNameFromBeanReadMethod(method), generalize(method.invoke(pojo), history));
-                } catch (Exception e) {
-                    throw new RuntimeException(e.getMessage(), e);
-                }
-            }
-        }
-        // public field
-        for (Field field : pojo.getClass().getFields()) {
-            if (ReflectUtils.isPublicInstanceField(field)) {
-                try {
-                    Object fieldValue = field.get(pojo);
-                    if (history.containsKey(pojo)) {
-                        Object pojoGeneralizedValue = history.get(pojo);
-                        if (pojoGeneralizedValue instanceof Map
-                                && ((Map) pojoGeneralizedValue).containsKey(field.getName())) {
-                            continue;
-                        }
-                    }
-                    if (fieldValue != null) {
-                        map.put(field.getName(), generalize(fieldValue, history));
-                    }
-                } catch (Exception e) {
-                    throw new RuntimeException(e.getMessage(), e);
-                }
-            }
-        }
-        return map;
-    }
-
-    public static Object realize(Object pojo, Class<?> type) {
-        return realize0(pojo, type, null, new IdentityHashMap<Object, Object>());
-    }
-
-    public static Object realize(Object pojo, Class<?> type, Type genericType) {
-        return realize0(pojo, type, genericType, new IdentityHashMap<Object, Object>());
-    }
-
-    private static class PojoInvocationHandler implements InvocationHandler {
-
-        private Map<Object, Object> map;
-
-        public PojoInvocationHandler(Map<Object, Object> map) {
-            this.map = map;
-        }
-
-        @Override
-        @SuppressWarnings(""unchecked"")
-        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-            if (method.getDeclaringClass() == Object.class) {
-                return method.invoke(map, args);
-            }
-            String methodName = method.getName();
-            Object value = null;
-            if (methodName.length() > 3 && methodName.startsWith(""get"")) {
-                value = map.get(methodName.substring(3, 4).toLowerCase() + methodName.substring(4));
-            } else if (methodName.length() > 2 && methodName.startsWith(""is"")) {
-                value = map.get(methodName.substring(2, 3).toLowerCase() + methodName.substring(3));
-            } else {
-                value = map.get(methodName.substring(0, 1).toLowerCase() + methodName.substring(1));
-            }
-            if (value instanceof Map<?, ?> && !Map.class.isAssignableFrom(method.getReturnType())) {
-                value = realize0((Map<String, Object>) value, method.getReturnType(), null, new IdentityHashMap<Object, Object>());
-            }
-            return value;
-        }
-    }
-
-    @SuppressWarnings(""unchecked"")
-    private static Collection<Object> createCollection(Class<?> type, int len) {
-        if (type.isAssignableFrom(ArrayList.class)) {
-            return new ArrayList<Object>(len);
-        }
-        if (type.isAssignableFrom(HashSet.class)) {
-            return new HashSet<Object>(len);
-        }
-        if (!type.isInterface() && !Modifier.isAbstract(type.getModifiers())) {
-            try {
-                return (Collection<Object>) type.newInstance();
-            } catch (Exception e) {
-                // ignore
-            }
-        }
-        return new ArrayList<Object>();
-    }
-
-    private static Map createMap(Map src) {
-        Class<? extends Map> cl = src.getClass();
-        Map result = null;
-        if (HashMap.class == cl) {
-            result = new HashMap();
-        } else if (Hashtable.class == cl) {
-            result = new Hashtable();
-        } else if (IdentityHashMap.class == cl) {
-            result = new IdentityHashMap();
-        } else if (LinkedHashMap.class == cl) {
-            result = new LinkedHashMap();
-        } else if (Properties.class == cl) {
-            result = new Properties();
-        } else if (TreeMap.class == cl) {
-            result = new TreeMap();
-        } else if (WeakHashMap.class == cl) {
-            return new WeakHashMap();
-        } else if (ConcurrentHashMap.class == cl) {
-            result = new ConcurrentHashMap();
-        } else if (ConcurrentSkipListMap.class == cl) {
-            result = new ConcurrentSkipListMap();
-        } else {
-            try {
-                result = cl.newInstance();
-            } catch (Exception e) { /* ignore */ }
-
-            if (result == null) {
-                try {
-                    Constructor<?> constructor = cl.getConstructor(Map.class);
-                    result = (Map) constructor.newInstance(Collections.EMPTY_MAP);
-                } catch (Exception e) { /* ignore */ }
-            }
-        }
-
-        if (result == null) {
-            result = new HashMap<Object, Object>();
-        }
-
-        return result;
-    }
-
-    @SuppressWarnings({""unchecked"", ""rawtypes""})
-    private static Object realize0(Object pojo, Class<?> type, Type genericType, final Map<Object, Object> history) {
-        if (pojo == null) {
-            return null;
-        }
-
-        if (type != null && type.isEnum() && pojo.getClass() == String.class) {
-            return Enum.valueOf((Class<Enum>) type, (String) pojo);
-        }
-
-        if (ReflectUtils.isPrimitives(pojo.getClass())
-                && !(type != null && type.isArray()
-                && type.getComponentType().isEnum()
-                && pojo.getClass() == String[].class)) {
-            return CompatibleTypeUtils.compatibleTypeConvert(pojo, type);
-        }
-
-        Object o = history.get(pojo);
-
-        if (o != null) {
-            return o;
-        }
-
-        history.put(pojo, pojo);
-
-        if (pojo.getClass().isArray()) {
-            if (Collection.class.isAssignableFrom(type)) {
-                Class<?> ctype = pojo.getClass().getComponentType();
-                int len = Array.getLength(pojo);
-                Collection dest = createCollection(type, len);
-                history.put(pojo, dest);
-                for (int i = 0; i < len; i++) {
-                    Object obj = Array.get(pojo, i);
-                    Object value = realize0(obj, ctype, null, history);
-                    dest.add(value);
-                }
-                return dest;
-            } else {
-                Class<?> ctype = (type != null && type.isArray() ? type.getComponentType() : pojo.getClass().getComponentType());
-                int len = Array.getLength(pojo);
-                Object dest = Array.newInstance(ctype, len);
-                history.put(pojo, dest);
-                for (int i = 0; i < len; i++) {
-                    Object obj = Array.get(pojo, i);
-                    Object value = realize0(obj, ctype, null, history);
-                    Array.set(dest, i, value);
-                }
-                return dest;
-            }
-        }
-
-        if (pojo instanceof Collection<?>) {
-            if (type.isArray()) {
-                Class<?> ctype = type.getComponentType();
-                Collection<Object> src = (Collection<Object>) pojo;
-                int len = src.size();
-                Object dest = Array.newInstance(ctype, len);
-                history.put(pojo, dest);
-                int i = 0;
-                for (Object obj : src) {
-                    Object value = realize0(obj, ctype, null, history);
-                    Array.set(dest, i, value);
-                    i++;
-                }
-                return dest;
-            } else {
-                Collection<Object> src = (Collection<Object>) pojo;
-                int len = src.size();
-                Collection<Object> dest = createCollection(type, len);
-                history.put(pojo, dest);
-                for (Object obj : src) {
-                    Type keyType = getGenericClassByIndex(genericType, 0);
-                    Class<?> keyClazz = obj == null ? null : obj.getClass();
-                    if (keyType instanceof Class) {
-                        keyClazz = (Class<?>) keyType;
-                    }
-                    Object value = realize0(obj, keyClazz, keyType, history);
-                    dest.add(value);
-                }
-                return dest;
-            }
-        }
-
-        if (pojo instanceof Map<?, ?> && type != null) {
-            Object className = ((Map<Object, Object>) pojo).get(""class"");
-            if (className instanceof String) {
-                try {
-                    type = ClassUtils.forName((String) className);
-                } catch (ClassNotFoundException e) {
-                    // ignore
-                }
-            }
-
-            // special logic for enum
-            if (type.isEnum()) {
-                Object name = ((Map<Object, Object>) pojo).get(""name"");
-                if (name != null) {
-                    return Enum.valueOf((Class<Enum>) type, name.toString());
-                }
-            }
-            Map<Object, Object> map;
-            // when return type is not the subclass of return type from the signature and not an interface
-            if (!type.isInterface() && !type.isAssignableFrom(pojo.getClass())) {
-                try {
-                    map = (Map<Object, Object>) type.newInstance();
-                    Map<Object, Object> mapPojo = (Map<Object, Object>) pojo;
-                    map.putAll(mapPojo);
-                    map.remove(""class"");
-                } catch (Exception e) {
-                    //ignore error
-                    map = (Map<Object, Object>) pojo;
-                }
-            } else {
-                map = (Map<Object, Object>) pojo;
-            }
-
-            if (Map.class.isAssignableFrom(type) || type == Object.class) {
-                final Map<Object, Object> result = createMap(map);
-                history.put(pojo, result);
-                for (Map.Entry<Object, Object> entry : map.entrySet()) {
-                    Type keyType = getGenericClassByIndex(genericType, 0);
-                    Type valueType = getGenericClassByIndex(genericType, 1);
-                    Class<?> keyClazz;
-                    if (keyType instanceof Class) {
-                        keyClazz = (Class<?>) keyType;
-                    } else if (keyType instanceof ParameterizedType) {
-                        keyClazz = (Class<?>) ((ParameterizedType) keyType).getRawType();
-                    } else {
-                        keyClazz = entry.getKey() == null ? null : entry.getKey().getClass();
-                    }
-                    Class<?> valueClazz;
-                    if (valueType instanceof Class) {
-                        valueClazz = (Class<?>) valueType;
-                    } else if (valueType instanceof ParameterizedType) {
-                        valueClazz = (Class<?>) ((ParameterizedType) valueType).getRawType();
-                    } else {
-                        valueClazz = entry.getValue() == null ? null : entry.getValue().getClass();
-                    }
-
-                    Object key = keyClazz == null ? entry.getKey() : realize0(entry.getKey(), keyClazz, keyType, history);
-                    Object value = valueClazz == null ? entry.getValue() : realize0(entry.getValue(), valueClazz, valueType, history);
-                    result.put(key, value);
-                }
-                return result;
-            } else if (type.isInterface()) {
-                Object dest = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[]{type}, new PojoInvocationHandler(map));
-                history.put(pojo, dest);
-                return dest;
-            } else {
-                Object dest = newInstance(type);
-                history.put(pojo, dest);
-                for (Map.Entry<Object, Object> entry : map.entrySet()) {
-                    Object key = entry.getKey();
-                    if (key instanceof String) {
-                        String name = (String) key;
-                        Object value = entry.getValue();
-                        if (value != null) {
-                            Method method = getSetterMethod(dest.getClass(), name, value.getClass());
-                            Field field = getField(dest.getClass(), name);
-                            if (method != null) {
-                                if (!method.isAccessible()) {
-                                    method.setAccessible(true);
-                                }
-                                Type ptype = method.getGenericParameterTypes()[0];
-                                value = realize0(value, method.getParameterTypes()[0], ptype, history);
-                                try {
-                                    method.invoke(dest, value);
-                                } catch (Exception e) {
-                                    String exceptionDescription = ""Failed to set pojo "" + dest.getClass().getSimpleName() + "" property "" + name
-                                            + "" value "" + value + ""("" + value.getClass() + ""), cause: "" + e.getMessage();
-                                    logger.error(exceptionDescription, e);
-                                    throw new RuntimeException(exceptionDescription, e);
-                                }
-                            } else if (field != null) {
-                                value = realize0(value, field.getType(), field.getGenericType(), history);
-                                try {
-                                    field.set(dest, value);
-                                } catch (IllegalAccessException e) {
-                                    throw new RuntimeException(""Failed to set field "" + name + "" of pojo "" + dest.getClass().getName() + "" : "" + e.getMessage(), e);
-                                }
-                            }
-                        }
-                    }
-                }
-                if (dest instanceof Throwable) {
-                    Object message = map.get(""message"");
-                    if (message instanceof String) {
-                        try {
-                            Field field = Throwable.class.getDeclaredField(""detailMessage"");
-                            if (!field.isAccessible()) {
-                                field.setAccessible(true);
-                            }
-                            field.set(dest, message);
-                        } catch (Exception e) {
-                        }
-                    }
-                }
-                return dest;
-            }
-        }
-        return pojo;
-    }
-
-    /**
-     * Get parameterized type
-     *
-     * @param genericType generic type
-     * @param index       index of the target parameterized type
-     * @return Return Person.class for List<Person>, return Person.class for Map<String, Person> when index=0
-     */
-    private static Type getGenericClassByIndex(Type genericType, int index) {
-        Type clazz = null;
-        // find parameterized type
-        if (genericType instanceof ParameterizedType) {
-            ParameterizedType t = (ParameterizedType) genericType;
-            Type[] types = t.getActualTypeArguments();
-            clazz = types[index];
-        }
-        return clazz;
-    }
-
-    private static Object newInstance(Class<?> cls) {
-        try {
-            return cls.newInstance();
-        } catch (Throwable t) {
-            try {
-                Constructor<?>[] constructors = cls.getDeclaredConstructors();
-                /**
-                 * From Javadoc java.lang.Class#getDeclaredConstructors
-                 * This method returns an array of Constructor objects reflecting all the constructors
-                 * declared by the class represented by this Class object.
-                 * This method returns an array of length 0,
-                 * if this Class object represents an interface, a primitive type, an array class, or void.
-                 */
-                if (constructors.length == 0) {
-                    throw new RuntimeException(""Illegal constructor: "" + cls.getName());
-                }
-                Constructor<?> constructor = constructors[0];
-                if (constructor.getParameterTypes().length > 0) {
-                    for (Constructor<?> c : constructors) {
-                        if (c.getParameterTypes().length < constructor.getParameterTypes().length) {
-                            constructor = c;
-                            if (constructor.getParameterTypes().length == 0) {
-                                break;
-                            }
-                        }
-                    }
-                }
-                constructor.setAccessible(true);
-                Object[] parameters = Arrays.stream(constructor.getParameterTypes()).map(PojoUtils::getDefaultValue).toArray();
-                return constructor.newInstance(parameters);
-            } catch (InstantiationException e) {
-                throw new RuntimeException(e.getMessage(), e);
-            } catch (IllegalAccessException e) {
-                throw new RuntimeException(e.getMessage(), e);
-            } catch (InvocationTargetException e) {
-                throw new RuntimeException(e.getMessage(), e);
-            }
-        }
-    }
-
-    /**
-     * return init value
-     * @param parameterType
-     * @return
-     */
-    private static Object getDefaultValue(Class<?> parameterType) {
-        if (parameterType.getName().equals(""char"")) {
-            return Character.MIN_VALUE;
-        }
-        if (parameterType.getName().equals(""bool"")) {
-            return false;
-        }
-        return parameterType.isPrimitive() ? 0 : null;
-    }
-
-    private static Method getSetterMethod(Class<?> cls, String property, Class<?> valueCls) {
-        String name = ""set"" + property.substring(0, 1).toUpperCase() + property.substring(1);
-        Method method = NAME_METHODS_CACHE.get(cls.getName() + ""."" + name + ""("" + valueCls.getName() + "")"");
-        if (method == null) {
-            try {
-                method = cls.getMethod(name, valueCls);
-            } catch (NoSuchMethodException e) {
-                for (Method m : cls.getMethods()) {
-                    if (ReflectUtils.isBeanPropertyWriteMethod(m) && m.getName().equals(name)) {
-                        method = m;
-                        break;
-                    }
-                }
-            }
-            if (method != null) {
-                NAME_METHODS_CACHE.put(cls.getName() + ""."" + name + ""("" + valueCls.getName() + "")"", method);
-            }
-        }
-        return method;
-    }
-
-    private static Field getField(Class<?> cls, String fieldName) {
-        Field result = null;
-        if (CLASS_FIELD_CACHE.containsKey(cls) && CLASS_FIELD_CACHE.get(cls).containsKey(fieldName)) {
-            return CLASS_FIELD_CACHE.get(cls).get(fieldName);
-        }
-        try {
-            result = cls.getDeclaredField(fieldName);
-            result.setAccessible(true);
-        } catch (NoSuchFieldException e) {
-            for (Field field : cls.getFields()) {
-                if (fieldName.equals(field.getName()) && ReflectUtils.isPublicInstanceField(field)) {
-                    result = field;
-                    break;
-                }
-            }
-        }
-        if (result != null) {
-            ConcurrentMap<String, Field> fields = CLASS_FIELD_CACHE.get(cls);
-            if (fields == null) {
-                fields = new ConcurrentHashMap<String, Field>();
-                CLASS_FIELD_CACHE.putIfAbsent(cls, fields);
-            }
-            fields = CLASS_FIELD_CACHE.get(cls);
-            fields.putIfAbsent(fieldName, result);
-        }
-        return result;
-    }
-
-    public static boolean isPojo(Class<?> cls) {
-        return !ReflectUtils.isPrimitives(cls)
-                && !Collection.class.isAssignableFrom(cls)
-                && !Map.class.isAssignableFrom(cls);
-    }
-
-}
+/*","[{'comment': 'please recover file end-line format', 'commenter': 'AlbumenJ'}]"
4296,dubbo-demo/dubbo-generic-demo/dubbo-generic-demo-consumer/src/main/java/org/apache/dubbo/demo/consumer/Application.java,"@@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.demo.consumer;
+
+import org.apache.dubbo.config.ReferenceConfig;
+import org.apache.dubbo.rpc.service.GenericService;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class Application {
+    /**
+     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before
+     * launch the application
+     */
+    public static void main(String[] args) {
+        ReferenceConfig<GenericService> reference = new ReferenceConfig<GenericService>();
+        // 弱类型接口名
+        reference.setInterface(""org.apache.dubbo.demo.provider.DemoGenericService"");
+        reference.setVersion(""1.0.0"");
+        // 声明为泛化接口","[{'comment': 'pls comment in English', 'commenter': 'AlbumenJ'}]"
4296,dubbo-demo/dubbo-generic-demo/dubbo-generic-demo-provider/src/main/java/org/apache/dubbo/demo/provider/RequestDemo.java,"@@ -0,0 +1,55 @@
+package org.apache.dubbo.demo.provider;
+
+import org.apache.dubbo.common.annotations.GenericFeature;
+
+import java.util.Map;
+
+/**
+ * @author hexiufeng","[{'comment': 'pls remove author field, thx.', 'commenter': 'AlbumenJ'}]"
4324,dubbo-filter/dubbo-filter-cache/src/main/java/org/apache/dubbo/cache/support/expiring/ExpiringMap.java,"@@ -263,7 +264,7 @@ public String toString() {
         }
 
         public ExpireThread() {
-            expirerThread = new Thread(this, ""ExpiryMapExpire-"" + expireCount++);
+            expirerThread = new Thread(this, ""ExpiryMapExpire-"" + expireCount.getAndIncrement());","[{'comment': 'expireCount.incrementAndGet()', 'commenter': 'lixiaojiee'}, {'comment': '@lixiaojiee Please test, i++ means to use first, then +1;\r\n', 'commenter': 'slievrly'}, {'comment': 'My fault', 'commenter': 'lixiaojiee'}]"
4334,dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java,"@@ -129,6 +129,8 @@ public static Object compatibleTypeConvert(Object value, Class<?> type) {
                 return BigDecimal.valueOf(number.doubleValue());
             } else if (type == Date.class) {
                 return new Date(number.longValue());
+            } else if (type == boolean.class || type == Boolean.class) {
+                return 1 == number.intValue() ? Boolean.TRUE : Boolean.FALSE;","[{'comment': 'please change to `return number.intValue() != 0`:\r\n0 return false, else return true.', 'commenter': 'zonghaishang'}, {'comment': 'It has been modified', 'commenter': 'nullcodeexecutor'}]"
4358,dubbo-remoting/dubbo-remoting-etcd3/src/main/java/org/apache/dubbo/remoting/etcd/jetcd/JEtcdClient.java,"@@ -447,7 +447,11 @@ protected void closeWatchRequest() {
             if (this.watchRequest == null) {
                 return;
             }
-            this.watchRequest.onCompleted();","[{'comment': 'change to :\r\n\r\n```java\r\nprotected void closeWatchRequest() {\r\n    if (this.watchRequest == null) {\r\n        return;\r\n    }\r\n\r\n    try{\r\n        WatchCancelRequest watchCancelRequest =\r\n                WatchCancelRequest.newBuilder().setWatchId(watchId).build();\r\n        WatchRequest cancelRequest = WatchRequest.newBuilder()\r\n                .setCancelRequest(watchCancelRequest).build();\r\n        watchRequest.onNext(cancelRequest);\r\n    }finally {\r\n        this.watchRequest.onCompleted();\r\n        this.watchRequest = null;\r\n    }\r\n\r\n}\r\n```', 'commenter': 'zonghaishang'}, {'comment': ""I think it's fine. We can always reformat the code at any time, considering the author fails to response. I will merge it."", 'commenter': 'beiwei30'}]"
4359,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/RegistryConfig.java,"@@ -432,4 +437,15 @@ public boolean isValid() {
         return !StringUtils.isEmpty(address);
     }
 
+    protected void updatePortIfAbsent(Integer value) {
+        if (value != null && port == null) {","[{'comment': 'change to `if (value != null && value > 0 && port == null) {`', 'commenter': 'zonghaishang'}]"
4365,dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java,"@@ -765,7 +770,15 @@ private void saveInExtensionClass(Map<String, Class<?>> extensionClasses, Class<
         if (c == null) {
             extensionClasses.put(name, clazz);
         } else if (c != clazz) {
-            throw new IllegalStateException(""Duplicate extension "" + type.getName() + "" name "" + name + "" on "" + c.getName() + "" and "" + clazz.getName());
+            duplicateExceptionMsg.append(""Duplicate extension "")
+                    .append(type.getName())
+                    .append("" name "")
+                    .append(name)
+                    .append("" on "")
+                    .append(c.getName())
+                    .append("" and "")
+                    .append(clazz.getName())
+                    .append(""\r\n"");","[{'comment': 'I recommend switching to System.lineSeparator() better, what do you think?', 'commenter': 'manzhizhen'}]"
4365,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ApplicationConfig.java,"@@ -147,6 +148,11 @@
      */
     private String shutwait;
 
+    /**
+     * when in initialization process,throw {@link org.apache.dubbo.common.extension.DubboInitCheckException},stop program
+     */
+    private Boolean check;","[{'comment': 'I think `dubbo.application.check` is a little too ambiguous.\r\n\r\nWould `extension-loader.duplicate.check` be better? And I also think there\'s no necessity to declare it in the main trunk, users who want to change the default value can declare in `parameters`.\r\n1. XML\r\n```xml\r\n<dubbo:application>\r\n   <dubbo:parameter key=""dubbo.application.extension-loader.duplicate.check"" value=true />\r\n</dubbo:application>\r\n```\r\n\r\n2. properties file\r\n```properties\r\ndubbo.application.parameters.extension-loader.duplicate.check=true\r\n```', 'commenter': 'chickenlj'}, {'comment': 'Maybe our original intention is different. I assume a scene: when I accidentally customize a dubbo internal filter（just the same name） in another framework, when user use these two jars(our framework & dubbo), how can you guarantee who is loaded first. According to dubbo currently, the first filter loaded will enter the filter chain, and the later loaded same name filter will throw an exception, but this exception is eaten, how do you notify the user. At least we have encountered this situation in Win10 and Centos7, and there is no exception, but the filter does not work.', 'commenter': 'masteryourself'}]"
4388,dubbo-configcenter/dubbo-configcenter-etcd/src/main/java/org/apache/dubbo/configcenter/support/etcd/EtcdDynamicConfiguration.java,"@@ -179,7 +174,6 @@ private void watch() {
                     .setKey(ByteString.copyFromUtf8(key))
                     .setProgressNotify(true);
             WatchRequest req = WatchRequest.newBuilder().setCreateRequest(builder).build();
-            observer.onNext(req);","[{'comment': 'Why remove this line?', 'commenter': 'ralf0131'}, {'comment': 'Oops! this is an unexpected deletion. I will add it back.', 'commenter': 'chickenlj'}]"
4388,dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java,"@@ -81,47 +82,29 @@ public Object getInternalProperty(String key) {
      */
     @Override
     public void addListener(String key, String group, ConfigurationListener listener) {
-        cacheListener.addListener(key, listener);
+        cacheListener.addListener(getPathKey(group, key), listener);
     }
 
     @Override
     public void removeListener(String key, String group, ConfigurationListener listener) {
-        cacheListener.removeListener(key, listener);
+        cacheListener.removeListener(getPathKey(group, key), listener);
     }
 
     @Override
-    public String getConfig(String key, String group, long timeout) throws IllegalStateException {
-        /**
-         * when group is not null, we are getting startup configs from Config Center, for example:
-         * group=dubbo, key=dubbo.properties
-         */
-        if (StringUtils.isNotEmpty(group)) {
-            key = group + ""/"" + key;
-        }
-        /**
-         * when group is null, we are fetching governance rules, for example:
-         * 1. key=org.apache.dubbo.DemoService.configurators
-         * 2. key = org.apache.dubbo.DemoService.condition-router
-         */
-        else {
-            int i = key.lastIndexOf(""."");
-            key = key.substring(0, i) + ""/"" + key.substring(i + 1);
-        }
-
-        return (String) getInternalProperty(rootPath + ""/"" + key);
+    public String getRule(String key, String group, long timeout) throws IllegalStateException {
+        return (String) getInternalProperty(getPathKey(group, key));
     }
 
-    /**
-     * For zookeeper, {@link #getConfig(String, String, long)} and {@link #getConfigs(String, String, long)} have the same meaning.
-     *
-     * @param key
-     * @param group
-     * @param timeout
-     * @return
-     * @throws IllegalStateException
-     */
     @Override
-    public String getConfigs(String key, String group, long timeout) throws IllegalStateException {
-        return (String) getConfig(key, group, timeout);
+    public String getProperties(String key, String group, long timeout) throws IllegalStateException {","[{'comment': 'This can be put to parent as default method.', 'commenter': 'ralf0131'}, {'comment': 'put it in the next major version https://github.com/apache/dubbo/pull/4388', 'commenter': 'chickenlj'}]"
4388,dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java,"@@ -81,47 +82,29 @@ public Object getInternalProperty(String key) {
      */
     @Override
     public void addListener(String key, String group, ConfigurationListener listener) {
-        cacheListener.addListener(key, listener);
+        cacheListener.addListener(getPathKey(group, key), listener);
     }
 
     @Override
     public void removeListener(String key, String group, ConfigurationListener listener) {
-        cacheListener.removeListener(key, listener);
+        cacheListener.removeListener(getPathKey(group, key), listener);
     }
 
     @Override
-    public String getConfig(String key, String group, long timeout) throws IllegalStateException {
-        /**
-         * when group is not null, we are getting startup configs from Config Center, for example:
-         * group=dubbo, key=dubbo.properties
-         */
-        if (StringUtils.isNotEmpty(group)) {
-            key = group + ""/"" + key;
-        }
-        /**
-         * when group is null, we are fetching governance rules, for example:
-         * 1. key=org.apache.dubbo.DemoService.configurators
-         * 2. key = org.apache.dubbo.DemoService.condition-router
-         */
-        else {
-            int i = key.lastIndexOf(""."");
-            key = key.substring(0, i) + ""/"" + key.substring(i + 1);
-        }
-
-        return (String) getInternalProperty(rootPath + ""/"" + key);
+    public String getRule(String key, String group, long timeout) throws IllegalStateException {
+        return (String) getInternalProperty(getPathKey(group, key));
     }
 
-    /**
-     * For zookeeper, {@link #getConfig(String, String, long)} and {@link #getConfigs(String, String, long)} have the same meaning.
-     *
-     * @param key
-     * @param group
-     * @param timeout
-     * @return
-     * @throws IllegalStateException
-     */
     @Override
-    public String getConfigs(String key, String group, long timeout) throws IllegalStateException {
-        return (String) getConfig(key, group, timeout);
+    public String getProperties(String key, String group, long timeout) throws IllegalStateException {
+        // use global group 'dubbo' if no group specified
+        if (StringUtils.isEmpty(group)) {
+            group = DEFAULT_GROUP;
+        }
+        return (String) getInternalProperty(getPathKey(group, key));
+    }
+
+    private String getPathKey(String group, String key) {","[{'comment': 'And so does this method, I see it in ZK, etcd, consule implementation. ', 'commenter': 'ralf0131'}, {'comment': 'resolve in the next version https://github.com/apache/dubbo/pull/4388', 'commenter': 'chickenlj'}]"
4413,dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/MockInvokerTest.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.support;
+
+import java.io.Serializable;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.*;","[{'comment': 'pls do not use `import *`', 'commenter': 'Moriadry-zz'}, {'comment': 'Apologies, I missed that. I have removed the wildcard', 'commenter': 'EricHetti'}]"
4425,dubbo-common/src/main/java/org/apache/dubbo/common/io/Bytes.java,"@@ -620,6 +620,9 @@ public static String bytes2base64(final byte[] bs, final int off, final int len,
         if (len < 0) {
             throw new IndexOutOfBoundsException(""base642bytes: length < 0, length is "" + len);
         }
+        if (len == 0) {","[{'comment': 'pls. consider to add the same check for *public static byte[] base642bytes(final String str, final int off, final int len, final char[] code) *', 'commenter': 'beiwei30'}]"
4431,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java,"@@ -212,6 +214,9 @@ private boolean checkAddressMatch(List<String> addresses, String host, int port)
                 if (NetUtils.matchIpExpression(address, host, port)) {
                     return true;
                 }
+                if ((ALL_IP_MATCH + "":"" + port).equals(address)) {","[{'comment': 'Reuse CommonConstants.ANYHOST would be better.', 'commenter': 'chickenlj'}, {'comment': 'ok', 'commenter': 'cvictory'}]"
4493,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java,"@@ -16,6 +16,22 @@
  */
 package org.apache.dubbo.remoting.transport.netty4;
 
+import io.netty.bootstrap.Bootstrap;","[{'comment': ""pls. don't change import order. Refer to https://github.com/apache/dubbo/blob/master/CONTRIBUTING.md#code-style for the details."", 'commenter': 'beiwei30'}]"
4493,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java,"@@ -28,32 +44,26 @@
 import org.apache.dubbo.remoting.transport.AbstractClient;
 import org.apache.dubbo.remoting.utils.UrlUtils;
 
-import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.PooledByteBufAllocator;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.handler.proxy.Socks5ProxyHandler;
-import io.netty.handler.timeout.IdleStateHandler;
-import io.netty.util.concurrent.DefaultThreadFactory;
+import java.net.InetSocketAddress;
+import java.util.Locale;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
-import java.net.InetSocketAddress;
-
 /**
  * NettyClient.
  */
 public class NettyClient extends AbstractClient {
 
     private static final Logger logger = LoggerFactory.getLogger(NettyClient.class);
+
+    /**
+     * the os name
+     */
+    private static final String osName = SystemPropertyUtil.get(""os.name"").toLowerCase(Locale.UK).trim();","[{'comment': 'use *Locale.ENGLISH* instead of *Locale.UK*', 'commenter': 'beiwei30'}]"
4493,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java,"@@ -28,32 +44,26 @@
 import org.apache.dubbo.remoting.transport.AbstractClient;
 import org.apache.dubbo.remoting.utils.UrlUtils;
 
-import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.PooledByteBufAllocator;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.handler.proxy.Socks5ProxyHandler;
-import io.netty.handler.timeout.IdleStateHandler;
-import io.netty.util.concurrent.DefaultThreadFactory;
+import java.net.InetSocketAddress;
+import java.util.Locale;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
-import java.net.InetSocketAddress;
-
 /**
  * NettyClient.
  */
 public class NettyClient extends AbstractClient {
 
     private static final Logger logger = LoggerFactory.getLogger(NettyClient.class);
+
+    /**
+     * the os name
+     */
+    private static final String osName = SystemPropertyUtil.get(""os.name"").toLowerCase(Locale.UK).trim();
     /**
      * netty client bootstrap
      */
-    private static final NioEventLoopGroup nioEventLoopGroup = new NioEventLoopGroup(Constants.DEFAULT_IO_THREADS, new DefaultThreadFactory(""NettyClientWorker"", true));
+    private static final EventLoopGroup eventLoopGroup = ""linux"".equals(osName) ?  new EpollEventLoopGroup(Constants.DEFAULT_IO_THREADS, new DefaultThreadFactory(""NettyClientWorker"", true)): new NioEventLoopGroup(Constants.DEFAULT_IO_THREADS, new DefaultThreadFactory(""NettyClientWorker"", true));","[{'comment': 'pls. pay attention to line wrap, which should be 120 column wide. Is it better to rewrite like this:\r\n\r\n```java\r\n    private static EventLoopGroup eventLoopGroup() {\r\n        String osName = SystemPropertyUtil.get(""os.name"").toLowerCase(Locale.ENGLISH).trim();\r\n        return ""linux"".equals(osName) ?\r\n                new EpollEventLoopGroup(Constants.DEFAULT_IO_THREADS, new DefaultThreadFactory(""NettyClientWorker"", true)) :\r\n                new NioEventLoopGroup(Constants.DEFAULT_IO_THREADS, new DefaultThreadFactory(""NettyClientWorker"", true));\r\n    }\r\n```', 'commenter': 'beiwei30'}]"
4493,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClient.java,"@@ -89,23 +99,23 @@ public NettyClient(final URL url, final ChannelHandler handler) throws RemotingE
     protected void doOpen() throws Throwable {
         final NettyClientHandler nettyClientHandler = new NettyClientHandler(getUrl(), this);
         bootstrap = new Bootstrap();
-        bootstrap.group(nioEventLoopGroup)
+        bootstrap.group(eventLoopGroup)","[{'comment': 'if we have two factory methods, then we can change this logic to \r\n\r\n```java\r\n        bootstrap.group(eventLoopGroup())\r\n                .option(ChannelOption.SO_KEEPALIVE, true)\r\n                .option(ChannelOption.TCP_NODELAY, true)\r\n                .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\r\n                //.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout())\r\n                .channel(socketChannelClass());\r\n```\r\n\r\nsocketChannelClass()\r\n\r\n```java\r\n    private static Class<? extends SocketChannel> socketChannelClass() {\r\n        String osName = SystemPropertyUtil.get(""os.name"").toLowerCase(Locale.ENGLISH).trim();\r\n        return ""linux"".equals(osName) ? EpollSocketChannel.class : NioSocketChannel.class)\r\n    }\r\n```', 'commenter': 'beiwei30'}]"
4493,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServer.java,"@@ -56,6 +61,12 @@
 public class NettyServer extends AbstractServer implements Server {
 
     private static final Logger logger = LoggerFactory.getLogger(NettyServer.class);
+
+    /**
+     * the os name
+     */
+    private static final String osName = SystemPropertyUtil.get(""os.name"").toLowerCase(Locale.UK).trim();","[{'comment': 'ditto', 'commenter': 'beiwei30'}]"
4493,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServer.java,"@@ -16,35 +16,40 @@
  */
 package org.apache.dubbo.remoting.transport.netty4;
 
+import io.netty.bootstrap.ServerBootstrap;","[{'comment': 'ditto', 'commenter': 'beiwei30'}]"
4493,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServer.java,"@@ -87,22 +98,28 @@ public NettyServer(URL url, ChannelHandler handler) throws RemotingException {
     @Override
     protected void doOpen() throws Throwable {
         bootstrap = new ServerBootstrap();
-
-        bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory(""NettyServerBoss"", true));
-        workerGroup = new NioEventLoopGroup(getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),
-                new DefaultThreadFactory(""NettyServerWorker"", true));
-
+        Class<? extends ServerChannel> channelServerHandler = null;
+        if (""linux"".equals(osName)) {","[{'comment': 'pls. consider to introduce factory method too.', 'commenter': 'beiwei30'}]"
4593,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -280,7 +280,7 @@ private void init() {
         map.put(SIDE_KEY, CONSUMER_SIDE);
 
         appendRuntimeParameters(map);
-        if (!isGeneric()) {
+        if (!Boolean.valueOf(getGeneric())) {","[{'comment': ""getGeneric() can return non-boolean-literal value, such as 'bean' or 'nativejava'"", 'commenter': 'chickenlj'}]"
4606,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/extension/GraceFulShutDown.java,"@@ -0,0 +1,42 @@
+package org.apache.dubbo.config.spring.extension;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * this interface is used to enable grace shutdown
+ * any class implements this interface should be a spring bean
+ * @since 2.7.3
+ */
+public interface GraceFulShutDown {
+
+
+    /**
+     * it is the beginning stage of shut down
+     * some resources should be closed after  dubbo registries are destroyed but before dubbo connections are destroyed
+     * so you should do something in close method
+     * at this moment,some dubbo rpc invoke may be executing now,so any destroy method for are forbidden
+     * for example, kafka message consumer should stop the poll method at this stage
+     */
+    default void afterRegistriesDestroyed(){}","[{'comment': ""Pls. pay attention to code style, e.g, a space is required betwee ')' and '{'.  You can import https://github.com/apache/dubbo/tree/master/codestyle and examine your change throughly. "", 'commenter': 'beiwei30'}, {'comment': 'Get it', 'commenter': 'kele6413430'}]"
4606,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/extension/GraceFulShutDown.java,"@@ -0,0 +1,42 @@
+package org.apache.dubbo.config.spring.extension;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * this interface is used to enable grace shutdown
+ * any class implements this interface should be a spring bean
+ * @since 2.7.3
+ */
+public interface GraceFulShutDown {","[{'comment': ""This interface is introduced to work and work only with spring framework. I am wondering: should we make it work for all scenarios? A quick thought is, should we make GracefulShutDown (or rename it to 'DubboLifecycle') an dubbo extension and let DubboShutdownHook to hold it?"", 'commenter': 'beiwei30'}, {'comment': 'good idea,I will edit resolve it later!', 'commenter': 'kele6413430'}]"
4618,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -418,7 +418,7 @@ private T createProxy(Map<String, String> map) {
             throw new IllegalStateException(""Failed to check the status of the service "" + interfaceName + "". No provider available for the service "" + (group == null ? """" : group + ""/"") + interfaceName + (version == null ? """" : "":"" + version) + "" from the url "" + invoker.getUrl() + "" to the consumer "" + NetUtils.getLocalHost() + "" use dubbo version "" + Version.getVersion());
         }
         if (logger.isInfoEnabled()) {
-            logger.info(""Refer dubbo service "" + interfaceClass.getName() + "" from url "" + invoker.getUrl());
+            logger.info(String.format(""Refer %s service %s from url %s"", StringUtils.isNotEmpty(getProtocol()) ? getProtocol() : ""dubbo"", interfaceClass.getName(), invoker.getUrl()));","[{'comment': ""Here 'dubbo' doesn't mean protocol but 'dubbo service'. Since protocol is in url, I don't think it is necessary to emphasis it."", 'commenter': 'beiwei30'}, {'comment': 'OK, I just found it is easy to ignore the protocol of service from the log.', 'commenter': 'tswstarplanet'}]"
4618,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -578,7 +578,7 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r
             // export to remote if the config is not local (export to local only when config is local)
             if (!SCOPE_LOCAL.equalsIgnoreCase(scope)) {
                 if (!isOnlyInJvm() && logger.isInfoEnabled()) {
-                    logger.info(""Export dubbo service "" + interfaceClass.getName() + "" to url "" + url);
+                    logger.info(String.format(""Export %s service %s to url %s"", getProtocol() != null ? getProtocol().getName() : ""dubbo"", interfaceClass.getName(),  url));","[{'comment': 'same, pls. leave dubbo as is.', 'commenter': 'beiwei30'}]"
4618,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -640,7 +640,7 @@ private void exportLocal(URL url) {
         Exporter<?> exporter = protocol.export(
                 PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, local));
         exporters.add(exporter);
-        logger.info(""Export dubbo service "" + interfaceClass.getName() + "" to local registry url : "" + local);
+        logger.info(String.format(""Export %s service %s to local registry url : "", getProtocol() == null ? ""dubbo"" : getProtocol().getName(), interfaceClass.getName(), local));","[{'comment': 'same, pls. leave dubbo as is.', 'commenter': 'beiwei30'}]"
4629,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java,"@@ -262,10 +272,19 @@ protected String getContextPath(URL url) {
 
     protected class ConnectionMonitor extends Thread {
         private volatile boolean shutdown;
-        private final List<PoolingHttpClientConnectionManager> connectionManagers = Collections.synchronizedList(new LinkedList<>());
+        private final Map<String, PoolingHttpClientConnectionManager> connectionManagers = new ConcurrentHashMap<>();
+
+        public void addConnectionManager(String key, PoolingHttpClientConnectionManager connectionManager) {
+            connectionManagers.put(key, connectionManager);
+//            connectionManagers.add(connectionManager);","[{'comment': 'remove unuse comment', 'commenter': 'xiantang'}]"
4636,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvoker.java,"@@ -91,6 +91,11 @@ public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, L
                             + "" using the dubbo version "" + Version.getVersion() + "". Last error is: ""
                             + le.getMessage(), le);
                 }
+
+                if(result != null && result.getException() != null && result.getException() instanceof RpcException){","[{'comment': 'Can be judged directly by result. hasException().\r\n', 'commenter': 'CrazyHZM'}, {'comment': 'yet ,i will use result.hasException，but here result may be null，so result also judged null', 'commenter': 'codeimport'}]"
4636,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvoker.java,"@@ -91,6 +91,11 @@ public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, L
                             + "" using the dubbo version "" + Version.getVersion() + "". Last error is: ""
                             + le.getMessage(), le);
                 }
+
+                if(result != null && result.getException() != null && result.getException() instanceof RpcException){
+                    throw result.getException();","[{'comment': '1.throw biz exception.\r\n2.Record the last exception', 'commenter': 'CrazyHZM'}, {'comment': 'i think that here only can throw RpcException ，can not throw biz exception，or consumer will not invoke mock', 'commenter': 'codeimport'}, {'comment': 'do you mean RpcException is explicitly thrown from business code on the provider side?', 'commenter': 'beiwei30'}, {'comment': 'the RpcException throw by Dubbo self filter not business code，eg：\r\nwhen the connection over executes on provider side , the RpcException will throw in ExecuteLimitFilter', 'commenter': 'codeimport'}]"
4636,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailoverRpcExceptionTest.java,"@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.support;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.*;
+import org.apache.dubbo.rpc.cluster.Directory;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+
+/**
+ * @description:
+ * @author: chengang6","[{'comment': 'Remove author information.', 'commenter': 'CrazyHZM'}, {'comment': 'yet ,i will remove author', 'commenter': 'codeimport'}]"
4636,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailoverRpcExceptionTest.java,"@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.support;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.*;","[{'comment': 'pls do not use comma import', 'commenter': 'AlbumenJ'}]"
4645,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/codec/ExchangeCodec.java,"@@ -152,7 +152,8 @@ protected Object decodeBody(Channel channel, InputStream is, byte[] header) thro
                 if (status == Response.OK) {
                     Object data;
                     if (res.isHeartbeat()) {
-                        data = decodeHeartbeatData(channel, in);
+                        // data = decodeHeartbeatData(channel, in);","[{'comment': 'would it be better to implement it like this?\r\n\r\n```java\r\n    @Deprecated\r\n    protected Object decodeHeartbeatData(Channel channel, ObjectInput in) throws IOException {\r\n        return Response.HEARTBEAT_EVENT;\r\n    }\r\n```', 'commenter': 'beiwei30'}, {'comment': ""Yes, it's better to implement."", 'commenter': 'chenyu2016'}]"
4645,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/codec/ExchangeCodec.java,"@@ -378,7 +379,11 @@ protected void encodeData(ObjectOutput out, Object data) throws IOException {
     }
 
     private void encodeEventData(ObjectOutput out, Object data) throws IOException {
-        out.writeObject(data);
+        if(data != null) {
+            out.writeObject(data);","[{'comment': 'would it be better to implement it like this?\r\n\r\n```java\r\n    @Deprecated\r\n    protected Object decodeHeartbeatData(Channel channel, ObjectInput in) throws IOException {\r\n        return Response.HEARTBEAT_EVENT;\r\n    }\r\n```', 'commenter': 'beiwei30'}, {'comment': 'encode I suggest or judge. To prevent accidents\r\n2.7.3 vesion I see ProtostuffObjectOutput.writeObject ，\r\nIn the method, I see “obj == null”', 'commenter': 'chenyu2016'}]"
4659,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/ProtocolFilterWrapper.java,"@@ -169,8 +169,6 @@ public Result invoke(Invocation invocation) throws RpcException {
                                 listener.onError(t, filterInvoker, invocation);
                             }
                         }
-                    } else {","[{'comment': 'would you mind to explain why it is unnecessary?', 'commenter': 'beiwei30'}, {'comment': 'We cannot remove this method, otherwise, legacy filters will not get invoked.', 'commenter': 'chickenlj'}]"
4660,dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java,"@@ -87,6 +88,9 @@ public static MetadataReportService instance(Supplier<URL> metadataReportUrl) {
     }
 
     public void publishProvider(URL providerUrl) throws RpcException {
+        if (!needStore(providerUrl)) {
+            return;
+        }","[{'comment': ""If return directly, the detailed URL will also not present in metadata, that's not what we expect."", 'commenter': 'chickenlj'}]"
4677,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/AnnotationUtils.java,"@@ -93,6 +92,14 @@ public static String resolveInterfaceName(Service service, Class<?> defaultInter
      * @throws IllegalStateException if interface name was not found
      */
     public static String resolveInterfaceName(AnnotationAttributes attributes, Class<?> defaultInterfaceClass) {
+        Boolean generic = getAttribute(attributes, ""generic"");","[{'comment': 'looks like this is unnecessary, since it works only for `@Service`', 'commenter': 'beiwei30'}, {'comment': ""No, it also use for `@Reference`. I think the method's comments is wrong."", 'commenter': 'CodingSinger'}, {'comment': 'nope, my mistake.', 'commenter': 'beiwei30'}]"
4735,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"@@ -122,8 +122,8 @@
 
     private final static Logger logger = LoggerFactory.getLogger(RegistryProtocol.class);
     private static RegistryProtocol INSTANCE;
-    private final Map<URL, NotifyListener> overrideListeners = new ConcurrentHashMap<>();
-    private final Map<String, ServiceConfigurationListener> serviceConfigurationListeners = new ConcurrentHashMap<>();
+    private final Map<URL, List<NotifyListener>> overrideListeners = new ConcurrentHashMap<>();","[{'comment': 'I am not convinced that we need a list of overrideListeners and ServiceConfigurationListener here. I will leave this to @chickenlj to judge.', 'commenter': 'beiwei30'}, {'comment': ""what's the difference between `serviceKey` classified listeners and `URL` classified listeners?\r\n Map<String, ServiceConfigurationListener> serviceConfigurationListeners \r\nMap<URL, List<NotifyListener>> overrideListeners\r\n"", 'commenter': 'chickenlj'}]"
4761,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperTransporter.java,"@@ -137,8 +138,8 @@ void writeToClientMap(List<String> addressList, ZookeeperClient zookeeperClient)
     URL toClientURL(URL url) {
         Map<String, String> parameterMap = new HashMap<>();
         // for CuratorZookeeperClient
-        if (url.getParameter(TIMEOUT_KEY) != null) {
-            parameterMap.put(TIMEOUT_KEY, url.getParameter(TIMEOUT_KEY));
+        if (url.getParameter(Constants.CONFIG_TIMEOUT_KEY) != null) {
+            parameterMap.put(Constants.CONFIG_TIMEOUT_KEY, url.getParameter(Constants.CONFIG_TIMEOUT_KEY));","[{'comment': 'This is not right, because the zookeeper transporter is not only used by config-center. It will not use ""config.timeout"" as timeout key when it is used by Zookeeper Registry.\r\nAnd it seems your pr is not clean, you should rebase your repository from official upstream master branch.\r\nI have send a pr #4763 to solve the problem. (I am really sorry that I didn\'t see your pr when I sent my pr. Would you please close the pr ? Welcome to send more prs!)', 'commenter': 'tswstarplanet'}]"
4767,dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java,"@@ -94,7 +94,7 @@ public void publishProvider(URL providerUrl) throws RpcException {
         try {
             String interfaceName = providerUrl.getParameter(INTERFACE_KEY);
             if (StringUtils.isNotEmpty(interfaceName)) {
-                Class interfaceClass = Class.forName(interfaceName);
+                Class interfaceClass =Thread.currentThread().getContextClassLoader().loadClass(interfaceName);","[{'comment': 'I think this change is not appropriate, the Thread.currentThread().getContextClassLoader().loadClass may cause NullPointerException if calling Thread.currentThread().setContextClassLoader(null) first.\r\n', 'commenter': 'kexianjun'}, {'comment': 'Ok, I have modified it, refer to jdbc', 'commenter': 'kaori-seasons'}, {'comment': 'I think it should be like the following\r\n```java\r\nClassLoader classLoader = null == Thread.currentThread().getContextClassLoader() ? this.getClass().getClassLoader() : Thread.currentThread().getContextClassLoader();\r\n Class interfaceClass = Class.forName(interfaceName, false, classLoader);\r\n```', 'commenter': 'kexianjun'}, {'comment': '@kexianjun \r\nI think it should be like this:\r\nOnly when the Class in the same class loader is compared using ==, this is the time when the user registers the interfaceName.\xa0, the class loader to which the interfaceName belongs is the same as when it was called.\r\n```\r\nprivate static boolean isInterfaceAllowed(Class<?> tClass, ClassLoader classLoader) {\r\n        boolean result = false;\r\n        Class<?> aClass = null;\r\n        try {\r\n            // The incoming classLoader is the current class loader that calls interfaceName, looking for the class object of interfaceName\r\n            aClass =  Class.forName(tClass.getName(), true, classLoader);\r\n        } catch (Exception ex) {\r\n            result = false;\r\n        }\r\n        //Only when the Class in the same class loader is compared using ==, this is the time when the user registers the interfaceName.\r\n        //,the class loader to which the interfaceName belongs is the same as when it was called.\r\n        result = ( aClass == tClass ) ? true : false;\r\n\r\n\r\n         return result;\r\n    }\r\n```\r\n', 'commenter': 'kaori-seasons'}]"
4767,dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java,"@@ -94,12 +112,15 @@ public void publishProvider(URL providerUrl) throws RpcException {
         try {
             String interfaceName = providerUrl.getParameter(INTERFACE_KEY);
             if (StringUtils.isNotEmpty(interfaceName)) {
-                Class interfaceClass = Class.forName(interfaceName);
-                FullServiceDefinition fullServiceDefinition = ServiceDefinitionBuilder.buildFullDefinition(interfaceClass, providerUrl.getParameters());
-                metadataReport.storeProviderMetadata(new MetadataIdentifier(providerUrl.getServiceInterface(),
-                        providerUrl.getParameter(VERSION_KEY), providerUrl.getParameter(GROUP_KEY),
-                        PROVIDER_SIDE, providerUrl.getParameter(APPLICATION_KEY)), fullServiceDefinition);
-                return;
+                ClassLoader classLoader = null == Thread.currentThread().getContextClassLoader() ? this.getClass().getClassLoader() : Thread.currentThread().getContextClassLoader();
+                Class interfaceClass = Class.forName(interfaceName, true, classLoader);
+                if(isInterfaceAllowed(interfaceClass,classLoader)) {
+                    FullServiceDefinition fullServiceDefinition = ServiceDefinitionBuilder.buildFullDefinition(interfaceClass, providerUrl.getParameters());","[{'comment': 'It seems that the invoke of isInterfaceAllowed is not needed.', 'commenter': 'tswstarplanet'}, {'comment': 'Ok, I have modified it', 'commenter': 'kaori-seasons'}]"
4767,dubbo-metadata-report/dubbo-metadata-report-api/src/main/java/org/apache/dubbo/metadata/integration/MetadataReportService.java,"@@ -86,6 +86,24 @@ public static MetadataReportService instance(Supplier<URL> metadataReportUrl) {
         return metadataReportService;
     }
 
+    private static boolean isInterfaceAllowed(Class<?> tClass, ClassLoader classLoader) {","[{'comment': 'please remove this method since you do not call it anywhere', 'commenter': 'kexianjun'}, {'comment': '\r\nI have removed', 'commenter': 'kaori-seasons'}]"
4802,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -369,15 +370,26 @@ private void filterServiceNames(Set<String> serviceNames, URL url) {
         return serviceNames;
     }
 
-    private List<URL> buildURLs(URL consumerURL, Collection<Instance> instances) {
-        if (instances.isEmpty()) {
-            return Collections.emptyList();
+    private List<URL> toUrlWithEmpty(URL consumerURL, Collection<Instance> instances) {
+        List<URL> urls = buildURLs(consumerURL, instances);
+        if (urls.size() == 0) {
+            URL empty = URLBuilder.from(consumerURL)
+                    .setProtocol(EMPTY_PROTOCOL)
+                    .addParameter(CATEGORY_KEY, DEFAULT_CATEGORY)
+                    .build();
+            urls.add(empty);
         }
+        return urls;
+    }
+
+    private List<URL> buildURLs(URL consumerURL, Collection<Instance> instances) {
         List<URL> urls = new LinkedList<>();
-        for (Instance instance : instances) {
-            URL url = buildURL(instance);
-            if (UrlUtils.isMatch(consumerURL, url)) {
-                urls.add(url);
+        if (instances != null && !instances.isEmpty()) {","[{'comment': ""Maybe we don't  need to check whether `instances` is empty"", 'commenter': 'Moriadry-zz'}, {'comment': 'For String or Collection, I think not only null, but also size check are needed because the for each will create useless iterator object.', 'commenter': 'tswstarplanet'}]"
4802,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -406,9 +418,11 @@ private void subscribeEventListener(String serviceName, final URL url, final Not
      */
     private void notifySubscriber(URL url, NotifyListener listener, Collection<Instance> instances) {
         List<Instance> healthyInstances = new LinkedList<>(instances);
-        // Healthy Instances
-        filterHealthyInstances(healthyInstances);
-        List<URL> urls = buildURLs(url, healthyInstances);
+        if (healthyInstances.size() > 0) {","[{'comment': 'If healthyInstances is empty, this still works? Not sure, could u pls check it.\r\nI believe we should make our code as clean as possible :)', 'commenter': 'Moriadry-zz'}, {'comment': ""Same as above. I think it's a fail-fast term."", 'commenter': 'tswstarplanet'}]"
4802,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -369,15 +370,26 @@ private void filterServiceNames(Set<String> serviceNames, URL url) {
         return serviceNames;
     }
 
-    private List<URL> buildURLs(URL consumerURL, Collection<Instance> instances) {
-        if (instances.isEmpty()) {
-            return Collections.emptyList();
+    private List<URL> toUrlWithEmpty(URL consumerURL, Collection<Instance> instances) {","[{'comment': 'Last nitpick, what about changing  `toUrlWithEmpty` to  `toUrlsWhenEmpty`? (just \r\n one suggestion, there should be another better method name to make it clear)\r\n\r\nI know we use `toUrlWithEmpty` in zookeeperRegistry.class, but I found the name may bring us a little confusion :)', 'commenter': 'Moriadry-zz'}, {'comment': 'The name tells that the protocol will be set ""empty""', 'commenter': 'tswstarplanet'}]"
4819,dubbo-serialization/dubbo-serialization-fastjson/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.common.serialize.Serialization,"@@ -1 +1 @@
-fastjson=org.apache.dubbo.common.serialize.fastjson.FastJsonSerialization
\ No newline at end of file
+fastjson=fastjson=com.alibaba.dubbo.common.serialize.support.json.GenericFastJsonSerialization","[{'comment': 'This is not right', 'commenter': 'tswstarplanet'}]"
4820,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ReferenceBean.java,"@@ -181,19 +181,19 @@ public void afterPropertiesSet() throws Exception {
 
         if (getMetadataReportConfig() == null) {
             Map<String, MetadataReportConfig> metadataReportConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MetadataReportConfig.class, false, false);
-            if (metadataReportConfigMap != null && metadataReportConfigMap.size() == 1) {
+            if (CollectionUtils.mapSizeEq(metadataReportConfigMap, 1)) {
                 // first elements
                 super.setMetadataReportConfig(metadataReportConfigMap.values().iterator().next());
-            } else if (metadataReportConfigMap != null && metadataReportConfigMap.size() > 1) {
+            } else if (CollectionUtils.mapSizeGt(metadataReportConfigMap, 1)) {","[{'comment': ""I do not see the benefits of this change, actually it increase the difficulty to understand. I'd rather keep the original logic."", 'commenter': 'ralf0131'}]"
4820,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/eager/EagerThreadPool.java,"@@ -51,7 +51,7 @@ public Executor getExecutor(URL url) {
         int alive = url.getParameter(ALIVE_KEY, DEFAULT_ALIVE);
 
         // init queue and executor
-        TaskQueue<Runnable> taskQueue = new TaskQueue<Runnable>(queues <= 0 ? 1 : queues);
+        TaskQueue<Runnable> taskQueue = new TaskQueue<Runnable>(Math.max(1, queues));","[{'comment': ""Both of two lines got the same meaning, I believe it's unnecessary to change this."", 'commenter': 'Moriadry-zz'}]"
4832,dubbo-demo/dubbo-demo-api/dubbo-demo-api-consumer/pom.xml,"@@ -40,7 +40,11 @@
         </dependency>
         <dependency>
             <groupId>org.apache.dubbo</groupId>
-            <artifactId>dubbo-registry-multicast</artifactId>","[{'comment': 'Please do not remove the the multicast dependency.  We need to keep the convenience for People to switch between multicast and zookeeper.', 'commenter': 'ralf0131'}]"
4865,dubbo-common/src/main/java/org/apache/dubbo/common/beanutil/JavaBeanDescriptor.java,"@@ -195,15 +186,15 @@ private boolean isValidType(int type) {
         return TYPE_MIN <= type && type <= TYPE_MAX;
     }
 
-    private void notNull(Object obj, String message) {
+    private void notNull(Object obj) {","[{'comment': 'why would u change this method,  It seems original method definition is cleaner.', 'commenter': 'Moriadry-zz'}, {'comment': 'consider there is not other case used a different message, so extract to a common method. but maybe u are right.', 'commenter': 'leechor'}]"
4865,dubbo-common/src/test/java/org/apache/dubbo/common/beanutil/JavaBeanSerializeUtilTest.java,"@@ -89,55 +90,81 @@ public void testDeserialize_Null() {
     @Test
     public void testDeserialize_containsProperty() {
         Assertions.assertThrows(IllegalArgumentException.class, () -> {
-            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(), JavaBeanDescriptor.TYPE_PRIMITIVE);
+            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(),
+                    JavaBeanDescriptor.TYPE_PRIMITIVE);
             descriptor.containsProperty(null);
         });
     }
 
     @Test
     public void testSetEnumNameProperty() {
         Assertions.assertThrows(IllegalStateException.class, () -> {
-            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(), JavaBeanDescriptor.TYPE_PRIMITIVE);
+            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(),
+                    JavaBeanDescriptor.TYPE_PRIMITIVE);
             descriptor.setEnumNameProperty(JavaBeanDescriptor.class.getName());
         });
+
+        JavaBeanDescriptor descriptor1 = new JavaBeanDescriptor(JavaBeanDescriptor.class.getName(),
+                JavaBeanDescriptor.TYPE_ENUM);
+
+        String oldValue1 = descriptor1.setEnumNameProperty(JavaBeanDescriptor.class.getName());","[{'comment': ""You'd better not use a variable named oldValue1."", 'commenter': 'Moriadry-zz'}]"
4865,dubbo-common/src/test/java/org/apache/dubbo/common/beanutil/JavaBeanSerializeUtilTest.java,"@@ -89,55 +90,81 @@ public void testDeserialize_Null() {
     @Test
     public void testDeserialize_containsProperty() {
         Assertions.assertThrows(IllegalArgumentException.class, () -> {
-            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(), JavaBeanDescriptor.TYPE_PRIMITIVE);
+            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(),
+                    JavaBeanDescriptor.TYPE_PRIMITIVE);
             descriptor.containsProperty(null);
         });
     }
 
     @Test
     public void testSetEnumNameProperty() {
         Assertions.assertThrows(IllegalStateException.class, () -> {
-            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(), JavaBeanDescriptor.TYPE_PRIMITIVE);
+            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(),
+                    JavaBeanDescriptor.TYPE_PRIMITIVE);
             descriptor.setEnumNameProperty(JavaBeanDescriptor.class.getName());
         });
+
+        JavaBeanDescriptor descriptor1 = new JavaBeanDescriptor(JavaBeanDescriptor.class.getName(),
+                JavaBeanDescriptor.TYPE_ENUM);
+
+        String oldValue1 = descriptor1.setEnumNameProperty(JavaBeanDescriptor.class.getName());
+        Assertions.assertNull(oldValue1);
+
+        String oldValue2 = descriptor1.setEnumNameProperty(JavaBeanDescriptor.class.getName());","[{'comment': 'Same here.', 'commenter': 'Moriadry-zz'}]"
4865,dubbo-common/src/test/java/org/apache/dubbo/common/beanutil/JavaBeanSerializeUtilTest.java,"@@ -89,55 +90,81 @@ public void testDeserialize_Null() {
     @Test
     public void testDeserialize_containsProperty() {
         Assertions.assertThrows(IllegalArgumentException.class, () -> {
-            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(), JavaBeanDescriptor.TYPE_PRIMITIVE);
+            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(),
+                    JavaBeanDescriptor.TYPE_PRIMITIVE);
             descriptor.containsProperty(null);
         });
     }
 
     @Test
     public void testSetEnumNameProperty() {
         Assertions.assertThrows(IllegalStateException.class, () -> {
-            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(), JavaBeanDescriptor.TYPE_PRIMITIVE);
+            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(),
+                    JavaBeanDescriptor.TYPE_PRIMITIVE);
             descriptor.setEnumNameProperty(JavaBeanDescriptor.class.getName());
         });
+
+        JavaBeanDescriptor descriptor1 = new JavaBeanDescriptor(JavaBeanDescriptor.class.getName(),
+                JavaBeanDescriptor.TYPE_ENUM);
+
+        String oldValue1 = descriptor1.setEnumNameProperty(JavaBeanDescriptor.class.getName());
+        Assertions.assertNull(oldValue1);
+
+        String oldValue2 = descriptor1.setEnumNameProperty(JavaBeanDescriptor.class.getName());
+        Assertions.assertEquals(oldValue2, descriptor1.getEnumPropertyName());
     }
 
     @Test
     public void testGetEnumNameProperty() {
         Assertions.assertThrows(IllegalStateException.class, () -> {
-            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(), JavaBeanDescriptor.TYPE_PRIMITIVE);
+            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(),
+                    JavaBeanDescriptor.TYPE_PRIMITIVE);
             descriptor.getEnumPropertyName();
         });
     }
 
     @Test
     public void testSetClassNameProperty() {
+
         Assertions.assertThrows(IllegalStateException.class, () -> {
-            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(), JavaBeanDescriptor.TYPE_PRIMITIVE);
+            JavaBeanDescriptor descriptor = new JavaBeanDescriptor(long.class.getName(),
+                    JavaBeanDescriptor.TYPE_PRIMITIVE);
             descriptor.setClassNameProperty(JavaBeanDescriptor.class.getName());
         });
+
+        JavaBeanDescriptor descriptor1 = new JavaBeanDescriptor(JavaBeanDescriptor.class.getName(),","[{'comment': 'And this line.', 'commenter': 'Moriadry-zz'}]"
4865,dubbo-common/src/main/java/org/apache/dubbo/common/beanutil/JavaBeanDescriptor.java,"@@ -24,21 +24,18 @@
 
 public final class JavaBeanDescriptor implements Serializable, Iterable<Map.Entry<Object, Object>> {
 
+    private static final long serialVersionUID = -8505586483570518029L;
+
     public static final int TYPE_CLASS = 1;
     public static final int TYPE_ENUM = 2;
     public static final int TYPE_COLLECTION = 3;
     public static final int TYPE_MAP = 4;
     public static final int TYPE_ARRAY = 5;
-    /**
-     * @see org.apache.dubbo.common.utils.ReflectUtils#isPrimitive(Class)
-     */","[{'comment': 'Keep this comment as it be.', 'commenter': 'Moriadry-zz'}, {'comment': 'according to ur advise, i have changed the pr.', 'commenter': 'leechor'}]"
4866,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java,"@@ -150,6 +163,17 @@ public String telnet(Channel channel, String message) {
         return buf.toString();
     }
 
+    private Invoker<?> findInvoker(ProviderModel provider) {
+        for (Exporter<?> exporter : DubboProtocol.getDubboProtocol().getExporters()) {
+            Invoker<?> invoker = exporter.getInvoker();","[{'comment': 'I think the getExporters() method should move to the AbstractProtocol.java. So we can process non-dubbo protocol invokers. Or this may cause null pointer exception if there is no DubboProtocol instance', 'commenter': 'tswstarplanet'}, {'comment': ""@tswstarplanet \r\n`InvokeTelnetHandler` is actually defined in module `dubbo-rpc-dubbo`, so it's always used for dubbo protocol invokers, it's not implemented in other protocols.\r\nBut it's a good point, maybe we shouldn't just use `ApplicationModel#allProviderModels` to list services, we also need to filter out non-dubbo protocol invokers."", 'commenter': 'mzorro'}, {'comment': ""@tswstarplanet I added hint when no dubbo protocol invoker found, I thinks it's enough. After all it's mainly for debugging purposes."", 'commenter': 'mzorro'}]"
4866,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/telnet/InvokeTelnetHandler.java,"@@ -150,6 +163,17 @@ public String telnet(Channel channel, String message) {
         return buf.toString();
     }
 
+    private Invoker<?> findInvoker(ProviderModel provider) {
+        for (Exporter<?> exporter : DubboProtocol.getDubboProtocol().getExporters()) {","[{'comment': 'this change makes an assumption: all services will be exported with dubbo protocol. \r\n\r\nI am wondering if we should introduce this limitation, in order to make the filter work.', 'commenter': 'beiwei30'}, {'comment': ""should we try to find invoker from dubbo protocol first, and if there's no invoke found, then fallback to call the found method instead?"", 'commenter': 'beiwei30'}]"
4866,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -451,14 +451,15 @@ public synchronized void unexport() {
     private void doExportUrls() {
         List<URL> registryURLs = loadRegistries(true);
         for (ProtocolConfig protocolConfig : protocols) {
-            String pathKey = URL.buildKey(getContextPath(protocolConfig).map(p -> p + ""/"" + path).orElse(path), group, version);
+            URL url = buildExportUrlsFor1Protocol(protocolConfig, registryURLs);","[{'comment': 'is the change made here for the problem you mentioned:\r\n\r\n> Also found and fixed a bug: when contextpath is set and starts with /，providerModel.getServiceName() does not match with invoker.getUrl().getPathKey()', 'commenter': 'beiwei30'}, {'comment': 'yes, this is because this code:\r\nhttps://github.com/apache/dubbo/blob/21397b30599ce765d3db938ca53ba26c108ab363/dubbo-common/src/main/java/org/apache/dubbo/common/URL.java#L180-L182\r\n\r\nthus `URL.buildKey(getContextPath(protocolConfig).map(p -> p + ""/"" + path).orElse(path), group, version)` wouldn\'t match with `url.getPathKey()`', 'commenter': 'mzorro'}]"
4866,dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java,"@@ -1,65 +1,65 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.rpc.protocol.injvm;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.RpcContext;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.protocol.AbstractInvoker;
-
-import java.util.Map;
-
-import static org.apache.dubbo.common.constants.CommonConstants.LOCALHOST_VALUE;
-
-/**
- * InjvmInvoker
- */
-class InjvmInvoker<T> extends AbstractInvoker<T> {
-
-    private final String key;
-
-    private final Map<String, Exporter<?>> exporterMap;
-
-    InjvmInvoker(Class<T> type, URL url, String key, Map<String, Exporter<?>> exporterMap) {
-        super(type, url);
-        this.key = key;
-        this.exporterMap = exporterMap;
-    }
-
-    @Override
-    public boolean isAvailable() {
-        InjvmExporter<?> exporter = (InjvmExporter<?>) exporterMap.get(key);
-        if (exporter == null) {
-            return false;
-        } else {
-            return super.isAvailable();
-        }
-    }
-
-    @Override
-    public Result doInvoke(Invocation invocation) throws Throwable {
-        Exporter<?> exporter = InjvmProtocol.getExporter(exporterMap, getUrl());
-        if (exporter == null) {
-            throw new RpcException(""Service ["" + key + ""] not found."");
-        }
-        RpcContext.getContext().setRemoteAddress(LOCALHOST_VALUE, 0);
-        return exporter.getInvoker().invoke(invocation);
-    }
-}
+/*","[{'comment': 'Please recover file endline format of this file.', 'commenter': 'AlbumenJ'}]"
4866,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProxyProtocol.java,"@@ -1,152 +1,136 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.rpc.protocol;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.utils.NetUtils;
-import org.apache.dubbo.remoting.Constants;
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.ProxyFactory;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.RpcException;
-
-import java.util.List;
-import java.util.Objects;
-import java.util.concurrent.CopyOnWriteArrayList;
-
-import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;
-
-/**
- * AbstractProxyProtocol
- */
-public abstract class AbstractProxyProtocol extends AbstractProtocol {
-
-    private final List<Class<?>> rpcExceptions = new CopyOnWriteArrayList<Class<?>>();
-
-    private ProxyFactory proxyFactory;
-
-    public AbstractProxyProtocol() {
-    }
-
-    public AbstractProxyProtocol(Class<?>... exceptions) {
-        for (Class<?> exception : exceptions) {
-            addRpcException(exception);
-        }
-    }
-
-    public void addRpcException(Class<?> exception) {
-        this.rpcExceptions.add(exception);
-    }
-
-    public ProxyFactory getProxyFactory() {
-        return proxyFactory;
-    }
-
-    public void setProxyFactory(ProxyFactory proxyFactory) {
-        this.proxyFactory = proxyFactory;
-    }
-
-    @Override
-    @SuppressWarnings(""unchecked"")
-    public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {
-        final String uri = serviceKey(invoker.getUrl());
-        Exporter<T> exporter = (Exporter<T>) exporterMap.get(uri);
-        if (exporter != null) {
-            // When modifying the configuration through override, you need to re-expose the newly modified service.
-            if (Objects.equals(exporter.getInvoker().getUrl(), invoker.getUrl())) {
-                return exporter;
-            }
-        }
-        final Runnable runnable = doExport(proxyFactory.getProxy(invoker, true), invoker.getInterface(), invoker.getUrl());
-        exporter = new AbstractExporter<T>(invoker) {
-            @Override
-            public void unexport() {
-                super.unexport();
-                exporterMap.remove(uri);
-                if (runnable != null) {
-                    try {
-                        runnable.run();
-                    } catch (Throwable t) {
-                        logger.warn(t.getMessage(), t);
-                    }
-                }
-            }
-        };
-        exporterMap.put(uri, exporter);
-        return exporter;
-    }
-
-    @Override
-    protected <T> Invoker<T> protocolBindingRefer(final Class<T> type, final URL url) throws RpcException {
-        final Invoker<T> target = proxyFactory.getInvoker(doRefer(type, url), type, url);
-        Invoker<T> invoker = new AbstractInvoker<T>(type, url) {
-            @Override
-            protected Result doInvoke(Invocation invocation) throws Throwable {
-                try {
-                    Result result = target.invoke(invocation);
-                    // FIXME result is an AsyncRpcResult instance.
-                    Throwable e = result.getException();
-                    if (e != null) {
-                        for (Class<?> rpcException : rpcExceptions) {
-                            if (rpcException.isAssignableFrom(e.getClass())) {
-                                throw getRpcException(type, url, invocation, e);
-                            }
-                        }
-                    }
-                    return result;
-                } catch (RpcException e) {
-                    if (e.getCode() == RpcException.UNKNOWN_EXCEPTION) {
-                        e.setCode(getErrorCode(e.getCause()));
-                    }
-                    throw e;
-                } catch (Throwable e) {
-                    throw getRpcException(type, url, invocation, e);
-                }
-            }
-        };
-        invokers.add(invoker);
-        return invoker;
-    }
-
-    protected RpcException getRpcException(Class<?> type, URL url, Invocation invocation, Throwable e) {
-        RpcException re = new RpcException(""Failed to invoke remote service: "" + type + "", method: ""
-                + invocation.getMethodName() + "", cause: "" + e.getMessage(), e);
-        re.setCode(getErrorCode(e));
-        return re;
-    }
-
-    protected String getAddr(URL url) {
-        String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());
-        if (url.getParameter(ANYHOST_KEY, false)) {
-            bindIp = ANYHOST_VALUE;
-        }
-        return NetUtils.getIpByHost(bindIp) + "":"" + url.getParameter(Constants.BIND_PORT_KEY, url.getPort());
-    }
-
-    protected int getErrorCode(Throwable e) {
-        return RpcException.UNKNOWN_EXCEPTION;
-    }
-
-    protected abstract <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException;
-
-    protected abstract <T> T doRefer(Class<T> type, URL url) throws RpcException;
-
-}
+/*","[{'comment': 'Also for this', 'commenter': 'AlbumenJ'}]"
4870,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java,"@@ -75,10 +75,16 @@ protected int getWeight(Invoker<?> invoker, Invocation invocation) {
         if (weight > 0) {
             long timestamp = invoker.getUrl().getParameter(REMOTE_TIMESTAMP_KEY, 0L);","[{'comment': ""pls. change `REMOTE_TIMESTAMP_KEY` to `TIMESTAMP_KEY`. Pls. also remove org.apache.dubbo.rpc.cluster.Constants#REMOTE_TIMESTAMP_KEY since it's now useless."", 'commenter': 'beiwei30'}]"
4870,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java,"@@ -75,10 +75,16 @@ protected int getWeight(Invoker<?> invoker, Invocation invocation) {
         if (weight > 0) {
             long timestamp = invoker.getUrl().getParameter(REMOTE_TIMESTAMP_KEY, 0L);
             if (timestamp > 0L) {
-                int uptime = (int) (System.currentTimeMillis() - timestamp);
+                long uptime = System.currentTimeMillis() - timestamp;","[{'comment': 'should we change this method to\r\n\r\n```java\r\n    protected int getWeight(Invoker<?> invoker, Invocation invocation) {\r\n        int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);\r\n        if (weight > 0) {\r\n            long timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, 0L);\r\n            if (timestamp > 0L) {\r\n                int uptime = (int) Math.max(System.currentTimeMillis() - timestamp, 0);\r\n                int warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);\r\n                if (uptime >= 0 && uptime < warmup) {\r\n                    weight = calculateWarmupWeight(uptime, warmup, weight);\r\n                }\r\n            }\r\n        }\r\n        return weight >= 0 ? weight : 0;\r\n    }\r\n```', 'commenter': 'beiwei30'}, {'comment': 'the diff is\r\n\r\n```diff\r\nindex ed6f3c4e9..14640d4fb 100644\r\n--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\r\n+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java\r\n@@ -24,6 +24,7 @@ import org.apache.dubbo.rpc.cluster.LoadBalance;\r\n \r\n import java.util.List;\r\n \r\n+import static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;^M\r\n import static org.apache.dubbo.rpc.cluster.Constants.DEFAULT_WARMUP;\r\n import static org.apache.dubbo.rpc.cluster.Constants.DEFAULT_WEIGHT;\r\n import static org.apache.dubbo.rpc.cluster.Constants.REMOTE_TIMESTAMP_KEY;\r\n@@ -73,11 +74,11 @@ public abstract class AbstractLoadBalance implements LoadBalance {\r\n     protected int getWeight(Invoker<?> invoker, Invocation invocation) {\r\n         int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);\r\n         if (weight > 0) {\r\n-            long timestamp = invoker.getUrl().getParameter(REMOTE_TIMESTAMP_KEY, 0L);\r\n+            long timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, 0L);^M\r\n             if (timestamp > 0L) {\r\n-                int uptime = (int) (System.currentTimeMillis() - timestamp);\r\n+                int uptime = (int) Math.max(System.currentTimeMillis() - timestamp, 0);^M\r\n                 int warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);\r\n-                if (uptime > 0 && uptime < warmup) {\r\n+                if (uptime >= 0 && uptime < warmup) {^M\r\n                     weight = calculateWarmupWeight(uptime, warmup, weight);\r\n                 }\r\n             }\r\n```', 'commenter': 'beiwei30'}, {'comment': ""I don't think so,  if the provider is started 24 days ago, then `System.currentTimeMillis() - timestamp` will be bigger than `Integer.MAX_VALUE`.\r\n\r\nConsider that `System.currentTimeMillis() = 1566209746000`(2019-08-19 18:15:46), and `timestamp = 1561914711000`(2019-07-01 01:11:51),  then `int uptime = (int) Math.max(System.currentTimeMillis() - timestamp, 0)` is `67704`, this will result in a smaller weight."", 'commenter': 'aftersss'}]"
4870,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java,"@@ -73,12 +73,18 @@ static int calculateWarmupWeight(int uptime, int warmup, int weight) {
     protected int getWeight(Invoker<?> invoker, Invocation invocation) {
         int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);
         if (weight > 0) {
-            long timestamp = invoker.getUrl().getParameter(REMOTE_TIMESTAMP_KEY, 0L);
+            long timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, 0L);
             if (timestamp > 0L) {
-                int uptime = (int) (System.currentTimeMillis() - timestamp);
+                long uptime = System.currentTimeMillis() - timestamp;
+                if (uptime >= Integer.MAX_VALUE) {
+                    return weight;
+                }
+                else if (uptime < 0) {","[{'comment': 'uptime == 0 case is not correctly handled', 'commenter': 'FinalVersion'}]"
4880,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperClient.java,"@@ -45,6 +46,8 @@
 
     private volatile boolean closed = false;
 
+    private final Set<String>  persistentExistNodePath = Sets.newConcurrentHashSet();
+","[{'comment': 'If a path is deleted, the path should be removed from the set.', 'commenter': 'tswstarplanet'}, {'comment': '> If a path is deleted, the path should be removed from the set.\r\nFrom me , I think we delete only the non persistent node. I will have a look with the code\r\n', 'commenter': 'qixiaobo'}, {'comment': ""pls. avoid of using guava. It's introduced from "", 'commenter': 'beiwei30'}]"
4880,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/support/AbstractZookeeperClient.java,"@@ -16,6 +16,7 @@
  */
 package org.apache.dubbo.remoting.zookeeper.support;
 
+import com.google.common.collect.Sets;","[{'comment': 'pls. avoid of using guava directly.', 'commenter': 'beiwei30'}, {'comment': 'OK, I will modify the code', 'commenter': 'qixiaobo'}]"
4935,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcStatus.java,"@@ -112,6 +112,9 @@ public static boolean beginCount(URL url, String methodName, int max) {
         max = (max <= 0) ? Integer.MAX_VALUE : max;
         RpcStatus appStatus = getStatus(url);
         RpcStatus methodStatus = getStatus(url, methodName);
+        if (methodStatus.active.get() >= max) {","[{'comment': 'should we change this to a particluar check, otherwise it would be confusing:\r\n\r\n```java\r\nif (methodStatus.active.get() == Integer.MAX_VALUE) {\r\n```\r\n\r\nIt would be nice if you put one comment above to explain why we need this.', 'commenter': 'beiwei30'}, {'comment': 'you are right, I have changed, pls verify\r\n\r\n', 'commenter': 'sunchuanleihit'}]"
4948,dubbo-dependencies-bom/pom.xml,"@@ -609,6 +609,13 @@
                 <artifactId>nacos-client</artifactId>
                 <version>${nacos_version}</version>
             </dependency>
+            <!--for dubbo-configcenter-apollo-->
+            <dependency>
+                <groupId>com.ctrip.framework.apollo</groupId>
+                <artifactId>apollo-mockserver</artifactId>
+                <version>${apollo_client_version}</version>
+                <scope>test</scope>","[{'comment': 'pls. limit the test scope library to the apollo module, since this bom will be distributed to all dubbo users.', 'commenter': 'beiwei30'}]"
4957,dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ReplierDispatcherTest.java,"@@ -14,93 +14,116 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.dubbo.remoting;
+package org.apache.dubbo.remoting.transport.netty4;
 
 import org.apache.dubbo.common.URL;
+import org.apache.dubbo.remoting.RemotingException;
 import org.apache.dubbo.remoting.exchange.ExchangeChannel;
+import org.apache.dubbo.remoting.exchange.ExchangeServer;
 import org.apache.dubbo.remoting.exchange.Exchangers;
-import org.apache.dubbo.remoting.exchange.support.Replier;
 import org.apache.dubbo.remoting.exchange.support.ReplierDispatcher;
-
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 import java.io.Serializable;
 import java.util.Random;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
+import java.util.concurrent.*;
+
 
 /**
- * Main
+ * ReplierDispatcherTest
  */
 
-public class Main {
-    public static void main(String[] args) throws Exception {
-        startServer(9010);
-        mutliThreadTest(10, 9010);
-        dataPackageTest(9010);
-    }
+public class ReplierDispatcherTest {
+
+    private ExchangeServer exchangeServer;
+
+    private ConcurrentHashMap<String, ExchangeChannel> clients = new ConcurrentHashMap<>();
 
-    private static void startServer(int port) throws Exception {
+    private int port;
+
+    @BeforeEach
+    public void startServer() throws RemotingException {
+        port = (int) (1000 * Math.random() + 10000);","[{'comment': 'if you are looking for a random port (which is available), check `NetUtils.getAvailablePort()`', 'commenter': 'htynkn'}, {'comment': 'Thank you for your correction', 'commenter': 'xiaomoran'}]"
4957,dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ReplierDispatcherTest.java,"@@ -14,93 +14,116 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.dubbo.remoting;
+package org.apache.dubbo.remoting.transport.netty4;
 
 import org.apache.dubbo.common.URL;
+import org.apache.dubbo.remoting.RemotingException;
 import org.apache.dubbo.remoting.exchange.ExchangeChannel;
+import org.apache.dubbo.remoting.exchange.ExchangeServer;
 import org.apache.dubbo.remoting.exchange.Exchangers;
-import org.apache.dubbo.remoting.exchange.support.Replier;
 import org.apache.dubbo.remoting.exchange.support.ReplierDispatcher;
-
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 import java.io.Serializable;
 import java.util.Random;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
+import java.util.concurrent.*;
+
 
 /**
- * Main
+ * ReplierDispatcherTest
  */
 
-public class Main {
-    public static void main(String[] args) throws Exception {
-        startServer(9010);
-        mutliThreadTest(10, 9010);
-        dataPackageTest(9010);
-    }
+public class ReplierDispatcherTest {
+
+    private ExchangeServer exchangeServer;
+
+    private ConcurrentHashMap<String, ExchangeChannel> clients = new ConcurrentHashMap<>();
 
-    private static void startServer(int port) throws Exception {
+    private int port;
+
+    @BeforeEach
+    public void startServer() throws RemotingException {
+        port = (int) (1000 * Math.random() + 10000);
         ReplierDispatcher dispatcher = new ReplierDispatcher();
         dispatcher.addReplier(RpcMessage.class, new RpcMessageHandler());
-        dispatcher.addReplier(Object.class, new Replier<Object>() {
-            public Object reply(ExchangeChannel channel, Object msg) {
-                for (int i = 0; i < 10000; i++)
-                    System.currentTimeMillis();
-                System.out.println(""handle:"" + msg + "";thread:"" + Thread.currentThread().getName());
-                return new StringMessage(""hello world"");
+        dispatcher.addReplier(Object.class, (channel, msg) -> {
+            for (int i = 0; i < 10000; i++) {
+                System.currentTimeMillis();
             }
+            System.out.println(""handle:"" + msg + "";thread:"" + Thread.currentThread().getName());
+            return new StringMessage(""hello world"");
         });
-        Exchangers.bind(URL.valueOf(""dubbo://localhost:"" + port), dispatcher);
+        exchangeServer = Exchangers.bind(URL.valueOf(""dubbo://localhost:"" + port), dispatcher);
     }
 
-    static void dataPackageTest(int port) throws Exception {
+
+    @Test
+    public void testDataPackage() throws Exception {
         ExchangeChannel client = Exchangers.connect(URL.valueOf(""dubbo://localhost:"" + port));
         Random random = new Random();
         for (int i = 5; i < 100; i++) {
             StringBuilder sb = new StringBuilder();
             for (int j = 0; j < i * 100; j++)
-                sb.append(""("" + random.nextLong() + "")"");
-            Main.Data d = new Main.Data();
+                sb.append(""("").append(random.nextLong()).append("")"");
+            Data d = new Data();
             d.setData(sb.toString());
-            client.request(d).get();
+            Assertions.assertEquals(client.request(d).get().toString(), ""hello world"");
         }
-        System.out.println(""send finished."");
+        clients.put(Thread.currentThread().getName(), client);
     }
 
-    static void mutliThreadTest(int tc, final int port) throws Exception {
-        Executor exec = Executors.newFixedThreadPool(tc);
+
+    @Test
+    public void testMutliThread() throws Exception {
+        int tc = 10;
+        ExecutorService exec = Executors.newFixedThreadPool(tc);
         for (int i = 0; i < tc; i++)
-            exec.execute(new Runnable() {
-                public void run() {
-                    try {
-                        test(port);
-                    } catch (Exception e) {
-                        e.printStackTrace();
-                    }
+            exec.execute(() -> {
+                try {
+                    clientExchangeInfo(port);
+                } catch (Exception e) {
+                    e.printStackTrace();","[{'comment': 'for any exception, we should consider this unit test fail.\r\nYou can throw this exception or invoke `fail` method in junit library', 'commenter': 'htynkn'}]"
4957,dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ReplierDispatcherTest.java,"@@ -14,93 +14,116 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.dubbo.remoting;
+package org.apache.dubbo.remoting.transport.netty4;
 
 import org.apache.dubbo.common.URL;
+import org.apache.dubbo.remoting.RemotingException;
 import org.apache.dubbo.remoting.exchange.ExchangeChannel;
+import org.apache.dubbo.remoting.exchange.ExchangeServer;
 import org.apache.dubbo.remoting.exchange.Exchangers;
-import org.apache.dubbo.remoting.exchange.support.Replier;
 import org.apache.dubbo.remoting.exchange.support.ReplierDispatcher;
-
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 import java.io.Serializable;
 import java.util.Random;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
+import java.util.concurrent.*;
+
 
 /**
- * Main
+ * ReplierDispatcherTest
  */
 
-public class Main {
-    public static void main(String[] args) throws Exception {
-        startServer(9010);
-        mutliThreadTest(10, 9010);
-        dataPackageTest(9010);
-    }
+public class ReplierDispatcherTest {
+
+    private ExchangeServer exchangeServer;
+
+    private ConcurrentHashMap<String, ExchangeChannel> clients = new ConcurrentHashMap<>();
 
-    private static void startServer(int port) throws Exception {
+    private int port;
+
+    @BeforeEach
+    public void startServer() throws RemotingException {
+        port = (int) (1000 * Math.random() + 10000);
         ReplierDispatcher dispatcher = new ReplierDispatcher();
         dispatcher.addReplier(RpcMessage.class, new RpcMessageHandler());
-        dispatcher.addReplier(Object.class, new Replier<Object>() {
-            public Object reply(ExchangeChannel channel, Object msg) {
-                for (int i = 0; i < 10000; i++)
-                    System.currentTimeMillis();
-                System.out.println(""handle:"" + msg + "";thread:"" + Thread.currentThread().getName());
-                return new StringMessage(""hello world"");
+        dispatcher.addReplier(Object.class, (channel, msg) -> {
+            for (int i = 0; i < 10000; i++) {
+                System.currentTimeMillis();
             }
+            System.out.println(""handle:"" + msg + "";thread:"" + Thread.currentThread().getName());","[{'comment': 'This sout is not required for unit test. maybe remove it', 'commenter': 'htynkn'}]"
4957,dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ReplierDispatcherTest.java,"@@ -14,93 +14,116 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.dubbo.remoting;
+package org.apache.dubbo.remoting.transport.netty4;
 
 import org.apache.dubbo.common.URL;
+import org.apache.dubbo.remoting.RemotingException;
 import org.apache.dubbo.remoting.exchange.ExchangeChannel;
+import org.apache.dubbo.remoting.exchange.ExchangeServer;
 import org.apache.dubbo.remoting.exchange.Exchangers;
-import org.apache.dubbo.remoting.exchange.support.Replier;
 import org.apache.dubbo.remoting.exchange.support.ReplierDispatcher;
-
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 import java.io.Serializable;
 import java.util.Random;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
+import java.util.concurrent.*;
+
 
 /**
- * Main
+ * ReplierDispatcherTest
  */
 
-public class Main {
-    public static void main(String[] args) throws Exception {
-        startServer(9010);
-        mutliThreadTest(10, 9010);
-        dataPackageTest(9010);
-    }
+public class ReplierDispatcherTest {
+
+    private ExchangeServer exchangeServer;
+
+    private ConcurrentHashMap<String, ExchangeChannel> clients = new ConcurrentHashMap<>();
 
-    private static void startServer(int port) throws Exception {
+    private int port;
+
+    @BeforeEach
+    public void startServer() throws RemotingException {
+        port = (int) (1000 * Math.random() + 10000);
         ReplierDispatcher dispatcher = new ReplierDispatcher();
         dispatcher.addReplier(RpcMessage.class, new RpcMessageHandler());
-        dispatcher.addReplier(Object.class, new Replier<Object>() {
-            public Object reply(ExchangeChannel channel, Object msg) {
-                for (int i = 0; i < 10000; i++)
-                    System.currentTimeMillis();
-                System.out.println(""handle:"" + msg + "";thread:"" + Thread.currentThread().getName());
-                return new StringMessage(""hello world"");
+        dispatcher.addReplier(Object.class, (channel, msg) -> {
+            for (int i = 0; i < 10000; i++) {
+                System.currentTimeMillis();
             }
+            System.out.println(""handle:"" + msg + "";thread:"" + Thread.currentThread().getName());
+            return new StringMessage(""hello world"");
         });
-        Exchangers.bind(URL.valueOf(""dubbo://localhost:"" + port), dispatcher);
+        exchangeServer = Exchangers.bind(URL.valueOf(""dubbo://localhost:"" + port), dispatcher);
     }
 
-    static void dataPackageTest(int port) throws Exception {
+
+    @Test
+    public void testDataPackage() throws Exception {
         ExchangeChannel client = Exchangers.connect(URL.valueOf(""dubbo://localhost:"" + port));
         Random random = new Random();
         for (int i = 5; i < 100; i++) {
             StringBuilder sb = new StringBuilder();
             for (int j = 0; j < i * 100; j++)
-                sb.append(""("" + random.nextLong() + "")"");
-            Main.Data d = new Main.Data();
+                sb.append(""("").append(random.nextLong()).append("")"");
+            Data d = new Data();
             d.setData(sb.toString());
-            client.request(d).get();
+            Assertions.assertEquals(client.request(d).get().toString(), ""hello world"");
         }
-        System.out.println(""send finished."");
+        clients.put(Thread.currentThread().getName(), client);
     }
 
-    static void mutliThreadTest(int tc, final int port) throws Exception {
-        Executor exec = Executors.newFixedThreadPool(tc);
+
+    @Test
+    public void testMutliThread() throws Exception {
+        int tc = 10;","[{'comment': '`Mutli` --> `Multi` ?', 'commenter': 'htynkn'}, {'comment': ""Thank you for your suggestion. I've already revised it.\r\n\r\n"", 'commenter': 'xiaomoran'}]"
4974,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -252,7 +251,7 @@ private void scheduleServiceNamesLookup(final URL url, final NotifyListener list
                     boolean accepted = false;
                     for (String category : ALL_SUPPORTED_CATEGORIES) {
                         String prefix = category + SERVICE_NAME_SEPARATOR;
-                        if (StringUtils.startsWith(serviceName, prefix)) {
+                        if (serviceName != null && serviceName.startsWith(prefix)) {","[{'comment': 'I think previous version is okay.', 'commenter': 'Moriadry-zz'}]"
4974,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -16,24 +16,23 @@
  */
 package org.apache.dubbo.registry.nacos;
 
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.UrlUtils;
-import org.apache.dubbo.registry.NotifyListener;
-import org.apache.dubbo.registry.Registry;
-import org.apache.dubbo.registry.support.FailbackRegistry;
-
-import com.alibaba.nacos.api.exception.NacosException;
-import com.alibaba.nacos.api.naming.NamingService;
-import com.alibaba.nacos.api.naming.listener.EventListener;
-import com.alibaba.nacos.api.naming.listener.NamingEvent;
-import com.alibaba.nacos.api.naming.pojo.Instance;
-import com.alibaba.nacos.api.naming.pojo.ListView;
-import org.apache.commons.lang3.ArrayUtils;
-import org.apache.commons.lang3.StringUtils;","[{'comment': 'Why remove StringUtils usage? It somehow makes our code more elegant.', 'commenter': 'Moriadry-zz'}, {'comment': ""I think we should not rely on common-lang3 directly. It is a traverse dependency from nacos. We've already had StringUtils in dubbo. Instead of use another StringUtils, I would prefer to enhance the existing one."", 'commenter': 'beiwei30'}]"
4974,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -324,32 +323,32 @@ private void filterServiceNames(Set<String> serviceNames, URL url) {
             // (required) segments[1] = serviceInterface
             // (optional) segments[2] = version
             // (optional) segments[3] = group
-            String[] segments = StringUtils.split(serviceName, SERVICE_NAME_SEPARATOR);
+            String[] segments = serviceName.split(SERVICE_NAME_SEPARATOR, -1);
             int length = segments.length;
             if (length != 4) { // must present 4 segments
                 return false;
             }
 
             String category = segments[CATEGORY_INDEX];
-            if (!ArrayUtils.contains(categories, category)) { // no match category
+            if (!categories.contains(category)) { // no match category","[{'comment': 'This will cause NPE.', 'commenter': 'Moriadry-zz'}, {'comment': 'getCategories guarentees it cannot be null.\r\n\r\n```java\r\nfinal List<String> categories = getCategories(url); \r\n```', 'commenter': 'beiwei30'}]"
4974,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -324,32 +323,32 @@ private void filterServiceNames(Set<String> serviceNames, URL url) {
             // (required) segments[1] = serviceInterface
             // (optional) segments[2] = version
             // (optional) segments[3] = group
-            String[] segments = StringUtils.split(serviceName, SERVICE_NAME_SEPARATOR);
+            String[] segments = serviceName.split(SERVICE_NAME_SEPARATOR, -1);
             int length = segments.length;
             if (length != 4) { // must present 4 segments
                 return false;
             }
 
             String category = segments[CATEGORY_INDEX];
-            if (!ArrayUtils.contains(categories, category)) { // no match category
+            if (!categories.contains(category)) { // no match category
                 return false;
             }
 
             String serviceInterface = segments[SERVICE_INTERFACE_INDEX];
             if (!WILDCARD.equals(targetServiceInterface) &&
-                    !StringUtils.equals(targetServiceInterface, serviceInterface)) { // no match service interface
+                    !targetServiceInterface.equals(serviceInterface)) { // no match service interface","[{'comment': 'Same NPE here.', 'commenter': 'Moriadry-zz'}, {'comment': 'will fix.', 'commenter': 'beiwei30'}]"
4974,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -324,32 +323,32 @@ private void filterServiceNames(Set<String> serviceNames, URL url) {
             // (required) segments[1] = serviceInterface
             // (optional) segments[2] = version
             // (optional) segments[3] = group
-            String[] segments = StringUtils.split(serviceName, SERVICE_NAME_SEPARATOR);
+            String[] segments = serviceName.split(SERVICE_NAME_SEPARATOR, -1);
             int length = segments.length;
             if (length != 4) { // must present 4 segments
                 return false;
             }
 
             String category = segments[CATEGORY_INDEX];
-            if (!ArrayUtils.contains(categories, category)) { // no match category
+            if (!categories.contains(category)) { // no match category
                 return false;
             }
 
             String serviceInterface = segments[SERVICE_INTERFACE_INDEX];
             if (!WILDCARD.equals(targetServiceInterface) &&
-                    !StringUtils.equals(targetServiceInterface, serviceInterface)) { // no match service interface
+                    !targetServiceInterface.equals(serviceInterface)) { // no match service interface
                 return false;
             }
 
             String version = segments[SERVICE_VERSION_INDEX];
             if (!WILDCARD.equals(targetVersion) &&
-                    !StringUtils.equals(targetVersion, version)) { // no match service version
+                    !targetVersion.equals(version)) { // no match service version
                 return false;
             }
 
             String group = segments[SERVICE_GROUP_INDEX];
             return group == null || WILDCARD.equals(targetGroup)
-                    || StringUtils.equals(targetGroup, group);
+                    || targetGroup.equals(group);","[{'comment': 'Same here.', 'commenter': 'Moriadry-zz'}, {'comment': ""targetGroup cannot be null, but I will use dubbo's StringUtils anyway."", 'commenter': 'beiwei30'}]"
4974,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -324,32 +323,32 @@ private void filterServiceNames(Set<String> serviceNames, URL url) {
             // (required) segments[1] = serviceInterface
             // (optional) segments[2] = version
             // (optional) segments[3] = group
-            String[] segments = StringUtils.split(serviceName, SERVICE_NAME_SEPARATOR);
+            String[] segments = serviceName.split(SERVICE_NAME_SEPARATOR, -1);
             int length = segments.length;
             if (length != 4) { // must present 4 segments
                 return false;
             }
 
             String category = segments[CATEGORY_INDEX];
-            if (!ArrayUtils.contains(categories, category)) { // no match category
+            if (!categories.contains(category)) { // no match category
                 return false;
             }
 
             String serviceInterface = segments[SERVICE_INTERFACE_INDEX];
             if (!WILDCARD.equals(targetServiceInterface) &&
-                    !StringUtils.equals(targetServiceInterface, serviceInterface)) { // no match service interface
+                    !targetServiceInterface.equals(serviceInterface)) { // no match service interface
                 return false;
             }
 
             String version = segments[SERVICE_VERSION_INDEX];
             if (!WILDCARD.equals(targetVersion) &&
-                    !StringUtils.equals(targetVersion, version)) { // no match service version
+                    !targetVersion.equals(version)) { // no match service version","[{'comment': 'Same here.', 'commenter': 'Moriadry-zz'}, {'comment': ""targetVersion cannot be null, but I will use dubbo's StringUtils anyway."", 'commenter': 'beiwei30'}]"
4974,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceName.java,"@@ -113,12 +107,12 @@ public boolean isCompatible(NacosServiceName concreteServiceName) {
         }
 
         // Not match comparison
-        if (!StringUtils.equals(this.category, concreteServiceName.category) &&
-                !ArrayUtils.contains(splitPreserveAllTokens(this.category, VALUE_SEPARATOR), concreteServiceName.category)) {
+        if (!this.category.equals(concreteServiceName.category)","[{'comment': 'NPE concern.', 'commenter': 'Moriadry-zz'}, {'comment': ""will change to use dubbo's stringutils."", 'commenter': 'beiwei30'}]"
4974,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceName.java,"@@ -113,12 +107,12 @@ public boolean isCompatible(NacosServiceName concreteServiceName) {
         }
 
         // Not match comparison
-        if (!StringUtils.equals(this.category, concreteServiceName.category) &&
-                !ArrayUtils.contains(splitPreserveAllTokens(this.category, VALUE_SEPARATOR), concreteServiceName.category)) {
+        if (!this.category.equals(concreteServiceName.category)
+                && !matchRange(this.category, concreteServiceName.category)) {
             return false;
         }
 
-        if (!StringUtils.equals(this.serviceInterface, concreteServiceName.serviceInterface)) {
+        if (!this.serviceInterface.equals(concreteServiceName.serviceInterface)) {","[{'comment': 'And here.', 'commenter': 'Moriadry-zz'}, {'comment': ""will change to use dubbo's stringutils."", 'commenter': 'beiwei30'}]"
4974,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceName.java,"@@ -132,13 +126,12 @@ public boolean isCompatible(NacosServiceName concreteServiceName) {
         }
 
         // range condition
-        if (!StringUtils.equals(this.version, concreteServiceName.version) &&
-                !matchRange(this.version, concreteServiceName.version)) {
+        if (!this.version.equals(concreteServiceName.version)","[{'comment': 'Same here.', 'commenter': 'Moriadry-zz'}, {'comment': ""will change to use dubbo's stringutils."", 'commenter': 'beiwei30'}]"
4998,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalance.java,"@@ -1,141 +1,142 @@
-/*","[{'comment': 'so many unexpected changes', 'commenter': 'kezhenxu94'}]"
5026,dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/ReplierDispatcherTest.java,"@@ -14,93 +14,120 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.dubbo.remoting;
+package org.apache.dubbo.remoting.transport.netty4;
 
 import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.remoting.RemotingException;
 import org.apache.dubbo.remoting.exchange.ExchangeChannel;
+import org.apache.dubbo.remoting.exchange.ExchangeServer;
 import org.apache.dubbo.remoting.exchange.Exchangers;
-import org.apache.dubbo.remoting.exchange.support.Replier;
 import org.apache.dubbo.remoting.exchange.support.ReplierDispatcher;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
 import java.io.Serializable;
 import java.util.Random;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
+import java.util.concurrent.*;
+
+import static org.junit.jupiter.api.Assertions.fail;
+
 
 /**
- * Main
+ * ReplierDispatcherTest
  */
 
-public class Main {
-    public static void main(String[] args) throws Exception {
-        startServer(9010);
-        mutliThreadTest(10, 9010);
-        dataPackageTest(9010);
-    }
+public class ReplierDispatcherTest {
+
+    private ExchangeServer exchangeServer;
+
+    private ConcurrentHashMap<String, ExchangeChannel> clients = new ConcurrentHashMap<>();
 
-    private static void startServer(int port) throws Exception {
+    private int port;
+
+    @BeforeEach
+    public void startServer() throws RemotingException {
+        port = NetUtils.getAvailablePort();
         ReplierDispatcher dispatcher = new ReplierDispatcher();
         dispatcher.addReplier(RpcMessage.class, new RpcMessageHandler());
-        dispatcher.addReplier(Object.class, new Replier<Object>() {
-            public Object reply(ExchangeChannel channel, Object msg) {
-                for (int i = 0; i < 10000; i++)
-                    System.currentTimeMillis();
-                System.out.println(""handle:"" + msg + "";thread:"" + Thread.currentThread().getName());
-                return new StringMessage(""hello world"");
+        dispatcher.addReplier(Data.class, (channel, msg) -> {
+            for (int i = 0; i < 10000; i++) {","[{'comment': ""I know this is existing code. but I'm thinking what's purpose for this code? looks like this is not necessary for this unit test"", 'commenter': 'htynkn'}, {'comment': '\r\nYes, this loop seems to be unnecessary, just to keep the existing code. I have changed it.', 'commenter': 'xiaomoran'}]"
5051,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ProtocolAnnotationBeanPostProcessor.java,"@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.config.spring.beans.factory.annotation;
+
+import org.apache.dubbo.config.ProtocolConfig;
+import org.springframework.beans.BeansException;
+import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
+import org.springframework.beans.factory.support.BeanDefinitionRegistry;
+import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;
+import org.springframework.beans.factory.support.DefaultListableBeanFactory;
+
+public class ProtocolAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor {
+
+    public static final String BEAN_NAME = ""protocolAnnotationBeanPostProcessor"";
+
+    @Override
+    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
+        if (registry instanceof DefaultListableBeanFactory) {
+            DefaultListableBeanFactory factory = (DefaultListableBeanFactory) registry;
+            String[] beanNames = factory.getBeanNamesForType(ProtocolConfig.class, true, false);
+            for (String beanName : beanNames) {
+                ProtocolConfig config = (ProtocolConfig) factory.getBean(beanName);","[{'comment': ""getBean method will cause the initialization of ProtocolConfig's bean too early"", 'commenter': 'mercyblitz'}, {'comment': ""> getBean method will cause the initialization of ProtocolConfig's bean too early\r\n\r\nI have created a PR #5063.. to avoid the eager initialization of ProtocolConfig's bean"", 'commenter': 'sonymoon'}]"
5108,dubbo-configcenter/dubbo-configcenter-apollo/src/main/java/org/apache/dubbo/configcenter/support/apollo/ApolloDynamicConfiguration.java,"@@ -83,6 +84,7 @@
 
         dubboConfig = ConfigService.getConfig(url.getParameter(CONFIG_NAMESPACE_KEY, DEFAULT_GROUP));
         dubboConfigFile = ConfigService.getConfigFile(url.getParameter(CONFIG_NAMESPACE_KEY, DEFAULT_GROUP), ConfigFileFormat.Properties);
+        governanceConfig = ConfigService.getConfig(url.getParameter(CONFIG_GOVERNANCE_NAMESPACE_KEY, DEFAULT_DUBBO_CONFIG_GOVERNANCCE_NAMESPACE));","[{'comment': 'CONFIG_GOVERNANCE_NAMESPACE_KEY  should be = CONFIG_NAMESPACE_KEY + "".governance""', 'commenter': 'kimmking'}, {'comment': '所以你认为只是key有这层关系，还是namespace的名称也是这层关系？', 'commenter': 'CodingSinger'}]"
5158,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"@@ -1,511 +1,512 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.registry.support;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.CollectionUtils;
-import org.apache.dubbo.common.utils.ConcurrentHashSet;
-import org.apache.dubbo.common.utils.ConfigUtils;
-import org.apache.dubbo.common.utils.NamedThreadFactory;
-import org.apache.dubbo.common.utils.UrlUtils;
-import org.apache.dubbo.registry.NotifyListener;
-import org.apache.dubbo.registry.Registry;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.RandomAccessFile;
-import java.nio.channels.FileChannel;
-import java.nio.channels.FileLock;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static org.apache.dubbo.common.constants.CommonConstants.ANY_VALUE;
-import static org.apache.dubbo.common.constants.CommonConstants.APPLICATION_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.FILE_KEY;
-import static org.apache.dubbo.common.constants.RegistryConstants.CATEGORY_KEY;
-import static org.apache.dubbo.common.constants.RegistryConstants.DEFAULT_CATEGORY;
-import static org.apache.dubbo.common.constants.RegistryConstants.DYNAMIC_KEY;
-import static org.apache.dubbo.common.constants.RegistryConstants.EMPTY_PROTOCOL;
-import static org.apache.dubbo.registry.Constants.REGISTRY_FILESAVE_SYNC_KEY;
-
-/**
- * AbstractRegistry. (SPI, Prototype, ThreadSafe)
- */
-public abstract class AbstractRegistry implements Registry {
-
-    // URL address separator, used in file cache, service provider URL separation
-    private static final char URL_SEPARATOR = ' ';
-    // URL address separated regular expression for parsing the service provider URL list in the file cache
-    private static final String URL_SPLIT = ""\\s+"";
-    // Max times to retry to save properties to local cache file
-    private static final int MAX_RETRY_TIMES_SAVE_PROPERTIES = 3;
-    // Log output
-    protected final Logger logger = LoggerFactory.getLogger(getClass());
-    // Local disk cache, where the special key value.registries records the list of registry centers, and the others are the list of notified service providers
-    private final Properties properties = new Properties();
-    // File cache timing writing
-    private final ExecutorService registryCacheExecutor = Executors.newFixedThreadPool(1, new NamedThreadFactory(""DubboSaveRegistryCache"", true));
-    // Is it synchronized to save the file
-    private final boolean syncSaveFile;
-    private final AtomicLong lastCacheChanged = new AtomicLong();
-    private final AtomicInteger savePropertiesRetryTimes = new AtomicInteger();
-    private final Set<URL> registered = new ConcurrentHashSet<>();
-    private final ConcurrentMap<URL, Set<NotifyListener>> subscribed = new ConcurrentHashMap<>();
-    private final ConcurrentMap<URL, Map<String, List<URL>>> notified = new ConcurrentHashMap<>();
-    private URL registryUrl;
-    // Local disk cache file
-    private File file;
-
-    public AbstractRegistry(URL url) {
-        setUrl(url);
-        // Start file save timer
-        syncSaveFile = url.getParameter(REGISTRY_FILESAVE_SYNC_KEY, false);
-        String filename = url.getParameter(FILE_KEY, System.getProperty(""user.home"") + ""/.dubbo/dubbo-registry-"" + url.getParameter(APPLICATION_KEY) + ""-"" + url.getAddress() + "".cache"");
-        File file = null;
-        if (ConfigUtils.isNotEmpty(filename)) {
-            file = new File(filename);
-            if (!file.exists() && file.getParentFile() != null && !file.getParentFile().exists()) {
-                if (!file.getParentFile().mkdirs()) {
-                    throw new IllegalArgumentException(""Invalid registry cache file "" + file + "", cause: Failed to create directory "" + file.getParentFile() + ""!"");
-                }
-            }
-        }
-        this.file = file;
-        // When starting the subscription center,
-        // we need to read the local cache file for future Registry fault tolerance processing.
-        loadProperties();
-        notify(url.getBackupUrls());
-    }
-
-    protected static List<URL> filterEmpty(URL url, List<URL> urls) {
-        if (CollectionUtils.isEmpty(urls)) {
-            List<URL> result = new ArrayList<>(1);
-            result.add(url.setProtocol(EMPTY_PROTOCOL));
-            return result;
-        }
-        return urls;
-    }
-
-    @Override
-    public URL getUrl() {
-        return registryUrl;
-    }
-
-    protected void setUrl(URL url) {
-        if (url == null) {
-            throw new IllegalArgumentException(""registry url == null"");
-        }
-        this.registryUrl = url;
-    }
-
-    public Set<URL> getRegistered() {
-        return Collections.unmodifiableSet(registered);
-    }
-
-    public Map<URL, Set<NotifyListener>> getSubscribed() {
-        return Collections.unmodifiableMap(subscribed);
-    }
-
-    public Map<URL, Map<String, List<URL>>> getNotified() {
-        return Collections.unmodifiableMap(notified);
-    }
-
-    public File getCacheFile() {
-        return file;
-    }
-
-    public Properties getCacheProperties() {
-        return properties;
-    }
-
-    public AtomicLong getLastCacheChanged() {
-        return lastCacheChanged;
-    }
-
-    public void doSaveProperties(long version) {
-        if (version < lastCacheChanged.get()) {
-            return;
-        }
-        if (file == null) {
-            return;
-        }
-        // Save
-        try {
-            File lockfile = new File(file.getAbsolutePath() + "".lock"");
-            if (!lockfile.exists()) {
-                lockfile.createNewFile();
-            }
-            try (RandomAccessFile raf = new RandomAccessFile(lockfile, ""rw"");
-                 FileChannel channel = raf.getChannel()) {
-                FileLock lock = channel.tryLock();
-                if (lock == null) {
-                    throw new IOException(""Can not lock the registry cache file "" + file.getAbsolutePath() + "", ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties"");
-                }
-                // Save
-                try {
-                    if (!file.exists()) {
-                        file.createNewFile();
-                    }
-                    try (FileOutputStream outputFile = new FileOutputStream(file)) {
-                        properties.store(outputFile, ""Dubbo Registry Cache"");
-                    }
-                } finally {
-                    lock.release();
-                }
-            }
-        } catch (Throwable e) {
-            savePropertiesRetryTimes.incrementAndGet();
-            if (savePropertiesRetryTimes.get() >= MAX_RETRY_TIMES_SAVE_PROPERTIES) {
-                logger.warn(""Failed to save registry cache file after retrying "" + MAX_RETRY_TIMES_SAVE_PROPERTIES + "" times, cause: "" + e.getMessage(), e);
-                savePropertiesRetryTimes.set(0);
-                return;
-            }
-            if (version < lastCacheChanged.get()) {
-                savePropertiesRetryTimes.set(0);
-                return;
-            } else {
-                registryCacheExecutor.execute(new SaveProperties(lastCacheChanged.incrementAndGet()));
-            }
-            logger.warn(""Failed to save registry cache file, will retry, cause: "" + e.getMessage(), e);
-        }
-    }
-
-    private void loadProperties() {
-        if (file != null && file.exists()) {
-            InputStream in = null;
-            try {
-                in = new FileInputStream(file);
-                properties.load(in);
-                if (logger.isInfoEnabled()) {
-                    logger.info(""Load registry cache file "" + file + "", data: "" + properties);
-                }
-            } catch (Throwable e) {
-                logger.warn(""Failed to load registry cache file "" + file, e);
-            } finally {
-                if (in != null) {
-                    try {
-                        in.close();
-                    } catch (IOException e) {
-                        logger.warn(e.getMessage(), e);
-                    }
-                }
-            }
-        }
-    }
-
-    public List<URL> getCacheUrls(URL url) {
-        for (Map.Entry<Object, Object> entry : properties.entrySet()) {
-            String key = (String) entry.getKey();
-            String value = (String) entry.getValue();
-            if (key != null && key.length() > 0 && key.equals(url.getServiceKey())
-                    && (Character.isLetter(key.charAt(0)) || key.charAt(0) == '_')
-                    && value != null && value.length() > 0) {
-                String[] arr = value.trim().split(URL_SPLIT);
-                List<URL> urls = new ArrayList<>();
-                for (String u : arr) {
-                    urls.add(URL.valueOf(u));
-                }
-                return urls;
-            }
-        }
-        return null;
-    }
-
-    @Override
-    public List<URL> lookup(URL url) {
-        List<URL> result = new ArrayList<>();
-        Map<String, List<URL>> notifiedUrls = getNotified().get(url);
-        if (notifiedUrls != null && notifiedUrls.size() > 0) {
-            for (List<URL> urls : notifiedUrls.values()) {
-                for (URL u : urls) {
-                    if (!EMPTY_PROTOCOL.equals(u.getProtocol())) {
-                        result.add(u);
-                    }
-                }
-            }
-        } else {
-            final AtomicReference<List<URL>> reference = new AtomicReference<>();
-            NotifyListener listener = reference::set;
-            subscribe(url, listener); // Subscribe logic guarantees the first notify to return
-            List<URL> urls = reference.get();
-            if (CollectionUtils.isNotEmpty(urls)) {
-                for (URL u : urls) {
-                    if (!EMPTY_PROTOCOL.equals(u.getProtocol())) {
-                        result.add(u);
-                    }
-                }
-            }
-        }
-        return result;
-    }
-
-    @Override
-    public void register(URL url) {
-        if (url == null) {
-            throw new IllegalArgumentException(""register url == null"");
-        }
-        if (logger.isInfoEnabled()) {
-            logger.info(""Register: "" + url);
-        }
-        registered.add(url);
-    }
-
-    @Override
-    public void unregister(URL url) {
-        if (url == null) {
-            throw new IllegalArgumentException(""unregister url == null"");
-        }
-        if (logger.isInfoEnabled()) {
-            logger.info(""Unregister: "" + url);
-        }
-        registered.remove(url);
-    }
-
-    @Override
-    public void subscribe(URL url, NotifyListener listener) {
-        if (url == null) {
-            throw new IllegalArgumentException(""subscribe url == null"");
-        }
-        if (listener == null) {
-            throw new IllegalArgumentException(""subscribe listener == null"");
-        }
-        if (logger.isInfoEnabled()) {
-            logger.info(""Subscribe: "" + url);
-        }
-        Set<NotifyListener> listeners = subscribed.computeIfAbsent(url, n -> new ConcurrentHashSet<>());
-        listeners.add(listener);
-    }
-
-    @Override
-    public void unsubscribe(URL url, NotifyListener listener) {
-        if (url == null) {
-            throw new IllegalArgumentException(""unsubscribe url == null"");
-        }
-        if (listener == null) {
-            throw new IllegalArgumentException(""unsubscribe listener == null"");
-        }
-        if (logger.isInfoEnabled()) {
-            logger.info(""Unsubscribe: "" + url);
-        }
-        Set<NotifyListener> listeners = subscribed.get(url);
-        if (listeners != null) {
-            listeners.remove(listener);
-        }
-    }
-
-    protected void recover() throws Exception {
-        // register
-        Set<URL> recoverRegistered = new HashSet<>(getRegistered());
-        if (!recoverRegistered.isEmpty()) {
-            if (logger.isInfoEnabled()) {
-                logger.info(""Recover register url "" + recoverRegistered);
-            }
-            for (URL url : recoverRegistered) {
-                register(url);
-            }
-        }
-        // subscribe
-        Map<URL, Set<NotifyListener>> recoverSubscribed = new HashMap<>(getSubscribed());
-        if (!recoverSubscribed.isEmpty()) {
-            if (logger.isInfoEnabled()) {
-                logger.info(""Recover subscribe url "" + recoverSubscribed.keySet());
-            }
-            for (Map.Entry<URL, Set<NotifyListener>> entry : recoverSubscribed.entrySet()) {
-                URL url = entry.getKey();
-                for (NotifyListener listener : entry.getValue()) {
-                    subscribe(url, listener);
-                }
-            }
-        }
-    }
-
-    protected void notify(List<URL> urls) {
-        if (CollectionUtils.isEmpty(urls)) {
-            return;
-        }
-
-        for (Map.Entry<URL, Set<NotifyListener>> entry : getSubscribed().entrySet()) {
-            URL url = entry.getKey();
-
-            if (!UrlUtils.isMatch(url, urls.get(0))) {
-                continue;
-            }
-
-            Set<NotifyListener> listeners = entry.getValue();
-            if (listeners != null) {
-                for (NotifyListener listener : listeners) {
-                    try {
-                        notify(url, listener, filterEmpty(url, urls));
-                    } catch (Throwable t) {
-                        logger.error(""Failed to notify registry event, urls: "" + urls + "", cause: "" + t.getMessage(), t);
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * Notify changes from the Provider side.
-     *
-     * @param url      consumer side url
-     * @param listener listener
-     * @param urls     provider latest urls
-     */
-    protected void notify(URL url, NotifyListener listener, List<URL> urls) {
-        if (url == null) {
-            throw new IllegalArgumentException(""notify url == null"");
-        }
-        if (listener == null) {
-            throw new IllegalArgumentException(""notify listener == null"");
-        }
-        if ((CollectionUtils.isEmpty(urls))
-                && !ANY_VALUE.equals(url.getServiceInterface())) {
-            logger.warn(""Ignore empty notify urls for subscribe url "" + url);
-            return;
-        }
-        if (logger.isInfoEnabled()) {
-            logger.info(""Notify urls for subscribe url "" + url + "", urls: "" + urls);
-        }
-        // keep every provider's category.
-        Map<String, List<URL>> result = new HashMap<>();
-        for (URL u : urls) {
-            if (UrlUtils.isMatch(url, u)) {
-                String category = u.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY);
-                List<URL> categoryList = result.computeIfAbsent(category, k -> new ArrayList<>());
-                categoryList.add(u);
-            }
-        }
-        if (result.size() == 0) {
-            return;
-        }
-        Map<String, List<URL>> categoryNotified = notified.computeIfAbsent(url, u -> new ConcurrentHashMap<>());
-        for (Map.Entry<String, List<URL>> entry : result.entrySet()) {
-            String category = entry.getKey();
-            List<URL> categoryList = entry.getValue();
-            categoryNotified.put(category, categoryList);
-            listener.notify(categoryList);
-            // We will update our cache file after each notification.
-            // When our Registry has a subscribe failure due to network jitter, we can return at least the existing cache URL.
-            saveProperties(url);
-        }
-    }
-
-    private void saveProperties(URL url) {
-        if (file == null) {
-            return;
-        }
-
-        try {
-            StringBuilder buf = new StringBuilder();
-            Map<String, List<URL>> categoryNotified = notified.get(url);
-            if (categoryNotified != null) {
-                for (List<URL> us : categoryNotified.values()) {
-                    for (URL u : us) {
-                        if (buf.length() > 0) {
-                            buf.append(URL_SEPARATOR);
-                        }
-                        buf.append(u.toFullString());
-                    }
-                }
-            }
-            properties.setProperty(url.getServiceKey(), buf.toString());
-            long version = lastCacheChanged.incrementAndGet();
-            if (syncSaveFile) {
-                doSaveProperties(version);
-            } else {
-                registryCacheExecutor.execute(new SaveProperties(version));
-            }
-        } catch (Throwable t) {
-            logger.warn(t.getMessage(), t);
-        }
-    }
-
-    @Override
-    public void destroy() {
-        if (logger.isInfoEnabled()) {
-            logger.info(""Destroy registry:"" + getUrl());
-        }
-        Set<URL> destroyRegistered = new HashSet<>(getRegistered());
-        if (!destroyRegistered.isEmpty()) {
-            for (URL url : new HashSet<>(getRegistered())) {
-                if (url.getParameter(DYNAMIC_KEY, true)) {
-                    try {
-                        unregister(url);
-                        if (logger.isInfoEnabled()) {
-                            logger.info(""Destroy unregister url "" + url);
-                        }
-                    } catch (Throwable t) {
-                        logger.warn(""Failed to unregister url "" + url + "" to registry "" + getUrl() + "" on destroy, cause: "" + t.getMessage(), t);
-                    }
-                }
-            }
-        }
-        Map<URL, Set<NotifyListener>> destroySubscribed = new HashMap<>(getSubscribed());
-        if (!destroySubscribed.isEmpty()) {
-            for (Map.Entry<URL, Set<NotifyListener>> entry : destroySubscribed.entrySet()) {
-                URL url = entry.getKey();
-                for (NotifyListener listener : entry.getValue()) {
-                    try {
-                        unsubscribe(url, listener);
-                        if (logger.isInfoEnabled()) {
-                            logger.info(""Destroy unsubscribe url "" + url);
-                        }
-                    } catch (Throwable t) {
-                        logger.warn(""Failed to unsubscribe url "" + url + "" to registry "" + getUrl() + "" on destroy, cause: "" + t.getMessage(), t);
-                    }
-                }
-            }
-        }
-    }
-
-    @Override
-    public String toString() {
-        return getUrl().toString();
-    }
-
-    private class SaveProperties implements Runnable {
-        private long version;
-
-        private SaveProperties(long version) {
-            this.version = version;
-        }
-
-        @Override
-        public void run() {
-            doSaveProperties(version);
-        }
-    }
-
-}
+/*","[{'comment': 'What changes in this file? If no changes for this file, please revert it.', 'commenter': 'htynkn'}, {'comment': ""I only modified 95 and 96 lines, the local comparison is only modified 95 and 96 lines, I don't know why the whole file is modified here."", 'commenter': 'JoeKerouac'}]"
5199,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -452,9 +454,6 @@ public synchronized void unexport() {
     private void doExportUrls() {
         List<URL> registryURLs = loadRegistries(true);
         for (ProtocolConfig protocolConfig : protocols) {
-            String pathKey = URL.buildKey(getContextPath(protocolConfig).map(p -> p + ""/"" + path).orElse(path), group, version);","[{'comment': 'you should make a unit test case for this change', 'commenter': 'kimmking'}, {'comment': 'to ensure the commit can solve your NPE issue ', 'commenter': 'kimmking'}]"
5212,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -398,16 +398,17 @@ private void filterServiceNames(Set<String> serviceNames, URL url) {
 
     private void subscribeEventListener(String serviceName, final URL url, final NotifyListener listener)
             throws NacosException {
-        if (!nacosListeners.containsKey(serviceName)) {
-            EventListener eventListener = event -> {
-                if (event instanceof NamingEvent) {
-                    NamingEvent e = (NamingEvent) event;
-                    notifySubscriber(url, listener, e.getInstances());
-                }
-            };
-            namingService.subscribe(serviceName, eventListener);
-            nacosListeners.put(serviceName, eventListener);
+        if (nacosListeners.containsKey(serviceName)) {
+            logger.info(""nacosListeners contains serviceName:"" + serviceName);
         }
+        EventListener eventListener = event -> {
+            if (event instanceof NamingEvent) {
+                NamingEvent e = (NamingEvent) event;
+                notifySubscriber(url, listener, e.getInstances());
+            }
+        };
+        namingService.subscribe(serviceName, eventListener);
+        nacosListeners.put(serviceName, eventListener);","[{'comment': 'I think we should also consider changing the data structure of nacosListeners to Map<String, List<EventListener>>?', 'commenter': 'chickenlj'}]"
5270,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java,"@@ -115,35 +115,41 @@ public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
     private void log(String accessLog, AccessLogData accessLogData) {
         Set<AccessLogData> logSet = LOG_ENTRIES.computeIfAbsent(accessLog, k -> new ConcurrentHashSet<>());
 
-        if (logSet.size() < LOG_MAX_BUFFER) {
+        if (logSet.size() >= LOG_MAX_BUFFER) {","[{'comment': 'Shouldn\'t this comparator be ""<"", which means we can only add new item to logSet when it\'s size does not exceed `LOG_MAX_BUFFER `?', 'commenter': 'chickenlj'}, {'comment': 'You are right! I will fix this.', 'commenter': 'wangkezun'}]"
5481,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyFactory.java,"@@ -17,28 +17,24 @@
 package org.apache.dubbo.rpc.proxy;
 
 import org.apache.dubbo.common.utils.ReflectUtils;
+import org.apache.dubbo.rpc.Constants;
 import org.apache.dubbo.rpc.Invoker;
 import org.apache.dubbo.rpc.ProxyFactory;
 import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.service.Destroyable;
 import org.apache.dubbo.rpc.service.GenericService;
 
 import com.alibaba.dubbo.rpc.service.EchoService;
 
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.Set;
-
 import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;
 import static org.apache.dubbo.rpc.Constants.INTERFACES;
 
+import java.util.HashSet;
+import java.util.Set;
+
 /**
  * AbstractProxyFactory
  */
 public abstract class AbstractProxyFactory implements ProxyFactory {
-    private static final Class<?>[] INTERNAL_INTERFACES = new Class<?>[]{
-            EchoService.class, Destroyable.class","[{'comment': 'this part is lost in the pr.', 'commenter': 'chickenlj'}]"
5481,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyFactory.java,"@@ -47,25 +43,31 @@
 
     @Override
     public <T> T getProxy(Invoker<T> invoker, boolean generic) throws RpcException {
-        Set<Class<?>> interfaces = new HashSet<>();
-
+        Set<Class<?>> interfaces = new HashSet<Class<?>>();
         String config = invoker.getUrl().getParameter(INTERFACES);
         if (config != null && config.length() > 0) {
             String[] types = COMMA_SPLIT_PATTERN.split(config);
-            if (types != null && types.length > 0) {
-                for (int i = 0; i < types.length; i++) {
-                    // TODO can we load successfully for a different classloader?.
-                    interfaces.add(ReflectUtils.forName(types[i]));
-                }
+
+            for (String type : types) {
+                // TODO can we load successfully for a different classloader?.
+                interfaces.add(ReflectUtils.forName(type));
             }
         }
 
-        if (!GenericService.class.isAssignableFrom(invoker.getInterface()) && generic) {
-            interfaces.add(com.alibaba.dubbo.rpc.service.GenericService.class);
-        }
+        interfaces.add(EchoService.class);
+        if (generic) {
+            if (!GenericService.class.isAssignableFrom(invoker.getInterface())) {
+                interfaces.add(GenericService.class);","[{'comment': '`com.alibaba.dubbo.rpc.service.GenericService` should still b supported.', 'commenter': 'chickenlj'}]"
5484,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java,"@@ -1,183 +1,183 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.registry.support;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.URLBuilder;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.registry.NotifyListener;
-import org.apache.dubbo.registry.Registry;
-import org.apache.dubbo.registry.RegistryFactory;
-import org.apache.dubbo.registry.RegistryService;
-
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.locks.ReentrantLock;
-
-import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;
-import static org.apache.dubbo.rpc.cluster.Constants.EXPORT_KEY;
-import static org.apache.dubbo.rpc.cluster.Constants.REFER_KEY;
-
-/**
- * AbstractRegistryFactory. (SPI, Singleton, ThreadSafe)
- *
- * @see org.apache.dubbo.registry.RegistryFactory
- */
-public abstract class AbstractRegistryFactory implements RegistryFactory {
-
-    // Log output
-    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRegistryFactory.class);
-
-    // The lock for the acquisition process of the registry
-    private static final ReentrantLock LOCK = new ReentrantLock();
-
-    // Registry Collection Map<RegistryAddress, Registry>
-    private static final Map<String, Registry> REGISTRIES = new HashMap<>();
-
-    private static final AtomicBoolean destroyed = new AtomicBoolean(false);
-
-    /**
-     * Get all registries
-     *
-     * @return all registries
-     */
-    public static Collection<Registry> getRegistries() {
-        return Collections.unmodifiableCollection(REGISTRIES.values());
-    }
-
-    public static Registry getRegistry(String key) {
-        return REGISTRIES.get(key);
-    }
-
-    /**
-     * Close all created registries
-     */
-    public static void destroyAll() {
-        if (!destroyed.compareAndSet(false, true)) {
-            return;
-        }
-
-        if (LOGGER.isInfoEnabled()) {
-            LOGGER.info(""Close all registries "" + getRegistries());
-        }
-        // Lock up the registry shutdown process
-        LOCK.lock();
-        try {
-            for (Registry registry : getRegistries()) {
-                try {
-                    registry.destroy();
-                } catch (Throwable e) {
-                    LOGGER.error(e.getMessage(), e);
-                }
-            }
-            REGISTRIES.clear();
-        } finally {
-            // Release the lock
-            LOCK.unlock();
-        }
-    }
-
-    @Override
-    public Registry getRegistry(URL url) {
-        if (destroyed.get()) {
-            LOGGER.warn(""All registry instances have been destroyed, failed to fetch any instance. "" +
-                    ""Usually, this means no need to try to do unnecessary redundant resource clearance, all registries has been taken care of."");
-            return DEFAULT_NOP_REGISTRY;
-        }
-
-        url = URLBuilder.from(url)
-                .setPath(RegistryService.class.getName())
-                .addParameter(INTERFACE_KEY, RegistryService.class.getName())
-                .removeParameters(EXPORT_KEY, REFER_KEY)
-                .build();
-        String key = url.toServiceStringWithoutResolving();
-        // Lock the registry access process to ensure a single instance of the registry
-        LOCK.lock();
-        try {
-            Registry registry = REGISTRIES.get(key);
-            if (registry != null) {
-                return registry;
-            }
-            //create registry by spi/ioc
-            registry = createRegistry(url);
-            if (registry == null) {
-                throw new IllegalStateException(""Can not create registry "" + url);
-            }
-            REGISTRIES.put(key, registry);
-            return registry;
-        } finally {
-            // Release the lock
-            LOCK.unlock();
-        }
-    }
-
-    protected abstract Registry createRegistry(URL url);
-
-
-    private static Registry DEFAULT_NOP_REGISTRY = new Registry() {
-        @Override
-        public URL getUrl() {
-            return null;
-        }
-
-        @Override
-        public boolean isAvailable() {
-            return false;
-        }
-
-        @Override
-        public void destroy() {
-
-        }
-
-        @Override
-        public void register(URL url) {
-
-        }
-
-        @Override
-        public void unregister(URL url) {
-
-        }
-
-        @Override
-        public void subscribe(URL url, NotifyListener listener) {
-
-        }
-
-        @Override
-        public void unsubscribe(URL url, NotifyListener listener) {
-
-        }
-
-        @Override
-        public List<URL> lookup(URL url) {
-            return null;
-        }
-    };
-
-    // for unit test
-    public static void clearRegistryNotDestroy() {
-        REGISTRIES.clear();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.support;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.URLBuilder;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.registry.NotifyListener;
+import org.apache.dubbo.registry.Registry;
+import org.apache.dubbo.registry.RegistryFactory;
+import org.apache.dubbo.registry.RegistryService;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.ReentrantLock;
+
+import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;
+import static org.apache.dubbo.rpc.cluster.Constants.EXPORT_KEY;
+import static org.apache.dubbo.rpc.cluster.Constants.REFER_KEY;
+
+/**
+ * AbstractRegistryFactory. (SPI, Singleton, ThreadSafe)
+ *
+ * @see org.apache.dubbo.registry.RegistryFactory
+ */
+public abstract class AbstractRegistryFactory implements RegistryFactory {
+
+    // Log output
+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRegistryFactory.class);
+
+    // The lock for the acquisition process of the registry
+    private static final ReentrantLock LOCK = new ReentrantLock();
+
+    // Registry Collection Map<RegistryAddress, Registry>
+    private static final Map<String, Registry> REGISTRIES = new ConcurrentHashMap<>();
+
+    private static final AtomicBoolean destroyed = new AtomicBoolean(false);
+
+    /**
+     * Get all registries
+     *
+     * @return all registries
+     */
+    public static Collection<Registry> getRegistries() {
+        return Collections.unmodifiableCollection(REGISTRIES.values());
+    }
+
+    public static Registry getRegistry(String key) {
+        return REGISTRIES.get(key);
+    }
+
+    /**
+     * Close all created registries
+     */
+    public static void destroyAll() {
+        if (!destroyed.compareAndSet(false, true)) {
+            return;
+        }
+
+        if (LOGGER.isInfoEnabled()) {
+            LOGGER.info(""Close all registries "" + getRegistries());
+        }
+        // Lock up the registry shutdown process
+        LOCK.lock();
+        try {
+            for (Registry registry : getRegistries()) {
+                try {
+                    registry.destroy();
+                } catch (Throwable e) {
+                    LOGGER.error(e.getMessage(), e);
+                }
+            }
+            REGISTRIES.clear();
+        } finally {
+            // Release the lock
+            LOCK.unlock();
+        }
+    }
+
+    @Override
+    public Registry getRegistry(URL url) {
+        if (destroyed.get()) {
+            LOGGER.warn(""All registry instances have been destroyed, failed to fetch any instance. "" +
+                    ""Usually, this means no need to try to do unnecessary redundant resource clearance, all registries has been taken care of."");
+            return DEFAULT_NOP_REGISTRY;
+        }
+
+        url = URLBuilder.from(url)
+                .setPath(RegistryService.class.getName())
+                .addParameter(INTERFACE_KEY, RegistryService.class.getName())
+                .removeParameters(EXPORT_KEY, REFER_KEY)
+                .build();
+        String key = url.toServiceStringWithoutResolving();
+        Registry registry = REGISTRIES.get(key);","[{'comment': ""i think shouldn't move those code outside the lock-unlock block. it will cause invoke createRegistry multiple times in some cases."", 'commenter': 'CodingSinger'}]"
5484,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistryFactory.java,"@@ -1,183 +1,183 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.registry.support;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.URLBuilder;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.registry.NotifyListener;
-import org.apache.dubbo.registry.Registry;
-import org.apache.dubbo.registry.RegistryFactory;
-import org.apache.dubbo.registry.RegistryService;
-
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.locks.ReentrantLock;
-
-import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;
-import static org.apache.dubbo.rpc.cluster.Constants.EXPORT_KEY;
-import static org.apache.dubbo.rpc.cluster.Constants.REFER_KEY;
-
-/**
- * AbstractRegistryFactory. (SPI, Singleton, ThreadSafe)
- *
- * @see org.apache.dubbo.registry.RegistryFactory
- */
-public abstract class AbstractRegistryFactory implements RegistryFactory {
-
-    // Log output
-    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRegistryFactory.class);
-
-    // The lock for the acquisition process of the registry
-    private static final ReentrantLock LOCK = new ReentrantLock();
-
-    // Registry Collection Map<RegistryAddress, Registry>
-    private static final Map<String, Registry> REGISTRIES = new HashMap<>();
-
-    private static final AtomicBoolean destroyed = new AtomicBoolean(false);
-
-    /**
-     * Get all registries
-     *
-     * @return all registries
-     */
-    public static Collection<Registry> getRegistries() {
-        return Collections.unmodifiableCollection(REGISTRIES.values());
-    }
-
-    public static Registry getRegistry(String key) {
-        return REGISTRIES.get(key);
-    }
-
-    /**
-     * Close all created registries
-     */
-    public static void destroyAll() {
-        if (!destroyed.compareAndSet(false, true)) {
-            return;
-        }
-
-        if (LOGGER.isInfoEnabled()) {
-            LOGGER.info(""Close all registries "" + getRegistries());
-        }
-        // Lock up the registry shutdown process
-        LOCK.lock();
-        try {
-            for (Registry registry : getRegistries()) {
-                try {
-                    registry.destroy();
-                } catch (Throwable e) {
-                    LOGGER.error(e.getMessage(), e);
-                }
-            }
-            REGISTRIES.clear();
-        } finally {
-            // Release the lock
-            LOCK.unlock();
-        }
-    }
-
-    @Override
-    public Registry getRegistry(URL url) {
-        if (destroyed.get()) {
-            LOGGER.warn(""All registry instances have been destroyed, failed to fetch any instance. "" +
-                    ""Usually, this means no need to try to do unnecessary redundant resource clearance, all registries has been taken care of."");
-            return DEFAULT_NOP_REGISTRY;
-        }
-
-        url = URLBuilder.from(url)
-                .setPath(RegistryService.class.getName())
-                .addParameter(INTERFACE_KEY, RegistryService.class.getName())
-                .removeParameters(EXPORT_KEY, REFER_KEY)
-                .build();
-        String key = url.toServiceStringWithoutResolving();
-        // Lock the registry access process to ensure a single instance of the registry
-        LOCK.lock();
-        try {
-            Registry registry = REGISTRIES.get(key);
-            if (registry != null) {
-                return registry;
-            }
-            //create registry by spi/ioc
-            registry = createRegistry(url);
-            if (registry == null) {
-                throw new IllegalStateException(""Can not create registry "" + url);
-            }
-            REGISTRIES.put(key, registry);
-            return registry;
-        } finally {
-            // Release the lock
-            LOCK.unlock();
-        }
-    }
-
-    protected abstract Registry createRegistry(URL url);
-
-
-    private static Registry DEFAULT_NOP_REGISTRY = new Registry() {
-        @Override
-        public URL getUrl() {
-            return null;
-        }
-
-        @Override
-        public boolean isAvailable() {
-            return false;
-        }
-
-        @Override
-        public void destroy() {
-
-        }
-
-        @Override
-        public void register(URL url) {
-
-        }
-
-        @Override
-        public void unregister(URL url) {
-
-        }
-
-        @Override
-        public void subscribe(URL url, NotifyListener listener) {
-
-        }
-
-        @Override
-        public void unsubscribe(URL url, NotifyListener listener) {
-
-        }
-
-        @Override
-        public List<URL> lookup(URL url) {
-            return null;
-        }
-    };
-
-    // for unit test
-    public static void clearRegistryNotDestroy() {
-        REGISTRIES.clear();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.support;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.URLBuilder;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.registry.NotifyListener;
+import org.apache.dubbo.registry.Registry;
+import org.apache.dubbo.registry.RegistryFactory;
+import org.apache.dubbo.registry.RegistryService;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.ReentrantLock;
+
+import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;
+import static org.apache.dubbo.rpc.cluster.Constants.EXPORT_KEY;
+import static org.apache.dubbo.rpc.cluster.Constants.REFER_KEY;
+
+/**
+ * AbstractRegistryFactory. (SPI, Singleton, ThreadSafe)
+ *
+ * @see org.apache.dubbo.registry.RegistryFactory
+ */
+public abstract class AbstractRegistryFactory implements RegistryFactory {
+
+    // Log output
+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRegistryFactory.class);
+
+    // The lock for the acquisition process of the registry
+    private static final ReentrantLock LOCK = new ReentrantLock();
+
+    // Registry Collection Map<RegistryAddress, Registry>
+    private static final Map<String, Registry> REGISTRIES = new ConcurrentHashMap<>();
+
+    private static final AtomicBoolean destroyed = new AtomicBoolean(false);
+
+    /**
+     * Get all registries
+     *
+     * @return all registries
+     */
+    public static Collection<Registry> getRegistries() {
+        return Collections.unmodifiableCollection(REGISTRIES.values());
+    }
+
+    public static Registry getRegistry(String key) {
+        return REGISTRIES.get(key);
+    }
+
+    /**
+     * Close all created registries
+     */
+    public static void destroyAll() {
+        if (!destroyed.compareAndSet(false, true)) {
+            return;
+        }
+
+        if (LOGGER.isInfoEnabled()) {
+            LOGGER.info(""Close all registries "" + getRegistries());
+        }
+        // Lock up the registry shutdown process
+        LOCK.lock();
+        try {
+            for (Registry registry : getRegistries()) {
+                try {
+                    registry.destroy();
+                } catch (Throwable e) {
+                    LOGGER.error(e.getMessage(), e);
+                }
+            }
+            REGISTRIES.clear();
+        } finally {
+            // Release the lock
+            LOCK.unlock();
+        }
+    }
+
+    @Override
+    public Registry getRegistry(URL url) {
+        if (destroyed.get()) {
+            LOGGER.warn(""All registry instances have been destroyed, failed to fetch any instance. "" +
+                    ""Usually, this means no need to try to do unnecessary redundant resource clearance, all registries has been taken care of."");
+            return DEFAULT_NOP_REGISTRY;
+        }
+
+        url = URLBuilder.from(url)
+                .setPath(RegistryService.class.getName())
+                .addParameter(INTERFACE_KEY, RegistryService.class.getName())
+                .removeParameters(EXPORT_KEY, REFER_KEY)
+                .build();
+        String key = url.toServiceStringWithoutResolving();
+        Registry registry = REGISTRIES.get(key);
+        if (registry != null) {
+            return registry;
+        }
+        // Lock the registry access process to ensure a single instance of the registry
+        LOCK.lock();
+        try {
+            //create registry by spi/ioc
+            registry = createRegistry(url);
+            if (registry == null) {
+                throw new IllegalStateException(""Can not create registry "" + url);
+            }
+            REGISTRIES.put(key, registry);","[{'comment': 'Maybe using the `java.util.concurrent.ConcurrentHashMap#computeIfAbsent`  is the better choice ? \r\n', 'commenter': 'CodingSinger'}, {'comment': 'Agree. Could you please take a look? @zhaixiaoxiang ', 'commenter': 'chickenlj'}]"
5492,dubbo-common/src/main/java/org/apache/dubbo/common/URL.java,"@@ -304,31 +309,33 @@ public static URL valueOf(String url) {
 
     public static Map<String, Map<String, String>> toMethodParameters(Map<String, String> parameters) {","[{'comment': 'What is the purpose of changing this method?', 'commenter': 'zhaixiaoxiang'}, {'comment': 'The nesting level of this method is too deep.', 'commenter': 'LinShunKang'}]"
5492,dubbo-common/src/main/java/org/apache/dubbo/common/URL.java,"@@ -477,7 +484,7 @@ public int getPort(int defaultPort) {
     }
 
     public String getAddress() {
-        return port <= 0 ? host : host + "":"" + port;
+        return address;","[{'comment': 'Should we check if `address` is empty before return? Or compute address like before when address is empty?', 'commenter': 'chickenlj'}, {'comment': '`new URL(...)` is not the only way of allocating URL instance, if URL instance is allocated in other way, for example deserialization, the address property would be left empty.', 'commenter': 'chickenlj'}]"
5569,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,"@@ -396,12 +396,56 @@ private void optimizeSerialization(URL url) throws RpcException {
         optimizeSerialization(url);
 
         // create rpc invoker.
-        DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, getClients(url), invokers);
+        DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, getClientsV2(url), invokers);","[{'comment': 'After you refactored your code, your unit tests failed. Please fix these exceptions.\r\n\r\n[ERROR] DubboLazyConnectTest.testSticky1:53 Unexpected exception type thrown ==> expected: <org.apache.dubbo.rpc.RpcException> but was: <java.lang.IndexOutOfBoundsException>\r\n[ERROR] DubboLazyConnectTest.testSticky3:67 Unexpected exception type thrown ==> expected: <org.apache.dubbo.rpc.RpcException> but was: <java.lang.IndexOutOfBoundsException>\r\n[ERROR] ExplicitCallbackTest.TestCallbackConsumerLimit:176 Unexpected exception type thrown ==> expected: <org.apache.dubbo.rpc.RpcException> but was: <java.lang.IndexOutOfBoundsException>\r\n[ERROR] ExplicitCallbackTest.TestCallbackProviderLimit:203 Unexpected exception type thrown ==> expected: <org.apache.dubbo.rpc.RpcException> but was: <java.lang.IndexOutOfBoundsException>\r\n[ERROR] Errors:\r\n[ERROR] DubboInvokerAvilableTest.test_Lazy_ChannelReadOnly:131 » IndexOutOfBounds Inde...\r\n[ERROR] DubboInvokerAvilableTest.test_NoInvokers:118 » IndexOutOfBounds Index: 0, Size...\r\n[ERROR] DubboInvokerAvilableTest.test_Normal_ChannelReadOnly:78 » IndexOutOfBounds Ind...\r\n[ERROR] DubboInvokerAvilableTest.test_Normal_available:67 » IndexOutOfBounds Index: 0,...\r\n[ERROR] DubboLazyConnectTest.testSticky2:62 » IndexOutOfBounds Index: 0, Size: 0\r\n[ERROR] DubboLazyConnectTest.testSticky4:81 » IndexOutOfBounds Index: 0, Size: 0\r\n[ERROR] DubboProtocolTest.testDemoProtocol:62 » IndexOutOfBounds Index: 0, Size: 0\r\n[ERROR] DubboProtocolTest.testDubboProtocol:71 » IndexOutOfBounds Index: 0, Size: 0\r\n[ERROR] DubboProtocolTest.testDubboProtocolMultiService:148 » IndexOutOfBounds Index: ...\r\n[ERROR] DubboProtocolTest.testDubboProtocolWithMina:104 » IndexOutOfBounds Index: 0, S...\r\n[ERROR] DubboProtocolTest.testNonSerializedParameter:178 » IndexOutOfBounds Index: 0, ...\r\n[ERROR] DubboProtocolTest.testPerm:166 » IndexOutOfBounds Index: 0, Size: 0\r\n[ERROR] DubboProtocolTest.testRemoteApplicationName:208 » IndexOutOfBounds Index: 0, S...\r\n[ERROR] DubboProtocolTest.testReturnNonSerialized:192 » IndexOutOfBounds Index: 0, Siz...\r\n[ERROR] ExplicitCallbackTest.TestCallbackMultiInstans:128->initOrResetService:90->referService:65 » IndexOutOfBounds\r\n[ERROR] ExplicitCallbackTest.TestCallbackNormal:107->initOrResetService:90->referService:65 » IndexOutOfBounds\r\n[ERROR] MultiThreadTest.testDubboMultiThreadInvoke:51 » IndexOutOfBounds Index: 0, Siz...\r\n[ERROR] ReferenceCountExchangeClientTest.test_counter_error:156->init:223 » Arithmetic\r\n[ERROR] ReferenceCountExchangeClientTest.test_mult_share_connect:117->init:223 » Arithmetic\r\n[ERROR] ReferenceCountExchangeClientTest.test_multi_destory:139->init:223 » Arithmetic\r\n[ERROR] ReferenceCountExchangeClientTest.test_not_share_connect:103->init:221->referInvoker:72 » IndexOutOfBounds\r\n[ERROR] ReferenceCountExchangeClientTest.test_share_connect:92->init:223 » Arithmetic ...\r\n[ERROR] RpcFilterTest.testRpcFilter:48 » IndexOutOfBounds Index: 0, Size: 0\r\n\r\n@haiyang1985', 'commenter': 'EZKAYOTWJPRKXWCUYEEB'}, {'comment': 'Current PR is for discuss only, not my final version.', 'commenter': 'haiyang1985'}]"
5581,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java,"@@ -18,6 +18,7 @@
 
 import org.apache.dubbo.common.utils.Assert;
 import org.apache.dubbo.config.ReferenceConfigBase;
+import org.apache.dubbo.config.annotation.Service;","[{'comment': ""Please delete unused import, otherwise you can't pass ci check."", 'commenter': 'EZKAYOTWJPRKXWCUYEEB'}, {'comment': 'thanks, will do.', 'commenter': 'beiwei30'}]"
5581,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ServiceRepository.java,"@@ -84,33 +90,39 @@ public void registerConsumer(String serviceKey,
                                  ReferenceConfigBase<?> rc,
                                  Object proxy,
                                  ServiceMetadata serviceMetadata) {
-        consumers.computeIfAbsent(
-                serviceKey,
-                _k -> new ConsumerModel(
-                        serviceMetadata.getServiceKey(),
-                        proxy,
-                        serviceDescriptor,
-                        rc,
-                        serviceMetadata
-                )
-        );
+        ConsumerModel consumerModel = new ConsumerModel(serviceMetadata.getServiceKey(), proxy, serviceDescriptor, rc,
+                serviceMetadata);
+        consumers.putIfAbsent(serviceKey, consumerModel);
+    }
+
+    public void reRegisterConsumer(String newServiceKey, String serviceKey) {
+        ConsumerModel consumerModel = consumers.get(serviceKey);
+        consumerModel.setServiceKey(newServiceKey);
+        consumers.putIfAbsent(newServiceKey, consumerModel);
+        consumers.remove(serviceKey);
+
     }
 
     public void registerProvider(String serviceKey,
                                  Object serviceInstance,
                                  ServiceDescriptor serviceModel,
                                  ServiceConfigBase<?> serviceConfig,
                                  ServiceMetadata serviceMetadata) {
-        providers.computeIfAbsent(
-                serviceKey,
-                _k -> new ProviderModel(
-                        serviceKey,
-                        serviceInstance,
-                        serviceModel,
-                        serviceConfig,
-                        serviceMetadata
-                )
-        );
+        ProviderModel providerModel = new ProviderModel(serviceKey, serviceInstance, serviceModel, serviceConfig,
+                serviceMetadata);
+        providers.putIfAbsent(serviceKey, providerModel);
+        providersWithoutGroup.putIfAbsent(keyWithoutGroup(serviceKey), providerModel);
+    }
+
+    private static String keyWithoutGroup(String serviceKey) {
+        return interfaceFromServiceKey(serviceKey) + "":"" + versionFromServiceKey(serviceKey);
+    }
+
+    public void reRegisterProvider(String newServiceKey, String serviceKey) {","[{'comment': 'if newServiceKey equals serviceKey,then ProviderModel would be remove', 'commenter': 'qinliujie'}]"
5581,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java,"@@ -616,8 +641,14 @@ public URL getRegisteredConsumerUrl() {
         return registeredConsumerUrl;
     }
 
-    public void setRegisteredConsumerUrl(URL registeredConsumerUrl) {
-        this.registeredConsumerUrl = registeredConsumerUrl;
+    public void setRegisteredConsumerUrl(URL url) {
+        if (!shouldSimplified) {","[{'comment': 'is it should be `if (shouldSimplified) `', 'commenter': 'qinliujie'}]"
5622,dubbo-registry/dubbo-registry-redis/src/main/java/org/apache/dubbo/registry/redis/RedisRegistry.java,"@@ -83,13 +83,15 @@
 
     private final static String DEFAULT_ROOT = ""dubbo"";
 
+    private static final String REDIS_MASTER_NAME_KEY = ""masterName"";","[{'comment': ""please follow the convention and rename the key to 'master-name'"", 'commenter': 'chickenlj'}]"
5636,dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java,"@@ -266,6 +266,7 @@ private void convertProtocolIdsToProtocols() {
                         protocolConfig.setId(id);
                         protocolConfig.refresh();
                         tmpProtocols.add(protocolConfig);
+                        ApplicationModel.getConfigManager().addProtocol(protocolConfig);","[{'comment': '不能将所有的 ProtocolConfig 实例都放进 ConfigManager：\r\n1. 有些 ProtocolConfig 是全局共享的(默认 default=true)，所有 ServiceConfig 都使用\r\n2. 有些 ProtocolConfig 是某个 ServiceConfig 使用的，通过 id 引用，如果要放进 ConfigManager，还需要区分好 default 类型才好', 'commenter': 'chickenlj'}]"
5637,NOTICE,"@@ -1,5 +1,9 @@
 Apache Dubbo
+<<<<<<< HEAD
+Copyright 2018-2020 The Apache Software Foundation
+=======","[{'comment': 'pls fix merge confictions', 'commenter': 'AlbumenJ'}, {'comment': 'ok，i will do it', 'commenter': 'xiaoheng1'}, {'comment': 'I am already re-merging the dubbo/master branch in my own branch. Is there anything else I need to do here?', 'commenter': 'xiaoheng1'}]"
5649,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java,"@@ -1,301 +1,352 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.rpc.cluster.router.condition;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.CollectionUtils;
-import org.apache.dubbo.common.utils.NetUtils;
-import org.apache.dubbo.common.utils.StringUtils;
-import org.apache.dubbo.common.utils.UrlUtils;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.cluster.router.AbstractRouter;
-
-import java.text.ParseException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import static org.apache.dubbo.common.constants.CommonConstants.ENABLED_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.HOST_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.METHOD_KEY;
-import static org.apache.dubbo.rpc.cluster.Constants.ADDRESS_KEY;
-import static org.apache.dubbo.rpc.cluster.Constants.FORCE_KEY;
-import static org.apache.dubbo.rpc.cluster.Constants.PRIORITY_KEY;
-import static org.apache.dubbo.rpc.cluster.Constants.RULE_KEY;
-import static org.apache.dubbo.rpc.cluster.Constants.RUNTIME_KEY;
-
-/**
- * ConditionRouter
- *
- */
-public class ConditionRouter extends AbstractRouter {
-    public static final String NAME = ""condition"";
-
-    private static final Logger logger = LoggerFactory.getLogger(ConditionRouter.class);
-    protected static final Pattern ROUTE_PATTERN = Pattern.compile(""([&!=,]*)\\s*([^&!=,\\s]+)"");
-    protected Map<String, MatchPair> whenCondition;
-    protected Map<String, MatchPair> thenCondition;
-
-    private boolean enabled;
-
-    public ConditionRouter(String rule, boolean force, boolean enabled) {
-        this.force = force;
-        this.enabled = enabled;
-        this.init(rule);
-    }
-
-    public ConditionRouter(URL url) {
-        this.url = url;
-        this.priority = url.getParameter(PRIORITY_KEY, 0);
-        this.force = url.getParameter(FORCE_KEY, false);
-        this.enabled = url.getParameter(ENABLED_KEY, true);
-        init(url.getParameterAndDecoded(RULE_KEY));
-    }
-
-    public void init(String rule) {
-        try {
-            if (rule == null || rule.trim().length() == 0) {
-                throw new IllegalArgumentException(""Illegal route rule!"");
-            }
-            rule = rule.replace(""consumer."", """").replace(""provider."", """");
-            int i = rule.indexOf(""=>"");
-            String whenRule = i < 0 ? null : rule.substring(0, i).trim();
-            String thenRule = i < 0 ? rule.trim() : rule.substring(i + 2).trim();
-            Map<String, MatchPair> when = StringUtils.isBlank(whenRule) || ""true"".equals(whenRule) ? new HashMap<String, MatchPair>() : parseRule(whenRule);
-            Map<String, MatchPair> then = StringUtils.isBlank(thenRule) || ""false"".equals(thenRule) ? null : parseRule(thenRule);
-            // NOTE: It should be determined on the business level whether the `When condition` can be empty or not.
-            this.whenCondition = when;
-            this.thenCondition = then;
-        } catch (ParseException e) {
-            throw new IllegalStateException(e.getMessage(), e);
-        }
-    }
-
-    private static Map<String, MatchPair> parseRule(String rule)
-            throws ParseException {
-        Map<String, MatchPair> condition = new HashMap<String, MatchPair>();
-        if (StringUtils.isBlank(rule)) {
-            return condition;
-        }
-        // Key-Value pair, stores both match and mismatch conditions
-        MatchPair pair = null;
-        // Multiple values
-        Set<String> values = null;
-        final Matcher matcher = ROUTE_PATTERN.matcher(rule);
-        while (matcher.find()) { // Try to match one by one
-            String separator = matcher.group(1);
-            String content = matcher.group(2);
-            // Start part of the condition expression.
-            if (StringUtils.isEmpty(separator)) {
-                pair = new MatchPair();
-                condition.put(content, pair);
-            }
-            // The KV part of the condition expression
-            else if (""&"".equals(separator)) {
-                if (condition.get(content) == null) {
-                    pair = new MatchPair();
-                    condition.put(content, pair);
-                } else {
-                    pair = condition.get(content);
-                }
-            }
-            // The Value in the KV part.
-            else if (""="".equals(separator)) {
-                if (pair == null) {
-                    throw new ParseException(""Illegal route rule \""""
-                            + rule + ""\"", The error char '"" + separator
-                            + ""' at index "" + matcher.start() + "" before \""""
-                            + content + ""\""."", matcher.start());
-                }
-
-                values = pair.matches;
-                values.add(content);
-            }
-            // The Value in the KV part.
-            else if (""!="".equals(separator)) {
-                if (pair == null) {
-                    throw new ParseException(""Illegal route rule \""""
-                            + rule + ""\"", The error char '"" + separator
-                            + ""' at index "" + matcher.start() + "" before \""""
-                            + content + ""\""."", matcher.start());
-                }
-
-                values = pair.mismatches;
-                values.add(content);
-            }
-            // The Value in the KV part, if Value have more than one items.
-            else if ("","".equals(separator)) { // Should be separated by ','
-                if (values == null || values.isEmpty()) {
-                    throw new ParseException(""Illegal route rule \""""
-                            + rule + ""\"", The error char '"" + separator
-                            + ""' at index "" + matcher.start() + "" before \""""
-                            + content + ""\""."", matcher.start());
-                }
-                values.add(content);
-            } else {
-                throw new ParseException(""Illegal route rule \"""" + rule
-                        + ""\"", The error char '"" + separator + ""' at index ""
-                        + matcher.start() + "" before \"""" + content + ""\""."", matcher.start());
-            }
-        }
-        return condition;
-    }
-
-    @Override
-    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)
-            throws RpcException {
-        if (!enabled) {
-            return invokers;
-        }
-
-        if (CollectionUtils.isEmpty(invokers)) {
-            return invokers;
-        }
-        try {
-            if (!matchWhen(url, invocation)) {
-                return invokers;
-            }
-            List<Invoker<T>> result = new ArrayList<Invoker<T>>();
-            if (thenCondition == null) {
-                logger.warn(""The current consumer in the service blacklist. consumer: "" + NetUtils.getLocalHost() + "", service: "" + url.getServiceKey());
-                return result;
-            }
-            for (Invoker<T> invoker : invokers) {
-                if (matchThen(invoker.getUrl(), url)) {
-                    result.add(invoker);
-                }
-            }
-            if (!result.isEmpty()) {
-                return result;
-            } else if (force) {
-                logger.warn(""The route result is empty and force execute. consumer: "" + NetUtils.getLocalHost() + "", service: "" + url.getServiceKey() + "", router: "" + url.getParameterAndDecoded(RULE_KEY));
-                return result;
-            }
-        } catch (Throwable t) {
-            logger.error(""Failed to execute condition router rule: "" + getUrl() + "", invokers: "" + invokers + "", cause: "" + t.getMessage(), t);
-        }
-        return invokers;
-    }
-
-    @Override
-    public boolean isRuntime() {
-        // We always return true for previously defined Router, that is, old Router doesn't support cache anymore.
-//        return true;
-        return this.url.getParameter(RUNTIME_KEY, false);
-    }
-
-    @Override
-    public URL getUrl() {
-        return url;
-    }
-
-    boolean matchWhen(URL url, Invocation invocation) {
-        return CollectionUtils.isEmptyMap(whenCondition) || matchCondition(whenCondition, url, null, invocation);
-    }
-
-    private boolean matchThen(URL url, URL param) {
-        return CollectionUtils.isNotEmptyMap(thenCondition) && matchCondition(thenCondition, url, param, null);
-    }
-
-    private boolean matchCondition(Map<String, MatchPair> condition, URL url, URL param, Invocation invocation) {
-        Map<String, String> sample = url.toMap();
-        boolean result = false;
-        for (Map.Entry<String, MatchPair> matchPair : condition.entrySet()) {
-            String key = matchPair.getKey();
-            String sampleValue;
-            //get real invoked method name from invocation
-            if (invocation != null && (METHOD_KEY.equals(key) || METHODS_KEY.equals(key))) {
-                sampleValue = invocation.getMethodName();
-            } else if (ADDRESS_KEY.equals(key)) {
-                sampleValue = url.getAddress();
-            } else if (HOST_KEY.equals(key)) {
-                sampleValue = url.getHost();
-            } else {
-                sampleValue = sample.get(key);
-                if (sampleValue == null) {
-                    sampleValue = sample.get(key);
-                }
-            }
-            if (sampleValue != null) {
-                if (!matchPair.getValue().isMatch(sampleValue, param)) {
-                    return false;
-                } else {
-                    result = true;
-                }
-            } else {
-                //not pass the condition
-                if (!matchPair.getValue().matches.isEmpty()) {
-                    return false;
-                } else {
-                    result = true;
-                }
-            }
-        }
-        return result;
-    }
-
-    protected static final class MatchPair {
-        final Set<String> matches = new HashSet<String>();
-        final Set<String> mismatches = new HashSet<String>();
-
-        private boolean isMatch(String value, URL param) {
-            if (!matches.isEmpty() && mismatches.isEmpty()) {
-                for (String match : matches) {
-                    if (UrlUtils.isMatchGlobPattern(match, value, param)) {
-                        return true;
-                    }
-                }
-                return false;
-            }
-
-            if (!mismatches.isEmpty() && matches.isEmpty()) {
-                for (String mismatch : mismatches) {
-                    if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {
-                        return false;
-                    }
-                }
-                return true;
-            }
-
-            if (!matches.isEmpty() && !mismatches.isEmpty()) {
-                //when both mismatches and matches contain the same value, then using mismatches first
-                for (String mismatch : mismatches) {
-                    if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {
-                        return false;
-                    }
-                }
-                for (String match : matches) {
-                    if (UrlUtils.isMatchGlobPattern(match, value, param)) {
-                        return true;
-                    }
-                }
-                return false;
-            }
-            return false;
-        }
-    }
-}
+/*","[{'comment': 'pls recover end-line format of this file', 'commenter': 'AlbumenJ'}, {'comment': 'I have fix it in https://github.com/apache/dubbo/pull/7378, please refer to the new PR.', 'commenter': 'furaul'}]"
5657,dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/interceptor/AbstractClusterInterceptor.java,"@@ -0,0 +1,17 @@
+package com.alibaba.dubbo.rpc.cluster.interceptor;","[{'comment': 'Please add a license to the top of all new files.', 'commenter': 'EZKAYOTWJPRKXWCUYEEB'}, {'comment': '怎么个提交法? 撤回这个PR,重新提交?', 'commenter': 'brucelwl'}, {'comment': '> 怎么个提交法? 撤回这个PR,重新提交?\r\n\r\n继续在您的分支 (brucelwl:2.6.x) 中添加上license，push至该分支即可。', 'commenter': 'EZKAYOTWJPRKXWCUYEEB'}, {'comment': '> Please add a license to the top of all new files.\r\n\r\n已经添加', 'commenter': 'brucelwl'}, {'comment': '@lzf971107 测试不通过是什么情况, 好像原先就是不通过的?', 'commenter': 'brucelwl'}, {'comment': '> @lzf971107 测试不通过是什么情况, 好像原先就是不通过的?\r\n\r\n单元测试未通过，上一次是因为您没有添加license。\r\nAbstractClusterInvokerTest.testSelect_Invokersize2AndselectNotNull:191 » NullPointer', 'commenter': 'EZKAYOTWJPRKXWCUYEEB'}, {'comment': '> > @lzf971107 测试不通过是什么情况, 好像原先就是不通过的?\r\n> \r\n> 单元测试未通过，上一次是因为您没有添加license。\r\n> AbstractClusterInvokerTest.testSelect_Invokersize2AndselectNotNull:191 » NullPointer\r\n\r\n现在添加了,还是没有通过啊 ', 'commenter': 'brucelwl'}, {'comment': '> > > @lzf971107 测试不通过是什么情况, 好像原先就是不通过的?\r\n> > \r\n> > \r\n> > 单元测试未通过，上一次是因为您没有添加license。\r\n> > AbstractClusterInvokerTest.testSelect_Invokersize2AndselectNotNull:191 » NullPointer\r\n> \r\n> 现在添加了,还是没有通过啊\r\n\r\n这次是代码问题\r\n具体单元测试类为：AbstractClusterInvokerTest.testSelect_Invokersize2AndselectNotNull:191 » NullPointer', 'commenter': 'EZKAYOTWJPRKXWCUYEEB'}, {'comment': '> 这次是代码问题\r\n> 具体单元测试类为：AbstractClusterInvokerTest.testSelect_Invokersize2AndselectNotNull:191 » NullPointer\r\n我看了下这个代码,传值是null,所以报错,但是代码原先的单元测试就是这么写的,我没有做过改动\r\n', 'commenter': 'brucelwl'}]"
5657,dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/AbstractClusterInvoker.java,"@@ -134,29 +148,30 @@ public void destroy() {
         return invoker;
     }
 
-    private Invoker<T> doSelect(LoadBalance loadbalance, Invocation invocation, List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {
-        if (invokers == null || invokers.isEmpty())
+    private Invoker<T> doSelect(LoadBalance loadbalance, Invocation invocation,
+                                List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {
+
+        if (CollectionUtils.isEmpty(invokers)) {
             return null;
-        if (invokers.size() == 1)
+        }
+        if (invokers.size() == 1) {
             return invokers.get(0);
-        if (loadbalance == null) {
-            loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(Constants.DEFAULT_LOADBALANCE);","[{'comment': 'Why delete here.', 'commenter': 'EZKAYOTWJPRKXWCUYEEB'}, {'comment': '> Why delete here.\r\n\r\n已经修改单元测试,这个地方传入的loadbalance不会为null的', 'commenter': 'brucelwl'}, {'comment': '> > Why delete here.\r\n> \r\n> 已经修改单元测试,这个地方传入的loadbalance不会为null的\r\n\r\n代码问题不应该由单元测试承担错误，如果扩展该类的开发者不进行空指针检查loadbalance将为空，进而造成空指针异常，具体详情可以查看此pr中信息 https://github.com/apache/dubbo/pull/1376#discussion_r170158998', 'commenter': 'EZKAYOTWJPRKXWCUYEEB'}, {'comment': '这个代码在dubbo2.7.5中就是没有这个if检查的,\r\n ```\r\nif (loadbalance == null) {\r\n            loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(Constants.DEFAULT_LOADBALANCE);\r\n```\r\n单元测试是不应该承担错误,但是也要根据情况,不一定所有的方法中都要给方法参数设置默认值. 在方法调用前就应该做判断. 扩展该类的开发者本身就应该进行空指针检查.\r\n', 'commenter': 'brucelwl'}, {'comment': '我已经把默认LoadBalance添加上', 'commenter': 'brucelwl'}, {'comment': '没关系社区需要讨论，也或许你是对的。 @chickenlj need-triage', 'commenter': 'EZKAYOTWJPRKXWCUYEEB'}, {'comment': '> 没关系社区需要讨论，也或许你是对的。 @chickenlj need-triage\r\n\r\n奇怪,现在还是检查不通过,郁闷中....', 'commenter': 'brucelwl'}, {'comment': '> > 没关系社区需要讨论，也或许你是对的。 @chickenlj need-triage\r\n> \r\n> 奇怪,现在还是检查不通过,郁闷中....\r\n\r\n单元测试异常: RegistryDirectoryTest.test_Constructor_CheckStatus:116 expected:<notsupported://10.20.30.40/com.alibaba.dubbo.registry.dubbo.RegistryDirectoryTest$DemoService?foo=bar> but was:<notsupported://10.20.30.40/com.alibaba.dubbo.registry.dubbo.RegistryDirectoryTest$DemoService?foo=bar&registry.a=b>', 'commenter': 'EZKAYOTWJPRKXWCUYEEB'}, {'comment': '@lzf971107 钉钉号多少,讨论下,这个地方我知道原因了, 参考这个issue https://github.com/apache/dubbo/issues/5654#issuecomment-574540023 我使用的方案二,导致原来的单元测试失败', 'commenter': 'brucelwl'}, {'comment': '> @lzf971107 钉钉号多少,讨论下,这个地方我知道原因了, 参考这个issue [#5654 (comment)](https://github.com/apache/dubbo/issues/5654#issuecomment-574540023) 我使用的方案二,导致原来的单元测试失败\r\n\r\n我对这块不是太熟，可能没法跟您讨论。', 'commenter': 'EZKAYOTWJPRKXWCUYEEB'}, {'comment': '@lzf971107  现在java7版本的验证通过了, Java8的还没有通过,能帮忙看下哪里出了问题么?', 'commenter': 'brucelwl'}]"
5657,dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java,"@@ -37,6 +37,7 @@
 import com.alibaba.dubbo.rpc.cluster.directory.StaticDirectory;
 import com.alibaba.dubbo.rpc.cluster.support.AvailableCluster;","[{'comment': 'You have to delete these unused imports.', 'commenter': 'EZKAYOTWJPRKXWCUYEEB'}, {'comment': '已经完成检查', 'commenter': 'brucelwl'}]"
5661,dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java,"@@ -747,14 +749,15 @@ private void cacheDefaultExtensionName() {
 
         String value = defaultAnnotation.value();
         if ((value = value.trim()).length() > 0) {
-            String[] names = NAME_SEPARATOR.split(value);
+            cachedDefaultName = value;
+           /* String[] names = NAME_SEPARATOR.split(value);
             if (names.length > 1) {
                 throw new IllegalStateException(""More than 1 default extension name on extension "" + type.getName()
                         + "": "" + Arrays.toString(names));
             }
             if (names.length == 1) {
                 cachedDefaultName = names[0];
-            }
+            }*/","[{'comment': 'Why comment this snippet?', 'commenter': 'chickenlj'}, {'comment': 'If there are multiple type names separated by commas, an error will be directly reported below, that is, multiple types cannot be displayed, so why do we need to use separators? Think of it as a type name', 'commenter': 'Unknown'}]"
5661,dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java,"@@ -727,10 +727,12 @@ private boolean isSetter(Method method) {
         cacheDefaultExtensionName();
 
         Map<String, Class<?>> extensionClasses = new HashMap<>();
-
+        String typeName = type.getName();
         for (LoadingStrategy strategy : strategies) {
-            loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(), strategy.excludedPackages());
-            loadDirectory(extensionClasses, strategy.directory(), type.getName().replace(""org.apache"", ""com.alibaba""), strategy.preferExtensionClassLoader(), strategy.excludedPackages());","[{'comment': 'If someone uses a lower version, org.apache will not be matched, and it is useless logic to perform the replacement.', 'commenter': 'Unknown'}, {'comment': 'In current, `org.apache` will be matched always, would this be roundabout?', 'commenter': 'AlbumenJ'}]"
5880,dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java,"@@ -0,0 +1,348 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;
+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;
+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;
+
+public final class URLStrParser {
+
+    private static final char SPACE = 0x20;
+
+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));
+
+    private URLStrParser() {
+        //empty
+    }
+
+    /**
+     * @param decodedURLStr : after {@link URL#decode} string
+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2
+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]
+     */
+    public static URL parseDecodedStr(String decodedURLStr) {
+        Map<String, String> parameters = null;
+        int pathEndIdx = decodedURLStr.indexOf('?');
+        if (pathEndIdx >= 0) {
+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);
+        } else {
+            pathEndIdx = decodedURLStr.length();
+        }
+
+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);
+        return parseURLBody(decodedURLStr, decodedBody, parameters);
+    }
+
+    private static Map<String, String> parseDecodedParams(String str, int from) {
+        int len = str.length();
+        if (from >= len) {
+            return Collections.emptyMap();
+        }
+
+        TempBuf tempBuf = DECODE_TEMP_BUF.get();
+        Map<String, String> params = new HashMap<>();
+        int nameStart = from;
+        int valueStart = -1;
+        int i;
+        for (i = from; i < len; i++) {
+            char ch = str.charAt(i);
+            switch (ch) {
+                case '=':
+                    if (nameStart == i) {
+                        nameStart = i + 1;
+                    } else if (valueStart < nameStart) {
+                        valueStart = i + 1;
+                    }
+                    break;
+                case ';':
+                case '&':
+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);
+                    nameStart = i + 1;
+                    break;
+                default:
+                    // continue
+            }
+        }
+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);
+        return params;
+    }
+
+    /**
+     * @param fullURLStr  : fullURLString
+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]
+     * @param parameters  :
+     * @return URL
+     */
+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {
+        int starIdx = 0, endIdx = decodedBody.length();
+        String protocol = null;
+        int protoEndIdx = decodedBody.indexOf(""://"");","[{'comment': 'Line 98 - 115\r\n这里先用 idx = indexOf("":/"")\r\n然后判断 idx + 1 的字符是否为 \'/\' 可以在 file:/path 的情况下减少一次 indexOf', 'commenter': 'guohao'}, {'comment': '逻辑上是可行的，但是会牺牲一定的可读性', 'commenter': 'LinShunKang'}]"
5880,dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java,"@@ -0,0 +1,348 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;
+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;
+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;
+
+public final class URLStrParser {
+
+    private static final char SPACE = 0x20;
+
+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));
+
+    private URLStrParser() {
+        //empty
+    }
+
+    /**
+     * @param decodedURLStr : after {@link URL#decode} string
+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2
+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]
+     */
+    public static URL parseDecodedStr(String decodedURLStr) {
+        Map<String, String> parameters = null;
+        int pathEndIdx = decodedURLStr.indexOf('?');
+        if (pathEndIdx >= 0) {
+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);
+        } else {
+            pathEndIdx = decodedURLStr.length();
+        }
+
+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);
+        return parseURLBody(decodedURLStr, decodedBody, parameters);
+    }
+
+    private static Map<String, String> parseDecodedParams(String str, int from) {
+        int len = str.length();
+        if (from >= len) {
+            return Collections.emptyMap();
+        }
+
+        TempBuf tempBuf = DECODE_TEMP_BUF.get();
+        Map<String, String> params = new HashMap<>();
+        int nameStart = from;
+        int valueStart = -1;
+        int i;
+        for (i = from; i < len; i++) {
+            char ch = str.charAt(i);
+            switch (ch) {
+                case '=':
+                    if (nameStart == i) {
+                        nameStart = i + 1;
+                    } else if (valueStart < nameStart) {
+                        valueStart = i + 1;
+                    }
+                    break;
+                case ';':
+                case '&':
+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);
+                    nameStart = i + 1;
+                    break;
+                default:
+                    // continue
+            }
+        }
+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);
+        return params;
+    }
+
+    /**
+     * @param fullURLStr  : fullURLString
+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]
+     * @param parameters  :
+     * @return URL
+     */
+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {
+        int starIdx = 0, endIdx = decodedBody.length();
+        String protocol = null;
+        int protoEndIdx = decodedBody.indexOf(""://"");
+        if (protoEndIdx >= 0) {
+            if (protoEndIdx == 0) {
+                throw new IllegalStateException(""url missing protocol: \"""" + fullURLStr + ""\"""");
+            }
+            protocol = decodedBody.substring(0, protoEndIdx);
+            starIdx = protoEndIdx + 3;
+        } else {
+            // case: file:/path/to/file.txt
+            protoEndIdx = decodedBody.indexOf("":/"");
+            if (protoEndIdx >= 0) {
+                if (protoEndIdx == 0) {
+                    throw new IllegalStateException(""url missing protocol: \"""" + fullURLStr + ""\"""");
+                }
+                protocol = decodedBody.substring(0, protoEndIdx);
+                starIdx = protoEndIdx + 1;
+            }
+        }
+
+        String path = null;
+        int pathStartIdx = indexOf(decodedBody, '/', starIdx, endIdx);","[{'comment': ""这里是否可以直接用decodedBoyd.indexOf('/',startIdx) "", 'commenter': 'guohao'}, {'comment': '是的，可以，之所以这么写是为了保持上下文逻辑的一致性，统一使用 indexof(String, char, int, int)', 'commenter': 'LinShunKang'}]"
5880,dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java,"@@ -0,0 +1,348 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;
+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;
+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;
+
+public final class URLStrParser {
+
+    private static final char SPACE = 0x20;
+
+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));
+
+    private URLStrParser() {
+        //empty
+    }
+
+    /**
+     * @param decodedURLStr : after {@link URL#decode} string
+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2
+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]
+     */
+    public static URL parseDecodedStr(String decodedURLStr) {
+        Map<String, String> parameters = null;
+        int pathEndIdx = decodedURLStr.indexOf('?');
+        if (pathEndIdx >= 0) {
+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);
+        } else {
+            pathEndIdx = decodedURLStr.length();
+        }
+
+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);
+        return parseURLBody(decodedURLStr, decodedBody, parameters);
+    }
+
+    private static Map<String, String> parseDecodedParams(String str, int from) {
+        int len = str.length();
+        if (from >= len) {
+            return Collections.emptyMap();
+        }
+
+        TempBuf tempBuf = DECODE_TEMP_BUF.get();
+        Map<String, String> params = new HashMap<>();
+        int nameStart = from;
+        int valueStart = -1;
+        int i;
+        for (i = from; i < len; i++) {
+            char ch = str.charAt(i);
+            switch (ch) {
+                case '=':
+                    if (nameStart == i) {
+                        nameStart = i + 1;
+                    } else if (valueStart < nameStart) {
+                        valueStart = i + 1;
+                    }
+                    break;
+                case ';':
+                case '&':
+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);
+                    nameStart = i + 1;
+                    break;
+                default:
+                    // continue
+            }
+        }
+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);
+        return params;
+    }
+
+    /**
+     * @param fullURLStr  : fullURLString
+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]
+     * @param parameters  :
+     * @return URL
+     */
+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {
+        int starIdx = 0, endIdx = decodedBody.length();
+        String protocol = null;
+        int protoEndIdx = decodedBody.indexOf(""://"");
+        if (protoEndIdx >= 0) {
+            if (protoEndIdx == 0) {
+                throw new IllegalStateException(""url missing protocol: \"""" + fullURLStr + ""\"""");
+            }
+            protocol = decodedBody.substring(0, protoEndIdx);","[{'comment': 'protocol 这种基本不变或类型可枚举的属性值，可以考虑使用缓存，减少 substring 生成新对象数量', 'commenter': 'guohao'}, {'comment': '可以使用缓存，但是需要多维护一个类似于 Trie 的代码，这就需要考虑代价与收益了', 'commenter': 'LinShunKang'}, {'comment': '其实，相较于 protocol，paramsMap 里的 key 才是更需要优化的', 'commenter': 'LinShunKang'}, {'comment': '> 其实，相较于 protocol，paramsMap 里的 key 才是更需要优化的\r\n\r\n这个问题也可以通过缓存的方式解决。\r\nparamsMap 的 key 和 value 可以分成两种：可枚举和不可枚举。\r\n可枚举的 kv  可以使用预先生成的静态表 + 索引存储，比如bool 值，静态表包含 {0,1}，它的值也只需要一个 byte \r\n不可枚举的 kv 可以用动态表 + 索引的方式，动态表是一个全局 array ，包含所有可能值和对应索引，URL 中只存储索引值。这种方式可最大程度减少 URL 的驻留内存。\r\n\r\n在服务注册发现场景，多次推送的 URL 大部分都是相同的，可以引入 URL string -> URL 对象的缓存。在这个前提下，URL string-> URL 对象的转换大部分都可以走缓存，不需要重新解析。重新解析时，从实现上看，可以使用 char[] 字典树 / 生成临时 String 两种方式，一般来说，这里生成的临时 String 数量是有限的，不会成为内存瓶颈。可以考虑下。\r\n', 'commenter': 'guohao'}, {'comment': '在我看来，只需要维护一个 Trie 即可，Trie 里存放所有解析过的 Key 和  Value 即可，毕竟在 Dubbo 的场景里所有的 Key 和 Value 是有限的和固定的；这样所有 URL 对象的 `URL#parameters` 和 `URL#methodParameters` 里的 Key 和 Value 都是指向 Trie 里的字符串', 'commenter': 'LinShunKang'}]"
5880,dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java,"@@ -0,0 +1,348 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;
+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;
+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;
+
+public final class URLStrParser {
+
+    private static final char SPACE = 0x20;
+
+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));
+
+    private URLStrParser() {
+        //empty
+    }
+
+    /**
+     * @param decodedURLStr : after {@link URL#decode} string
+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2
+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]
+     */
+    public static URL parseDecodedStr(String decodedURLStr) {
+        Map<String, String> parameters = null;
+        int pathEndIdx = decodedURLStr.indexOf('?');
+        if (pathEndIdx >= 0) {
+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);
+        } else {
+            pathEndIdx = decodedURLStr.length();
+        }
+
+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);
+        return parseURLBody(decodedURLStr, decodedBody, parameters);
+    }
+
+    private static Map<String, String> parseDecodedParams(String str, int from) {
+        int len = str.length();
+        if (from >= len) {
+            return Collections.emptyMap();
+        }
+
+        TempBuf tempBuf = DECODE_TEMP_BUF.get();
+        Map<String, String> params = new HashMap<>();
+        int nameStart = from;
+        int valueStart = -1;
+        int i;
+        for (i = from; i < len; i++) {
+            char ch = str.charAt(i);
+            switch (ch) {
+                case '=':
+                    if (nameStart == i) {
+                        nameStart = i + 1;
+                    } else if (valueStart < nameStart) {
+                        valueStart = i + 1;
+                    }
+                    break;
+                case ';':
+                case '&':
+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);
+                    nameStart = i + 1;
+                    break;
+                default:
+                    // continue
+            }
+        }
+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);
+        return params;
+    }
+
+    /**
+     * @param fullURLStr  : fullURLString
+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]
+     * @param parameters  :
+     * @return URL
+     */
+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {
+        int starIdx = 0, endIdx = decodedBody.length();
+        String protocol = null;
+        int protoEndIdx = decodedBody.indexOf(""://"");
+        if (protoEndIdx >= 0) {
+            if (protoEndIdx == 0) {
+                throw new IllegalStateException(""url missing protocol: \"""" + fullURLStr + ""\"""");
+            }
+            protocol = decodedBody.substring(0, protoEndIdx);
+            starIdx = protoEndIdx + 3;
+        } else {
+            // case: file:/path/to/file.txt
+            protoEndIdx = decodedBody.indexOf("":/"");
+            if (protoEndIdx >= 0) {
+                if (protoEndIdx == 0) {
+                    throw new IllegalStateException(""url missing protocol: \"""" + fullURLStr + ""\"""");
+                }
+                protocol = decodedBody.substring(0, protoEndIdx);
+                starIdx = protoEndIdx + 1;
+            }
+        }
+
+        String path = null;
+        int pathStartIdx = indexOf(decodedBody, '/', starIdx, endIdx);
+        if (pathStartIdx >= 0) {
+            path = decodedBody.substring(pathStartIdx + 1);
+            endIdx = pathStartIdx;
+        }
+
+        String username = null;
+        String password = null;
+        int pwdEndIdx = lastIndexOf(decodedBody, '@', starIdx, endIdx);
+        if (pwdEndIdx > 0) {
+            int userNameEndIdx = indexOf(decodedBody, ':', starIdx, pwdEndIdx);
+            username = decodedBody.substring(starIdx, userNameEndIdx);
+            password = decodedBody.substring(userNameEndIdx + 1, pwdEndIdx);
+            starIdx = pwdEndIdx + 1;
+        }
+
+        String host = null;
+        int port = 0;
+        int hostEndIdx = lastIndexOf(decodedBody, ':', starIdx, endIdx);
+        if (hostEndIdx > 0 && hostEndIdx < decodedBody.length() - 1) {
+            if (lastIndexOf(decodedBody, '%', starIdx, endIdx) > hostEndIdx) {","[{'comment': '按照 [ipv6地址%zoneId]:port 的格式\r\n这个分支应该不会走到吧', 'commenter': 'guohao'}]"
5880,dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java,"@@ -0,0 +1,348 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;
+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;
+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;
+
+public final class URLStrParser {
+
+    private static final char SPACE = 0x20;
+
+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));
+
+    private URLStrParser() {
+        //empty
+    }
+
+    /**
+     * @param decodedURLStr : after {@link URL#decode} string
+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2
+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]
+     */
+    public static URL parseDecodedStr(String decodedURLStr) {
+        Map<String, String> parameters = null;
+        int pathEndIdx = decodedURLStr.indexOf('?');
+        if (pathEndIdx >= 0) {
+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);
+        } else {
+            pathEndIdx = decodedURLStr.length();
+        }
+
+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);
+        return parseURLBody(decodedURLStr, decodedBody, parameters);
+    }
+
+    private static Map<String, String> parseDecodedParams(String str, int from) {
+        int len = str.length();
+        if (from >= len) {
+            return Collections.emptyMap();
+        }
+
+        TempBuf tempBuf = DECODE_TEMP_BUF.get();
+        Map<String, String> params = new HashMap<>();
+        int nameStart = from;
+        int valueStart = -1;
+        int i;
+        for (i = from; i < len; i++) {
+            char ch = str.charAt(i);
+            switch (ch) {
+                case '=':
+                    if (nameStart == i) {
+                        nameStart = i + 1;
+                    } else if (valueStart < nameStart) {
+                        valueStart = i + 1;
+                    }
+                    break;
+                case ';':
+                case '&':
+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);
+                    nameStart = i + 1;
+                    break;
+                default:
+                    // continue
+            }
+        }
+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);
+        return params;
+    }
+
+    /**
+     * @param fullURLStr  : fullURLString
+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]
+     * @param parameters  :
+     * @return URL
+     */
+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {
+        int starIdx = 0, endIdx = decodedBody.length();
+        String protocol = null;
+        int protoEndIdx = decodedBody.indexOf(""://"");
+        if (protoEndIdx >= 0) {
+            if (protoEndIdx == 0) {
+                throw new IllegalStateException(""url missing protocol: \"""" + fullURLStr + ""\"""");
+            }
+            protocol = decodedBody.substring(0, protoEndIdx);
+            starIdx = protoEndIdx + 3;
+        } else {
+            // case: file:/path/to/file.txt
+            protoEndIdx = decodedBody.indexOf("":/"");
+            if (protoEndIdx >= 0) {
+                if (protoEndIdx == 0) {
+                    throw new IllegalStateException(""url missing protocol: \"""" + fullURLStr + ""\"""");
+                }
+                protocol = decodedBody.substring(0, protoEndIdx);
+                starIdx = protoEndIdx + 1;
+            }
+        }
+
+        String path = null;
+        int pathStartIdx = indexOf(decodedBody, '/', starIdx, endIdx);
+        if (pathStartIdx >= 0) {
+            path = decodedBody.substring(pathStartIdx + 1);
+            endIdx = pathStartIdx;
+        }
+
+        String username = null;
+        String password = null;
+        int pwdEndIdx = lastIndexOf(decodedBody, '@', starIdx, endIdx);
+        if (pwdEndIdx > 0) {
+            int userNameEndIdx = indexOf(decodedBody, ':', starIdx, pwdEndIdx);
+            username = decodedBody.substring(starIdx, userNameEndIdx);
+            password = decodedBody.substring(userNameEndIdx + 1, pwdEndIdx);
+            starIdx = pwdEndIdx + 1;
+        }
+
+        String host = null;
+        int port = 0;
+        int hostEndIdx = lastIndexOf(decodedBody, ':', starIdx, endIdx);
+        if (hostEndIdx > 0 && hostEndIdx < decodedBody.length() - 1) {
+            if (lastIndexOf(decodedBody, '%', starIdx, endIdx) > hostEndIdx) {
+                // ipv6 address with scope id
+                // e.g. fe80:0:0:0:894:aeec:f37d:23e1%en0
+                // see https://howdoesinternetwork.com/2013/ipv6-zone-id
+                // ignore
+            } else {
+                port = Integer.parseInt(decodedBody.substring(hostEndIdx + 1, endIdx));
+                endIdx = hostEndIdx;
+            }
+        }
+
+        if (endIdx > starIdx) {
+            host = decodedBody.substring(starIdx, endIdx);","[{'comment': '看了下 org.apache.dubbo.common.utils.NetUtils#normalizeV6Address ，获取地址注册的时候也没加 [ ] 。\r\n如果注册时默认约定 ipv6 都不加 [] ，当前这种模式是没问题的。\r\n\r\n但是按照 https://tools.ietf.org/html/rfc3986#section-3.2.2 ，ipv6 的 host 是要加 [] 的。\r\n如果加了[] ，connect 的时候需要把 [] 去掉。\r\n可以单独开个 issue 讨论下这个问题\r\n', 'commenter': 'guohao'}, {'comment': 'I agree we can discuss if we should take ` [] ` later', 'commenter': 'chickenlj'}]"
5880,dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java,"@@ -88,6 +91,33 @@
 
     public static final String HYPHEN = valueOf(HYPHEN_CHAR);
 
+    static {
+        HEX2B = new byte[Character.MAX_VALUE + 1];","[{'comment': '128 就够了，用不到 65536', 'commenter': 'guohao'}, {'comment': 'char 的范围是 [0, 65535]\r\n* 如果 HEX2B 大小为 128，那么在 StringUtils#decodeHexNibble(char) 方法中就需要判断入参的大小是否在  128  之内，如果在 128 以内则返回 HEX2B[c]，如果不在 128 以内则返回默认值 -1\r\n* 如果 HEX2B 大小为 65536，那么在 StringUtils#decodeHexNibble(char) 方法中就可以直接返回 HEX2B[c]\r\n\r\n这个就需要取舍了。', 'commenter': 'LinShunKang'}, {'comment': '从用法上看 input char 如果 > 128 ，decodeHexNibble 返回 -1 后会抛 IllegalArgumentException，也属于异常场景，实际应用情况应该很少发生。\r\n加一个 if/else 大部分情况可以走分支预测优化掉。', 'commenter': 'guohao'}]"
5880,dubbo-common/src/main/java/org/apache/dubbo/common/utils/Utf8Utils.java,"@@ -0,0 +1,245 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+package org.apache.dubbo.common.utils;
+
+import static java.lang.Character.MIN_HIGH_SURROGATE;
+import static java.lang.Character.MIN_LOW_SURROGATE;
+import static java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT;
+
+/**
+ * See original <a href=
+ * ""https://github.com/protocolbuffers/protobuf/blob/master/java/core/src/main/java/com/google/protobuf/Utf8.java""
+ * >Utf8.java</a>
+ */
+public final class Utf8Utils {","[{'comment': 'Please keep the original License header as it is.', 'commenter': 'chickenlj'}]"
5902,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -169,12 +170,33 @@ private void doSubscribe(final URL url, final NotifyListener listener, final Set
         execute(namingService -> {
             for (String serviceName : serviceNames) {
                 List<Instance> instances = namingService.getAllInstances(serviceName);
+
+                //TO FIX bug with https://github.com/apache/dubbo/issues/5885
+                if (CollectionUtils.isEmpty(instances) && isServiceNamesWithCompatibleMode(url)) {","[{'comment': '这里有个问题，目前你的更改应该只能解决instances为空的问题，但是没解决不为空的情况下，其中一个serviceName触发实例变动导致的覆盖问题。', 'commenter': 'CodingSinger'}, {'comment': '是的，现在的解决方案存在这个问题。这两个serviceName表示同一个接口，只是因为版本问题产生的两个不同的名字，两个serviceName的instances应该放在一起考虑。我来改下代码', 'commenter': 'laddcn'}, {'comment': '我增加一个实例管理工具类，实现了相关serviceName的实例一起考虑，避免了覆盖问题，同时对instances为空的情况依然能正常处理，测试功能正常，之前的bug已经解决。', 'commenter': 'laddcn'}]"
5902,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosInstanceManageUtil.java,"@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.nacos.util;
+
+import com.alibaba.nacos.api.naming.pojo.Instance;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import org.apache.dubbo.common.utils.CollectionUtils;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Instance manage util for multiple serviceNames
+ * To resolve bug with https://github.com/apache/dubbo/issues/5885 and https://github.com/apache/dubbo/issues/5899
+ *
+ * @since 2.7.6
+ */
+public class NacosInstanceManageUtil {
+
+    /**
+     * serviceName -> refreshed instance list
+     */
+    private static final Map<String, List<Instance>> serviceInstanceListMap = Maps.newHashMap();
+
+    /**
+     * serviceName -> corresponding serviceName list
+     */
+    private static final Map<String, Set<String>> correspondingServiceNamesMap = Maps.newHashMap();","[{'comment': '这里是不是应该考虑并发问题，用ConcurrentHashMap比较合适？', 'commenter': 'CodingSinger'}]"
5902,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosInstanceManageUtil.java,"@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.nacos.util;
+
+import com.alibaba.nacos.api.naming.pojo.Instance;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import org.apache.dubbo.common.utils.CollectionUtils;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Instance manage util for multiple serviceNames
+ * To resolve bug with https://github.com/apache/dubbo/issues/5885 and https://github.com/apache/dubbo/issues/5899
+ *
+ * @since 2.7.6
+ */
+public class NacosInstanceManageUtil {
+
+    /**
+     * serviceName -> refreshed instance list
+     */
+    private static final Map<String, List<Instance>> serviceInstanceListMap = Maps.newHashMap();","[{'comment': '同下', 'commenter': 'CodingSinger'}, {'comment': '已更新', 'commenter': 'laddcn'}]"
5902,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -162,20 +164,62 @@ public void doUnregister(final URL url) {
     @Override
     public void doSubscribe(final URL url, final NotifyListener listener) {
         Set<String> serviceNames = getServiceNames(url, listener);
+
+        //Set corresponding serviceNames for easy search later
+        if(isServiceNamesWithCompatibleMode(url)){
+            for(String serviceName:serviceNames){
+                NacosInstanceManageUtil.setCorrespondingServiceNames(serviceName, serviceNames);
+            }
+        }
+","[{'comment': '这里我觉得还是有问题，比如服务端是2.7.3之前的版本，那它的ur是老的形式，按你这个。如果最后一个provider下线，那这里不会按照empty协议去通知，所以客户端的最后一个provider的代理invoker不会被清理掉', 'commenter': 'tswstarplanet'}, {'comment': '这里的url是consumer的引用ref url，类似consumer://ip/org.apache.dubbo.demo.DemoService?application=demo-consumer&category=providers,configurators,routers&check=false&dubbo=2.0.2&init=false&interface=org.apache.dubbo.demo.DemoService&methods=sayHello,sayHelloAsync&pid=46172&qos.port=33333&side=consumer&sticky=false&timestamp=1585126881120，现在的问题是2.7.3之前和之后的版本，ref url对应的serviceName（存储在nacos中的服务名称）不同。2.7.6为了兼容，针对同一个url（consumer ref url），会订阅2个serviceName对应的nacos服务，导致了这两个issue里面说的问题。我现在的处理逻辑是，新老serviceName实质上是同一个服务，只是在nacos中有2个不同的名字。因此，我把新老两个serviceName对应的服务统一看待，每次更新可用instances的时候保证会包含两个serviceName对应的所有instances。你说的这种情况，如果服务只有2.7.3以下的provider（只有老版本的serviceName对应的服务），当所有provider都下线的时候，我们通过2个serviceName获取的健康instances数也是为0的，notify执行时，会把invokerUrl（这个代表providerUrl）的协议设置为empty，从而把consumer端接口的调用设置为forbidden=true禁止掉。等有新的provider上线的时候，会设置forbidden=true，恢复正常调用。如果provider既有老版本（2.7.3之前），又有新版本（2.7.3及以后）的，会在新老版本的所有instances都下线的情况下，才把consumer端的引用禁止掉。', 'commenter': 'laddcn'}]"
5902,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -162,20 +164,62 @@ public void doUnregister(final URL url) {
     @Override
     public void doSubscribe(final URL url, final NotifyListener listener) {
         Set<String> serviceNames = getServiceNames(url, listener);
+
+        //Set corresponding serviceNames for easy search later
+        if(isServiceNamesWithCompatibleMode(url)){
+            for(String serviceName:serviceNames){
+                NacosInstanceManageUtil.setCorrespondingServiceNames(serviceName, serviceNames);
+            }
+        }
+
         doSubscribe(url, listener, serviceNames);
     }
 
     private void doSubscribe(final URL url, final NotifyListener listener, final Set<String> serviceNames) {
         execute(namingService -> {
-            List<Instance> instances = new LinkedList();
-            for (String serviceName : serviceNames) {
-                instances.addAll(namingService.getAllInstances(serviceName));
-                subscribeEventListener(serviceName, url, listener);
+            if (isServiceNamesWithCompatibleMode(url)) {
+                List<Instance> allCorrespondingInstanceList = Lists.newArrayList();
+
+                /**
+                 * Get all instances with serviceNames to avoid instance overwrite and but with empty instance mentioned
+                 * in https://github.com/apache/dubbo/issues/5885 and https://github.com/apache/dubbo/issues/5899
+                 */
+                for (String serviceName : serviceNames) {
+                    List<Instance> instances = namingService.getAllInstances(serviceName);
+                    NacosInstanceManageUtil.initOrRefreshServiceInstanceList(serviceName, instances);
+                    allCorrespondingInstanceList.addAll(instances);
+                }
+                notifySubscriber(url, listener, allCorrespondingInstanceList);
+                for (String serviceName : serviceNames) {
+                    subscribeEventListener(serviceName, url, listener);
+                }
+            } else {
+                List<Instance> instances = new LinkedList();
+                for (String serviceName : serviceNames) {
+                    instances.addAll(namingService.getAllInstances(serviceName));
+                    notifySubscriber(url, listener, instances);
+                    subscribeEventListener(serviceName, url, listener);
+                }
             }
-            notifySubscriber(url, listener, instances);
+
         });
     }
 
+    /**
+     * Since 2.7.6 the legacy service name will be added to serviceNames
+     * to fix bug with https://github.com/apache/dubbo/issues/5442
+     *
+     * @param url
+     * @return
+     */
+    private boolean isServiceNamesWithCompatibleMode(final URL url) {
+        if (!isAdminProtocol(url) && createServiceName(url).isConcrete()) {","[{'comment': '你好，最近看这块代码觉得有点困惑。为什么判断服务是否需要兼容的时候，要通过`createServiceName(url).isConcrete()`去判断呢？', 'commenter': 'horizonzy'}]"
5973,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ClusterUtils.java,"@@ -1,120 +1,119 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.rpc.cluster.support;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.remoting.Constants;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.apache.dubbo.common.constants.CommonConstants.ALIVE_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.APPLICATION_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.CORE_THREADS_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_KEY_PREFIX;
-import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_VERSION_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.INVOKER_LISTENER_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.QUEUES_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.REFERENCE_FILTER_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.RELEASE_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.REMOTE_APPLICATION_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.THREADPOOL_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.THREADS_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.THREAD_NAME_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;
-
-/**
- * ClusterUtils
- */
-public class ClusterUtils {
-
-    private ClusterUtils() {
-    }
-
-    public static URL mergeUrl(URL remoteUrl, Map<String, String> localMap) {
-        Map<String, String> map = new HashMap<String, String>();
-        Map<String, String> remoteMap = remoteUrl.getParameters();
-
-        if (remoteMap != null && remoteMap.size() > 0) {
-            map.putAll(remoteMap);
-
-            // Remove configurations from provider, some items should be affected by provider.
-            map.remove(THREAD_NAME_KEY);
-            map.remove(DEFAULT_KEY_PREFIX + THREAD_NAME_KEY);
-
-            map.remove(THREADPOOL_KEY);
-            map.remove(DEFAULT_KEY_PREFIX + THREADPOOL_KEY);
-
-            map.remove(CORE_THREADS_KEY);
-            map.remove(DEFAULT_KEY_PREFIX + CORE_THREADS_KEY);
-
-            map.remove(THREADS_KEY);
-            map.remove(DEFAULT_KEY_PREFIX + THREADS_KEY);
-
-            map.remove(QUEUES_KEY);
-            map.remove(DEFAULT_KEY_PREFIX + QUEUES_KEY);
-
-            map.remove(ALIVE_KEY);
-            map.remove(DEFAULT_KEY_PREFIX + ALIVE_KEY);
-
-            map.remove(Constants.TRANSPORTER_KEY);
-            map.remove(DEFAULT_KEY_PREFIX + Constants.TRANSPORTER_KEY);
-        }
-
-        if (localMap != null && localMap.size() > 0) {
-            Map<String, String> copyOfLocalMap = new HashMap<>(localMap);
-
-            if(map.containsKey(GROUP_KEY)){
-                copyOfLocalMap.remove(GROUP_KEY);
-            }
-            if(map.containsKey(VERSION_KEY)){
-                copyOfLocalMap.remove(VERSION_KEY);
-            }
-
-            copyOfLocalMap.remove(RELEASE_KEY);
-            copyOfLocalMap.remove(DUBBO_VERSION_KEY);
-            copyOfLocalMap.remove(METHODS_KEY);
-            copyOfLocalMap.remove(TIMESTAMP_KEY);
-            copyOfLocalMap.remove(TAG_KEY);
-
-            map.putAll(copyOfLocalMap);
-
-            map.put(REMOTE_APPLICATION_KEY, remoteMap.get(APPLICATION_KEY));
-
-            // Combine filters and listeners on Provider and Consumer
-            String remoteFilter = remoteMap.get(REFERENCE_FILTER_KEY);
-            String localFilter = copyOfLocalMap.get(REFERENCE_FILTER_KEY);
-            if (remoteFilter != null && remoteFilter.length() > 0
-                    && localFilter != null && localFilter.length() > 0) {
-                map.put(REFERENCE_FILTER_KEY, remoteFilter + "","" + localFilter);
-            }
-            String remoteListener = remoteMap.get(INVOKER_LISTENER_KEY);
-            String localListener = copyOfLocalMap.get(INVOKER_LISTENER_KEY);
-            if (remoteListener != null && remoteListener.length() > 0
-                    && localListener != null && localListener.length() > 0) {
-                map.put(INVOKER_LISTENER_KEY, remoteListener + "","" + localListener);
-            }
-        }
-
-        return remoteUrl.clearParameters().addParameters(map);
-    }
-
-}
+/*","[{'comment': 'please recover file end-line format of this file', 'commenter': 'AlbumenJ'}]"
5981,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ClusterUtils.java,"@@ -93,7 +92,7 @@ public static URL mergeUrl(URL remoteUrl, Map<String, String> localMap) {
             copyOfLocalMap.remove(DUBBO_VERSION_KEY);
             copyOfLocalMap.remove(METHODS_KEY);
             copyOfLocalMap.remove(TIMESTAMP_KEY);
-            copyOfLocalMap.remove(TAG_KEY);
+","[{'comment': '这个修改是错误的吧。 本地consumer本来应该被过滤掉，因为merge里merge完的结果是provider的URL。\r\n\r\n这个问题还得从其他方面找原因。', 'commenter': 'cvictory'}]"
5998,dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java,"@@ -1,453 +1,453 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.common.bytecode;
-
-import org.apache.dubbo.common.utils.ClassUtils;
-import org.apache.dubbo.common.utils.ReflectUtils;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.regex.Matcher;
-
-/**
- * Wrapper.
- */
-public abstract class Wrapper {
-    private static final Map<Class<?>, Wrapper> WRAPPER_MAP = new ConcurrentHashMap<Class<?>, Wrapper>(); //class wrapper map
-    private static final String[] EMPTY_STRING_ARRAY = new String[0];
-    private static final String[] OBJECT_METHODS = new String[]{""getClass"", ""hashCode"", ""toString"", ""equals""};
-    private static final Wrapper OBJECT_WRAPPER = new Wrapper() {
-        @Override
-        public String[] getMethodNames() {
-            return OBJECT_METHODS;
-        }
-
-        @Override
-        public String[] getDeclaredMethodNames() {
-            return OBJECT_METHODS;
-        }
-
-        @Override
-        public String[] getPropertyNames() {
-            return EMPTY_STRING_ARRAY;
-        }
-
-        @Override
-        public Class<?> getPropertyType(String pn) {
-            return null;
-        }
-
-        @Override
-        public Object getPropertyValue(Object instance, String pn) throws NoSuchPropertyException {
-            throw new NoSuchPropertyException(""Property ["" + pn + ""] not found."");
-        }
-
-        @Override
-        public void setPropertyValue(Object instance, String pn, Object pv) throws NoSuchPropertyException {
-            throw new NoSuchPropertyException(""Property ["" + pn + ""] not found."");
-        }
-
-        @Override
-        public boolean hasProperty(String name) {
-            return false;
-        }
-
-        @Override
-        public Object invokeMethod(Object instance, String mn, Class<?>[] types, Object[] args) throws NoSuchMethodException {
-            if (""getClass"".equals(mn)) {
-                return instance.getClass();
-            }
-            if (""hashCode"".equals(mn)) {
-                return instance.hashCode();
-            }
-            if (""toString"".equals(mn)) {
-                return instance.toString();
-            }
-            if (""equals"".equals(mn)) {
-                if (args.length == 1) {
-                    return instance.equals(args[0]);
-                }
-                throw new IllegalArgumentException(""Invoke method ["" + mn + ""] argument number error."");
-            }
-            throw new NoSuchMethodException(""Method ["" + mn + ""] not found."");
-        }
-    };
-    private static AtomicLong WRAPPER_CLASS_COUNTER = new AtomicLong(0);
-
-    /**
-     * get wrapper.
-     *
-     * @param c Class instance.
-     * @return Wrapper instance(not null).
-     */
-    public static Wrapper getWrapper(Class<?> c) {
-        while (ClassGenerator.isDynamicClass(c)) // can not wrapper on dynamic class.
-        {
-            c = c.getSuperclass();
-        }
-
-        if (c == Object.class) {
-            return OBJECT_WRAPPER;
-        }
-
-        return WRAPPER_MAP.computeIfAbsent(c, Wrapper::makeWrapper);
-    }
-
-    private static Wrapper makeWrapper(Class<?> c) {
-        if (c.isPrimitive()) {
-            throw new IllegalArgumentException(""Can not create wrapper for primitive type: "" + c);
-        }
-
-        String name = c.getName();
-        ClassLoader cl = ClassUtils.getClassLoader(c);
-
-        StringBuilder c1 = new StringBuilder(""public void setPropertyValue(Object o, String n, Object v){ "");
-        StringBuilder c2 = new StringBuilder(""public Object getPropertyValue(Object o, String n){ "");
-        StringBuilder c3 = new StringBuilder(""public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws "" + InvocationTargetException.class.getName() + ""{ "");
-
-        c1.append(name).append("" w; try{ w = (("").append(name).append("")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }"");
-        c2.append(name).append("" w; try{ w = (("").append(name).append("")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }"");
-        c3.append(name).append("" w; try{ w = (("").append(name).append("")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }"");
-
-        Map<String, Class<?>> pts = new HashMap<>(); // <property name, property types>
-        Map<String, Method> ms = new LinkedHashMap<>(); // <method desc, Method instance>
-        List<String> mns = new ArrayList<>(); // method names.
-        List<String> dmns = new ArrayList<>(); // declaring method names.
-
-        // get all public field.
-        for (Field f : c.getFields()) {
-            String fn = f.getName();
-            Class<?> ft = f.getType();
-            if (Modifier.isStatic(f.getModifiers()) || Modifier.isTransient(f.getModifiers())) {
-                continue;
-            }
-
-            c1.append("" if( $2.equals(\"""").append(fn).append(""\"") ){ w."").append(fn).append(""="").append(arg(ft, ""$3"")).append(""; return; }"");
-            c2.append("" if( $2.equals(\"""").append(fn).append(""\"") ){ return ($w)w."").append(fn).append(""; }"");
-            pts.put(fn, ft);
-        }
-
-        Method[] methods = c.getMethods();
-        // get all public method.
-        boolean hasMethod = hasMethods(methods);
-        if (hasMethod) {
-            c3.append("" try{"");
-            for (Method m : methods) {
-                //ignore Object's method.
-                if (m.getDeclaringClass() == Object.class) {
-                    continue;
-                }
-
-                String mn = m.getName();
-                c3.append("" if( \"""").append(mn).append(""\"".equals( $2 ) "");
-                int len = m.getParameterTypes().length;
-                c3.append("" && "").append("" $3.length == "").append(len);
-
-                boolean overload = false;
-                for (Method m2 : methods) {
-                    if (m != m2 && m.getName().equals(m2.getName())) {
-                        overload = true;
-                        break;
-                    }
-                }
-                if (overload) {
-                    if (len > 0) {
-                        for (int l = 0; l < len; l++) {
-                            c3.append("" && "").append("" $3["").append(l).append(""].getName().equals(\"""")
-                                    .append(m.getParameterTypes()[l].getName()).append(""\"")"");
-                        }
-                    }
-                }
-
-                c3.append("" ) { "");
-
-                if (m.getReturnType() == Void.TYPE) {
-                    c3.append("" w."").append(mn).append('(').append(args(m.getParameterTypes(), ""$4"")).append("");"").append("" return null;"");
-                } else {
-                    c3.append("" return ($w)w."").append(mn).append('(').append(args(m.getParameterTypes(), ""$4"")).append("");"");
-                }
-
-                c3.append("" }"");
-
-                mns.add(mn);
-                if (m.getDeclaringClass() == c) {
-                    dmns.add(mn);
-                }
-                ms.put(ReflectUtils.getDesc(m), m);
-            }
-            c3.append("" } catch(Throwable e) { "");
-            c3.append(""     throw new java.lang.reflect.InvocationTargetException(e); "");
-            c3.append("" }"");
-        }
-
-        c3.append("" throw new "" + NoSuchMethodException.class.getName() + ""(\""Not found method \\\""\""+$2+\""\\\"" in class "" + c.getName() + "".\""); }"");
-
-        // deal with get/set method.
-        Matcher matcher;
-        for (Map.Entry<String, Method> entry : ms.entrySet()) {
-            String md = entry.getKey();
-            Method method = entry.getValue();
-            if ((matcher = ReflectUtils.GETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) {
-                String pn = propertyName(matcher.group(1));
-                c2.append("" if( $2.equals(\"""").append(pn).append(""\"") ){ return ($w)w."").append(method.getName()).append(""(); }"");
-                pts.put(pn, method.getReturnType());
-            } else if ((matcher = ReflectUtils.IS_HAS_CAN_METHOD_DESC_PATTERN.matcher(md)).matches()) {
-                String pn = propertyName(matcher.group(1));
-                c2.append("" if( $2.equals(\"""").append(pn).append(""\"") ){ return ($w)w."").append(method.getName()).append(""(); }"");
-                pts.put(pn, method.getReturnType());
-            } else if ((matcher = ReflectUtils.SETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) {
-                Class<?> pt = method.getParameterTypes()[0];
-                String pn = propertyName(matcher.group(1));
-                c1.append("" if( $2.equals(\"""").append(pn).append(""\"") ){ w."").append(method.getName()).append(""("").append(arg(pt, ""$3"")).append(""); return; }"");
-                pts.put(pn, pt);
-            }
-        }
-        c1.append("" throw new "" + NoSuchPropertyException.class.getName() + ""(\""Not found property \\\""\""+$2+\""\\\"" field or setter method in class "" + c.getName() + "".\""); }"");
-        c2.append("" throw new "" + NoSuchPropertyException.class.getName() + ""(\""Not found property \\\""\""+$2+\""\\\"" field or getter method in class "" + c.getName() + "".\""); }"");
-
-        // make class
-        long id = WRAPPER_CLASS_COUNTER.getAndIncrement();
-        ClassGenerator cc = ClassGenerator.newInstance(cl);
-        cc.setClassName((Modifier.isPublic(c.getModifiers()) ? Wrapper.class.getName() : c.getName() + ""$sw"") + id);
-        cc.setSuperClass(Wrapper.class);
-
-        cc.addDefaultConstructor();
-        cc.addField(""public static String[] pns;""); // property name array.
-        cc.addField(""public static "" + Map.class.getName() + "" pts;""); // property type map.
-        cc.addField(""public static String[] mns;""); // all method name array.
-        cc.addField(""public static String[] dmns;""); // declared method name array.
-        for (int i = 0, len = ms.size(); i < len; i++) {
-            cc.addField(""public static Class[] mts"" + i + "";"");
-        }
-
-        cc.addMethod(""public String[] getPropertyNames(){ return pns; }"");
-        cc.addMethod(""public boolean hasProperty(String n){ return pts.containsKey($1); }"");
-        cc.addMethod(""public Class getPropertyType(String n){ return (Class)pts.get($1); }"");
-        cc.addMethod(""public String[] getMethodNames(){ return mns; }"");
-        cc.addMethod(""public String[] getDeclaredMethodNames(){ return dmns; }"");
-        cc.addMethod(c1.toString());
-        cc.addMethod(c2.toString());
-        cc.addMethod(c3.toString());
-
-        try {
-            Class<?> wc = cc.toClass();
-            // setup static field.
-            wc.getField(""pts"").set(null, pts);
-            wc.getField(""pns"").set(null, pts.keySet().toArray(new String[0]));
-            wc.getField(""mns"").set(null, mns.toArray(new String[0]));
-            wc.getField(""dmns"").set(null, dmns.toArray(new String[0]));
-            int ix = 0;
-            for (Method m : ms.values()) {
-                wc.getField(""mts"" + ix++).set(null, m.getParameterTypes());
-            }
-            return (Wrapper) wc.getDeclaredConstructor().newInstance();
-        } catch (RuntimeException e) {
-            throw e;
-        } catch (Throwable e) {
-            throw new RuntimeException(e.getMessage(), e);
-        } finally {
-            cc.release();
-            ms.clear();
-            mns.clear();
-            dmns.clear();
-        }
-    }
-
-    private static String arg(Class<?> cl, String name) {
-        if (cl.isPrimitive()) {
-            if (cl == Boolean.TYPE) {
-                return ""((Boolean)"" + name + "").booleanValue()"";
-            }
-            if (cl == Byte.TYPE) {
-                return ""((Byte)"" + name + "").byteValue()"";
-            }
-            if (cl == Character.TYPE) {
-                return ""((Character)"" + name + "").charValue()"";
-            }
-            if (cl == Double.TYPE) {
-                return ""((Number)"" + name + "").doubleValue()"";
-            }
-            if (cl == Float.TYPE) {
-                return ""((Number)"" + name + "").floatValue()"";
-            }
-            if (cl == Integer.TYPE) {
-                return ""((Number)"" + name + "").intValue()"";
-            }
-            if (cl == Long.TYPE) {
-                return ""((Number)"" + name + "").longValue()"";
-            }
-            if (cl == Short.TYPE) {
-                return ""((Number)"" + name + "").shortValue()"";
-            }
-            throw new RuntimeException(""Unknown primitive type: "" + cl.getName());
-        }
-        return ""("" + ReflectUtils.getName(cl) + "")"" + name;
-    }
-
-    private static String args(Class<?>[] cs, String name) {
-        int len = cs.length;
-        if (len == 0) {
-            return """";
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < len; i++) {
-            if (i > 0) {
-                sb.append(',');
-            }
-            sb.append(arg(cs[i], name + ""["" + i + ""]""));
-        }
-        return sb.toString();
-    }
-
-    private static String propertyName(String pn) {
-        return pn.length() == 1 || Character.isLowerCase(pn.charAt(1)) ? Character.toLowerCase(pn.charAt(0)) + pn.substring(1) : pn;
-    }
-
-    private static boolean hasMethods(Method[] methods) {
-        if (methods == null || methods.length == 0) {
-            return false;
-        }
-        for (Method m : methods) {
-            if (m.getDeclaringClass() != Object.class) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * get property name array.
-     *
-     * @return property name array.
-     */
-    abstract public String[] getPropertyNames();
-
-    /**
-     * get property type.
-     *
-     * @param pn property name.
-     * @return Property type or nul.
-     */
-    abstract public Class<?> getPropertyType(String pn);
-
-    /**
-     * has property.
-     *
-     * @param name property name.
-     * @return has or has not.
-     */
-    abstract public boolean hasProperty(String name);
-
-    /**
-     * get property value.
-     *
-     * @param instance instance.
-     * @param pn       property name.
-     * @return value.
-     */
-    abstract public Object getPropertyValue(Object instance, String pn) throws NoSuchPropertyException, IllegalArgumentException;
-
-    /**
-     * set property value.
-     *
-     * @param instance instance.
-     * @param pn       property name.
-     * @param pv       property value.
-     */
-    abstract public void setPropertyValue(Object instance, String pn, Object pv) throws NoSuchPropertyException, IllegalArgumentException;
-
-    /**
-     * get property value.
-     *
-     * @param instance instance.
-     * @param pns      property name array.
-     * @return value array.
-     */
-    public Object[] getPropertyValues(Object instance, String[] pns) throws NoSuchPropertyException, IllegalArgumentException {
-        Object[] ret = new Object[pns.length];
-        for (int i = 0; i < ret.length; i++) {
-            ret[i] = getPropertyValue(instance, pns[i]);
-        }
-        return ret;
-    }
-
-    /**
-     * set property value.
-     *
-     * @param instance instance.
-     * @param pns      property name array.
-     * @param pvs      property value array.
-     */
-    public void setPropertyValues(Object instance, String[] pns, Object[] pvs) throws NoSuchPropertyException, IllegalArgumentException {
-        if (pns.length != pvs.length) {
-            throw new IllegalArgumentException(""pns.length != pvs.length"");
-        }
-
-        for (int i = 0; i < pns.length; i++) {
-            setPropertyValue(instance, pns[i], pvs[i]);
-        }
-    }
-
-    /**
-     * get method name array.
-     *
-     * @return method name array.
-     */
-    abstract public String[] getMethodNames();
-
-    /**
-     * get method name array.
-     *
-     * @return method name array.
-     */
-    abstract public String[] getDeclaredMethodNames();
-
-    /**
-     * has method.
-     *
-     * @param name method name.
-     * @return has or has not.
-     */
-    public boolean hasMethod(String name) {
-        for (String mn : getMethodNames()) {
-            if (mn.equals(name)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * invoke method.
-     *
-     * @param instance instance.
-     * @param mn       method name.
-     * @param types
-     * @param args     argument array.
-     * @return return value.
-     */
-    abstract public Object invokeMethod(Object instance, String mn, Class<?>[] types, Object[] args) throws NoSuchMethodException, InvocationTargetException;
-}
+/*","[{'comment': 'Please recover the file end-line format of this file.', 'commenter': 'AlbumenJ'}, {'comment': 'Strange, github will automatically add a empty line', 'commenter': 'fzhyzamt'}]"
6055,dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java,"@@ -266,24 +266,14 @@ public String getExtensionName(Class<?> extensionClass) {
             }
             activateExtensions.sort(ActivateComparator.COMPARATOR);
         }
-        List<T> loadedExtensions = new ArrayList<>();
-        for (int i = 0; i < names.size(); i++) {
-            String name = names.get(i);
-            if (!name.startsWith(REMOVE_VALUE_PREFIX)
-                    && !names.contains(REMOVE_VALUE_PREFIX + name)) {
-                if (DEFAULT_KEY.equals(name)) {
-                    if (!loadedExtensions.isEmpty()) {
-                        activateExtensions.addAll(0, loadedExtensions);
-                        loadedExtensions.clear();
-                    }","[{'comment': 'default extensions will lose if remove there code', 'commenter': 'AlbumenJ'}]"
6234,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/expression/ExpressionRouter.java,"@@ -0,0 +1,132 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.expression;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.config.configcenter.ConfigChangeType;
+import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.Constants;
+import org.apache.dubbo.rpc.cluster.router.expression.context.ContextBuilder;
+import org.apache.dubbo.rpc.cluster.router.expression.model.Rule;
+import org.apache.dubbo.rpc.cluster.router.expression.model.RuleSet;
+import org.apache.dubbo.rpc.cluster.router.expression.model.ExpressionRuleConstructor;
+
+import org.apache.commons.jexl3.JexlBuilder;
+import org.apache.commons.jexl3.JexlContext;
+import org.apache.commons.jexl3.JexlEngine;
+import org.apache.commons.jexl3.MapContext;
+import org.yaml.snakeyaml.Yaml;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.stream.Collectors;
+
+/**
+ * ExpressionRouter which observes the change of Config Center for the key of <Application_Name>.observer-router.
+ * RuleSets dynamically changes according to the related value.
+ *
+ * @author Weihua
+ * @since 2.7.8
+ */
+public class ExpressionRouter extends ObserverRouter {
+
+    public static final String NAME = ""expression"";
+
+    private static final Logger logger = LoggerFactory.getLogger(ExpressionRouter.class);
+
+    /**
+     * Store the mapping relations of provider/ruleSet.
+     */
+    private static final Map<String, RuleSet> ruleSets = new ConcurrentHashMap<>();","[{'comment': 'Following Java conventions, `ruleSets` should be all upper case words with `_` in between. I think `RULE_SETS_BY_PROVIDER` is better. Same for the line below.', 'commenter': 'lfzCarlosC'}]"
6234,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/expression/ExpressionRouter.java,"@@ -0,0 +1,132 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.expression;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.config.configcenter.ConfigChangeType;
+import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.Constants;
+import org.apache.dubbo.rpc.cluster.router.expression.context.ContextBuilder;
+import org.apache.dubbo.rpc.cluster.router.expression.model.Rule;
+import org.apache.dubbo.rpc.cluster.router.expression.model.RuleSet;
+import org.apache.dubbo.rpc.cluster.router.expression.model.ExpressionRuleConstructor;
+
+import org.apache.commons.jexl3.JexlBuilder;
+import org.apache.commons.jexl3.JexlContext;
+import org.apache.commons.jexl3.JexlEngine;
+import org.apache.commons.jexl3.MapContext;
+import org.yaml.snakeyaml.Yaml;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.stream.Collectors;
+
+/**
+ * ExpressionRouter which observes the change of Config Center for the key of <Application_Name>.observer-router.
+ * RuleSets dynamically changes according to the related value.
+ *
+ * @author Weihua","[{'comment': 'pls remove author tag, thx', 'commenter': 'AlbumenJ'}]"
6234,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/expression/ExpressionRouterFactory.java,"@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.expression;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.rpc.cluster.Router;
+import org.apache.dubbo.rpc.cluster.RouterFactory;
+
+/**
+ * ExpressionRouterFactory
+ *
+ * @author Weihua","[{'comment': 'also for this', 'commenter': 'AlbumenJ'}]"
6234,dubbo-demo/dubbo-demo-annotation/dubbo-demo-web-consumer/pom.xml,"@@ -0,0 +1,100 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>","[{'comment': 'how about moving this sample to `dubbo-samples`', 'commenter': 'AlbumenJ'}]"
6500,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServer.java,"@@ -45,8 +45,7 @@
 import java.util.Map;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static org.apache.dubbo.common.constants.CommonConstants.IO_THREADS_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.SSL_ENABLED_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.*;","[{'comment': 'wildcard import is not allowed in Dubbo. pls remove it', 'commenter': 'AlbumenJ'}, {'comment': ""I've done it"", 'commenter': 'skyguard1'}]"
6500,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServer.java,"@@ -94,10 +96,13 @@ protected void doOpen() throws Throwable {
         final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this);
         channels = nettyServerHandler.getChannels();
 
+        boolean keepalive = getUrl().getParameter(KEEP_ALIVE_KEY, Boolean.FALSE);","[{'comment': 'shall default disable keep alive proper ?', 'commenter': 'AlbumenJ'}, {'comment': 'The default value of the keep alive parameter of netty is false, which can keep the configuration consistent with the previous version', 'commenter': 'skyguard1'}]"
6623,dubbo-plugin/dubbo-qos/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.qos.probe.ReadinessProbe,"@@ -0,0 +1,2 @@
+bootstrap = org.apache.dubbo.qos.probe.impl.BootstrapReadinessProbe","[{'comment': ""I didn't find the definition of this class."", 'commenter': 'chickenlj'}]"
6623,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/probe/impl/ProviderReadinessProbe.java,"@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.qos.probe.impl;
+
+import org.apache.dubbo.qos.probe.ReadinessProbe;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ProviderModel;
+import org.apache.dubbo.rpc.model.ServiceRepository;
+
+import java.util.Collection;
+import java.util.List;
+
+public class ProviderReadinessProbe implements ReadinessProbe {
+    private static ServiceRepository serviceRepository = ApplicationModel.getServiceRepository();
+
+    @Override
+    public boolean check() {","[{'comment': 'I think checking whether ServiceInstance has been registered would be enough.', 'commenter': 'chickenlj'}, {'comment': 'Readiness probe is used in total life cycle. If readiness probe failed, the endpoint will temporarily be removed from service. ServiceInstance is registered when startup.', 'commenter': 'AlbumenJ'}]"
6631,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ClusterUtils.java,"@@ -21,25 +21,9 @@
 
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Optional;
 
-import static org.apache.dubbo.common.constants.CommonConstants.ALIVE_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.APPLICATION_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.CORE_THREADS_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_KEY_PREFIX;
-import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_VERSION_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.INVOKER_LISTENER_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.QUEUES_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.REFERENCE_FILTER_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.RELEASE_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.REMOTE_APPLICATION_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.THREADPOOL_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.THREADS_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.THREAD_NAME_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.*;","[{'comment': ""According to `codestyle/checkstyle.xml`, using the '.*' form of import should be avoided."", 'commenter': 'AlbumenJ'}]"
6631,dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java,"@@ -119,6 +125,27 @@ public void checkDefault() throws IllegalStateException {
         }
     }
 
+    public void checkProtocol() throws IllegalStateException {
+        if (_protocol == null) {
+            List<ProtocolConfig> protocolConfigs = ApplicationModel.getConfigManager().getDefaultProtocols();
+            if (protocolConfigs.isEmpty()) {
+                return;
+            }
+
+            if (protocolConfigs.size() > 1) {
+                throw new IllegalStateException(""Consumer cannot support configure multiple protocols"");
+            }
+
+            _protocol = protocolConfigs.get(0);
+
+            // 设置全局protocol","[{'comment': 'Please comment it in English.', 'commenter': 'AlbumenJ'}]"
6631,dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java,"@@ -67,6 +68,11 @@
      */
     protected ConsumerConfig consumer;
 
+    /**
+     * The protocol config
+     */
+    protected ProtocolConfig _protocol;","[{'comment': 'What is your purpose to add this parameter?', 'commenter': 'AlbumenJ'}, {'comment': 'now if u want to configure the `heartbeat` and`protocol`properties the consumer, u can only configure it at the service level, which is not desirable for the user, who wants to use `PortocolConfig `to globally configure the `heartbeat` and `protocol` properties of the consumer.', 'commenter': 'XiaoWeiKIN'}, {'comment': 'thanks for your description, I think if this paramerter could be named in lowerCamelCase and more specific of its usage would be better.', 'commenter': 'AlbumenJ'}, {'comment': 'Yes, I agree better to follow the name convention as the other existing properties.', 'commenter': 'chickenlj'}, {'comment': 'ok', 'commenter': 'XiaoWeiKIN'}]"
6631,dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java,"@@ -119,6 +125,27 @@ public void checkDefault() throws IllegalStateException {
         }
     }
 
+    public void checkProtocol() throws IllegalStateException {
+        if (_protocol == null) {
+            List<ProtocolConfig> protocolConfigs = ApplicationModel.getConfigManager().getDefaultProtocols();
+            if (protocolConfigs.isEmpty()) {
+                return;
+            }
+
+            if (protocolConfigs.size() > 1) {
+                throw new IllegalStateException(""Consumer cannot support configure multiple protocols"");","[{'comment': 'It is possible for applcation who has configured more than one protocol.', 'commenter': 'AlbumenJ'}, {'comment': ""It is possible for a provider to configure multiple protocols, while a consumer configuration only invokes the service provider for the specified protocol, and other protocols ignore it. So I don't think it makes sense to deploy multiple protocols on the consumer side. the consumer use the following configuration,as with `ReferenceConfig`\r\n```\r\ndubbo.protocol.name=dubbo,rmi\r\n```"", 'commenter': 'XiaoWeiKIN'}]"
6631,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -220,6 +220,7 @@ public synchronized void init() {
         // remove 'default.' prefix for configs from ConsumerConfig
         // appendParameters(map, consumer, Constants.DEFAULT_KEY);
         AbstractConfig.appendParameters(map, consumer);
+        AbstractConfig.appendParameters(map, _protocol);","[{'comment': 'will this override the configurations which are config before?', 'commenter': 'AlbumenJ'}, {'comment': ""No, you can check `<reference/>` and `<protocol/>` `<consumer/>` schema and the priority is ` <reference/> ` > `< protocol/>` > `<consumer/>` . Now the consumer `<protocol/>`  configuration is not available and must be configured in <reference/>. I don't think it's reasonable."", 'commenter': 'XiaoWeiKIN'}]"
6631,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"@@ -95,13 +95,7 @@
 import static org.apache.dubbo.registry.Constants.REGISTER_KEY;
 import static org.apache.dubbo.registry.Constants.REGISTRY_RETRY_PERIOD_KEY;
 import static org.apache.dubbo.registry.Constants.SIMPLIFIED_KEY;
-import static org.apache.dubbo.remoting.Constants.BIND_IP_KEY;
-import static org.apache.dubbo.remoting.Constants.BIND_PORT_KEY;
-import static org.apache.dubbo.remoting.Constants.CHECK_KEY;
-import static org.apache.dubbo.remoting.Constants.CODEC_KEY;
-import static org.apache.dubbo.remoting.Constants.CONNECTIONS_KEY;
-import static org.apache.dubbo.remoting.Constants.EXCHANGER_KEY;
-import static org.apache.dubbo.remoting.Constants.SERIALIZATION_KEY;
+import static org.apache.dubbo.remoting.Constants.*;","[{'comment': ""the same with using the '.*' form of import should be avoided."", 'commenter': 'AlbumenJ'}, {'comment': 'i have updated.', 'commenter': 'XiaoWeiKIN'}]"
6660,dubbo-configcenter/dubbo-configcenter-redis/src/main/java/org/apache/dubbo/configcenter/support/redis/RedisDynamicConfiguration.java,"@@ -0,0 +1,177 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.configcenter.support.redis;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.config.configcenter.ConfigChangeType;
+import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;
+import org.apache.dubbo.common.config.configcenter.ConfigurationListener;
+import org.apache.dubbo.common.config.configcenter.TreePathDynamicConfiguration;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.NamedThreadFactory;
+import org.apache.dubbo.remoting.redis.RedisClient;
+import org.apache.dubbo.remoting.redis.jedis.ClusterRedisClient;
+import org.apache.dubbo.remoting.redis.jedis.MonoRedisClient;
+import org.apache.dubbo.remoting.redis.jedis.SentinelRedisClient;
+
+import java.util.Collection;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.ANY_VALUE;
+import static org.apache.dubbo.common.constants.CommonConstants.CLUSTER_REDIS;
+import static org.apache.dubbo.common.constants.CommonConstants.MONO_REDIS;
+import static org.apache.dubbo.common.constants.CommonConstants.REDIS_CLIENT_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.SENTINEL_REDIS;
+import static org.apache.dubbo.common.utils.StringUtils.SLASH;
+
+/**
+ * Redis DynamicConfiguration
+ */
+public class RedisDynamicConfiguration extends TreePathDynamicConfiguration {
+    private static final Logger logger = LoggerFactory.getLogger(RedisDynamicConfiguration.class);
+    private static final String OK_RESPONSE = ""OK"";
+    private static final Long DEL_OK = 1L;
+    private static final long DEFAULT_CHECK_CONFIG_INTERVAL = 16000L;
+    private static final String CHECK_CONFIG_INTERVAL = ""redus-check-config-interval"";
+    /**
+     * Store the mapping of pathKey to hash of value
+     */
+    private ConcurrentMap<String, HashHolder> configHashes = new ConcurrentHashMap<>();
+    /**
+     * Store the mapping of pathKey to configuration listener
+     */
+    private ConcurrentMap<String, ConfigurationListener> configListeners = new ConcurrentHashMap<>();
+    private RedisClient redisClient;
+    /**
+     * Thread pool to poll the configuration
+     */
+    private ScheduledExecutorService configCheckExecutor;
+
+    public RedisDynamicConfiguration(URL url) {
+        super(url);
+        String type = url.getParameter(REDIS_CLIENT_KEY, MONO_REDIS);
+        if (SENTINEL_REDIS.equals(type)) {
+            redisClient = new SentinelRedisClient(url);
+        } else if (CLUSTER_REDIS.equals(type)) {
+            redisClient = new ClusterRedisClient(url);
+        } else {
+            redisClient = new MonoRedisClient(url);
+        }
+        long checkPassInterval = url.getParameter(CHECK_CONFIG_INTERVAL, DEFAULT_CHECK_CONFIG_INTERVAL);
+        configCheckExecutor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(""Ttl-Redis-Check-Executor"", true));
+        configCheckExecutor.scheduleAtFixedRate(this::checkConfig, checkPassInterval / 8,
+                checkPassInterval / 8, TimeUnit.MILLISECONDS);
+    }
+
+    @Override
+    protected boolean doPublishConfig(String pathKey, String content) throws Exception {
+        return OK_RESPONSE.equals(redisClient.set(pathKey, content));
+    }
+
+    @Override
+    protected String doGetConfig(String pathKey) throws Exception {
+        return redisClient.get(pathKey);
+    }
+
+    @Override
+    protected boolean doRemoveConfig(String pathKey) throws Exception {
+        redisClient.del(pathKey);
+        return true;
+    }
+
+    @Override
+    protected Collection<String> doGetConfigKeys(String groupPath) {
+        if (!groupPath.endsWith(ANY_VALUE)) {
+            if (!groupPath.endsWith(SLASH)) {
+                groupPath = groupPath + SLASH;
+            }
+            groupPath = groupPath + ANY_VALUE;
+        }
+        return redisClient.scan(groupPath);
+    }
+
+    @Override
+    protected void doAddListener(String pathKey, ConfigurationListener listener) {
+        logger.info(""register listener "" + listener.getClass() + "" for config with key: "" + pathKey);
+        String value = redisClient.get(pathKey);
+        if (value == null) {
+            configHashes.put(pathKey, HashHolder.getNullHash());
+        } else {
+            configHashes.put(pathKey, new HashHolder(value.hashCode()));
+        }
+        configListeners.put(pathKey, listener);
+    }
+
+    @Override
+    protected void doRemoveListener(String pathKey, ConfigurationListener listener) {
+        logger.info(""unregister listener "" + listener.getClass() + "" for config with key: "" + pathKey);
+        configHashes.remove(pathKey);
+        configListeners.remove(pathKey);
+    }
+
+    @Override
+    protected void doClose() throws Exception {
+        configHashes.clear();
+        configListeners.clear();
+        configCheckExecutor.shutdownNow();
+        redisClient.close();
+    }
+
+    private void checkConfig() {
+        for (Map.Entry<String, HashHolder> entry : configHashes.entrySet()) {
+            String value = redisClient.get(entry.getKey());
+            if (value != null) {
+                Integer hash = Integer.valueOf(value.hashCode());
+                Integer originHash = entry.getValue().getHash();
+                if (!hash.equals(originHash)) {
+                    System.out.println(""-------------key: "" + entry.getKey() + "", -----------value: "" + entry.getValue());","[{'comment': 'I think using `System.io` to output is need to banned. pls use `logger` instead.', 'commenter': 'AlbumenJ'}, {'comment': 'Thanks! It is my test code, and I forgot to delete.', 'commenter': 'tswstarplanet'}]"
6720,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProxyProtocol.java,"@@ -1,281 +1,279 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.rpc.protocol;
-
-import org.apache.dubbo.common.Parameters;
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.utils.NetUtils;
-import org.apache.dubbo.common.utils.StringUtils;
-import org.apache.dubbo.remoting.Channel;
-import org.apache.dubbo.remoting.ChannelHandler;
-import org.apache.dubbo.remoting.Constants;
-import org.apache.dubbo.remoting.RemotingException;
-import org.apache.dubbo.remoting.RemotingServer;
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.ProtocolServer;
-import org.apache.dubbo.rpc.ProxyFactory;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.RpcException;
-
-import java.net.InetSocketAddress;
-import java.util.Collection;
-import java.util.List;
-import java.util.Objects;
-import java.util.concurrent.CopyOnWriteArrayList;
-
-import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;
-
-/**
- * AbstractProxyProtocol
- */
-public abstract class AbstractProxyProtocol extends AbstractProtocol {
-
-    private final List<Class<?>> rpcExceptions = new CopyOnWriteArrayList<Class<?>>();
-
-    protected ProxyFactory proxyFactory;
-
-    public AbstractProxyProtocol() {
-    }
-
-    public AbstractProxyProtocol(Class<?>... exceptions) {
-        for (Class<?> exception : exceptions) {
-            addRpcException(exception);
-        }
-    }
-
-    public void addRpcException(Class<?> exception) {
-        this.rpcExceptions.add(exception);
-    }
-
-    public ProxyFactory getProxyFactory() {
-        return proxyFactory;
-    }
-
-    public void setProxyFactory(ProxyFactory proxyFactory) {
-        this.proxyFactory = proxyFactory;
-    }
-
-    @Override
-    @SuppressWarnings(""unchecked"")
-    public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {
-        final String uri = serviceKey(invoker.getUrl());
-        Exporter<T> exporter = (Exporter<T>) exporterMap.get(uri);
-        if (exporter != null) {
-            // When modifying the configuration through override, you need to re-expose the newly modified service.
-            if (Objects.equals(exporter.getInvoker().getUrl(), invoker.getUrl())) {
-                return exporter;
-            }
-        }
-        final Runnable runnable = doExport(proxyFactory.getProxy(invoker, true), invoker.getInterface(), invoker.getUrl());
-        exporter = new AbstractExporter<T>(invoker) {
-            @Override
-            public void afterUnExport() {
-                exporterMap.remove(uri);
-                if (runnable != null) {
-                    try {
-                        runnable.run();
-                    } catch (Throwable t) {
-                        logger.warn(t.getMessage(), t);
-                    }
-                }
-            }
-        };
-        exporterMap.put(uri, exporter);
-        return exporter;
-    }
-
-    @Override
-    protected <T> Invoker<T> protocolBindingRefer(final Class<T> type, final URL url) throws RpcException {
-        final Invoker<T> target = proxyFactory.getInvoker(doRefer(type, url), type, url);
-        Invoker<T> invoker = new AbstractInvoker<T>(type, url) {
-            @Override
-            protected Result doInvoke(Invocation invocation) throws Throwable {
-                try {
-                    Result result = target.invoke(invocation);
-                    // FIXME result is an AsyncRpcResult instance.
-                    Throwable e = result.getException();
-                    if (e != null) {
-                        for (Class<?> rpcException : rpcExceptions) {
-                            if (rpcException.isAssignableFrom(e.getClass())) {
-                                throw getRpcException(type, url, invocation, e);
-                            }
-                        }
-                    }
-                    return result;
-                } catch (RpcException e) {
-                    if (e.getCode() == RpcException.UNKNOWN_EXCEPTION) {
-                        e.setCode(getErrorCode(e.getCause()));
-                    }
-                    throw e;
-                } catch (Throwable e) {
-                    throw getRpcException(type, url, invocation, e);
-                }
-            }
-
-            @Override
-            public void destroy() {
-                super.destroy();
-                target.destroy();
-                invokers.remove(this);
-            }
-        };
-        invokers.add(invoker);
-        return invoker;
-    }
-
-    protected RpcException getRpcException(Class<?> type, URL url, Invocation invocation, Throwable e) {
-        RpcException re = new RpcException(""Failed to invoke remote service: "" + type + "", method: ""
-                + invocation.getMethodName() + "", cause: "" + e.getMessage(), e);
-        re.setCode(getErrorCode(e));
-        return re;
-    }
-
-    protected String getAddr(URL url) {
-        String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());
-        if (url.getParameter(ANYHOST_KEY, false)) {
-            bindIp = ANYHOST_VALUE;
-        }
-        return NetUtils.getIpByHost(bindIp) + "":"" + url.getParameter(Constants.BIND_PORT_KEY, url.getPort());
-    }
-
-    protected int getErrorCode(Throwable e) {
-        return RpcException.UNKNOWN_EXCEPTION;
-    }
-
-    protected abstract <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException;
-
-    protected abstract <T> T doRefer(Class<T> type, URL url) throws RpcException;
-
-    protected class ProxyProtocolServer implements ProtocolServer {
-
-        private RemotingServer server;
-        private String address;
-
-        public ProxyProtocolServer(RemotingServer server) {
-            this.server = server;
-        }
-
-        @Override
-        public RemotingServer getRemotingServer() {
-            return server;
-        }
-
-        @Override
-        public String getAddress() {
-            return StringUtils.isNotEmpty(address) ? address : server.getUrl().getAddress();
-        }
-
-        @Override
-        public void setAddress(String address) {
-            this.address = address;
-        }
-
-        @Override
-        public URL getUrl() {
-            return server.getUrl();
-        }
-
-        @Override
-        public void close() {
-            server.close();
-        }
-    }
-
-    protected abstract class RemotingServerAdapter implements RemotingServer {
-
-        public abstract Object getDelegateServer();
-
-        /**
-         * @return
-         */
-        @Override
-        public boolean isBound() {
-            return false;
-        }
-
-        @Override
-        public Collection<Channel> getChannels() {
-            return null;
-        }
-
-        @Override
-        public Channel getChannel(InetSocketAddress remoteAddress) {
-            return null;
-        }
-
-        @Override
-        public void reset(Parameters parameters) {
-
-        }
-
-        @Override
-        public void reset(URL url) {
-
-        }
-
-        @Override
-        public URL getUrl() {
-            return null;
-        }
-
-        @Override
-        public ChannelHandler getChannelHandler() {
-            return null;
-        }
-
-        @Override
-        public InetSocketAddress getLocalAddress() {
-            return null;
-        }
-
-        @Override
-        public void send(Object message) throws RemotingException {
-
-        }
-
-        @Override
-        public void send(Object message, boolean sent) throws RemotingException {
-
-        }
-
-        @Override
-        public void close() {
-
-        }
-
-        @Override
-        public void close(int timeout) {
-
-        }
-
-        @Override
-        public void startClose() {
-
-        }
-
-        @Override
-        public boolean isClosed() {
-            return false;
-        }
-    }
-
-
-}
+/*","[{'comment': 'please recover file endline format of this file', 'commenter': 'AlbumenJ'}]"
6720,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/DelegateExporterMap.java,"@@ -0,0 +1,59 @@
+/*","[{'comment': 'also for this file', 'commenter': 'AlbumenJ'}]"
6720,dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmExporter.java,"@@ -1,46 +1,42 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.rpc.protocol.injvm;
-
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.protocol.AbstractExporter;
-
-import java.util.Map;
-
-/**
- * InjvmExporter
- */
-class InjvmExporter<T> extends AbstractExporter<T> {
-
-    private final String key;
-
-    private final Map<String, Exporter<?>> exporterMap;
-
-    InjvmExporter(Invoker<T> invoker, String key, Map<String, Exporter<?>> exporterMap) {
-        super(invoker);
-        this.key = key;
-        this.exporterMap = exporterMap;
-        exporterMap.put(key, this);
-    }
-
-    @Override
-    public void afterUnExport() {
-        exporterMap.remove(key);
-    }
-
-}
+/*","[{'comment': 'also', 'commenter': 'AlbumenJ'}]"
6720,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java,"@@ -42,7 +43,7 @@
 /**
  * abstract ProtocolSupport.
  */
-public abstract class AbstractProtocol implements Protocol {
+public abstract class AbstractProtocol implements DelegateExporterMap, Protocol {","[{'comment': ""I think it's better to make `DelegateExporterMap` as AbstractProtocol's property than as its super interface.\r\n\r\nThat is, AbstractProtocol has a `DelegateExporterMap` rather is a `DelegateExporterMap`"", 'commenter': 'chickenlj'}]"
6720,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java,"@@ -1,116 +1,148 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.rpc.protocol;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.ConcurrentHashSet;
-import org.apache.dubbo.remoting.Constants;
-import org.apache.dubbo.rpc.Exporter;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Protocol;
-import org.apache.dubbo.rpc.ProtocolServer;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.support.ProtocolUtils;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-
-import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;
-
-/**
- * abstract ProtocolSupport.
- */
-public abstract class AbstractProtocol implements Protocol {
-
-    protected final Logger logger = LoggerFactory.getLogger(getClass());
-
-    protected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>();
-
-    /**
-     * <host:port, ProtocolServer>
-     */
-    protected final Map<String, ProtocolServer> serverMap = new ConcurrentHashMap<>();
-
-    //TODO SoftReference
-    protected final Set<Invoker<?>> invokers = new ConcurrentHashSet<Invoker<?>>();
-
-    protected static String serviceKey(URL url) {
-        int port = url.getParameter(Constants.BIND_PORT_KEY, url.getPort());
-        return serviceKey(port, url.getPath(), url.getParameter(VERSION_KEY), url.getParameter(GROUP_KEY));
-    }
-
-    protected static String serviceKey(int port, String serviceName, String serviceVersion, String serviceGroup) {
-        return ProtocolUtils.serviceKey(port, serviceName, serviceVersion, serviceGroup);
-    }
-
-    public List<ProtocolServer> getServers() {
-        return Collections.unmodifiableList(new ArrayList<>(serverMap.values()));
-    }
-
-    @Override
-    public void destroy() {
-        for (Invoker<?> invoker : invokers) {
-            if (invoker != null) {
-                invokers.remove(invoker);
-                try {
-                    if (logger.isInfoEnabled()) {
-                        logger.info(""Destroy reference: "" + invoker.getUrl());
-                    }
-                    invoker.destroy();
-                } catch (Throwable t) {
-                    logger.warn(t.getMessage(), t);
-                }
-            }
-        }
-        for (String key : new ArrayList<String>(exporterMap.keySet())) {
-            Exporter<?> exporter = exporterMap.remove(key);
-            if (exporter != null) {
-                try {
-                    if (logger.isInfoEnabled()) {
-                        logger.info(""Unexport service: "" + exporter.getInvoker().getUrl());
-                    }
-                    exporter.unexport();
-                } catch (Throwable t) {
-                    logger.warn(t.getMessage(), t);
-                }
-            }
-        }
-    }
-
-    @Override
-    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
-        return new AsyncToSyncInvoker<>(protocolBindingRefer(type, url));
-    }
-
-    protected abstract <T> Invoker<T> protocolBindingRefer(Class<T> type, URL url) throws RpcException;
-
-    public Map<String, Exporter<?>> getExporterMap() {
-        return exporterMap;
-    }
-
-    public Collection<Exporter<?>> getExporters() {
-        return Collections.unmodifiableCollection(exporterMap.values());
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.ConcurrentHashSet;
+import org.apache.dubbo.remoting.Constants;
+import org.apache.dubbo.rpc.Exporter;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.ProtocolServer;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.support.ProtocolUtils;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;
+
+/**
+ * abstract ProtocolSupport.
+ */
+public abstract class AbstractProtocol implements Protocol {
+
+    protected final Logger logger = LoggerFactory.getLogger(getClass());
+
+    protected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>();
+
+    protected final DelegateExporterMap delegateExporterMap = new DelegateExporterMap() {","[{'comment': 'Can we merge `exporterMap` and `delegateExporterMap` by defining DelegateExporterMap as a Map or have it referencing a map?', 'commenter': 'chickenlj'}, {'comment': ""Pls., also check the failed unit tests. We'll try to merge it quickly this time once ready, thanks."", 'commenter': 'chickenlj'}]"
6773,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/migration/MigrationClusterComparator.java,"@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.support.migration;
+
+import org.apache.dubbo.common.extension.SPI;
+import org.apache.dubbo.rpc.Invoker;
+
+import java.util.List;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more","[{'comment': 'i think you should delete this duplicate license', 'commenter': 'zouyx'}]"
6773,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/migration/MigrationClusterInvoker.java,"@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.support.migration;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.cluster.ClusterInvoker;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more","[{'comment': 'as above', 'commenter': 'zouyx'}]"
6773,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/migration/MigrationRuleTest.java,"@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.support.migration;
+
+import org.junit.jupiter.api.Test;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more","[{'comment': 'as abovw', 'commenter': 'zouyx'}]"
6773,dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java,"@@ -451,11 +451,18 @@ public void setLayer(String layer) {
         this.layer = layer;
     }
 
+    /**
+     * Always use the global ApplicationConfig
+     */
     public ApplicationConfig getApplication() {
-        if (application != null) {
+        ApplicationConfig globalApplication = ApplicationModel.getConfigManager().getApplicationOrElseThrow();
+        if (globalApplication == null) {
+            return application;
+        }
+        if (application != null && !application.getName().equals(globalApplication.getName())) {
             return application;
         }
-        return ApplicationModel.getConfigManager().getApplicationOrElseThrow();
+        return globalApplication;","[{'comment': 'Why change this behaviour?', 'commenter': 'chickenlj'}, {'comment': 'merge from 3.0 ?', 'commenter': 'quhongwei'}]"
6773,dubbo-registry/dubbo-registry-consul/src/main/java/org/apache/dubbo/registry/consul/ConsulServiceDiscoveryFactory.java~HEAD,"@@ -14,15 +14,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.dubbo.registry.multicast;","[{'comment': 'This file and the following should be removed.', 'commenter': 'chickenlj'}]"
6773,dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleRegistryServiceDiscoveryFactory.java,"@@ -0,0 +1,12 @@
+package org.apache.dubbo.registry.multiple;","[{'comment': 'Missing Apache license header', 'commenter': 'chickenlj'}]"
6773,dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleRegistryServiceDiscovery.java,"@@ -0,0 +1,193 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.multiple;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.utils.DefaultPage;
+import org.apache.dubbo.common.utils.Page;
+import org.apache.dubbo.event.ConditionalEventListener;
+import org.apache.dubbo.registry.client.ServiceDiscovery;
+import org.apache.dubbo.registry.client.ServiceDiscoveryFactory;
+import org.apache.dubbo.registry.client.ServiceInstance;
+import org.apache.dubbo.registry.client.event.ServiceInstancesChangedEvent;
+import org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more","[{'comment': 'duplicate license header', 'commenter': 'chickenlj'}]"
6773,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java,"@@ -116,16 +112,10 @@ public void unregister(ServiceInstance serviceInstance) throws RuntimeException
     public void addServiceInstancesChangedListener(ServiceInstancesChangedListener listener)
             throws NullPointerException, IllegalArgumentException {
         execute(namingService, service -> {
-            listener.getServiceNames().forEach(serviceName -> {
-                try {
-                    service.subscribe(serviceName, e -> { // Register Nacos EventListener
-                        if (e instanceof NamingEvent) {
-                            NamingEvent event = (NamingEvent) e;
-                            handleEvent(event, listener);
-                        }
-                    });
-                } catch (NacosException e) {
-                    e.printStackTrace();
+            service.subscribe(listener.getServiceNames(), e -> { // Register Nacos EventListener
+                if (e instanceof NamingEvent) {
+                    NamingEvent event = (NamingEvent) e;
+                    handleEvent(event, listener);","[{'comment': 'Is this outdated changes?', 'commenter': 'chickenlj'}, {'comment': 'merge from dubbo 3.0', 'commenter': 'quhongwei'}]"
6816,dubbo-common/src/main/java/org/apache/dubbo/rpc/service/GenericService.java,"@@ -37,12 +37,24 @@
      */
     Object $invoke(String method, String[] parameterTypes, Object[] args) throws GenericException;
 
+    /**
+     * Call target method on the consumer side asynchronously, the provider side should not be called the $invokeAsync method.
+     *
+     * @param method         Method name, e.g. findPerson. If there are overridden methods, parameter info is
+     *                       required, e.g. findPerson(java.lang.String)
+     * @param parameterTypes Parameter types
+     * @param args           Arguments
+     * @return invocation return value
+     * @throws GenericException potential exception thrown from the invocation
+     */
     default CompletableFuture<Object> $invokeAsync(String method, String[] parameterTypes, Object[] args) throws GenericException {
-        Object object = $invoke(method, parameterTypes, args);
-        if (object instanceof CompletableFuture) {
-            return (CompletableFuture<Object>) object;
-        }
-        return CompletableFuture.completedFuture(object);
+        return CompletableFuture.supplyAsync(() -> {
+            Object object = $invoke(method, parameterTypes, args);
+            // if (object instanceof CompletableFuture) {
+            //     return ((CompletableFuture) object).get();
+            // }
+            return object;
+        });","[{'comment': 'The initial motivation of introducing $invokeAsync is to support the direct calling of methods with the signature of CompletableFuture. \r\n\r\nThis pr seems like a breaking API change for the CompletableFuture instance returned has been changed.\r\n\r\nHow about simply adding the following line to make $invoke asynchronously.\r\n```java\r\nRpcContext.getContext().setAttachment(ASYNC_KEY, ""true"");\r\n```\r\n', 'commenter': 'chickenlj'}, {'comment': '> The initial motivation of introducing $invokeAsync is to support the direct calling of methods with the signature of CompletableFuture.\r\n\r\nCould the $invoke method return a CompletableFuture object?\r\n\r\nIf `$invoke()` is a synchronous call, calling directly here will block the thread, so I want to change it to asynchronous execution, by calling `$invoke()` in `CompletableFuture.supplyAsync()`.', 'commenter': 'kylixs'}, {'comment': '> Could the $invoke method return a CompletableFuture object?\r\n\r\nYes, only if the method signature is like:\r\n```java\r\nclass Service {\r\n     CompletableFuture<String> sayHello(); \r\n}\r\n```', 'commenter': 'chickenlj'}, {'comment': '> If $invoke() is a synchronous call, calling directly here will block the thread,\r\n\r\nYes, you are right, the code before will block the thread. I think adding an ASYNC_KEY attachment would solve this issue while avoiding the previous CompletableFuture instance issue. \r\n\r\n`RpcContext.getContext().setAttachment(ASYNC_KEY, ""true"");`\r\n', 'commenter': 'chickenlj'}, {'comment': '> Yes, only if the method signature is like:\r\n> class Service {\r\n>      CompletableFuture<String> sayHello(); \r\n> }\r\n\r\nThis code should be the implementation code of the Service. The returned CompletableFuture object will be processed during serialization and will not be received on the consumer side. Not sure how the injvm protocol handles this situation.\r\n', 'commenter': 'kylixs'}, {'comment': '>  The returned CompletableFuture object will be processed during serialization and will not be received on the consumer side. \r\n\r\nActually the CompletableFuture is not serialized and transmitted on the wire, it is disassembled at the provider \r\n side and reassembled at the consumer side. Anyway, the completable future instance should not be changed.', 'commenter': 'chickenlj'}, {'comment': 'Sorry, I think I missed something here.\r\n```java\r\nif (object instanceof CompletableFuture) {\r\n      return ((CompletableFuture) object).get();\r\n  }\r\n```\r\n\r\n', 'commenter': 'chickenlj'}]"
6844,dubbo-cluster/pom.xml,"@@ -31,6 +31,11 @@
         <skip_maven_deploy>false</skip_maven_deploy>
     </properties>
     <dependencies>
+        <dependency>
+            <groupId>org.roaringbitmap</groupId>
+            <artifactId>RoaringBitmap</artifactId>
+            <version>0.9.0</version>","[{'comment': 'pls move this field to `dubbo-dependencies` module', 'commenter': 'AlbumenJ'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -98,7 +167,30 @@ private void sort() {
      * @return
      */
     public List<Invoker<T>> route(URL url, Invocation invocation) {
-        List<Invoker<T>> finalInvokers = invokers;
+
+        AddrCache cache = this.cache.get();
+        if (cache == null) {
+            throw new RpcException(RpcException.ROUTER_CACHE_NOT_BUILD, ""Failed to invoke the method ""
+                + invocation.getMethodName() + "" in the service "" + url.getServiceInterface()
+                + "". address cache not build ""
+                + "" on the consumer "" + NetUtils.getLocalHost()
+                + "" using the dubbo version "" + Version.getVersion()
+                + ""."");
+        }
+        BitList<Invoker<T>> finalBitListInvokers = new BitList<Invoker<T>>(invokers, false);
+        for (StateRouter stateRouter : stateRouters) {
+            if (stateRouter.isEnable()) {
+                finalBitListInvokers = stateRouter.route(finalBitListInvokers, cache.getCache().get(stateRouter.getName()), url, invocation);
+            }
+        }
+
+        // FIXME 看一下高版本的RoaringBitMap，是否有内置函数支持更高效的遍历","[{'comment': 'pls comment in English', 'commenter': 'AlbumenJ'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -111,6 +203,96 @@ private void sort() {
      */
     public void setInvokers(List<Invoker<T>> invokers) {
         this.invokers = (invokers == null ? Collections.emptyList() : invokers);
+        stateRouters.forEach(router -> router.notify(this.invokers));
         routers.forEach(router -> router.notify(this.invokers));
+        loop(true);
+    }
+
+    private void buildCache(boolean notify) {
+        if (invokers == null || invokers.size() <= 0) {
+            return;
+        }
+        AddrCache origin = cache.get();
+        List copyInvokers = new ArrayList<>(this.invokers);
+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());
+        AddrCache newCache = new AddrCache();
+        newCache.setInvokers((List)invokers);
+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);
+        for (StateRouter stateRouter : (List<StateRouter>)stateRouters) {
+            if (stateRouter.isEnable()) {
+                executorRepository.getPoolRouterExecutor().execute(new Runnable() {","[{'comment': 'is this executor necessary?', 'commenter': 'AlbumenJ'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -111,6 +203,96 @@ private void sort() {
      */
     public void setInvokers(List<Invoker<T>> invokers) {
         this.invokers = (invokers == null ? Collections.emptyList() : invokers);
+        stateRouters.forEach(router -> router.notify(this.invokers));
         routers.forEach(router -> router.notify(this.invokers));
+        loop(true);
+    }
+
+    private void buildCache(boolean notify) {
+        if (invokers == null || invokers.size() <= 0) {
+            return;
+        }
+        AddrCache origin = cache.get();
+        List copyInvokers = new ArrayList<>(this.invokers);
+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());
+        AddrCache newCache = new AddrCache();
+        newCache.setInvokers((List)invokers);
+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);
+        for (StateRouter stateRouter : (List<StateRouter>)stateRouters) {
+            if (stateRouter.isEnable()) {
+                executorRepository.getPoolRouterExecutor().execute(new Runnable() {
+                    @Override
+                    public void run() {
+                        RouterCache routerCache = null;
+                        try {
+                            routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);
+                            //file cache
+                            newCache.getCache().put(stateRouter.getName(), routerCache);
+                        } catch (Throwable t) {
+                            poolSuccess.set(false);
+                            logger.error(""Failed to pool router: "" + stateRouter.getUrl() + "", cause: "" + t.getMessage(), t);
+                        } finally {
+                            cdl.countDown();
+                        }
+                    }
+                });
+            }
+        }
+        try {
+            cdl.await();
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();","[{'comment': 'is this works? Just wrapped with `RPCException` and throw it would be better?', 'commenter': 'AlbumenJ'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -111,6 +203,96 @@ private void sort() {
      */
     public void setInvokers(List<Invoker<T>> invokers) {
         this.invokers = (invokers == null ? Collections.emptyList() : invokers);
+        stateRouters.forEach(router -> router.notify(this.invokers));
         routers.forEach(router -> router.notify(this.invokers));
+        loop(true);
+    }
+
+    private void buildCache(boolean notify) {
+        if (invokers == null || invokers.size() <= 0) {
+            return;
+        }
+        AddrCache origin = cache.get();
+        List copyInvokers = new ArrayList<>(this.invokers);
+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());
+        AddrCache newCache = new AddrCache();
+        newCache.setInvokers((List)invokers);
+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);
+        for (StateRouter stateRouter : (List<StateRouter>)stateRouters) {
+            if (stateRouter.isEnable()) {
+                executorRepository.getPoolRouterExecutor().execute(new Runnable() {
+                    @Override
+                    public void run() {
+                        RouterCache routerCache = null;
+                        try {
+                            routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);
+                            //file cache
+                            newCache.getCache().put(stateRouter.getName(), routerCache);
+                        } catch (Throwable t) {
+                            poolSuccess.set(false);
+                            logger.error(""Failed to pool router: "" + stateRouter.getUrl() + "", cause: "" + t.getMessage(), t);
+                        } finally {
+                            cdl.countDown();
+                        }
+                    }
+                });
+            }
+        }
+        try {
+            cdl.await();
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+        }
+
+        if (poolSuccess.get()) {
+            this.cache.set(newCache);
+        }
+    }
+
+    private RouterCache poolRouter(StateRouter router, AddrCache orign, List<Invoker<T>> invokers, boolean notify) {
+        String routerName = router.getName();
+        RouterCache routerCache = null;
+        if (isCacheMiss(orign, routerName) || router.shouldRePool() || notify) {
+            return router.pool(invokers);
+        } else {
+            routerCache = orign.getCache().get(routerName);
+        }
+        if (routerCache == null) {
+            return new RouterCache();
+        }
+        return routerCache;
+    }
+
+    private boolean isCacheMiss(AddrCache cache, String routerName) {
+        if (cache == null || cache.getCache() == null || cache.getInvokers() == null || cache.getCache().get(routerName) == null) {
+            return true;
+        }
+        return false;
+    }
+
+    public void loop(boolean notify) {
+        // 1、多个服务并行执行 buildCache","[{'comment': 'Please comment in English', 'commenter': 'AlbumenJ'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -111,6 +203,96 @@ private void sort() {
      */
     public void setInvokers(List<Invoker<T>> invokers) {
         this.invokers = (invokers == null ? Collections.emptyList() : invokers);
+        stateRouters.forEach(router -> router.notify(this.invokers));
         routers.forEach(router -> router.notify(this.invokers));
+        loop(true);
+    }
+
+    private void buildCache(boolean notify) {
+        if (invokers == null || invokers.size() <= 0) {
+            return;
+        }
+        AddrCache origin = cache.get();
+        List copyInvokers = new ArrayList<>(this.invokers);
+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());
+        AddrCache newCache = new AddrCache();
+        newCache.setInvokers((List)invokers);
+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);
+        for (StateRouter stateRouter : (List<StateRouter>)stateRouters) {
+            if (stateRouter.isEnable()) {
+                executorRepository.getPoolRouterExecutor().execute(new Runnable() {
+                    @Override
+                    public void run() {
+                        RouterCache routerCache = null;
+                        try {
+                            routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);
+                            //file cache
+                            newCache.getCache().put(stateRouter.getName(), routerCache);
+                        } catch (Throwable t) {
+                            poolSuccess.set(false);
+                            logger.error(""Failed to pool router: "" + stateRouter.getUrl() + "", cause: "" + t.getMessage(), t);
+                        } finally {
+                            cdl.countDown();
+                        }
+                    }
+                });
+            }
+        }
+        try {
+            cdl.await();
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+        }
+
+        if (poolSuccess.get()) {
+            this.cache.set(newCache);
+        }
+    }
+
+    private RouterCache poolRouter(StateRouter router, AddrCache orign, List<Invoker<T>> invokers, boolean notify) {
+        String routerName = router.getName();
+        RouterCache routerCache = null;
+        if (isCacheMiss(orign, routerName) || router.shouldRePool() || notify) {
+            return router.pool(invokers);
+        } else {
+            routerCache = orign.getCache().get(routerName);
+        }
+        if (routerCache == null) {
+            return new RouterCache();
+        }
+        return routerCache;
+    }
+
+    private boolean isCacheMiss(AddrCache cache, String routerName) {
+        if (cache == null || cache.getCache() == null || cache.getInvokers() == null || cache.getCache().get(routerName) == null) {
+            return true;
+        }
+        return false;
+    }
+
+    public void loop(boolean notify) {
+        // 1、多个服务并行执行 buildCache
+        // 2、notify true/false
+        if (notify) {
+            if (loopPermitNotify.tryAcquire()) {
+                LOOP_THREAD_POOL.submit(new Runnable() {","[{'comment': 'Try make this Runnable as a static class reference or lambda reference. Reduce inner class creation.', 'commenter': 'AlbumenJ'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java,"@@ -0,0 +1,28 @@
+package org.apache.dubbo.rpc.cluster.router.state;","[{'comment': 'Please add Apache License header', 'commenter': 'AlbumenJ'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/BitList.java,"@@ -0,0 +1,216 @@
+package org.apache.dubbo.rpc.cluster.router.state;","[{'comment': 'Please add Apache License header', 'commenter': 'AlbumenJ'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/RouterCache.java,"@@ -0,0 +1,27 @@
+package org.apache.dubbo.rpc.cluster.router.state;","[{'comment': 'Please add Apache License header', 'commenter': 'AlbumenJ'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouterFactory.java,"@@ -0,0 +1,19 @@
+package org.apache.dubbo.rpc.cluster.router.state;","[{'comment': 'Please add Apache License header', 'commenter': 'AlbumenJ'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java,"@@ -0,0 +1,261 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.tag;
+
+import java.net.UnknownHostException;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.config.configcenter.ConfigChangeType;
+import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;
+import org.apache.dubbo.common.config.configcenter.ConfigurationListener;
+import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.RouterChain;
+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;
+import org.apache.dubbo.rpc.cluster.router.state.BitList;
+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;
+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;
+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRuleParser;
+
+import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;
+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;
+import static org.apache.dubbo.rpc.Constants.FORCE_USE_TAG;
+
+/**
+ * TagRouter, ""application.tag-router""
+ */
+public class TagDynamicStateRouter extends AbstractStateRouter implements ConfigurationListener {
+    public static final String NAME = ""TAG_ROUTER"";
+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;
+    private static final Logger logger = LoggerFactory.getLogger(TagDynamicStateRouter.class);
+    private static final String RULE_SUFFIX = "".tag-router"";
+    private static final String NO_TAG = ""noTag"";
+
+    private TagRouterRule tagRouterRule;
+    private String application;
+
+    public TagDynamicStateRouter(URL url, RouterChain chain) {
+        super(url, chain);
+        this.priority = TAG_ROUTER_DEFAULT_PRIORITY;
+    }
+
+    @Override
+    public synchronized void process(ConfigChangedEvent event) {
+        setForce(true);
+        if (logger.isDebugEnabled()) {
+            logger.debug(""Notification of tag rule, change type is: "" + event.getChangeType() + "", raw rule is:\n "" +
+                    event.getContent());
+        }
+
+        try {
+            if (event.getChangeType().equals(ConfigChangeType.DELETED)) {
+                this.tagRouterRule = null;
+            } else {
+                this.tagRouterRule = TagRuleParser.parse(event.getContent());
+            }
+        } catch (Exception e) {
+            logger.error(""Failed to parse the raw tag router rule and it will not take effect, please check if the "" +
+                    ""rule matches with the template, the raw rule is:\n "", e);
+        }
+    }
+
+    @Override
+    public URL getUrl() {
+        return url;
+    }
+
+    @Override
+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url,
+        Invocation invocation) throws RpcException {
+
+
+        final TagRouterRule tagRouterRuleCopy = (TagRouterRule)cache.getAddrMetadata();
+
+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :
+            invocation.getAttachment(TAG_KEY);
+
+        ConcurrentHashMap<String, BitList<Invoker>> addrPool = cache.getAddrPool();
+
+        if (StringUtils.isEmpty(tag)) {
+            return invokers.intersect((BitList)addrPool.get(NO_TAG), invokers.getUnmodifiableList());
+        } else {
+            BitList<Invoker> result = addrPool.get(tag);
+
+            if (CollectionUtils.isNotEmpty(result) || (tagRouterRuleCopy != null && tagRouterRuleCopy.isForce())
+                || isForceUseTag(invocation)) {
+                return invokers.intersect((BitList)result, invokers.getUnmodifiableList());
+            } else {
+                invocation.setAttachment(TAG_KEY, NO_TAG);
+                return invokers;
+            }
+        }
+    }
+
+    private boolean isForceUseTag(Invocation invocation) {
+        return Boolean.valueOf(invocation.getAttachment(FORCE_USE_TAG, url.getParameter(FORCE_USE_TAG, ""false"")));
+    }
+
+    @Override
+    public boolean isRuntime() {
+        return tagRouterRule != null && tagRouterRule.isRuntime();
+    }
+
+    @Override
+    public boolean isEnable() {
+        return true;
+    }
+
+    @Override
+    public boolean isForce() {
+        return tagRouterRule != null && tagRouterRule.isForce();
+    }
+
+    @Override
+    public String getName() {
+        return ""TagDynamic"";
+    }
+
+    @Override
+    public boolean shouldRePool() {
+        return false;
+    }
+
+    @Override
+    public <T> RouterCache pool(List<Invoker<T>> invokers) {
+
+        RouterCache routerCache = new RouterCache();
+        ConcurrentHashMap<String, BitList<Invoker<T>>> addrPool = new ConcurrentHashMap<>();
+
+        final TagRouterRule tagRouterRuleCopy = tagRouterRule;
+
+
+        if (tagRouterRuleCopy == null || !tagRouterRuleCopy.isValid() || !tagRouterRuleCopy.isEnabled()) {
+            return routerCache;
+        }
+
+        List<String> tagNames = tagRouterRuleCopy.getTagNames();
+        Map<String, List<String>> tagnameToAddresses = tagRouterRuleCopy.getTagnameToAddresses();
+
+        for (String tag : tagNames) {
+            List<String> addresses = tagnameToAddresses.get(tag);
+            BitList<Invoker<T>> list = new BitList<>(invokers, true);
+            // 地址为空，则动态路由不生效，直接看静态路由","[{'comment': 'Please comment in English', 'commenter': 'AlbumenJ'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java,"@@ -0,0 +1,261 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.tag;
+
+import java.net.UnknownHostException;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.config.configcenter.ConfigChangeType;
+import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;
+import org.apache.dubbo.common.config.configcenter.ConfigurationListener;
+import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.RouterChain;
+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;
+import org.apache.dubbo.rpc.cluster.router.state.BitList;
+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;
+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;
+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRuleParser;
+
+import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;
+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;
+import static org.apache.dubbo.rpc.Constants.FORCE_USE_TAG;
+
+/**
+ * TagRouter, ""application.tag-router""
+ */
+public class TagDynamicStateRouter extends AbstractStateRouter implements ConfigurationListener {
+    public static final String NAME = ""TAG_ROUTER"";
+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;
+    private static final Logger logger = LoggerFactory.getLogger(TagDynamicStateRouter.class);
+    private static final String RULE_SUFFIX = "".tag-router"";
+    private static final String NO_TAG = ""noTag"";
+
+    private TagRouterRule tagRouterRule;
+    private String application;
+
+    public TagDynamicStateRouter(URL url, RouterChain chain) {
+        super(url, chain);
+        this.priority = TAG_ROUTER_DEFAULT_PRIORITY;
+    }
+
+    @Override
+    public synchronized void process(ConfigChangedEvent event) {
+        setForce(true);
+        if (logger.isDebugEnabled()) {
+            logger.debug(""Notification of tag rule, change type is: "" + event.getChangeType() + "", raw rule is:\n "" +
+                    event.getContent());
+        }
+
+        try {
+            if (event.getChangeType().equals(ConfigChangeType.DELETED)) {
+                this.tagRouterRule = null;
+            } else {
+                this.tagRouterRule = TagRuleParser.parse(event.getContent());
+            }
+        } catch (Exception e) {
+            logger.error(""Failed to parse the raw tag router rule and it will not take effect, please check if the "" +
+                    ""rule matches with the template, the raw rule is:\n "", e);
+        }
+    }
+
+    @Override
+    public URL getUrl() {
+        return url;
+    }
+
+    @Override
+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url,
+        Invocation invocation) throws RpcException {
+
+
+        final TagRouterRule tagRouterRuleCopy = (TagRouterRule)cache.getAddrMetadata();
+
+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :
+            invocation.getAttachment(TAG_KEY);
+
+        ConcurrentHashMap<String, BitList<Invoker>> addrPool = cache.getAddrPool();
+
+        if (StringUtils.isEmpty(tag)) {
+            return invokers.intersect((BitList)addrPool.get(NO_TAG), invokers.getUnmodifiableList());
+        } else {
+            BitList<Invoker> result = addrPool.get(tag);
+
+            if (CollectionUtils.isNotEmpty(result) || (tagRouterRuleCopy != null && tagRouterRuleCopy.isForce())
+                || isForceUseTag(invocation)) {
+                return invokers.intersect((BitList)result, invokers.getUnmodifiableList());
+            } else {
+                invocation.setAttachment(TAG_KEY, NO_TAG);
+                return invokers;
+            }
+        }
+    }
+
+    private boolean isForceUseTag(Invocation invocation) {
+        return Boolean.valueOf(invocation.getAttachment(FORCE_USE_TAG, url.getParameter(FORCE_USE_TAG, ""false"")));
+    }
+
+    @Override
+    public boolean isRuntime() {
+        return tagRouterRule != null && tagRouterRule.isRuntime();
+    }
+
+    @Override
+    public boolean isEnable() {
+        return true;
+    }
+
+    @Override
+    public boolean isForce() {
+        return tagRouterRule != null && tagRouterRule.isForce();
+    }
+
+    @Override
+    public String getName() {
+        return ""TagDynamic"";
+    }
+
+    @Override
+    public boolean shouldRePool() {
+        return false;
+    }
+
+    @Override
+    public <T> RouterCache pool(List<Invoker<T>> invokers) {
+
+        RouterCache routerCache = new RouterCache();
+        ConcurrentHashMap<String, BitList<Invoker<T>>> addrPool = new ConcurrentHashMap<>();","[{'comment': 'try specify inital size', 'commenter': 'AlbumenJ'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -45,11 +69,27 @@
     // instance will never delete or recreate.
     private List<Router> builtinRouters = Collections.emptyList();
 
+    private List<StateRouter> builtinStateRouters = Collections.emptyList();
+    private List<StateRouter> stateRouters = Collections.emptyList();
+    private final ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();","[{'comment': '```suggestion\r\n    private static final ExecutorRepository REPO = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();\r\n```', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -45,11 +69,27 @@
     // instance will never delete or recreate.
     private List<Router> builtinRouters = Collections.emptyList();
 
+    private List<StateRouter> builtinStateRouters = Collections.emptyList();
+    private List<StateRouter> stateRouters = Collections.emptyList();
+    private final ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();
+
+    protected URL url;
+
+    protected AtomicReference<AddrCache> cache = new AtomicReference<>();
+
+    private Semaphore loopPermit = new Semaphore(1);
+    private Semaphore loopPermitNotify = new Semaphore(1);
+
+    private final ExecutorService LOOP_THREAD_POOL;","[{'comment': '```suggestion\r\n    private final ExecutorService  loopPool;\r\n```', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -45,11 +69,27 @@
     // instance will never delete or recreate.
     private List<Router> builtinRouters = Collections.emptyList();
 
+    private List<StateRouter> builtinStateRouters = Collections.emptyList();
+    private List<StateRouter> stateRouters = Collections.emptyList();
+    private final ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();
+
+    protected URL url;
+
+    protected AtomicReference<AddrCache> cache = new AtomicReference<>();
+
+    private Semaphore loopPermit = new Semaphore(1);","[{'comment': '```suggestion\r\n    private final Semaphore loopPermit = new Semaphore(1);\r\n```', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -45,11 +69,27 @@
     // instance will never delete or recreate.
     private List<Router> builtinRouters = Collections.emptyList();
 
+    private List<StateRouter> builtinStateRouters = Collections.emptyList();
+    private List<StateRouter> stateRouters = Collections.emptyList();
+    private final ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();
+
+    protected URL url;
+
+    protected AtomicReference<AddrCache> cache = new AtomicReference<>();
+
+    private Semaphore loopPermit = new Semaphore(1);
+    private Semaphore loopPermitNotify = new Semaphore(1);","[{'comment': '```suggestion\r\n    private final Semaphore loopPermitNotify = new Semaphore(1);\r\n```', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -70,6 +121,15 @@ public void initWithRouters(List<Router> builtinRouters) {
         this.sort();
     }
 
+    public void initWithStateRouters(List<StateRouter> builtinRouters) {
+        this.builtinStateRouters = builtinRouters;
+        this.stateRouters = new ArrayList<>(builtinRouters);
+    }
+
+    private void sortStateRouters() {","[{'comment': 'unused method', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -86,6 +146,13 @@ public void addRouters(List<Router> routers) {
         this.routers = newRouters;
     }
 
+    public void addStateRouters(List<StateRouter> stateRouters) {","[{'comment': 'unused method', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -95,13 +157,35 @@ private void sort() {
     }
 
     /**
-     *
      * @param url
      * @param invocation
      * @return
      */
     public List<Invoker<T>> route(URL url, Invocation invocation) {
-        List<Invoker<T>> finalInvokers = invokers;
+
+        AddrCache cache = this.cache.get();
+        if (cache == null) {
+            throw new RpcException(RpcException.ROUTER_CACHE_NOT_BUILD, ""Failed to invoke the method ""
+                + invocation.getMethodName() + "" in the service "" + url.getServiceInterface()
+                + "". address cache not build ""
+                + "" on the consumer "" + NetUtils.getLocalHost()
+                + "" using the dubbo version "" + Version.getVersion()
+                + ""."");
+        }
+        BitList<Invoker<T>> finalBitListInvokers = new BitList<Invoker<T>>(invokers, false);
+        for (StateRouter stateRouter : stateRouters) {
+            if (stateRouter.isEnable()) {
+                finalBitListInvokers = stateRouter.route(finalBitListInvokers,
+                    cache.getCache().get(stateRouter.getName()), url, invocation);
+            }
+        }
+
+        List<Invoker<T>> finalInvokers = new ArrayList<>(finalBitListInvokers.size());
+        Iterator<Invoker<T>> iter = finalBitListInvokers.iterator();
+        while (iter.hasNext()) {","[{'comment': '```suggestion\r\n        for(Invoker<T> invoker: finalBitListInvokers)\r\n```', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -114,7 +198,87 @@ private void sort() {
      */
     public void setInvokers(List<Invoker<T>> invokers) {
         this.invokers = (invokers == null ? Collections.emptyList() : invokers);
+        stateRouters.forEach(router -> router.notify(this.invokers));
         routers.forEach(router -> router.notify(this.invokers));
+        loop(true);
+    }
+
+    private void buildCache(boolean notify) {
+        if (invokers == null || invokers.size() <= 0) {
+            return;
+        }
+        AddrCache origin = cache.get();
+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);","[{'comment': '```suggestion\r\n        List<Invoker<T>> copyInvokers = new ArrayList<>(this.invokers);\r\n```', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -114,7 +198,87 @@ private void sort() {
      */
     public void setInvokers(List<Invoker<T>> invokers) {
         this.invokers = (invokers == null ? Collections.emptyList() : invokers);
+        stateRouters.forEach(router -> router.notify(this.invokers));
         routers.forEach(router -> router.notify(this.invokers));
+        loop(true);
+    }
+
+    private void buildCache(boolean notify) {
+        if (invokers == null || invokers.size() <= 0) {
+            return;
+        }
+        AddrCache origin = cache.get();
+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);
+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());","[{'comment': 'unused var', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -114,7 +198,87 @@ private void sort() {
      */
     public void setInvokers(List<Invoker<T>> invokers) {
         this.invokers = (invokers == null ? Collections.emptyList() : invokers);
+        stateRouters.forEach(router -> router.notify(this.invokers));
         routers.forEach(router -> router.notify(this.invokers));
+        loop(true);
+    }
+
+    private void buildCache(boolean notify) {
+        if (invokers == null || invokers.size() <= 0) {
+            return;
+        }
+        AddrCache origin = cache.get();
+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);
+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());
+        AddrCache newCache = new AddrCache();
+        newCache.setInvokers((List)invokers);
+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);","[{'comment': 'remove this var ', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -114,7 +198,87 @@ private void sort() {
      */
     public void setInvokers(List<Invoker<T>> invokers) {
         this.invokers = (invokers == null ? Collections.emptyList() : invokers);
+        stateRouters.forEach(router -> router.notify(this.invokers));
         routers.forEach(router -> router.notify(this.invokers));
+        loop(true);
+    }
+
+    private void buildCache(boolean notify) {
+        if (invokers == null || invokers.size() <= 0) {
+            return;
+        }
+        AddrCache origin = cache.get();
+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);
+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());
+        AddrCache newCache = new AddrCache();
+        newCache.setInvokers((List)invokers);
+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);
+        for (StateRouter stateRouter : stateRouters) {
+            RouterCache routerCache;","[{'comment': '```suggestion\r\n          \r\n            try{\r\n              for(;;)\r\n              this.cache.set()\r\n              }catch{\r\n              }\r\n```', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -114,7 +198,87 @@ private void sort() {
      */
     public void setInvokers(List<Invoker<T>> invokers) {
         this.invokers = (invokers == null ? Collections.emptyList() : invokers);
+        stateRouters.forEach(router -> router.notify(this.invokers));
         routers.forEach(router -> router.notify(this.invokers));
+        loop(true);
+    }
+
+    private void buildCache(boolean notify) {
+        if (invokers == null || invokers.size() <= 0) {
+            return;
+        }
+        AddrCache origin = cache.get();
+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);
+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());
+        AddrCache newCache = new AddrCache();
+        newCache.setInvokers((List)invokers);
+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);
+        for (StateRouter stateRouter : stateRouters) {
+            RouterCache routerCache;
+            try {
+                routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);
+                //file cache
+                newCache.getCache().put(stateRouter.getName(), routerCache);
+            } catch (Throwable t) {
+                poolSuccess.set(false);
+                logger.error(""Failed to pool router: "" + stateRouter.getUrl() + "", cause: "" + t.getMessage(), t);
+            } finally {
+                cdl.countDown();
+            }
+        }
+
+        if (poolSuccess.get()) {
+            this.cache.set(newCache);
+        }
+    }
+
+    private RouterCache poolRouter(StateRouter router, AddrCache orign, List<Invoker<T>> invokers, boolean notify) {
+        String routerName = router.getName();
+        RouterCache routerCache = null;","[{'comment': '```suggestion\r\n        RouterCache routerCache ;\r\n```', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -114,7 +198,87 @@ private void sort() {
      */
     public void setInvokers(List<Invoker<T>> invokers) {
         this.invokers = (invokers == null ? Collections.emptyList() : invokers);
+        stateRouters.forEach(router -> router.notify(this.invokers));
         routers.forEach(router -> router.notify(this.invokers));
+        loop(true);
+    }
+
+    private void buildCache(boolean notify) {
+        if (invokers == null || invokers.size() <= 0) {
+            return;
+        }
+        AddrCache origin = cache.get();
+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);
+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());
+        AddrCache newCache = new AddrCache();
+        newCache.setInvokers((List)invokers);
+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);
+        for (StateRouter stateRouter : stateRouters) {
+            RouterCache routerCache;
+            try {
+                routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);
+                //file cache
+                newCache.getCache().put(stateRouter.getName(), routerCache);
+            } catch (Throwable t) {
+                poolSuccess.set(false);
+                logger.error(""Failed to pool router: "" + stateRouter.getUrl() + "", cause: "" + t.getMessage(), t);
+            } finally {
+                cdl.countDown();
+            }
+        }
+
+        if (poolSuccess.get()) {
+            this.cache.set(newCache);
+        }
+    }
+
+    private RouterCache poolRouter(StateRouter router, AddrCache orign, List<Invoker<T>> invokers, boolean notify) {
+        String routerName = router.getName();
+        RouterCache routerCache = null;
+        if (isCacheMiss(orign, routerName) || router.shouldRePool() || notify) {
+            return router.pool(invokers);
+        } else {
+            routerCache = orign.getCache().get(routerName);
+        }
+        if (routerCache == null) {
+            return new RouterCache();
+        }
+        return routerCache;
+    }
+
+    private boolean isCacheMiss(AddrCache cache, String routerName) {
+        if (cache == null || cache.getCache() == null || cache.getInvokers() == null || cache.getCache().get(routerName)","[{'comment': '```suggestion\r\n              return cache == null || cache.getCache() == null || cache.getInvokers() == null || \r\n                cache.getCache().get(routerName) == null;\r\n```', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouter.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.state;
+
+import java.util.List;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.Directory;
+
+/**
+ * Router. (SPI, Prototype, ThreadSafe)
+ * <p>
+ * <a href=""http://en.wikipedia.org/wiki/Routing"">Routing</a>
+ *
+ * @see org.apache.dubbo.rpc.cluster.Cluster#join(Directory)
+ * @see Directory#list(Invocation)
+ */
+public interface StateRouter extends Comparable<StateRouter> {","[{'comment': '```suggestion\r\npublic interface StateRouter<T> extends Comparable<StateRouter<T>>\r\n\r\n```', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouter.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.state;
+
+import java.util.List;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.Directory;
+
+/**
+ * Router. (SPI, Prototype, ThreadSafe)
+ * <p>
+ * <a href=""http://en.wikipedia.org/wiki/Routing"">Routing</a>
+ *
+ * @see org.apache.dubbo.rpc.cluster.Cluster#join(Directory)
+ * @see Directory#list(Invocation)
+ */
+public interface StateRouter extends Comparable<StateRouter> {
+
+    int DEFAULT_PRIORITY = Integer.MAX_VALUE;
+
+    /**
+     * Get the router url.
+     *
+     * @return url
+     */
+    URL getUrl();
+
+    /**
+     * Filter invokers with current routing rule and only return the invokers that comply with the rule.
+     *
+     * @param invokers   invoker list
+     * @param url        refer url
+     * @param invocation invocation
+     * @return routed invokers
+     * @throws RpcException
+     */
+    <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url, Invocation invocation)","[{'comment': '```suggestion\r\nBitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url, Invocation invocation)\r\n\r\n```', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouter.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.state;
+
+import java.util.List;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.Directory;
+
+/**
+ * Router. (SPI, Prototype, ThreadSafe)
+ * <p>
+ * <a href=""http://en.wikipedia.org/wiki/Routing"">Routing</a>
+ *
+ * @see org.apache.dubbo.rpc.cluster.Cluster#join(Directory)
+ * @see Directory#list(Invocation)
+ */
+public interface StateRouter extends Comparable<StateRouter> {
+
+    int DEFAULT_PRIORITY = Integer.MAX_VALUE;
+
+    /**
+     * Get the router url.
+     *
+     * @return url
+     */
+    URL getUrl();
+
+    /**
+     * Filter invokers with current routing rule and only return the invokers that comply with the rule.
+     *
+     * @param invokers   invoker list
+     * @param url        refer url
+     * @param invocation invocation
+     * @return routed invokers
+     * @throws RpcException
+     */
+    <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url, Invocation invocation)
+        throws
+        RpcException;
+
+    default <T> void notify(List<Invoker<T>> invokers) {
+
+    }
+
+    /**
+     * To decide whether this router need to execute every time an RPC comes or should only execute when addresses or
+     * rule change.
+     *
+     * @return true if the router need to execute every time.
+     */
+    boolean isRuntime();
+
+    boolean isEnable();
+
+    boolean isForce();
+
+    int getPriority();
+
+    @Override
+    default int compareTo(StateRouter o) {
+        if (o == null) {
+            throw new IllegalArgumentException();
+        }
+        return Integer.compare(this.getPriority(), o.getPriority());
+    }
+
+    String getName();
+
+    boolean shouldRePool();
+
+    <T> RouterCache pool(List<Invoker<T>> invokers);","[{'comment': '```suggestion\r\n     RouterCache pool(List<Invoker<T>> invokers);\r\n\r\n```', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouterFactory.java,"@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.state;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Adaptive;
+import org.apache.dubbo.common.extension.SPI;
+import org.apache.dubbo.rpc.cluster.RouterChain;
+
+@SPI
+public interface StateRouterFactory {
+    /**
+     * Create router.
+     * Since 2.7.0, most of the time, we will not use @Adaptive feature, so it's kept only for compatibility.
+     *
+     * @param url url
+     * @return router instance
+     */
+    @Adaptive(""protocol"")
+    StateRouter getRouter(URL url, RouterChain chain);","[{'comment': '```suggestion\r\n       <T> StateRouter<T> getRouter(URL url, RouterChain<T> chain);\r\n```', 'commenter': 'guohao'}]"
6844,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/RouterCache.java,"@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.state;
+
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.dubbo.rpc.Invoker;
+
+public class RouterCache {","[{'comment': '```suggestion\r\nRouterCache<T> \r\n```', 'commenter': 'guohao'}]"
6848,dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ObjectInput.java,"@@ -109,4 +110,12 @@ public Object readObject() throws IOException {
     public InputStream readInputStream() throws IOException {
         return mH2i.readInputStream();
     }
+
+	@Override
+	public void cleanup() {
+		// TODO Auto-generated method stub","[{'comment': 'remove the comment', 'commenter': 'kimmking'}, {'comment': 'ok', 'commenter': 'luckyyuandm'}]"
6848,dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ObjectInput.java,"@@ -28,7 +29,7 @@
 /**
  * Hessian2 object input implementation
  */
-public class Hessian2ObjectInput implements ObjectInput {
+public class Hessian2ObjectInput implements ObjectInput,Cleanable {","[{'comment': 'keep a blank before Cleanable', 'commenter': 'kimmking'}, {'comment': 'ok', 'commenter': 'luckyyuandm'}]"
6848,dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ObjectOutput.java,"@@ -106,4 +107,12 @@ public void flushBuffer() throws IOException {
     public OutputStream getOutputStream() throws IOException {
         return mH2o.getBytesOutputStream();
     }
+
+	@Override
+	public void cleanup() {
+		// TODO Auto-generated method stub","[{'comment': 'remove comment', 'commenter': 'kimmking'}, {'comment': 'ok', 'commenter': 'luckyyuandm'}]"
6848,dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ObjectOutput.java,"@@ -27,7 +28,7 @@
 /**
  * Hessian2 object output implementation
  */
-public class Hessian2ObjectOutput implements ObjectOutput {
+public class Hessian2ObjectOutput implements ObjectOutput,Cleanable {","[{'comment': 'keep a blank before Cleanable', 'commenter': 'kimmking'}, {'comment': 'ok', 'commenter': 'luckyyuandm'}]"
6860,dubbo-compatible/src/test/java/org/apache/dubbo/filter/FilterTest.java,"@@ -1,60 +0,0 @@
-/*","[{'comment': 'Could you pls describe why you remove this class?', 'commenter': 'AlbumenJ'}]"
6867,dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/ClassUtils.java,"@@ -1,445 +1,445 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.common.compiler.support;
-
-import org.apache.dubbo.common.utils.StringUtils;
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.lang.reflect.Array;
-import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.lang.reflect.TypeVariable;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * ClassUtils. (Tool, Static, ThreadSafe)
- */
-public class ClassUtils {
-
-    public static final String CLASS_EXTENSION = "".class"";
-
-    public static final String JAVA_EXTENSION = "".java"";
-    private static final int JIT_LIMIT = 5 * 1024;
-
-    private ClassUtils() {
-    }
-
-    public static Object newInstance(String name) {
-        try {
-            return forName(name).newInstance();
-        } catch (InstantiationException | IllegalAccessException e) {
-            throw new IllegalStateException(e.getMessage(), e);
-        }
-    }
-
-    public static Class<?> forName(String[] packages, String className) {
-        try {
-            return classForName(className);
-        } catch (ClassNotFoundException e) {
-            if (packages != null && packages.length > 0) {
-                for (String pkg : packages) {
-                    try {
-                        return classForName(pkg + ""."" + className);
-                    } catch (ClassNotFoundException e2) {
-                    }
-                }
-            }
-            throw new IllegalStateException(e.getMessage(), e);
-        }
-    }
-
-    public static Class<?> forName(String className) {
-        try {
-            return classForName(className);
-        } catch (ClassNotFoundException e) {
-            throw new IllegalStateException(e.getMessage(), e);
-        }
-    }
-
-    public static Class<?> classForName(String className) throws ClassNotFoundException {
-        switch (className) {
-            case ""boolean"":
-                return boolean.class;
-            case ""byte"":
-                return byte.class;
-            case ""char"":
-                return char.class;
-            case ""short"":
-                return short.class;
-            case ""int"":
-                return int.class;
-            case ""long"":
-                return long.class;
-            case ""float"":
-                return float.class;
-            case ""double"":
-                return double.class;
-            case ""boolean[]"":
-                return boolean[].class;
-            case ""byte[]"":
-                return byte[].class;
-            case ""char[]"":
-                return char[].class;
-            case ""short[]"":
-                return short[].class;
-            case ""int[]"":
-                return int[].class;
-            case ""long[]"":
-                return long[].class;
-            case ""float[]"":
-                return float[].class;
-            case ""double[]"":
-                return double[].class;
-            default:
-        }
-        try {
-            return arrayForName(className);
-        } catch (ClassNotFoundException e) {
-            // try to load from java.lang package
-            if (className.indexOf('.') == -1) {
-                try {
-                    return arrayForName(""java.lang."" + className);
-                } catch (ClassNotFoundException e2) {
-                    // ignore, let the original exception be thrown
-                }
-            }
-            throw e;
-        }
-    }
-
-    private static Class<?> arrayForName(String className) throws ClassNotFoundException {
-        return Class.forName(className.endsWith(""[]"")
-                ? ""[L"" + className.substring(0, className.length() - 2) + "";""
-                : className, true, Thread.currentThread().getContextClassLoader());
-    }
-
-    public static Class<?> getBoxedClass(Class<?> type) {
-        if (type == boolean.class) {
-            return Boolean.class;
-        } else if (type == char.class) {
-            return Character.class;
-        } else if (type == byte.class) {
-            return Byte.class;
-        } else if (type == short.class) {
-            return Short.class;
-        } else if (type == int.class) {
-            return Integer.class;
-        } else if (type == long.class) {
-            return Long.class;
-        } else if (type == float.class) {
-            return Float.class;
-        } else if (type == double.class) {
-            return Double.class;
-        } else {
-            return type;
-        }
-    }
-
-    public static Boolean boxed(boolean v) {
-        return Boolean.valueOf(v);
-    }
-
-    public static Character boxed(char v) {
-        return Character.valueOf(v);
-    }
-
-    public static Byte boxed(byte v) {
-        return Byte.valueOf(v);
-    }
-
-    public static Short boxed(short v) {
-        return Short.valueOf(v);
-    }
-
-    public static Integer boxed(int v) {
-        return Integer.valueOf(v);
-    }
-
-    public static Long boxed(long v) {
-        return Long.valueOf(v);
-    }
-
-    public static Float boxed(float v) {
-        return Float.valueOf(v);
-    }
-
-    public static Double boxed(double v) {
-        return Double.valueOf(v);
-    }
-
-    public static Object boxed(Object v) {
-        return v;
-    }
-
-    public static boolean unboxed(Boolean v) {
-        return v == null ? false : v.booleanValue();
-    }
-
-    public static char unboxed(Character v) {
-        return v == null ? '\0' : v.charValue();
-    }
-
-    public static byte unboxed(Byte v) {
-        return v == null ? 0 : v.byteValue();
-    }
-
-    public static short unboxed(Short v) {
-        return v == null ? 0 : v.shortValue();
-    }
-
-    public static int unboxed(Integer v) {
-        return v == null ? 0 : v.intValue();
-    }
-
-    public static long unboxed(Long v) {
-        return v == null ? 0 : v.longValue();
-    }
-
-    public static float unboxed(Float v) {
-        return v == null ? 0 : v.floatValue();
-    }
-
-    public static double unboxed(Double v) {
-        return v == null ? 0 : v.doubleValue();
-    }
-
-    public static Object unboxed(Object v) {
-        return v;
-    }
-
-    public static boolean isNotEmpty(Object object) {
-        return getSize(object) > 0;
-    }
-
-    public static int getSize(Object object) {
-        if (object == null) {
-            return 0;
-        }
-        if (object instanceof Collection<?>) {
-            return ((Collection<?>) object).size();
-        } else if (object instanceof Map<?, ?>) {
-            return ((Map<?, ?>) object).size();
-        } else if (object.getClass().isArray()) {
-            return Array.getLength(object);
-        } else {
-            return -1;
-        }
-    }
-
-    public static URI toURI(String name) {
-        try {
-            return new URI(name);
-        } catch (URISyntaxException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    public static Class<?> getGenericClass(Class<?> cls) {
-        return getGenericClass(cls, 0);
-    }
-
-    public static Class<?> getGenericClass(Class<?> cls, int i) {
-        try {
-            ParameterizedType parameterizedType = ((ParameterizedType) cls.getGenericInterfaces()[0]);
-            Object genericClass = parameterizedType.getActualTypeArguments()[i];
-            if (genericClass instanceof ParameterizedType) {
-                return (Class<?>) ((ParameterizedType) genericClass).getRawType();
-            } else if (genericClass instanceof GenericArrayType) {
-                Type type = ((GenericArrayType) genericClass).getGenericComponentType();
-                if (type instanceof TypeVariable) {
-                    return type.getClass();
-                }
-                return (((GenericArrayType) genericClass).getGenericComponentType() instanceof Class<?>)
-                        ? (Class<?>) ((GenericArrayType) genericClass).getGenericComponentType()
-                        : ((GenericArrayType) genericClass).getGenericComponentType().getClass();
-            } else if (genericClass != null) {
-                if (genericClass instanceof TypeVariable) {
-                    return genericClass.getClass();
-                }
-                return (Class<?>) genericClass;
-            }
-        } catch (Throwable e) {
-
-        }
-        if (cls.getSuperclass() != null) {
-            return getGenericClass(cls.getSuperclass(), i);
-        } else {
-            throw new IllegalArgumentException(cls.getName() + "" generic type undefined!"");
-        }
-    }
-
-    public static boolean isBeforeJava5(String javaVersion) {
-        return (StringUtils.isEmpty(javaVersion) || ""1.0"".equals(javaVersion)
-                || ""1.1"".equals(javaVersion) || ""1.2"".equals(javaVersion)
-                || ""1.3"".equals(javaVersion) || ""1.4"".equals(javaVersion));
-    }
-
-    public static boolean isBeforeJava6(String javaVersion) {
-        return isBeforeJava5(javaVersion) || ""1.5"".equals(javaVersion);
-    }
-
-    public static String toString(Throwable e) {
-        StringWriter w = new StringWriter();
-        PrintWriter p = new PrintWriter(w);
-        p.print(e.getClass().getName() + "": "");
-        if (e.getMessage() != null) {
-            p.print(e.getMessage() + ""\n"");
-        }
-        p.println();
-        try {
-            e.printStackTrace(p);
-            return w.toString();
-        } finally {
-            p.close();
-        }
-    }
-
-    public static void checkBytecode(String name, byte[] bytecode) {
-        if (bytecode.length > JIT_LIMIT) {
-            System.err.println(""The template bytecode too long, may be affect the JIT compiler. template class: "" + name);
-        }
-    }
-
-    public static String getSizeMethod(Class<?> cls) {
-        try {
-            return cls.getMethod(""size"", new Class<?>[0]).getName() + ""()"";
-        } catch (NoSuchMethodException e) {
-            try {
-                return cls.getMethod(""length"", new Class<?>[0]).getName() + ""()"";
-            } catch (NoSuchMethodException e2) {
-                try {
-                    return cls.getMethod(""getSize"", new Class<?>[0]).getName() + ""()"";
-                } catch (NoSuchMethodException e3) {
-                    try {
-                        return cls.getMethod(""getLength"", new Class<?>[0]).getName() + ""()"";
-                    } catch (NoSuchMethodException e4) {
-                        return null;
-                    }
-                }
-            }
-        }
-    }
-
-    public static String getMethodName(Method method, Class<?>[] parameterClasses, String rightCode) {
-        if (method.getParameterTypes().length > parameterClasses.length) {
-            Class<?>[] types = method.getParameterTypes();
-            StringBuilder buf = new StringBuilder(rightCode);
-            for (int i = parameterClasses.length; i < types.length; i++) {
-                if (buf.length() > 0) {
-                    buf.append("","");
-                }
-                Class<?> type = types[i];
-                String def;
-                if (type == boolean.class) {
-                    def = ""false"";
-                } else if (type == char.class) {
-                    def = ""\'\\0\'"";
-                } else if (type == byte.class
-                        || type == short.class
-                        || type == int.class
-                        || type == long.class
-                        || type == float.class
-                        || type == double.class) {
-                    def = ""0"";
-                } else {
-                    def = ""null"";
-                }
-                buf.append(def);
-            }
-        }
-        return method.getName() + ""("" + rightCode + "")"";
-    }
-
-    public static Method searchMethod(Class<?> currentClass, String name, Class<?>[] parameterTypes) throws NoSuchMethodException {
-        if (currentClass == null) {
-            throw new NoSuchMethodException(""class == null"");
-        }
-        try {
-            return currentClass.getMethod(name, parameterTypes);
-        } catch (NoSuchMethodException e) {
-            for (Method method : currentClass.getMethods()) {
-                if (method.getName().equals(name)
-                        && parameterTypes.length == method.getParameterTypes().length
-                        && Modifier.isPublic(method.getModifiers())) {
-                    if (parameterTypes.length > 0) {
-                        Class<?>[] types = method.getParameterTypes();
-                        boolean match = true;
-                        for (int i = 0; i < parameterTypes.length; i++) {
-                            if (!types[i].isAssignableFrom(parameterTypes[i])) {
-                                match = false;
-                                break;
-                            }
-                        }
-                        if (!match) {
-                            continue;
-                        }
-                    }
-                    return method;
-                }
-            }
-            throw e;
-        }
-    }
-
-    public static String getInitCode(Class<?> type) {
-        if (byte.class.equals(type)
-                || short.class.equals(type)
-                || int.class.equals(type)
-                || long.class.equals(type)
-                || float.class.equals(type)
-                || double.class.equals(type)) {
-            return ""0"";
-        } else if (char.class.equals(type)) {
-            return ""'\\0'"";
-        } else if (boolean.class.equals(type)) {
-            return ""false"";
-        } else {
-            return ""null"";
-        }
-    }
-
-    public static <K, V> Map<K, V> toMap(Map.Entry<K, V>[] entries) {
-        Map<K, V> map = new HashMap<K, V>();
-        if (entries != null && entries.length > 0) {
-            for (Map.Entry<K, V> entry : entries) {
-                map.put(entry.getKey(), entry.getValue());
-            }
-        }
-        return map;
-    }
-    
-    /**
-     * get simple class name from qualified class name
-     */
-    public static String getSimpleClassName(String qualifiedName) {
-        if (null == qualifiedName) {
-            return null;
-        }
-        
-        int i = qualifiedName.lastIndexOf('.');
-        return i < 0 ? qualifiedName : qualifiedName.substring(i + 1);
-    }
-
-}
+/*","[{'comment': 'Pls recover end-line format of this file', 'commenter': 'AlbumenJ'}, {'comment': ""it's CRLF to LF problem. recover it already."", 'commenter': 'leechor'}]"
6966,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvoker.java,"@@ -20,19 +20,19 @@
 import org.apache.dubbo.common.logger.Logger;
 import org.apache.dubbo.common.logger.LoggerFactory;
 import org.apache.dubbo.common.utils.NetUtils;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.RpcContext;
-import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.remoting.RemotingException;
+import org.apache.dubbo.rpc.*;","[{'comment': 'please do not use comma import', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'wikiwikiwiki'}]"
6980,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"@@ -208,7 +189,15 @@ private void registerStatedUrl(URL registryUrl, URL registeredProviderUrl, boole
 
         // url to registry
         final Registry registry = getRegistry(registryUrl);
-        final URL registeredProviderUrl = getUrlToRegistry(providerUrl, registryUrl);
+
+        URL regUrl = getUrlToRegistry(providerUrl, registryUrl);
+
+        String dockerHostBind  = ConfigUtils.getSystemProperty(DOCKER_DUBBO_IP_TO_BIND);","[{'comment': 'I think The `DUBBO_IP_TO_BIND` and `DUBBO_IP_TO_REGISTRY` jvm properties have already covered this scenario.', 'commenter': 'chickenlj'}]"
6987,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mock/MockInvokersSelector.java,"@@ -63,41 +63,31 @@ public MockInvokersSelector() {
     }
 
     private <T> List<Invoker<T>> getMockedInvokers(final List<Invoker<T>> invokers) {
-        if (!hasMockProviders(invokers)) {
-            return null;
-        }
         List<Invoker<T>> sInvokers = new ArrayList<Invoker<T>>(1);
         for (Invoker<T> invoker : invokers) {
-            if (invoker.getUrl().getProtocol().equals(MOCK_PROTOCOL)) {
+            if (isMockProtocol(invoker)) {
                 sInvokers.add(invoker);
             }
         }
         return sInvokers;
     }
 
     private <T> List<Invoker<T>> getNormalInvokers(final List<Invoker<T>> invokers) {
-        if (!hasMockProviders(invokers)) {
-            return invokers;","[{'comment': ""On most occasions, the call will hit this if branch and return directly.  I don't think the new way will bring any performance impromement."", 'commenter': 'chickenlj'}, {'comment': ""> On most occasions, the call will hit this if branch and return directly. I don't think the new way will bring any performance impromement.\r\n\r\nThere are no obvious differences of performance between the previous way and the new way. However, the simple changes can make the code have better reusability and readability. @chickenlj "", 'commenter': 'pinxiong'}, {'comment': ""I worry there'll have a performance drop for allocating Arraylist for every call."", 'commenter': 'chickenlj'}, {'comment': ""You're right, thanks!"", 'commenter': 'pinxiong'}]"
7039,dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java,"@@ -470,6 +470,16 @@ public static boolean isServiceKeyMatch(URL pattern, URL value) {
     }
 
     public static List<URL> classifyUrls(List<URL> urls, Predicate<URL> predicate) {
+        boolean filter = false;
+        for (URL url : urls) {
+            if (!predicate.test(url)) {
+                filter = true;
+                break;
+            }
+        }
+        if (!filter) {
+            return urls;","[{'comment': 'keep an outer variable is dangerous.', 'commenter': 'kimmking'}, {'comment': 'Better wrapping `urls` with unmodifiable?', 'commenter': 'chickenlj'}, {'comment': ""Let's keep this snippet as-is for this is not a critical path for performance improvement."", 'commenter': 'chickenlj'}]"
7045,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -41,11 +66,35 @@
     // Fixed router instances: ConfigConditionRouter, TagRouter, e.g., the rule for each instance may change but the
     // instance will never delete or recreate.
     private List<Router> builtinRouters = Collections.emptyList();
+    private List<StateRouter> builtinStateRouters = Collections.emptyList();
+    private List<StateRouter> stateRouters = Collections.emptyList();
+
+    protected URL url;
+
+    protected AtomicReference<AddrCache> cache = new AtomicReference<>();
+    private Semaphore loopPermit = new Semaphore(1);
+
+    private final static ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(1,
+        new NamedInternalThreadFactory(""dubbo-state-router-scheduled-"", true));
+
+    private final static ExecutorService loopThreadPool = new ThreadPoolExecutor(1, 1,","[{'comment': '`loopThreadPool`和`poolRouterThreadPool` 可以合并成一个吗', 'commenter': 'guohao'}, {'comment': '之前好像提过，可能会死锁？', 'commenter': 'panxiaojun233'}]"
7045,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -111,6 +217,94 @@ private void sort() {
      */
     public void setInvokers(List<Invoker<T>> invokers) {
         this.invokers = (invokers == null ? Collections.emptyList() : invokers);
+        stateRouters.forEach(router -> router.notify(this.invokers));
         routers.forEach(router -> router.notify(this.invokers));
+        loop(true);
+    }
+
+    private void buildCache(boolean notify) {
+        if (invokers == null || invokers.size() <= 0) {
+            return;
+        }
+        AddrCache origin = cache.get();
+        List copyInvokers = new ArrayList<>(this.invokers);
+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());
+        AddrCache newCache = new AddrCache();
+        newCache.setInvokers((List)invokers);
+        for (StateRouter stateRouter : (List<StateRouter>)stateRouters) {
+            if (stateRouter.isEnable()) {
+                poolRouterThreadPool.execute(new Runnable() {
+                    @Override
+                    public void run() {
+                        RouterCache routerCache = null;
+                        try {
+                            routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);
+                            //file cache
+                            newCache.getCache().put(stateRouter.getName(), routerCache);
+                        } catch (Throwable t) {
+                            logger.error(""Failed to pool router: "" + stateRouter.getUrl() + "", cause: "" + t.getMessage(), t);","[{'comment': '这里如果失败了，是否不该使用newCache替换原有cache？', 'commenter': 'guohao'}]"
7045,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -111,6 +217,94 @@ private void sort() {
      */
     public void setInvokers(List<Invoker<T>> invokers) {
         this.invokers = (invokers == null ? Collections.emptyList() : invokers);
+        stateRouters.forEach(router -> router.notify(this.invokers));
         routers.forEach(router -> router.notify(this.invokers));
+        loop(true);
+    }
+
+    private void buildCache(boolean notify) {
+        if (invokers == null || invokers.size() <= 0) {
+            return;
+        }
+        AddrCache origin = cache.get();
+        List copyInvokers = new ArrayList<>(this.invokers);
+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());
+        AddrCache newCache = new AddrCache();
+        newCache.setInvokers((List)invokers);
+        for (StateRouter stateRouter : (List<StateRouter>)stateRouters) {
+            if (stateRouter.isEnable()) {
+                poolRouterThreadPool.execute(new Runnable() {
+                    @Override
+                    public void run() {
+                        RouterCache routerCache = null;
+                        try {
+                            routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);
+                            //file cache
+                            newCache.getCache().put(stateRouter.getName(), routerCache);
+                        } catch (Throwable t) {
+                            logger.error(""Failed to pool router: "" + stateRouter.getUrl() + "", cause: "" + t.getMessage(), t);
+                        } finally {
+                            cdl.countDown();
+                        }
+                    }
+                });
+            }
+        }
+        try {
+            cdl.await();
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+        }
+
+        this.cache.set(newCache);","[{'comment': '如上', 'commenter': 'guohao'}]"
7045,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AbstractStateRouter.java,"@@ -0,0 +1,69 @@
+package org.apache.dubbo.rpc.cluster.router.state;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.cluster.governance.GovernanceRuleRepository;
+
+public abstract class AbstractStateRouter implements StateRouter {
+    protected int priority = DEFAULT_PRIORITY;
+    protected boolean force = false;","[{'comment': '是否会有线程安全问题，换成 Atomic?', 'commenter': 'guohao'}]"
7045,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java,"@@ -0,0 +1,260 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.tag;
+
+import java.net.UnknownHostException;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.config.configcenter.ConfigChangeType;
+import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;
+import org.apache.dubbo.common.config.configcenter.ConfigurationListener;
+import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.BitList;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;
+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;
+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;
+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRuleParser;
+
+import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;
+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;
+import static org.apache.dubbo.rpc.Constants.FORCE_USE_TAG;
+
+/**
+ * TagRouter, ""application.tag-router""
+ */
+public class TagDynamicStateRouter extends AbstractStateRouter implements ConfigurationListener {
+    public static final String NAME = ""TAG_ROUTER"";
+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;
+    private static final Logger logger = LoggerFactory.getLogger(TagDynamicStateRouter.class);
+    private static final String RULE_SUFFIX = "".tag-router"";
+    private static final String NO_TAG = ""noTag"";
+
+    private TagRouterRule tagRouterRule;
+    private String application;
+
+    public TagDynamicStateRouter(URL url) {
+        super(url);
+        this.priority = TAG_ROUTER_DEFAULT_PRIORITY;
+    }
+
+    @Override
+    public synchronized void process(ConfigChangedEvent event) {","[{'comment': '这里应该需要 setForce(true)', 'commenter': 'guohao'}]"
7045,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.tag;
+
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.BitList;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;
+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;
+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;
+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;
+
+/**
+ * TagRouter, ""application.tag-router""
+ */
+public class TagStaticStateRouter extends AbstractStateRouter {
+    public static final String NAME = ""TAG_ROUTER"";
+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;
+    private static final Logger logger = LoggerFactory.getLogger(TagStaticStateRouter.class);
+    private static final String RULE_SUFFIX = "".tag-router"";
+    private static final String NO_TAG = ""noTag"";
+
+    private TagRouterRule tagRouterRule;
+
+    public TagStaticStateRouter(URL url) {
+        super(url);
+        this.priority = TAG_ROUTER_DEFAULT_PRIORITY;
+    }
+
+    @Override
+    public URL getUrl() {
+        return url;
+    }
+
+    @Override
+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache routerCache, URL url, Invocation invocation)
+        throws RpcException {
+
+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :
+            invocation.getAttachment(TAG_KEY);
+        if (StringUtils.isEmpty(tag)) {
+            tag = NO_TAG;
+        }
+
+        ConcurrentHashMap<String, BitList<Invoker>> pool = routerCache.getAddrPool();
+        BitList res = pool.get(tag);
+        if (res == null) {
+            return invokers;
+        }
+        return invokers.intersect((BitList)res, invokers.getUnmodifiableList());
+    }
+
+
+    @Override
+    public boolean isRuntime() {
+        return tagRouterRule != null && tagRouterRule.isRuntime();
+    }
+
+    @Override
+    public boolean isEnable() {
+        return true;
+    }
+
+    @Override
+    public boolean isForce() {
+        // FIXME","[{'comment': 'Fix\r\n', 'commenter': 'guohao'}]"
7045,dubbo-common/src/main/java/org/apache/dubbo/common/utils/BitList.java,"@@ -0,0 +1,159 @@
+package org.apache.dubbo.common.utils;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+/**
+ *
+ */
+public class BitList<E> implements BitListInterf<E> {
+    BitListInterf<E> delegate;
+
+    public BitList(List<E> unmodifiableList, boolean empty) {
+        if (Jvm.isJava8Plus()) {
+            delegate = new RoaringBitList<>(unmodifiableList, empty);
+        } else {
+            delegate = new NormalList<>(unmodifiableList, empty);","[{'comment': 'Dubbo3只适用于 Java8+，不需要NormalList', 'commenter': 'guohao'}]"
7045,dubbo-common/src/main/java/org/apache/dubbo/common/utils/Jvm.java,"@@ -0,0 +1,36 @@
+package org.apache.dubbo.common.utils;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ *
+ */","[{'comment': '这个类可以删除，理由同上', 'commenter': 'guohao'}]"
7045,dubbo-common/src/main/java/org/apache/dubbo/common/utils/NormalList.java,"@@ -0,0 +1,167 @@
+package org.apache.dubbo.common.utils;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.Set;
+
+/**
+ *
+ */
+public class NormalList<E> implements BitListInterf<E> {","[{'comment': '这个类可以删除，理由同上', 'commenter': 'guohao'}]"
7045,dubbo-common/src/main/java/org/apache/dubbo/common/utils/RoaringBitList.java,"@@ -0,0 +1,217 @@
+package org.apache.dubbo.common.utils;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+import org.roaringbitmap.IntIterator;
+import org.roaringbitmap.RoaringBitmap;
+
+class RoaringBitList<E> implements BitListInterf<E> {","[{'comment': '看一下高版本的RoaringBitMap，是否有内置函数支持更高效的遍历', 'commenter': 'guohao'}]"
7045,dubbo-common/src/main/java/org/apache/dubbo/common/utils/BitList.java,"@@ -0,0 +1,155 @@
+package org.apache.dubbo.common.utils;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+/**
+ *
+ */
+public class BitList<E> implements BitListInterf<E> {","[{'comment': '就一个实现类，不需要BitListInterf这个接口拉', 'commenter': 'guohao'}]"
7082,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java,"@@ -152,7 +152,9 @@ private String judgeCategory(URL url) {
         return """";
     }
 
-    private void refreshOverrideAndInvoker(List<URL> urls) {
+    // Issue: https://github.com/apache/dubbo/issues/6763.","[{'comment': 'remove this line, and we can refer these changes in git blame', 'commenter': 'AlbumenJ'}, {'comment': 'done.', 'commenter': 'horizonzy'}]"
7101,dubbo-rpc/dubbo-rpc-memcached/src/main/java/org/apache/dubbo/rpc/protocol/memcached/MemcachedProtocol.java,"@@ -95,9 +95,9 @@ protected Result doInvoke(Invocation invocation) throws Throwable {
                         return AsyncRpcResult.newDefaultAsyncResult(value, invocation);
                     } catch (Throwable t) {
                         RpcException re = new RpcException(""Failed to invoke memcached service method. interface: "" + type.getName() + "", method: "" + invocation.getMethodName() + "", url: "" + url + "", cause: "" + t.getMessage(), t);
-                        if (t instanceof TimeoutException || t instanceof SocketTimeoutException) {","[{'comment': 'Are TimeoutException and SocketTimeoutException of the same type?', 'commenter': 'chickenlj'}]"
7121,dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java,"@@ -116,6 +122,35 @@ public void timeoutSend() throws Exception {
         }
     }
 
+    @Test
+    public void interruptSend() throws Exception {
+        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(""yyyy-MM-dd HH:mm:ss"");
+        System.out.println(""before a future is create , time is : "" + LocalDateTime.now().format(formatter));
+        // timeout after 5 seconds.
+        Channel channel = new MockedChannel();
+        Request request = new Request(10);
+        ExecutorService sharedExecutor = ExtensionLoader.getExtensionLoader(ExecutorRepository.class)
+                .getDefaultExtension().createExecutorIfAbsent(URL.valueOf(""dubbo://127.0.0.1:23456""));
+        ThreadlessExecutor executor = new ThreadlessExecutor(sharedExecutor);
+        DefaultFuture f = DefaultFuture.newFuture(channel, request, 5000, executor);
+        //mark the future is sent
+        DefaultFuture.sent(channel, request);
+        // get operate will throw a timeout exception, because the future is timeout.
+        try {
+            new InterruptThread(Thread.currentThread()).start();
+            executor.waitAndDrain();
+            f.get();
+        } catch (Exception e) {
+            Assertions.assertTrue(e instanceof InterruptedException, ""catch exception is not interrupted exception!"");
+            System.out.println(e.getMessage());
+        }
+        //waiting timeout check task finishing
+        Thread.sleep(8000);","[{'comment': 'it would be better if u use shorter timeout', 'commenter': 'AlbumenJ'}, {'comment': 'ok，how about  timeout=1500ms ,sleep(2000) and sleep(1000) in InterruptThread', 'commenter': 'bigShong'}]"
7121,dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java,"@@ -116,6 +122,35 @@ public void timeoutSend() throws Exception {
         }
     }
 
+    @Test
+    public void interruptSend() throws Exception {
+        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(""yyyy-MM-dd HH:mm:ss"");
+        System.out.println(""before a future is create , time is : "" + LocalDateTime.now().format(formatter));
+        // timeout after 5 seconds.
+        Channel channel = new MockedChannel();
+        Request request = new Request(10);
+        ExecutorService sharedExecutor = ExtensionLoader.getExtensionLoader(ExecutorRepository.class)
+                .getDefaultExtension().createExecutorIfAbsent(URL.valueOf(""dubbo://127.0.0.1:23456""));
+        ThreadlessExecutor executor = new ThreadlessExecutor(sharedExecutor);
+        DefaultFuture f = DefaultFuture.newFuture(channel, request, 5000, executor);
+        //mark the future is sent
+        DefaultFuture.sent(channel, request);
+        // get operate will throw a timeout exception, because the future is timeout.","[{'comment': 'this comment should  change to this: get operate will throw a interrupted exception, because the thread is interrupted.', 'commenter': 'bigShong'}]"
7121,.github/workflows/build-and-test.yml,"@@ -0,0 +1,179 @@
+name: Build and Test
+
+on: [push, pull_request]
+
+env:
+  FORK_COUNT: 2
+  FAIL_FAST: 0
+  SHOW_ERROR_DETAIL: 1
+  #multi-version size limit
+  VERSIONS_LIMIT: 4
+  CANDIDATE_VERSIONS: '
+    spring.version:4.3.30.RELEASE;
+    spring-boot.version:1.5.22.RELEASE;
+    spring-boot.version:2.4.1;
+    '
+jobs:
+  build-source:
+    runs-on: ubuntu-18.04
+    steps:
+      - uses: actions/checkout@v2
+      - uses: actions/setup-java@v1
+        with:
+          java-version: 8
+      - uses: actions/cache@v2
+        name: ""Cache local Maven repository""
+        with:
+          path: ~/.m2/repository
+          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
+      - name: ""Dubbo cache""
+        uses: actions/cache@v2
+        with:
+          path: ~/.m2/repository/org/apache/dubbo
+          key: ${{ runner.os }}-dubbo-snapshot-${{ github.sha }}
+      - name: ""Build with Maven""
+        run: ./mvnw --batch-mode -U -e --no-transfer-progress  clean install -Dmaven.wagon.httpconnectionManager.ttlSeconds=120 -Dmaven.wagon.http.retryHandler.count=5 -Dmaven.test.skip=true -Dmaven.test.skip.exec=true
+      - name: ""Calculate Dubbo Version""
+        run: |
+          REVISION=`awk '/<revision>[^<]+<\/revision>/{gsub(/<revision>|<\/revision>/,"""",$1);print $1;exit;}' pom.xml`
+          mkdir dubbo-version
+          echo $REVISION > dubbo-version/dubbo-version
+      - name: ""Upload Dubbo version""
+        uses: actions/upload-artifact@v2
+        with:
+          name: dubbo-version
+          path: dubbo-version
+
+  unit-test:
+    needs: [build-source]
+    name: ""Unit Test On ${{ matrix.os }} (JDK: ${{ matrix.jdk }})""
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ ubuntu-18.04, windows-2019 ]
+        jdk: [ 8, 11 ]
+    steps:
+      - uses: actions/checkout@v2
+      - name: ""Set up JDK ${{ matrix.jdk }}""
+        uses: actions/setup-java@v1
+        with:
+          java-version: ${{ matrix.jdk }}
+      - uses: actions/cache@v2
+        name: ""Cache local Maven repository""
+        with:
+          path: ~/.m2/repository
+          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
+          restore-keys: |
+            ${{ runner.os }}-maven-
+      - name: ""Test with Maven with Integration Tests""
+        timeout-minutes: 30
+        if: ${{ startsWith( matrix.os, 'ubuntu') }}
+        run: ./mvnw --batch-mode -U -e --no-transfer-progress clean test -Dmaven.wagon.httpconnectionManager.ttlSeconds=120 -Dmaven.wagon.http.retryHandler.count=5 -DskipTests=false -DskipIntegrationTests=false -Dcheckstyle.skip=false -Drat.skip=false -Dmaven.javadoc.skip=true
+      - name: ""Test with Maven without Integration Tests""
+        env:
+          DISABLE_FILE_SYSTEM_TEST: true
+        timeout-minutes: 30
+        if: ${{ startsWith( matrix.os, 'windows') }}
+        run: ./mvnw --batch-mode -U -e --no-transfer-progress clean install -D""http.keepAlive=false"" -D""maven.wagon.http.pool=false"" -D""maven.wagon.httpconnectionManager.ttlSeconds=120"" -D""maven.wagon.http.retryHandler.count=5"" -DskipTests=false -DskipIntegrationTests=true -D""checkstyle.skip=false"" -D""rat.skip=false"" -D""maven.javadoc.skip=true""
+      - name: ""Upload coverage to Codecov""
+        uses: codecov/codecov-action@v1
+
+  integration-test-prepare:
+    runs-on: ubuntu-18.04
+    env:
+      JOB_COUNT: 3
+    steps:
+      - uses: actions/checkout@v2
+        with:
+          repository: 'apache/dubbo-samples'
+          ref: master
+      - name: ""Prepare test list""
+        run: |
+          bash ./test/scripts/prepare-test.sh
+      - name: ""Upload test list""
+        uses: actions/upload-artifact@v2
+        with:
+          name: test-list
+          path: test/jobs
+
+  integration-test-job:
+    needs: [build-source, integration-test-prepare]
+    name: ""Integration Test on ubuntu-18.04 (JobId: ${{matrix.job_id}})""
+    runs-on: ubuntu-18.04
+    timeout-minutes: 30
+    env:
+      JAVA_VER: 8
+      TEST_CASE_FILE: jobs/testjob_${{matrix.job_id}}.txt
+    strategy:
+      fail-fast: false
+      matrix:
+        job_id: [1, 2, 3]
+    steps:
+      - uses: actions/checkout@v2
+        with:
+          repository: 'apache/dubbo-samples'
+          ref: master
+      - name: ""Cache local Maven repository""
+        uses: actions/cache@v2
+        with:
+          path: ~/.m2/repository
+          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
+          restore-keys: |
+            ${{ runner.os }}-maven-
+      - name: ""Restore Dubbo cache""
+        uses: actions/cache@v2
+        with:
+          path: ~/.m2/repository/org/apache/dubbo
+          key: ${{ runner.os }}-dubbo-snapshot-${{ github.sha }}
+          restore-keys: |
+            ${{ runner.os }}-dubbo-
+      - name: ""Download test list""
+        uses: actions/download-artifact@v2
+        with:
+          name: test-list
+          path: test/jobs/
+      - name: ""Download Dubbo version""
+        uses: actions/download-artifact@v2
+        with:
+          name: dubbo-version
+          path: dubbo-version
+      - name: ""Set up JDK 8""
+        uses: actions/setup-java@v1
+        with:
+          java-version: 8
+      - name: ""Init Candidate Versions""
+        run: |
+          DUBBO_VERSION=`cat dubbo-version/dubbo-version`
+          CANDIDATE_VERSIONS=""dubbo.version:$DUBBO_VERSION;$CANDIDATE_VERSIONS""
+          echo ""CANDIDATE_VERSIONS=$CANDIDATE_VERSIONS"" >> $GITHUB_ENV
+      - name: ""Build test image""
+        run: |
+          cd test && bash ./build-test-image.sh
+      - name: ""Run tests""
+        run: cd test && bash ./run-tests.sh
+      - name: ""Upload test result""
+        if: always()
+        uses: actions/upload-artifact@v2
+        with:
+          name: test-result
+          path: test/jobs/*-result*
+
+  integration-test-result:
+    needs: [integration-test-job]
+    if: always()
+    runs-on: ubuntu-18.04
+    env:
+      JAVA_VER: 8
+    steps:
+      - uses: actions/checkout@v2
+        with:
+          repository: 'apache/dubbo-samples'
+          ref: master
+      - name: ""Download test result""
+        uses: actions/download-artifact@v2
+        with:
+          name: test-result
+          path: test/jobs/
+      - name: ""Merge test result""
+        run: ./test/scripts/merge-test-results.sh","[{'comment': 'Why is this file changed?', 'commenter': 'chickenlj'}, {'comment': 'Renamed from unit-test.yml? please submit a separate for this change?', 'commenter': 'chickenlj'}, {'comment': 'this file changed by this commit,when merge branch.\r\n [Unit Test] Use matrix build workflow & Add Integration Test (#7078) ', 'commenter': 'bigShong'}]"
7121,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java,"@@ -85,8 +85,13 @@ public void waitAndDrain() throws InterruptedException {
         if (finished) {
             return;
         }
-
-        Runnable runnable = queue.take();
+        Runnable runnable;
+        try {
+            runnable = queue.take();
+        }catch (InterruptedException e){
+            waiting = false;
+            throw e;
+        }","[{'comment': 'This change looks fine to me.', 'commenter': 'chickenlj'}]"
7172,dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java,"@@ -28,22 +28,8 @@
 import java.util.stream.Collectors;
 
 import static java.util.Collections.emptyMap;
-import static org.apache.dubbo.common.constants.CommonConstants.ANY_VALUE;
-import static org.apache.dubbo.common.constants.CommonConstants.CLASSIFIER_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;
-import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_PROTOCOL;
-import static org.apache.dubbo.common.constants.CommonConstants.ENABLED_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.HOST_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.PASSWORD_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.PATH_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.PORT_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.PROTOCOL_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.REGISTRY_SPLIT_PATTERN;
-import static org.apache.dubbo.common.constants.CommonConstants.REMOVE_VALUE_PREFIX;
-import static org.apache.dubbo.common.constants.CommonConstants.USERNAME_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.*;","[{'comment': '@kuailejiandan \r\nplease install codestyle template in your ide\r\n\r\nyou can follow this https://github.com/apache/dubbo/blob/master/CONTRIBUTING.md#code-style\r\n\r\nimport classes with wildcard is not allow in Dubbo\r\n\r\n', 'commenter': 'AlbumenJ'}]"
7172,dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java,"@@ -94,23 +96,28 @@ public static URL parseURL(String address, Map<String, String> defaults) {
         int defaultPort = StringUtils.parseInteger(defaults == null ? null : defaults.get(PORT_KEY));
         String defaultPath = defaults == null ? null : defaults.get(PATH_KEY);
         Map<String, String> defaultParameters = defaults == null ? null : new HashMap<>(defaults);
-        if (defaultParameters != null) {
-            defaultParameters.remove(PROTOCOL_KEY);
-            defaultParameters.remove(USERNAME_KEY);
-            defaultParameters.remove(PASSWORD_KEY);
-            defaultParameters.remove(HOST_KEY);
-            defaultParameters.remove(PORT_KEY);
-            defaultParameters.remove(PATH_KEY);
-        }
         URL u = URL.valueOf(url);
-        boolean changed = false;
         String protocol = u.getProtocol();
         String username = u.getUsername();
         String password = u.getPassword();
         String host = u.getHost();
         int port = u.getPort();
         String path = u.getPath();
+        boolean changed = false;
         Map<String, String> parameters = new HashMap<>(u.getParameters());
+        if (defaultParameters != null) {
+            boolean protocolBank = StringUtils.isBlank(protocol);
+            // If the protocol parameter is equal to ""nacos"", the username and password will not be removed from the collection ;
+            // If the protocol parameter is not equal to ""nacos"", the username and password will  be removed from the collection ;
+            if (protocolBank || !protocol.equals(""nacos"")) {","[{'comment': 'Is it reasonable proper make `nacos` impl coupling with `dubbo-common` ?\r\n\r\nMaybe we can change the param name for `nacos` ?', 'commenter': 'AlbumenJ'}, {'comment': 'How about we solve this issue by adding duplicate key-value pair to parameters\r\nhttps://github.com/apache/dubbo/pull/7239', 'commenter': 'chickenlj'}]"
7174,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java,"@@ -47,28 +48,53 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L
         RpcContext.getContext().setInvokers((List) invokers);
         RpcException exception = null;
         Result result = null;
+        URL url = getUrl();
+        // The value range of broadcast.fail.threshold must be 0～100.
+        // 100 means that an exception will be thrown last, and 0 means that as long as an exception occurs, it will be thrown.
+        int broadcastFailPercent = url.getParameter(""broadcast.fail.percent"", 100);
+
+        int failThresholdIndex = invokers.size() * broadcastFailPercent / 100;
+        int failIndex = 0;
         for (Invoker<T> invoker : invokers) {
             try {
                 result = invoker.invoke(invocation);
                 if(null != result && result.hasException()){
                     Throwable resultException = result.getException();
                     if(null != resultException){
-                        logger.warn(resultException.getMessage(), resultException);
-                        throw resultException;
+                        exception = getRpcException(result.getException());
+                        if(failIndex == failThresholdIndex){
+                            break;
+                        }else{
+                            logger.warn(exception.getMessage(), exception);
+                            failIndex++;
+                        }
                     }
                 }
-            } catch (RpcException e) {
-                exception = e;
-                logger.warn(e.getMessage(), e);
             } catch (Throwable e) {
-                exception = new RpcException(e.getMessage(), e);
-                logger.warn(e.getMessage(), e);
+                exception = getRpcException(e);
+                if(failIndex == failThresholdIndex){
+                    break;
+                }else{
+                    logger.warn(exception.getMessage(), exception);
+                    failIndex++;
+                }
             }
         }
-        if (exception != null) {
+
+        if (exception != null && failIndex == failThresholdIndex) {","[{'comment': 'Should we report the exception in the end even when failIndex does not reach the threshold?', 'commenter': 'chickenlj'}, {'comment': 'Perhaps the threshold is just to control whether other nodes need to be called, and in the end, as long as an exception occurs, it will be thrown. This way of handling is better, do you think so? In this case, it does not change the previous logic, but only controls whether it needs to continue to call other nodes when an exception occurs.', 'commenter': 'xiaoheng1'}, {'comment': ""Yes, I think it's more reasonable."", 'commenter': 'chickenlj'}, {'comment': 'Okay, I will modify it.', 'commenter': 'xiaoheng1'}, {'comment': 'Please cr again, thanks.', 'commenter': 'xiaoheng1'}]"
7174,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java,"@@ -47,21 +48,53 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L
         RpcContext.getContext().setInvokers((List) invokers);
         RpcException exception = null;
         Result result = null;
+        URL url = getUrl();
+        // The value range of broadcast.fail.threshold must be 0～100.
+        // 100 means that an exception will be thrown last, and 0 means that as long as an exception occurs, it will be thrown.
+        int broadcastFailPercent = url.getParameter(""broadcast.fail.percent"", 100);","[{'comment': 'pls convert `""broadcast.fail.percent""` and `100` to constant', 'commenter': 'AlbumenJ'}]"
7174,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java,"@@ -47,21 +48,53 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L
         RpcContext.getContext().setInvokers((List) invokers);
         RpcException exception = null;
         Result result = null;
+        URL url = getUrl();
+        // The value range of broadcast.fail.threshold must be 0～100.
+        // 100 means that an exception will be thrown last, and 0 means that as long as an exception occurs, it will be thrown.
+        int broadcastFailPercent = url.getParameter(""broadcast.fail.percent"", 100);
+
+        int failThresholdIndex = invokers.size() * broadcastFailPercent / 100;","[{'comment': 'pls check if `broadcastFailPercent` is in proper range', 'commenter': 'AlbumenJ'}]"
7174,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java,"@@ -47,21 +48,53 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L
         RpcContext.getContext().setInvokers((List) invokers);
         RpcException exception = null;
         Result result = null;
+        URL url = getUrl();
+        // The value range of broadcast.fail.threshold must be 0～100.
+        // 100 means that an exception will be thrown last, and 0 means that as long as an exception occurs, it will be thrown.
+        int broadcastFailPercent = url.getParameter(""broadcast.fail.percent"", 100);
+
+        int failThresholdIndex = invokers.size() * broadcastFailPercent / 100;
+        int failIndex = 0;
         for (Invoker<T> invoker : invokers) {
             try {
                 result = invoker.invoke(invocation);
-            } catch (RpcException e) {
-                exception = e;
-                logger.warn(e.getMessage(), e);
+                if(null != result && result.hasException()){","[{'comment': 'Please use IDE code style formatter to achieve more standardized layout, also please remember to add the [template file](https://github.com/apache/dubbo/tree/master/codestyle/dubbo_codestyle_for_idea.xml) to IDEA if you use', 'commenter': 'AlbumenJ'}]"
7174,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java,"@@ -47,21 +48,53 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L
         RpcContext.getContext().setInvokers((List) invokers);
         RpcException exception = null;
         Result result = null;
+        URL url = getUrl();
+        // The value range of broadcast.fail.threshold must be 0～100.
+        // 100 means that an exception will be thrown last, and 0 means that as long as an exception occurs, it will be thrown.
+        int broadcastFailPercent = url.getParameter(""broadcast.fail.percent"", 100);
+
+        int failThresholdIndex = invokers.size() * broadcastFailPercent / 100;
+        int failIndex = 0;
         for (Invoker<T> invoker : invokers) {
             try {
                 result = invoker.invoke(invocation);
-            } catch (RpcException e) {
-                exception = e;
-                logger.warn(e.getMessage(), e);
+                if(null != result && result.hasException()){
+                    Throwable resultException = result.getException();
+                    if(null != resultException){
+                        exception = getRpcException(result.getException());
+                        if(failIndex == failThresholdIndex){
+                            break;
+                        }else{
+                            logger.warn(exception.getMessage(), exception);","[{'comment': 'Would it be more reasonable if add more message like `Exception caught while invoke boardcast cluster` ?', 'commenter': 'AlbumenJ'}]"
7174,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java,"@@ -47,21 +48,53 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L
         RpcContext.getContext().setInvokers((List) invokers);
         RpcException exception = null;
         Result result = null;
+        URL url = getUrl();
+        // The value range of broadcast.fail.threshold must be 0～100.
+        // 100 means that an exception will be thrown last, and 0 means that as long as an exception occurs, it will be thrown.
+        int broadcastFailPercent = url.getParameter(""broadcast.fail.percent"", 100);
+
+        int failThresholdIndex = invokers.size() * broadcastFailPercent / 100;
+        int failIndex = 0;
         for (Invoker<T> invoker : invokers) {
             try {
                 result = invoker.invoke(invocation);
-            } catch (RpcException e) {
-                exception = e;
-                logger.warn(e.getMessage(), e);
+                if(null != result && result.hasException()){
+                    Throwable resultException = result.getException();
+                    if(null != resultException){
+                        exception = getRpcException(result.getException());
+                        if(failIndex == failThresholdIndex){
+                            break;","[{'comment': 'Shall we notify user if fail count reaches threshold ?', 'commenter': 'AlbumenJ'}]"
7189,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java,"@@ -72,8 +75,13 @@ public AbstractDirectory(URL url, RouterChain<T> routerChain) {
         this.consumedProtocol = this.queryMap.get(PROTOCOL_KEY) == null ? DUBBO : this.queryMap.get(PROTOCOL_KEY);
         this.url = url.removeParameter(REFER_KEY).removeParameter(MONITOR_KEY);
 
-        this.consumerUrl = this.url.setProtocol(consumedProtocol).setPath(path == null ? queryMap.get(INTERFACE_KEY) : path).addParameters(queryMap)
-                .removeParameter(MONITOR_KEY);
+        URL consumerUrlFrom = this.url.setProtocol(consumedProtocol)
+                .setPath(path == null ? queryMap.get(INTERFACE_KEY) : path);
+        if (isUrlFromRegistry) {
+            // reserve parameters if url is already a consumer url
+            consumerUrlFrom = consumerUrlFrom.clearParameters();","[{'comment': 'Will clearing all the parameters of the registry url cause the loss of some useful parameters of the consumer url?\r\n\r\n**What parameters does the consumer url need to extract from the registry url?**\r\n\r\nThis bug is actually that the `group` parameter of the registry URL is incorrectly passed to the consumer URL.', 'commenter': 'kylixs'}, {'comment': '> Will clearing all the parameters of the registry url cause the loss of some useful parameters of the consumer url?\r\n\r\nThe paramaters in url which is from `DynamicDirectory`  is the paramaters of registry. Real reference paramaters are bring encoded and set in `refer` paramater which is `queryMap` here.', 'commenter': 'AlbumenJ'}]"
7189,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java,"@@ -1,113 +1,113 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.rpc.cluster.directory;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.CollectionUtils;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.cluster.RouterChain;
-
-import java.util.Collections;
-import java.util.List;
-
-/**
- * StaticDirectory
- */
-public class StaticDirectory<T> extends AbstractDirectory<T> {
-    private static final Logger logger = LoggerFactory.getLogger(StaticDirectory.class);
-
-    private final List<Invoker<T>> invokers;
-
-    public StaticDirectory(List<Invoker<T>> invokers) {
-        this(null, invokers, null);
-    }
-
-    public StaticDirectory(List<Invoker<T>> invokers, RouterChain<T> routerChain) {
-        this(null, invokers, routerChain);
-    }
-
-    public StaticDirectory(URL url, List<Invoker<T>> invokers) {
-        this(url, invokers, null);
-    }
-
-    public StaticDirectory(URL url, List<Invoker<T>> invokers, RouterChain<T> routerChain) {
-        super(url == null && CollectionUtils.isNotEmpty(invokers) ? invokers.get(0).getUrl() : url, routerChain);
-        if (CollectionUtils.isEmpty(invokers)) {
-            throw new IllegalArgumentException(""invokers == null"");
-        }
-        this.invokers = invokers;
-    }
-
-    @Override
-    public Class<T> getInterface() {
-        return invokers.get(0).getInterface();
-    }
-
-    @Override
-    public List<Invoker<T>> getAllInvokers() {
-        return invokers;
-    }
-
-    @Override
-    public boolean isAvailable() {
-        if (isDestroyed()) {
-            return false;
-        }
-        for (Invoker<T> invoker : invokers) {
-            if (invoker.isAvailable()) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    @Override
-    public void destroy() {
-        if (isDestroyed()) {
-            return;
-        }
-        super.destroy();
-        for (Invoker<T> invoker : invokers) {
-            invoker.destroy();
-        }
-        invokers.clear();
-    }
-
-    public void buildRouterChain() {
-        RouterChain<T> routerChain = RouterChain.buildChain(getUrl());
-        routerChain.setInvokers(invokers);
-        this.setRouterChain(routerChain);
-    }
-
-    @Override
-    protected List<Invoker<T>> doList(Invocation invocation) throws RpcException {
-        List<Invoker<T>> finalInvokers = invokers;
-        if (routerChain != null) {
-            try {
-                finalInvokers = routerChain.route(getConsumerUrl(), invocation);
-            } catch (Throwable t) {
-                logger.error(""Failed to execute router: "" + getUrl() + "", cause: "" + t.getMessage(), t);
-            }
-        }
-        return finalInvokers == null ? Collections.emptyList() : finalInvokers;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.directory;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.RouterChain;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * StaticDirectory
+ */
+public class StaticDirectory<T> extends AbstractDirectory<T> {
+    private static final Logger logger = LoggerFactory.getLogger(StaticDirectory.class);
+
+    private final List<Invoker<T>> invokers;
+
+    public StaticDirectory(List<Invoker<T>> invokers) {
+        this(null, invokers, null);
+    }
+
+    public StaticDirectory(List<Invoker<T>> invokers, RouterChain<T> routerChain) {
+        this(null, invokers, routerChain);
+    }
+
+    public StaticDirectory(URL url, List<Invoker<T>> invokers) {
+        this(url, invokers, null);
+    }
+
+    public StaticDirectory(URL url, List<Invoker<T>> invokers, RouterChain<T> routerChain) {
+        super(url == null && CollectionUtils.isNotEmpty(invokers) ? invokers.get(0).getUrl() : url, routerChain, false);
+        if (CollectionUtils.isEmpty(invokers)) {
+            throw new IllegalArgumentException(""invokers == null"");
+        }
+        this.invokers = invokers;
+    }
+
+    @Override
+    public Class<T> getInterface() {
+        return invokers.get(0).getInterface();
+    }
+
+    @Override
+    public List<Invoker<T>> getAllInvokers() {
+        return invokers;
+    }
+
+    @Override
+    public boolean isAvailable() {
+        if (isDestroyed()) {
+            return false;
+        }
+        for (Invoker<T> invoker : invokers) {
+            if (invoker.isAvailable()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public void destroy() {
+        if (isDestroyed()) {
+            return;
+        }
+        super.destroy();
+        for (Invoker<T> invoker : invokers) {
+            invoker.destroy();
+        }
+        invokers.clear();
+    }
+
+    public void buildRouterChain() {
+        RouterChain<T> routerChain = RouterChain.buildChain(getUrl());
+        routerChain.setInvokers(invokers);
+        this.setRouterChain(routerChain);
+    }
+
+    @Override
+    protected List<Invoker<T>> doList(Invocation invocation) throws RpcException {
+        List<Invoker<T>> finalInvokers = invokers;
+        if (routerChain != null) {
+            try {
+                finalInvokers = routerChain.route(getConsumerUrl(), invocation);
+            } catch (Throwable t) {
+                logger.error(""Failed to execute router: "" + getUrl() + "", cause: "" + t.getMessage(), t);
+            }
+        }
+        return finalInvokers == null ? Collections.emptyList() : finalInvokers;
+    }
+
+}","[{'comment': 'Please check why the whole file is marked as changed.', 'commenter': 'chickenlj'}]"
7192,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/registry/ZoneAwareClusterInvoker.java,"@@ -93,7 +94,7 @@ public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, L
 
 
         // load balance among all registries, with registry weight count in.
-        Invoker<T> balancedInvoker = select(loadbalance, invocation, invokers, null);
+        Invoker<T> balancedInvoker = select(ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(LOADBALANCE_AMONG_REGISTRIES), invocation, invokers, null);","[{'comment': 'better avoid calling getExtension() every time', 'commenter': 'chickenlj'}]"
7316,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java,"@@ -160,7 +160,7 @@ public URL getUrl() {
      * @return
      */
     private <T> List<Invoker<T>> filterUsingStaticTag(List<Invoker<T>> invokers, URL url, Invocation invocation) {
-        List<Invoker<T>> result = invokers;
+        List<Invoker<T>> result;","[{'comment': 'Why remove this assignment?', 'commenter': 'chickenlj'}, {'comment': 'Oh, I see, I reviewed the wrong method.', 'commenter': 'chickenlj'}]"
7326,dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java,"@@ -37,18 +37,7 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.LinkedHashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.ServiceLoader;
-import java.util.Set;
-import java.util.TreeSet;
+import java.util.*;","[{'comment': 'pls recover wildcard import', 'commenter': 'AlbumenJ'}]"
7334,dubbo-rpc/dubbo-rpc-injvm/src/test/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocolTest.java,"@@ -81,6 +81,17 @@ public void testLocalProtocol() throws Exception {
 
     }
 
+    @Test
+    public void testLocalProtocolWithToken() throws Exception {
+        DemoService service = new DemoServiceImpl();
+        Invoker<?> invoker = proxy.getInvoker(service, DemoService.class, URL.valueOf(""injvm://127.0.0.1/TestService?token=abc"").addParameter(INTERFACE_KEY, DemoService.class.getName()));
+        assertTrue(invoker.isAvailable());
+        Exporter<?> exporter = protocol.export(invoker);","[{'comment': 'pls destroy it in the final', 'commenter': 'AlbumenJ'}]"
7372,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleManager.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.cluster.router.mesh.route;
+
+import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+import java.util.Collection;
+import java.util.concurrent.ConcurrentHashMap;
+
+
+public final class MeshRuleManager {
+
+    public static final Logger logger = LoggerFactory.getLogger(MeshRuleManager.class);
+
+    private static final String MESH_RULE_DATA_ID_SUFFIX = "".MESHAPPRULE"";
+    private static final String GROUP = ""DEFAULT_GROUP"";
+
+    private static ConcurrentHashMap<String, MeshAppRuleListener> appRuleListeners = new ConcurrentHashMap<>();
+
+    public static void subscribeAppRule(String app) {
+        // 注册 diamond 的监听","[{'comment': 'pls comment in english', 'commenter': 'AlbumenJ'}]"
7372,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/rule/BaseRule.java,"@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.cluster.router.mesh.rule;
+
+import java.util.Map;
+
+
+public class BaseRule {","[{'comment': 'pls override `equal` and `hashcode` method', 'commenter': 'AlbumenJ'}]"
7372,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/rule/destination/TCPSettings.java,"@@ -0,0 +1,25 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.cluster.router.mesh.rule.destination;
+
+
+public class TCPSettings {","[{'comment': 'what is this class used for? without getter and setter method', 'commenter': 'AlbumenJ'}]"
7372,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/rule/destination/TcpKeepalive.java,"@@ -0,0 +1,26 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.cluster.router.mesh.rule.destination;
+
+
+public class TcpKeepalive {","[{'comment': 'what is this class used for? without getter and setter method', 'commenter': 'AlbumenJ'}]"
7372,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/rule/virtualservice/match/DubboMethodArg.java,"@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.cluster.router.mesh.rule.virtualservice.match;
+
+
+public class DubboMethodArg {
+    private int index;
+    private String type;
+    private ListStringMatch str_value;","[{'comment': 'pls use lower camel rule', 'commenter': 'AlbumenJ'}]"
7372,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/rule/virtualservice/match/DubboMethodMatch.java,"@@ -0,0 +1,128 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.cluster.router.mesh.rule.virtualservice.match;
+
+import java.util.List;
+import java.util.Map;
+
+
+public class DubboMethodMatch {
+    private StringMatch name_match;","[{'comment': 'pls use lower camel rule', 'commenter': 'AlbumenJ'}]"
7372,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mesh/rule/DestinationRuleTest.java,"@@ -0,0 +1,99 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.cluster.router.mesh.rule;
+
+import org.apache.dubbo.rpc.cluster.router.mesh.rule.destination.DestinationRule;
+import org.apache.dubbo.rpc.cluster.router.mesh.rule.destination.loadbalance.SimpleLB;
+import org.apache.dubbo.rpc.cluster.router.mesh.rule.virtualservice.VirtualServiceRule;
+import org.junit.jupiter.api.Test;
+import org.yaml.snakeyaml.Yaml;
+
+import java.util.Map;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+
+public class DestinationRuleTest {
+
+    @Test
+    public void parserTest() {
+        Yaml yaml = new Yaml();
+        DestinationRule destinationRule = yaml.loadAs(this.getClass().getClassLoader().getResourceAsStream(""DestinationRuleTest.yaml""), DestinationRule.class);
+
+        System.out.println(destinationRule);","[{'comment': '`System.out.println` has no effect in ut', 'commenter': 'AlbumenJ'}]"
7372,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/mesh/rule/VirtualServiceRuleTest.java,"@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.cluster.router.mesh.rule;
+
+import org.apache.dubbo.rpc.cluster.router.mesh.rule.virtualservice.VirtualServiceRule;
+import org.junit.jupiter.api.Test;
+import org.yaml.snakeyaml.Yaml;
+
+
+public class VirtualServiceRuleTest {
+
+    @Test
+    public void parserTest() {
+        Yaml yaml = new Yaml();
+        VirtualServiceRule virtualServiceRule = yaml.loadAs(this.getClass().getClassLoader().getResourceAsStream(""VirtualServiceTest.yaml""), VirtualServiceRule.class);
+
+        System.out.println(virtualServiceRule);","[{'comment': 'it should be better to change to equal check', 'commenter': 'AlbumenJ'}]"
7378,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java,"@@ -262,6 +275,54 @@ private boolean matchCondition(Map<String, MatchPair> condition, URL url, URL pa
         return result;
     }
 
+    /**
+     * analysis the arguments in the rule.
+     * Examples would be like this:
+     * ""arguments[0]=1"", whenCondition is that the first argument is equal to '1'.
+     * ""arguments[1].param=a"", whenCondition is that the 'param' attribute in the second argument is equal to 'a'.
+     * ""arguments[2].inner.param=b"", whenCondition is that the 'param' attribute in the 'inner' attribute of the third argument is equal to 'b'.
+     * @param matchPair
+     * @param invocation
+     * @return
+     */
+    public boolean matchArguments(Map.Entry<String, MatchPair> matchPair, Invocation invocation) {
+        try {
+            // split the rule
+            String key = matchPair.getKey();
+            String[] expressArray = key.split(""\\."");
+            String argumentExpress = expressArray[0];
+            final Matcher matcher = ARGUMENTS_PATTERN.matcher(argumentExpress);
+            if (!matcher.find()) {
+                return false;
+            }
+
+            //extract the argument index
+            int index = Integer.parseInt(matcher.group(1));
+            if (index < 0 || index > invocation.getArguments().length) {
+                return false;
+            }
+
+            //extract the argument value
+            Object object = invocation.getArguments()[index];
+            for (int i = 1; i < expressArray.length; i++) {
+                if (object == null) {
+                    return false;
+                }
+                Field field = object.getClass().getDeclaredField(expressArray[i]);","[{'comment': 'pls use FieldUtils', 'commenter': 'AlbumenJ'}, {'comment': '👌', 'commenter': 'furaul'}]"
7378,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java,"@@ -262,6 +275,54 @@ private boolean matchCondition(Map<String, MatchPair> condition, URL url, URL pa
         return result;
     }
 
+    /**
+     * analysis the arguments in the rule.
+     * Examples would be like this:
+     * ""arguments[0]=1"", whenCondition is that the first argument is equal to '1'.
+     * ""arguments[1].param=a"", whenCondition is that the 'param' attribute in the second argument is equal to 'a'.
+     * ""arguments[2].inner.param=b"", whenCondition is that the 'param' attribute in the 'inner' attribute of the third argument is equal to 'b'.
+     * @param matchPair
+     * @param invocation
+     * @return
+     */
+    public boolean matchArguments(Map.Entry<String, MatchPair> matchPair, Invocation invocation) {
+        try {
+            // split the rule
+            String key = matchPair.getKey();
+            String[] expressArray = key.split(""\\."");
+            String argumentExpress = expressArray[0];
+            final Matcher matcher = ARGUMENTS_PATTERN.matcher(argumentExpress);
+            if (!matcher.find()) {
+                return false;
+            }
+
+            //extract the argument index
+            int index = Integer.parseInt(matcher.group(1));
+            if (index < 0 || index > invocation.getArguments().length) {
+                return false;
+            }
+
+            //extract the argument value
+            Object object = invocation.getArguments()[index];
+            for (int i = 1; i < expressArray.length; i++) {
+                if (object == null) {
+                    return false;
+                }
+                Field field = object.getClass().getDeclaredField(expressArray[i]);
+                field.setAccessible(true);
+                object = field.get(object);
+            }
+
+            if (matchPair.getValue().isMatch((String)object, null)) {","[{'comment': 'Shall we adapt those types not match string? Or using toString?', 'commenter': 'AlbumenJ'}, {'comment': 'Good advice.', 'commenter': 'furaul'}]"
7378,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/ConditionRouter.java,"@@ -262,6 +276,54 @@ private boolean matchCondition(Map<String, MatchPair> condition, URL url, URL pa
         return result;
     }
 
+    /**
+     * analysis the arguments in the rule.
+     * Examples would be like this:
+     * ""arguments[0]=1"", whenCondition is that the first argument is equal to '1'.
+     * ""arguments[1].param=a"", whenCondition is that the 'param' attribute in the second argument is equal to 'a'.
+     * ""arguments[2].inner.param=b"", whenCondition is that the 'param' attribute in the 'inner' attribute of the third argument is equal to 'b'.","[{'comment': ""I think it's a good complement to have an argument matcher.\r\n\r\nI think it's better if we can make the argument routing rules simpler while still covering more than 90% of the usage scenarios.\r\n\r\nFor example, we only support the matching of string type parameters and do not support t matching of complex objects like `arguments[1].param`. Or even our routing rule is like a switch, when the user tells us to turn it on, we will constantly match the first parameter of the method and require that this parameter be a string or primitive type."", 'commenter': 'chickenlj'}, {'comment': '> I think it\'s a good complement to have an argument matcher.\r\n> \r\n> I think it\'s better if we can make the argument routing rules simpler while still covering more than 90% of the usage scenarios.\r\n> \r\n> For example, we only support the matching of string type parameters and do not support t matching of complex objects like `arguments[1].param`. Or even our routing rule is like a switch, when the user tells us to turn it on, we will constantly match the first parameter of the method and require that this parameter be a string or primitive type.\r\n\r\nI would like to simplify the arguments rule to make it easier to be understood and used.\r\nFor example,  we only support ""one flour param"", like  ""arguments[0]=1"", and only support java primary data type, like int, long, string and so on.\r\nBut I think it is not a good idea to make it like a switch, that would reduce flexibility. \r\nAnd in the future, I would like to config arguments router in the configuration pages, we could use drop-down box to choose the right arguments and its value. And in that time, we could expand the explementation of arguments router.\r\n@AlbumenJ ', 'commenter': 'furaul'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/Message.java,"@@ -0,0 +1,21 @@
+package org.apache.dubbo.rpc.protocol.tri;
+
+import java.io.InputStream;
+
+public class Message {
+    private Object headers;","[{'comment': '1. 定义成 Object 不合适，需要有具体的方法\r\n2. 好像没有地方调用getHeaders', 'commenter': 'guohao'}]"
7423,dubbo-common/src/main/java/org/apache/dubbo/common/stream/StreamObserver.java,"@@ -0,0 +1,9 @@
+package org.apache.dubbo.common.stream;
+
+public interface StreamObserver<T> {
+    void onNext(T var1) throws Exception;","[{'comment': 'onNext 不应该抛Exception', 'commenter': 'guohao'}]"
7423,dubbo-common/src/main/java/org/apache/dubbo/common/stream/StreamObserver.java,"@@ -0,0 +1,9 @@
+package org.apache.dubbo.common.stream;
+
+public interface StreamObserver<T> {
+    void onNext(T var1) throws Exception;
+
+    void onError(Throwable var1);","[{'comment': '变量名要有具体含义，不要用var/foo/bar  这种', 'commenter': 'guohao'}, {'comment': 'fix', 'commenter': 'panxiaojun233'}]"
7423,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java,"@@ -40,18 +46,54 @@
     private final Type[] returnTypes;
     private final String methodName;
     private final boolean generic;
+    private final boolean stream;","[{'comment': '可以抽象出一个方法类型枚举，将stream 和 needwrap 合成一个字段。stream 都是不需要 wrap 的，unary_wrap/ unary_unwrap 这种', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java,"@@ -43,11 +44,11 @@
             .withDescription(""Too many data"");
     private final ChannelHandlerContext ctx;
     private final URL url;
+    private boolean needWrap;","[{'comment': '这里的needwrap 能否改为MethodDescriptor', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java,"@@ -43,11 +44,11 @@
             .withDescription(""Too many data"");
     private final ChannelHandlerContext ctx;
     private final URL url;
+    private boolean needWrap;
     private MultipleSerialization multipleSerialization;
     private Http2Headers headers;
     private Http2Headers te;
-    private boolean needWrap;
-    private InputStream data;
+    private Queue<InputStream> datas = new ArrayDeque<>();","[{'comment': 'arrayDeque 会自动扩容，如果出现请求堆积，容易内存泄漏，这里设置一个合理的默认值，再提供参数配置是不是更合理，参考netty的各种参数格式', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java,"@@ -100,22 +97,26 @@ public Http2Headers getTe() {
         return te;
     }
 
+    public InputStream pollData() {
+        return datas.poll();
+    }
+
     public InputStream getData() {
-        return data;
+        return datas.peek();","[{'comment': '这个方法没用到', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientStream.java,"@@ -224,4 +224,7 @@ public void halfClose() {
         }
     }
 
+    @Override
+    protected void onSingleMessage(InputStream in) throws Exception {","[{'comment': '\x08TBD?', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/Message.java,"@@ -0,0 +1,21 @@
+package org.apache.dubbo.rpc.protocol.tri;
+
+import java.io.InputStream;
+
+public class Message {
+    private Object headers;
+    private InputStream is;","[{'comment': 'final', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/Processor.java,"@@ -0,0 +1,77 @@
+package org.apache.dubbo.rpc.protocol.tri;
+
+import java.io.InputStream;
+import java.util.ArrayDeque;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import com.google.protobuf.Message;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.serialize.MultipleSerialization;
+import org.apache.dubbo.rpc.model.MethodDescriptor;
+import org.apache.dubbo.triple.TripleWrapper;
+
+// metadata + is -> object
+// object -> is
+public class Processor {
+    private ServerStream serverStream;","[{'comment': 'final', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/Processor.java,"@@ -0,0 +1,77 @@
+package org.apache.dubbo.rpc.protocol.tri;
+
+import java.io.InputStream;
+import java.util.ArrayDeque;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import com.google.protobuf.Message;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.serialize.MultipleSerialization;
+import org.apache.dubbo.rpc.model.MethodDescriptor;
+import org.apache.dubbo.triple.TripleWrapper;
+
+// metadata + is -> object
+// object -> is
+public class Processor {
+    private ServerStream serverStream;
+    private MethodDescriptor md;
+    private String serializeType;
+    private MultipleSerialization multipleSerialization;
+    private URL url;
+
+    public Processor(ServerStream serverStream, MethodDescriptor md, URL url, String serializeType,
+        MultipleSerialization multipleSerialization) {
+        this.serverStream = serverStream;
+        this.md = md;
+        this.url = url;
+        this.serializeType = serializeType;
+        this.multipleSerialization = multipleSerialization;
+    }
+
+    public void onSingleMessage(InputStream in) throws Exception {
+        if (serverStream instanceof StreamServerStream) {","[{'comment': '用抽象，不要用instance of', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/Processor.java,"@@ -0,0 +1,77 @@
+package org.apache.dubbo.rpc.protocol.tri;
+
+import java.io.InputStream;
+import java.util.ArrayDeque;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import com.google.protobuf.Message;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.serialize.MultipleSerialization;
+import org.apache.dubbo.rpc.model.MethodDescriptor;
+import org.apache.dubbo.triple.TripleWrapper;
+
+// metadata + is -> object
+// object -> is
+public class Processor {
+    private ServerStream serverStream;
+    private MethodDescriptor md;
+    private String serializeType;
+    private MultipleSerialization multipleSerialization;
+    private URL url;
+
+    public Processor(ServerStream serverStream, MethodDescriptor md, URL url, String serializeType,
+        MultipleSerialization multipleSerialization) {
+        this.serverStream = serverStream;
+        this.md = md;
+        this.url = url;
+        this.serializeType = serializeType;
+        this.multipleSerialization = multipleSerialization;
+    }
+
+    public void onSingleMessage(InputStream in) throws Exception {
+        if (serverStream instanceof StreamServerStream) {
+            StreamServerStream stream = (StreamServerStream)serverStream;
+            final Object[] resp = decodeRequestMessage(in);
+            if (resp.length > 1) {
+                return;
+            }
+            stream.getObserver().onNext(resp[0]);
+        }
+
+    }
+
+    public Object[] decodeRequestMessage(InputStream is) {
+        if (md.isNeedWrap()) {","[{'comment': 'md 提供 unpack 是不是也合理，这块逻辑就能多协议复用了', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ServerInboundObserver.java,"@@ -0,0 +1,68 @@
+package org.apache.dubbo.rpc.protocol.tri;
+
+import java.io.InputStream;
+import java.util.Arrays;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.serialize.MultipleSerialization;
+import org.apache.dubbo.common.stream.StreamObserver;
+import org.apache.dubbo.config.Constants;
+import org.apache.dubbo.rpc.model.MethodDescriptor;
+import org.apache.dubbo.triple.TripleWrapper;
+
+public class ServerInboundObserver implements StreamObserver<Object> {","[{'comment': '这个类没用到吗', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/Stream.java,"@@ -25,7 +25,7 @@
 
     void onHeaders(Http2Headers headers);
 
-    void onData(InputStream in);
+    void onData(InputStream in) throws Exception;","[{'comment': '应该在内部处理Exception', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/StreamOutboundWriter.java,"@@ -0,0 +1,37 @@
+package org.apache.dubbo.rpc.protocol.tri;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.dubbo.common.stream.StreamObserver;
+
+public class StreamOutboundWriter implements StreamObserver<Object> {
+
+    private StreamServerStream stream;","[{'comment': '\x08final', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/StreamServerStream.java,"@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.tri;
+
+import java.io.InputStream;
+
+import com.google.protobuf.Message;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPromise;
+import io.netty.handler.codec.http.HttpHeaderNames;
+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;
+import io.netty.handler.codec.http2.DefaultHttp2Headers;
+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;
+import io.netty.handler.codec.http2.Http2Headers;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.stream.StreamObserver;
+import org.apache.dubbo.common.utils.ExecutorUtil;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcInvocation;
+import org.apache.dubbo.rpc.model.MethodDescriptor;
+import org.apache.dubbo.rpc.model.ServiceDescriptor;
+import org.apache.dubbo.rpc.protocol.tri.GrpcStatus.Code;
+
+import static io.netty.handler.codec.http.HttpResponseStatus.OK;
+
+public class StreamServerStream extends ServerStream implements Stream {
+    private static final Logger LOGGER = LoggerFactory.getLogger(StreamServerStream.class);
+
+    private StreamObserver<Object> observer;
+
+
+    public StreamServerStream(Invoker<?> invoker, ServiceDescriptor serviceDescriptor, MethodDescriptor md, ChannelHandlerContext ctx) {
+        super(invoker, ExecutorUtil.setThreadName(invoker.getUrl(), ""DubboPUServerHandler""), serviceDescriptor, md, ctx);
+    }
+
+
+    @Override
+    public void streamCreated(boolean endStream) throws Exception {
+        RpcInvocation inv = buildInvocation();
+        inv.setArguments(new Object[]{new StreamOutboundWriter(this)});
+        inv.setParameterTypes(new Class[] {StreamObserver.class});
+        inv.setReturnTypes(new Class[] {StreamObserver.class});
+
+        Result result = getInvoker().invoke(inv);
+        observer = (StreamObserver<Object>)result.get().getValue();
+        setProcessor(new Processor(this, getMd(), getUrl(), getSerializeType(), getMultipleSerialization()));
+        final Http2Headers headers = new DefaultHttp2Headers()
+            .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)
+            .status(OK.codeAsText())
+            .setInt(TripleConstant.STATUS_KEY, Code.OK.code);
+        getCtx().writeAndFlush(new DefaultHttp2HeadersFrame(headers, endStream));
+    }
+
+    @Override
+    protected void onSingleMessage(InputStream is) throws Exception {
+        getProcessor().onSingleMessage(is);
+    }
+
+
+    @Override
+    public void onError(GrpcStatus status) {
+    }
+
+    @Override
+    public void write(Object obj, ChannelPromise promise) throws Exception {
+        final Message message = (Message) obj;
+        final ByteBuf buf = getProcessor().encodeResponse(message, getCtx());
+        getCtx().write(new DefaultHttp2DataFrame(buf));","[{'comment': 'flush', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/StreamServerStream.java,"@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.tri;
+
+import java.io.InputStream;
+
+import com.google.protobuf.Message;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPromise;
+import io.netty.handler.codec.http.HttpHeaderNames;
+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;
+import io.netty.handler.codec.http2.DefaultHttp2Headers;
+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;
+import io.netty.handler.codec.http2.Http2Headers;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.stream.StreamObserver;
+import org.apache.dubbo.common.utils.ExecutorUtil;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcInvocation;
+import org.apache.dubbo.rpc.model.MethodDescriptor;
+import org.apache.dubbo.rpc.model.ServiceDescriptor;
+import org.apache.dubbo.rpc.protocol.tri.GrpcStatus.Code;
+
+import static io.netty.handler.codec.http.HttpResponseStatus.OK;
+
+public class StreamServerStream extends ServerStream implements Stream {
+    private static final Logger LOGGER = LoggerFactory.getLogger(StreamServerStream.class);
+
+    private StreamObserver<Object> observer;
+
+
+    public StreamServerStream(Invoker<?> invoker, ServiceDescriptor serviceDescriptor, MethodDescriptor md, ChannelHandlerContext ctx) {
+        super(invoker, ExecutorUtil.setThreadName(invoker.getUrl(), ""DubboPUServerHandler""), serviceDescriptor, md, ctx);
+    }
+
+
+    @Override
+    public void streamCreated(boolean endStream) throws Exception {
+        RpcInvocation inv = buildInvocation();
+        inv.setArguments(new Object[]{new StreamOutboundWriter(this)});
+        inv.setParameterTypes(new Class[] {StreamObserver.class});
+        inv.setReturnTypes(new Class[] {StreamObserver.class});
+
+        Result result = getInvoker().invoke(inv);
+        observer = (StreamObserver<Object>)result.get().getValue();
+        setProcessor(new Processor(this, getMd(), getUrl(), getSerializeType(), getMultipleSerialization()));
+        final Http2Headers headers = new DefaultHttp2Headers()
+            .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)
+            .status(OK.codeAsText())
+            .setInt(TripleConstant.STATUS_KEY, Code.OK.code);
+        getCtx().writeAndFlush(new DefaultHttp2HeadersFrame(headers, endStream));
+    }
+
+    @Override
+    protected void onSingleMessage(InputStream is) throws Exception {
+        getProcessor().onSingleMessage(is);
+    }
+
+
+    @Override
+    public void onError(GrpcStatus status) {
+    }
+
+    @Override
+    public void write(Object obj, ChannelPromise promise) throws Exception {
+        final Message message = (Message) obj;
+        final ByteBuf buf = getProcessor().encodeResponse(message, getCtx());
+        getCtx().write(new DefaultHttp2DataFrame(buf));
+    }
+
+    public void halfClose() throws Exception {
+        onComplete();
+    }
+
+
+    public void onComplete() {
+        final Http2Headers trailers = new DefaultHttp2Headers()","[{'comment': '需要判断 header /data/trailers 发送状态 避免异常时发送重复stream导致h2 error', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java,"@@ -43,22 +47,19 @@
             .withDescription(""Too many data"");
     private final ChannelHandlerContext ctx;
     private final URL url;
+    private final MethodDescriptor md;
     private MultipleSerialization multipleSerialization;
     private Http2Headers headers;
     private Http2Headers te;
-    private boolean needWrap;
-    private InputStream data;
+    private final Queue<InputStream> datas;
     private String serializeType;
 
-    protected AbstractStream(URL url, ChannelHandlerContext ctx) {
-        this(url, ctx, false);
-    }
-
-    protected AbstractStream(URL url, ChannelHandlerContext ctx, boolean needWrap) {
+    protected AbstractStream(URL url, ChannelHandlerContext ctx, MethodDescriptor md) {
         this.ctx = ctx;
         this.url = url;
-        this.needWrap = needWrap;
-        if (needWrap) {
+        this.md = md;
+        this.datas = new MpscChunkedArrayQueue<>(16, 1 << 30);","[{'comment': '会有 MPSC 的情况吗，SPSC是不是就够了', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java,"@@ -110,12 +107,16 @@ public MultipleSerialization getMultipleSerialization() {
 
     @Override
     public void onData(InputStream in) {
-        if (data != null) {
-            responseErr(ctx, TOO_MANY_DATA);
-            return;
+        //TODO requestN n>1 notify onNext(request)
+        try {
+            if (false) {
+                this.datas.add(in);
+            } else {
+                onSingleMessage(in);
+            }
+        } catch (Exception e) {
+            e.printStackTrace();","[{'comment': 'Log or throw exception', 'commenter': 'guohao'}]"
7423,dubbo-common/src/main/java/org/apache/dubbo/common/stream/StreamObserver.java,"@@ -0,0 +1,9 @@
+package org.apache.dubbo.common.stream;","[{'comment': 'Please add Apache License Header', 'commenter': 'AlbumenJ'}]"
7423,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java,"@@ -90,4 +134,19 @@ public boolean isGeneric() {
         return generic;
     }
 
+    public enum RpcType {","[{'comment': 'What about extract it as a independent class alone with MethodDescriptor class?', 'commenter': 'AlbumenJ'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/StreamServerStream.java,"@@ -0,0 +1,99 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.tri;
+
+import java.io.InputStream;
+
+import com.google.protobuf.Message;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPromise;
+import io.netty.handler.codec.http.HttpHeaderNames;
+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;
+import io.netty.handler.codec.http2.DefaultHttp2Headers;
+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;
+import io.netty.handler.codec.http2.Http2Headers;
+import io.netty.util.concurrent.Promise;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.stream.StreamObserver;
+import org.apache.dubbo.common.utils.ExecutorUtil;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcInvocation;
+import org.apache.dubbo.rpc.model.MethodDescriptor;
+import org.apache.dubbo.rpc.model.ServiceDescriptor;
+import org.apache.dubbo.rpc.protocol.tri.GrpcStatus.Code;
+
+import static io.netty.handler.codec.http.HttpResponseStatus.OK;
+
+public class StreamServerStream extends ServerStream implements Stream {
+    private static final Logger LOGGER = LoggerFactory.getLogger(StreamServerStream.class);
+
+    public StreamServerStream(Invoker<?> invoker, ServiceDescriptor serviceDescriptor, MethodDescriptor md, ChannelHandlerContext ctx) {
+        super(invoker, ExecutorUtil.setThreadName(invoker.getUrl(), ""DubboPUServerHandler""), serviceDescriptor, md, ctx);
+    }
+
+
+    @Override
+    public void streamCreated(boolean endStream, Promise promise) throws Exception {
+        RpcInvocation inv = buildInvocation();
+        inv.setArguments(new Object[]{new StreamOutboundWriter(this)});
+        inv.setParameterTypes(new Class[] {StreamObserver.class});
+        inv.setReturnTypes(new Class[] {StreamObserver.class});
+
+        Result result = getInvoker().invoke(inv);
+        setObserver((StreamObserver<Object>)result.get().getValue());
+        setProcessor(new Processor(this, getMd(), getUrl(), getSerializeType(), getMultipleSerialization()));
+        final Http2Headers headers = new DefaultHttp2Headers()
+            .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)
+            .status(OK.codeAsText())
+            .setInt(TripleConstant.STATUS_KEY, Code.OK.code);
+        getCtx().writeAndFlush(new DefaultHttp2HeadersFrame(headers, endStream));
+    }
+
+    @Override
+    protected void onSingleMessage(InputStream is) throws Exception {
+        getProcessor().onSingleMessage(is);
+    }
+
+
+    @Override
+    public void onError(GrpcStatus status) {
+    }
+
+    @Override
+    public void write(Object obj, ChannelPromise promise) {
+        final Message message = (Message) obj;
+        final ByteBuf buf = getProcessor().encodeResponse(message, getCtx());
+        getCtx().writeAndFlush(new DefaultHttp2DataFrame(buf));
+    }
+
+    public void halfClose() {
+        onComplete();
+    }
+
+
+    public void onComplete() {
+        // todo 需要判断 header /data/trailers 发送状态 避免异常时发送重复stream导致h2 error","[{'comment': 'pls comment in English', 'commenter': 'AlbumenJ'}]"
7423,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/MethodDescriptor.java,"@@ -40,21 +44,61 @@
     private final Type[] returnTypes;
     private final String methodName;
     private final boolean generic;
+    private final RpcType rpcType;
 
     public MethodDescriptor(Method method) {
         this.method = method;
-        this.parameterClasses = method.getParameterTypes();
-        this.returnClass = method.getReturnType();
+        Class<?>[] parameterTypes = method.getParameterTypes();
+        if (parameterTypes.length == 1 && isStreamType(parameterTypes[0])) {
+            this.parameterClasses = new Class<?>[] {
+                (Class<?>)((ParameterizedType)method.getGenericReturnType()).getActualTypeArguments()[0]};
+            this.returnClass = (Class<?>)((ParameterizedType)method.getGenericParameterTypes()[0])
+                .getActualTypeArguments()[0];
+            rpcType = RpcType.STREAM;
+        } else {
+            this.parameterClasses = method.getParameterTypes();
+            this.returnClass = method.getReturnType();
+            if (needWrap()) {
+                rpcType = RpcType.UNARY_WRAP;
+            } else {
+                rpcType = RpcType.UNARY_UNWRAP;
+            }
+        }
         this.returnTypes = ReflectUtils.getReturnTypes(method);
         this.paramDesc = ReflectUtils.getDesc(parameterClasses);
         this.compatibleParamSignatures = Stream.of(parameterClasses)
-                .map(Class::getName)
-                .toArray(String[]::new);
+            .map(Class::getName)
+            .toArray(String[]::new);
         this.methodName = method.getName();
         this.generic = (methodName.equals($INVOKE) || methodName.equals($INVOKE_ASYNC)) && parameterClasses.length == 3;
     }
 
-    public boolean matchParams (String params) {
+    public boolean isStream() {
+        return rpcType.equals(RpcType.STREAM);
+    }
+
+    public boolean isNeedWrap() {
+        return rpcType.equals(RpcType.UNARY_WRAP);
+    }
+
+    private boolean needWrap() {
+        if (CommonConstants.$INVOKE.equals(methodName) || CommonConstants.$INVOKE_ASYNC.equals(methodName)) {
+            return true;
+        } else if (""$echo"".equals(methodName)) {","[{'comment': '""$echo"" should be replaced with constant', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java,"@@ -177,6 +187,20 @@ protected void convertAttachment(Http2Headers trailers, Map<String, Object> atta
                     trailers.add(key + ""-tw-bin"", encoded);
                 }
             }
+        } catch (IOException e) {
+            // todo log","[{'comment': 'FIX', 'commenter': 'guohao'}]"
7423,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/StreamOutboundWriter.java,"@@ -0,0 +1,27 @@
+package org.apache.dubbo.rpc.protocol.tri;
+
+import org.apache.dubbo.common.stream.StreamObserver;
+
+public class StreamOutboundWriter implements StreamObserver<Object> {","[{'comment': '<T>', 'commenter': 'guohao'}, {'comment': '<T>', 'commenter': 'guohao'}, {'comment': '```suggestion\r\npublic class StreamOutboundWriter implements StreamObserver<T> {\r\n```', 'commenter': 'guohao'}]"
7433,dubbo-configcenter/dubbo-configcenter-apollo/src/test/java/org/apache/dubbo/configcenter/support/apollo/EmbeddedApolloJunit5.java,"@@ -0,0 +1,194 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.configcenter.support.apollo;
+
+import com.ctrip.framework.apollo.build.ApolloInjector;
+import com.ctrip.framework.apollo.core.dto.ApolloConfig;
+import com.ctrip.framework.apollo.core.dto.ApolloConfigNotification;
+import com.ctrip.framework.apollo.core.utils.ResourceUtils;
+import com.ctrip.framework.apollo.internals.ConfigServiceLocator;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.google.gson.Gson;
+import com.google.gson.reflect.TypeToken;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.Set;
+
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import org.junit.jupiter.api.extension.AfterAllCallback;
+import org.junit.jupiter.api.extension.BeforeAllCallback;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class EmbeddedApolloJunit5 implements BeforeAllCallback, AfterAllCallback {
+    private static final Logger logger = LoggerFactory.getLogger(EmbeddedApolloJunit5.class);
+    private static final Type notificationType = new TypeToken<List<ApolloConfigNotification>>() {
+    }.getType();
+
+    private static Method CONFIG_SERVICE_LOCATOR_CLEAR;
+    private static ConfigServiceLocator CONFIG_SERVICE_LOCATOR;
+
+    private static final Gson GSON = new Gson();
+    private final Map<String, Map<String, String>> addedOrModifiedPropertiesOfNamespace = Maps.newConcurrentMap();
+    private final Map<String, Set<String>> deletedKeysOfNamespace = Maps.newConcurrentMap();
+
+    private MockWebServer server;
+
+    static {
+        try {
+            System.setProperty(""apollo.longPollingInitialDelayInMills"", ""0"");
+            CONFIG_SERVICE_LOCATOR = ApolloInjector.getInstance(ConfigServiceLocator.class);
+            CONFIG_SERVICE_LOCATOR_CLEAR = ConfigServiceLocator.class.getDeclaredMethod(""initConfigServices"");
+            CONFIG_SERVICE_LOCATOR_CLEAR.setAccessible(true);
+        } catch (NoSuchMethodException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void clear() throws Exception {
+        resetOverriddenProperties();
+    }
+
+    private void mockConfigServiceUrl(String url) throws Exception {
+        System.setProperty(""apollo.configService"", url);
+
+        CONFIG_SERVICE_LOCATOR_CLEAR.invoke(CONFIG_SERVICE_LOCATOR);
+    }
+
+    private String loadConfigFor(String namespace) {
+        String filename = String.format(""mockdata-%s.properties"", namespace);
+        final Properties prop = ResourceUtils.readConfigFile(filename, new Properties());
+        Map<String, String> configurations = Maps.newHashMap();
+        for (String propertyName : prop.stringPropertyNames()) {
+            configurations.put(propertyName, prop.getProperty(propertyName));
+        }
+        ApolloConfig apolloConfig = new ApolloConfig(""someAppId"", ""someCluster"", namespace, ""someReleaseKey"");
+
+        Map<String, String> mergedConfigurations = mergeOverriddenProperties(namespace, configurations);
+        apolloConfig.setConfigurations(mergedConfigurations);
+        return GSON.toJson(apolloConfig);
+    }
+
+    private String mockLongPollBody(String notificationsStr) {
+        List<ApolloConfigNotification> oldNotifications = GSON.fromJson(notificationsStr, notificationType);
+        List<ApolloConfigNotification> newNotifications = new ArrayList<>();
+        for (ApolloConfigNotification notification : oldNotifications) {
+            newNotifications
+                    .add(new ApolloConfigNotification(notification.getNamespaceName(), notification.getNotificationId() + 1));
+        }
+        return GSON.toJson(newNotifications);
+    }
+
+    /**
+     * 合并用户对namespace的修改","[{'comment': 'Pls comment in eng', 'commenter': 'AlbumenJ'}, {'comment': '👌', 'commenter': 'xiaoheng1'}]"
7438,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java,"@@ -212,9 +228,26 @@ private String generateReferenceBeanName(AnnotationAttributes attributes, Class<
         if (!attributes.isEmpty()) {
             beanNameBuilder.append('(');
             for (Map.Entry<String, Object> entry : attributes.entrySet()) {
+                String value;
+                if (entry.getValue().getClass().isArray()) {
+                    String[] entryValues = (String[]) entry.getValue();
+                    if (""parameters"".equals(entry.getKey())) {
+                        // parameters spec is {key1,value1,key2,value2}
+                        ArrayList<String> kvList = new ArrayList<>();
+                        for (int i = 0; i < entryValues.length / 2 * 2; i = i + 2) {","[{'comment': '` i < entryValues.length / 2 * 2` changed to  `i < entryValues.length`.', 'commenter': 'zonghaishang'}, {'comment': 'This is to avoid mistake useage like {key1,value1,key2,value2,key3}\r\n', 'commenter': 'zhangyz-hd'}]"
7438,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java,"@@ -344,4 +377,14 @@ public void destroy() throws Exception {
         this.injectedFieldReferenceBeanCache.clear();
         this.injectedMethodReferenceBeanCache.clear();
     }
+
+    @Override
+    public void onApplicationEvent(ApplicationEvent event) {
+        if (event instanceof ContextRefreshedEvent) {
+            referencedBeanNameIdx.entrySet().stream().filter(e -> e.getValue().size() > 1).forEach(e -> {","[{'comment': 'release referencedBeanNameIdx resource after app started.', 'commenter': 'zonghaishang'}, {'comment': 'OK', 'commenter': 'zhangyz-hd'}]"
7438,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java,"@@ -61,8 +61,9 @@
 
     private final Set<String> serviceNames;
     private final ServiceDiscovery serviceDiscovery;
+    private final String registryId;
     private URL url;
-    private Map<String, NotifyListener> listeners;
+    private Map<String, List<NotifyListener>> listeners;","[{'comment': 'List<NotifyListener>改成Set<NotifyListener>', 'commenter': 'zonghaishang'}, {'comment': 'OK~', 'commenter': 'zhangyz-hd'}]"
7438,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java,"@@ -211,10 +229,19 @@ private String generateReferenceBeanName(AnnotationAttributes attributes, Class<
 
         if (!attributes.isEmpty()) {
             beanNameBuilder.append('(');
-            for (Map.Entry<String, Object> entry : attributes.entrySet()) {
-                beanNameBuilder.append(entry.getKey())
+            //sort attributes keys
+            List<String> sortedAttrKeys = new ArrayList<>(attributes.keySet());
+            Collections.sort(sortedAttrKeys);
+            for (String key : sortedAttrKeys) {
+                Object value = attributes.get(key);
+                //handle method array, generic array
+                if (value != null && value.getClass().isArray()) {
+                    Object[] array = ObjectUtils.toObjectArray(value);
+                    value = Arrays.toString(array);","[{'comment': 'It seems that `@Method`\'s `@Argument` array is not handled properly.\r\n```\r\n@DubboReference(methods = @Method(name = ""sayHello"", timeout = 100, arguments = @Argument(index = 0, callback = true)))\r\n```\r\n\r\nSome code snippets:\r\n\r\n```\r\nfor (String key : sortedAttrKeys) {\r\n      Object value = attributes.get(key);\r\n      value = convertAttribute(value);\r\n      beanNameBuilder.append(key)\r\n              .append(\'=\')\r\n              .append(value)\r\n              .append(\',\');\r\n}\r\n```\r\n\r\n```\r\n    private Object convertAttribute(Object obj) {\r\n        if (obj == null) {\r\n            return null;\r\n        }\r\n        if (obj instanceof Annotation) {\r\n            AnnotationAttributes attributes = AnnotationUtils.getAnnotationAttributes((Annotation) obj, true);\r\n            for (Map.Entry<String, Object> entry : attributes.entrySet()) {\r\n                entry.setValue(convertAttribute(entry.getValue()));\r\n            }\r\n            return attributes;\r\n        } else if (obj.getClass().isArray()) {\r\n            Object[] array = ObjectUtils.toObjectArray(obj);\r\n            Object[] newArray = new Object[array.length];\r\n            for (int i = 0; i < array.length; i++) {\r\n                newArray[i] = convertAttribute(array[i]);\r\n            }\r\n            return Arrays.toString(newArray);\r\n        } else {\r\n            return obj;\r\n        }\r\n    }\r\n```\r\n', 'commenter': 'kylixs'}]"
7466,dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java,"@@ -38,15 +37,12 @@
  */
 
 public class CacheListener implements DataListener {","[{'comment': 'Is CacheListener still needed? Can we connect TargetListener(zookeeper listener) and DataListener(dubbo listener) directly?', 'commenter': 'chickenlj'}, {'comment': 'CacheListener can hold same path listeners, ZookeeperListener : ConfigurationListener -> 1 : N.\r\nWe still use CacheListener, ZookeeperListener : CacheListener -> 1 : 1, CacheListener : ConfigurationListener -> 1 : N.\r\n\r\nCacheListener is an adapter, it holds real listeners,  and adapt kinds of listener (zookeeper, nacos ...)', 'commenter': 'horizonzy'}]"
7466,dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/ZookeeperDynamicConfiguration.java,"@@ -107,10 +94,12 @@ protected boolean doRemoveConfig(String pathKey) throws Exception {
     @Override
     protected void doAddListener(String pathKey, ConfigurationListener listener) {
         cacheListener.addListener(pathKey, listener);
+        zkClient.addDataListener(pathKey, cacheListener, executor);
     }
 
     @Override
     protected void doRemoveListener(String pathKey, ConfigurationListener listener) {
         cacheListener.removeListener(pathKey, listener);
+        zkClient.removeDataListener(pathKey, cacheListener);","[{'comment': 'What if cacheListener holds more than one DataListener? Should we check dataListener size before stop listening from zookeeper', 'commenter': 'chickenlj'}, {'comment': 'right.', 'commenter': 'horizonzy'}]"
7466,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java,"@@ -218,47 +218,48 @@ public void doClose() {
 
     @Override
     protected CuratorZookeeperClient.CuratorWatcherImpl createTargetDataListener(String path, DataListener listener) {
-        return new CuratorWatcherImpl(client, listener);
+        return new CuratorWatcherImpl(client, listener, path);
     }
 
     @Override
-    protected void addTargetDataListener(String path, CuratorZookeeperClient.CuratorWatcherImpl treeCacheListener) {
-        this.addTargetDataListener(path, treeCacheListener, null);
+    protected void addTargetDataListener(String path, CuratorZookeeperClient.CuratorWatcherImpl nodeCacheListener) {
+        this.addTargetDataListener(path, nodeCacheListener, null);
     }
 
     @Override
-    protected void addTargetDataListener(String path, CuratorZookeeperClient.CuratorWatcherImpl treeCacheListener, Executor executor) {
+    protected void addTargetDataListener(String path, CuratorZookeeperClient.CuratorWatcherImpl nodeCacheListener, Executor executor) {
         try {
-            TreeCache treeCache = TreeCache.newBuilder(client, path).setCacheData(false).build();
-            treeCacheMap.putIfAbsent(path, treeCache);
-
+            NodeCache nodeCache = new NodeCache(client, path);
+            if (nodeCacheMap.putIfAbsent(path, nodeCache) != null) {
+                return;
+            }
             if (executor == null) {
-                treeCache.getListenable().addListener(treeCacheListener);
+                nodeCache.getListenable().addListener(nodeCacheListener);
             } else {
-                treeCache.getListenable().addListener(treeCacheListener, executor);
+                nodeCache.getListenable().addListener(nodeCacheListener, executor);
             }
 
-            treeCache.start();
+            nodeCache.start();
         } catch (Exception e) {
-            throw new IllegalStateException(""Add treeCache listener for path:"" + path, e);
+            throw new IllegalStateException(""Add nodeCache listener for path:"" + path, e);
         }
     }
 
     @Override
-    protected void removeTargetDataListener(String path, CuratorZookeeperClient.CuratorWatcherImpl treeCacheListener) {
-        TreeCache treeCache = treeCacheMap.get(path);
-        if (treeCache != null) {
-            treeCache.getListenable().removeListener(treeCacheListener);
+    protected void removeTargetDataListener(String path, CuratorZookeeperClient.CuratorWatcherImpl nodeCacheListener) {
+        NodeCache nodeCache = nodeCacheMap.get(path);
+        if (nodeCache != null) {
+            nodeCache.getListenable().removeListener(nodeCacheListener);
         }
-        treeCacheListener.dataListener = null;
+        nodeCacheListener.dataListener = null;
     }
 
     @Override
     public void removeTargetChildListener(String path, CuratorWatcherImpl listener) {
         listener.unwatch();
     }
 
-    static class CuratorWatcherImpl implements CuratorWatcher, TreeCacheListener {
+    static class CuratorWatcherImpl implements CuratorWatcher, NodeCacheListener {","[{'comment': 'I suggest we separate CuratorWatcherImpl into two classes, one with a single responsbility.', 'commenter': 'chickenlj'}, {'comment': 'agree', 'commenter': 'horizonzy'}]"
7484,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java,"@@ -138,42 +136,28 @@ protected static int getIntConfig(String key, int def) {
             }
         }
 
+        evictUrlForConsumer(consumer);
         stringUrls.put(consumer, newURLs);
 
-        // destroy used urls
-        try {
-            if (oldURLs != null && oldURLs.size() > 0) {
-                Long currentTimestamp = System.currentTimeMillis();
-                for (Map.Entry<String, ServiceAddressURL> entry : oldURLs.entrySet()) {
-                    waitForRemove.put(entry.getValue(), currentTimestamp);
-                }
-                if (CollectionUtils.isNotEmptyMap(waitForRemove)) {
-                    if (semaphore.tryAcquire()) {
-                        cacheRemovalScheduler.schedule(new RemovalTask(), cacheRemovalTaskIntervalInMillis, TimeUnit.MILLISECONDS);
-                    }
-                }
-            }
-        } catch (Exception e) {
-            logger.warn(""Failed to evict url for "" + consumer, e);
-        }
-
         return new ArrayList<>(newURLs.values());
     }
 
     protected List<URL> toUrlsWithEmpty(URL consumer, String path, Collection<String> providers) {
-        List<URL> urls;
-        if (CollectionUtils.isEmpty(providers)) {
-            urls = new ArrayList<>(1);
-            // clear cache on empty notification: unsubscribe or provider offline
-            stringUrls.remove(consumer);
+        List<URL> urls = new ArrayList<>(1);","[{'comment': 'plz resolve the conflicts first', 'commenter': 'kimmking'}, {'comment': 'done', 'commenter': 'kevinw66'}]"
7486,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java,"@@ -52,50 +52,7 @@ public ChannelEventRunnable(Channel channel, ChannelHandler handler, ChannelStat
 
     @Override
     public void run() {
-        if (state == ChannelState.RECEIVED) {","[{'comment': 'Please refer to this link for why this if branch is added: https://blog.csdn.net/hengyunabc/article/details/80342163', 'commenter': 'chickenlj'}]"
7493,dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java,"@@ -166,14 +172,8 @@ private static Wrapper makeWrapper(Class<?> c) {
                 int len = m.getParameterTypes().length;
                 c3.append("" && "").append("" $3.length == "").append(len);
 
-                boolean overload = false;
-                for (Method m2 : methods) {
-                    if (m != m2 && m.getName().equals(m2.getName())) {
-                        overload = true;
-                        break;
-                    }
-                }
-                if (overload) {
+                boolean override = sameNameMethodCount.get(m.getName()) > 1;
+                if (override) {","[{'comment': 'this situation should be `overload`', 'commenter': 'AlbumenJ'}]"
7493,dubbo-common/src/test/java/org/apache/dubbo/common/bytecode/WrapperTest.java,"@@ -113,6 +114,26 @@ public void testNoSuchMethod() throws Exception {
         });
     }
 
+    @Test
+    public void testOverrideMethod() throws Exception {","[{'comment': 'please also change this method name to `overload`', 'commenter': 'AlbumenJ'}]"
7493,dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java,"@@ -154,6 +154,12 @@ private static Wrapper makeWrapper(Class<?> c) {
         // get all public method.
         boolean hasMethod = hasMethods(methods);
         if (hasMethod) {
+            Map<String, Integer> sameNameMethodCount = new HashMap<>();","[{'comment': 'it would be better if we give it a big enough initial size, such as `(int) (methods.size() / 0.75f) + 1`', 'commenter': 'AlbumenJ'}]"
7494,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java,"@@ -96,9 +96,15 @@ private static RootBeanDefinition parse(Element element, ParserContext parserCon
                 generatedBeanName = beanClass.getName();
             }
             id = generatedBeanName;
-            int counter = 2;
-            while (parserContext.getRegistry().containsBeanDefinition(id)) {
-                id = generatedBeanName + (counter++);
+            if (parserContext.getRegistry().containsBeanDefinition(id)) {
+                if (beanClass.equals(ServiceBean.class)) {
+                    return (RootBeanDefinition) parserContext.getRegistry().getBeanDefinition(id);","[{'comment': ""According to issue #7478, ignoring the duplicate service bean is not a good solution. Don't avoid the error. The problem of duplicate definition should be prompted to the user to deal with."", 'commenter': 'kylixs'}, {'comment': 'should an exception be thrown?', 'commenter': 'zhongxiongzeng'}, {'comment': 'well, i fixed the code, can you review this pr again?', 'commenter': 'zhongxiongzeng'}]"
7494,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java,"@@ -96,9 +96,15 @@ private static RootBeanDefinition parse(Element element, ParserContext parserCon
                 generatedBeanName = beanClass.getName();
             }
             id = generatedBeanName;
-            int counter = 2;
-            while (parserContext.getRegistry().containsBeanDefinition(id)) {
-                id = generatedBeanName + (counter++);
+            if (parserContext.getRegistry().containsBeanDefinition(id)) {
+                if (beanClass.equals(ServiceBean.class)) {
+                    throw new IllegalStateException(""Duplicate service bean id "" + id);","[{'comment': 'I think it is only necessary to prohibit the automatic renaming of ServiceBean, and the problem of duplicate bean definition has been checked later.\r\n\r\n```\r\nif (!beanClass.equals(ServiceBean.class)) {\r\n            int counter = 2;\r\n            while (parserContext.getRegistry().containsBeanDefinition(id)) {\r\n                id = generatedBeanName + (counter++);\r\n            }\r\n}\r\n```', 'commenter': 'kylixs'}, {'comment': 'Yeah，you are right ', 'commenter': 'zhongxiongzeng'}, {'comment': 'i fixed it', 'commenter': 'zhongxiongzeng'}]"
7494,dubbo-config/dubbo-config-spring/src/test/resources/META-INF/spring/multiple-services-with-methods.xml,"@@ -1,45 +1,45 @@
-<!--
-  Licensed to the Apache Software Foundation (ASF) under one or more
-  contributor license agreements.  See the NOTICE file distributed with
-  this work for additional information regarding copyright ownership.
-  The ASF licenses this file to You under the Apache License, Version 2.0
-  (the ""License""); you may not use this file except in compliance with
-  the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an ""AS IS"" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
-  -->
-<beans xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
-       xmlns:dubbo=""http://dubbo.apache.org/schema/dubbo""
-       xmlns=""http://www.springframework.org/schema/beans""
-       xsi:schemaLocation=""http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
-    http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd
-    "">
-
-    <!-- current application configuration -->
-    <dubbo:application id=""application"" name=""demo-provider""/>
-
-    <!-- registry center configuration -->
-    <dubbo:registry id=""registry"" address=""N/A""/>
-
-    <!-- protocol configuration -->
-    <dubbo:protocol name=""dubbo"" port=""-1""/>
-
-    <!-- service configuration -->
-    <dubbo:service interface=""org.apache.dubbo.config.spring.api.DemoService""
-                   class=""org.apache.dubbo.config.spring.impl.DemoServiceImpl"">
-        <dubbo:method name=""sayName"" timeout=""500"" />
-    </dubbo:service>
-
-    <dubbo:service interface=""org.apache.dubbo.config.spring.api.DemoService""
-                   class=""org.apache.dubbo.config.spring.impl.DemoServiceImpl_LongWaiting"">
-        <dubbo:method name=""sayName"" timeout=""1000"" />
-    </dubbo:service>
-
-
+<!--","[{'comment': 'please recover end-line format of this file', 'commenter': 'AlbumenJ'}]"
7494,dubbo-config/dubbo-config-spring/src/test/resources/META-INF/spring/multiple-services-with-methods.xml,"@@ -31,15 +31,15 @@
     <dubbo:protocol name=""dubbo"" port=""-1""/>
 
     <!-- service configuration -->
-    <dubbo:service interface=""org.apache.dubbo.config.spring.api.DemoService""
+    <dubbo:service id = ""demoServiceImpl"" interface=""org.apache.dubbo.config.spring.api.DemoService""","[{'comment': 'please revert it', 'commenter': 'kylixs'}]"
7494,dubbo-config/dubbo-config-spring/src/test/resources/META-INF/spring/multiple-services-with-methods.xml,"@@ -31,15 +31,15 @@
     <dubbo:protocol name=""dubbo"" port=""-1""/>
 
     <!-- service configuration -->
-    <dubbo:service interface=""org.apache.dubbo.config.spring.api.DemoService""
+    <dubbo:service id = ""demoServiceImpl"" interface=""org.apache.dubbo.config.spring.api.DemoService""
                    class=""org.apache.dubbo.config.spring.impl.DemoServiceImpl"">
         <dubbo:method name=""sayName"" timeout=""500"" />
     </dubbo:service>
 
-    <dubbo:service interface=""org.apache.dubbo.config.spring.api.DemoService""
+    <dubbo:service id = ""demoServiceImpl_LongWaiting"" interface=""org.apache.dubbo.config.spring.api.DemoService""","[{'comment': 'remove the id', 'commenter': 'kylixs'}]"
7494,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/schema/DubboBeanDefinitionParser.java,"@@ -419,4 +403,32 @@ private static String resolveAttribute(Element element, String attributeName, Pa
         Environment environment = parserContext.getReaderContext().getEnvironment();
         return environment.resolvePlaceholders(attributeValue);
     }
+
+    private static String generateId(Element element, ParserContext parserContext, Class<?> beanClass, boolean required) {
+        String id = resolveAttribute(element, ""id"", parserContext);
+        if (StringUtils.isEmpty(id) && required) {
+            String generatedBeanName = resolveAttribute(element, ""name"", parserContext);
+
+            if (StringUtils.isEmpty((generatedBeanName))) {
+                if (ProtocolConfig.class.equals(beanClass)) {
+                    generatedBeanName = CommonConstants.DUBBO;
+                } else {
+                    generatedBeanName = resolveAttribute(element, CommonConstants.INTERFACE_KEY, parserContext);
+                    generatedBeanName = StringUtils.isEmpty(generatedBeanName) ? beanClass.getName() : generatedBeanName;
+                    if (beanClass.equals(ServiceBean.class)) {
+                        String groupName = resolveAttribute(element, CommonConstants.GROUP_KEY, parserContext);","[{'comment': 'Not suggested, forget this.\r\n> Here you need to check whether the group/version is empty, if it is empty, try to read from the provider config if the `provider` or `providerIds` attribute is not empty.  \r\n> \r\n> NOTE: If present  `provider` attribure, it may be a  `RuntimeBeanReference` of nest config.\r\n> ```\r\n> <dubbo:provider group=""demo""  version=""1.2.3"" >\r\n>     <dubbo:service .../>\r\n> </dubbo:provider>\r\n> ```\r\n> \r\n> If present `providerIds`, it may be the provider bean name.\r\n> \r\n> ```\r\n> <dubbo:provider id=""myprovider"" group=""demo""  version=""1.2.3"" />\r\n> <dubbo:service ... provider=""myprovider"" />\r\n> ```\r\n> \r\n> There are still some omissions, such as setting group/version in the default provider config. But it is more complicated to get the default provider config and may not be registered yet.', 'commenter': 'kylixs'}]"
7494,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -724,4 +736,45 @@ public DubboBootstrap getBootstrap() {
     public void setBootstrap(DubboBootstrap bootstrap) {
         this.bootstrap = bootstrap;
     }
+
+    protected void delayExport() {","[{'comment': ""Why add the 'delayExport' method?"", 'commenter': 'kylixs'}, {'comment': 'this is hook method for ServiceBean，when the program is delayed to execute the export method for a period of time, the application context may have been destroyed, and there is no need to execute the export method at this time', 'commenter': 'zhongxiongzeng'}, {'comment': 'Dubbo and spring context are independent. Do you mean that DubboBootstrap has been destroyed before export service? At this time, export service check status throws an exception.', 'commenter': 'kylixs'}, {'comment': 'NO NO ,  when Spring context destoryed, the DubboBootStrap destroy also .but another Spring application context is starting and the configManager is reconfigured. At this time, the Service Config of the previous Spring application context can still be exported.\r\n\r\nthis is what I found while debugging two consecutive Test case', 'commenter': 'zhongxiongzeng'}]"
7494,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -724,4 +736,45 @@ public DubboBootstrap getBootstrap() {
     public void setBootstrap(DubboBootstrap bootstrap) {
         this.bootstrap = bootstrap;
     }
+
+    protected void delayExport() {
+        doExport();
+    }
+
+    private void duplicateExportCheck() {","[{'comment': ""I think it would be better to extract the service bean triple check to another class, such as DubboBootstrap / ConfigManager.\r\nThe `serviceBeanId` field name is not appropriate enough, it may be misunderstood as spring bean id/name.\r\n\r\nIt is recommended to use the non-static Set<String> field to save the state instead of using a static object. Static objects will bring a lot of state problems, don't use it unless necessary\r\n"", 'commenter': 'kylixs'}, {'comment': 'when I checked the test cases, I also found that writing this way will cause a lot of issues.\r\nthank you for your guidance', 'commenter': 'zhongxiongzeng'}]"
7494,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -724,4 +736,45 @@ public DubboBootstrap getBootstrap() {
     public void setBootstrap(DubboBootstrap bootstrap) {
         this.bootstrap = bootstrap;
     }
+
+    protected void delayExport() {
+        doExport();
+    }
+
+    private void duplicateExportCheck() {
+        String generateVersion = version;
+        String generateGroup = group;
+
+        if (StringUtils.isBlank(version) && provider != null) {
+            generateVersion = provider.getVersion();
+        }
+
+        if (StringUtils.isBlank(group) && provider != null) {
+            generateGroup = provider.getGroup();
+        }
+        StringBuilder stringBuilder = new StringBuilder();
+        stringBuilder.append(""ServiceBean:"");
+
+        if (!StringUtils.isBlank(generateGroup)) {
+            stringBuilder.append(generateGroup);
+        }
+
+        stringBuilder.append(""/"").append(interfaceName);
+
+        if (!StringUtils.isBlank(generateVersion)) {
+            stringBuilder.append("":"").append(generateVersion);
+        }
+
+        serviceBeanId = stringBuilder.toString();
+
+        if (exportedServiceBeanIds.contains(serviceBeanId)) {
+            throw new IllegalArgumentException(""The Duplicated BeanDefinition of ServiceBean[group:"" +","[{'comment': '\r\nThe error message should include the conflicting ServiceConfig instances (toString directly), which makes it easier to locate the sources of the problem.', 'commenter': 'kylixs'}, {'comment': 'ok, thanks for your guidance', 'commenter': 'zhongxiongzeng'}]"
7494,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java,"@@ -1080,23 +1083,33 @@ private void exportServices() {
             if (exportAsync) {
                 ExecutorService executor = executorRepository.getServiceExporterExecutor();
                 Future<?> future = executor.submit(() -> {
-                	try {
-                        sc.export();
-                        exportedServices.add(sc);
-                	}catch (Throwable t) {
-                		logger.error(""export async catch error : "" + t.getMessage(), t);
-					}
+                  try{
+                    exportService(serviceConfig);
+                  }catch(Throwable t){
+                    logger.error(""export async catch error : "" + t.getMessage(), t);
+                  }
                 });
                 asyncExportingFutures.add(future);
             } else {
-                sc.export();
-                exportedServices.add(sc);
+                exportService(serviceConfig);
             }
         });
     }
 
+    private void exportService(ServiceConfig sc){
+        if (exportedServiceNames.contains(sc.getServiceName())) {
+            throw new IllegalArgumentException(""The Duplicated BeanDefinition of ServiceBean[ServiceConfig:"" +","[{'comment': 'Using IllegalStateException is better than IllegalArgumentException here.', 'commenter': 'kylixs'}, {'comment': 'Need to print duplicate ServiceName.\r\nIt would be better if duplicate instances of ServiceConfig could be printed.', 'commenter': 'kylixs'}, {'comment': ""Need to explain the inspection rules, triples (group, interface, version) cannot be repeated. Users who see errors need to know what's going on and how to fix them."", 'commenter': 'kylixs'}, {'comment': 'ok , all changes pushed, could you pls help me to fix test case.\r\nhttps://github.com/apache/dubbo/issues/7623', 'commenter': 'zhongxiongzeng'}]"
7494,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java,"@@ -182,9 +182,7 @@
 
     private volatile MetadataServiceExporter metadataServiceExporter;
 
-    private List<ServiceConfigBase<?>> exportedServices = new ArrayList<>();
-
-    private Set<String> exportedServiceNames = new HashSet<>();
+    private Map<String, ServiceConfigBase<?>> exportedServices = new HashMap<>();","[{'comment': 'Change to ConcurrentHashMap to ensure thread safety', 'commenter': 'kylixs'}]"
7494,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java,"@@ -1096,20 +1094,20 @@ private void exportServices() {
         });
     }
 
-    private void exportService(ServiceConfig sc){
-        if (exportedServiceNames.contains(sc.getServiceName())) {
-            throw new IllegalArgumentException(""The Duplicated BeanDefinition of ServiceBean[ServiceConfig:"" +
-                    sc.toString() + ""] try to export"");
+    private void exportService(ServiceConfig sc) {
+        if (exportedServices.containsKey(sc.getServiceName())) {
+            throw new IllegalStateException(""The Duplicated BeanDefinition of ServiceBean[ServiceName: "" +
+                    sc.getServiceName() + ""ServiceConfig:"" +","[{'comment': 'A description example:\r\n\r\nThere are multiple ServiceBean instances with the same service name: [group/interface:version], instances: [serviceConfig1, serviceConfig2 ]. Only one service can be exported for the same triple (group, interface, version), please modify the group or version if you really need to export multiple services of the same interface.', 'commenter': 'kylixs'}, {'comment': 'ok ,thank you', 'commenter': 'zhongxiongzeng'}]"
7498,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParser.java,"@@ -137,8 +137,6 @@
 
     private static String toParameterString(ConfigItem item) {
         StringBuilder sb = new StringBuilder();
-        sb.append(""category="");
-        sb.append(DYNAMIC_CONFIGURATORS_CATEGORY);","[{'comment': 'I think we should keep this two lines and remove `urlBuilder.append(""&category="").append(DYNAMIC_CONFIGURATORS_CATEGORY);` \r\nin the caller mehod.', 'commenter': 'chickenlj'}, {'comment': 'Yes, you are right. it\'s my fault that I didn\'t look carefully. method appItemToUrls also calls the method toParameterString, and it is filled with the ""appdynamicconfigurators"" parameter.Indeed, only the serviceItemToUrls method has the ""category"" parameter repeatedly added.', 'commenter': 'BurningCN'}, {'comment': 'Hi, do you have time to fix this issue so we can merge this patch soon？', 'commenter': 'chickenlj'}, {'comment': 'I have modified it, but there are multiple commit logs under this PR, do I need to re-issue a new PR request to merge?', 'commenter': 'BurningCN'}]"
7534,dubbo-common/src/main/java/org/apache/dubbo/common/constants/ClusterRules.java,"@@ -0,0 +1,48 @@
+package org.apache.dubbo.common.constants;","[{'comment': 'pls add asf license header', 'commenter': 'AlbumenJ'}]"
7534,dubbo-common/src/main/java/org/apache/dubbo/common/constants/ClusterRules.java,"@@ -0,0 +1,48 @@
+package org.apache.dubbo.common.constants;
+
+/**
+ *  constant for Cluster fault-tolerant mode
+ * @author lucky-pan","[{'comment': 'please remove author tag, thx', 'commenter': 'AlbumenJ'}]"
7534,dubbo-common/src/main/java/org/apache/dubbo/common/constants/LoadbalanceRules.java,"@@ -0,0 +1,36 @@
+package org.apache.dubbo.common.constants;","[{'comment': 'also for this file', 'commenter': 'AlbumenJ'}]"
7534,dubbo-common/src/main/java/org/apache/dubbo/config/annotation/Reference.java,"@@ -167,11 +170,9 @@
     int retries() default 2;
 
     /**
-     * Load balance strategy, legal values include: random, roundrobin, leastactive
-     * <p>
-     * see Constants#DEFAULT_LOADBALANCE
+     * Load balance strategy, you can use {@link org.apache.dubbo.common.constants.LoadbalanceRules#RANDOM} ……
      */
-    String loadbalance() default """";
+    String loadbalance() default LoadbalanceRules.RANDOM;","[{'comment': 'maintain the original logic, use empty str.', 'commenter': 'horizonzy'}, {'comment': 'OK（前辈睡的有点晚/捂脸）', 'commenter': 'rockit-ba'}]"
7602,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -286,19 +288,29 @@ private void shutdownServiceNamesLookup() {
     private Set<String> filterServiceNames(NacosServiceName serviceName) {
         Set<String> serviceNames = new LinkedHashSet<>();
 
-        execute(namingService -> {
+        execute(namingService -> serviceNames.addAll(namingService.getServicesOfServer(1, Integer.MAX_VALUE,
+                getUrl().getParameter(GROUP_KEY, Constants.DEFAULT_GROUP)).getData()
+                .stream()
+                .filter(this::isConformRules)
+                .map(NacosServiceName::new)
+                .filter(serviceName::isCompatible)
+                .map(NacosServiceName::toString)
+                .collect(Collectors.toList())));
 
-            serviceNames.addAll(namingService.getServicesOfServer(1, Integer.MAX_VALUE,
-                    getUrl().getParameter(GROUP_KEY, Constants.DEFAULT_GROUP)).getData()
-                    .stream()
-                    .map(NacosServiceName::new)
-                    .filter(serviceName::isCompatible)
-                    .map(NacosServiceName::toString)
-                    .collect(Collectors.toList()));
+        return serviceNames;
+    }
 
-        });
+    /**
+     * Verify whether it is a dubbo service
+     *
+     * @param serviceName
+     * @return
+     * @since 2.7.11
+     */
+    public boolean isConformRules(String serviceName) {
+
+        return serviceName.split(NAME_SEPARATOR, -1).length == 4;","[{'comment': 'you should make more unit tests for this new case.', 'commenter': 'kimmking'}, {'comment': 'done', 'commenter': 'CrazyHZM'}]"
7610,dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ServiceConfigTest.java,"@@ -40,16 +40,7 @@
 import java.util.Collections;
 import java.util.concurrent.TimeUnit;
 
-import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.APPLICATION_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.GENERIC_SERIALIZATION_BEAN;
-import static org.apache.dubbo.common.constants.CommonConstants.GENERIC_SERIALIZATION_DEFAULT;
-import static org.apache.dubbo.common.constants.CommonConstants.GENERIC_SERIALIZATION_NATIVE_JAVA;
-import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER;
-import static org.apache.dubbo.common.constants.CommonConstants.SHUTDOWN_WAIT_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.*;","[{'comment': 'pls do not use comma import', 'commenter': 'AlbumenJ'}, {'comment': 'changed', 'commenter': 'wuwen5'}]"
7637,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java,"@@ -90,7 +94,9 @@ public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
                     generic = RpcContext.getContext().getAttachment(GENERIC_KEY);
                 }
 
-                if (StringUtils.isEmpty(generic)
+                if (ProtocolUtils.isGsonGenericSerialization(generic)) {","[{'comment': 'Code clean: This case should after origin first `if` judgement.', 'commenter': 'horizonzy'}, {'comment': 'agree with horizonzy', 'commenter': 'kimmking'}, {'comment': 'get', 'commenter': 'goodjava'}]"
7637,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java,"@@ -174,6 +180,14 @@ public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
         return invoker.invoke(inv);
     }
 
+    private Object[] getArgs(final Object[] args, Type[] types) {
+        Gson gson = new Gson();","[{'comment': 'transfer to instance variable.', 'commenter': 'horizonzy'}, {'comment': 'get', 'commenter': 'goodjava'}]"
7637,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java,"@@ -174,6 +180,14 @@ public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
         return invoker.invoke(inv);
     }
 
+    private Object[] getArgs(final Object[] args, Type[] types) {
+        Gson gson = new Gson();
+        return IntStream.range(0, args.length).mapToObj(i -> {
+            String s = args[i].toString();","[{'comment': 'variable s is unnecessary', 'commenter': 'kimmking'}, {'comment': 'get', 'commenter': 'goodjava'}]"
7639,dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java,"@@ -194,7 +194,7 @@ public void checkDefault() throws IllegalStateException {
         if (provider == null) {
             provider = ApplicationModel.getConfigManager()
                     .getDefaultProvider()
-                    .orElse(new ProviderConfig());
+                    .orElseGet(ProviderConfig::new);","[{'comment': 'This will put the ProviderConfig instance into ConfigManager, which is not an action expected.', 'commenter': 'chickenlj'}]"
7643,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java,"@@ -162,7 +166,9 @@ public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
                     }
                 }
 
-                RpcInvocation rpcInvocation = new RpcInvocation(method, invoker.getInterface().getName(), invoker.getUrl().getProtocolServiceKey(), args, inv.getObjectAttachments(), inv.getAttributes());
+                RpcInvocation rpcInvocation =","[{'comment': 'why format this line？', 'commenter': 'kimmking'}, {'comment': 'This code is too long, in order to facilitate reading, so formatted.', 'commenter': 'xiaoheng1'}]"
7660,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/definition/model/MethodDefinition.java,"@@ -70,7 +72,18 @@ public void setReturnType(String returnType) {
         this.returnType = formatType(returnType);
     }
 
-    @Override
+	public List<Annotation> getAnnotations() {
+		if (annotations == null) {
+			return new ArrayList<>();
+		}
+		return annotations;
+	}
+
+	public void setAnnotations(List<Annotation> annotations) {
+		this.annotations = annotations;
+	}
+
+	@Override","[{'comment': 'please use four space indentation', 'commenter': 'AlbumenJ'}]"
7660,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/definition/ServiceDefinitionBuilder.java,"@@ -61,12 +64,17 @@ public static FullServiceDefinition buildFullDefinition(final Class<?> interface
     public static <T extends ServiceDefinition> void build(T sd, final Class<?> interfaceClass) {
         sd.setCanonicalName(interfaceClass.getCanonicalName());
         sd.setCodeSource(ClassUtils.getCodeSource(interfaceClass));
+        Annotation[] classAnnotations = interfaceClass.getAnnotations();
+        sd.setAnnotations(classAnnotations == null ? new ArrayList<>() : Arrays.asList(classAnnotations));
 
         TypeDefinitionBuilder builder = new TypeDefinitionBuilder();
         List<Method> methods = ClassUtils.getPublicNonStaticMethods(interfaceClass);
         for (Method method : methods) {
             MethodDefinition md = new MethodDefinition();
             md.setName(method.getName());
+            
+            Annotation[] methodAnnotations = method.getAnnotations();
+            md.setAnnotations(methodAnnotations == null ? new ArrayList<>() : Arrays.asList(methodAnnotations));","[{'comment': 'please also fix these lines', 'commenter': 'AlbumenJ'}]"
7660,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/definition/ServiceDefinitionBuilder.java,"@@ -61,13 +64,18 @@ public static FullServiceDefinition buildFullDefinition(final Class<?> interface
     public static <T extends ServiceDefinition> void build(T sd, final Class<?> interfaceClass) {
         sd.setCanonicalName(interfaceClass.getCanonicalName());
         sd.setCodeSource(ClassUtils.getCodeSource(interfaceClass));
+        Annotation[] classAnnotations = interfaceClass.getAnnotations();
+        sd.setAnnotations(classAnnotations == null ? new ArrayList<>() : Arrays.asList(classAnnotations));","[{'comment': 'Code clean. empty List can use `java.util.Collections#emptyList`. \r\nOther place also follow this.', 'commenter': 'horizonzy'}]"
7671,dubbo-common/src/main/java/org/apache/dubbo/common/URL.java,"@@ -1298,7 +1298,7 @@ public String getPathKey() {
     }
 
     public static String buildKey(String path, String group, String version) {
-        return BaseServiceMetadata.buildServiceKey(path, group, version);
+        return BaseServiceMetadata.buildServiceKey(path, group, version).intern();","[{'comment': 'use intern() in BaseServiceMetadata.buildServiceKey?', 'commenter': 'horizonzy'}, {'comment': 'done', 'commenter': 'AlbumenJ'}]"
7671,dubbo-common/src/main/java/org/apache/dubbo/common/BaseServiceMetadata.java,"@@ -42,7 +42,7 @@ public static String buildServiceKey(String path, String group, String version)
         if (version != null && version.length() > 0) {
             buf.append("":"").append(version);
         }
-        return buf.toString();
+        return buf.toString().intern();","[{'comment': ""I am a bit confused. Does the memory already being allocated from `toString()`?\r\nI think doing intern this way will only possibly save the memory if the String returned will be held by a constant reference, it won't save the temporary memory allocated."", 'commenter': 'chickenlj'}, {'comment': ""> I think doing intern this way will only possibly save the memory if the String returned will be held by a constant reference, it won't save the temporary memory allocated.\r\n\r\nYes, it is useless about temporarory memory allocation. But, it can save persistence memory allocation. That is the urls from directory can hold the same String object, and temporarory String object from `toString()` can be release by GC. URLs will persistence exist if the invoker is still alive, and it will keep the reference of `ServiceKey` as a cache."", 'commenter': 'AlbumenJ'}, {'comment': 'I thought you were improving the efficiency of the RPC call, say, RT, QPS.', 'commenter': 'chickenlj'}]"
7677,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java,"@@ -73,27 +71,18 @@ public AbortPolicyWithReport(String threadName, URL url) {
     @Override
     public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
         String msg = String.format(""Thread pool is EXHAUSTED!"" +
-                "" Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d), Task: %d (completed: ""
-                + ""%d),"" +
-                "" Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s), in %s://%s:%d!"",
-            threadName, e.getPoolSize(), e.getActiveCount(), e.getCorePoolSize(), e.getMaximumPoolSize(),
-            e.getLargestPoolSize(),
-            e.getTaskCount(), e.getCompletedTaskCount(), e.isShutdown(), e.isTerminated(), e.isTerminating(),
-            url.getProtocol(), url.getIp(), url.getPort());
+                        "" Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d),"" +
+                        "" Task: %d (completed: %d),"" +
+                        "" Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s), in %s://%s:%d!"",
+                threadName, e.getPoolSize(), e.getActiveCount(), e.getCorePoolSize(), e.getMaximumPoolSize(),
+                e.getLargestPoolSize(),
+                e.getTaskCount(), e.getCompletedTaskCount(), e.isShutdown(), e.isTerminated(), e.isTerminating(),
+                url.getProtocol(), url.getIp(), url.getPort());
         logger.warn(msg);
         dumpJStack();
-        dispatchThreadPoolExhaustedEvent(msg);","[{'comment': 'I think we need replacement Listener for this Event.', 'commenter': 'chickenlj'}, {'comment': 'done', 'commenter': 'kevinw66'}]"
7677,dubbo-registry/dubbo-registry-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesServiceDiscovery.java,"@@ -194,21 +194,22 @@ public ServiceInstance getLocalInstance() {
 
     @Override
     public void addServiceInstancesChangedListener(ServiceInstancesChangedListener listener) throws NullPointerException, IllegalArgumentException {
+        super.addServiceInstancesChangedListener(listener);
         listener.getServiceNames().forEach(serviceName -> {
             SERVICE_UPDATE_TIME.put(serviceName, new AtomicLong(0L));
 
             // Watch Service Endpoint Modification
-            watchEndpoints(listener, serviceName);
+            watchEndpoints(serviceName);","[{'comment': 'Does this change still match the original meaning?\r\n\r\nThe original impl only notify one listener while the new one notifies all listeners.', 'commenter': 'chickenlj'}]"
7677,dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscoveryChangeWatcher.java,"@@ -68,7 +63,7 @@ public ZookeeperServiceDiscoveryChangeWatcher(ZookeeperServiceDiscovery zookeepe
         this.notifier = new RegistryNotifier(zookeeperServiceDiscovery.getDelay(), getExecutorRepository().getServiceDiscoveryAddressNotificationExecutor()) {
             @Override
             protected void doNotify(Object rawAddresses) {
-                listeners.forEach(listener -> listener.onEvent((ServiceInstancesChangedEvent)rawAddresses));
+                zookeeperServiceDiscovery.dispatchServiceInstancesChangedEvent((ServiceInstancesChangedEvent)rawAddresses);","[{'comment': 'Can listeners in Watcher being replaced with listeners in ServiceDiscovery?\r\n\r\nWatcher is bound to one single service while ServiceDiscovery is shared among services.', 'commenter': 'chickenlj'}]"
7697,dubbo-serialization/dubbo-serialization-msgpack/src/main/java/org/apache/dubbo/common/serialize/msgpack/MsgpackObjectInput.java,"@@ -0,0 +1,114 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.serialize.msgpack;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import org.apache.dubbo.common.serialize.ObjectInput;
+import org.apache.dubbo.common.utils.PojoUtils;
+
+import org.msgpack.jackson.dataformat.MessagePackFactory;
+
+import java.io.*;","[{'comment': 'Please do not use comma import', 'commenter': 'AlbumenJ'}, {'comment': 'get', 'commenter': 'goodjava'}]"
7697,dubbo-serialization/dubbo-serialization-msgpack/src/main/java/org/apache/dubbo/common/serialize/msgpack/MsgpackObjectOutput.java,"@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.serialize.msgpack;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import org.apache.dubbo.common.serialize.ObjectOutput;
+
+import org.msgpack.jackson.dataformat.MessagePackFactory;
+
+import java.io.*;","[{'comment': 'also for this', 'commenter': 'AlbumenJ'}, {'comment': 'get', 'commenter': 'goodjava'}]"
7697,dubbo-serialization/dubbo-serialization-msgpack/src/test/java/org/apache/dubbo/common/serialize/msgpack/BizException.java,"@@ -0,0 +1,9 @@
+","[{'comment': 'Please add Apache License header for this file', 'commenter': 'AlbumenJ'}, {'comment': 'What is the purpose of designing BizException? \r\nPersonally think that the definition of BizException is not appropriate under serialization.\r\n\r\n', 'commenter': 'xiaoheng1'}, {'comment': 'for test @xiaoheng1 ', 'commenter': 'goodjava'}]"
7697,dubbo-serialization/dubbo-serialization-msgpack/src/test/java/org/apache/dubbo/common/serialize/msgpack/MsgpackObjectOutputTest.java,"@@ -0,0 +1,161 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.serialize.msgpack;
+
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+
+import static org.hamcrest.CoreMatchers.*;","[{'comment': 'also for this file', 'commenter': 'AlbumenJ'}, {'comment': 'get', 'commenter': 'goodjava'}]"
7697,dubbo-serialization/dubbo-serialization-msgpack/src/test/java/org/apache/dubbo/common/serialize/msgpack/MsgpackObjectOutputTest.java,"@@ -0,0 +1,161 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.serialize.msgpack;
+
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+public class MsgpackObjectOutputTest {
+    private MsgpackObjectOutput msgpackObjectOutput;
+    private MsgpackObjectInput msgpackObjectInput;
+    private ByteArrayOutputStream byteArrayOutputStream;
+    private ByteArrayInputStream byteArrayInputStream;
+
+    @BeforeEach
+    public void setUp() throws Exception {
+        this.byteArrayOutputStream = new ByteArrayOutputStream();
+        this.msgpackObjectOutput = new MsgpackObjectOutput(byteArrayOutputStream);
+    }
+
+    @Test
+    public void testWriteBool() throws IOException {
+        this.msgpackObjectOutput.writeBool(true);
+        this.flushToInput();
+
+        assertThat(msgpackObjectInput.readBool(), is(true));
+    }
+
+    @Test
+    public void testWriteShort() throws IOException {
+        this.msgpackObjectOutput.writeShort((short) 2);
+        this.flushToInput();
+
+        assertThat(msgpackObjectInput.readShort(), is((short) 2));
+    }
+
+    @Test
+    public void testWriteInt() throws IOException {
+        this.msgpackObjectOutput.writeInt(1);
+        this.flushToInput();
+
+        assertThat(msgpackObjectInput.readInt(), is(1));
+    }
+
+    @Test
+    public void testWriteLong() throws IOException {
+        this.msgpackObjectOutput.writeLong(1000L);
+        this.flushToInput();
+
+        assertThat(msgpackObjectInput.readLong(), is(1000L));
+    }
+
+    @Test
+    public void testWriteUTF() throws IOException {
+        this.msgpackObjectOutput.writeUTF(""Pace Hasîtî 和平 Мир"");
+        this.flushToInput();
+
+        assertThat(msgpackObjectInput.readUTF(), is(""Pace Hasîtî 和平 Мир""));
+    }
+
+    @Test
+    public void testWriteUTF2() throws IOException {
+        this.msgpackObjectOutput.writeUTF(""a"");
+        this.msgpackObjectOutput.writeUTF(""b"");
+        this.msgpackObjectOutput.writeUTF(""c"");
+        this.flushToInput();
+        assertThat(msgpackObjectInput.readUTF(), is(""a""));
+        assertThat(msgpackObjectInput.readUTF(), is(""b""));
+        assertThat(msgpackObjectInput.readUTF(), is(""c""));
+    }
+
+
+    @Test
+    public void testWriteThrowable() throws IOException, ClassNotFoundException {
+        BizException throwable = new BizException(""error"");
+        this.msgpackObjectOutput.writeThrowable(throwable);
+        this.flushToInput();
+        Throwable ex = msgpackObjectInput.readThrowable();
+        assertThat(ex.getMessage(), is(""error""));
+        assertThat(ex.getClass(), is(BizException.class));
+    }
+
+    @Test
+    public void testWriteFloat() throws IOException {
+        this.msgpackObjectOutput.writeFloat(1.88f);
+        this.flushToInput();
+
+        assertThat(this.msgpackObjectInput.readFloat(), is(1.88f));
+    }
+
+    @Test
+    public void testWriteDouble() throws IOException {
+        this.msgpackObjectOutput.writeDouble(1.66d);
+        this.flushToInput();
+
+        assertThat(this.msgpackObjectInput.readDouble(), is(1.66d));
+    }
+
+    @Test
+    public void testWriteBytes() throws IOException {
+        this.msgpackObjectOutput.writeBytes(""hello"".getBytes());
+        this.flushToInput();
+
+        assertThat(this.msgpackObjectInput.readBytes(), is(""hello"".getBytes()));
+    }
+
+    @Test
+    public void testWriteBytesWithSubLength() throws IOException {
+        this.msgpackObjectOutput.writeBytes(""hello"".getBytes(), 2, 2);
+        this.flushToInput();
+
+        assertThat(this.msgpackObjectInput.readBytes(), is(""ll"".getBytes()));
+    }
+
+    @Test
+    public void testWriteByte() throws IOException {
+        this.msgpackObjectOutput.writeByte((byte) 123);
+        this.flushToInput();
+
+        assertThat(this.msgpackObjectInput.readByte(), is((byte) 123));
+    }
+
+    @Test
+    public void testWriteObject() throws IOException, ClassNotFoundException {
+        Image image = new Image(""http://dubbo.apache.org/img/dubbo_white.png"", ""logo"", 300, 480, Image.Size.SMALL);","[{'comment': 'Please save this file to test resources. Try to reduce network dependence for unit test cases.', 'commenter': 'AlbumenJ'}, {'comment': 'get', 'commenter': 'goodjava'}]"
7697,dubbo-serialization/dubbo-serialization-msgpack/src/main/java/org/apache/dubbo/common/serialize/msgpack/MsgpackObjectInput.java,"@@ -0,0 +1,114 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.serialize.msgpack;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import org.apache.dubbo.common.serialize.ObjectInput;
+import org.apache.dubbo.common.utils.PojoUtils;
+
+import org.msgpack.jackson.dataformat.MessagePackFactory;
+
+import java.io.*;
+import java.lang.reflect.Type;
+
+public class MsgpackObjectInput implements ObjectInput {
+
+    private final InputStream in;
+
+    private ObjectMapper om;
+
+    public MsgpackObjectInput(InputStream in) {
+        this.in = in;
+        om = new ObjectMapper(new MessagePackFactory());
+        om.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false);","[{'comment': ""Why can't we initialize `ObjectMapper` in the same way in both `MsgpackObjectInput` and `MsgpackObjectOutput` class?\r\n```java\r\n    public MsgpackObjectOutput(OutputStream out) {\r\n        this.out = out;\r\n        om = new ObjectMapper(new MessagePackFactory());\r\n    }\r\n```"", 'commenter': 'pinxiong'}, {'comment': 'get', 'commenter': 'goodjava'}]"
7697,dubbo-serialization/dubbo-serialization-msgpack/src/test/java/org/apache/dubbo/common/serialize/msgpack/BizException.java,"@@ -0,0 +1,24 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.serialize.msgpack;
+
+public class BizException extends RuntimeException {","[{'comment': 'change it to static class inner In Test class.', 'commenter': 'horizonzy'}, {'comment': 'get', 'commenter': 'goodjava'}]"
7712,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/AbstractServer.java,"@@ -23,11 +23,7 @@
 import org.apache.dubbo.common.threadpool.manager.ExecutorRepository;
 import org.apache.dubbo.common.utils.ExecutorUtil;
 import org.apache.dubbo.common.utils.NetUtils;
-import org.apache.dubbo.remoting.Channel;
-import org.apache.dubbo.remoting.ChannelHandler;
-import org.apache.dubbo.remoting.Constants;
-import org.apache.dubbo.remoting.RemotingException;
-import org.apache.dubbo.remoting.RemotingServer;
+import org.apache.dubbo.remoting.*;","[{'comment': 'please do not use comma import', 'commenter': 'AlbumenJ'}, {'comment': 'OK, It has been modified', 'commenter': 'BurningCN'}]"
7740,dubbo-common/src/main/java/org/apache/dubbo/config/SslConfig.java,"@@ -120,6 +131,24 @@ public void setClientTrustCertCollectionPath(String clientTrustCertCollectionPat
         this.clientTrustCertCollectionPath = clientTrustCertCollectionPath;
     }
 
+    @Parameter(key = ""ciphers"")
+    public List<String> getCiphers() {
+        return ciphers;
+    }
+
+    public void setCiphers(List<String> ciphers) {
+        this.ciphers = ciphers;
+    }
+
+    @Parameter(key = ""protocals"")","[{'comment': 'Is this a spelling error？', 'commenter': 'AlbumenJ'}, {'comment': 'yes, sorry', 'commenter': 'owen200008'}]"
7740,dubbo-common/src/main/java/org/apache/dubbo/config/SslConfig.java,"@@ -40,6 +41,16 @@
     private String clientKeyPassword;
     private String clientTrustCertCollectionPath;
 
+    /**
+     * set support cipher
+     */
+    private List<String> ciphers;
+
+    /**
+     * set support protocal","[{'comment': 'there is another spelling mistake', 'commenter': 'AlbumenJ'}]"
7740,dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/SslContextsTest.java,"@@ -0,0 +1,66 @@
+package org.apache.dubbo.remoting.transport.netty4;
+
+import io.netty.handler.ssl.*;","[{'comment': 'Please avoid using ""import *""', 'commenter': 'chickenlj'}, {'comment': 'i have fix it. sorry', 'commenter': 'owen200008'}]"
7740,dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/SslContextsTest.java,"@@ -0,0 +1,70 @@
+package org.apache.dubbo.remoting.transport.netty4;","[{'comment': 'Please add ASF license header for this file', 'commenter': 'AlbumenJ'}, {'comment': 'fix it now~ ', 'commenter': 'owen200008'}]"
7740,dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/SslContextsTest.java,"@@ -0,0 +1,86 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.transport.netty4;
+
+import io.netty.handler.ssl.JdkSslContext;
+import io.netty.handler.ssl.OpenSsl;
+import io.netty.handler.ssl.OpenSslContext;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.ReferenceCountedOpenSslContext;
+import org.apache.dubbo.config.SslConfig;
+import org.apache.dubbo.config.context.ConfigManager;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.List;
+
+import org.mockito.MockedStatic;
+import org.mockito.Mockito;
+
+/**
+ * @author owen.cai","[{'comment': 'Please remove these tags. THX', 'commenter': 'AlbumenJ'}]"
7809,dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/MetricsConfigTest.java,"@@ -0,0 +1,23 @@
+package org.apache.dubbo.config;","[{'comment': 'Please add ASF license header for this file. thx', 'commenter': 'AlbumenJ'}]"
7809,dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/MetricsConfigTest.java,"@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.config;
+
+import org.junit.jupiter.api.Test;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.*;","[{'comment': 'please do not use comma import', 'commenter': 'AlbumenJ'}]"
7824,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java,"@@ -17,62 +17,109 @@
 package org.apache.dubbo.registry.client.metadata;
 
 import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.utils.CollectionUtils;
-import org.apache.dubbo.metadata.MappingListener;
+import org.apache.dubbo.common.config.configcenter.ConfigItem;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.mapping.MappingListener;
+import org.apache.dubbo.mapping.ServiceNameMapping;
+import org.apache.dubbo.mapping.ServiceNameMappingHandler;
 import org.apache.dubbo.metadata.MetadataService;
-import org.apache.dubbo.metadata.ServiceNameMapping;
 import org.apache.dubbo.metadata.report.MetadataReport;
 import org.apache.dubbo.metadata.report.MetadataReportInstance;
 import org.apache.dubbo.registry.client.RegistryClusterIdentifier;
 
+import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
 
-import static java.util.Arrays.asList;
+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SEPARATOR;
 import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_KEY;
 import static org.apache.dubbo.rpc.model.ApplicationModel.getName;
 
 public class MetadataServiceNameMapping implements ServiceNameMapping {
-    private static final List<String> IGNORED_SERVICE_INTERFACES = asList(MetadataService.class.getName());
+
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+
+    private static final List<String> IGNORED_SERVICE_INTERFACES = Collections.singletonList(MetadataService.class.getName());
+
+    private static final int CAS_RETRY_TIMES = 6;
 
     @Override
     public void map(URL url) {
+        execute(() -> {
+            String serviceInterface = url.getServiceInterface();
+            if (IGNORED_SERVICE_INTERFACES.contains(serviceInterface)) {
+                return;
+            }
+            String registryCluster = getRegistryCluster(url);
+            MetadataReport metadataReport = MetadataReportInstance.getMetadataReport(registryCluster);
+            if (metadataReport.isSupportCas() && ServiceNameMappingHandler.isBothMapping()) {
+                doCasMap(metadataReport, url);
+                doNormalMap(metadataReport, url);","[{'comment': 'Why do we need two different types of mapping method? ', 'commenter': 'chickenlj'}, {'comment': 'This is quite confusing on a concept or interface level. Will one single mapping method for all extensions to implement based on their own characteristics work?', 'commenter': 'chickenlj'}]"
7846,dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/legacy/CountTelnetHandlerTest.java,"@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.qos.legacy;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.qos.legacy.channel.MockChannel;
+import org.apache.dubbo.qos.legacy.service.DemoService;
+import org.apache.dubbo.remoting.telnet.TelnetHandler;
+import org.apache.dubbo.remoting.telnet.support.TelnetUtils;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcStatus;
+import org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.reset;
+
+public class CountTelnetHandlerTest {
+
+    private TelnetHandler handler = new CountTelnetHandler();
+    private MockChannel mockChannel;
+    private Invoker<DemoService> mockInvoker;
+    private URL url = URL.valueOf(""dubbo://127.0.0.1:20884/demo"");
+
+    @BeforeEach
+    public void setUp() {
+        mockChannel = new MockChannel(url);
+        mockInvoker = mock(Invoker.class);
+        given(mockInvoker.getInterface()).willReturn(DemoService.class);
+        given(mockInvoker.getUrl()).willReturn(url);
+    }
+
+    @AfterEach
+    public void tearDown() {
+        ProtocolUtils.closeAll();
+        mockChannel.close();
+        reset(mockInvoker);
+    }
+
+    @Test
+    public void test() throws Exception {
+        String methodName = ""sayHello"";
+        String message = ""org.apache.dubbo.qos.legacy.service.DemoService sayHello 1"";
+
+        DubboProtocol.getDubboProtocol().export(mockInvoker);
+        RpcStatus.beginCount(url, methodName);
+        RpcStatus.endCount(url, methodName, 10L, true);
+        handler.telnet(mockChannel, message);
+
+        Thread.sleep(1000);
+        StringBuilder sb = new StringBuilder();
+        for (Object o : mockChannel.getReceivedObjects()) {
+            sb.append(o.toString());
+        }
+        Assertions.assertEquals(""\r\n"" + buildTable(methodName,","[{'comment': 'please use contains to prevent directly compare `\\r\\n`', 'commenter': 'AlbumenJ'}, {'comment': 'Done', 'commenter': 'icankeep'}]"
7846,dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/legacy/CountTelnetHandlerTest.java,"@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.qos.legacy;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.qos.legacy.channel.MockChannel;
+import org.apache.dubbo.qos.legacy.service.DemoService;
+import org.apache.dubbo.remoting.telnet.TelnetHandler;
+import org.apache.dubbo.remoting.telnet.support.TelnetUtils;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcStatus;
+import org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.reset;
+
+public class CountTelnetHandlerTest {
+
+    private TelnetHandler handler = new CountTelnetHandler();
+    private MockChannel mockChannel;
+    private Invoker<DemoService> mockInvoker;
+    private URL url = URL.valueOf(""dubbo://127.0.0.1:20884/demo"");
+
+    @BeforeEach
+    public void setUp() {
+        mockChannel = new MockChannel(url);
+        mockInvoker = mock(Invoker.class);
+        given(mockInvoker.getInterface()).willReturn(DemoService.class);
+        given(mockInvoker.getUrl()).willReturn(url);
+    }
+
+    @AfterEach
+    public void tearDown() {
+        ProtocolUtils.closeAll();
+        mockChannel.close();
+        reset(mockInvoker);
+    }
+
+    @Test
+    public void test() throws Exception {
+        String methodName = ""sayHello"";
+        String message = ""org.apache.dubbo.qos.legacy.service.DemoService sayHello 1"";
+
+        DubboProtocol.getDubboProtocol().export(mockInvoker);
+        RpcStatus.beginCount(url, methodName);
+        RpcStatus.endCount(url, methodName, 10L, true);
+        handler.telnet(mockChannel, message);
+
+        Thread.sleep(1000);","[{'comment': 'Try use CountDownLatch to wait async computing. Using timeout without any check is unreliable.', 'commenter': 'AlbumenJ'}, {'comment': 'Done', 'commenter': 'icankeep'}]"
7883,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AvailableClusterInvokerTest.java,"@@ -0,0 +1,108 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.support;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.*;
+import org.apache.dubbo.rpc.cluster.Directory;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+
+/**
+ * AvailableClusterInvokerTest
+ */
+public class AvailableClusterInvokerTest {
+
+    private List<Invoker<AvailableClusterInvokerTest>> invokers = new ArrayList<>();
+    private URL url = URL.valueOf(""test://test:11/test"");
+    private Invoker<AvailableClusterInvokerTest> invoker1 = mock(Invoker.class);
+    private Invoker<AvailableClusterInvokerTest> invoker2 = mock(Invoker.class);
+    private Invoker<AvailableClusterInvokerTest> invoker3 = mock(Invoker.class);
+    private RpcInvocation invocation = new RpcInvocation();
+    private Directory<AvailableClusterInvokerTest> dic;
+    private Result result = new AppResponse();
+
+    @BeforeEach
+    public void setUp() throws Exception {
+
+        dic = mock(Directory.class);
+
+        given(dic.getUrl()).willReturn(url);
+        given(dic.getConsumerUrl()).willReturn(url);
+        given(dic.list(invocation)).willReturn(invokers);
+        given(dic.getInterface()).willReturn(AvailableClusterInvokerTest.class);
+
+        invocation.setMethodName(""method1"");
+
+        invokers.add(invoker1);
+        invokers.add(invoker2);
+        invokers.add(invoker3);
+    }
+
+    private void resetInvokerToException() {","[{'comment': 'unused method should remove', 'commenter': 'icankeep'}]"
7883,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AvailableClusterInvokerTest.java,"@@ -0,0 +1,108 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.support;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.*;","[{'comment': 'avoid using import *', 'commenter': 'chickenlj'}]"
7884,dubbo-common/src/test/java/org/apache/dubbo/common/utils/NetUtilsTest.java,"@@ -20,11 +20,10 @@
 import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 
-import java.net.Inet6Address;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.UnknownHostException;
+import java.net.*;","[{'comment': 'Please avoid using ""import *"" ', 'commenter': 'chickenlj'}]"
7906,dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/PublishMetadataTest.java,"@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.qos.command.impl;
+
+import org.apache.dubbo.config.ApplicationConfig;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+public class PublishMetadataTest {
+
+    @BeforeEach
+    public void before() {
+        ApplicationModel.getConfigManager().setApplication(new ApplicationConfig(""app""));","[{'comment': 'Please reset ApplicationModel after tests', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'BurningCN'}]"
7906,dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/ReadyTest.java,"@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.qos.command.impl;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.config.ApplicationConfig;
+import org.apache.dubbo.config.RegistryConfig;
+import org.apache.dubbo.config.ServiceConfig;
+import org.apache.dubbo.config.bootstrap.DubboBootstrap;
+import org.apache.dubbo.qos.command.support.DemoService;
+import org.apache.dubbo.qos.command.support.impl.DemoServiceImpl;
+import org.apache.dubbo.rpc.model.ServiceRepository;
+import org.apache.dubbo.rpc.model.ProviderModel;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ServiceMetadata;
+import org.apache.dubbo.rpc.model.ServiceDescriptor;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+public class ReadyTest {
+
+    private Ready ready;
+
+    @BeforeEach
+    public void setUp(){
+        ready = new Ready();
+    }
+
+    @Test
+    public void appReadyTest(){
+        DubboBootstrap.getInstance().setReady(false);","[{'comment': 'Please use `DubboBootstrap.reset()` to revocer env after test', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'BurningCN'}]"
7926,dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java,"@@ -300,8 +300,7 @@ public String getExtensionName(Class<?> extensionClass) {
             }
         }
         List<T> loadedExtensions = new ArrayList<>();
-        for (int i = 0; i < names.size(); i++) {
-            String name = names.get(i);
+        for (String name : names) {","[{'comment': 'Iterator with set is lack of performance. Sometimes it will create a lot of iterator objects.', 'commenter': 'AlbumenJ'}, {'comment': '但是Set好像只能用iterator遍历了，这里的改动主要是觉得多次执行了这个`names.contains(name)`\r\nList改为Set可能会好些', 'commenter': 'icankeep'}, {'comment': ""`CollectionUtils.ofSet` is based on `LinkedHashSet`. So, it doesn't have this problem"", 'commenter': 'AlbumenJ'}]"
7929,dubbo-registry/dubbo-registry-redis/src/test/java/org/apache/dubbo/registry/redis/RedisRegistryTest.java,"@@ -105,6 +110,66 @@ public void testAnyHost() {
         });
     }
 
+    @Test
+    public void testSubscribeWhenProviderCrash() throws Exception {
+
+        // 关闭doExpire，则本单元测试不通过","[{'comment': 'please comment in English', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'lkxiaolou'}]"
7929,dubbo-registry/dubbo-registry-redis/src/main/java/org/apache/dubbo/registry/redis/RedisRegistry.java,"@@ -294,10 +308,12 @@ private void doNotify(Collection<String> keys, URL url, Collection<NotifyListene
             if (CollectionUtils.isNotEmptyMap(values)) {
                 for (Map.Entry<String, String> entry : values.entrySet()) {
                     URL u = URL.valueOf(entry.getKey());
+                    long expire = Long.parseLong(entry.getValue());
                     if (!u.getParameter(DYNAMIC_KEY, true)
-                            || Long.parseLong(entry.getValue()) >= now) {
+                            || expire >= now) {
                         if (UrlUtils.isMatch(url, u)) {
                             urls.add(u);
+                            expireCache.put(u, expire);","[{'comment': ""Is it possible for expireCache to go leaking for it's never cleared?"", 'commenter': 'chickenlj'}, {'comment': 'ok , add remove logic and related UT', 'commenter': 'lkxiaolou'}, {'comment': ""Also, I don't see where `expireCache` is used inside `doNotify`."", 'commenter': 'chickenlj'}, {'comment': '`expireCache` mark which service may be down and call `doNotity` to fetch latest data from redis\r\n\r\n', 'commenter': 'lkxiaolou'}]"
7931,dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java,"@@ -547,6 +551,24 @@ public void setStartupProbe(String startupProbe) {
         this.startupProbe = startupProbe;
     }
 
+    @Parameter(key = ""export-async"")
+    public Boolean getExportAsync() {","[{'comment': ""You'd better use `boolean`  instead of `Boolean`, you can see #3531"", 'commenter': 'pinxiong'}, {'comment': 'Although there is an issue to suggest we use primitive types. Still there are a lot non-primitive types is using in project. And here I was just trying to keep the same style as before. Maybe we can find a time to change it all together?', 'commenter': 'kevinw66'}, {'comment': 'Yes, we can open an new PR to fix the issue #3531', 'commenter': 'pinxiong'}, {'comment': ""I think Boolean is ok for it's better for us to recognize if default value is set."", 'commenter': 'chickenlj'}]"
7931,dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java,"@@ -547,6 +551,24 @@ public void setStartupProbe(String startupProbe) {
         this.startupProbe = startupProbe;
     }
 
+    @Parameter(key = ""export-async"")
+    public Boolean getExportAsync() {
+        return exportAsync;
+    }
+
+    public void setExportAsync(Boolean exportAsync) {
+        this.exportAsync = exportAsync;
+    }
+
+    @Parameter(key = ""refer-async"")
+    public Boolean getReferAsync() {","[{'comment': 'Same as above', 'commenter': 'pinxiong'}]"
7931,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java,"@@ -81,8 +83,9 @@ public DefaultExecutorRepository() {
 //        reconnectScheduledExecutor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(""Dubbo-reconnect-scheduler""));
         poolRouterExecutor = new ThreadPoolExecutor(1, 10, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(1024),
             new NamedInternalThreadFactory(""Dubbo-state-router-pool-router"", true), new ThreadPoolExecutor.AbortPolicy());
-        serviceExporterExecutor = Executors.newScheduledThreadPool(1, new NamedThreadFactory(""Dubbo-exporter-scheduler""));
-        serviceDiscveryAddressNotificationExecutor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(""Dubbo-SD-address-refresh""));
+        serviceExporterExecutor = Executors.newScheduledThreadPool(10, new NamedThreadFactory(""Dubbo-exporter-scheduler"", true));","[{'comment': ""I don't think we need to define different ThreadPools.  In most cases, only one of `serviceExporterExecutor` and `serviceRefererExecutor` will work, because it is less likely that a service is both a `service` and a `reference`"", 'commenter': 'pinxiong'}, {'comment': 'good idea', 'commenter': 'kevinw66'}]"
7931,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java,"@@ -1092,15 +1100,17 @@ private void unexportMetadataService() {
     private void exportServices() {
         configManager.getServices().forEach(sc -> {
             // TODO, compatible with ServiceConfig.export()
-            ServiceConfig serviceConfig = (ServiceConfig) sc;
+            ServiceConfig<?> serviceConfig = (ServiceConfig<?>) sc;
             serviceConfig.setBootstrap(this);
 
-            if (exportAsync) {
+            ApplicationConfig config = getApplication();
+            if (config.getExportAsync() != null && config.getExportAsync()) {","[{'comment': '  Why not design the `exportServices` to be asynchronous instead of relying on `export-async` parameter?', 'commenter': 'pinxiong'}, {'comment': ""I think it's better to let user to choose."", 'commenter': 'kevinw66'}, {'comment': ""In this case, we know that `async` is better than `sync`, why don't we recomend `async` or set it as default?"", 'commenter': 'pinxiong'}, {'comment': ""fair point. I'll change it."", 'commenter': 'kevinw66'}]"
7931,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java,"@@ -1131,15 +1141,14 @@ private void referServices() {
 
         configManager.getReferences().forEach(rc -> {
             // TODO, compatible with  ReferenceConfig.refer()
-            ReferenceConfig referenceConfig = (ReferenceConfig) rc;
+            ReferenceConfig<?> referenceConfig = (ReferenceConfig<?>) rc;
             referenceConfig.setBootstrap(this);
 
             if (rc.shouldInit()) {
-                if (referAsync) {
-                    CompletableFuture<Object> future = ScheduledCompletableFuture.submit(
-                            executorRepository.getServiceExporterExecutor(),
-                            () -> cache.get(rc)
-                    );
+                ApplicationConfig config = getApplication();
+                if (config.getReferAsync() != null && config.getReferAsync()) {","[{'comment': '  Why not design the `referServices` to be asynchronous instead of relying on `refer-async` parameter?', 'commenter': 'pinxiong'}]"
7931,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java,"@@ -1141,6 +1163,16 @@ private void unreferServices() {
         cache.destroyAll();
     }
 
+    private ExecutorService getExportReferExecutor() {","[{'comment': 'Please consider moving this executor to ExecutorRepository', 'commenter': 'chickenlj'}, {'comment': 'done', 'commenter': 'kevinw66'}]"
7931,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/DubboBootstrap.java,"@@ -1067,19 +1082,21 @@ private void unexportMetadataService() {
     private void exportServices() {
         configManager.getServices().forEach(sc -> {
             // TODO, compatible with ServiceConfig.export()
-            ServiceConfig serviceConfig = (ServiceConfig) sc;
+            ServiceConfig<?> serviceConfig = (ServiceConfig<?>) sc;
             serviceConfig.setBootstrap(this);
 
-            if (exportAsync) {","[{'comment': 'Has the definition of exportAsync cleaned up in Bootstrap?', 'commenter': 'chickenlj'}, {'comment': ""Already annotated with @Deprecated, But It's better to remove the definition, I'll change it"", 'commenter': 'kevinw66'}]"
7931,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java,"@@ -177,8 +186,41 @@ public ExecutorService nextExecutorExecutor() {
     }
 
     @Override
-    public ScheduledExecutorService getServiceExporterExecutor() {
-        return serviceExporterExecutor;
+    public ScheduledExecutorService getExportReferExecutor() {
+        if (exportReferExecutor == null) {
+            synchronized (LOCK) {
+                if (exportReferExecutor == null) {
+                    int coreSize = getExportReferThreadNum();
+                    exportReferExecutor = Executors.newScheduledThreadPool(coreSize,
+                        new NamedThreadFactory(""Dubbo-export-refer"", true));
+                }
+            }
+        }
+
+        return exportReferExecutor;
+    }
+
+    private Integer getExportReferThreadNum() {
+        Stream<Integer> provider = getConfigManager().getProviders()","[{'comment': 'This might cause NPE in some situations. It is better to return default value.', 'commenter': 'AlbumenJ'}, {'comment': ""I don't think this is necessary, there always exists default provider/consumer."", 'commenter': 'kevinw66'}]"
7932,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/UrlMergeProcessor.java,"@@ -14,16 +14,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.dubbo.rpc.cluster.support;
+package org.apache.dubbo.rpc.cluster;
 
 import org.apache.dubbo.common.URL;
 import org.apache.dubbo.common.extension.SPI;
 
 import java.util.Map;
 
-@SPI
-public interface ProviderURLMergeProcessor {
-    URL mergeProviderUrl(URL providerUrl, Map<String, String> localParametersMap);
+@SPI(""default"")
+public interface UrlMergeProcessor {","[{'comment': 'Please avoid changing the SPI definition.', 'commenter': 'chickenlj'}, {'comment': 'done', 'commenter': 'CrazyHZM'}]"
7981,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceClassPostProcessor.java,"@@ -46,10 +46,7 @@
 import org.springframework.beans.factory.xml.BeanDefinitionParser;
 import org.springframework.context.EnvironmentAware;
 import org.springframework.context.ResourceLoaderAware;
-import org.springframework.context.annotation.AnnotationBeanNameGenerator;
-import org.springframework.context.annotation.AnnotationConfigUtils;
-import org.springframework.context.annotation.ClassPathBeanDefinitionScanner;
-import org.springframework.context.annotation.ConfigurationClassPostProcessor;
+import org.springframework.context.annotation.*;","[{'comment': 'Please fix importing of *', 'commenter': 'chickenlj'}, {'comment': 'OK. I have fixed it and added more testcases.', 'commenter': 'pinxiong'}]"
8077,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java,"@@ -16,32 +16,27 @@
  */
 package org.apache.dubbo.registry.nacos;
 
+import com.alibaba.nacos.api.exception.NacosException;
+import com.alibaba.nacos.api.naming.listener.NamingEvent;
+import com.alibaba.nacos.api.naming.pojo.Instance;
+import com.alibaba.nacos.api.naming.pojo.ListView;
+import com.alibaba.nacos.api.naming.utils.NamingUtils;
 import org.apache.dubbo.common.URL;
 import org.apache.dubbo.common.function.ThrowableFunction;
-import org.apache.dubbo.common.logger.Logger;
-import org.apache.dubbo.common.logger.LoggerFactory;
 import org.apache.dubbo.registry.client.AbstractServiceDiscovery;
 import org.apache.dubbo.registry.client.ServiceDiscovery;
 import org.apache.dubbo.registry.client.ServiceInstance;
 import org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener;
 import org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils;
 
-import com.alibaba.nacos.api.exception.NacosException;
-import com.alibaba.nacos.api.naming.listener.NamingEvent;
-import com.alibaba.nacos.api.naming.pojo.Instance;
-import com.alibaba.nacos.api.naming.pojo.ListView;
-import com.alibaba.nacos.api.naming.utils.NamingUtils;
-
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.stream.Collectors;
 
 import static org.apache.dubbo.common.function.ThrowableConsumer.execute;
-import static org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils.createNamingService;
-import static org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils.getGroup;
-import static org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils.toInstance;
+import static org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils.*;","[{'comment': 'Please do not use comma inport in Dubbo project', 'commenter': 'AlbumenJ'}]"
8116,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java,"@@ -103,14 +106,19 @@ private Bootstrap create() {
             @Override
             protected void initChannel(SocketChannel ch) {
                 ch.attr(CONNECTION).set(Connection.this);
-                // TODO support SSL
+
+                SslContext sslContext = SslContexts.buildClientSslContext(url);","[{'comment': ' SSL context shoule only be created when URL enables it', 'commenter': 'guohao'}, {'comment': 'done', 'commenter': 'CrazyHZM'}]"
8116,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServerHandler.java,"@@ -76,41 +70,28 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             return;
         }
 
-        if (isSsl(in)) {
-            enableSsl(ctx);
-        } else {
-            for (final WireProtocol protocol : protocols) {
-                in.markReaderIndex();
-                final ProtocolDetector.Result result = protocol.detector().detect(ctx, in);
-                in.resetReaderIndex();
-                switch (result) {
-                    case UNRECOGNIZED:
-                        continue;
-                    case RECOGNIZED:
-                        protocol.configServerPipeline(ctx.pipeline(), null);
-                        ctx.pipeline().remove(this);
-                    case NEED_MORE_DATA:
-                        return;
-                }
+        for (final WireProtocol protocol : protocols) {","[{'comment': 'Will it be better to support both SSL and nonSSL ?\r\n\r\nhttps://github.com/netty/netty/blob/4.1/example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java\r\n\r\n', 'commenter': 'guohao'}, {'comment': 'Migrate to SslServerTlsHandler, the reason is to integrate ssl in netty4\r\n', 'commenter': 'CrazyHZM'}]"
8116,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/Connection.java,"@@ -103,14 +106,19 @@ private Bootstrap create() {
             @Override
             protected void initChannel(SocketChannel ch) {
                 ch.attr(CONNECTION).set(Connection.this);
-                // TODO support SSL
+
+                SslContext sslContext = SslContexts.buildClientSslContext(url);
+
+                if (getUrl().getParameter(SSL_ENABLED_KEY, false)) {
+                    ch.pipeline().addLast(""negotiation"", SslHandlerInitializer.sslClientHandler(sslContext, connectionHandler));","[{'comment': 'It is enough to delegate SSL handling to PU handler rather than add it to pipepline firstly', 'commenter': 'guohao'}, {'comment': 'Done.\r\nMigrate to SslServerTlsHandler.', 'commenter': 'CrazyHZM'}]"
8116,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java,"@@ -265,8 +266,8 @@ private boolean isCacheMiss(AddrCache<T> cache, String routerName) {
      * @param notify Whether the addresses in registry has changed.
      */
     public void loop(boolean notify) {
-        if (firstBuildCache) {
-            firstBuildCache = false;
+        if (firstBuildCache.get()) {","[{'comment': '```suggestion\r\n        if (firstBuildCache.compareAndSet(true,false)) {\r\n```', 'commenter': 'guohao'}, {'comment': 'Will it be better ?', 'commenter': 'guohao'}]"
8147,dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocolTest.java,"@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.ProxyFactory;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ServiceDescriptor;
+import org.apache.dubbo.rpc.model.ServiceMetadata;
+import org.apache.dubbo.rpc.protocol.tri.support.IGreeter;
+import org.apache.dubbo.rpc.protocol.tri.support.IGreeterImpl;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+
+/**
+ * @author shaoyu","[{'comment': 'please remove author tag, thx', 'commenter': 'AlbumenJ'}, {'comment': 'Sorry, I forgot to modify this when submitting.I am going to modify this now', 'commenter': 'xiaoheng1'}]"
8163,dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/api/MultiplexProtocolConnectionManagerTest.java,"@@ -0,0 +1,41 @@
+package org.apache.dubbo.remoting.api;","[{'comment': 'Please ASF license header for new files', 'commenter': 'AlbumenJ'}]"
8175,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/ChangeTelnet.java,"@@ -0,0 +1,51 @@
+package org.apache.dubbo.qos.command.impl;","[{'comment': 'Please add ASF license header', 'commenter': 'AlbumenJ'}]"
8175,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/CountTelnet.java,"@@ -1,70 +1,57 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.dubbo.qos.legacy;","[{'comment': 'Please recover ASF license header', 'commenter': 'AlbumenJ'}]"
8175,dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/RegistryConfigTest.java,"@@ -233,7 +233,8 @@ public void testOverrideConfigBySystemProps() {
             Assertions.assertEquals(1, registries.size());
             RegistryConfig registryConfig = registries.iterator().next();
             Assertions.assertEquals(""zookeeper://localhost:2188"", registryConfig.getAddress());
-        } finally {
+        } catch(Exception e){
+            e.printStackTrace();","[{'comment': 'exceptions should not be ignored in unit test cases', 'commenter': 'AlbumenJ'}]"
8175,dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/CountTelnetTest.java,"@@ -13,17 +13,19 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */
-package org.apache.dubbo.qos.legacy;
+ */package org.apache.dubbo.qos.command.impl;","[{'comment': 'please recover for code style', 'commenter': 'AlbumenJ'}]"
8175,dubbo-plugin/dubbo-qos/src/test/java/org/apache/dubbo/qos/command/impl/InvokeTelnetTest.java,"@@ -0,0 +1,256 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.qos.command.impl;
+
+import org.apache.dubbo.config.bootstrap.DubboBootstrap;
+import org.apache.dubbo.qos.command.BaseCommand;
+import org.apache.dubbo.qos.command.CommandContext;
+import org.apache.dubbo.qos.legacy.ProtocolUtils;
+import org.apache.dubbo.qos.legacy.service.DemoService;
+import org.apache.dubbo.qos.legacy.service.DemoServiceImpl;
+import org.apache.dubbo.remoting.RemotingException;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ServiceDescriptor;
+import org.apache.dubbo.rpc.model.ServiceRepository;
+
+import io.netty.channel.Channel;
+import io.netty.util.DefaultAttributeMap;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.reset;
+
+public class InvokeTelnetTest {
+
+    private static final BaseCommand invoke = new InvokeTelnet();
+    private static final BaseCommand select = new SelectTelnet();
+    private Channel mockChannel;
+    private CommandContext mockCommandContext;
+    private final DefaultAttributeMap defaultAttributeMap = new DefaultAttributeMap();
+    private final ServiceRepository repository = ApplicationModel.getServiceRepository();
+
+    @BeforeEach
+    public void setup() {
+        DubboBootstrap.reset();
+        mockChannel = mock(Channel.class);
+        mockCommandContext = mock(CommandContext.class);
+        given(mockCommandContext.getRemote()).willReturn(mockChannel);
+    }
+
+    @AfterEach
+    public void after() {
+        ProtocolUtils.closeAll();","[{'comment': 'reset DubboBootstrap after each test case', 'commenter': 'AlbumenJ'}]"
8236,dubbo-common/pom.xml,"@@ -80,6 +80,10 @@
             <groupId>org.eclipse.collections</groupId>
             <artifactId>eclipse-collections</artifactId>
         </dependency>
+        <dependency>
+            <groupId>com.google.protobuf</groupId>
+            <artifactId>protobuf-java</artifactId>","[{'comment': 'please add test only scope', 'commenter': 'AlbumenJ'}, {'comment': 'ok, i will change it.', 'commenter': 'xiaoheng1'}]"
8258,dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/telnet/support/TelnetHandlerAdapterTest.java,"@@ -0,0 +1,54 @@
+package org.apache.dubbo.remoting.telnet.support;","[{'comment': 'Please add ASF license header, thx', 'commenter': 'AlbumenJ'}, {'comment': '> Please add ASF license header, thx\r\n\r\nOK,I have added the ASF license header, thx!', 'commenter': 'dgzpg'}]"
8291,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java,"@@ -73,32 +74,37 @@ public AbstractDirectory(URL url, RouterChain<T> routerChain, boolean isUrlFromR
 
         this.url = url.removeAttribute(REFER_KEY).removeAttribute(MONITOR_KEY);
 
-        Object referParams = url.getAttribute(REFER_KEY);
-        if (referParams != null) {
-            this.queryMap = (Map<String, String>) referParams;
-            this.consumerUrl = (URL)url.getAttribute(CONSUMER_URL_KEY);
-        } else {
-            this.queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));
-        }
+        Map<String, String> referParams = (Map<String, String>) url.getAttribute(REFER_KEY);
+        this.consumerUrl = (URL) url.getAttribute(CONSUMER_URL_KEY);
 
-        if (consumerUrl == null) {
-            String host = StringUtils.isNotEmpty(queryMap.get(""register.ip"")) ? queryMap.get(""register.ip"") : this.url.getHost();
-            String path = queryMap.get(PATH_KEY);
-            String consumedProtocol = this.queryMap.get(PROTOCOL_KEY) == null ? DUBBO : this.queryMap.get(PROTOCOL_KEY);
+        if (consumerUrl == null && referParams != null) {
+            String host = StringUtils.isNotEmpty(referParams.get(""register.ip"")) ? referParams.get(""register.ip"") : this.url.getHost();
+            String path = referParams.get(PATH_KEY);
+            String consumedProtocol = referParams.get(PROTOCOL_KEY) == null ? DUBBO : referParams.get(PROTOCOL_KEY);
 
             URL consumerUrlFrom = this.url
                     .setHost(host)
                     .setPort(0)
                     .setProtocol(consumedProtocol)
-                    .setPath(path == null ? queryMap.get(INTERFACE_KEY) : path);
+                    .setPath(path == null ? referParams.get(INTERFACE_KEY) : path);
             if (isUrlFromRegistry) {
                 // reserve parameters if url is already a consumer url
                 consumerUrlFrom = consumerUrlFrom.clearParameters();
             }
-            this.consumerUrl = consumerUrlFrom.addParameters(queryMap).removeAttribute(MONITOR_KEY);
+            this.consumerUrl = consumerUrlFrom.addParameters(referParams).removeAttribute(MONITOR_KEY);
         }
 
         setRouterChain(routerChain);
+
+        Map<String, String> queryMap;
+        if (referParams != null) {
+            queryMap = ClusterUtils.mergeLocalParams(referParams);
+        } else {
+            queryMap = ClusterUtils.mergeLocalParams(StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY)));
+        }
+
+        // remove some local only parameters
+        this.queryMap = ClusterUtils.mergeLocalParams(queryMap);","[{'comment': '```java\r\nif (referParams != null) {\r\n    queryMap = ClusterUtils.mergeLocalParams(referParams);\r\n} \r\n\r\n\r\nthis.queryMap = ClusterUtils.mergeLocalParams(queryMap);\r\n\r\n```\r\n\r\nSeems like referParams will be merged twice?', 'commenter': 'chickenlj'}]"
8308,dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java,"@@ -559,6 +560,13 @@ public void refresh() {
         postProcessRefresh();
     }
 
+    private void invokeSetParameters(Map<String, String> values) {
+        Map<String, String> map = invokeGetParameters(getClass(), this);","[{'comment': 'It is better to check argument `Map<String, String> values`, If it is null or empty, just return', 'commenter': 'kylixs'}, {'comment': 'ok, i will modify it.', 'commenter': 'xiaoheng1'}]"
8308,dubbo-common/src/main/java/org/apache/dubbo/config/AbstractConfig.java,"@@ -540,10 +541,10 @@ public void refresh() {
                     String propertyName = extractPropertyName(method.getName());
                     String value = StringUtils.trim(subPropsConfiguration.getString(propertyName));
                     if (StringUtils.hasText(value)) {
-                        Map<String, String> map = invokeGetParameters(getClass(), this);
-                        map = map == null ? new HashMap<>() : map;
-                        map.putAll(convert(StringUtils.parseParameters(value), """"));
-                        invokeSetParameters(getClass(), this, map);
+                        invokeSetParameters(convert(StringUtils.parseParameters(value), """"));
+                    } else {
+                        // in this case, maybe parameters.item3=value3.
+                        invokeSetParameters(ConfigurationUtils.getSubProperties(subProperties, PARAMETERS));","[{'comment': 'Should we do `convert()` parameters or not? \r\nFor compatibility, convert is needed, but additional parameters will be added, which leads to more url parameters, which is not good. This compatibility does not know what the specific problem is, it is best to deal with it when the parameters are read.\r\n', 'commenter': 'kylixs'}, {'comment': 'Some use a.b, some a-b, we will normalize parameter keys later. ', 'commenter': 'kylixs'}]"
8320,dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java,"@@ -183,6 +183,8 @@
 
     String GROUP_KEY = ""group"";
 
+    String NACOS_GROUP_KEY = ""nacos.group"";","[{'comment': 'It would be better if we move this constant to dubbo-registry-nacos module', 'commenter': 'AlbumenJ'}, {'comment': 'good idea. i will modify it.', 'commenter': 'xiaoheng1'}]"
8320,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosNamingServiceUtils.java,"@@ -91,7 +93,9 @@ public static ServiceInstance toServiceInstance(Instance instance) {
      * @since 2.7.5
      */
     public static String getGroup(URL connectionURL) {
-        return connectionURL.getParameter(""nacos.group"", DEFAULT_GROUP);
+        // Compatible with nacos grouping via group.
+        String group = connectionURL.getParameter(GROUP_KEY, DEFAULT_GROUP);","[{'comment': 'Use `dubbo` as the default group will be better?', 'commenter': 'horizonzy'}, {'comment': 'If it is modified to dubbo, then the nacos registration center and configuration center side also need to be adjusted synchronously. This impact is relatively large.', 'commenter': 'xiaoheng1'}]"
8455,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -305,143 +330,153 @@ protected synchronized void init() {
                         map.put(methodConfig.getName() + "".retries"", ""0"");
                     }
                 }
-                AsyncMethodInfo asyncMethodInfo = AbstractConfig.convertMethodConfig2AsyncInfo(methodConfig);
-                if (asyncMethodInfo != null) {
-//                    consumerModel.getMethodModel(methodConfig.getName()).addAttribute(ASYNC_KEY, asyncMethodInfo);
-                    attributes.put(methodConfig.getName(), asyncMethodInfo);
-                }
             }
         }
 
-        String hostToRegistry = ConfigUtils.getSystemProperty(DUBBO_IP_TO_REGISTRY);
-        if (StringUtils.isEmpty(hostToRegistry)) {
-            hostToRegistry = NetUtils.getLocalHost();
-        } else if (isInvalidLocalHost(hostToRegistry)) {
-            throw new IllegalArgumentException(
-                    ""Specified invalid registry ip from property:"" + DUBBO_IP_TO_REGISTRY + "", value:"" + hostToRegistry);
-        }
-        map.put(REGISTER_IP_KEY, hostToRegistry);
+        return map;
+    }
 
-        serviceMetadata.getAttachments().putAll(map);
+    @SuppressWarnings({""unchecked""})
+    private T createProxy(Map<String, String> referenceParameters) {
+        if (shouldJvmRefer(referenceParameters)) {
+            createInvokerForLocal(referenceParameters);
+        } else {
+            urls.clear();
+            if (url != null && url.length() > 0) {
+                // user specified URL, could be peer-to-peer address, or register center's address.
+                parseUrl(referenceParameters);
+            } else {
+                // if protocols not in jvm checkRegistry
+                if (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) {
+                    AggregateUrlFromRegistry(referenceParameters);
+                }
+            }
+            createInvokerForRemote();
+        }
 
-        ref = createProxy(map);
+        if (logger.isInfoEnabled()) {
+            logger.info(""Referred dubbo service "" + interfaceClass.getName());
+        }
 
-        serviceMetadata.setTarget(ref);
-        serviceMetadata.addAttribute(PROXY_CLASS_REF, ref);
-        ConsumerModel consumerModel = repository.lookupReferredService(serviceMetadata.getServiceKey());
-        consumerModel.setProxyObject(ref);
-        consumerModel.init(attributes);
+        URL consumerUrl = new ServiceConfigURL(CONSUMER_PROTOCOL, referenceParameters.get(REGISTER_IP_KEY), 0,
+            referenceParameters.get(INTERFACE_KEY), referenceParameters);
+        MetadataUtils.publishServiceDefinition(consumerUrl);
 
-        initialized = true;
+        // create service proxy
+        return (T) PROXY_FACTORY.getProxy(invoker, ProtocolUtils.isGeneric(generic));
+    }
 
-        checkInvokerAvailable();
+    /**
+     * Make a local reference, create a local invoker.
+     *
+     * @param referenceParameters
+     */
+    private void createInvokerForLocal(Map<String, String> referenceParameters) {
+        URL url = new ServiceConfigURL(LOCAL_PROTOCOL, LOCALHOST_VALUE, 0, interfaceClass.getName()).addParameters(referenceParameters);
+        invoker = REF_PROTOCOL.refer(interfaceClass, url);
+        if (logger.isInfoEnabled()) {
+            logger.info(""Using in jvm service "" + interfaceClass.getName());
+        }
     }
 
-    @SuppressWarnings({""unchecked"", ""rawtypes"", ""deprecation""})
-    private T createProxy(Map<String, String> map) {
-        if (shouldJvmRefer(map)) {
-            URL url = new ServiceConfigURL(LOCAL_PROTOCOL, LOCALHOST_VALUE, 0, interfaceClass.getName()).addParameters(map);
-            invoker = REF_PROTOCOL.refer(interfaceClass, url);
-            if (logger.isInfoEnabled()) {
-                logger.info(""Using injvm service "" + interfaceClass.getName());
-            }
-        } else {
-            urls.clear();
-            if (url != null && url.length() > 0) { // user specified URL, could be peer-to-peer address, or register center's address.
-                String[] us = SEMICOLON_SPLIT_PATTERN.split(url);
-                if (us != null && us.length > 0) {
-                    for (String u : us) {
-                        URL url = URL.valueOf(u);
-                        if (StringUtils.isEmpty(url.getPath())) {
-                            url = url.setPath(interfaceName);
-                        }
-                        if (UrlUtils.isRegistry(url)) {
-                            urls.add(url.putAttribute(REFER_KEY, map));
-                        } else {
-                            URL peerURL = ClusterUtils.mergeUrl(url, map);
-                            peerURL = peerURL.putAttribute(PEER_KEY, true);
-                            urls.add(peerURL);
-                        }
-                    }
+    /**
+     * Parse the directly configured url.
+     */
+    private void parseUrl(Map<String, String> referenceParameters) {
+        String[] us = SEMICOLON_SPLIT_PATTERN.split(url);
+        if (us != null && us.length > 0) {
+            for (String u : us) {
+                URL url = URL.valueOf(u);
+                if (StringUtils.isEmpty(url.getPath())) {
+                    url = url.setPath(interfaceName);
                 }
-            } else { // assemble URL from register center's configuration
-                // if protocols not injvm checkRegistry
-                if (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) {
-                    checkRegistry();
-                    List<URL> us = ConfigValidationUtils.loadRegistries(this, false);
-                    if (CollectionUtils.isNotEmpty(us)) {
-                        for (URL u : us) {
-                            URL monitorUrl = ConfigValidationUtils.loadMonitor(this, u);
-                            if (monitorUrl != null) {
-                                u = u.putAttribute(MONITOR_KEY, monitorUrl);
-                            }
-                            urls.add(u.putAttribute(REFER_KEY, map));
-                        }
-                    }
-                    if (urls.isEmpty()) {
-                        throw new IllegalStateException(
-                                ""No such any registry to reference "" + interfaceName + "" on the consumer "" + NetUtils.getLocalHost() +
-                                        "" use dubbo version "" + Version.getVersion() +
-                                        "", please config <dubbo:registry address=\""...\"" /> to your spring config."");
-                    }
+                if (UrlUtils.isRegistry(url)) {
+                    urls.add(url.putAttribute(REFER_KEY, referenceParameters));
+                } else {
+                    URL peerUrl = ClusterUtils.mergeUrl(url, referenceParameters);
+                    peerUrl = peerUrl.putAttribute(PEER_KEY, true);
+                    urls.add(peerUrl);
                 }
             }
+        }
+    }
 
-            if (urls.size() == 1) {
-                invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(0));
-            } else {
-                List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();
-                URL registryURL = null;
-                for (URL url : urls) {
-                    // For multi-registry scenarios, it is not checked whether each referInvoker is available.
-                    // Because this invoker may become available later.
-                    invokers.add(REF_PROTOCOL.refer(interfaceClass, url));
-
-                    if (UrlUtils.isRegistry(url)) {
-                        registryURL = url; // use last registry url
-                    }
-                }
-
-                if (registryURL != null) { // registry url is available
-                    // for multi-subscription scenario, use 'zone-aware' policy by default
-                    String cluster = registryURL.getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME);
-                    // The invoker wrap sequence would be: ZoneAwareClusterInvoker(StaticDirectory) -> FailoverClusterInvoker(RegistryDirectory, routing happens here) -> Invoker
-                    invoker = Cluster.getCluster(cluster, false).join(new StaticDirectory(registryURL, invokers));
-                } else { // not a registry url, must be direct invoke.
-                    String cluster = CollectionUtils.isNotEmpty(invokers)
-                            ?
-                            (invokers.get(0).getUrl() != null ? invokers.get(0).getUrl().getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME) :
-                                    Cluster.DEFAULT)
-                            : Cluster.DEFAULT;
-                    invoker = Cluster.getCluster(cluster).join(new StaticDirectory(invokers));
+    /**
+     * Get URLs from the registry and aggregate them.
+     */
+    private void AggregateUrlFromRegistry(Map<String, String> referenceParameters) {","[{'comment': 'The method name should be `camelCase`', 'commenter': 'kylixs'}, {'comment': 'done', 'commenter': 'CrazyHZM'}]"
8455,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java,"@@ -64,7 +66,20 @@ public ConsumerModel(String serviceKey
         this.referenceConfig = referenceConfig;
     }
 
-    public void init(Map<String, AsyncMethodInfo> attributes) {
+
+    public void initMethodModels(List<MethodConfig> methodConfigs) {
+
+        Map<String, AsyncMethodInfo> attributes = null;
+        if (CollectionUtils.isNotEmpty(methodConfigs)) {
+            attributes = new HashMap<>(16);
+            for (MethodConfig methodConfig : methodConfigs) {
+                AsyncMethodInfo asyncMethodInfo = methodConfig.convertMethodConfig2AsyncInfo();","[{'comment': 'I think the model class should be as simple as possible, it is best to convert `MethodConfig` first, and then pass it to `ConsumerModel`.', 'commenter': 'kylixs'}, {'comment': 'In fact, ConsumerModel is not that simple, and the initMethodModels method of ConsumerModel is for MethodModel. There is nothing wrong with the association between MethodModel and MethodConfig.', 'commenter': 'CrazyHZM'}, {'comment': ""There are still some problems:\r\n* `ConsumerMethodModel` and `AsyncMethodInfo` are not the same things, the method naming is not very appropriate `initMethodModels(List<MethodConfig> methodConfigs)`, the origin method name is `init()`, it's means do some initialization, may include other attributes later. \r\n* `List<MethodConfig> methodConfigs` can be obtained by `ReferenceConfig.getMethods()`. \r\nIn fact, it does not need to be passed in by parameters."", 'commenter': 'kylixs'}, {'comment': 'Agree with this point of view, I revised it and reviewed it again.', 'commenter': 'CrazyHZM'}]"
8455,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -247,26 +238,69 @@ protected synchronized void init() {
             this.refresh();
         }
 
-        //init serivceMetadata
+        //init serviceMetadata
         initServiceMetadata(consumer);
         serviceMetadata.setServiceType(getServiceInterfaceClass());
         // TODO, uncomment this line once service key is unified
         serviceMetadata.setServiceKey(URL.buildKey(interfaceName, group, version));
 
+        Map<String, String> referenceParameters = appendConfig();
+
+        serviceMetadata.getAttachments().putAll(referenceParameters);
+
+        ref = createProxy(referenceParameters);
+
+        serviceMetadata.setTarget(ref);
+        serviceMetadata.addAttribute(PROXY_CLASS_REF, ref);
+
         ServiceRepository repository = ApplicationModel.getServiceRepository();
         ServiceDescriptor serviceDescriptor = repository.registerService(interfaceClass);
         repository.registerConsumer(","[{'comment': 'It seems that consumer model may be fetched in creating proxy processing. \r\n```java\r\n    public InvokerInvocationHandler(Invoker<?> handler) {\r\n        this.invoker = handler;\r\n        this.url = invoker.getUrl();\r\n        String serviceKey = this.url.getServiceKey();\r\n        this.protocolServiceKey = this.url.getProtocolServiceKey();\r\n        if (serviceKey != null) {\r\n            this.consumerModel = ApplicationModel.getConsumerModel(serviceKey);\r\n        }\r\n    }\r\n```\r\n![image](https://user-images.githubusercontent.com/5483385/128995823-747170b8-8687-4a4a-854c-75be07b5f7c8.png)\r\n', 'commenter': 'kylixs'}, {'comment': 'Has been adjusted, I feel that it can be optimized here.\r\nAt that time, I will think about the process here', 'commenter': 'CrazyHZM'}]"
8455,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -305,143 +353,153 @@ protected synchronized void init() {
                         map.put(methodConfig.getName() + "".retries"", ""0"");
                     }
                 }
-                AsyncMethodInfo asyncMethodInfo = AbstractConfig.convertMethodConfig2AsyncInfo(methodConfig);
-                if (asyncMethodInfo != null) {
-//                    consumerModel.getMethodModel(methodConfig.getName()).addAttribute(ASYNC_KEY, asyncMethodInfo);
-                    attributes.put(methodConfig.getName(), asyncMethodInfo);
-                }
             }
         }
 
-        String hostToRegistry = ConfigUtils.getSystemProperty(DUBBO_IP_TO_REGISTRY);
-        if (StringUtils.isEmpty(hostToRegistry)) {
-            hostToRegistry = NetUtils.getLocalHost();
-        } else if (isInvalidLocalHost(hostToRegistry)) {
-            throw new IllegalArgumentException(
-                    ""Specified invalid registry ip from property:"" + DUBBO_IP_TO_REGISTRY + "", value:"" + hostToRegistry);
-        }
-        map.put(REGISTER_IP_KEY, hostToRegistry);
+        return map;
+    }
 
-        serviceMetadata.getAttachments().putAll(map);
+    @SuppressWarnings({""unchecked""})
+    private T createProxy(Map<String, String> referenceParameters) {
+        if (shouldJvmRefer(referenceParameters)) {
+            createInvokerForLocal(referenceParameters);
+        } else {
+            urls.clear();
+            if (url != null && url.length() > 0) {
+                // user specified URL, could be peer-to-peer address, or register center's address.
+                parseUrl(referenceParameters);
+            } else {
+                // if protocols not in jvm checkRegistry
+                if (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) {
+                    aggregateUrlFromRegistry(referenceParameters);
+                }
+            }
+            createInvokerForRemote();
+        }
 
-        ref = createProxy(map);
+        if (logger.isInfoEnabled()) {
+            logger.info(""Referred dubbo service "" + interfaceClass.getName());","[{'comment': 'use unique service name is more explicit.\r\n```java\r\nlogger.info(""Referred dubbo service: "" + this.getUniqueServiceName());\r\n```', 'commenter': 'kylixs'}]"
8478,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java,"@@ -409,17 +405,7 @@ public boolean hasMethodParameter(String method) {
         }
 
         public String toDescString() {
-            return this.getMatchKey() + getMethodSignaturesString() + new TreeMap<>(getParams());
-        }
-
-        private String getMethodSignaturesString() {
-            SortedSet<String> methodStrings = new TreeSet();
-
-            Method[] methods = ClassUtils.forName(name).getMethods();
-            for (Method method : methods) {
-                methodStrings.add(method.toString());
-            }
-            return methodStrings.toString();
+            return this.getMatchKey() + name + group + version + path + protocol + new TreeMap<>(getParams());","[{'comment': 'The following two parts have the same meaning：\r\n\r\n`name + group + version + path + protocol`\r\n\r\n`getServiceKey()`', 'commenter': 'chickenlj'}, {'comment': 'done, `getMatchKey()` contains `name + group + version + protocol`', 'commenter': 'AlbumenJ'}]"
8492,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressURL.java,"@@ -62,30 +62,38 @@ public MetadataInfo getMetadataInfo() {
 
     @Override
     public String getServiceInterface() {
-        return RpcContext.getServiceContext().getInterfaceName();
+        String serviceInterface = RpcContext.getServiceContext().getInterfaceName();
+        return StringUtils.isEmpty(serviceInterface) ? super.getParameter(INTERFACE_KEY) : serviceInterface;
     }
 
+    @Override
     public String getGroup() {
-        return RpcContext.getServiceContext().getGroup();
+        String group = RpcContext.getServiceContext().getGroup();
+        return StringUtils.isEmpty(group) ? super.getGroup() : group;","[{'comment': ' `super.getGroup()/getVersion()/getServiceInterface()` will call `getParameter()` internally and will cause recursive calls to `super.getXXX()`', 'commenter': 'guohao'}, {'comment': 'Okay, I set consumerUrl to ServiceContext in AbstractClusterInvoker.', 'commenter': 'xiaoheng1'}]"
8492,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/InstanceAddressUrlListener.java,"@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.registry.client;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.registry.AddressListener;
+import org.apache.dubbo.rpc.cluster.Directory;
+
+import java.util.List;
+
+/**
+ * Add consumerUrl information
+ */
+@Activate(order = 0)
+public class InstanceAddressUrlListener implements AddressListener {
+    @Override
+    public List<URL> notify(List<URL> addresses, URL consumerUrl, Directory registryDirectory) {
+
+        if (CollectionUtils.isNotEmpty(addresses)) {
+            for (URL url : addresses) {
+                if (url instanceof InstanceAddressURL) {
+                    url.addParametersIfAbsent(consumerUrl.getParameters());
+                }","[{'comment': '`InstanceURL` is a application level URL which contains multiple service URLs, so `consumerUrl` in service level should not be add to `InstanceURL`', 'commenter': 'guohao'}]"
8492,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java,"@@ -333,10 +351,15 @@ protected LoadBalance initLoadBalance(List<Invoker<T>> invokers, Invocation invo
 
 
     private void setContext(Invoker<T> invoker) {
+        setContext(invoker, null);
+    }
+
+    private void setContext(Invoker<T> invoker, URL consumerUrl) {
         RpcContext context = RpcContext.getServiceContext();
         context.setInvoker(invoker)
-                .setRemoteAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort())
-                .setRemoteApplicationName(invoker.getUrl().getRemoteApplication());
+            .setRemoteAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort())
+            .setRemoteApplicationName(invoker.getUrl().getRemoteApplication())","[{'comment': 'needless to set remote-address and remote-application-name', 'commenter': 'AlbumenJ'}, {'comment': 'ok，i will remove it.', 'commenter': 'xiaoheng1'}]"
8497,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientTransportObserver.java,"@@ -41,6 +41,12 @@
     public ClientTransportObserver(ChannelHandlerContext ctx, AbstractClientStream stream, ChannelPromise promise) {
         this.ctx = ctx;
         this.promise = promise;
+        Boolean ssl = ctx.channel().attr(TripleConstant.SSL_ATTRIBUTE_KEY).get();
+        if (ssl != null && ssl) {
+            SCHEME = AsciiString.of(""https"");","[{'comment': '`of` will create a new AsciiString instance , try reuse a literal variable.', 'commenter': 'guohao'}]"
8497,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientHandler.java,"@@ -82,6 +82,8 @@ private void writeRequest(ChannelHandlerContext ctx, final Request req, final Ch
         } else {
             stream = AbstractClientStream.stream(url);
         }
+        boolean ssl = url.getParameter(CommonConstants.SSL_ENABLED_KEY,false);
+        ctx.channel().attr(TripleConstant.SSL_ATTRIBUTE_KEY).set(ssl);","[{'comment': 'Set attr only if  ssl `enabled`', 'commenter': 'guohao'}]"
8519,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/ShortestResponseLoadBalanceTest.java,"@@ -97,14 +97,13 @@ public void testSelectByResponse() throws NoSuchFieldException, IllegalAccessExc
             }
         }
         Map<Invoker<LoadBalanceBaseTest>, Integer> weightMap = weightInvokersSR.stream()
-                .collect(Collectors.toMap(Function.identity(), e -> Integer.valueOf(e.getUrl().getParameter(""weight""))));
+            .collect(Collectors.toMap(Function.identity(), e -> Integer.valueOf(e.getUrl().getParameter(""weight""))));
         Integer totalWeight = weightMap.values().stream().reduce(0, Integer::sum);
-        // max deviation 10%
+        // max deviation 12.5%
         int expectWeightValue = loop / totalWeight;
-        int maxDeviation = expectWeightValue / 10;
+        int maxDeviation = expectWeightValue / 8;","[{'comment': 'As for test stability, it would be better to set maxDeviation to `expectWeightValue*2` to tolerant random seed problem.', 'commenter': 'AlbumenJ'}, {'comment': 'Good idea!', 'commenter': '24kpure'}]"
8566,compiler/src/main/resources/Dubbo3InterfaceStub.mustache,"@@ -18,11 +18,37 @@ static final String SERVICE_NAME = ""{{commonPackageName}}.{{serviceName}}"";
     // FIXME, initialize Dubbo3 stub when interface loaded, thinking of new ways doing this.
     static final boolean inited = {{className}}.init();
 
-{{#methods}}
+{{#unaryMethods}}
+    {{#javaDoc}}
+        {{{javaDoc}}}
+    {{/javaDoc}}
+    {{#deprecated}}
+        @java.lang.Deprecated
+    {{/deprecated}}
     {{outputType}} {{methodName}}({{inputType}} request);
 
     CompletableFuture<{{outputType}}> {{methodName}}Async({{inputType}} request);
 
-{{/methods}}
+{{/unaryMethods}}
+
+{{#serverStreamingMethods}}
+    {{#javaDoc}}
+        {{{javaDoc}}}
+    {{/javaDoc}}
+    {{#deprecated}}
+        @java.lang.Deprecated
+    {{/deprecated}}
+    void {{methodName}}({{inputType}} request, org.apache.dubbo.common.stream.StreamObserver<{{outputType}}> responseObserver);
+{{/serverStreamingMethods}}
+
+{{#biStreamingMethods}}
+    {{#javaDoc}}
+        {{{javaDoc}}}
+    {{/javaDoc}}
+    {{#deprecated}}
+        @java.lang.Deprecated
+    {{/deprecated}}
+    org.apache.dubbo.common.stream.StreamObserver<{{inputType}}> {{methodName}}(org.apache.dubbo.common.stream.StreamObserver<{{outputType}}> responseObserver);
+{{/biStreamingMethods}}","[{'comment': ""I think we should consider how the developers will use this before determining support of streaming interface:\r\n* For the consumer side, developers can call any of the `sync`, `async`, `streaming` methods from the proxy they get.\r\n* For the provider side, developers don't have to provider implementation for all methods, one bi-directional streaming implementation would be enough."", 'commenter': 'chickenlj'}, {'comment': ""i think we should support like grpc. That's enough.This is also how tri Stream is implemented"", 'commenter': 'EarthChen'}, {'comment': 'Yes, but simply add those streaming method declarations will be a burden for the Provider, we should think of letting the Provider only care about the bi-directional streaming implementation.', 'commenter': 'chickenlj'}, {'comment': 'not have to give the implementation of all methods.', 'commenter': 'chickenlj'}, {'comment': 'server stream and bi stream is diff, Developers should decide which to use', 'commenter': 'EarthChen'}, {'comment': ""They are different and that's the key point we need to determine. I think for the most generic case, Provider can provider one streaming implementation that can serve all different kinds of calls from the Consumer side. "", 'commenter': 'chickenlj'}, {'comment': ""Sure we can let the Provider decide to only support unary or streaming or bi streaming, but is that necessary, or at least whey they want to choose they don't need to give the implementation of all kinds."", 'commenter': 'chickenlj'}, {'comment': 'You mean to provide a default implementation that wraps the service stream with a bi-directional stream', 'commenter': 'EarthChen'}, {'comment': ""I got it the wrong way. \r\n\r\nThere're `{{#unaryMethods}}` and `{{#serverStreamingMethods}}` instructing creation of which kind of method. I thought all kinds of methods would be created for one method defined in IDL.a"", 'commenter': 'chickenlj'}]"
8584,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -239,6 +239,16 @@ public synchronized void export() {
         }
     }
 
+    protected void doDelayExport() {
+        DELAY_EXPORT_EXECUTOR.schedule(() -> {
+            try {
+                doExport();
+            } catch (Exception e) {
+                logger.error(e);","[{'comment': 'general log is not recommended.', 'commenter': 'changfubai'}, {'comment': 'Add some brief info such as `logger.error(""Export service ${foo} failed"",e)`', 'commenter': 'guohao'}]"
8584,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -260,7 +270,7 @@ private void checkAndUpdateSubConfigs() {
 
         // init some null configuration.
         List<ConfigInitializer> configInitializers = ExtensionLoader.getExtensionLoader(ConfigInitializer.class)
-                .getActivateExtension(URL.valueOf(""configInitializer://""), (String[]) null);
+            .getActivateExtension(URL.valueOf(""configInitializer://""), (String[]) null);","[{'comment': 'Plz fix fomat', 'commenter': 'guohao'}]"
8585,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ServerStream.java,"@@ -83,27 +84,34 @@ public void onMetadata(Metadata metadata, boolean endStream, OperationHandler ha
                 subscribe((StreamObserver<Object>) result.getValue());
             } catch (Throwable t) {
                 transportError(GrpcStatus.fromCode(GrpcStatus.Code.INTERNAL)
-                        .withDescription(""Failed to create server's observer""));
+                    .withDescription(""Failed to create server's observer""));
             }
         }
 
         @Override
         public void onData(byte[] in, boolean endStream, OperationHandler handler) {
             try {
-                final Object[] arguments = deserializeRequest(in);
-                if (arguments != null) {
-                    if (getMethodDescriptor().getRpcType() == MethodDescriptor.RpcType.SERVER_STREAM) {
-                        final RpcInvocation inv = buildInvocation(getHeaders());
+                if (getMethodDescriptor().getRpcType() == MethodDescriptor.RpcType.SERVER_STREAM) {
+                    RpcInvocation inv = buildInvocation(getHeaders());
+                    for (HeaderFilter headerFilter : getHeaderFilters()) {
+                        inv = headerFilter.invoke(getInvoker(), inv);
+                    }
+                    final Object[] arguments = deserializeRequest(in);
+                    if (arguments != null) {
                         inv.setArguments(new Object[]{arguments[0], asStreamObserver()});
                         getInvoker().invoke(inv);
-                    } else {
+                    }
+                } else {
+                    final Object[] arguments = deserializeRequest(in);","[{'comment': 'Bi-stream will create inocation at `onMetadata` method, filters should also be added there', 'commenter': 'guohao'}]"
8585,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TokenHeaderFilter.java,"@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.filter;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.utils.ConfigUtils;
+import org.apache.dubbo.rpc.HeaderFilter;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.RpcInvocation;
+
+import java.util.Map;
+
+import static org.apache.dubbo.rpc.Constants.TOKEN_KEY;
+
+@Activate
+public class TokenHeaderFilter implements HeaderFilter {
+    @Override
+    public RpcInvocation invoke(Invoker<?> invoker, RpcInvocation invocation) throws RpcException {
+        String token = invoker.getUrl().getParameter(TOKEN_KEY);
+        if (ConfigUtils.isNotEmpty(token)) {
+            Class<?> serviceType = invoker.getInterface();
+            Map<String, Object> attachments = invocation.getObjectAttachments();
+            String remoteToken = (attachments == null ? null : (String) attachments.get(TOKEN_KEY));
+            if (!token.equals(remoteToken)) {
+                throw new RpcException(""Forbid invoke remote service "" + serviceType + "" method "" + invocation.getMethodName() +","[{'comment': 'Should an explicit exception be throwed to set `grpc-status` as `Unauthorized`?', 'commenter': 'guohao'}]"
8608,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryClientStream.java,"@@ -54,9 +54,14 @@ protected TransportObserver createTransportObserver() {
         public void doOnComplete(OperationHandler handler) {
             execute(() -> {
                 try {
-                    final Object resp = deserializeResponse(getData());
+                    AppResponse result;
+                    if (!""void"".equals(getMethodDescriptor().getReturnClass().getName())) {","[{'comment': 'i think string ""void"" is not good ，consider change to `Void.TYPE`', 'commenter': 'EarthChen'}]"
8642,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java,"@@ -257,17 +256,6 @@ private Metadata getTrailers(GrpcStatus grpcStatus) {
         if (getMethodDescriptor() != null && !getMethodDescriptor().isNeedWrap()) {","[{'comment': 'remove useless code ,return metadata directly', 'commenter': 'EarthChen'}]"
8668,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryClientStream.java,"@@ -75,17 +75,19 @@ public void doOnComplete() {
 
         @Override
         protected void onError(GrpcStatus status) {
-            Response response = new Response(getRequest().getId(), TripleConstant.TRI_VERSION);
-            response.setErrorMessage(status.description);
-            final AppResponse result = new AppResponse();
-            result.setException(getThrowable(this.getTrailers()));
-            result.setObjectAttachments(UnaryClientStream.this.parseMetadataToAttachmentMap(this.getTrailers()));
-            response.setResult(result);
-            if (!result.hasException()) {
-                final byte code = GrpcStatus.toDubboStatus(status.code);
-                response.setStatus(code);
-            }
-            DefaultFuture2.received(getConnection(), response);
+            execute(()-> {","[{'comment': 'Please explain the reason for this change with a comment.', 'commenter': 'EarthChen'}]"
8671,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/util/NacosNamingServiceUtils.java,"@@ -133,7 +133,7 @@ private static void setServerAddr(URL url, Properties properties) {
     }
 
     private static void setProperties(URL url, Properties properties) {
-        putPropertyIfAbsent(url, properties, NACOS_NAMING_LOG_NAME);
+        putPropertyIfAbsent(url, properties, NACOS_NAMING_LOG_NAME, null);","[{'comment': '`null` should not be default value here. We should not call `properties.setProperty` with null.', 'commenter': 'AlbumenJ'}, {'comment': 'Also refer to Integration Tests', 'commenter': 'AlbumenJ'}]"
8701,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java,"@@ -246,12 +246,17 @@ private void refreshInvoker(List<URL> invokerUrls) {
             destroyAllInvokers(); // Close all invokers
         } else {
             this.forbidden = false; // Allow accessing
-            Map<String, Invoker<T>> oldUrlInvokerMap = this.urlInvokerMap; // local reference
             if (CollectionUtils.isEmpty(invokerUrls)) {
                 return;
             }
 
-            Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map
+            // can't use local reference because this.urlInvokerMap might be accessed at isAvailable() by main thread concurrently.
+            Map<String, Invoker<T>> oldUrlInvokerMap = null;
+            if (this.urlInvokerMap != null) {
+                oldUrlInvokerMap = new HashMap<>();","[{'comment': 'it would be better to sepcify the default size for HashMap here', 'commenter': 'AlbumenJ'}, {'comment': 'using LinkedHashMap will reduce temporally memery usage when using iterator in forEach', 'commenter': 'AlbumenJ'}, {'comment': '@AlbumenJ already changed to LinkedHashMap and set the default size', 'commenter': 'zrlw'}]"
8701,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java,"@@ -216,7 +216,14 @@ private void refreshInvoker(List<URL> invokerUrls) {
             if (invokerUrls.isEmpty()) {
                 return;
             }
-            Map<URL, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map
+            
+            // can't use local reference because this.urlInvokerMap might be accessed at isAvailable() by main thread concurrently.
+            Map<URL, Invoker<T>> oldUrlInvokerMap = null;
+            if (this.urlInvokerMap != null) {
+                oldUrlInvokerMap = new HashMap<>();","[{'comment': 'also for there', 'commenter': 'AlbumenJ'}, {'comment': 'pls review again', 'commenter': 'zrlw'}]"
8701,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java,"@@ -222,7 +223,14 @@ private void refreshInvoker(List<URL> invokerUrls) {
             if (invokerUrls.isEmpty()) {
                 return;
             }
-            Map<URL, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map
+            
+            // can't use local reference because this.urlInvokerMap might be accessed at isAvailable() by main thread concurrently.
+            Map<URL, Invoker<T>> oldUrlInvokerMap = null;
+            if (this.urlInvokerMap != null) {
+                oldUrlInvokerMap = new LinkedHashMap<>(this.urlInvokerMap.size());","[{'comment': 'Please consider load factor. `this.urlInvokerMap.size() / 0.75f + 1` would reduce one time resize.', 'commenter': 'AlbumenJ'}, {'comment': 'do you mean setting the initial capacity greater than the maximum number of entries divided by the load factor (default: 0.75) to avoid rehash operations?', 'commenter': 'zrlw'}, {'comment': '```\r\n            if (this.urlInvokerMap != null) {\r\n                // the initial capacity should be set greater than the maximum number of entries divided by the load factor to avoid resizing.\r\n                oldUrlInvokerMap = new LinkedHashMap<>(Math.round(1 + this.urlInvokerMap.size() / DEFAULT_HASHMAP_LOAD_FACTOR));\r\n                this.urlInvokerMap.forEach(oldUrlInvokerMap::put);\r\n            }\r\n```\r\npls review again', 'commenter': 'zrlw'}]"
8705,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientHandler.java,"@@ -74,12 +74,12 @@ private void writeRequest(ChannelHandlerContext ctx, final Request req, final Ch
         final URL url = inv.getInvoker().getUrl();
         ConsumerModel consumerModel = (ConsumerModel) url.getServiceModel();
 
-        MethodDescriptor methodDescriptor = consumerModel.getServiceModel().getMethod(inv.getMethodName(), inv.getParameterTypes());
-        String serviceKey = url.getServiceKey();
-        // If it is InstanceAddressURL, the serviceKey may not be obtained.
-        if (null == serviceKey) {
-            serviceKey = inv.getTargetServiceUniqueName();
-        }
+        MethodDescriptor methodDescriptor = inv.getMethodDescriptor();
+        // String serviceKey = url.getServiceKey();","[{'comment': 'Remove this ?', 'commenter': 'guohao'}]"
8705,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2FrameServerHandler.java,"@@ -172,17 +173,20 @@ public void onHeadersRead(ChannelHandlerContext ctx, Http2HeadersFrame msg) thro
         MethodDescriptor methodDescriptor = null;
         List<MethodDescriptor> methodDescriptors = null;
 
-        if (CommonConstants.$INVOKE.equals(methodName) || CommonConstants.$INVOKE_ASYNC.equals(methodName)) {
+        if (isINVOKE(methodName)) {","[{'comment': '`isGeneric`', 'commenter': 'guohao'}]"
8712,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/GrpcStatus.java,"@@ -82,6 +88,31 @@ public static byte toDubboStatus(Code code) {
         return status;
     }
 
+    public static GrpcStatus rpcExceptionCodeToGrpc(int rpcExceptionCode) {
+        Code code;
+        switch (rpcExceptionCode) {
+            case TIMEOUT_EXCEPTION:
+                code = Code.DEADLINE_EXCEEDED;
+                break;
+            case FORBIDDEN_EXCEPTION:
+                code = Code.PERMISSION_DENIED;
+                break;
+            case LIMIT_EXCEEDED_EXCEPTION:
+                code = Code.ABORTED;
+                break;
+            case TIMEOUT_TERMINATE:
+                code = Code.OUT_OF_RANGE;","[{'comment': 'DEADLINE_EXCEEDED', 'commenter': 'guohao'}]"
8712,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/GrpcStatus.java,"@@ -82,6 +88,31 @@ public static byte toDubboStatus(Code code) {
         return status;
     }
 
+    public static GrpcStatus rpcExceptionCodeToGrpc(int rpcExceptionCode) {
+        Code code;
+        switch (rpcExceptionCode) {
+            case TIMEOUT_EXCEPTION:
+                code = Code.DEADLINE_EXCEEDED;
+                break;
+            case FORBIDDEN_EXCEPTION:
+                code = Code.PERMISSION_DENIED;
+                break;
+            case LIMIT_EXCEEDED_EXCEPTION:
+                code = Code.ABORTED;","[{'comment': 'https://github.com/grpc/grpc/blob/master/doc/http-grpc-status-mapping.md\r\n\r\nUNAVAILABLE will be better', 'commenter': 'guohao'}]"
8712,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/GrpcStatus.java,"@@ -82,6 +88,31 @@ public static byte toDubboStatus(Code code) {
         return status;
     }
 
+    public static GrpcStatus rpcExceptionCodeToGrpc(int rpcExceptionCode) {
+        Code code;
+        switch (rpcExceptionCode) {
+            case TIMEOUT_EXCEPTION:
+                code = Code.DEADLINE_EXCEEDED;
+                break;
+            case FORBIDDEN_EXCEPTION:
+                code = Code.PERMISSION_DENIED;
+                break;
+            case LIMIT_EXCEEDED_EXCEPTION:
+                code = Code.ABORTED;
+                break;
+            case TIMEOUT_TERMINATE:
+                code = Code.OUT_OF_RANGE;
+                break;
+            case METHOD_NOT_FOUND:
+                code = Code.NOT_FOUND;
+                break;
+            default:
+                code = Code.UNKNOWN;
+                break;
+        }
+        return fromCode(code);
+    }
+","[{'comment': 'Add `NETWORK_EXCEPTION` -> `UNAVAILABLE`\r\n`SERIALIZATION_EXCEPTION` -> `INTERNAL`\r\n\r\n', 'commenter': 'guohao'}]"
8712,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryServerStream.java,"@@ -98,11 +101,11 @@ public void invoke() {
                 try {
                     if (response.hasException()) {
                         final Throwable exception = response.getException();
-                        if (exception instanceof TripleRpcException) {
-                            transportError(((TripleRpcException) exception).getStatus(), response.getObjectAttachments());
+                        if (exception instanceof RpcException) {
+                            transportError(rpcExceptionCodeToGrpc(((RpcException) exception).getCode()), response.getObjectAttachments());","[{'comment': ""detail msg in `RPCException` has been dropped, should be pass to `Status`' description"", 'commenter': 'guohao'}]"
8712,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryServerStream.java,"@@ -114,28 +117,28 @@ public void invoke() {
                     final byte[] data;
                     try {
                         ClassLoadUtil.switchContextLoader(
-                                getProviderModel().getServiceInterfaceClass().getClassLoader());
+                            getProviderModel().getServiceInterfaceClass().getClassLoader());
                         data = encodeResponse(response.getValue());
                     } finally {
                         ClassLoadUtil.switchContextLoader(tccl);
                     }
                     getTransportSubscriber().onData(data, false);
 
                     Metadata trailers = new DefaultMetadata()
-                            .put(TripleHeaderEnum.STATUS_KEY.getHeader(), Integer.toString(GrpcStatus.Code.OK.code));
+                        .put(TripleHeaderEnum.STATUS_KEY.getHeader(), Integer.toString(GrpcStatus.Code.OK.code));
                     final Map<String, Object> attachments = response.getObjectAttachments();
                     if (attachments != null) {
                         convertAttachment(trailers, attachments);
                     }
                     getTransportSubscriber().onMetadata(trailers, true);
                 } catch (Throwable e) {
                     LOGGER.warn(""Exception processing triple message"", e);
-                    if (e instanceof TripleRpcException) {
-                        transportError(((TripleRpcException) e).getStatus(), response.getObjectAttachments());
+                    if (e instanceof RpcException) {
+                        transportError(rpcExceptionCodeToGrpc(((RpcException) e).getCode()), response.getObjectAttachments());","[{'comment': 'Same issue as above', 'commenter': 'guohao'}]"
8712,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/GrpcStatus.java,"@@ -82,6 +83,28 @@ public static byte toDubboStatus(Code code) {
         return status;
     }
 
+    public static GrpcStatus rpcExceptionCodeToGrpc(int rpcExceptionCode) {","[{'comment': 'Would it be better to replace it with enum？and put them in map and getValue', 'commenter': 'EarthChen'}]"
8721,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java,"@@ -53,38 +53,40 @@ public MetadataServiceNameMapping() {
 
     @Override
     public boolean map(URL url) {
-            if (CollectionUtils.isEmpty(applicationModel.getApplicationConfigManager().getMetadataConfigs())) {
-                return false;
-            }
-            String serviceInterface = url.getServiceInterface();
-            if (IGNORED_SERVICE_INTERFACES.contains(serviceInterface)) {
-                return false;
-            }
-            String registryCluster = getRegistryCluster(url);
-            MetadataReport metadataReport = metadataReportInstance.getMetadataReport(registryCluster);
+        if (CollectionUtils.isEmpty(applicationModel.getApplicationConfigManager().getMetadataConfigs())) {
+            return false;
+        }
+        String serviceInterface = url.getServiceInterface();
+        if (IGNORED_SERVICE_INTERFACES.contains(serviceInterface)) {
+            return false;
+        }
+        String registryCluster = getRegistryCluster(url);
+        MetadataReport metadataReport = metadataReportInstance.getMetadataReport(registryCluster);
 
-            String appName = applicationModel.getApplicationName();
-            if (metadataReport.registerServiceAppMapping(serviceInterface, appName, url)) {
-                // MetadataReport support directly register service-app mapping
-                return true;
-            }
+        String appName = applicationModel.getApplicationName();
+        if (metadataReport.registerServiceAppMapping(serviceInterface, appName, url)) {
+            // MetadataReport support directly register service-app mapping
+            return true;
+        }
 
-            int currentRetryTimes = 1;
-            boolean succeeded = false;
-            String newConfigContent = appName;
-            do {
-                ConfigItem configItem = metadataReport.getConfigItem(serviceInterface, DEFAULT_MAPPING_GROUP);
-                String oldConfigContent = configItem.getContent();
-                if (StringUtils.isNotEmpty(oldConfigContent)) {
-                    boolean contains = StringUtils.isContains(oldConfigContent, appName);
-                    if (contains) {
-                        break;
-                    }
-                    newConfigContent = oldConfigContent + COMMA_SEPARATOR + appName;
+        int currentRetryTimes = 1;
+        boolean succeeded = false;
+        String newConfigContent = appName;
+        do {
+            ConfigItem configItem = metadataReport.getConfigItem(serviceInterface, DEFAULT_MAPPING_GROUP);
+            String oldConfigContent = configItem.getContent();
+            if (StringUtils.isNotEmpty(oldConfigContent)) {
+                boolean contains = StringUtils.isContains(oldConfigContent, appName);
+                if (contains) {
+                    // From the user's perspective, it means successful when the oldConfigContent has contained the current appName. So we should not throw an Exception to user, it will confuse the user.
+                    succeeded = true;","[{'comment': 'Is it better to just return true?', 'commenter': 'EarthChen'}, {'comment': 'According to the original function,  setting the `succeeded` variable may be better.\r\nThe latter code may do something base on `succeeded` status.\r\n', 'commenter': 'plusmancn'}, {'comment': 'Based on existing code, a direct return is better', 'commenter': 'EarthChen'}]"
8730,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/Constants.java,"@@ -95,10 +95,10 @@
     String INVOCATION_KEY = ""invocation"";
     String SERIALIZATION_ID_KEY = ""serialization_id"";
 
-    String H2_SETTINGS_HEADER_TABLE_SIZE_KEY = ""h2.settings.header-table-size"";
-    String H2_SETTINGS_ENABLE_PUSH_KEY = ""h2.settings.enable-push"";
-    String H2_SETTINGS_MAX_CONCURRENT_STREAMS_KEY = ""h2.settings.max-concurrent-streams"";
-    String H2_SETTINGS_INITIAL_WINDOW_SIZE_KEY = ""h2.settings.initial-window-size"";
-    String H2_SETTINGS_MAX_FRAME_SIZE_KEY = ""h2.settings.max-frame-size"";
-    String H2_SETTINGS_MAX_HEADER_LIST_SIZE_KEY = ""h2.settings.max-header-list-size"";
+    String H2_SETTINGS_HEADER_TABLE_SIZE_KEY = ""dubbo.rpc.tri.header-table-size"";
+    String H2_SETTINGS_ENABLE_PUSH_KEY = ""dubbo.rpc.tri.enable-push"";
+    String H2_SETTINGS_MAX_CONCURRENT_STREAMS_KEY = ""dubbo.rpc.tri.max-concurrent-streams"";
+    String H2_SETTINGS_INITIAL_WINDOW_SIZE_KEY = ""dubbo.rpc.tri.init-window-size"";","[{'comment': ""It's better to just change the prefix . `dubbo.rpc.tri.initial-window-size`"", 'commenter': 'EarthChen'}, {'comment': 'ACK', 'commenter': 'zhuangjinjin'}]"
8730,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java,"@@ -55,7 +56,7 @@ public void close() {
 
     @Override
     public void configServerPipeline(ChannelPipeline pipeline, SslContext sslContext) {
-        final Configuration config = ConfigurationUtils.getGlobalConfiguration();
+        final Configuration config = ConfigurationUtils.getGlobalConfiguration(ApplicationModel.defaultModel());","[{'comment': 'Is the `defaultModel` always ok?', 'commenter': 'plusmancn'}, {'comment': 'I will solve this  in another PR , plz just ignore here', 'commenter': 'guohao'}]"
8834,dubbo-configcenter/dubbo-configcenter-zookeeper/src/main/java/org/apache/dubbo/configcenter/support/zookeeper/CacheListener.java,"@@ -98,7 +98,9 @@ private String getGroup(String path) {
     @Override
     public void dataChanged(String path, Object value, EventType eventType) {
         ConfigChangeType changeType;
-        if (value == null) {
+        if (EventType.NodeCreated.equals(eventType)) {
+            changeType = ConfigChangeType.ADDED;
+        } if (value == null) {","[{'comment': 'else if  (value == null) \r\n\r\n漏了个else，逻辑完全不一样了。', 'commenter': 'changfubai'}, {'comment': 'you are right', 'commenter': 'zrlw'}]"
8840,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/MetadataReport.java,"@@ -45,7 +45,7 @@
     default void publishAppMetadata(SubscriberMetadataIdentifier identifier, MetadataInfo metadataInfo) {
     }
 
-    default MetadataInfo getAppMetadata(SubscriberMetadataIdentifier identifier, Map<String, String> instanceMetadata) {
+    default MetadataInfo getAppMetadata(SubscriberMetadataIdentifier identifier) {","[{'comment': 'Please do not change this method signature. `instanceMetadata` contains some instance releated properties which will take effect when getting metadata', 'commenter': 'AlbumenJ'}]"
8871,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/CancellationContext.java,"@@ -0,0 +1,118 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.Executor;
+
+public class CancellationContext implements Closeable {
+
+    private ArrayList<ExecutableListener> listeners;
+    private Throwable cancellationCause;
+    private boolean cancelled;
+
+    public void addListener(
+            final CancellationListener cancellationListener, final Executor executor) {
+        addListener(cancellationListener, executor, null);
+    }
+
+    public void addListener(
+            final CancellationListener cancellationListener) {
+        addListener(cancellationListener, Runnable::run, null);
+    }
+
+    public void addListener(
+            final CancellationListener cancellationListener,
+            final RpcServiceContext context) {
+        addListener(cancellationListener, Runnable::run, context);
+    }
+
+    public void addListener(
+            final CancellationListener cancellationListener,
+            final Executor executor,
+            final RpcServiceContext context) {
+        addListenerInternal(new ExecutableListener(executor, cancellationListener, context));
+    }
+
+    public void addListenerInternal(ExecutableListener executableListener) {
+        synchronized (this) {
+            if (isCancelled()) {
+                executableListener.deliver();
+            } else {
+                if (listeners == null) {
+                    listeners = new ArrayList<>();
+                }
+                listeners.add(executableListener);
+            }
+        }
+    }
+
+    public boolean cancel(Throwable cause) {
+        boolean triggeredCancel = false;
+        synchronized (this) {
+            if (!cancelled) {
+                cancelled = true;
+                this.cancellationCause = cause;
+                triggeredCancel = true;
+            }
+        }
+        if (triggeredCancel) {
+            notifyAndClearListeners();
+        }
+        return triggeredCancel;
+    }
+
+    private void notifyAndClearListeners() {
+        ArrayList<ExecutableListener> tmpListeners;
+        synchronized (this) {
+            if (listeners == null) {
+                return;
+            }
+            tmpListeners = listeners;","[{'comment': 'This reference may cause `ConcurrentModification`', 'commenter': 'guohao'}, {'comment': ""It's not going to produce"", 'commenter': 'EarthChen'}]"
8871,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/CancellationContext.java,"@@ -0,0 +1,118 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.Executor;
+
+public class CancellationContext implements Closeable {
+
+    private ArrayList<ExecutableListener> listeners;
+    private Throwable cancellationCause;
+    private boolean cancelled;
+
+    public void addListener(
+            final CancellationListener cancellationListener, final Executor executor) {
+        addListener(cancellationListener, executor, null);
+    }
+
+    public void addListener(
+            final CancellationListener cancellationListener) {
+        addListener(cancellationListener, Runnable::run, null);
+    }
+
+    public void addListener(
+            final CancellationListener cancellationListener,
+            final RpcServiceContext context) {
+        addListener(cancellationListener, Runnable::run, context);
+    }
+
+    public void addListener(
+            final CancellationListener cancellationListener,
+            final Executor executor,
+            final RpcServiceContext context) {
+        addListenerInternal(new ExecutableListener(executor, cancellationListener, context));
+    }
+
+    public void addListenerInternal(ExecutableListener executableListener) {
+        synchronized (this) {
+            if (isCancelled()) {
+                executableListener.deliver();
+            } else {
+                if (listeners == null) {
+                    listeners = new ArrayList<>();
+                }
+                listeners.add(executableListener);
+            }
+        }
+    }
+
+    public boolean cancel(Throwable cause) {
+        boolean triggeredCancel = false;
+        synchronized (this) {
+            if (!cancelled) {
+                cancelled = true;
+                this.cancellationCause = cause;
+                triggeredCancel = true;
+            }
+        }
+        if (triggeredCancel) {
+            notifyAndClearListeners();
+        }
+        return triggeredCancel;
+    }
+
+    private void notifyAndClearListeners() {
+        ArrayList<ExecutableListener> tmpListeners;
+        synchronized (this) {
+            if (listeners == null) {
+                return;
+            }
+            tmpListeners = listeners;
+            listeners = null;
+        }
+        for (ExecutableListener tmpListener : tmpListeners) {
+            tmpListener.deliver();
+        }
+    }
+
+    public boolean isCancelled() {","[{'comment': '```suggestion\r\n    public synchronized boolean isCancelled() {\r\n       return cancelled;\r\n    }\r\n```', 'commenter': 'guohao'}]"
8871,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ServerTransportObserver.java,"@@ -48,19 +59,38 @@ public void onMetadata(Metadata metadata, boolean endStream) {
             headers.set(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader(), TripleConstant.CONTENT_PROTO);
         }
         ctx.writeAndFlush(new DefaultHttp2HeadersFrame(headers, endStream))
-            .addListener(future -> {
-                if (!future.isSuccess()) {
-                    promise.tryFailure(future.cause());
-                }
-            });
+                .addListener(future -> {","[{'comment': 'why discard `promise` here ?', 'commenter': 'guohao'}, {'comment': 'This PR has an explanation.\r\nhttps://github.com/apache/dubbo/pull/8922', 'commenter': 'EarthChen'}]"
8907,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/MockClusterInvoker.java,"@@ -75,6 +75,9 @@ public boolean isAvailable() {
 
     @Override
     public void destroy() {
+        //#8895 second question directory must destroy","[{'comment': 'please remove this issue reference, just leave some description is enough', 'commenter': 'AlbumenJ'}]"
8907,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java,"@@ -238,7 +238,8 @@ public void destroy() {
         // unsubscribe.
         try {
             if (getSubscribeConsumerurl() != null && registry != null && registry.isAvailable()) {
-                registry.unsubscribe(getSubscribeConsumerurl(), this);
+                //#8895 second question overwrite by child","[{'comment': 'please remove this issue reference, just leave some description is enough', 'commenter': 'AlbumenJ'}]"
8907,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -495,26 +512,45 @@ private void filterServiceNames(Set<String> serviceNames, URL url) {
 
     private void subscribeEventListener(String serviceName, final URL url, final NotifyListener listener)
             throws NacosException {
-        EventListener eventListener = event -> {
-            if (event instanceof NamingEvent) {
-                NamingEvent e = (NamingEvent) event;
-                List<Instance> instances = e.getInstances();
+        ConcurrentMap<NotifyListener, EventListener> listeners = nacosListeners.computeIfAbsent(url, k -> new ConcurrentHashMap<>());
+        EventListener nacosListener = listeners.computeIfAbsent(listener, k -> {","[{'comment': 'mark: This fixes a memory leak in Dubbo admin √', 'commenter': 'wuwen5'}, {'comment': '发现这里解决了一个内存泄露问题👍，之前```EventListener```会被```scheduleServiceNamesLookup```无限制存储到 ```com.alibaba.nacos.client.naming.event.InstancesChangeNotifier#listenerMap```中，导致内存溢出, 这里标记下，后续有人dubbo-admin中遇到可以关注下', 'commenter': 'wuwen5'}]"
8916,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java,"@@ -72,6 +84,28 @@
 
         private final int[] argumentIndex;
 
+        /**
+         * key: server(invoker) address
+         * value: count of requests accept by certain server
+         */
+        private Map<String, Long> serverRequestCountMap = new HashMap<>();","[{'comment': 'Change to ConcurrentHashMap to prevent concurrent problem', 'commenter': 'AlbumenJ'}, {'comment': 'I have resolved this problem. ', 'commenter': 'laddcn'}]"
8916,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java,"@@ -111,13 +149,49 @@ private String toKey(Object[] args) {
         }
 
         private Invoker<T> selectForKey(long hash) {
+            ++totalRequestCount;
             Map.Entry<Long, Invoker<T>> entry = virtualInvokers.ceilingEntry(hash);
             if (entry == null) {
                 entry = virtualInvokers.firstEntry();
             }
+            String serverAddress = entry.getValue().getUrl().getAddress();
+            double overloadThread = ((double) totalRequestCount / (double) serverCount) * overloadRatioAllowed;
+
+            /**
+             * Find a valid server node:
+             * 1. Not have accept request yet
+             * or
+             * 2. Not have overloaded (request count already accept < thread (average request count * overloadRatioAllowed ))
+             */
+            while (serverRequestCountMap.containsKey(serverAddress)
+                    && serverRequestCountMap.get(serverAddress) >= overloadThread) {
+                /**
+                 * If server node is not valid, get next node
+                 */
+                entry = virtualInvokers.higherEntry(entry.getKey());
+                if(entry == null){
+                    entry = virtualInvokers.firstEntry();
+                }
+                serverAddress = entry.getValue().getUrl().getAddress();
+            }
+
+            if (!serverRequestCountMap.containsKey(serverAddress)) {
+                //
+                serverRequestCountMap.put(serverAddress, 1L);
+            } else {
+                serverRequestCountMap.put(serverAddress, serverRequestCountMap.get(entry.getValue().getUrl().getAddress()) + 1L);","[{'comment': 'Use ActomicLong.increase to prevent concurrent problem', 'commenter': 'AlbumenJ'}, {'comment': 'I have resolved this problem. ', 'commenter': 'laddcn'}]"
8916,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java,"@@ -111,13 +149,49 @@ private String toKey(Object[] args) {
         }
 
         private Invoker<T> selectForKey(long hash) {
+            ++totalRequestCount;","[{'comment': 'change to AtomicInteger to prevent concurrent problem?', 'commenter': 'changfubai'}, {'comment': 'Thank you for review. I have resolved this problem yet.', 'commenter': 'laddcn'}]"
8916,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java,"@@ -111,13 +149,49 @@ private String toKey(Object[] args) {
         }
 
         private Invoker<T> selectForKey(long hash) {
+            ++totalRequestCount;
             Map.Entry<Long, Invoker<T>> entry = virtualInvokers.ceilingEntry(hash);
             if (entry == null) {
                 entry = virtualInvokers.firstEntry();
             }
+            String serverAddress = entry.getValue().getUrl().getAddress();
+            double overloadThread = ((double) totalRequestCount / (double) serverCount) * overloadRatioAllowed;
+
+            /**
+             * Find a valid server node:
+             * 1. Not have accept request yet
+             * or
+             * 2. Not have overloaded (request count already accept < thread (average request count * overloadRatioAllowed ))
+             */
+            while (serverRequestCountMap.containsKey(serverAddress)
+                    && serverRequestCountMap.get(serverAddress) >= overloadThread) {
+                /**
+                 * If server node is not valid, get next node
+                 */
+                entry = virtualInvokers.higherEntry(entry.getKey());
+                if(entry == null){
+                    entry = virtualInvokers.firstEntry();","[{'comment': 'why not invoke method `getNextInvokerNode`?', 'commenter': 'changfubai'}, {'comment': 'This problem is also resolved.', 'commenter': 'laddcn'}]"
8967,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/adaptive/AdaptiveFilter.java,"@@ -0,0 +1,37 @@
+package org.apache.dubbo.rpc.cluster.adaptive;
+
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.rpc.*;
+import org.apache.dubbo.rpc.cluster.loadbalance.P2CLoadBalance;
+
+import java.util.function.Supplier;
+
+@Activate(group = CommonConstants.CONSUMER)
+public class AdaptiveFilter implements Filter, BaseFilter.Listener {
+    private static final Supplier<Long> clock = System::nanoTime;
+
+    @Override
+    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
+        try {","[{'comment': 'unused try catch', 'commenter': 'guohao'}]"
8967,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/adaptive/AdaptiveFilter.java,"@@ -0,0 +1,37 @@
+package org.apache.dubbo.rpc.cluster.adaptive;
+
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.rpc.*;
+import org.apache.dubbo.rpc.cluster.loadbalance.P2CLoadBalance;
+
+import java.util.function.Supplier;
+
+@Activate(group = CommonConstants.CONSUMER)
+public class AdaptiveFilter implements Filter, BaseFilter.Listener {
+    private static final Supplier<Long> clock = System::nanoTime;
+
+    @Override
+    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
+        try {
+            Result result = invoker.invoke(invocation);
+            return result;
+        } catch (Exception e) {
+            throw e;
+        }
+
+    }
+
+    @Override
+    public void onResponse(Result appResponse, Invoker<?> invoker, Invocation invocation) {
+        String remain = appResponse.getAttachment(""remain"");","[{'comment': 'try use constant instead of literal', 'commenter': 'guohao'}]"
8967,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/adaptive/AdaptiveFilter.java,"@@ -0,0 +1,37 @@
+package org.apache.dubbo.rpc.cluster.adaptive;
+
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.rpc.*;
+import org.apache.dubbo.rpc.cluster.loadbalance.P2CLoadBalance;
+
+import java.util.function.Supplier;
+
+@Activate(group = CommonConstants.CONSUMER)
+public class AdaptiveFilter implements Filter, BaseFilter.Listener {
+    private static final Supplier<Long> clock = System::nanoTime;
+
+    @Override
+    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
+        try {
+            Result result = invoker.invoke(invocation);
+            return result;
+        } catch (Exception e) {
+            throw e;
+        }
+
+    }
+
+    @Override
+    public void onResponse(Result appResponse, Invoker<?> invoker, Invocation invocation) {
+        String remain = appResponse.getAttachment(""remain"");
+        String limit = appResponse.getAttachment(""limit"");
+        long pickTime = (Long)invocation.get(""pickTime"");
+        P2CLoadBalance.updateNodes(Integer.parseInt(remain),invocation.getMethodName(),invoker.getUrl().getBackupAddress(),clock.get() - pickTime);","[{'comment': 'use SPI or pass reference here to reduce static code', 'commenter': 'guohao'}]"
8967,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/adaptive/Node.java,"@@ -0,0 +1,39 @@
+package org.apache.dubbo.rpc.cluster.adaptive;
+
+import org.apache.dubbo.rpc.Invoker;
+
+public class Node {
+    private volatile int remain;
+    private Invoker invoker;
+    private String address;
+
+    public Node(Invoker invoker){
+        this();
+        this.invoker = invoker;
+        this.address = invoker.getUrl().getBackupAddress();","[{'comment': 'why use backup address?', 'commenter': 'guohao'}]"
8967,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/P2CLoadBalance.java,"@@ -0,0 +1,101 @@
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.LoadBalance;
+import org.apache.dubbo.rpc.cluster.adaptive.Node;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+
+public class P2CLoadBalance implements LoadBalance {
+    private static final ConcurrentHashMap<String, List<Node>> method2Nodes = new ConcurrentHashMap<>(32);
+    private static final Supplier<Long> clock = System::nanoTime;
+    private final ReentrantLock lock = new ReentrantLock();
+
+    @Override
+    public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
+        //update method2Nodes
+        updatemethod2Nodes(invokers,invocation);
+        //prepick
+        Node[] prepick = prepick(invocation);
+        //pick
+        Invoker pick = pick(prepick);
+        //set pickTime
+        invocation.put(""pickTime"",clock.get());
+        return pick;
+    }
+
+    private <T> void updatemethod2Nodes(List<Invoker<T>> invokers,Invocation invocation){
+        //todo 注册中心的健康检查机制
+        String methodName = invocation.getMethodName();
+        if (method2Nodes.containsKey(methodName))return;","[{'comment': 'brace', 'commenter': 'guohao'}]"
8967,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/P2CLoadBalance.java,"@@ -0,0 +1,101 @@
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.LoadBalance;
+import org.apache.dubbo.rpc.cluster.adaptive.Node;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+
+public class P2CLoadBalance implements LoadBalance {
+    private static final ConcurrentHashMap<String, List<Node>> method2Nodes = new ConcurrentHashMap<>(32);
+    private static final Supplier<Long> clock = System::nanoTime;
+    private final ReentrantLock lock = new ReentrantLock();
+
+    @Override
+    public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
+        //update method2Nodes
+        updatemethod2Nodes(invokers,invocation);
+        //prepick
+        Node[] prepick = prepick(invocation);
+        //pick
+        Invoker pick = pick(prepick);
+        //set pickTime
+        invocation.put(""pickTime"",clock.get());
+        return pick;
+    }
+
+    private <T> void updatemethod2Nodes(List<Invoker<T>> invokers,Invocation invocation){
+        //todo 注册中心的健康检查机制
+        String methodName = invocation.getMethodName();
+        if (method2Nodes.containsKey(methodName))return;
+        try{
+            lock.lock();
+            method2Nodes.computeIfAbsent(methodName,k-> new ArrayList<>());","[{'comment': 'will it be better to use `set` for lookup ?', 'commenter': 'guohao'}]"
8967,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AdaptiveFilter.java,"@@ -0,0 +1,70 @@
+package org.apache.dubbo.rpc.filter;
+
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.rpc.*;
+import org.apache.dubbo.rpc.filter.limiter.AbstractLimiter;
+import org.apache.dubbo.rpc.filter.limiter.Limiter;
+import org.apache.dubbo.rpc.filter.limiter.SimpleLimiter;
+
+import java.util.Optional;
+import java.util.Properties;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Supplier;
+
+/**
+ * 服务端过滤器
+ * 可选接口
+ * 此类可以修改实现，不可以移动类或者修改包名
+ * 用户可以在服务端拦截请求和响应,捕获 rpc 调用时产生、服务端返回的已知异常。
+ */
+@Activate(group = CommonConstants.PROVIDER)
+public class AdaptiveFilter implements Filter, BaseFilter.Listener {
+    private static final ConcurrentHashMap<String, Limiter> name2limiter = new ConcurrentHashMap<>();","[{'comment': 'Is it accessary to use static?', 'commenter': 'guohao'}, {'comment': 'In this case, the name2limiter maps a method name to a limiter. Method names, however, may conflict with others. For example, interface1 has a method named ""methodA"", interface2 has another method named ""methodA"" as well, and then, the name2limiter will return the same limiter for both methods. This is not acceptable.', 'commenter': 'justxuewei'}]"
8967,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/limiter/AbstractLimiter.java,"@@ -0,0 +1,51 @@
+package org.apache.dubbo.rpc.filter.limiter;
+
+import org.apache.dubbo.rpc.filter.limit.Limit;
+import org.apache.dubbo.rpc.filter.limit.VegasLimit;
+
+import java.util.Optional;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Supplier;
+
+public abstract class AbstractLimiter implements Limiter{
+    private static final Supplier<Long> clock = System::nanoTime;
+    protected Limit limitAlgorithm;
+    protected AtomicInteger inflight;
+
+    public AbstractLimiter(){
+        this.limitAlgorithm = new VegasLimit();","[{'comment': 'Why use VegasLimit as default limit algorithm for the AbstractLimiter?', 'commenter': 'justxuewei'}]"
9001,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -791,13 +791,13 @@ public synchronized void destroy() {
             unRegisterShutdownHook();
             unregisterServiceInstance();
             unexportMetadataService();
-            if (asyncMetadataFuture != null) {
-                asyncMetadataFuture.cancel(true);
-            }
 
             executeShutdownCallbacks();
 
             applicationModel.destroy();
+            if (asyncMetadataFuture != null) {
+                asyncMetadataFuture.cancel(true);
+            }
 ","[{'comment': 'Metadata refresh future should be canceled after unregister service instance, which should be called before `applicationModel.destroy()`.', 'commenter': 'AlbumenJ'}, {'comment': 'pls review again.', 'commenter': 'zrlw'}]"
9002,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -709,7 +709,9 @@ private void registerServiceInstance() {
             // scheduled task for updating Metadata and ServiceInstance
             asyncMetadataFuture = executorRepository.nextScheduledExecutor().scheduleAtFixedRate(() -> {
                 InMemoryWritableMetadataService localMetadataService = (InMemoryWritableMetadataService) WritableMetadataService.getDefaultExtension(applicationModel);
-                localMetadataService.blockUntilUpdated();
+                if (!applicationModel.getDeployer().isStopping()) {","[{'comment': 'pls check both stopping and stopped state', 'commenter': 'AlbumenJ'}, {'comment': 'done, thanks', 'commenter': 'wangchengming666'}]"
9003,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -924,8 +924,21 @@ private void destroyMetadataReports() {
     private void destroyDynamicConfigurations() {
         // TODO only destroy DynamicConfiguration of this application
         // DynamicConfiguration may be cached somewhere, and maybe used during destroy
-        // destroy them may cause some troubles, so just clear instances cache
-        // ExtensionLoader.resetExtensionLoader(DynamicConfigurationFactory.class);
+        // destroy them may cause some troubles,
+        // but let them go also cause troubles such as configCenter connection leak.
+        if (environment.getDynamicConfiguration().isPresent() &&
+            environment.getDynamicConfiguration().get() instanceof CompositeDynamicConfiguration) {","[{'comment': 'I think you can simplify this `if`by using the `filter(...)` method of Optional.\r\n\r\nI suggest to change it to\r\n```Java\r\nvar optionalOfTypeCompositeDynamicConfiguration = environment.getDynamicConfiguration()\r\n.filter(item -> item instanceof CompositeDynamicConfiguration);\r\n\r\nif (optionalOfTypeCompositeDynamicConfiguration.isPresent()) {\r\n    var compositeDynamicConfiguration = optionalOfTypeCompositeDynamicConfiguration.get();\r\n    // rest of the logic\r\n}\r\n\r\n```', 'commenter': 'DiegoKrupitza'}, {'comment': 'done', 'commenter': 'zrlw'}]"
9003,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java,"@@ -224,7 +224,7 @@ public void onDestroy() {
         }
 
         if (environment != null) {
-            environment.destroy();
+            // just set null here, destroy environment at DefaultApplicationDeployer destroyDynamicConfigurations().","[{'comment': 'deployer的destroy行为在这行之前，为了保证 environment 被销毁这里不能注释掉（兼容不使用 deployer 的场景）', 'commenter': 'AlbumenJ'}, {'comment': 'pls review again.', 'commenter': 'zrlw'}]"
9003,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -924,8 +924,21 @@ private void destroyMetadataReports() {
     private void destroyDynamicConfigurations() {
         // TODO only destroy DynamicConfiguration of this application
         // DynamicConfiguration may be cached somewhere, and maybe used during destroy
-        // destroy them may cause some troubles, so just clear instances cache
-        // ExtensionLoader.resetExtensionLoader(DynamicConfigurationFactory.class);
+        // destroy them may cause some troubles,
+        // but let them go also cause troubles such as configCenter connection leak.
+        Optional<DynamicConfiguration> opt = environment.getDynamicConfiguration()
+                .filter(v -> v instanceof CompositeDynamicConfiguration);
+        if (opt.isPresent()) {
+            CompositeDynamicConfiguration compositeDynamicConfiguration = (CompositeDynamicConfiguration) opt.get();
+            compositeDynamicConfiguration.getInnerConfigurations().forEach(dynamicConfiguration -> {
+                try {
+                    dynamicConfiguration.close();","[{'comment': '默认动态配置中心是不支持销毁的\r\n```java\r\norg.apache.dubbo.common.config.configcenter.DynamicConfiguration\r\n    @Override\r\n    default void close() throws Exception {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n```', 'commenter': 'AlbumenJ'}, {'comment': 'pls review again.', 'commenter': 'zrlw'}, {'comment': '`DynamicConfiguration` is destroyed in `org.apache.dubbo.common.config.Environment`, on need to release here ? \r\n```\r\n    @Override\r\n    public void destroy() throws IllegalStateException {\r\n        initialized.set(false);\r\n        systemConfiguration = null;\r\n        propertiesConfiguration = null;\r\n        environmentConfiguration = null;\r\n        externalConfiguration = null;\r\n        appExternalConfiguration = null;\r\n        appConfiguration = null;\r\n        globalConfiguration = null;\r\n        globalConfigurationMaps = null;\r\n        defaultDynamicGlobalConfiguration = null;\r\n        if (defaultDynamicConfiguration != null) {\r\n            try {\r\n                defaultDynamicConfiguration.close();\r\n            } catch (Exception e) {\r\n                logger.warn(""close dynamic configuration failed: "" + e.getMessage(), e);\r\n            }\r\n            defaultDynamicConfiguration = null;\r\n        }\r\n    }\r\n```', 'commenter': 'kylixs'}, {'comment': 'destroyDynamicConfigurations() wrote:\r\n```\r\n// DynamicConfiguration may be cached somewhere, and maybe used during destroy\r\n```\r\nit might be better that close it by DefaultApplicationDeployer which created it.', 'commenter': 'zrlw'}, {'comment': 'The `compositeDynamicConfiguration` only used in environment and it is already destroyed in it.  No need to release it again. You can debug it, the `close()` method will be called when application is stopping.\r\n\r\n```java\r\nprivate void startConfigCenter() {\r\n  ...\r\n  if (CollectionUtils.isNotEmpty(configCenters)) {\r\n      CompositeDynamicConfiguration compositeDynamicConfiguration = new CompositeDynamicConfiguration();\r\n      for (ConfigCenterConfig configCenter : configCenters) {\r\n          // Pass config from ConfigCenterBean to environment\r\n          environment.updateExternalConfigMap(configCenter.getExternalConfiguration());\r\n          environment.updateAppExternalConfigMap(configCenter.getAppExternalConfiguration());\r\n\r\n          // Fetch config from remote config center\r\n          compositeDynamicConfiguration.addConfiguration(prepareEnvironment(configCenter));\r\n      }\r\n      environment.setDynamicConfiguration(compositeDynamicConfiguration);\r\n  }\r\n  ...\r\n}\r\n```', 'commenter': 'kylixs'}, {'comment': '> destroyDynamicConfigurations() wrote:\r\n> \r\n> ```\r\n> // DynamicConfiguration may be cached somewhere, and maybe used during destroy\r\n> ```\r\n\r\nIt seems a history problem before support multi application instances, the XxxDynamicConfiguration instance is cache in ExtensionLoader at that moment, but now is independent instance for each application. So destroy it in `Environment` is ok. ', 'commenter': 'kylixs'}]"
9003,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -924,8 +924,21 @@ private void destroyMetadataReports() {
     private void destroyDynamicConfigurations() {
         // TODO only destroy DynamicConfiguration of this application
         // DynamicConfiguration may be cached somewhere, and maybe used during destroy
-        // destroy them may cause some troubles, so just clear instances cache
-        // ExtensionLoader.resetExtensionLoader(DynamicConfigurationFactory.class);
+        // destroy them may cause some troubles,
+        // but let them go also cause troubles such as configCenter connection leak.
+        Optional<DynamicConfiguration> opt = environment.getDynamicConfiguration()
+                .filter(v -> v instanceof CompositeDynamicConfiguration);
+        if (opt.isPresent()) {
+            CompositeDynamicConfiguration compositeDynamicConfiguration = (CompositeDynamicConfiguration) opt.get();
+            compositeDynamicConfiguration.getInnerConfigurations().forEach(dynamicConfiguration -> {
+                try {
+                    dynamicConfiguration.close();
+                } catch (Throwable ignored) {
+                    logger.warn(ignored.getMessage(), ignored);
+                }
+            });
+        }
+        environment.destroy();","[{'comment': 'environment 是由 applicationModel 持有的，不应该由 deployer 去销毁', 'commenter': 'AlbumenJ'}]"
9003,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -927,8 +930,18 @@ private void destroyMetadataReports() {
     private void destroyDynamicConfigurations() {
         // TODO only destroy DynamicConfiguration of this application
         // DynamicConfiguration may be cached somewhere, and maybe used during destroy
-        // destroy them may cause some troubles, so just clear instances cache
-        // ExtensionLoader.resetExtensionLoader(DynamicConfigurationFactory.class);
+        // destroy them may cause some troubles,
+        // but let them go also cause troubles such as configCenter connection leak.
+        if (compositeDynamicConfiguration != null) {
+            compositeDynamicConfiguration.getInnerConfigurations().forEach(dynamicConfiguration -> {
+                try {
+                    dynamicConfiguration.close();
+                } catch (Throwable ignored) {
+                    logger.warn(ignored.getMessage(), ignored);","[{'comment': 'ignore UnsupportedOperationException here', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'zrlw'}]"
9015,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -906,19 +907,6 @@ private void destroyProtocols() {
         }
     }
 
-    private void destroyServiceDiscoveries() {
-        RegistryManager.getInstance(applicationModel).getServiceDiscoveries().forEach(serviceDiscovery -> {
-            try {
-                serviceDiscovery.destroy();
-            } catch (Throwable ignored) {
-                logger.warn(ignored.getMessage(), ignored);
-            }
-        });
-        if (logger.isDebugEnabled()) {
-            logger.debug(getIdentifier() + ""'s all ServiceDiscoveries have been destroyed."");
-        }
-    }
-","[{'comment': 'cloud you pls desc why you remove these code', 'commenter': 'AlbumenJ'}, {'comment': 'destroyRegistries() destroy all registries including service discoveries:\r\n```\r\n    private void destroyRegistries() {\r\n        RegistryManager.getInstance(applicationModel).destroyAll(); \r\n    }\r\n```\r\nRegistryManager#destroyAll()\r\n```\r\n    public void destroyAll() {\r\n       ...\r\n        try {\r\n            for (Registry registry : getRegistries()) {\r\n                try {\r\n                    registry.destroy(); <== destroy registry including service discovery.\r\n                } catch (Throwable e) {\r\n                    LOGGER.warn(e.getMessage(), e);\r\n                }\r\n            }\r\n            registries.clear(); <== clear registries map whch includes service discoveries.\r\n       ...\r\n    }\r\n```', 'commenter': 'zrlw'}]"
9015,dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java,"@@ -113,7 +114,7 @@ public boolean isAvailable() {
     public void destroy() {
         super.destroy();
         try {
-            zkClient.close();
+            zkClient.close(getUrl().getParameter(APPLICATION_KEY, """"));","[{'comment': 'see https://github.com/apache/dubbo/pull/9033#discussion_r728694883\r\nThe zk client is shared between ZookeeperRegistry , ZookeeperDynamicConfiguration and ZookeeperMetadataReport, if close it in one place, the other reference use the zk client may throw already destroyed exeception.\r\nThe safe way is close zk clients in ApplicationDeployer.postDestroy() after release all zk components before onStopped(), some thing like: zookeeperTransporter.closeClientsOfApplication(application)', 'commenter': 'kylixs'}, {'comment': ""calling zkClient.close(application) does not mean the client is to be closed, \r\nif zookeeperTransporter == null then close it.\r\notherwise check whether it's still used by any application by zookeeperTransporter.close(zkClient, application) and only close it when no application use it anymore. "", 'commenter': 'zrlw'}, {'comment': 'The zk client is shared between ZookeeperRegistry , ZookeeperDynamicConfiguration and ZookeeperMetadataReport **in same application** !  \r\nzk client not just shared between applications but also shared in multi components within application, so say: \r\n> The safe way is close zk clients in ApplicationDeployer.postDestroy() after release all zk components before onStopped(), some thing like: zookeeperTransporter.closeClientsOfApplication(application)', 'commenter': 'kylixs'}]"
9015,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/zookeeper/ZookeeperClient.java,"@@ -55,7 +55,9 @@
 
     boolean isConnected();
 
-    void close();
+    void close(String application);","[{'comment': '`zkclient.close(applicationName)` is ugly and opaque,  we should close zk clients of application from `ZookeeperTransporter` who keep zk client and application associations.', 'commenter': 'kylixs'}, {'comment': ""i don't think so. if you want share zkclient among all applications, then zkclient close method should know which application is going to be destroyed.\r\none application is going to be destroyed does not mean the global ZookeeperTransporter that shared between all applications is also going to be destroyed."", 'commenter': 'zrlw'}, {'comment': 'The ZK client is a low-level component, it should not care who is using it, the upper level management matters should not be placed on it !', 'commenter': 'kylixs'}, {'comment': ""i see. this PR is based from 3.0 which hasn't ApplicationDeployer.postDestroy method yet, i‘ll try to add it in your way."", 'commenter': 'zrlw'}, {'comment': 'zookeeper client codes are reverted, now zkClient is closed by ZookeeperTransporter(zkClient, application) which might be called by ZookeeperRegistry.destroy() or ZookeeperDynamicConfiguration.doClose().\r\nAdding ApplicationDeployer.postDestroy method is much more than what i was expecting, so i abandon to do it and wait for your fix. \r\npls review again.\r\n@kylixs ', 'commenter': 'zrlw'}]"
9015,dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java,"@@ -113,7 +117,7 @@ public boolean isAvailable() {
     public void destroy() {
         super.destroy();
         try {
-            zkClient.close();
+            zookeeperTransporter.close(zkClient, getUrl().getParameter(APPLICATION_KEY, """"));","[{'comment': 'Do not close the zkClient here, if it is closed here, other components using this zkClient later will report an error.  Close them in ApplicationDeployer destroy/postDestroy  before `onStopped`.', 'commenter': 'kylixs'}, {'comment': 'zookeeperTransporter will check that it is should be closed or not.\r\nby the way, this codes could be modified after ApplicationDeployer destroy/postDestroy is merged into 3.0 branch.', 'commenter': 'zrlw'}, {'comment': 'zookeeperTransporter only check zkclient and application relationship, but not consider multi references of single zk client  in same application.', 'commenter': 'kylixs'}, {'comment': 'i tried to close zkClient at DefaultApplicationDeployer.destroy() but it cause many ut failed.\r\n', 'commenter': 'zrlw'}]"
9015,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/zookeeper/AbstractZookeeperTransporter.java,"@@ -54,25 +58,51 @@ public ZookeeperClient connect(URL url) {
         ZookeeperClient zookeeperClient;
         // address format: {[username:password@]address}
         List<String> addressList = getURLBackupAddress(url);
-        // The field define the zookeeper server , including protocol, host, port, username, password
-        if ((zookeeperClient = fetchAndUpdateZookeeperClientCache(addressList)) != null && zookeeperClient.isConnected()) {
-            logger.info(""find valid zookeeper client from the cache for address: "" + url);
-            return zookeeperClient;
-        }
+        String application = url.getParameter(APPLICATION_KEY, """");
         // avoid creating too many connections， so add lock
-        synchronized (zookeeperClientMap) {
-            if ((zookeeperClient = fetchAndUpdateZookeeperClientCache(addressList)) != null && zookeeperClient.isConnected()) {
+        synchronized (zookeeperApplicationMap) {
+            if ((zookeeperClient = fetchAndUpdateZookeeperClientCache(addressList, application)) != null &&
+                    zookeeperClient.isConnected()) {
                 logger.info(""find valid zookeeper client from the cache for address: "" + url);
                 return zookeeperClient;
             }
 
             zookeeperClient = createZookeeperClient(url);
+            Set<String> applications = new HashSet<>();
+            applications.add(application);
+            zookeeperApplicationMap.put(zookeeperClient, applications);            
             logger.info(""No valid zookeeper client found from cache, therefore create a new client for url. "" + url);
             writeToClientMap(addressList, zookeeperClient);
         }
         return zookeeperClient;
     }
 
+    /**
+     * close zookeeper connection if no application use it.
+     * 
+     * @param zookeeperClient
+     * @param application the application which is destroying. 
+     */
+    @Override
+    public void close(ZookeeperClient zookeeperClient, String application) {
+        synchronized (zookeeperApplicationMap) {
+            Set<String> applications = zookeeperApplicationMap.get(zookeeperClient);
+            if (applications == null) {
+                logger.warn(""No applications associated with the zookeeper client: "" + zookeeperClient.getUrl());
+                zookeeperClient.close();
+                return;
+            }
+
+            if (application == null) {
+                application = """";
+            }
+            applications.remove(application);
+            if (application.isEmpty()) {
+                zookeeperClient.close();","[{'comment': 'Remove  zookeeperClient from zookeeperApplicationMap after close it.', 'commenter': 'kylixs'}, {'comment': 'done', 'commenter': 'zrlw'}]"
9015,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -512,22 +513,23 @@ private void initMetadataService() {
      * @return
      */
     @Override
+    @SuppressWarnings(""rawtypes"")
     public synchronized Future start() {
-        CompletableFuture startFuture = getStartFuture();
-
-        // maybe call start again after add new module, check if any new module
-        boolean hasPendingModule = hasPendingModule();
-
         if (isStarting()) {
-            // currently is starting, maybe both start by module and application
-            // if has new modules, start them
-            if (hasPendingModule) {
-                startModules();
-            }
+            // currently is starting.
+            // maybe first start ModuleDeployer then start DubboBootstrap,
+            // so initialize() and doStart() should support idempotent calling 
+            // because we don't know whether they have been called or not.
+            // see DubboBootstrapMultiInstanceTest#testBothStartByModuleAndByApplication
+            initialize();
+            doStart();","[{'comment': 'Why do you need to change the start processing, and what problem is it to solve? There are problems with some details. If the application is starting, doStart() cannot be entered twice. Application start processing should split pr separately\r\n', 'commenter': 'kylixs'}, {'comment': 'i debuged DubboBootstrapMultiInstanceTest#testBothStartByModuleAndByApplication and found providerBootstrap.start() just calls startModules() because the state of default application deployer is set to starting by moduleDeployer1.start().get() calling onStarting(), so initiailzie() and doStart() in DefaultApplicationDeployer# are not called anymore and it might cause problems.\r\n', 'commenter': 'zrlw'}, {'comment': 'NO, It is expected.  Re-start an application when it is starting will not start again, just start new modules.', 'commenter': 'kylixs'}, {'comment': 'you are right, i see DefaultModuleDeployer calls  applicationDeployer.initialize() and prepareApplicationInstance.\r\nbut we might remove the condition of prepareApplicationInstance execution in DefaultModuleDeployer as DefaultModuleDeployer#hasExportedServices() already includes exported check for all modules.\r\n', 'commenter': 'zrlw'}, {'comment': 'i changed the codes about starting new modules based on your code, pls review again.', 'commenter': 'zrlw'}]"
9015,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -625,18 +634,27 @@ public void prepareApplicationInstance() {
         }
     }
 
+    /**
+     * start and await internal module deploy finished if internal module deployer is not running.
+     */
+    @SuppressWarnings(""rawtypes"")
     private void prepareInternalModule() {
         // export MetadataService
         exportMetadataService();
         // start internal module
         ModuleDeployer internalModuleDeployer = applicationModel.getInternalModule().getDeployer();
-        if (!internalModuleDeployer.isStarted()) {
-            Future future = internalModuleDeployer.start();
-            // wait for internal module start finished
+        if (internalModuleDeployer.isRunning()) {
+            return;","[{'comment': 'Should wait for internal module finish start, cannot return here.', 'commenter': 'kylixs'}, {'comment': 'i changed it to return if state is started or failed or stopping or stopped, it might be better than only checking started condition.', 'commenter': 'zrlw'}, {'comment': 'We MUST ensure to start internal module first, that will make start steps more clear.', 'commenter': 'kylixs'}, {'comment': ""let's say, if the module has problem and could not be started, should we repeat trying start it again and again?"", 'commenter': 'zrlw'}]"
9015,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -625,18 +634,27 @@ public void prepareApplicationInstance() {
         }
     }
 
+    /**
+     * start and await internal module deploy finished if internal module deployer is not running.
+     */
+    @SuppressWarnings(""rawtypes"")
     private void prepareInternalModule() {
         // export MetadataService
         exportMetadataService();
         // start internal module
         ModuleDeployer internalModuleDeployer = applicationModel.getInternalModule().getDeployer();
-        if (!internalModuleDeployer.isStarted()) {
-            Future future = internalModuleDeployer.start();
-            // wait for internal module start finished
+        if (internalModuleDeployer.isRunning()) {
+            return;
+        }
+        // await internal module deploy finished
+        Future internalFuture = internalModuleDeployer.start();
+        while (isStarting() && !internalModuleDeployer.isRunning()) {","[{'comment': 'The condition `!internalModuleDeployer.isRunning()` is always `false` after start module \r\n unless it fails or stops.', 'commenter': 'kylixs'}]"
9015,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -554,63 +556,70 @@ private boolean hasPendingModule() {
         return found;
     }
 
-    private CompletableFuture getStartFuture() {
-        if (startFuture == null) {
-            synchronized (this) {
-                if (startFuture == null) {
-                    startFuture = new CompletableFuture();
-                }
-            }
-        }
-        return startFuture;
-    }
-
-
+    @SuppressWarnings(""rawtypes"")
     private void doStart() {
-        startModules();
+        List<Future> futures = startModules();
 
         // prepare application instance
         prepareApplicationInstance();
 
+        // keep starting modules while state is starting
         executorRepository.getSharedExecutor().submit(() -> {
-            while (true) {
-                // notify on each module started
-                synchronized (startedLock) {
-                    try {
-                        startedLock.wait(500);
-                    } catch (InterruptedException e) {
-                        // ignore
-                    }
-                }
-
-                // if has new module, do start again
-                if (hasPendingModule()) {
-                    startModules();
-                    continue;
-                }
-
-                DeployState newState = checkState();
-                if (!(newState == DeployState.STARTING || newState == DeployState.PENDING)) {
-                    // start finished or error
-                    break;
-                }
-            }
+            awaitDeployFinished(futures);
         });
     }
 
-    private void startModules() {
+    @SuppressWarnings(""rawtypes"")
+    private List<Future> startModules() {
         // copy current modules, ignore new module during starting
         List<ModuleModel> moduleModels = new ArrayList<>(applicationModel.getModuleModels());
+        List<Future> futures = new ArrayList<>(moduleModels.size());
         for (ModuleModel moduleModel : moduleModels) {
             // export services in module
             if (moduleModel.getDeployer().isPending()) {
-                moduleModel.getDeployer().start();
+                futures.add(moduleModel.getDeployer().start());
+            }
+        }
+        return futures;
+    }
+
+    /**
+     * keep starting modules while state is starting. 
+     * 
+     * @param futures
+     */
+    @SuppressWarnings(""rawtypes"")
+    private void awaitDeployFinished(List<Future> futures) {
+        while (isStarting()) {
+            if (futures.isEmpty()) {
+                try {
+                    Thread.sleep(DEFAULT_TIMEOUT);","[{'comment': 'Monitoring the `startedLock` is to process the module started event in time. And after modifying it to monitor the future, it may be processed delayed.\r\n', 'commenter': 'kylixs'}, {'comment': 'awaitDeployFinished() provide same function as startedLock, and it provide more functions such as starting new added modules automatically until the state is changed to started or failed or stopping or stopped.', 'commenter': 'zrlw'}, {'comment': 'The `Thread.sleep(DEFAULT_TIMEOUT);`  will not be interrupted when any module is started, it will block until sleep time is up.', 'commenter': 'kylixs'}, {'comment': 'i changed new modules startup codes samed with your codes, so awaitDeployFinished is not matter now.', 'commenter': 'zrlw'}]"
9032,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java,"@@ -63,6 +59,10 @@ public static AbstractClientStream newClientStream(URL url, boolean unary) {
         final CancellationContext cancellationContext = stream.getCancellationContext();
         // for client cancel,send rst frame to server
         cancellationContext.addListener(context -> {
+            if (LOGGER.isErrorEnabled()) {
+                Throwable throwable = cancellationContext.getCancellationCause();
+                LOGGER.error(""Cancel by local throwable="", throwable);
+            }","[{'comment': 'warn may be better?', 'commenter': 'guohao'}]"
9032,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/CancelableStreamObserver.java,"@@ -20,16 +20,25 @@
 import org.apache.dubbo.common.stream.StreamObserver;
 import org.apache.dubbo.rpc.CancellationContext;
 
+import java.util.concurrent.atomic.AtomicBoolean;
+
 public abstract class CancelableStreamObserver<T> implements StreamObserver<T> {
 
     private CancellationContext cancellationContext;
 
-    public CancellationContext getCancellationContext() {
-        return cancellationContext;
+    private final AtomicBoolean contextSet = new AtomicBoolean(false);
+
+    public CancelableStreamObserver() {
     }
 
-    public void setCancellationContext(CancellationContext cancellationContext) {
-        this.cancellationContext = cancellationContext;
+    public CancelableStreamObserver(CancellationContext cancellationContext) {
+        setCancellationContext(cancellationContext);
+    }
+
+    public final void setCancellationContext(CancellationContext cancellationContext) {
+        if (contextSet.compareAndSet(false, true)) {
+            this.cancellationContext = cancellationContext;
+        }","[{'comment': 'Shoulde add any Exception or log ?', 'commenter': 'guohao'}]"
9032,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientStream.java,"@@ -29,27 +30,48 @@ protected ClientStream(URL url) {
 
     @Override
     protected StreamObserver<Object> createStreamObserver() {
-        ClientStreamObserver clientStreamObserver = new ClientStreamObserver() {
-            boolean metaSent;
+        return new ClientStreamObserverImpl(getCancellationContext());
+    }
 
-            @Override
-            public void onNext(Object data) {
-                if (!metaSent) {
-                    metaSent = true;
-                    final Metadata metadata = createRequestMeta((RpcInvocation) getRequest().getData());
-                    getTransportSubscriber().onMetadata(metadata, false);
-                }
-                final byte[] bytes = encodeRequest(data);
-                getTransportSubscriber().onData(bytes, false);
+    private class ClientStreamObserverImpl extends CancelableStreamObserver<Object> implements ClientStreamObserver<Object> {
+
+        private boolean metaSent;
+
+        public ClientStreamObserverImpl(CancellationContext cancellationContext) {
+            super(cancellationContext);
+            this.metaSent = false;
+        }
+
+        @Override
+        public void onNext(Object data) {
+            if (!metaSent) {
+                metaSent = true;
+                final Metadata metadata = createRequestMeta((RpcInvocation) getRequest().getData());
+                getTransportSubscriber().onMetadata(metadata, false);
             }
+            final byte[] bytes = encodeRequest(data);
+            getTransportSubscriber().onData(bytes, false);
+        }
 
-            @Override
-            public void onError(Throwable throwable) {
-                transportError(throwable);
+        @Override
+        public void onError(Throwable throwable) {
+            transportError(throwable);
+        }
+
+        @Override
+        public void onCompleted() {
+            getTransportSubscriber().onComplete();
+        }
+
+        @Override
+        public void setCompression(String compression) {
+            if (metaSent) {
+                cancel(new IllegalStateException(""Metadata already has been sent,can not set compression""));","[{'comment': 'why cancel here ?', 'commenter': 'guohao'}, {'comment': 'If the metadata carrying compressed metadata is sent to the peer end, the peer end cannot know the new compressed encoding', 'commenter': 'EarthChen'}]"
9032,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientStreamObserver.java,"@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri;
+
+import org.apache.dubbo.common.stream.StreamObserver;
+
+public interface ClientStreamObserver<T> extends StreamObserver<T> {
+
+    /**
+     * Requests the peer to produce {@code count} more messages to be delivered to the 'inbound'
+     * {@link StreamObserver}.
+     *
+     * @param count more messages
+     */
+    default void request(int count) {
+        // todo support
+    }
+
+    /**
+     * Swaps to manual flow control where no message will be delivered to {@link
+     * StreamObserver#onNext(Object)} unless it is {@link #request request()}ed.
+     */","[{'comment': '`requeset` and `autoRequest` shoulde be commited in anthor PR', 'commenter': 'guohao'}]"
9032,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientTransportObserver.java,"@@ -56,9 +56,9 @@ public ClientTransportObserver(ChannelHandlerContext ctx, AbstractClientStream s
 
         final TripleHttp2ClientResponseHandler responseHandler = new TripleHttp2ClientResponseHandler();
         streamChannel.pipeline().addLast(responseHandler)
-                .addLast(new GrpcDataDecoder(Integer.MAX_VALUE))
-                .addLast(new TripleClientInboundHandler());
-        streamChannel.attr(TripleUtil.CLIENT_STREAM_KEY).set(stream);
+            .addLast(new GrpcDataDecoder(Integer.MAX_VALUE, true))
+            .addLast(new TripleClientInboundHandler());
+        TripleUtil.setClientStream(streamChannel, stream);","[{'comment': 'Try reduce usage of `util`', 'commenter': 'guohao'}]"
9032,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ServerStreamObserver.java,"@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri;
+
+import org.apache.dubbo.common.stream.StreamObserver;
+
+public interface ServerStreamObserver<T> extends StreamObserver<T> {
+
+    /**
+     * Requests the peer to produce {@code count} more messages to be delivered to the 'inbound'
+     * {@link StreamObserver}.
+     *
+     * @param count more messages
+     */
+    default void request(int count) {","[{'comment': 'Remove', 'commenter': 'guohao'}]"
9032,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleUtil.java,"@@ -85,20 +84,64 @@ public static boolean isQuiteException(Throwable t) {
         return false;
     }
 
+    public static void setClientStream(ChannelHandlerContext ctx, AbstractClientStream stream) {
+        setClientStream(ctx.channel(), stream);","[{'comment': 'place these method to other place without `static`', 'commenter': 'guohao'}]"
9032,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryClientStream.java,"@@ -122,4 +123,26 @@ private Throwable getThrowable(Metadata metadata) {
             }
         }
     }
+
+","[{'comment': '`ClientStreamObserver` already exists , maybe another concise name will be better ?', 'commenter': 'guohao'}]"
9052,dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/jetty/JettyHttpServer.java,"@@ -49,10 +49,6 @@
     public JettyHttpServer(URL url, final HttpHandler handler) {
         super(url, handler);
         this.url = url;
-        // TODO we should leave this setting to slf4j
-        // we must disable the debug logging for production use
-        Log.setLog(new StdErrLog());","[{'comment': ""Should here set to Dubbo's logger"", 'commenter': 'AlbumenJ'}, {'comment': ""but dubbo's logger and jetty's logger don't match. should i create an adapter for them?  give me some ideas!"", 'commenter': 'huangwenkan9'}, {'comment': 'adapt it', 'commenter': 'AlbumenJ'}]"
9052,dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/jetty/JettyLoggerAdapter.java,"@@ -0,0 +1,159 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.http.jetty;
+
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.eclipse.jetty.util.log.AbstractLogger;
+import org.eclipse.jetty.util.log.Logger;
+
+/**
+ * logger adapter for jetty
+ */
+public class JettyLoggerAdapter extends AbstractLogger {
+    protected String name;
+    private final org.apache.dubbo.common.logger.Logger logger;
+
+    public JettyLoggerAdapter(){
+        this(""org.apache.dubbo.remoting.http.jetty"");
+    }
+
+    public JettyLoggerAdapter(Class<?> clazz){
+        this(clazz.getName());
+    }
+
+    public JettyLoggerAdapter(String name) {
+        this.name = name;
+        this.logger = LoggerFactory.getLogger(name);
+    }
+
+    @Override
+    protected Logger newLogger(String name) {
+        return new JettyLoggerAdapter(name);
+    }
+
+    @Override
+    public String getName() {
+        return this.name;
+    }
+
+    @Override
+    public void warn(String msg, Object... objects) {
+        if (logger.isWarnEnabled()){
+            logger.warn(this.format(msg, objects));
+        }
+    }
+
+    @Override
+    public void warn(Throwable throwable) {
+        if (logger.isWarnEnabled()){
+            logger.warn(throwable);
+        }
+    }
+
+    @Override
+    public void warn(String msg, Throwable throwable) {
+        if (logger.isWarnEnabled()){
+            logger.warn(msg, throwable);
+        }
+    }
+
+    @Override
+    public void info(String msg, Object... objects) {
+        if (logger.isInfoEnabled()){
+            logger.info(this.format(msg, objects));
+        }
+    }
+
+    @Override
+    public void info(Throwable throwable) {
+        if (logger.isInfoEnabled()){
+            logger.info(throwable);
+        }
+    }
+
+    @Override
+    public void info(String msg, Throwable throwable) {
+        if (logger.isInfoEnabled()){
+            logger.info(msg, throwable);
+        }
+    }
+
+    @Override
+    public boolean isDebugEnabled() {
+        return logger.isDebugEnabled();
+    }
+
+    @Override
+    public void setDebugEnabled(boolean enabled) {
+        logger.warn(""setDebugEnabled not implemented"");
+    }
+
+    @Override
+    public void debug(String msg, Object... objects) {
+        if (logger.isDebugEnabled()){
+            logger.debug(this.format(msg, objects));
+        }
+    }
+
+    @Override
+    public void debug(Throwable throwable) {
+        if (logger.isDebugEnabled()){
+            logger.debug(throwable);
+        }
+    }
+
+    @Override
+    public void debug(String msg, Throwable throwable) {
+        if (logger.isDebugEnabled()){
+            logger.debug(msg, throwable);
+        }
+    }
+
+    @Override
+    public void ignore(Throwable throwable) {
+        if (logger.isDebugEnabled()){
+            logger.debug(""IGNORED EXCEPTION "", throwable);
+        }
+    }
+
+    private String format(String msg, Object... args) {
+        msg = String.valueOf(msg);
+        String braces = ""{}"";
+        StringBuilder builder = new StringBuilder();
+        int start = 0;
+        Object[] var6 = args;
+        int var7 = args.length;
+
+        for(int var8 = 0; var8 < var7; ++var8) {","[{'comment': 'Enhance the readability of variables.\r\n', 'commenter': 'CrazyHZM'}]"
9052,dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/jetty/JettyLoggerAdapter.java,"@@ -0,0 +1,159 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.http.jetty;
+
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.eclipse.jetty.util.log.AbstractLogger;
+import org.eclipse.jetty.util.log.Logger;
+
+/**
+ * logger adapter for jetty
+ */
+public class JettyLoggerAdapter extends AbstractLogger {
+    protected String name;
+    private final org.apache.dubbo.common.logger.Logger logger;
+
+    public JettyLoggerAdapter(){
+        this(""org.apache.dubbo.remoting.http.jetty"");
+    }
+
+    public JettyLoggerAdapter(Class<?> clazz){
+        this(clazz.getName());
+    }
+
+    public JettyLoggerAdapter(String name) {
+        this.name = name;
+        this.logger = LoggerFactory.getLogger(name);
+    }
+
+    @Override
+    protected Logger newLogger(String name) {
+        return new JettyLoggerAdapter(name);
+    }
+
+    @Override
+    public String getName() {
+        return this.name;
+    }
+
+    @Override
+    public void warn(String msg, Object... objects) {
+        if (logger.isWarnEnabled()){
+            logger.warn(this.format(msg, objects));
+        }
+    }
+
+    @Override
+    public void warn(Throwable throwable) {
+        if (logger.isWarnEnabled()){
+            logger.warn(throwable);
+        }
+    }
+
+    @Override
+    public void warn(String msg, Throwable throwable) {
+        if (logger.isWarnEnabled()){
+            logger.warn(msg, throwable);
+        }
+    }
+
+    @Override
+    public void info(String msg, Object... objects) {
+        if (logger.isInfoEnabled()){
+            logger.info(this.format(msg, objects));
+        }
+    }
+
+    @Override
+    public void info(Throwable throwable) {
+        if (logger.isInfoEnabled()){
+            logger.info(throwable);
+        }
+    }
+
+    @Override
+    public void info(String msg, Throwable throwable) {
+        if (logger.isInfoEnabled()){
+            logger.info(msg, throwable);
+        }
+    }
+
+    @Override
+    public boolean isDebugEnabled() {
+        return logger.isDebugEnabled();
+    }
+
+    @Override
+    public void setDebugEnabled(boolean enabled) {
+        logger.warn(""setDebugEnabled not implemented"");
+    }
+
+    @Override
+    public void debug(String msg, Object... objects) {
+        if (logger.isDebugEnabled()){
+            logger.debug(this.format(msg, objects));
+        }
+    }
+
+    @Override
+    public void debug(Throwable throwable) {
+        if (logger.isDebugEnabled()){
+            logger.debug(throwable);
+        }
+    }
+
+    @Override
+    public void debug(String msg, Throwable throwable) {
+        if (logger.isDebugEnabled()){
+            logger.debug(msg, throwable);
+        }
+    }
+
+    @Override
+    public void ignore(Throwable throwable) {
+        if (logger.isDebugEnabled()){
+            logger.debug(""IGNORED EXCEPTION "", throwable);
+        }
+    }
+
+    private String format(String msg, Object... args) {","[{'comment': 'Provide unit test\r\n', 'commenter': 'CrazyHZM'}, {'comment': 'how to test private method using mockito', 'commenter': 'huangwenkan9'}]"
9052,dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/jetty/JettyLoggerAdapter.java,"@@ -0,0 +1,159 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.http.jetty;
+
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.eclipse.jetty.util.log.AbstractLogger;
+import org.eclipse.jetty.util.log.Logger;
+
+/**
+ * logger adapter for jetty
+ */
+public class JettyLoggerAdapter extends AbstractLogger {","[{'comment': 'Provide unit test\r\n', 'commenter': 'CrazyHZM'}]"
9052,dubbo-remoting/dubbo-remoting-http/src/test/resources/log4j.xml,"@@ -0,0 +1,41 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the ""License""); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<!DOCTYPE log4j:configuration SYSTEM ""log4j.dtd"">
+<log4j:configuration xmlns:log4j=""http://jakarta.apache.org/log4j/"">
+    <!-- ===================================================================== -->
+    <!-- 以下是appender的定义 -->
+    <!-- ===================================================================== -->","[{'comment': 'please change to English description', 'commenter': 'CrazyHZM'}]"
9057,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientTransportObserver.java,"@@ -34,11 +34,13 @@
 public class ClientTransportObserver implements TransportObserver {
     private final AsciiString SCHEME;
     private final ChannelHandlerContext ctx;
-    private final Http2StreamChannel streamChannel;
+    private volatile Http2StreamChannel streamChannel;
     private final ChannelPromise promise;
-    private boolean headerSent = false;
-    private boolean endStreamSent = false;
-    private boolean resetSent = false;
+//    private boolean headerSent = false;","[{'comment': 'Remove unused fileds', 'commenter': 'guohao'}]"
9057,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractServerStream.java,"@@ -134,7 +137,7 @@ protected RpcInvocation buildInvocation(Metadata metadata) {
         ClassLoader tccl = Thread.currentThread().getContextClassLoader();
         try {
             if (getProviderModel() != null) {
-                ClassLoadUtil.switchContextLoader(getProviderModel().getClassLoader());
+                ClassLoadUtil.switchContextLoader(getProviderModel().getServiceInterfaceClass().getClassLoader());","[{'comment': 'What is the difference bwteen `model.getClassLoader()` and service interface classloader ?', 'commenter': 'guohao'}]"
9057,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ServerTransportObserver.java,"@@ -28,34 +28,32 @@
 import io.netty.handler.codec.http2.DefaultHttp2ResetFrame;
 import io.netty.handler.codec.http2.Http2Error;
 
-import static io.netty.handler.codec.http.HttpResponseStatus.OK;
-
 public class ServerTransportObserver implements TransportObserver {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(ServerTransportObserver.class);
 
     private final ChannelHandlerContext ctx;
-    private boolean headerSent = false;
-    private boolean resetSent = false;
+//    private boolean headerSent = false;","[{'comment': 'Remove these unused code', 'commenter': 'guohao'}]"
9057,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java,"@@ -194,4 +211,23 @@ protected void cancelByLocal(Throwable throwable) {
     }
 
 
+    protected abstract class AbstractClientTransport extends AbstractTransportObserver {
+
+        @Override
+        public void onData(byte[] data, boolean endStream) {
+            execute(() -> {
+                final Object resp = deserializeResponse(data);
+                getStreamSubscriber().onNext(resp);
+            });
+        }
+
+//        protected abstract","[{'comment': 'Fix', 'commenter': 'guohao'}]"
9057,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java,"@@ -69,11 +72,40 @@ public static AbstractClientStream newClientStream(URL url, boolean unary) {
         return stream;
     }
 
+    protected RpcInvocation getRpcInvocation() {
+        return (RpcInvocation) getRequest().getData();
+    }
+
+    protected void startCall() {
+        try {
+            doOnStartCall();
+        } catch (Throwable throwable) {
+            asStreamObserver().onError(throwable);","[{'comment': 'Client shoulde not send error to server if exception occurred in sending request ', 'commenter': 'guohao'}]"
9057,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryClientStream.java,"@@ -40,10 +38,16 @@ protected UnaryClientStream(URL url) {
     }
 
     @Override
-    protected StreamObserver<Object> createStreamObserver() {
-        return new UnaryClientStreamObserverImpl();
+    protected void doOnStartCall() {
+        asStreamObserver().onNext(getRpcInvocation());
+        asStreamObserver().onCompleted();
     }
 
+//    @Override","[{'comment': 'Remove these', 'commenter': 'guohao'}]"
9057,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java,"@@ -18,34 +18,58 @@
 package org.apache.dubbo.rpc.protocol.tri;
 
 import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.config.ConfigurationUtils;
 import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.stream.StreamObserver;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.remoting.Constants;
 import org.apache.dubbo.remoting.api.Connection;
+import org.apache.dubbo.remoting.exchange.Request;
 import org.apache.dubbo.remoting.exchange.support.DefaultFuture2;
 import org.apache.dubbo.rpc.CancellationContext;
 import org.apache.dubbo.rpc.RpcInvocation;
 import org.apache.dubbo.rpc.model.ConsumerModel;
+import org.apache.dubbo.rpc.model.MethodDescriptor;
+import org.apache.dubbo.rpc.model.ServiceModel;
 import org.apache.dubbo.triple.TripleWrapper;
 
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaderValues;
+import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http2.Http2Error;
+import io.netty.handler.codec.http2.Http2Headers;
+import io.netty.util.AsciiString;
 
+import java.util.Arrays;
+import java.util.List;
 import java.util.Map;
-import java.util.concurrent.Executor;
 import java.util.concurrent.RejectedExecutionException;
 
+import static org.apache.dubbo.rpc.Constants.COMPRESSOR_KEY;
+import static org.apache.dubbo.rpc.protocol.tri.Compressor.DEFAULT_COMPRESSOR;
+
 
 public abstract class AbstractClientStream extends AbstractStream implements Stream {
+
+    private final AsciiString scheme;
     private ConsumerModel consumerModel;
     private Connection connection;
+    private RpcInvocation rpcInvocation;
+    private long requestId;
 
     protected AbstractClientStream(URL url) {
         super(url);
+        this.scheme = getSchemeFromUrl(url);
+        // for client cancel,send rst frame to server
+        this.getCancellationContext().addListener(context -> {
+            Throwable throwable = this.getCancellationContext().getCancellationCause();
+            if (LOGGER.isWarnEnabled()) {
+                LOGGER.warn(""Cancel by local throwable is "", throwable);","[{'comment': '```suggestion\r\n                LOGGER.warn(""Triple request to {service+method} was canceled by local exception "", throwable);\r\n```', 'commenter': 'guohao'}]"
9057,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java,"@@ -55,38 +79,107 @@ public static ClientStream stream(URL url) {
         return new ClientStream(url);
     }
 
-    public static AbstractClientStream newClientStream(URL url, boolean unary) {
-        AbstractClientStream stream = unary ? unary(url) : stream(url);
-        final CancellationContext cancellationContext = stream.getCancellationContext();
-        // for client cancel,send rst frame to server
-        cancellationContext.addListener(context -> {
-            if (LOGGER.isWarnEnabled()) {
-                Throwable throwable = cancellationContext.getCancellationCause();
-                LOGGER.warn(""Cancel by local throwable is "", throwable);
-            }
-            stream.asTransportObserver().onReset(Http2Error.CANCEL);
-        });
+    public static AbstractClientStream newClientStream(Request req, Connection connection) {
+        final RpcInvocation inv = (RpcInvocation) req.getData();
+        final URL url = inv.getInvoker().getUrl();
+        ConsumerModel consumerModel = inv.getServiceModel() != null ? (ConsumerModel) inv.getServiceModel() : (ConsumerModel) url.getServiceModel();
+        MethodDescriptor methodDescriptor = getTriMethodDescriptor(consumerModel, inv);
+        ClassLoadUtil.switchContextLoader(consumerModel.getClassLoader());
+        AbstractClientStream stream = methodDescriptor.isUnary() ? unary(url) : stream(url);
+        Compressor compressor = getCompressor(url, consumerModel);
+        stream.request(req)
+            .service(consumerModel)
+            .connection(connection)
+            .serialize((String) inv.getObjectAttachment(Constants.SERIALIZATION_KEY))
+            .method(methodDescriptor)
+            .setCompressor(compressor)
+        ;","[{'comment': 'fix format', 'commenter': 'guohao'}]"
9057,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java,"@@ -55,38 +79,107 @@ public static ClientStream stream(URL url) {
         return new ClientStream(url);
     }
 
-    public static AbstractClientStream newClientStream(URL url, boolean unary) {
-        AbstractClientStream stream = unary ? unary(url) : stream(url);
-        final CancellationContext cancellationContext = stream.getCancellationContext();
-        // for client cancel,send rst frame to server
-        cancellationContext.addListener(context -> {
-            if (LOGGER.isWarnEnabled()) {
-                Throwable throwable = cancellationContext.getCancellationCause();
-                LOGGER.warn(""Cancel by local throwable is "", throwable);
-            }
-            stream.asTransportObserver().onReset(Http2Error.CANCEL);
-        });
+    public static AbstractClientStream newClientStream(Request req, Connection connection) {
+        final RpcInvocation inv = (RpcInvocation) req.getData();
+        final URL url = inv.getInvoker().getUrl();
+        ConsumerModel consumerModel = inv.getServiceModel() != null ? (ConsumerModel) inv.getServiceModel() : (ConsumerModel) url.getServiceModel();
+        MethodDescriptor methodDescriptor = getTriMethodDescriptor(consumerModel, inv);
+        ClassLoadUtil.switchContextLoader(consumerModel.getClassLoader());
+        AbstractClientStream stream = methodDescriptor.isUnary() ? unary(url) : stream(url);
+        Compressor compressor = getCompressor(url, consumerModel);
+        stream.request(req)
+            .service(consumerModel)
+            .connection(connection)
+            .serialize((String) inv.getObjectAttachment(Constants.SERIALIZATION_KEY))
+            .method(methodDescriptor)
+            .setCompressor(compressor)
+        ;
         return stream;
     }
 
-    public AbstractClientStream service(ConsumerModel model) {
-        this.consumerModel = model;
-        return this;
+    protected void startCall() {
+        try {
+            doOnStartCall();
+        } catch (Throwable throwable) {
+            cancel(throwable);
+            DefaultFuture2.getFuture(getRequestId()).cancel();
+        }
     }
 
-    public ConsumerModel getConsumerModel() {
-        return consumerModel;
+    protected abstract void doOnStartCall();
+
+    @Override
+    protected StreamObserver<Object> createStreamObserver() {
+        return new ClientStreamObserverImpl(getCancellationContext());
     }
 
-    public AbstractClientStream connection(Connection connection) {
-        this.connection = connection;
-        return this;
+    protected class ClientStreamObserverImpl extends CancelableStreamObserver<Object> implements ClientStreamObserver<Object> {
+
+        public ClientStreamObserverImpl(CancellationContext cancellationContext) {
+            super(cancellationContext);
+        }
+
+        @Override
+        public void onNext(Object data) {
+            if (getState().allowSendMeta()) {
+                getState().setMetaSend();
+                final Metadata metadata = createRequestMeta(getRpcInvocation());
+                getTransportSubscriber().onMetadata(metadata, false);
+            }
+            if (getState().allowSendData()) {
+                final byte[] bytes = encodeRequest(data);
+                getTransportSubscriber().onData(bytes, false);
+            }
+        }
+
+        /**
+         * Handle all exceptions in the request process, other procedures directly throw
+         * <p>
+         * other procedures is {@link ClientStreamObserver#onNext(Object)} and {@link ClientStreamObserver#onCompleted()}
+         */
+        @Override
+        public void onError(Throwable throwable) {
+            if (getState().allowSendEndStream()) {
+                getState().setEndStreamSend();
+                GrpcStatus status = GrpcStatus.getStatus(throwable);
+                transportError(status, null, getState().allowSendMeta());
+            } else {
+                if (LOGGER.isErrorEnabled()) {
+                    LOGGER.error(""client request error "", throwable);","[{'comment': 'Add service and method descriprtion to log', 'commenter': 'guohao'}]"
9057,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientTransportObserver.java,"@@ -20,62 +20,35 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
-import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http2.DefaultHttp2DataFrame;
 import io.netty.handler.codec.http2.DefaultHttp2Headers;
 import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;
 import io.netty.handler.codec.http2.DefaultHttp2ResetFrame;
 import io.netty.handler.codec.http2.Http2Error;
 import io.netty.handler.codec.http2.Http2Headers;
 import io.netty.handler.codec.http2.Http2StreamChannel;
-import io.netty.handler.codec.http2.Http2StreamChannelBootstrap;
-import io.netty.util.AsciiString;
 
 public class ClientTransportObserver implements TransportObserver {
-    private final AsciiString SCHEME;
     private final ChannelHandlerContext ctx;
-    private final Http2StreamChannel streamChannel;
     private final ChannelPromise promise;
-    private boolean headerSent = false;
-    private boolean endStreamSent = false;
-    private boolean resetSent = false;
+    private volatile Http2StreamChannel streamChannel;
 
+    public void setStreamChannel(Http2StreamChannel streamChannel) {
+        this.streamChannel = streamChannel;
+    }
 
-    public ClientTransportObserver(ChannelHandlerContext ctx, AbstractClientStream stream, ChannelPromise promise) {
+    public ClientTransportObserver(ChannelHandlerContext ctx, ChannelPromise promise) {
         this.ctx = ctx;
         this.promise = promise;
-        Boolean ssl = ctx.channel().attr(TripleConstant.SSL_ATTRIBUTE_KEY).get();
-        if (ssl != null && ssl) {
-            SCHEME = TripleConstant.HTTPS_SCHEME;
-        } else {
-            SCHEME = TripleConstant.HTTP_SCHEME;
-        }
-
-        final Http2StreamChannelBootstrap streamChannelBootstrap = new Http2StreamChannelBootstrap(ctx.channel());
-        streamChannel = streamChannelBootstrap.open().syncUninterruptibly().getNow();
-
-        final TripleHttp2ClientResponseHandler responseHandler = new TripleHttp2ClientResponseHandler();
-        streamChannel.pipeline().addLast(responseHandler)
-            .addLast(new GrpcDataDecoder(Integer.MAX_VALUE, true))
-            .addLast(new TripleClientInboundHandler());
-        streamChannel.attr(TripleConstant.CLIENT_STREAM_KEY).set(stream);
     }
 
     @Override
     public void onMetadata(Metadata metadata, boolean endStream) {
-        if (headerSent) {
-            return;
+        while (streamChannel == null) {
+            // wait channel initialized","[{'comment': 'streamChannel may be null if `open` failed, and will be blocked here forever', 'commenter': 'guohao'}, {'comment': 'How about using async send after channel created', 'commenter': 'guohao'}, {'comment': 'Change the next PR to send using a queue', 'commenter': 'EarthChen'}]"
9057,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientTransportObserver.java,"@@ -20,62 +20,51 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
-import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http2.DefaultHttp2DataFrame;
 import io.netty.handler.codec.http2.DefaultHttp2Headers;
 import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;
 import io.netty.handler.codec.http2.DefaultHttp2ResetFrame;
 import io.netty.handler.codec.http2.Http2Error;
 import io.netty.handler.codec.http2.Http2Headers;
 import io.netty.handler.codec.http2.Http2StreamChannel;
-import io.netty.handler.codec.http2.Http2StreamChannelBootstrap;
-import io.netty.util.AsciiString;
 
 public class ClientTransportObserver implements TransportObserver {
-    private final AsciiString SCHEME;
     private final ChannelHandlerContext ctx;
-    private final Http2StreamChannel streamChannel;
     private final ChannelPromise promise;
-    private boolean headerSent = false;
-    private boolean endStreamSent = false;
-    private boolean resetSent = false;
+    private Http2StreamChannel streamChannel;
 
+    private volatile int initialized = DEFAULT;
 
-    public ClientTransportObserver(ChannelHandlerContext ctx, AbstractClientStream stream, ChannelPromise promise) {
-        this.ctx = ctx;
-        this.promise = promise;
-        Boolean ssl = ctx.channel().attr(TripleConstant.SSL_ATTRIBUTE_KEY).get();
-        if (ssl != null && ssl) {
-            SCHEME = TripleConstant.HTTPS_SCHEME;
-        } else {
-            SCHEME = TripleConstant.HTTP_SCHEME;
-        }
 
-        final Http2StreamChannelBootstrap streamChannelBootstrap = new Http2StreamChannelBootstrap(ctx.channel());
-        streamChannel = streamChannelBootstrap.open().syncUninterruptibly().getNow();
+    private static final int DEFAULT = 0;
+    private static final int SUCCESS = 1;
+    private static final int FAIL = 2;
+
+    public void setStreamChannel(Http2StreamChannel streamChannel) {
+        this.streamChannel = streamChannel;
+        initialized = SUCCESS;
+    }
+
+    public void initializedFailed() {
+        initialized = FAIL;
+    }
 
-        final TripleHttp2ClientResponseHandler responseHandler = new TripleHttp2ClientResponseHandler();
-        streamChannel.pipeline().addLast(responseHandler)
-            .addLast(new GrpcDataDecoder(Integer.MAX_VALUE, true))
-            .addLast(new TripleClientInboundHandler());
-        streamChannel.attr(TripleConstant.CLIENT_STREAM_KEY).set(stream);
+    public ClientTransportObserver(ChannelHandlerContext ctx, ChannelPromise promise) {
+        this.ctx = ctx;
+        this.promise = promise;
     }
 
     @Override
     public void onMetadata(Metadata metadata, boolean endStream) {
-        if (headerSent) {
-            return;
+        while (initialized == DEFAULT) {
+            // wait channel initialized
         }
-        if (resetSent) {
+        // ","[{'comment': 'Exception or log is need', 'commenter': 'guohao'}]"
9057,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientRequestHandler.java,"@@ -63,85 +46,29 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
 
     private void writeRequest(ChannelHandlerContext ctx, final Request req, final ChannelPromise promise) {
         DefaultFuture2.addTimeoutListener(req.getId(), ctx::close);
-        final RpcInvocation inv = (RpcInvocation) req.getData();
-        final URL url = inv.getInvoker().getUrl();
-        ConsumerModel consumerModel = inv.getServiceModel() != null ? (ConsumerModel) inv.getServiceModel() : (ConsumerModel) url.getServiceModel();
-
-        MethodDescriptor methodDescriptor = getTriMethodDescriptor(consumerModel, inv);
-
-        ClassLoadUtil.switchContextLoader(consumerModel.getClassLoader());
-        final AbstractClientStream stream = AbstractClientStream.newClientStream(url, methodDescriptor.isUnary());
-
-        String ssl = url.getParameter(CommonConstants.SSL_ENABLED_KEY);
-        if (StringUtils.isNotEmpty(ssl)) {
-            ctx.channel().attr(TripleConstant.SSL_ATTRIBUTE_KEY).set(Boolean.parseBoolean(ssl));
-        }
-        // Compressor can not be set by dynamic config
-        String compressorStr = ConfigurationUtils
-            .getCachedDynamicProperty(inv.getModuleModel(), COMPRESSOR_KEY, DEFAULT_COMPRESSOR);
-
-        Compressor compressor = Compressor.getCompressor(url.getOrDefaultFrameworkModel(), compressorStr);
-        if (compressor != null) {
-            stream.setCompressor(compressor);
-        }
-
-        stream.service(consumerModel)
-            .connection(Connection.getConnectionFromChannel(ctx.channel()))
-            .method(methodDescriptor)
-            .methodName(methodDescriptor.getMethodName())
-            .request(req)
-            .serialize((String) inv.getObjectAttachment(Constants.SERIALIZATION_KEY))
-            .subscribe(new ClientTransportObserver(ctx, stream, promise));
-
-        if (methodDescriptor.isUnary()) {
-            stream.asStreamObserver().onNext(inv);
-            stream.asStreamObserver().onCompleted();
-        } else {
-            Response response = new Response(req.getId(), req.getVersion());
-            AppResponse result;
-            // the stream method params is fixed
-            if (methodDescriptor.getRpcType() == MethodDescriptor.RpcType.BIDIRECTIONAL_STREAM
-                || methodDescriptor.getRpcType() == MethodDescriptor.RpcType.CLIENT_STREAM) {
-                StreamObserver<Object> obServer = (StreamObserver<Object>) inv.getArguments()[0];
-                obServer = attachCancelContext(obServer, stream.getCancellationContext());
-                stream.subscribe(obServer);
-                result = new AppResponse(stream.asStreamObserver());
-            } else {
-                StreamObserver<Object> obServer = (StreamObserver<Object>) inv.getArguments()[1];
-                obServer = attachCancelContext(obServer, stream.getCancellationContext());
-                stream.subscribe(obServer);
-                result = new AppResponse();
-                stream.asStreamObserver().onNext(inv.getArguments()[0]);
-                stream.asStreamObserver().onCompleted();
-            }
-            response.setResult(result);
-            DefaultFuture2.received(stream.getConnection(), response);
-        }
-    }
-
-    /**
-     * Get the tri protocol special MethodDescriptor
-     */
-    private MethodDescriptor getTriMethodDescriptor(ConsumerModel consumerModel, RpcInvocation inv) {
-        List<MethodDescriptor> methodDescriptors = consumerModel.getServiceModel().getMethods(inv.getMethodName());
-        if (CollectionUtils.isEmpty(methodDescriptors)) {
-            throw new IllegalStateException(""methodDescriptors must not be null method="" + inv.getMethodName());
-        }
-        for (MethodDescriptor methodDescriptor : methodDescriptors) {
-            if (Arrays.equals(inv.getParameterTypes(), methodDescriptor.getRealParameterClasses())) {
-                return methodDescriptor;
-            }
-        }
-        throw new IllegalStateException(""methodDescriptors must not be null method="" + inv.getMethodName());
-    }
-
-
-    public <T> StreamObserver<T> attachCancelContext(StreamObserver<T> observer, CancellationContext context) {
-        if (observer instanceof CancelableStreamObserver) {
-            CancelableStreamObserver<T> streamObserver = ((CancelableStreamObserver<T>) observer);
-            streamObserver.setCancellationContext(context);
-            return streamObserver;
-        }
-        return observer;
+        Connection connection = Connection.getConnectionFromChannel(ctx.channel());
+        final AbstractClientStream stream = AbstractClientStream.newClientStream(req, connection);
+        final ClientTransportObserver clientTransportObserver = new ClientTransportObserver(ctx, promise);
+        final Http2StreamChannelBootstrap streamChannelBootstrap = new Http2StreamChannelBootstrap(ctx.channel());
+        streamChannelBootstrap.open()
+            .addListener(future -> {
+                if (future.isSuccess()) {
+                    final Http2StreamChannel curChannel = (Http2StreamChannel) future.get();","[{'comment': 'promise.trySuccess', 'commenter': 'guohao'}]"
9084,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java,"@@ -420,10 +420,10 @@ public Metadata getTrailers() {
         }
 
         @Override
-        public void onReset(Http2Error http2Error) {
+        public void onCancel(GrpcStatus status) {
             if (getState().allowSendReset()) {
                 getState().setResetSend();","[{'comment': 'Remove setResetSend() method ,This state is already set in transport', 'commenter': 'EarthChen'}]"
9084,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ClientTransportObserver.java,"@@ -68,8 +68,8 @@ protected void doOnData(byte[] data, boolean endStream) {
     }
 
     @Override
-    protected void doOnReset(Http2Error http2Error) {
-        streamChannel.writeAndFlush(new DefaultHttp2ResetFrame(http2Error))
+    protected void doOnCancel(GrpcStatus status) {","[{'comment': 'Can `GrpcStatus` be removed if we always send cancel?', 'commenter': 'EarthChen'}]"
9084,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ServerTransportObserver.java,"@@ -81,8 +81,8 @@ protected void doOnData(byte[] data, boolean endStream) {
     }
 
     @Override
-    protected void doOnReset(Http2Error http2Error) {
-        ctx.writeAndFlush(new DefaultHttp2ResetFrame(http2Error))
+    protected void doOnCancel(GrpcStatus status) {
+        ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.CANCEL))","[{'comment': 'like pre.', 'commenter': 'EarthChen'}]"
9084,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ServerStream.java,"@@ -198,9 +205,7 @@ public void onComplete() {
             if (getMethodDescriptor().getRpcType() == MethodDescriptor.RpcType.SERVER_STREAM) {","[{'comment': 'Replace `getMethodDescriptor().isServerStream()`', 'commenter': 'EarthChen'}]"
9084,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryInboundTransportObserver.java,"@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri;
+
+abstract class UnaryInboundTransportObserver extends InboundTransportObserver implements TransportObserver {
+    protected static final String DUPLICATED_DATA = ""Duplicated data"";
+
+    private byte[] data;
+
+    public byte[] getData() {
+        return data;
+    }
+
+    protected abstract void onError(GrpcStatus status);
+
+    public void onCancel(GrpcStatus status) {","[{'comment': 'Is cancel necessary here?', 'commenter': 'EarthChen'}]"
9084,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractStream.java,"@@ -266,7 +265,7 @@ public void subscribe(AbstractChannelTransportObserver observer) {
 
     @Override
     public TransportObserver asTransportObserver() {","[{'comment': 'Change the method name is better?', 'commenter': 'EarthChen'}]"
9084,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java,"@@ -70,7 +70,7 @@ protected AbstractClientStream(URL url) {
                     + getConsumerModel().getServiceName() + ""#"" + getMethodName() +
                     "" was canceled by local exception "", throwable);
             }
-            this.asTransportObserver().onReset(getHttp2Error(throwable));
+            this.asTransportObserver().onCancel(getHttp2Error(throwable));","[{'comment': 'Should call `OutboundTransportObserver`', 'commenter': 'EarthChen'}]"
9084,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/AbstractClientStream.java,"@@ -70,7 +70,7 @@ protected AbstractClientStream(URL url) {
                     + getConsumerModel().getServiceName() + ""#"" + getMethodName() +
                     "" was canceled by local exception "", throwable);
             }
-            this.asTransportObserver().onCancel(getHttp2Error(throwable));
+            this.inboundTransportObserver().onCancel(getHttp2Error(throwable));","[{'comment': 'When the client initiatively cancels here it should send RST', 'commenter': 'EarthChen'}]"
9122,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2FrameServerHandler.java,"@@ -83,8 +83,10 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
     public void onResetRead(ChannelHandlerContext ctx, Http2ResetFrame frame) {
         final AbstractServerStream serverStream = ctx.channel().attr(TripleConstant.SERVER_STREAM_KEY).get();
         LOGGER.warn(""Triple Server received remote reset errorCode="" + frame.errorCode());
-        serverStream.cancelByRemote();
-        ctx.close();
+        if (serverStream != null) {
+            serverStream.cancelByRemote();
+            ctx.close();","[{'comment': '`ctx.close` should be called even if the stream is `null`', 'commenter': 'guohao'}, {'comment': '@guohao done, thanks.', 'commenter': 'wangchengming666'}]"
9135,dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/status/ThreadPoolStatusCheckerTest.java,"@@ -0,0 +1,53 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.dubbo.status;
+
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.status.Status;
+import org.apache.dubbo.common.store.DataStore;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+/**
+ * {@link ThreadPoolStatusChecker}
+ */
+public class ThreadPoolStatusCheckerTest {
+
+    @Test
+    public void test() {
+        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();
+        ExecutorService executorService1 = Executors.newFixedThreadPool(1);
+        ExecutorService executorService2 = Executors.newFixedThreadPool(10);","[{'comment': 'shutdown executors after test', 'commenter': 'AlbumenJ'}]"
9140,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryServerStream.java,"@@ -85,10 +85,12 @@ public void invoke() {
                 outboundTransportObserver().onMetadata(metadata, false);
                 final byte[] data = encodeResponse(response.getValue());
                 if (data == null) {
+                    transportError(GrpcStatus.fromCode(GrpcStatus.Code.INTERNAL)","[{'comment': 'When method `encodeResponse`  returns null, it may be that encode threw an exception that was already handled in the method', 'commenter': 'EarthChen'}]"
9140,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleClientRequestHandler.java,"@@ -51,9 +51,14 @@ private void writeRequest(ChannelHandlerContext ctx, final Request req, final Ch
         streamChannelBootstrap.open()
             .addListener(future -> {
                 if (future.isSuccess()) {
-                    final Http2StreamChannel curChannel = (Http2StreamChannel) future.get();
+                    final Http2StreamChannel channel = (Http2StreamChannel) future.get();","[{'comment': 'Why move ？', 'commenter': 'EarthChen'}, {'comment': 'To seperate channel and stream layer', 'commenter': 'guohao'}]"
9145,dubbo-config/dubbo-config-api/pom.xml,"@@ -68,6 +68,11 @@
             <version>${project.parent.version}</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-rpc-triple</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>","[{'comment': 'What is the purpose of adding this dependency? Can it be changed to the test scope?', 'commenter': 'AlbumenJ'}]"
9187,dubbo-common/src/main/java/org/apache/dubbo/common/extension/Inject.java,"@@ -22,8 +22,20 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
+import static org.apache.dubbo.common.extension.Inject.InjectType.ByName;
+
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE, ElementType.METHOD})
-public @interface DisableInject {
+public @interface Inject {
+    // whether enable injection or not
+    boolean enable() default true;
+
+    // inject type default by name injection
+    InjectType type() default ByName;
+
+    enum InjectType{
+        ByName,
+        ByType
+    }","[{'comment': 'What is purpose of changing this annotation', 'commenter': 'AlbumenJ'}, {'comment': ""Hi AlbumenJ, DisableInject isn't generic, this Inject annotation is more generic,  dependency component injection is a common use case, disable inject is just a specific case, then ExtensionLoader can't support inject by type,  so refactor it, that's all!"", 'commenter': 'warmonipa'}, {'comment': 'I am worried about this change may break some implementation work fine before commit.', 'commenter': 'AlbumenJ'}, {'comment': 'First of all all ut&it pass, then this pr is compatible with legacy code, \r\nI think break implementation do not exist!', 'commenter': 'warmonipa'}]"
9187,dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java,"@@ -707,35 +708,58 @@ private T injectExtension(T instance) {
                 if (!isSetter(method)) {
                     continue;
                 }
-                /**
-                 * Check {@link DisableInject} to see if we need auto injection for this property
+
+                /*
+                 * Check {@link DisableInject} to see if we need autowire injection for this property
                  */
                 if (method.getAnnotation(DisableInject.class) != null) {
                     continue;
                 }
+
                 Class<?> pt = method.getParameterTypes()[0];
                 if (ReflectUtils.isPrimitives(pt)) {
                     continue;
                 }
 
-                try {
-                    String property = getSetterProperty(method);
-                    Object object = objectFactory.getExtension(pt, property);
-                    if (object != null) {
-                        method.invoke(instance, object);
+                /*
+                 * Check {@link Inject} to see if we need auto-injection for this property
+                 * {@link Inject#enable} == false will skip inject property phase
+                 * {@link Inject#InjectType#ByName} default inject by name
+                 */
+                String property = getSetterProperty(method);
+                Inject inject = method.getAnnotation(Inject.class);","[{'comment': 'It seems strange to do injection if miss annotation, although doing so is compatible with the previous injection logic. Thus, the `@Inject` annotation is not general, comparing to `@Autowire` of Spring \r\n\r\n', 'commenter': 'kylixs'}, {'comment': 'Print log msg if missing `@Inject` annotation or using `@DisableInject` annotation ?', 'commenter': 'kylixs'}, {'comment': 'About injection if miss annotation, this is default injection logic, i have not changed that.\r\nDefault injection behavior is injection by name with setter property name.\r\nRight now Injection logic code is compatible with legacy code, as well as it supports injection by type features.', 'commenter': 'warmonipa'}]"
9284,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java,"@@ -182,6 +182,9 @@ public Result invoke(Invocation inv) throws RpcException {
     }
 
     private void prepareInvocation(RpcInvocation inv) {
+        // fix #9283: set service context of InstanceAddressURL before other preparation.
+        url.setContext(RpcContext.getServiceContext());","[{'comment': 'URL 对象在服务间是复用的（即使不复用也会有问题）。在并发请求的时候，会出现一个 URL 只持有了一个上下文的情况，但实际上有很多个上下文同时使用了 URL 。', 'commenter': 'AlbumenJ'}, {'comment': '那么是不是LazyConnectExchangeClient这个功能要排除InstanceAddressURL类型的URL了，多个上下文复用这种类型的URL，那么在rpc之后根本没有办法从这种类型的URL获取path、protocol()和parameters了。', 'commenter': 'zrlw'}, {'comment': 'LazyConnectExchangeClient 这个后面要废掉，重新整合所有协议实现一个通用的连接管理机制', 'commenter': 'AlbumenJ'}]"
9290,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/DefaultFilterChainBuilder.java,"@@ -36,7 +40,17 @@
     public <T> Invoker<T> buildInvokerChain(final Invoker<T> originalInvoker, String key, String group) {
         Invoker<T> last = originalInvoker;
         URL url = originalInvoker.getUrl();
-        List<Filter> filters = ScopeModelUtil.getExtensionLoader(Filter.class, url.getScopeModel()).getActivateExtension(url, key, group);
+        List<ModuleModel> moduleModels = getModuleModelsFromUrl(url);
+        List<Filter> filters = new ArrayList<>();
+        if (moduleModels != null && moduleModels.size() != 0) {","[{'comment': ""If moduleModels' size is 1, directly use result to reduce memory allocation."", 'commenter': 'AlbumenJ'}]"
9290,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/DefaultFilterChainBuilder.java,"@@ -36,7 +40,17 @@
     public <T> Invoker<T> buildInvokerChain(final Invoker<T> originalInvoker, String key, String group) {
         Invoker<T> last = originalInvoker;
         URL url = originalInvoker.getUrl();
-        List<Filter> filters = ScopeModelUtil.getExtensionLoader(Filter.class, url.getScopeModel()).getActivateExtension(url, key, group);
+        List<ModuleModel> moduleModels = getModuleModelsFromUrl(url);
+        List<Filter> filters = new ArrayList<>();
+        if (moduleModels != null && moduleModels.size() != 0) {
+            for (ModuleModel moduleModel : moduleModels) {
+                List<Filter> tempFilters = ScopeModelUtil.getExtensionLoader(Filter.class, moduleModel).getActivateExtension(url, key, group);
+                filters.addAll(tempFilters);","[{'comment': 'Filters need to be sorted and de-duplicated.', 'commenter': 'AlbumenJ'}]"
9290,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/DefaultFilterChainBuilder.java,"@@ -69,4 +92,16 @@
         return last;
     }
 
+    private List<ModuleModel> getModuleModelsFromUrl(URL url) {
+        List<ModuleModel> moduleModels = null;
+        ScopeModel scopeModel = url.getScopeModel();
+        if (scopeModel instanceof ApplicationModel) {
+            moduleModels = ((ApplicationModel) scopeModel).getModuleModels();","[{'comment': 'Use `getPubModuleModels()` instead.', 'commenter': 'AlbumenJ'}]"
9329,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -241,7 +242,6 @@ public synchronized void destroy() {
             ModuleServiceRepository repository = getScopeModel().getServiceRepository();
             repository.unregisterConsumer(consumerModel);
         }
-        getScopeModel().getConfigManager().removeConfig(this);","[{'comment': 'pls desc why remove this', 'commenter': 'AlbumenJ'}, {'comment': 'The first step of the destroy method will call super.destroy, which is `ReferenceConfigBase#destroy`, and removeConfig has been executed', 'commenter': 'BurningCN'}]"
9348,dubbo-common/src/main/java/org/apache/dubbo/common/config/CompositeConfiguration.java,"@@ -21,19 +21,20 @@
 import org.apache.dubbo.common.utils.ArrayUtils;
 
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
 
 /**
  * This is an abstraction specially customized for the sequence Dubbo retrieves properties.
  */
 public class CompositeConfiguration implements Configuration {
-    private Logger logger = LoggerFactory.getLogger(CompositeConfiguration.class);
+    private final Logger logger = LoggerFactory.getLogger(CompositeConfiguration.class);
 
     /**
      * List holding all the configuration
      */
-    private List<Configuration> configList = new LinkedList<>();
+    private final List<Configuration> configList = Collections.synchronizedList(new LinkedList<>());","[{'comment': 'Use CopyOnWriteArrayList may be better. `synchronizedList` will block some read operations.', 'commenter': 'AlbumenJ'}, {'comment': '@AlbumenJ done, thanks', 'commenter': 'wangchengming666'}]"
9358,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"@@ -203,7 +204,11 @@ public void doSaveProperties(long version) {
         } catch (Throwable e) {
             savePropertiesRetryTimes.incrementAndGet();
             if (savePropertiesRetryTimes.get() >= MAX_RETRY_TIMES_SAVE_PROPERTIES) {
-                logger.warn(""Failed to save registry cache file after retrying "" + MAX_RETRY_TIMES_SAVE_PROPERTIES + "" times, cause: "" + e.getMessage(), e);
+                if (e instanceof OverlappingFileLockException) {
+                    // fix #9341, ignore OverlappingFileLockException","[{'comment': 'Adding one short info log here would be better for the users to notice what has happened.', 'commenter': 'chickenlj'}]"
9382,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java,"@@ -379,34 +382,34 @@ private String getMethodSignaturesString() {
         }
 
         public void addParameter(String key, String value) {
-            if (consumerParams != null) {
+            if (CollectionUtils.isNotEmptyMap(consumerParams)) {
                 this.consumerParams.put(key, value);
             }
         }
 
         public void addParameterIfAbsent(String key, String value) {
-            if (consumerParams != null) {
+            if (CollectionUtils.isNotEmptyMap(consumerParams)) {
                 this.consumerParams.putIfAbsent(key, value);
             }
         }
 
         public void addConsumerParams(Map<String, String> params) {
             // copy once for one service subscription
-            if (consumerParams == null) {
+            if (CollectionUtils.isEmptyMap(consumerParams)) {
                 consumerParams = new HashMap<>(params);
             }
         }
 
         public Map<String, Number> getNumbers() {
             // concurrent initialization is tolerant
-            if (numbers == null) {
+            if (CollectionUtils.isEmptyMap(numbers)) {","[{'comment': '`isEmptyMap` and `==null` do not have the same meaning here.', 'commenter': 'chickenlj'}]"
9423,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MetadataInfo.java,"@@ -315,27 +315,27 @@ public void setParams(Map<String, String> params) {
         }
 
         public String getParameter(String key) {
-            if (consumerParams != null) {
+            if (CollectionUtils.isNotEmptyMap(consumerParams)) {
                 String value = consumerParams.get(key);
-                if (value != null) {
+                if (StringUtils.isNotEmpty(value)) {
                     return value;
                 }
             }
             return params.get(key);
         }
 
         public String getMethodParameter(String method, String key, String defaultValue) {
-            if (methodParams == null) {
+            if (CollectionUtils.isNotEmptyMap(methodParams)) {","[{'comment': 'Be careful! The new code checks exactly the opposite condition.', 'commenter': 'chickenlj'}]"
9425,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java,"@@ -425,10 +428,10 @@ protected void refreshServiceDiscoveryInvoker(CountDownLatch latch) {
         }
         setListener(serviceDiscoveryInvoker, () -> {
             latch.countDown();
-            //TODO FrameworkStatusReporter
-//            FrameworkStatusReporter.reportConsumptionStatus(
-//                createConsumptionReport(consumerUrl.getServiceInterface(), consumerUrl.getVersion(), consumerUrl.getGroup(), ""app"")
-//            );
+            if (reportService.hasReporter()) {
+                reportService.reportMigrationStepStatus(","[{'comment': 'change to `reportService.reportConsumptionStatus`', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'BurningCN'}]"
9425,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java,"@@ -449,10 +452,10 @@ protected void refreshInterfaceInvoker(CountDownLatch latch) {
         }
         setListener(invoker, () -> {
             latch.countDown();
-            //TODO FrameworkStatusReporter
-//            FrameworkStatusReporter.reportConsumptionStatus(
-//                createConsumptionReport(consumerUrl.getServiceInterface(), consumerUrl.getVersion(), consumerUrl.getGroup(), ""interface"")
-//            );
+            if (reportService.hasReporter()) {
+                reportService.reportMigrationStepStatus(","[{'comment': 'change to `reportService.reportConsumptionStatus`', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'BurningCN'}]"
9451,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/merger/MergerFactory.java,"@@ -49,34 +56,51 @@ public void setScopeModel(ScopeModel scopeModel) {
             throw new IllegalArgumentException(""returnType is null"");
         }
 
-        Merger result;
-        if (returnType.isArray()) {
-            Class type = returnType.getComponentType();","[{'comment': 'What is the purpose of removing `returnType.getComponentType()`?', 'commenter': 'AlbumenJ'}, {'comment': 'one question is why the parameter type of Merger.merge() must be array? If use returnType.getComponentType() in MergerFactory, other non-array types can not exist in MergerFactory. \r\nfor example int[] and int type can not both exist in MergerFactory. \r\n', 'commenter': 'HetaoWang'}, {'comment': '> Another problem is MergerFactory caches merger by return type. But there may exist more than one merger with same return type, for example IntFindAnyMerger and IntFindFirstMerger in this pr. \r\n\r\n', 'commenter': 'HetaoWang'}]"
9454,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/UnaryClientStream.java,"@@ -106,7 +77,7 @@ public void onError(GrpcStatus status) {
             response.setErrorMessage(status.description);
             final AppResponse result = new AppResponse();
             final Metadata trailers = getTrailers() == null ? getHeaders() : getTrailers();
-            result.setException(getThrowable(trailers));
+            result.setException(getThrowableFromTrailers(trailers));","[{'comment': '`grpc-status-bin` maybe null,`status.cause` should be returned', 'commenter': 'EarthChen'}]"
9463,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/ChannelWrappedInvoker.java,"@@ -71,7 +71,9 @@ protected Result doInvoke(Invocation invocation) throws Throwable {
                 currentClient.send(inv, getUrl().getMethodParameter(invocation.getMethodName(), SENT_KEY, false));
                 return AsyncRpcResult.newDefaultAsyncResult(invocation);
             } else {
-                CompletableFuture<AppResponse> appResponseFuture = currentClient.request(inv).thenApply(obj -> (AppResponse) obj);
+                final String methodName = RpcUtils.getMethodName(invocation);
+                final int timeout = calculateTimeout(invocation, methodName);
+                CompletableFuture<AppResponse> appResponseFuture = currentClient.request(inv, timeout, null).thenApply(obj -> (AppResponse) obj);","[{'comment': 'I have two thoughts over this issue:\r\n1. Should we implicitly set all server push invokers to one-way mode inside the framework? \r\n2. If 1 is not right, I think adding a timeout to server push RPC call is necessary, but simply using `url.getParameter(""timeout"")` would be enough, times spent during the previous RPC call should not be considered into the calculation.', 'commenter': 'chickenlj'}]"
9464,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/FilterChainBuilder.java,"@@ -144,12 +126,116 @@ public String toString() {
      * @param <TYPE>
      */
     class ClusterFilterChainNode<T, TYPE extends ClusterInvoker<T>, FILTER extends BaseFilter>
-            extends FilterChainNode<T, TYPE, FILTER> implements ClusterInvoker<T> {
+        extends FilterChainNode<T, TYPE, FILTER> implements ClusterInvoker<T> {
         public ClusterFilterChainNode(TYPE originalInvoker, Invoker<T> nextNode, FILTER filter) {
             super(originalInvoker, nextNode, filter);
         }
 
 
+        @Override
+        public URL getRegistryUrl() {
+            return getOriginalInvoker().getRegistryUrl();
+        }
+
+        @Override
+        public Directory<T> getDirectory() {
+            return getOriginalInvoker().getDirectory();
+        }
+
+        @Override
+        public boolean isDestroyed() {
+            return getOriginalInvoker().isDestroyed();
+        }
+    }
+
+    class CallbackRegistrationInvoker<T, FILTER extends BaseFilter> implements Invoker<T> {
+        static final Logger LOGGER = LoggerFactory.getLogger(CallbackRegistrationInvoker.class);
+        private final Invoker<T> filterInvoker;
+        private final List<FILTER> filters;
+
+        public CallbackRegistrationInvoker(Invoker<T> filterInvoker, List<FILTER> filters) {
+            this.filterInvoker = filterInvoker;
+            this.filters = filters;
+        }
+
+        @Override
+        public Result invoke(Invocation invocation) throws RpcException {
+            Result asyncResult = filterInvoker.invoke(invocation);
+            asyncResult.whenCompleteWithContext((r, t) -> {
+                for (int i = filters.size() - 1; i >= 0; i--) {
+                    FILTER filter = filters.get(i);
+                    try {
+                        if (filter instanceof ListenableFilter) {
+                            ListenableFilter listenableFilter = ((ListenableFilter) filter);
+                            Filter.Listener listener = listenableFilter.listener(invocation);
+                            try {
+                                if (listener != null) {
+                                    if (t == null) {
+                                        listener.onResponse(r, filterInvoker, invocation);
+                                    } else {
+                                        listener.onError(t, filterInvoker, invocation);
+                                    }
+                                }
+                            } finally {
+                                listenableFilter.removeListener(invocation);
+                            }
+                        } else if (filter instanceof FILTER.Listener) {
+                            FILTER.Listener listener = (FILTER.Listener) filter;
+                            if (t == null) {
+                                listener.onResponse(r, filterInvoker, invocation);
+                            } else {
+                                listener.onError(t, filterInvoker, invocation);
+                            }
+                        }
+                    } catch (Throwable filterThrowable) {","[{'comment': 'Calling FILTER.Listener after all filters invoked may cause influence semantics of invokers, such as this may effect some environment clean up operation in finally block.\r\n\r\nExample:\r\n```java\r\npublic class DemoFilter implements Filter, Filter.Listener {\r\n\r\n    @Override\r\n    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\r\n        try {\r\n            return invoker.invoke(invocation);\r\n        } finally {\r\n            // action 1\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onResponse(Result appResponse, Invoker<?> invoker, Invocation invocation) {\r\n            // action 2\r\n    }\r\n\r\n    @Override\r\n    public void onError(Throwable t, Invoker<?> invoker, Invocation invocation) {\r\n            // action 2\r\n    }\r\n}\r\n```\r\n\r\nAfter this PR change, action 1 will happends before action 2.\r\n', 'commenter': 'AlbumenJ'}, {'comment': ""> After this PR change, action 1 will happends before action 2.\r\n\r\nAfter thinking about this issue, I came up with two possible problematic scenarios:\r\n\r\n```java\r\n        @Override\r\n        public Result invoke(Invocation invocation) throws RpcException {\r\n            Result asyncResult = filterInvoker.invoke(invocation);\r\n            asyncResult.whenCompleteWithContext((r, t) -> {\r\n                for (int i = filters.size() - 1; i >= 0; i--) {\r\n                    FILTER filter = filters.get(i);\r\n```\r\n\r\n## 1 The execution order of action1 and action2 in the same Fitler instance\r\n\r\n`Result asyncResult = filterInvoker.invoke(invocation);`(all `filter.invoke()` finished at this point) happens before `asyncResult.whenCompleteWithContext`(the onResponse callback registration). This sequence can make sure  that`action1` will always happen before `action2`, which I think is right and consistent with the previous behavior. \r\n\r\n## 2 The sequence of action1 and action2 among different filters\r\n\r\nFor filter chain like `Pxoxy -> Filter1 -> Filter2 -> Invoker`\r\n\r\nFilter1's `finally block(action1)` can be executed before `Filter2's onRespose callback(action2)`, which can be different from the previous behavior when making synchronous calls.  Typical example is `ClassLoaderFilter` which tries to set context that will be used by all the following filters and stacks, that is, all filters that set context across filters may be affected.\r\n\r\nBut in asynchronous scenarios, this behavior is also not guaranteed before."", 'commenter': 'chickenlj'}, {'comment': ""To conclude, there may still have some problems in certain scenarios for this `onResponse` model we are having now, but I don't think it's brought by changes in this patch."", 'commenter': 'chickenlj'}]"
9510,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java,"@@ -372,21 +370,20 @@ protected void notifyAddressChanged() {
      * Since this listener is shared among interfaces, destroy this listener only when all interface listener are unsubscribed
      */
     public synchronized void destroy() {
-        if (!destroyed.get()) {
+        if (!destroyed && CollectionUtils.isEmptyMap(listeners)) {
             if (CollectionUtils.isEmptyMap(listeners)) {","[{'comment': '`CollectionUtils.isEmptyMap(listeners)` is roundabout', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'BurningCN'}]"
9510,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java,"@@ -84,8 +82,8 @@
     public ServiceInstancesChangedListener(Set<String> serviceNames, ServiceDiscovery serviceDiscovery) {
         this.serviceNames = serviceNames;
         this.serviceDiscovery = serviceDiscovery;
-        this.listeners = new ConcurrentHashMap<>();
-        this.listenerQueue = new ConcurrentLinkedQueue<>();
+        this.listeners = new HashMap<>();
+        this.listenerQueue = new LinkedList<>();","[{'comment': '`listenerQueue` will be used concurrency in `notifyAddressChanged` method.', 'commenter': 'AlbumenJ'}, {'comment': 'Currently the `notifyAddressChanged` method is only called by the `doOnEvent` method with the `synchronized` modifier. The concurrent scenario you are talking about is that `notifyAddressChanged` may be called by subclasses in the future?', 'commenter': 'BurningCN'}]"
9520,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/BroadCastClusterInvokerTest.java,"@@ -117,6 +131,96 @@ public void testFailPercent() {
         assertTrue(invoker3.isInvoked());
         assertFalse(invoker4.isInvoked());
     }
+
+    @Test
+    public void testMockedInvokerSelect() {
+        given(dic.list(invocation)).willReturn(Arrays.asList(invoker1, invoker2, invoker3, invoker4));
+
+        List<Invoker<DemoService>> invokers = dic.list(invocation);
+        Assertions.assertEquals(4, invokers.size());
+    }
+
+
+    @Test
+    public void testFailoverInvokerSelect(){
+        given(dic.list(invocation)).willReturn(Arrays.asList(invoker1, invoker2, invoker3, invoker4));
+        //取得当前调用链的所有invoker，逐个判断调用是否成功","[{'comment': 'Please describe in English.\r\n', 'commenter': 'CrazyHZM'}]"
9520,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/BroadCastClusterInvokerTest.java,"@@ -117,6 +131,96 @@ public void testFailPercent() {
         assertTrue(invoker3.isInvoked());
         assertFalse(invoker4.isInvoked());
     }
+
+    @Test
+    public void testMockedInvokerSelect() {
+        given(dic.list(invocation)).willReturn(Arrays.asList(invoker1, invoker2, invoker3, invoker4));
+
+        List<Invoker<DemoService>> invokers = dic.list(invocation);
+        Assertions.assertEquals(4, invokers.size());
+    }
+
+
+    @Test
+    public void testFailoverInvokerSelect(){
+        given(dic.list(invocation)).willReturn(Arrays.asList(invoker1, invoker2, invoker3, invoker4));
+        //取得当前调用链的所有invoker，逐个判断调用是否成功
+
+        invokers =  dicIncludeInvokers.getAllInvokers();
+
+        BroadcastClusterInvoker broadcastCluster = new BroadcastClusterInvoker(dicIncludeInvokers);
+        Assertions.assertDoesNotThrow( () -> {
+                broadcastCluster.doInvoke(invocation, invokers, new MockLoadBalance());
+            });
+
+        try{
+            broadcastCluster.invoke(new RpcInvocation(""sayhello"",DemoService.class.getName(),"""",
+                new Class<?>[0], new Object[0]));
+            Thread.sleep(120*1000);
+        }catch (RpcException e ){
+            Assertions.assertEquals(RpcException.TIMEOUT_EXCEPTION, e.getCode());
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+
+
+    }
+}
+
+
+class MockLoadBalance implements LoadBalance {
+    @Override
+    public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
+        return null;
+    }
+}
+
+
+//设置一个注册中心地址，便于consumer本地进行远程调用测试","[{'comment': 'Please describe in English.\r\n\r\n', 'commenter': 'CrazyHZM'}]"
9520,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TokenFilter.java,"@@ -47,10 +47,14 @@ public Result invoke(Invoker<?> invoker, Invocation inv)
             Class<?> serviceType = invoker.getInterface();
             Map<String, Object> attachments = inv.getObjectAttachments();
             String remoteToken = (attachments == null ? null : (String) attachments.get(TOKEN_KEY));
-            if (!token.equals(remoteToken)) {
-                throw new RpcException(""Invalid token! Forbid invoke remote service "" + serviceType + "" method "" + inv.getMethodName() +
-                        ""() from consumer "" + RpcContext.getServiceContext().getRemoteHost() + "" to provider "" +
-                        RpcContext.getServiceContext().getLocalHost()+ "", consumer incorrect token is "" + remoteToken);
+            if (ConfigUtils.isDefault(token)){","[{'comment': 'This means that as long as the token=default is configured, the request can be executed arbitrarily, right?', 'commenter': 'CrazyHZM'}, {'comment': 'yes as described in the question', 'commenter': 'kaori-seasons'}]"
9520,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TokenFilter.java,"@@ -47,10 +47,14 @@ public Result invoke(Invoker<?> invoker, Invocation inv)
             Class<?> serviceType = invoker.getInterface();
             Map<String, Object> attachments = inv.getObjectAttachments();
             String remoteToken = (attachments == null ? null : (String) attachments.get(TOKEN_KEY));
-            if (!token.equals(remoteToken)) {
-                throw new RpcException(""Invalid token! Forbid invoke remote service "" + serviceType + "" method "" + inv.getMethodName() +
-                        ""() from consumer "" + RpcContext.getServiceContext().getRemoteHost() + "" to provider "" +
-                        RpcContext.getServiceContext().getLocalHost()+ "", consumer incorrect token is "" + remoteToken);
+            if (ConfigUtils.isDefault(token)){
+                inv.setAttachment(TOKEN_KEY,token);
+            }
+            if (!token.equals(remoteToken) && !ConfigUtils.isDefault(token)) {","[{'comment': 'This may cause token downgrade attack. If provider use default token, TokenFilter in provider side may not work.', 'commenter': 'AlbumenJ'}, {'comment': '> This may cause token downgrade attack. If provider use default token, TokenFilter in provider side may not work.\r\n\r\n@AlbumenJ You mean that when the token is passed in the thread context it should fake a value, or expose a configuration. Is it used to guarantee idempotency when downgrading?', 'commenter': 'kaori-seasons'}]"
9577,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java,"@@ -334,15 +335,23 @@ public void destroy() {
 
     @Override
     public URL getUrl() {
+        URL getUrl;
         if (currentAvailableInvoker != null) {
-            return currentAvailableInvoker.getUrl();
+            getUrl = currentAvailableInvoker.getUrl();
         } else if (invoker != null) {
-            return invoker.getUrl();
+            getUrl = invoker.getUrl();
         } else if (serviceDiscoveryInvoker != null) {
-            return serviceDiscoveryInvoker.getUrl();
+            getUrl = serviceDiscoveryInvoker.getUrl();
+        } else {
+            getUrl = consumerUrl;
         }
 
-        return consumerUrl;
+        // set parameter weight if needed.
+        if (getUrl != null && getUrl.getUrlParam() != null && StringUtils.isEmpty(getUrl.getParameter(WEIGHT_KEY))
+                && url != null && url.getUrlParam() != null && !StringUtils.isEmpty(url.getParameter(WEIGHT_KEY))) {
+            getUrl = getUrl.addParameter(WEIGHT_KEY, url.getParameter(WEIGHT_KEY));
+        }
+        return getUrl;","[{'comment': 'I think it would be more proper to move these to somewhere real registry invoker created.', 'commenter': 'AlbumenJ'}]"
9577,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java,"@@ -75,22 +73,17 @@ static int calculateWarmupWeight(int uptime, int warmup, int weight) {
     protected int getWeight(Invoker<?> invoker, Invocation invocation) {
         int weight;
         URL url = invoker.getUrl();
-        // Multiple registry scenario, load balance among multiple registries.
-        if (REGISTRY_SERVICE_REFERENCE_PATH.equals(url.getServiceInterface())) {","[{'comment': '`REGISTRY_KEY + ""."" + WEIGHT_KEY` needs to be reserved.\r\nRegistry\'s weight is not equals with provider\'s weight. Also, registry\'s weight should no override provider\'s weight.', 'commenter': 'AlbumenJ'}]"
9578,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvoker.java,"@@ -86,6 +86,9 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L
                 URL consumerUrl = RpcContext.getServiceContext().getConsumerUrl();
                 executor.execute(() -> {
                     try {
+                        if (ref.size() > 0) {","[{'comment': 'Very good, but the concurrency problem must be taken into account. Suppose that 10 threads execute this step and judge size=0. At this time, multiple elements will still be stored in the queue. The size judgment can use the atomic class, like the previous `final AtomicInteger count = new AtomicInteger();`', 'commenter': 'BurningCN'}, {'comment': 'I think that in the case of 10 threads judging at the same time, there should not be a limit, because the results are not obtained at this time and as many threads as possible need to initiate the access, so as to speed up the acquisition of results', 'commenter': 'juzi214032'}, {'comment': 'However, I have added a capacity limit to the queue, which prevents the memory usage caused by multiple threads getting the results at the same time', 'commenter': 'juzi214032'}, {'comment': 'Setting size to 1 can only ensure that the result of each call by multiple threads will not be stored when `queue.offer` is executed, but the actual call still occurs.\r\nOf course, this is a probabilistic event under multithreading.', 'commenter': 'BurningCN'}, {'comment': '> I think that in the case of 10 threads judging at the same time, there should not be a limit, because the results are not obtained at this time and as many threads as possible need to initiate the access, so as to speed up the acquisition of results\r\n\r\nYes, as stated above, concurrent calls cannot be limited because of the need to get the fastest results', 'commenter': 'juzi214032'}]"
9580,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java,"@@ -135,18 +134,16 @@ public synchronized void onEvent(ServiceInstancesChangedEvent event) {
 
             localServiceToRevisions.forEach((serviceKey, revisions) -> {
                 List<URL> urls = revisionsToUrls.get(revisions);
-                if (urls != null) {
-                    tmpServiceUrls.put(serviceKey, urls);
-                } else {
+                if (urls == null) {
                     urls = new ArrayList<>();
                     for (String r : revisions) {
                         for (ServiceInstance i : revisionToInstances.get(r)) {
                             urls.add(i.toURL());
                         }
                     }
                     revisionsToUrls.put(revisions, urls);
-                    tmpServiceUrls.put(serviceKey, urls);","[{'comment': 'Maybe no changes are seriously needed here?', 'commenter': 'AlbumenJ'}]"
9603,dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java,"@@ -23,16 +23,7 @@
 import com.alibaba.fastjson.JSON;
 
 import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeMap;
+import java.util.*;","[{'comment': '这里不要用*', 'commenter': 'wangchengming666'}, {'comment': '已修改', 'commenter': 'Qomolang'}]"
9604,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java,"@@ -148,26 +152,26 @@ public AbstractDirectory(URL url, RouterChain<T> routerChain, boolean isUrlFromR
         this.queryMap = applicationModel.getBeanFactory().getBean(ClusterUtils.class).mergeLocalParams(queryMap);
 
         if (consumerUrl == null) {
-            String host = StringUtils.isNotEmpty(queryMap.get(""register.ip"")) ? queryMap.get(""register.ip"") : this.url.getHost();
-            String path = queryMap.get(PATH_KEY);
-            String consumedProtocol = queryMap.get(PROTOCOL_KEY) == null ? DUBBO : queryMap.get(PROTOCOL_KEY);
+            String host = StringUtils.isNotEmpty(queryMap.get(REGISTER_IP_KEY)) ? queryMap.get(REGISTER_IP_KEY) : this.url.getHost();
+            String path = StringUtils.isNotEmpty(queryMap.get(PATH_KEY)) ? queryMap.get(PATH_KEY) : queryMap.get(INTERFACE_KEY);
+            String consumedProtocol = StringUtils.isNotEmpty(queryMap.get(PROTOCOL_KEY)) ? queryMap.get(PROTOCOL_KEY) : DUBBO;
 
             URL consumerUrlFrom = this.url
                 .setHost(host)
                 .setPort(0)
                 .setProtocol(consumedProtocol)
-                .setPath(path == null ? queryMap.get(INTERFACE_KEY) : path);
+                .setPath(path);
             if (isUrlFromRegistry) {
                 // reserve parameters if url is already a consumer url
-                consumerUrlFrom = consumerUrlFrom.clearParameters().setServiceModel(url.getServiceModel()).setScopeModel(url.getScopeModel());
+                consumerUrlFrom = consumerUrlFrom.clearParameters();","[{'comment': 'Why is `.setServiceModel(url.getServiceModel()).setScopeModel(url.getScopeModel());` removed?', 'commenter': 'chickenlj'}, {'comment': 'Because the `consumerUrlFrom` will directly have the `attributes` attribute of the `this.url`, there are already `scopeModel` and `serviceModel` in the `attributes`\r\n![image](https://user-images.githubusercontent.com/43363120/150489049-6486f2d2-b735-403a-a2ea-8f1608d1fce3.png)\r\n', 'commenter': 'BurningCN'}]"
9604,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java,"@@ -148,26 +152,26 @@ public AbstractDirectory(URL url, RouterChain<T> routerChain, boolean isUrlFromR
         this.queryMap = applicationModel.getBeanFactory().getBean(ClusterUtils.class).mergeLocalParams(queryMap);
 
         if (consumerUrl == null) {
-            String host = StringUtils.isNotEmpty(queryMap.get(""register.ip"")) ? queryMap.get(""register.ip"") : this.url.getHost();
-            String path = queryMap.get(PATH_KEY);
-            String consumedProtocol = queryMap.get(PROTOCOL_KEY) == null ? DUBBO : queryMap.get(PROTOCOL_KEY);
+            String host = StringUtils.isNotEmpty(queryMap.get(REGISTER_IP_KEY)) ? queryMap.get(REGISTER_IP_KEY) : this.url.getHost();
+            String path = StringUtils.isNotEmpty(queryMap.get(PATH_KEY)) ? queryMap.get(PATH_KEY) : queryMap.get(INTERFACE_KEY);
+            String consumedProtocol = StringUtils.isNotEmpty(queryMap.get(PROTOCOL_KEY)) ? queryMap.get(PROTOCOL_KEY) : DUBBO;
 
             URL consumerUrlFrom = this.url
                 .setHost(host)
                 .setPort(0)
                 .setProtocol(consumedProtocol)
-                .setPath(path == null ? queryMap.get(INTERFACE_KEY) : path);
+                .setPath(path);
             if (isUrlFromRegistry) {
                 // reserve parameters if url is already a consumer url
-                consumerUrlFrom = consumerUrlFrom.clearParameters().setServiceModel(url.getServiceModel()).setScopeModel(url.getScopeModel());
+                consumerUrlFrom = consumerUrlFrom.clearParameters();
             }
-            this.consumerUrl = consumerUrlFrom.addParameters(queryMap).removeAttribute(MONITOR_KEY);
+            this.consumerUrl = consumerUrlFrom.addParameters(queryMap);","[{'comment': 'And also why is `.removeAttribute(MONITOR_KEY)`  removed.', 'commenter': 'chickenlj'}, {'comment': 'It has been removed here\r\n\r\n![image](https://user-images.githubusercontent.com/43363120/150489164-7e39b76f-9dcc-4ef0-80cb-cf29cfa8d8a2.png)\r\n', 'commenter': 'BurningCN'}]"
9613,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvoker.java,"@@ -96,7 +93,7 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L
                 });
             }
             try {
-                Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);
+                Object ret = ref.poll(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);","[{'comment': 'What is the purpose change this line? Will this cause NPE?', 'commenter': 'AlbumenJ'}, {'comment': ""I don't think it's reasonable to make the queue wait indefinitely, which may generate some unknown exceptions, and a reasonable way would be to reverse the relevant exception message when the ret is empty"", 'commenter': 'juzi214032'}, {'comment': 'Yes，if poll method use the same timeout with the provider，when provider timeout the poll method used in forkingClusterInvoker will time out earlier than the provider side, so it will get null from the queue and throw NPE in the subsequent process.', 'commenter': 'codeimport'}, {'comment': 'Thank you for your suggestion. I understand what you mean, but if the provider side times out, an exception will be caught here and put into the queue, so the poll method will not return any null. There should be no other exceptions。\r\n\r\n`                    try {\r\n                        Result result = invokeWithContextAsync(invoker, invocation, consumerUrl);\r\n                        ref.offer(result);\r\n                    } catch (Throwable e) {\r\n                        int value = count.incrementAndGet();\r\n                        if (value >= selected.size()) {\r\n                            ref.offer(e);\r\n                        }\r\n                    }`\r\n\r\n', 'commenter': 'codeimport'}, {'comment': 'I agree with what you said', 'commenter': 'juzi214032'}]"
9616,dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java,"@@ -74,7 +75,10 @@
     private static final Logger logger = LoggerFactory.getLogger(PojoUtils.class);
     private static final ConcurrentMap<String, Method> NAME_METHODS_CACHE = new ConcurrentHashMap<String, Method>();
     private static final ConcurrentMap<Class<?>, ConcurrentMap<String, Field>> CLASS_FIELD_CACHE = new ConcurrentHashMap<Class<?>, ConcurrentMap<String, Field>>();
-    private static final boolean GENERIC_WITH_CLZ = Boolean.parseBoolean(ConfigurationUtils.getProperty(CommonConstants.GENERIC_WITH_CLZ_KEY, ""true""));
+    private static final boolean GENERIC_WITH_CLZ =
+            Boolean.parseBoolean(
+                    ConfigurationUtils.getProperty(
+                            ApplicationModel.defaultModel(), CommonConstants.GENERIC_WITH_CLZ_KEY, ""true""));","[{'comment': 'The proper way is to convert `PojoUtils` to a application scope bean to prevent use default model.', 'commenter': 'AlbumenJ'}]"
9631,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -396,7 +397,9 @@ private T createProxy(Map<String, String> referenceParameters) {
         }
 
         if (logger.isInfoEnabled()) {
-            logger.info(""Referred dubbo service "" + interfaceClass.getName());
+            logger.info(""Referred dubbo service: ["" + referenceParameters.get(INTERFACE_KEY) + ""]."" +
+                (Boolean.TRUE.toString().equals(referenceParameters.get(GENERIC_KEY)) ?","[{'comment': 'use `Boolean.parseBoolean` instead.', 'commenter': 'AlbumenJ'}]"
9645,dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocol.java,"@@ -88,7 +98,15 @@ public int getDefaultPort() {
 
     @Override
     public <T> Invoker<T> protocolBindingRefer(Class<T> serviceType, URL url) throws RpcException {
-        return new InjvmInvoker<T>(serviceType, url, url.getServiceKey(), exporterMap);
+        // group=""a,b"" or group=""*""
+        String group = url.getParameter(GROUP_KEY);
+        if (StringUtils.isNotEmpty(group)) {
+            if ((COMMA_SPLIT_PATTERN.split(group)).length > 1 || ""*"".equals(group)) {
+                return doCreateInvoker(url, Cluster.getCluster(url.getScopeModel(), MergeableCluster.NAME), serviceType);
+            }
+        }
+        Cluster cluster = Cluster.getCluster(url.getScopeModel(), url.getParameter(CLUSTER_KEY));","[{'comment': 'Can we just return `InjvmInvoker` directly for empty or single accurate group? Is cluster still necessary?', 'commenter': 'chickenlj'}, {'comment': 'There are some fault tolerance strategies in the cluster, which I think can also be reused in local.', 'commenter': 'CrazyHZM'}, {'comment': '```java\r\n    @SuppressWarnings({""unchecked"", ""rawtypes""})\r\n    private void createInvokerForLocal(Map<String, String> referenceParameters) {\r\n        URL url = new ServiceConfigURL(LOCAL_PROTOCOL, LOCALHOST_VALUE, 0, interfaceClass.getName(), referenceParameters);\r\n        url = url.setScopeModel(getScopeModel());\r\n        url = url.setServiceModel(consumerModel);\r\n        Invoker<?> withFilter = protocolSPI.refer(interfaceClass, url);\r\n        // Local Invoke ( Support Cluster Filter / Filter )\r\n        List<Invoker<?>> invokers = new ArrayList<>();\r\n        invokers.add(withFilter);\r\n        invoker = Cluster.getCluster(url.getScopeModel(), Cluster.DEFAULT).join(new StaticDirectory(url, invokers), true);\r\n\r\n        if (logger.isInfoEnabled()) {\r\n            logger.info(""Using in jvm service "" + interfaceClass.getName());\r\n        }\r\n    }\r\n\r\n```\r\n\r\nBut I think that the invoker returned from here will be wrapped with a cluster in ReferenceConfig.', 'commenter': 'chickenlj'}, {'comment': 'Oh, I just noticed that you removed the wrapper logic there\r\n```java\r\n  // Local Invoke ( Support Cluster Filter / Filter )\r\n        List<Invoker<?>> invokers = new ArrayList<>();\r\n        invokers.add(withFilter);\r\n        invoker = Cluster.getCluster(url.getScopeModel(), Cluster.DEFAULT).join(new StaticDirectory(url, invokers), true);\r\n```', 'commenter': 'chickenlj'}]"
9691,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -308,6 +308,7 @@ public synchronized void init() {
         }
         map.put(REGISTER_IP_KEY, hostToRegistry);
 
+        serviceMetadata.getAttachments().forEach((k, v) -> map.put(k, String.valueOf(v)));","[{'comment': 'When the value is not of type String, an exception will be thrown, and it is necessary to ensure that only metadata of type String can be passed', 'commenter': 'CrazyHZM'}]"
9691,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -457,6 +457,7 @@ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> r
             }
         }
         //init serviceMetadata attachments
+        serviceMetadata.getAttachments().forEach((k, v) -> map.put(k, String.valueOf(v)));","[{'comment': 'The same as above.\r\n', 'commenter': 'CrazyHZM'}]"
9692,dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java,"@@ -171,7 +171,7 @@ public static Object compatibleTypeConvert(Object value, Class<?> type) {
                 return BigInteger.valueOf(number.longValue());
             }
             if (type == BigDecimal.class) {
-                return BigDecimal.valueOf(number.doubleValue());
+                return new BigDecimal(number.toString());","[{'comment': 'Please add unit test.', 'commenter': 'CrazyHZM'}]"
9706,dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-consumer/src/main/java/org/apache/dubbo/springboot/demo/consumer/ConsumerApplication.java,"@@ -26,9 +26,9 @@
 import org.springframework.stereotype.Service;
 
 @SpringBootApplication
-@Service
+@DubboService","[{'comment': '`ConsumerApplication` does not need to be a Dubbo service', 'commenter': 'CrazyHZM'}]"
9723,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,"@@ -181,13 +185,32 @@ private void invoke(Channel channel, String methodKey) {
             Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);
             if (invocation != null) {
                 try {
+                    if (Boolean.TRUE.toString().equals(invocation.getAttachment(STUB_EVENT_KEY))) {
+                        getOrWaitStubService(channel, invocation);
+                    }
                     received(channel, invocation);
                 } catch (Throwable t) {
                     logger.warn(""Failed to invoke event method "" + invocation.getMethodName() + ""(), cause: "" + t.getMessage(), t);
                 }
             }
         }
 
+        private void getOrWaitStubService(Channel channel, Invocation invocation) throws InterruptedException {
+            try {
+                Invoker<?> invoker = getInvoker(channel, invocation);","[{'comment': 'If getInvoker throws an exception, it means that the stub service has not been exposed, it will try to wait for the signal that the stub exposure is complete, and then call back the related methods of the stub service.', 'commenter': 'BurningCN'}]"
9723,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,"@@ -253,7 +276,8 @@ private boolean isClientSide(Channel channel) {
         // if it's callback service on client side
         isStubServiceInvoke = Boolean.TRUE.toString().equals(inv.getObjectAttachments().get(STUB_EVENT_KEY));
         if (isStubServiceInvoke) {
-            port = channel.getRemoteAddress().getPort();
+            // The port of the client exposed stub service is 0
+            port = 0;","[{'comment': 'When the consumer exposes the stub service, the port number is 0', 'commenter': 'BurningCN'}, {'comment': 'One similar PR has been merged into the master branch\r\n\r\nhttps://github.com/apache/dubbo/pull/9825', 'commenter': 'chickenlj'}]"
9723,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,"@@ -702,6 +728,8 @@ public void destroy() {
             }
         }
         referenceClientMap.clear();
+        
+        stubServiceToLatch.clear();","[{'comment': 'I think we should take destroy of stubServiceToLatch on destroy of stub proxy too.\r\n\r\nThere might have lots of proxy invokers (reference config) create and destroy during the lifetime of DubboProtocol.', 'commenter': 'chickenlj'}, {'comment': 'I think we should take destroy of stubServiceToLatch on destroy of stub proxy too.\r\n\r\nThere might have lots of proxy invokers (reference config) create and destroy during the lifetime of DubboProtocol.', 'commenter': 'chickenlj'}, {'comment': ""I  don't think waiting for the stub to be ready is necessary for it will make the whole process more complicated. Just giving a more elegant and clear Exception or result would be enough. What do you think? @BurningCN "", 'commenter': 'chickenlj'}, {'comment': 'Consider the complexities of `latch.await()`, Can `stubServiceToLatch` be replaced with this similar structure, `Map<String,Boolean> stubService2Flag`.When the `connect` event occurs and the `stub invoker` is not found, execute `stubService2Flag.put(serviceKey, true)`.\r\nWhen the stub service exposure is completed, check `if(stubService2Flag.get(serviceKey))`, then call `received(channel, invocation);`', 'commenter': 'BurningCN'}, {'comment': '`Map<String,Boolean> stubService2Flag` is still a variable that needs to be taken care of in case of a memory leak. I think a detailed log giving full information of possible causes would be fine.', 'commenter': 'chickenlj'}, {'comment': 'ok, then there is no need to wait(`stubServiceToLatch`) or delay notification(`stubService2Flag`). If the `stub invoker `cannot be obtained, just print the detailed log. ', 'commenter': 'BurningCN'}]"
9741,dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java,"@@ -530,19 +532,31 @@ public static boolean isEquals(String s1, String s2) {
     }
 
     /**
-     * is integer string.
+     * is positive integer or zero string.","[{'comment': 'It may be more appropriate to change to the following expression: “determine whether it is a positive integer or zero string”', 'commenter': 'CrazyHZM'}, {'comment': ""i think this method need change method name or add some comment, but i don't know what to do, other people invoke this method must be careful."", 'commenter': 'levis9527'}, {'comment': '@levis9527 \r\nI think changing the description to: determine whether it is a positive integer or zero string', 'commenter': 'CrazyHZM'}]"
9741,dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java,"@@ -530,19 +532,31 @@ public static boolean isEquals(String s1, String s2) {
     }
 
     /**
-     * is integer string.
+     * is positive integer or zero string.
      *
-     * @param str
-     * @return is integer
+     * @param str a string
+     * @return is positive integer or zero","[{'comment': 'The return should be the judgment result.\r\n', 'commenter': 'CrazyHZM'}]"
9741,dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java,"@@ -515,8 +515,10 @@ public static boolean isNotEmpty(String str) {
     }
 
     /**
-     * @param s1
-     * @param s2
+     * if s1 is null and s2 is null, then return true","[{'comment': 'The content description of the method is not completed.\r\n', 'commenter': 'CrazyHZM'}]"
9775,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/util/ServiceCheckUtils.java,"@@ -47,6 +47,10 @@ public static int getConsumerAddressNum(ConsumerModel consumerModel) {
 
         Collection<Registry> registries = registryManager.getRegistries();
         if (CollectionUtils.isNotEmpty(registries)) {
+            Registry registry = registries.iterator().next();
+            if (!(registry instanceof AbstractRegistry)) {
+                return num;
+            }","[{'comment': 'Please iterate registries and skip the instances that are not of AbstractRegistry type.', 'commenter': 'chickenlj'}]"
9791,dubbo-dependencies-bom/pom.xml,"@@ -136,10 +136,10 @@
         <!-- Log libs -->
         <slf4j_version>1.7.25</slf4j_version>
         <jcl_version>1.2</jcl_version>
-        <log4j_version>1.2.16</log4j_version>
-        <logback_version>1.2.2</logback_version>
+        <log4j_version>1.2.17</log4j_version>
+        <logback_version>1.2.11</logback_version>
         <!-- Fix the bug of log4j refer:https://github.com/apache/logging-log4j2/pull/608 -->
-        <log4j2_version>2.17.0</log4j2_version>","[{'comment': 'Thank you for your contribution, there are still some areas that need to be upgraded, such as `dubbo-spring-boot` module , etc.', 'commenter': 'CrazyHZM'}]"
9802,dubbo-dependencies-bom/pom.xml,"@@ -116,7 +116,7 @@
         <jetty_version>9.4.43.v20210629</jetty_version>
         <validation_new_version>3.0.1</validation_new_version>
         <validation_version>1.1.0.Final</validation_version>
-        <hibernate_validator_version>5.4.1.Final</hibernate_validator_version>","[{'comment': 'I am more worried about the incompatibility between 5.x and 6.x. Is it reasonable to upgrade to 5.4.2?\r\n', 'commenter': 'CrazyHZM'}, {'comment': ""I'm not sure why dependabot suggested upgrading to hibernate-validator 6 - you're right that using a new v5 release is enough to fix the vulnerability. There is a v5.4.3 - I've upgraded to that, if that's ok."", 'commenter': 'pjfanning'}]"
9807,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/MetadataReportInstance.java,"@@ -82,7 +81,7 @@ public void init(List<MetadataReportConfig> metadataReportConfigs) {
     private void init(MetadataReportConfig config, MetadataReportFactory metadataReportFactory) {
         URL url = config.toUrl();
         if (METADATA_REPORT_KEY.equals(url.getProtocol())) {
-            String protocol = url.getParameter(METADATA_REPORT_KEY, DEFAULT_DIRECTORY);
+            String protocol = url.getParameter(METADATA_REPORT_KEY, config.getProtocol());","[{'comment': '`url.getParameter(METADATA_REPORT_KEY, isEmpty(config.getProtocol()) ? dubbo :config.getProtocol() );`\r\n\r\nI think we need to check if `config.getProtocol()` is empty here.\r\n\r\n', 'commenter': 'chickenlj'}, {'comment': ' I agree with you,but metadata report center support redis/zookeeper/nacos/…….Default value ```dubbo``` will occur a error when user‘s configuration is empty.\r\nso,I think we need to check the config is empty.it throws exception for user to remind that they need to config metadata report center protocol correctly.', 'commenter': 'lishangbu'}, {'comment': ""If end users want to use metadata  report center correctly,they must config ```dubbo.metadata-report.address ```like ```protocol://ip:port```,otherwise,they must config ```dubbo.metadata-report.address```,```dubbo.metadata-report.port``` and ```dubbo.metadata-report.protocol ```.If we give a default value ```dubbo```(Of course it is wrong),then when properties isn't correct,the application cannot start up successfully and application throws exception like ```java.lang.IllegalStateException: No such extension org.apache.dubbo.metadata.report.MetadataReportFactory by name dubbo, no related exception was found, please check whether related SPI module is missing.```\r\nBut if we don't give default value,the application will start up successfully but the metadata report center cannot work\r\n So I think we need to print a error log better than give default value dubbo.\r\n"", 'commenter': 'lishangbu'}, {'comment': 'I add an error log when the protocol cannot be parsed correctly.', 'commenter': 'lishangbu'}, {'comment': '> so,I think we need to check the config is empty.it throws exception for user to remind that they need to config metadata report center protocol correctly.\r\n\r\nTotally agree, that would be better.', 'commenter': 'chickenlj'}, {'comment': ""Please check this patch https://github.com/apache/dubbo/pull/9820\r\n\r\nI think it's better to check protocol configuration on the construction of metadata config url."", 'commenter': 'chickenlj'}]"
9820,dubbo-common/src/main/java/org/apache/dubbo/config/MetadataReportConfig.java,"@@ -152,7 +153,11 @@ public URL toUrl() throws IllegalArgumentException {
         // Normalize the parameters
         map.putAll(convert(map, null));
         // put the protocol of URL as the ""metadata""
-        map.put(""metadata"", url.getProtocol());
+        String metadataProtocol = isEmpty(url.getProtocol()) ? map.get(PROTOCOL_KEY) : url.getProtocol();
+        if (isEmpty(metadataProtocol)) {
+            throw new IllegalArgumentException(""Please specify valid protocol for metadata report."" + address);
+        }","[{'comment': 'It is recommended to be better as a config validation, and complete the logic in ConfigValidationUtils#validateMetadataConfig()', 'commenter': 'CrazyHZM'}]"
9830,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/parser/model/ConfigItem.java,"@@ -28,6 +28,14 @@
     public static final String WEIGHT_TYPE = ""weight"";
     public static final String BALANCING_TYPE = ""balancing"";
     public static final String DISABLED_TYPE = ""disabled"";
+    public static final String CONFIG_ITEM_TYPE = ""type"";
+    public static final String ENABLED_KEY =""enabled"";","[{'comment': 'need a blank', 'commenter': 'kimmking'}]"
9830,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/parser/model/ConfigItem.java,"@@ -28,6 +28,14 @@
     public static final String WEIGHT_TYPE = ""weight"";
     public static final String BALANCING_TYPE = ""balancing"";
     public static final String DISABLED_TYPE = ""disabled"";
+    public static final String CONFIG_ITEM_TYPE = ""type"";
+    public static final String ENABLED_KEY =""enabled"";
+    public static final String ADDRESSES_KEY=""addresses"";","[{'comment': 'need a blank.', 'commenter': 'kimmking'}]"
9830,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/parser/model/ConfiguratorConfig.java,"@@ -26,7 +26,11 @@
 public class ConfiguratorConfig {
     public static final String SCOPE_SERVICE = ""service"";
     public static final String SCOPE_APPLICATION = ""application"";
-
+    public static final String CONFIG_VERSION_KEY = ""configVersion"";
+    public static final String SCOPE_KEY = ""scope"";
+    public static final String CONFIG_KEY=""key"";
+    public static final String ENABLED_KEY=""enabled"";","[{'comment': 'And then I guess we can extract these same key to a Constants class？', 'commenter': 'kimmking'}]"
9831,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/SimpleReferenceCache.java,"@@ -67,7 +67,7 @@
 
     private final Map<String, List<ReferenceConfigBase<?>>> referenceKeyMap = new ConcurrentHashMap<>();
     private final Map<Class<?>, List<ReferenceConfigBase<?>>> referenceTypeMap = new ConcurrentHashMap<>();
-    private final Map<ReferenceConfigBase<?>, Object> references = new ConcurrentHashMap<>();
+    private final Map<String, Object> references = new ConcurrentHashMap<>();","[{'comment': 'It seems that the `type of key` does not need to be changed, the `equals` and `toString` methods are rewritten in `AbstractConfig`(`ReferenceConfigBase` is sub class of `AbstractConfig`)', 'commenter': 'BurningCN'}, {'comment': 'Change the title of pr, and simply declare the content of this change', 'commenter': 'BurningCN'}, {'comment': 'I think `type of key`  need to be changed, otherwise `KeyGenerator` makes no sense.', 'commenter': 'hanl754'}, {'comment': '@hanl754 \r\nAgree with @BurningCN , the reason for not changing here is to consider multi-instance scenarios.', 'commenter': 'CrazyHZM'}]"
9831,dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/utils/ReferenceCacheTest.java,"@@ -25,8 +25,7 @@
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.*;","[{'comment': 'Please do not use `*`', 'commenter': 'BurningCN'}, {'comment': '> Please do not use `*`\r\n\r\ngot it.', 'commenter': 'hanl754'}]"
9840,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/BroadcastClusterInvoker.java,"@@ -89,12 +89,14 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L
         }
 
         if (exception != null) {
-            if (failIndex == failThresholdIndex) {
-                logger.debug(
+            if (logger.isDebugEnabled()) {
+                if (failIndex == failThresholdIndex) {","[{'comment': 'Adjust the order of the two if judgments, so that the judgment condition of `isDebugEnabled() ` follows `logger.debug()`.', 'commenter': 'CrazyHZM'}, {'comment': 'done, thanks', 'commenter': 'BurningCN'}]"
9852,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/PortUnificationServer.java,"@@ -175,8 +175,8 @@ protected void doClose() throws Throwable {
                 long quietPeriod = Math.min(2000L, timeout);
                 Future<?> bossGroupShutdownFuture = bossGroup.shutdownGracefully(quietPeriod, timeout, MILLISECONDS);
                 Future<?> workerGroupShutdownFuture = workerGroup.shutdownGracefully(quietPeriod, timeout, MILLISECONDS);
-                bossGroupShutdownFuture.syncUninterruptibly();
-                workerGroupShutdownFuture.syncUninterruptibly();
+                bossGroupShutdownFuture.await(timeout, MILLISECONDS);","[{'comment': 'The Method `awaitUninterruptibly` is better?', 'commenter': 'EarthChen'}]"
9858,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ServerCallBase.java,"@@ -0,0 +1,390 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri.call;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.threadpool.serial.SerializingExecutor;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.CancellationContext;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcInvocation;
+import org.apache.dubbo.rpc.TriRpcStatus;
+import org.apache.dubbo.rpc.model.FrameworkModel;
+import org.apache.dubbo.rpc.model.MethodDescriptor;
+import org.apache.dubbo.rpc.model.PackableMethod;
+import org.apache.dubbo.rpc.model.ServiceDescriptor;
+import org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;
+import org.apache.dubbo.rpc.protocol.tri.TripleConstant;
+import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;
+import org.apache.dubbo.rpc.protocol.tri.compressor.Compressor;
+import org.apache.dubbo.rpc.protocol.tri.compressor.Identity;
+import org.apache.dubbo.rpc.protocol.tri.observer.ServerCallToObserverAdapter;
+import org.apache.dubbo.rpc.protocol.tri.stream.ServerStream;
+import org.apache.dubbo.rpc.protocol.tri.stream.StreamUtils;
+
+import io.netty.handler.codec.http.HttpHeaderNames;
+import io.netty.handler.codec.http.HttpResponseStatus;
+import io.netty.handler.codec.http2.DefaultHttp2Headers;
+import io.netty.util.concurrent.Future;
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+
+public abstract class ServerCallBase implements ServerCall, ServerStream.Listener {","[{'comment': 'Rename to `Basexxx` or `Absxxx` is better.', 'commenter': 'EarthChen'}]"
9858,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/command/CancelQueueCommand.java,"@@ -23,14 +23,19 @@
 import io.netty.handler.codec.http2.Http2Error;
 
 public class CancelQueueCommand extends QueuedCommand {
+    private final Http2Error error;","[{'comment': 'Why add error?', 'commenter': 'EarthChen'}, {'comment': '`Reset` frame requires a `errorcode` , `CancelQueueCommand` is used to send reset frame to remote peer not only `cancel`  .', 'commenter': 'guohao'}, {'comment': 'But now it seems to execute cancel after rst received?', 'commenter': 'EarthChen'}, {'comment': 'Yep , `rst` acts as `Cancel` at app layer , but at the sender side ,  `rst` may mean `Close the stream now` not only cancel', 'commenter': 'guohao'}]"
9858,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/TripleClientCall.java,"@@ -0,0 +1,285 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri.call;
+
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.stream.StreamObserver;
+import org.apache.dubbo.remoting.api.Connection;
+import org.apache.dubbo.rpc.TriRpcStatus;
+import org.apache.dubbo.rpc.model.FrameworkModel;
+import org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;
+import org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;
+import org.apache.dubbo.rpc.protocol.tri.RequestMetadata;
+import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;
+import org.apache.dubbo.rpc.protocol.tri.compressor.Compressor;
+import org.apache.dubbo.rpc.protocol.tri.compressor.Identity;
+import org.apache.dubbo.rpc.protocol.tri.observer.ClientCallToObserverAdapter;
+import org.apache.dubbo.rpc.protocol.tri.stream.ClientStream;
+import org.apache.dubbo.rpc.protocol.tri.stream.StreamUtils;
+import org.apache.dubbo.rpc.protocol.tri.stream.TripleClientStream;
+
+import com.google.protobuf.Any;
+import com.google.rpc.DebugInfo;
+import com.google.rpc.ErrorInfo;
+import com.google.rpc.Status;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Executor;
+
+public class TripleClientCall implements ClientCall, ClientStream.Listener {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(TripleClientCall.class);
+    private final Connection connection;
+    private final Executor executor;
+    private final FrameworkModel frameworkModel;
+    private RequestMetadata requestMetadata;
+    private ClientStream stream;
+    private ClientCall.Listener listener;
+    private boolean canceled;
+    private boolean headerSent;
+    private boolean autoRequestN = true;
+    private boolean done;
+
+    public TripleClientCall(Connection connection, Executor executor,
+        FrameworkModel frameworkModel) {
+        this.connection = connection;
+        this.executor = executor;
+        this.frameworkModel = frameworkModel;
+    }
+
+
+    // stream listener start
+    @Override
+    public void onMessage(byte[] message) {
+        if (done) {
+            LOGGER.warn(
+                ""Received message from closed stream,connection="" + connection + "" service=""
+                    + requestMetadata.service + "" method=""
+                    + requestMetadata.method.getMethodName());
+            return;
+        }
+        try {
+            final Object unpacked = requestMetadata.packableMethod.parseResponse(message);
+            listener.onMessage(unpacked);
+        } catch (IOException | ClassNotFoundException e) {
+            cancelByLocal(TriRpcStatus.INTERNAL.withDescription(""Deserialize response failed"")
+                .withCause(e).asException());
+        }
+    }
+
+    @Override
+    public void onCancelByRemote(TriRpcStatus status) {
+        if (canceled) {
+            return;
+        }
+        canceled = true;
+        if (requestMetadata.cancellationContext != null) {
+            requestMetadata.cancellationContext.cancel(status.asException());
+        }
+        onComplete(status, null, null);
+    }
+
+    @Override
+    public void onComplete(TriRpcStatus status, Map<String, Object> attachments,
+        Map<String, String> excludeHeaders) {
+        if (done) {
+            return;
+        }
+        done = true;
+        final TriRpcStatus detailStatus;
+        final TriRpcStatus statusFromTrailers = getStatusFromTrailers(excludeHeaders);
+        if (statusFromTrailers != null) {
+            detailStatus = statusFromTrailers;
+        } else {
+            detailStatus = status;
+        }
+        try {
+            listener.onClose(detailStatus, StreamUtils.toAttachments(attachments));
+        } catch (Throwable t) {
+            cancelByLocal(
+                TriRpcStatus.INTERNAL.withDescription(""Close stream error"").withCause(t)
+                    .asException());
+        }
+        if (requestMetadata.cancellationContext != null) {
+            requestMetadata.cancellationContext.cancel(null);
+        }
+    }
+
+    private TriRpcStatus getStatusFromTrailers(Map<String, String> metadata) {
+        if (null == metadata) {
+            return null;
+        }
+        // second get status detail
+        if (!metadata.containsKey(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader())) {
+            return null;
+        }
+        final String raw = (metadata.remove(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader()));
+        byte[] statusDetailBin = StreamUtils.decodeASCIIByte(raw);
+        ClassLoader tccl = Thread.currentThread().getContextClassLoader();
+        try {
+            final Status statusDetail = Status.parseFrom(statusDetailBin);
+            List<Any> detailList = statusDetail.getDetailsList();
+            Map<Class<?>, Object> classObjectMap = tranFromStatusDetails(detailList);
+
+            // get common exception from DebugInfo
+            TriRpcStatus status = TriRpcStatus.fromCode(statusDetail.getCode())
+                .withDescription(TriRpcStatus.decodeMessage(statusDetail.getMessage()));
+            DebugInfo debugInfo = (DebugInfo) classObjectMap.get(DebugInfo.class);
+            if (debugInfo != null) {
+                String msg = ExceptionUtils.getStackFrameString(
+                    debugInfo.getStackEntriesList());
+                status = status.appendDescription(msg);
+            }
+            return status;
+        } catch (IOException ioException) {
+            return null;
+        } finally {
+            ClassLoadUtil.switchContextLoader(tccl);
+        }
+
+    }
+
+    private Map<Class<?>, Object> tranFromStatusDetails(List<Any> detailList) {
+        Map<Class<?>, Object> map = new HashMap<>();
+        try {
+            for (Any any : detailList) {
+                if (any.is(ErrorInfo.class)) {
+                    ErrorInfo errorInfo = any.unpack(ErrorInfo.class);
+                    map.putIfAbsent(ErrorInfo.class, errorInfo);
+                } else if (any.is(DebugInfo.class)) {
+                    DebugInfo debugInfo = any.unpack(DebugInfo.class);
+                    map.putIfAbsent(DebugInfo.class, debugInfo);
+                }
+                // support others type but now only support this
+            }
+        } catch (Throwable t) {
+            LOGGER.error(""tran from grpc-status-details error"", t);
+        }
+        return map;
+    }
+
+    @Override
+    public void onStart() {
+        listener.onStart(TripleClientCall.this);
+    }
+
+    @Override
+    public void cancelByLocal(Throwable t) {
+        if (canceled) {
+            return;
+        }
+        // did not create stream
+        if (!headerSent) {
+            return;
+        }
+        canceled = true;
+        if (stream == null) {
+            return;
+        }
+        TriRpcStatus status = TriRpcStatus.CANCELLED.withCause(t)
+            .withDescription(""Cancelled by client"");
+        stream.cancelByLocal(status);
+        if (requestMetadata.cancellationContext != null) {
+            requestMetadata.cancellationContext.cancel(t);
+        }
+    }
+
+    @Override
+    public void request(int messageNumber) {
+        stream.request(messageNumber);
+    }
+
+    @Override
+    public void sendMessage(Object message) {
+        if (canceled) {
+            throw new IllegalStateException(""Call already canceled"");
+        }
+        if (!headerSent) {
+            headerSent = true;
+            stream.sendHeader(requestMetadata.toHeaders());
+        }
+        final byte[] data;
+        try {
+            data = requestMetadata.packableMethod.packRequest(message);
+            int compressed =
+                Identity.MESSAGE_ENCODING.equals(requestMetadata.compressor.getMessageEncoding())
+                    ? 0 : 1;
+            final byte[] compress = requestMetadata.compressor.compress(data);
+            stream.sendMessage(compress, compressed, false)
+                .addListener(f -> {
+                    if (!f.isSuccess()) {
+                        cancelByLocal(f.cause());
+                    }
+                });
+        } catch (Throwable t) {
+            LOGGER.error(String.format(""Serialize triple request failed, service=%s method=%s"",
+                requestMetadata.service,
+                requestMetadata.method), t);
+            cancelByLocal(t);
+            listener.onClose(TriRpcStatus.INTERNAL.withDescription(""Serialize request failed"")
+                .withCause(t), null);
+        }
+    }
+    // stream listener end
+
+    @Override
+    public void halfClose() {
+        if (!headerSent) {
+            return;
+        }
+        if (canceled) {
+            return;
+        }
+        stream.halfClose()
+            .addListener(f -> {
+                if (!f.isSuccess()) {
+                    cancelByLocal(new IllegalStateException(""Half close failed"", f.cause()));
+                }
+            });
+    }
+
+    @Override
+    public void setCompression(String compression) {
+        this.requestMetadata.compressor = Compressor.getCompressor(frameworkModel, compression);
+    }
+
+    @Override
+    public StreamObserver<Object> start(RequestMetadata metadata,
+        ClientCall.Listener responseListener) {
+        this.requestMetadata = metadata;
+        this.listener = responseListener;
+        this.stream = new TripleClientStream(frameworkModel, executor, connection.getChannel(),
+            this);
+        return new ClientCallToObserverAdapter<>(this);
+    }
+
+    @Override
+    public boolean isAutoRequestN() {
+        return autoRequestN;","[{'comment': 'Modify it to a unified name `request`.', 'commenter': 'EarthChen'}]"
9864,dubbo-common/src/main/java/org/apache/dubbo/config/ReferenceConfigBase.java,"@@ -48,6 +48,8 @@
 
     private static final long serialVersionUID = -5864351140409987595L;
 
+    private static final String ORIGIN_CONFIG = ""ORIGIN_CONFIG"";","[{'comment': 'You can put this `constant` in `CommonConstants` and modify `ServiceConfigBase` by the way', 'commenter': 'BurningCN'}]"
9907,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"@@ -242,7 +242,9 @@ public void doSaveProperties(long version) {
             logger.warn(""Failed to save registry cache file, will retry, cause: "" + e.getMessage(), e);
         } finally {
             if (lockfile != null) {
-                lockfile.delete();
+                if(!lockfile.delete()) {
+                    logger.warn(""Failed to delete lock file"");","[{'comment': 'Add a file name in log message will be better.', 'commenter': 'guohao'}, {'comment': 'Good idea!', 'commenter': 'Oliverwqcwrw'}]"
9933,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java,"@@ -354,8 +356,11 @@ private URL mergeUrl(URL providerUrl) {
 
         providerUrl = providerUrl.addParameter(Constants.CHECK_KEY, String.valueOf(false)); // Do not check whether the connection is successful or not, always create Invoker!
 
+        // fix issue#9922
+        Map<String, String> providerSideParameters = new HashMap<>(providerUrl.getParameters());
+        providerSideParameters.remove(CommonConstants.TAG_KEY);
         // The combination of directoryUrl and override is at the end of notify, which can't be handled here
-        this.overrideDirectoryUrl = this.overrideDirectoryUrl.addParametersIfAbsent(providerUrl.getParameters()); // Merge the provider side parameters
+        this.overrideDirectoryUrl = this.overrideDirectoryUrl.addParametersIfAbsent(providerSideParameters); // Merge the provider side parameters","[{'comment': ""`DefaultProviderURLMergeProcessor` has removed `dubbo.tag` , It's not the best way to fix it\r\n."", 'commenter': 'CrazyHZM'}, {'comment': '`DefaultProviderURLMergeProcessor` only remove consumer side `dubbo.tag`, provder side `dubbo.tag` still exist ', 'commenter': 'zhaoguhong'}]"
9936,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/AccessLogData.java,"@@ -16,32 +16,30 @@
  */
 package org.apache.dubbo.rpc.support;
 
+import com.alibaba.fastjson.JSON;","[{'comment': 'Do not change import orders', 'commenter': 'guohao'}, {'comment': 'Ok,I will solve it', 'commenter': 'Oliverwqcwrw'}]"
9948,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/SslContexts.java,"@@ -120,10 +120,10 @@ public static SslContext buildClientSslContext(URL url) {
      */
     private static SslProvider findSslProvider() {
         if (OpenSsl.isAvailable()) {
-            logger.info(""Using OPENSSL provider."");
+            logger.debug(""Using OPENSSL provider."");
             return SslProvider.OPENSSL;
         } else if (checkJdkProvider()) {","[{'comment': 'Replace `else if` to if', 'commenter': 'EarthChen'}]"
9948,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/SslContexts.java,"@@ -120,10 +120,15 @@ public static SslContext buildClientSslContext(URL url) {
      */
     private static SslProvider findSslProvider() {
         if (OpenSsl.isAvailable()) {
-            logger.info(""Using OPENSSL provider."");
+            if(logger.isDebugEnabled()) {","[{'comment': 'There is no string operation that does not require judgment.', 'commenter': 'EarthChen'}]"
9950,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/DefaultConnectionPool.java,"@@ -0,0 +1,249 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.remoting.api;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class DefaultConnectionPool implements ConnectionPool {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultConnectionPool.class);
+
+    private volatile State state = State.ACTIVE;
+
+    private final int maxTotal = 8;
+
+    private final int maxIdle = 8;
+
+    private final int minIdle = 0;
+
+    private final URL url;
+
+
+    private final CompletableFuture<Void> closeFuture = new CompletableFuture<>();
+
+    private final Queue<Connection> cache = new ConcurrentLinkedQueue<>();
+
+    private final Queue<Connection> all = new ConcurrentLinkedQueue<>();
+
+    private final AtomicInteger objectCount = new AtomicInteger();
+
+    private final AtomicInteger objectsInCreationCount = new AtomicInteger();
+
+    private final AtomicInteger idleCount = new AtomicInteger();
+
+    public DefaultConnectionPool(URL url) {
+        this.url = url;
+    }
+
+    @Override
+    public Connection acquire() {
+        Connection connection = cache.poll();
+        if (connection == null) {
+            long objects = getObjectCount() + getCreationInProgress();
+            if (getActualMaxTotal() > objects) {
+                return createConnection();
+            }
+            connection = all.peek();
+            connection.usedCount.incrementAndGet();
+            return connection;
+        }
+        idleCount.decrementAndGet();
+        return connection;
+    }
+
+    @Override
+    public void release(Connection connection) {
+        if (!all.contains(connection)) {
+            return;
+        }
+        if (connection.usedCount.decrementAndGet() > 0) {","[{'comment': 'race condion occurs when threads call `acquire` and `release` concurrently', 'commenter': 'guohao'}, {'comment': 'race condion occurs when threads call `acquire` and `release` concurrently', 'commenter': 'guohao'}, {'comment': 'Some sync mechanisms are required or close connection asyncly', 'commenter': 'guohao'}, {'comment': 'Some sync mechanisms are required or close connection asyncly', 'commenter': 'guohao'}]"
9950,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/MultiplexProtocolConnectionManager.java,"@@ -41,10 +40,16 @@ public Connection connect(URL url) {
     }
 
     @Override
-    public void forEachConnection(Consumer<Connection> connectionConsumer) {
-        protocols.values().forEach(p -> p.forEachConnection(connectionConsumer));
+    public ConnectionPool getConnectionPool(URL url) {
+        final ConnectionManager manager = protocols.computeIfAbsent(url.getProtocol(), this::createSingleProtocolConnectionManager);
+        return manager.getConnectionPool(url);
     }
 
+//    @Override
+//    public void forEachConnection(Consumer<Connection> connectionConsumer) {
+//        protocols.values().forEach(p -> p.forEachConnection(connectionConsumer));","[{'comment': 'just delete ', 'commenter': 'guohao'}, {'comment': 'just delete ', 'commenter': 'guohao'}]"
9950,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/MultiplexProtocolConnectionManager.java,"@@ -41,10 +40,16 @@ public Connection connect(URL url) {
     }
 
     @Override
-    public void forEachConnection(Consumer<Connection> connectionConsumer) {
-        protocols.values().forEach(p -> p.forEachConnection(connectionConsumer));
+    public ConnectionPool getConnectionPool(URL url) {","[{'comment': '`ConnectionPool` is similiar to `ConnectionManager` , can these merged into one ?', 'commenter': 'guohao'}, {'comment': '`ConnectionPool` is similiar to `ConnectionManager` , can these merged into one ?', 'commenter': 'guohao'}]"
9950,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java,"@@ -278,7 +287,14 @@ public boolean isAvailable() {
         if (!super.isAvailable()) {
             return false;
         }
-        return connection.isAvailable();
+        ConnectionPoolEntry poolEntry = connectionPool.acquire();
+        try {
+            connection = poolEntry.getConnection();
+            return connection.isAvailable();
+        } finally {
+            connectionPool.release(poolEntry);","[{'comment': 'Why release here?', 'commenter': 'guohao'}]"
9950,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/connection/DefaultConnectionPool.java,"@@ -0,0 +1,252 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.remoting.api.connection;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.api.Connection;
+import org.apache.dubbo.remoting.api.ConnectionPool;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class DefaultConnectionPool implements ConnectionPool<DefaultConnectionPoolEntry> {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultConnectionPool.class);
+
+    private volatile State state = State.ACTIVE;
+
+    private final int maxTotal = 8;
+
+    private final int maxIdle = 8;
+
+    private final int minIdle = 0;
+
+    private final CompletableFuture<Void> closeFuture = new CompletableFuture<>();
+
+    private final Queue<DefaultConnectionPoolEntry> cache = new ConcurrentLinkedQueue<>();
+
+    private final Queue<DefaultConnectionPoolEntry> all = new ConcurrentLinkedQueue<>();
+
+    private final AtomicInteger objectCount = new AtomicInteger();
+
+    private final AtomicInteger objectsInCreationCount = new AtomicInteger();
+
+    private final AtomicInteger idleCount = new AtomicInteger();
+
+    private final URL url;
+
+    public DefaultConnectionPool(URL url) {
+        this.url = url;
+    }
+
+
+    @Override
+    public ConnectionPoolEntry acquire() {
+        DefaultConnectionPoolEntry connection = cache.poll();","[{'comment': 'Thread not safe here', 'commenter': 'guohao'}]"
9950,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/connection/DefaultConnectionPool.java,"@@ -0,0 +1,252 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.remoting.api.connection;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.api.Connection;
+import org.apache.dubbo.remoting.api.ConnectionPool;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class DefaultConnectionPool implements ConnectionPool<DefaultConnectionPoolEntry> {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultConnectionPool.class);
+
+    private volatile State state = State.ACTIVE;
+
+    private final int maxTotal = 8;
+
+    private final int maxIdle = 8;
+
+    private final int minIdle = 0;
+
+    private final CompletableFuture<Void> closeFuture = new CompletableFuture<>();
+
+    private final Queue<DefaultConnectionPoolEntry> cache = new ConcurrentLinkedQueue<>();
+
+    private final Queue<DefaultConnectionPoolEntry> all = new ConcurrentLinkedQueue<>();
+
+    private final AtomicInteger objectCount = new AtomicInteger();
+
+    private final AtomicInteger objectsInCreationCount = new AtomicInteger();
+
+    private final AtomicInteger idleCount = new AtomicInteger();
+
+    private final URL url;
+
+    public DefaultConnectionPool(URL url) {
+        this.url = url;
+    }
+
+
+    @Override
+    public ConnectionPoolEntry acquire() {
+        DefaultConnectionPoolEntry connection = cache.poll();
+        if (connection == null) {
+            long objects = getObjectCount() + getCreationInProgress();
+            if (getActualMaxTotal() > objects) {
+                return createConnection();
+            }
+            connection = all.poll();
+            synchronized (connection.getReusedLock()) {
+                connection.getReusedCount().incrementAndGet();
+            }
+            try {
+                return connection;
+            } finally {
+                all.add(connection);
+            }
+        }
+        idleCount.decrementAndGet();
+        return connection;
+    }
+
+    @Override
+    public void release(DefaultConnectionPoolEntry poolEntry) {
+        if (poolEntry.getReusedCount().decrementAndGet() > 0) {","[{'comment': 'not thread safe', 'commenter': 'guohao'}]"
9958,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/AccessLogData.java,"@@ -239,7 +240,7 @@ public String getLogMessage() {
 
         Object[] args = get(ARGUMENTS) != null ? (Object[]) get(ARGUMENTS) : null;
         if (args != null && args.length > 0) {
-            sn.append(JSON.toJSONString(args));
+            sn.append(JSON.toJSONString(args, SerializerFeature.IgnoreErrorGetter));","[{'comment': 'Ignoring this property is not the best way. It is recommended to print an exception once to solve the problem of continuously filling the queue.', 'commenter': 'CrazyHZM'}]"
9978,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java,"@@ -141,6 +141,7 @@ private void writeLogQueueToFile(String accessLog, Queue<AccessLogData> logQueue
                 processWithAccessKeyLogger(logQueue, file);
             }
         } catch (Exception e) {
+            logQueue.poll();","[{'comment': 'It will be better to modify the traversal method of the queue.\r\n', 'commenter': 'CrazyHZM'}, {'comment': ""> It will be better to modify the traversal method of the queue.\r\n\r\nYes, I think so too, but I'm afraid that changing too much code might not be acceptable"", 'commenter': '106umao'}, {'comment': '> It will be better to modify the traversal method of the queue.\r\n\r\nAnd if you modify the queue traversal methods so processWithAccessKeyLogger two overloaded methods need to be modified', 'commenter': '106umao'}, {'comment': ""I'm sorry, maybe I didn't express it clearly, you should handle exceptions in processWithAccessKeyLogger, and you also need to dequeue operations. If the queue is not empty, the `while` operation will cause the thread to be blocked all the time.\r\n@106umao "", 'commenter': 'CrazyHZM'}]"
10006,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/model/MigrationRule.java,"@@ -180,13 +181,21 @@ public MigrationStep getStep(URL consumerURL) {
             // initial step : APPLICATION_FIRST
             step = MigrationStep.APPLICATION_FIRST;
             step = Enum.valueOf(MigrationStep.class,
-                consumerURL.getParameter(MIGRATION_STEP_KEY,
-                    ConfigurationUtils.getCachedDynamicProperty(consumerURL.getScopeModel(), DUBBO_SERVICEDISCOVERY_MIGRATION, step.name())));
+                consumerURL.getParameter(MIGRATION_STEP_KEY, getDefaultStep(consumerURL, step.name())));
         }
 
         return step;
     }
 
+    private String getDefaultStep(URL consumerURL, String defaultStep) {
+        String globalDefaultStep = ConfigurationUtils.getCachedDynamicProperty(consumerURL.getScopeModel(), DUBBO_SERVICEDISCOVERY_MIGRATION, null);
+        if (StringUtils.isEmpty(globalDefaultStep)) {
+            // check 'dubbo.application.service-discovery.step' for compatibility
+            globalDefaultStep = ConfigurationUtils.getCachedDynamicProperty(consumerURL.getScopeModel(), ""dubbo.application.service-discovery.step"", defaultStep);","[{'comment': 'Should be compatible with `dubbo.application.service-discovery.migration`', 'commenter': 'CrazyHZM'}, {'comment': 'Sure, I will fix it now\r\n', 'commenter': 'chickenlj'}]"
10040,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java,"@@ -148,23 +149,24 @@ private void writeLogSetToFile(String accessLog, Set<AccessLogData> logSet) {
 
     private void writeLogToFile() {
         if (!logEntries.isEmpty()) {
-            for (Map.Entry<String, Set<AccessLogData>> entry : logEntries.entrySet()) {
+            for (Map.Entry<String, Queue<AccessLogData>> entry : logEntries.entrySet()) {
                 String accessLog = entry.getKey();
-                Set<AccessLogData> logSet = entry.getValue();
+                Queue<AccessLogData> logSet = entry.getValue();
                 writeLogSetToFile(accessLog, logSet);
             }
         }
     }
 
-    private void processWithAccessKeyLogger(Set<AccessLogData> logSet, File file) throws IOException {
-        try (FileWriter writer = new FileWriter(file, true)) {
-            for (Iterator<AccessLogData> iterator = logSet.iterator();
-                 iterator.hasNext();
-                 iterator.remove()) {
-                writer.write(iterator.next().getLogMessage());
-                writer.write(System.getProperty(""line.separator""));
+    private void processWithAccessKeyLogger(Queue<AccessLogData> logQueue, File file) throws IOException {
+        FileWriter writer = new FileWriter(file, true);
+        try {
+            while (!logQueue.isEmpty()) {
+                writer.write(logQueue.poll().getLogMessage());
+                writer.write(System.getProperty(LINE_SEPARATOR));","[{'comment': 'If the queue is not empty, the while operation will cause the thread to be blocked all the time.', 'commenter': 'CrazyHZM'}, {'comment': ""It's fine for this task will be scheduled in a separate thread."", 'commenter': 'chickenlj'}]"
10048,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"@@ -220,16 +221,17 @@ public void doSaveProperties(long version) {
                 } finally {
                     lock.release();
                 }
-            }
-        } catch (Throwable e) {
-            savePropertiesRetryTimes.incrementAndGet();
-            if (savePropertiesRetryTimes.get() >= MAX_RETRY_TIMES_SAVE_PROPERTIES) {
+            } catch (Throwable e) {
                 if (e instanceof OverlappingFileLockException) {
-                    // fix #9341, ignore OverlappingFileLockException
                     logger.info(""Failed to save registry cache file for file overlapping lock exception, file name "" + file.getName());
                 } else {
-                    logger.warn(""Failed to save registry cache file after retrying "" + MAX_RETRY_TIMES_SAVE_PROPERTIES + "" times, cause: "" + e.getMessage(), e);
+                    throw e;
                 }
+            }","[{'comment': '`OverlappingFileLockException` still needs to be retried.', 'commenter': 'CrazyHZM'}, {'comment': 'Thanks for your review', 'commenter': 'wangchengming666'}]"
10049,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java,"@@ -418,7 +417,7 @@ protected void notifyAddressChanged() {
 
     protected List<URL> toUrlsWithEmpty(List<URL> urls) {
         if (urls == null) {
-            urls = Collections.emptyList();
+            urls = new ArrayList<>();","[{'comment': 'Return empty list directly if `emptyProectionEnabled` may better ?', 'commenter': 'guohao'}, {'comment': 'thanks', 'commenter': 'wangchengming666'}]"
10086,dubbo-common/src/test/java/org/apache/dubbo/common/utils/LFUCacheTest.java,"@@ -73,36 +73,6 @@ public void testDefaultCapacity() throws Exception {
         assertThat(cache.getCapacity(), equalTo(1000));
     }
 
-    @Test","[{'comment': 'why remove these test codes？', 'commenter': 'kimmking'}, {'comment': 'I just  revert #7967，The removed code is useless', 'commenter': 'zhaoguhong'}]"
10164,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvoker.java,"@@ -93,6 +93,10 @@ public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, L
                 if (e.isBiz()) { // biz exception.
                     throw e;
                 }
+                if (e.getCause() != null && InterruptedException.class.getName().equals(e.getCause().toString())) {
+                    // don`t catch interrupt exception
+                    throw new RuntimeException(e);
+                }","[{'comment': 'You can choose other fault tolerance strategies, such as cluster=""failfast""\r\n', 'commenter': 'CrazyHZM'}, {'comment': ""It's not a conflict, we need failover strategy at most time, but sometimes due to business needs, I need to interrupt thread pool tasks(which contains dubbo invoke)"", 'commenter': 'happytimor'}, {'comment': ""Interrupting a thread is not a common scenario, and I don't approve of modifying non-generic logic.\r\nBased on your scenario, I think you may need a custom Cluster implementation."", 'commenter': 'CrazyHZM'}, {'comment': 'my code is like this\r\n\r\n``` java\r\nFuture<?> future =RUNNER_EXECUTOR.submit(() -> {\r\n    pipelineService.startTask(taskId);\r\n});\r\n```\r\n``` java\r\n//because some logic error, i need find the future and  cancel task\r\nfuture.cancel();\r\n```\r\n\r\ni think it is a normal scenario......\r\n', 'commenter': 'happytimor'}, {'comment': 'For example, if it is not normal behavior to interrupt the thread, dubbo still needs to initiate a retry. If it is modified according to the above logic, the retry capability will be invalid.', 'commenter': 'CrazyHZM'}, {'comment': 'yes, i want disable the retry capability when it is initiative inerrupted by login user\r\ni have to copy failover class and use SPI to override the logic at production which seems ugly', 'commenter': 'happytimor'}, {'comment': 'I suggest that you can first create an issue to discuss this requirement,  so that more people can see and participate in the discussion.\r\n', 'commenter': 'CrazyHZM'}, {'comment': 'maybe later, thanks for your patient reply.', 'commenter': 'happytimor'}]"
10166,dubbo-distribution/dubbo-all/pom.xml,"@@ -335,6 +342,11 @@
             <groupId>com.alibaba</groupId>
             <artifactId>fastjson</artifactId>
         </dependency>
+        <dependency>
+            <groupId>com.alibaba.fastjson2</groupId>
+            <artifactId>fastjson2</artifactId>
+            <version>2.0.7</version>","[{'comment': 'External dependencies and version information can be written in `dubbo-dependencies-bom.pom`', 'commenter': 'CrazyHZM'}]"
10166,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/Constants.java,"@@ -79,7 +79,11 @@ public interface Constants {
 
     String SERIALIZATION_KEY = ""serialization"";
 
-    String DEFAULT_REMOTING_SERIALIZATION = ""hessian2"";
+    String DEFAULT_REMOTING_SERIALIZATION_PROPERTY_KEY = ""DUBBO_DEFAULT_SERIALIZATION"";
+
+    String DEFAULT_REMOTING_SERIALIZATION_PROPERTY = ""hessian2"";
+
+    String DEFAULT_REMOTING_SERIALIZATION = System.getProperty(DEFAULT_REMOTING_SERIALIZATION_PROPERTY_KEY, DEFAULT_REMOTING_SERIALIZATION_PROPERTY);","[{'comment': 'Not sure if it makes sense to open up the configuration here.\r\nIn what scenarios is it used? Like migration?\r\n\r\n\r\n', 'commenter': 'CrazyHZM'}, {'comment': 'Yep, for migration purpose.', 'commenter': 'AlbumenJ'}]"
10166,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java,"@@ -87,7 +87,7 @@ public Object decode(Channel channel, InputStream input) throws IOException {
             Thread.currentThread().setContextClassLoader(invocation.getServiceModel().getClassLoader());
         }
         ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)
-                .deserialize(channel.getUrl(), input);
+                .deserialize(null, input);","[{'comment': 'Add a description of the reason for null.\r\n', 'commenter': 'CrazyHZM'}]"
10166,dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/support/DefaultSerializationSelector.java,"@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.serialize.support;
+
+
+public class DefaultSerializationSelector {
+
+    private final static String DEFAULT_REMOTING_SERIALIZATION_PROPERTY_KEY = ""DUBBO_DEFAULT_SERIALIZATION"";
+
+    private final static String DEFAULT_REMOTING_SERIALIZATION_PROPERTY = ""hessian2"";
+
+    private final static String DEFAULT_REMOTING_SERIALIZATION;
+
+    static {
+        String fromProperty = System.getProperty(DEFAULT_REMOTING_SERIALIZATION_PROPERTY_KEY);
+        if (fromProperty != null) {
+            DEFAULT_REMOTING_SERIALIZATION = fromProperty;
+        } else {
+            String fromEnv = System.getenv(DEFAULT_REMOTING_SERIALIZATION_PROPERTY_KEY);
+            if (fromEnv != null) {
+                DEFAULT_REMOTING_SERIALIZATION = fromEnv;
+            } else {
+                DEFAULT_REMOTING_SERIALIZATION = DEFAULT_REMOTING_SERIALIZATION_PROPERTY;
+            }
+        }
+    }
+
+    public static String getDefaultRemotingSerialization() {","[{'comment': 'This behavior looks similar to `Constants.DEFAULT_REMOTING_SERIALIZATION`, can it be reused?\r\n', 'commenter': 'CrazyHZM'}, {'comment': '`Constants.DEFAULT_REMOTING_SERIALIZATION` should be removed', 'commenter': 'AlbumenJ'}]"
10166,dubbo-serialization/dubbo-serialization-fastjson2/pom.xml,"@@ -0,0 +1,50 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+Licensed to the Apache Software Foundation (ASF) under one or more
+contributor license agreements.  See the NOTICE file distributed with
+this work for additional information regarding copyright ownership.
+The ASF licenses this file to You under the Apache License, Version 2.0
+(the ""License""); you may not use this file except in compliance with
+the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+-->
+
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>org.apache.dubbo</groupId>
+        <artifactId>dubbo-serialization</artifactId>
+        <version>${revision}</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
+
+    <artifactId>dubbo-serialization-fastjson2</artifactId>
+    <packaging>jar</packaging>
+    <name>${project.artifactId}</name>
+    <description>The fastjson2 serialization module of dubbo project</description>
+    <properties>
+        <skip_maven_deploy>false</skip_maven_deploy>
+    </properties>
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-serialization-api</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.alibaba.fastjson2</groupId>
+            <artifactId>fastjson2</artifactId>
+            <version>2.0.7</version>","[{'comment': 'External dependencies and version information can be written in `dubbo-dependencies-bom.pom`', 'commenter': 'CrazyHZM'}]"
10182,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java,"@@ -296,6 +299,15 @@ public void nodeChanged() throws Exception {
 
     static class CuratorWatcherImpl implements CuratorWatcher {
 
+        private static final ExecutorService CURATOR_WATCHER_EXECUTOR_SERVICE = Executors.newSingleThreadExecutor(new ThreadFactory() {
+            @Override
+            public Thread newThread(Runnable r) {
+                Thread thread = new Thread(r);
+                thread.setName(""Dubbo-CuratorWatcher-Thread"");
+                return thread;
+            }
+        });
+","[{'comment': 'Replace to use `org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository#getSharedExecutor`.\r\n\r\n```java\r\ngetUrl().getOrDefaultFrameworkModel().getBeanFactory()\r\n            .getBean(FrameworkExecutorRepository.class).getSharedExecutor();\r\n```', 'commenter': 'AlbumenJ'}, {'comment': '> Replace to use `org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository#getSharedExecutor`.\r\n> \r\n> ```java\r\n> getUrl().getOrDefaultFrameworkModel().getBeanFactory()\r\n>             .getBean(FrameworkExecutorRepository.class).getSharedExecutor();\r\n> ```\r\n\r\nThe ``FrameworkExecutorRepository`` class is available after ``3.0`` branch,  but my code is ``master`` branch', 'commenter': 'icodening'}, {'comment': 'get. Would you please submit a pr base on `3.0` branch after this pr merged?', 'commenter': 'AlbumenJ'}, {'comment': 'OK ', 'commenter': 'icodening'}]"
10200,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java,"@@ -354,10 +360,29 @@ public void nodeChanged() throws Exception {
 
     static class CuratorWatcherImpl implements CuratorWatcher {
 
+        private static volatile ExecutorService CURATOR_WATCHER_EXECUTOR_SERVICE;
+
         private CuratorFramework client;
         private volatile ChildListener childListener;
         private String path;
 
+        private static void initExecutorIfNecessary() {
+            if (CURATOR_WATCHER_EXECUTOR_SERVICE == null) {
+                synchronized (CuratorWatcherImpl.class) {
+                    if (CURATOR_WATCHER_EXECUTOR_SERVICE == null) {
+                        CURATOR_WATCHER_EXECUTOR_SERVICE = Executors.newSingleThreadExecutor(new ThreadFactory() {
+                            @Override
+                            public Thread newThread(Runnable r) {
+                                Thread thread = new Thread(r);
+                                thread.setName(""Dubbo-CuratorWatcher-Thread"");
+                                return thread;
+                            }","[{'comment': 'Replace to use `NamedThreadFactory`', 'commenter': 'AlbumenJ'}]"
10200,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java,"@@ -256,6 +259,9 @@ public ConfigItem doGetConfigItem(String path) {
     public void doClose() {
         super.close();
         client.close();
+        if (CuratorWatcherImpl.CURATOR_WATCHER_EXECUTOR_SERVICE != null) {
+            CuratorWatcherImpl.CURATOR_WATCHER_EXECUTOR_SERVICE.shutdown();
+        }","[{'comment': '1. add lock\r\n2. set null to clean up env', 'commenter': 'AlbumenJ'}]"
10200,dubbo-remoting/dubbo-remoting-zookeeper/src/main/java/org/apache/dubbo/remoting/zookeeper/curator/CuratorZookeeperClient.java,"@@ -354,10 +365,24 @@ public void nodeChanged() throws Exception {
 
     static class CuratorWatcherImpl implements CuratorWatcher {
 
+        private static volatile ExecutorService CURATOR_WATCHER_EXECUTOR_SERVICE;
+
+        private static volatile boolean closed = false;","[{'comment': 'What is this state used for?', 'commenter': 'AlbumenJ'}, {'comment': 'if there is an event callback after closing, the ``null thread pool`` will be reinitialized.', 'commenter': 'icodening'}, {'comment': 'just check if CURATOR_WATCHER_EXECUTOR_SERVICE is null is enough?', 'commenter': 'AlbumenJ'}, {'comment': 'if only check CURATOR_WATCHER_EXECUTOR_SERVICE is null, it will be initialized when Curator is closed and event callbacks are executed concurrently', 'commenter': 'icodening'}]"
10234,dubbo-registry/dubbo-registry-redis/src/main/java/org/apache/dubbo/registry/redis/RedisRegistry.java,"@@ -266,7 +268,30 @@ public void doSubscribe(final URL url, final NotifyListener listener) {
                     }
                 }
             } else {
-                doNotify(redisClient.scan(service + PATH_SEPARATOR + ANY_VALUE), url, Collections.singletonList(listener));
+//                doNotify(redisClient.scan(service + PATH_SEPARATOR + ANY_VALUE), url, Collections.singletonList(listener));
+                //@tietang.wang  2022.06.29
+                // 原来为使用redis scan命令来扫描 /dubbo/com.xxx.yyy.XxxService/*的key
+                // 按照https://dubbo.apache.org/zh/docsv2.7/user/references/registry/redis/对redis注册中心的介绍
+                //只有/dubbo/com.xxx.yyy.XxxService/providers 和/dubbo/com.xxx.yyy.XxxService/consumers 2种可能性。
+                //在在使用ClusterRedisClient时，scan命令（参考：org.apache.dubbo.remoting.redis.jedis.ClusterRedisClient.scan）是迭代循环所有cluster node
+                // 来扫描每一个node，并合并扫描结果完成的，scan命令本来就很慢，使用ClusterRedisClient时会随着节点越多越慢
+                //我的场景中有6个节点，每次需要5~20秒的扫描时间，每次启动时很慢且卡在初始化reference阶段；或者泛化每接口第一次调用或者硬编码每接口第一次调用时，都会构建Reference，构建reference时花费了很多时间
+                //如果项目中service 接口很多时，有可能在启动或者重启后会导致worker线程阻塞而请求无法正常调用，目前在测试环境已经遇到了该现象，高并发请求时有可能引起雪奔，特别是存在dubbo http网关时的场景。
+                // 经过优化后，该场景在开发环境下从5~20秒性能提升至300~1000ms，提升5~20倍，基本上在300~1000ms即可构建好reference。
+                // 测试环境多线程（50线程）预创建48个reference需要，同机房1985ms（优化前9839ms）提升5倍，跨机房（同地域）3276ms（优化前35303ms）提升10倍。
+                // 本地环境（远程连接测试环境redis）多线程（50线程）预创建48个reference需要18288ms（优化前436235ms，约7分钟多，提升23倍）。","[{'comment': '这些描述在 PR 里面就行了，不需要写在代码中。另外代码必须全英文', 'commenter': 'AlbumenJ'}]"
10234,dubbo-remoting/dubbo-remoting-redis/src/main/java/org/apache/dubbo/remoting/redis/jedis/SentinelRedisClient.java,"@@ -49,6 +49,14 @@ public SentinelRedisClient(URL url) {
         sentinelPool = new JedisSentinelPool(masterName, sentinels, getConfig(), url.getPassword());
     }
 
+    @Override
+    public boolean exists(String key) {
+        Jedis jedis = sentinelPool.getResource();
+        boolean result = jedis.exists(key);
+        jedis.close();","[{'comment': '这些不使用 try finally 包起来么？  在 finally 里关闭(归还) jedis 么\r\n```\r\ntry(Jedis jedis = sentinelPool.getResource()){\r\n boolean result = jedis.exists(key);\r\nreturn result;\r\n}catch (Exception e){\r\nthrow e;\r\n}\r\n```', 'commenter': 'liufeiyu1002'}, {'comment': '不是已经try with了...', 'commenter': 'yx-Yaoxaing'}]"
10248,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java,"@@ -732,7 +732,11 @@ public <T> CompletableFuture<T> asyncCall(Callable<T> callable) {
                     if (o instanceof CompletableFuture) {
                         return (CompletableFuture<T>) o;
                     }
-                    return CompletableFuture.completedFuture(o);
+                    // not only local invoke will return directly, when return type of method is primitive type,
+                    // the proxy will convert null to default value of primitive type. therefore, should not return a completed Future when protocol is not injvm
+                    if (Constants.LOCAL_PROTOCOL.equals(url.getProtocol())) {","[{'comment': 'url here might not reliable', 'commenter': 'AlbumenJ'}]"
10248,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java,"@@ -732,7 +732,11 @@ public <T> CompletableFuture<T> asyncCall(Callable<T> callable) {
                     if (o instanceof CompletableFuture) {
                         return (CompletableFuture<T>) o;
                     }
-                    return CompletableFuture.completedFuture(o);
+                    // not only local invoke will return directly, when return type of method is primitive type,
+                    // the proxy will convert null to default value of primitive type. therefore, should not return a completed Future when protocol is not injvm
+                    if (Constants.LOCAL_PROTOCOL.equals(url.getProtocol())) {
+                        return CompletableFuture.completedFuture(o);
+                    }","[{'comment': 'If use async call invoke a local service without remote call, this will break the result', 'commenter': 'AlbumenJ'}]"
10282,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/newportunification/AbstractPortUnificationServer.java,"@@ -0,0 +1,59 @@
+package org.apache.dubbo.remoting.api.newportunification;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.ChannelHandler;
+import org.apache.dubbo.remoting.RemotingException;
+import org.apache.dubbo.remoting.transport.AbstractServer;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+// 继承了abstract server作为连接管理handler的能力","[{'comment': 'hi, please use English to replace comment', 'commenter': 'wangchengming666'}]"
10282,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/newportunification/NewWireProtocol.java,"@@ -0,0 +1,16 @@
+package org.apache.dubbo.remoting.api.newportunification;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionScope;
+import org.apache.dubbo.common.extension.SPI;
+
+@SPI(scope = ExtensionScope.FRAMEWORK)
+public interface NewWireProtocol {","[{'comment': 'Do not create new ones, call the original abstract interface\r\n', 'commenter': 'CrazyHZM'}]"
10282,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyTransporter.java,"@@ -32,7 +33,8 @@ public class NettyTransporter implements Transporter {
 
     @Override
     public RemotingServer bind(URL url, ChannelHandler handler) throws RemotingException {
-        return new NettyServer(url, handler);
+//        return new NettyServer(url, handler);
+        return new NettyPortUnificationServer(url, handler);","[{'comment': 'Do not replace the original logic. `NettyPortUnificationServer` should be created with `NettyPortUnification Transporter`\r\n\r\n', 'commenter': 'CrazyHZM'}]"
10290,dubbo-rpc/dubbo-rpc-triple/pom.xml,"@@ -30,9 +30,20 @@
     <properties>
         <skip_maven_deploy>false</skip_maven_deploy>
         <dubbo.compiler.version>0.0.4.1-SNAPSHOT</dubbo.compiler.version>
-
+        <reactive.version>1.0.4</reactive.version>
+        <reactor.version>3.4.19</reactor.version>
     </properties>
     <dependencies>
+        <dependency>
+            <groupId>org.reactivestreams</groupId>
+            <artifactId>reactive-streams</artifactId>
+            <version>${reactive.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>io.projectreactor</groupId>
+            <artifactId>reactor-core</artifactId>
+            <version>${reactor.version}</version>","[{'comment': 'set scope=`provide` or Implemented in a separate module is better?', 'commenter': 'EarthChen'}, {'comment': 'I think `Implemented in a separate module` is better, so I create a `dubbo-rpc-triple-reactive` module?\r\nLike this:\r\n---dubbo-rpc\r\n-------dubbo-rpc-triple\r\n-------dubbo-rpc-triple-reactive', 'commenter': 'JooKS-me'}]"
10290,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java,"@@ -195,26 +200,15 @@ AsyncRpcResult invokeUnary(MethodDescriptor methodDescriptor, Invocation invocat
 
         RequestMetadata request = createRequest(methodDescriptor, invocation, timeout);
 
+        ClientCall.Listener callListener;
+
         final Object pureArgument;
-        if (methodDescriptor.getParameterClasses().length == 2
-            && methodDescriptor.getParameterClasses()[1].isAssignableFrom(
-            StreamObserver.class)) {
+        if (invocation.getArguments() != null && invocation.getArguments().length == 2 && invocation.getArguments()[1] instanceof StreamObserver) {
             StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];
-            future.whenComplete((r, t) -> {","[{'comment': 'why del?', 'commenter': 'EarthChen'}]"
10290,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java,"@@ -181,7 +182,11 @@ StreamObserver<Object> streamCall(ClientCall call,
         }
         ObserverToClientCallListenerAdapter listener = new ObserverToClientCallListenerAdapter(
             responseObserver);
-        return call.start(metadata, listener);
+        StreamObserver<Object> streamObserver = call.start(metadata, listener);
+        if (responseObserver instanceof ClientResponseObserver) {","[{'comment': 'Whether ClientResponseObserver and CancellationContext can merge？ ', 'commenter': 'EarthChen'}, {'comment': 'good idea', 'commenter': 'JooKS-me'}]"
10290,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java,"@@ -195,26 +200,15 @@ AsyncRpcResult invokeUnary(MethodDescriptor methodDescriptor, Invocation invocat
 
         RequestMetadata request = createRequest(methodDescriptor, invocation, timeout);
 
+        ClientCall.Listener callListener;
+
         final Object pureArgument;
-        if (methodDescriptor.getParameterClasses().length == 2
-            && methodDescriptor.getParameterClasses()[1].isAssignableFrom(
-            StreamObserver.class)) {
+        if (invocation.getArguments() != null && invocation.getArguments().length == 2 && invocation.getArguments()[1] instanceof StreamObserver) {","[{'comment': 'Why did I change this？', 'commenter': 'EarthChen'}, {'comment': 'Handle in #10398', 'commenter': 'JooKS-me'}]"
10290,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java,"@@ -224,8 +218,8 @@ AsyncRpcResult invokeUnary(MethodDescriptor methodDescriptor, Invocation invocat
             result = new AsyncRpcResult(future, invocation);
             result.setExecutor(callbackExecutor);
             FutureContext.getContext().setCompatibleFuture(future);
+            callListener = new UnaryClientCallListener(future);","[{'comment': 'Why did I change this？', 'commenter': 'EarthChen'}]"
10290,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ObserverToClientCallListenerAdapter.java,"@@ -54,5 +55,9 @@ public void onStart(ClientCall call) {
         if (call.isAutoRequest()) {
             call.request(1);
         }
+
+        if (delegate instanceof SafeRequestObserver) {","[{'comment': 'Why not just replace the delegate？', 'commenter': 'EarthChen'}]"
10290,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/reactive/AbstractTripleReactorPublisher.java,"@@ -0,0 +1,190 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri.reactive;
+
+import org.apache.dubbo.rpc.protocol.tri.ClientStreamObserver;
+import org.apache.dubbo.rpc.protocol.tri.SafeRequestObserver;
+import org.apache.dubbo.rpc.protocol.tri.ServerStreamObserver;
+import org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver;
+import org.reactivestreams.Publisher;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLongFieldUpdater;
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+import java.util.function.Consumer;
+
+/**
+ * The middle layer between {@link org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver} and Reactive API. <p>
+ * 1. passing the data received by CallStreamObserver to Reactive consumer <br>
+ * 2. passing the request of Reactive API to CallStreamObserver
+ */
+public abstract class AbstractTripleReactorPublisher<T> implements Publisher<T>, SafeRequestObserver<T>, Subscription {
+
+    private static final Subscription EMPTY_SUBSCRIPTION = new Subscription() {
+        @Override
+        public void cancel() {
+        }
+        @Override
+        public void request(long n) {
+        }
+    };
+
+    private volatile long requested;
+
+    private static final AtomicLongFieldUpdater<AbstractTripleReactorPublisher> REQUESTED =","[{'comment': 'Is it possible not to use the updater?', 'commenter': 'EarthChen'}]"
10290,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/reactive/AbstractTripleReactorPublisher.java,"@@ -0,0 +1,190 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri.reactive;
+
+import org.apache.dubbo.rpc.protocol.tri.ClientStreamObserver;
+import org.apache.dubbo.rpc.protocol.tri.SafeRequestObserver;
+import org.apache.dubbo.rpc.protocol.tri.ServerStreamObserver;
+import org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver;
+import org.reactivestreams.Publisher;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLongFieldUpdater;
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+import java.util.function.Consumer;
+
+/**
+ * The middle layer between {@link org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver} and Reactive API. <p>
+ * 1. passing the data received by CallStreamObserver to Reactive consumer <br>
+ * 2. passing the request of Reactive API to CallStreamObserver
+ */
+public abstract class AbstractTripleReactorPublisher<T> implements Publisher<T>, SafeRequestObserver<T>, Subscription {
+
+    private static final Subscription EMPTY_SUBSCRIPTION = new Subscription() {
+        @Override
+        public void cancel() {
+        }
+        @Override
+        public void request(long n) {
+        }
+    };
+
+    private volatile long requested;
+
+    private static final AtomicLongFieldUpdater<AbstractTripleReactorPublisher> REQUESTED =
+        AtomicLongFieldUpdater.newUpdater(AbstractTripleReactorPublisher.class, ""requested"");
+
+    // weather CallStreamObserver#request can be called
+    private final AtomicBoolean CAN_REQUEST = new AtomicBoolean();
+
+    // weather publisher has been subscribed
+    private final AtomicBoolean SUBSCRIBED = new AtomicBoolean();
+
+    private volatile Subscriber<? super T> downstream;
+
+    protected volatile CallStreamObserver<?> subscription;
+
+    private static final AtomicReferenceFieldUpdater<AbstractTripleReactorPublisher, CallStreamObserver> SUBSCRIPTION =
+        AtomicReferenceFieldUpdater.newUpdater(AbstractTripleReactorPublisher.class, CallStreamObserver.class, ""subscription"");
+
+    // cancel status
+    private volatile boolean isCancelled;
+
+    // complete status
+    private volatile boolean isDone;
+
+    // to help bind TripleSubscriber
+    private volatile Consumer<CallStreamObserver<?>> onSubscribe;
+
+    private volatile Runnable shutdownHook;
+
+    @SuppressWarnings(""rawtypes"")
+    private static final AtomicReferenceFieldUpdater<AbstractTripleReactorPublisher, Runnable> SHUTDOWN_HOOK =
+        AtomicReferenceFieldUpdater.newUpdater(AbstractTripleReactorPublisher.class, Runnable.class, ""shutdownHook"");
+
+    public AbstractTripleReactorPublisher() {
+    }
+
+    public AbstractTripleReactorPublisher(Consumer<CallStreamObserver<?>> onSubscribe, Runnable shutdownHook) {
+        this.onSubscribe = onSubscribe;
+        this.shutdownHook = shutdownHook;
+    }
+
+    protected void onSubscribe(final CallStreamObserver<?> subscription) {
+        if (subscription != null && SUBSCRIPTION.compareAndSet(this, null, subscription)) {
+            this.subscription = subscription;
+            if (subscription instanceof ClientStreamObserver<?>) {
+                ((ClientStreamObserver<?>) subscription).disableAutoRequest();
+            } else if (subscription instanceof ServerStreamObserver<?>) {
+                ((ServerStreamObserver<?>) subscription).disableAutoInboundFlowControl();
+            }
+            if (onSubscribe != null) {
+                onSubscribe.accept(subscription);
+            }
+            return;
+        }
+
+        throw new IllegalStateException(getClass().getSimpleName() + "" supports only a single subscription"");
+    }
+
+    @Override
+    public void onNext(T data) {
+        if (isDone || isCancelled) {
+            return;
+        }
+        downstream.onNext(data);
+    }
+
+    @Override
+    public void onError(Throwable throwable) {
+        if (isDone || isCancelled) {
+            return;
+        }
+        downstream.onError(throwable);
+        isDone = true;
+        doPostShutdown();
+    }
+
+    @Override
+    public void onCompleted() {
+        if (isDone || isCancelled) {
+            return;
+        }
+        isDone = true;
+        downstream.onComplete();
+        doPostShutdown();
+    }
+
+    private void doPostShutdown() {
+        Runnable r = shutdownHook;
+        // CAS to confirm shutdownHook will be run only once.
+        if (r != null && SHUTDOWN_HOOK.compareAndSet(this, r, null)) {
+            r.run();
+        }
+    }
+
+    @Override
+    public void subscribe(Subscriber<? super T> subscriber) {
+        if (subscriber == null) {
+            throw new NullPointerException();
+        }
+
+        if (SUBSCRIBED.compareAndSet(false, true)) {
+            subscriber.onSubscribe(this);
+            this.downstream = subscriber;
+            if (isCancelled) {
+                this.downstream = null;
+            }
+        } else {
+            subscriber.onSubscribe(EMPTY_SUBSCRIPTION);
+            subscriber.onError(new IllegalStateException(getClass().getSimpleName() + "" can't be subscribed repeatedly""));
+        }
+    }
+
+    @Override
+    public void request(long l) {
+        if (SUBSCRIBED.get() && CAN_REQUEST.get()) {
+            subscription.request(l >= Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) l);
+        } else {
+            REQUESTED.getAndAdd(this, l);
+        }
+    }
+
+    @Override
+    public void startRequest() {
+        if (CAN_REQUEST.compareAndSet(false, true)) {
+            long count = requested;","[{'comment': 'Is it possible to call request directly？', 'commenter': 'EarthChen'}, {'comment': 'No, in the scenario where the client uses serverStream, the request can only be made after ObserverToClientCallListenerAdapter#onStart is called, otherwise the NPE of TripleClientStream#request will be triggered, because the deframer of TripleClientStream has not been initialized.', 'commenter': 'JooKS-me'}]"
10290,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/reactive/AbstractTripleReactorPublisher.java,"@@ -0,0 +1,190 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri.reactive;
+
+import org.apache.dubbo.rpc.protocol.tri.ClientStreamObserver;
+import org.apache.dubbo.rpc.protocol.tri.SafeRequestObserver;
+import org.apache.dubbo.rpc.protocol.tri.ServerStreamObserver;
+import org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver;
+import org.reactivestreams.Publisher;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLongFieldUpdater;
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+import java.util.function.Consumer;
+
+/**
+ * The middle layer between {@link org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver} and Reactive API. <p>
+ * 1. passing the data received by CallStreamObserver to Reactive consumer <br>
+ * 2. passing the request of Reactive API to CallStreamObserver
+ */
+public abstract class AbstractTripleReactorPublisher<T> implements Publisher<T>, SafeRequestObserver<T>, Subscription {
+
+    private static final Subscription EMPTY_SUBSCRIPTION = new Subscription() {
+        @Override
+        public void cancel() {
+        }
+        @Override
+        public void request(long n) {
+        }
+    };
+
+    private volatile long requested;
+
+    private static final AtomicLongFieldUpdater<AbstractTripleReactorPublisher> REQUESTED =
+        AtomicLongFieldUpdater.newUpdater(AbstractTripleReactorPublisher.class, ""requested"");
+
+    // weather CallStreamObserver#request can be called
+    private final AtomicBoolean CAN_REQUEST = new AtomicBoolean();
+
+    // weather publisher has been subscribed
+    private final AtomicBoolean SUBSCRIBED = new AtomicBoolean();
+
+    private volatile Subscriber<? super T> downstream;
+
+    protected volatile CallStreamObserver<?> subscription;
+
+    private static final AtomicReferenceFieldUpdater<AbstractTripleReactorPublisher, CallStreamObserver> SUBSCRIPTION =
+        AtomicReferenceFieldUpdater.newUpdater(AbstractTripleReactorPublisher.class, CallStreamObserver.class, ""subscription"");
+
+    // cancel status
+    private volatile boolean isCancelled;
+
+    // complete status
+    private volatile boolean isDone;
+
+    // to help bind TripleSubscriber
+    private volatile Consumer<CallStreamObserver<?>> onSubscribe;
+
+    private volatile Runnable shutdownHook;
+
+    @SuppressWarnings(""rawtypes"")
+    private static final AtomicReferenceFieldUpdater<AbstractTripleReactorPublisher, Runnable> SHUTDOWN_HOOK =
+        AtomicReferenceFieldUpdater.newUpdater(AbstractTripleReactorPublisher.class, Runnable.class, ""shutdownHook"");
+
+    public AbstractTripleReactorPublisher() {
+    }
+
+    public AbstractTripleReactorPublisher(Consumer<CallStreamObserver<?>> onSubscribe, Runnable shutdownHook) {
+        this.onSubscribe = onSubscribe;
+        this.shutdownHook = shutdownHook;
+    }
+
+    protected void onSubscribe(final CallStreamObserver<?> subscription) {
+        if (subscription != null && SUBSCRIPTION.compareAndSet(this, null, subscription)) {
+            this.subscription = subscription;
+            if (subscription instanceof ClientStreamObserver<?>) {
+                ((ClientStreamObserver<?>) subscription).disableAutoRequest();","[{'comment': 'Does it feel better to abstract into a unified api?', 'commenter': 'EarthChen'}, {'comment': ""How about let's merge disableAutoRequest into CallStreamObserver?"", 'commenter': 'JooKS-me'}, {'comment': 'Resolved in #10406', 'commenter': 'JooKS-me'}]"
10290,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/reactive/AbstractTripleReactorPublisher.java,"@@ -0,0 +1,190 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri.reactive;
+
+import org.apache.dubbo.rpc.protocol.tri.ClientStreamObserver;
+import org.apache.dubbo.rpc.protocol.tri.SafeRequestObserver;
+import org.apache.dubbo.rpc.protocol.tri.ServerStreamObserver;
+import org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver;
+import org.reactivestreams.Publisher;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLongFieldUpdater;
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+import java.util.function.Consumer;
+
+/**
+ * The middle layer between {@link org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver} and Reactive API. <p>
+ * 1. passing the data received by CallStreamObserver to Reactive consumer <br>
+ * 2. passing the request of Reactive API to CallStreamObserver
+ */
+public abstract class AbstractTripleReactorPublisher<T> implements Publisher<T>, SafeRequestObserver<T>, Subscription {
+
+    private static final Subscription EMPTY_SUBSCRIPTION = new Subscription() {
+        @Override
+        public void cancel() {
+        }
+        @Override
+        public void request(long n) {
+        }
+    };
+
+    private volatile long requested;
+
+    private static final AtomicLongFieldUpdater<AbstractTripleReactorPublisher> REQUESTED =
+        AtomicLongFieldUpdater.newUpdater(AbstractTripleReactorPublisher.class, ""requested"");
+
+    // weather CallStreamObserver#request can be called
+    private final AtomicBoolean CAN_REQUEST = new AtomicBoolean();
+
+    // weather publisher has been subscribed
+    private final AtomicBoolean SUBSCRIBED = new AtomicBoolean();
+
+    private volatile Subscriber<? super T> downstream;
+
+    protected volatile CallStreamObserver<?> subscription;
+
+    private static final AtomicReferenceFieldUpdater<AbstractTripleReactorPublisher, CallStreamObserver> SUBSCRIPTION =
+        AtomicReferenceFieldUpdater.newUpdater(AbstractTripleReactorPublisher.class, CallStreamObserver.class, ""subscription"");
+
+    // cancel status
+    private volatile boolean isCancelled;
+
+    // complete status
+    private volatile boolean isDone;
+
+    // to help bind TripleSubscriber
+    private volatile Consumer<CallStreamObserver<?>> onSubscribe;
+
+    private volatile Runnable shutdownHook;
+
+    @SuppressWarnings(""rawtypes"")
+    private static final AtomicReferenceFieldUpdater<AbstractTripleReactorPublisher, Runnable> SHUTDOWN_HOOK =
+        AtomicReferenceFieldUpdater.newUpdater(AbstractTripleReactorPublisher.class, Runnable.class, ""shutdownHook"");
+
+    public AbstractTripleReactorPublisher() {
+    }
+
+    public AbstractTripleReactorPublisher(Consumer<CallStreamObserver<?>> onSubscribe, Runnable shutdownHook) {
+        this.onSubscribe = onSubscribe;
+        this.shutdownHook = shutdownHook;
+    }
+
+    protected void onSubscribe(final CallStreamObserver<?> subscription) {
+        if (subscription != null && SUBSCRIPTION.compareAndSet(this, null, subscription)) {
+            this.subscription = subscription;
+            if (subscription instanceof ClientStreamObserver<?>) {
+                ((ClientStreamObserver<?>) subscription).disableAutoRequest();
+            } else if (subscription instanceof ServerStreamObserver<?>) {
+                ((ServerStreamObserver<?>) subscription).disableAutoInboundFlowControl();
+            }
+            if (onSubscribe != null) {
+                onSubscribe.accept(subscription);
+            }
+            return;
+        }
+
+        throw new IllegalStateException(getClass().getSimpleName() + "" supports only a single subscription"");
+    }
+
+    @Override
+    public void onNext(T data) {
+        if (isDone || isCancelled) {
+            return;
+        }
+        downstream.onNext(data);
+    }
+
+    @Override
+    public void onError(Throwable throwable) {
+        if (isDone || isCancelled) {
+            return;
+        }
+        downstream.onError(throwable);
+        isDone = true;
+        doPostShutdown();
+    }
+
+    @Override
+    public void onCompleted() {
+        if (isDone || isCancelled) {
+            return;
+        }
+        isDone = true;
+        downstream.onComplete();
+        doPostShutdown();
+    }
+
+    private void doPostShutdown() {
+        Runnable r = shutdownHook;
+        // CAS to confirm shutdownHook will be run only once.
+        if (r != null && SHUTDOWN_HOOK.compareAndSet(this, r, null)) {
+            r.run();
+        }
+    }
+
+    @Override
+    public void subscribe(Subscriber<? super T> subscriber) {
+        if (subscriber == null) {
+            throw new NullPointerException();
+        }
+
+        if (SUBSCRIBED.compareAndSet(false, true)) {
+            subscriber.onSubscribe(this);
+            this.downstream = subscriber;
+            if (isCancelled) {
+                this.downstream = null;
+            }
+        } else {
+            subscriber.onSubscribe(EMPTY_SUBSCRIPTION);","[{'comment': ""I think it's better to discard silently here"", 'commenter': 'EarthChen'}, {'comment': 'ok', 'commenter': 'JooKS-me'}]"
10290,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/reactive/AbstractTripleReactorSubscriber.java,"@@ -0,0 +1,116 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri.reactive;
+
+import org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+import reactor.core.CoreSubscriber;
+import reactor.util.annotation.NonNull;
+
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+
+/**
+ * The middle layer between {@link org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver} and Reactive API. <br>
+ * Passing the data from Reactive producer to CallStreamObserver.
+ */
+public abstract class AbstractTripleReactorSubscriber<T> implements Subscriber<T>, CoreSubscriber<T> {
+
+    private static final Subscription CANCELLED_SUBSCRIPTION = new Subscription() {
+        @Override
+        public void cancel() {}
+        @Override
+        public void request(long n) {}
+    };
+
+    protected volatile CallStreamObserver<T> downstream;
+
+    @SuppressWarnings(""rawtypes"")
+    private static final AtomicReferenceFieldUpdater<AbstractTripleReactorSubscriber, CallStreamObserver> DOWNSTREAM =
+        AtomicReferenceFieldUpdater.newUpdater(AbstractTripleReactorSubscriber.class, CallStreamObserver.class, ""downstream"");
+
+    private volatile Subscription subscription;
+
+    @SuppressWarnings(""rawtypes"")
+    private static final AtomicReferenceFieldUpdater<AbstractTripleReactorSubscriber, Subscription> SUBSCRIPTION =","[{'comment': 'Is it possible not to use the updater?', 'commenter': 'EarthChen'}, {'comment': 'removed', 'commenter': 'JooKS-me'}]"
10290,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/reactive/ServerTripleReactorSubscriber.java,"@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri.reactive;
+
+import org.apache.dubbo.rpc.CancellationContext;
+import org.apache.dubbo.rpc.protocol.tri.CancelableStreamObserver;
+import org.apache.dubbo.rpc.protocol.tri.observer.CallStreamObserver;
+
+/**
+ * The Subscriber in server to passing the data produced by user publisher to responseStream.
+ */
+public class ServerTripleReactorSubscriber<T> extends AbstractTripleReactorSubscriber<T>{
+
+    @Override
+    public void subscribe(CallStreamObserver<T> downstream) {
+        super.subscribe(downstream);
+        if (downstream instanceof CancelableStreamObserver) {
+            CancelableStreamObserver<?> observer = (CancelableStreamObserver<?>) downstream;
+            final CancellationContext context;
+            if (observer.getCancellationContext() == null) {","[{'comment': 'In what scenario is it null？', 'commenter': 'EarthChen'}, {'comment': 'At present, this place is always `null`, and it is additionally judged that it is `not null` to defend against possible changes later.', 'commenter': 'JooKS-me'}]"
10292,dubbo-common/src/main/java/org/apache/dubbo/common/logger/ErrorType.java,"@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.logger;
+
+/**
+ * Represents an error type, which can be displayed by the logger like:
+ * "".... This may be caused by [error cause], go to [URL] to find instructions.""
+ */
+public enum ErrorType {
+
+    // Temporarily empty. The only one entry is for testing.
+    REGISTRY_CENTER_OFFLINE(""registry center offline"", ""http://dubbo.apache.org/"");","[{'comment': '具体报错的信息不要带有官网地址，把官网地址抽成一个静态变量', 'commenter': 'AlbumenJ'}]"
10292,dubbo-common/src/main/java/org/apache/dubbo/common/logger/ErrorType.java,"@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.logger;
+
+/**
+ * Represents an error type, which can be displayed by the logger like:
+ * "".... This may be caused by [error cause], go to [URL] to find instructions.""
+ */
+public enum ErrorType {
+
+    // Temporarily empty. The only one entry is for testing.
+    REGISTRY_CENTER_OFFLINE(""registry center offline"", ""http://dubbo.apache.org/"");
+
+    /**
+     * Error cause.
+     */
+    private final String cause;
+
+    /**
+     * Link to instructions.
+     */
+    private final String errorUrl;","[{'comment': '这里需要有错误码，类似 1-1，1-2 这种（第一位是报错类型，第二位是报错序号）\r\n\r\n报错类型是类似“注册中心”、“路由” 这种', 'commenter': 'AlbumenJ'}, {'comment': 'FAQ链接基于报错码自动生成', 'commenter': 'AlbumenJ'}, {'comment': '需要扩展一个字端在报错的时候可以自定义透出一些信息', 'commenter': 'AlbumenJ'}, {'comment': '“需要扩展一个字端在报错的时候可以自定义透出一些信息” 这个是怎么放来着？\r\n比如这样？ "".... This may be caused by [error cause], go to [URL] to find instructions. [自定义信息]""', 'commenter': 'win120a'}]"
10292,dubbo-common/src/main/java/org/apache/dubbo/common/logger/support/FailsafeErrorTypeAwareLogger.java,"@@ -0,0 +1,160 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.logger.support;
+
+import org.apache.dubbo.common.Version;
+import org.apache.dubbo.common.logger.ErrorType;
+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.utils.NetUtils;
+
+/**
+ * A fail-safe (ignoring exception thrown by logger) wrapper of error type aware logger.
+ */
+public class FailsafeErrorTypeAwareLogger extends FailsafeLogger implements ErrorTypeAwareLogger {
+
+    public FailsafeErrorTypeAwareLogger(Logger logger) {
+        super(logger);
+    }
+
+    private String appendContextMessageWithInstructions(ErrorType errorType, String msg) {
+        return "" [DUBBO] "" + msg + "", dubbo version: "" + Version.getVersion() +","[{'comment': '报错码这里需要输出', 'commenter': 'AlbumenJ'}]"
10292,dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperRegistry.java,"@@ -150,8 +150,8 @@ public void doSubscribe(final URL url, final NotifyListener listener) {
                 String root = toRootPath();
                 boolean check = url.getParameter(CHECK_KEY, false);
                 ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.computeIfAbsent(url, k -> new ConcurrentHashMap<>());
-                ChildListener zkListener = listeners.computeIfAbsent(listener, k -> (parentPath, currentChilds) -> {
-                    for (String child : currentChilds) {
+                ChildListener zkListener = listeners.computeIfAbsent(listener, k -> (parentPath, currentChildren) -> {
+                    for (String child : currentChildren) {
                         child = URL.decode(child);
                         if (!anyServices.contains(child)) {","[{'comment': '无关修改还原回去', 'commenter': 'AlbumenJ'}, {'comment': '不知道怎么就混了进来…… 我并没有动这里……', 'commenter': 'win120a'}]"
10297,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java,"@@ -511,16 +517,20 @@ protected Set<String> getProtocolServiceKeyList(String serviceKey, NotifyListene
     protected class AddressRefreshRetryTask implements Runnable {
         private final RetryServiceInstancesChangedEvent retryEvent;
         private final Semaphore retryPermission;
+        private final int retryCount;
 
-        public AddressRefreshRetryTask(Semaphore semaphore, String serviceName) {
-            this.retryEvent = new RetryServiceInstancesChangedEvent(serviceName);
+        public AddressRefreshRetryTask(Semaphore semaphore, String serviceName, int retryCount) {
+            this.retryEvent = new RetryServiceInstancesChangedEvent(serviceName, retryCount);
             this.retryPermission = semaphore;
+            this.retryCount = retryCount;
         }
 
         @Override
         public void run() {
             retryPermission.release();
-            ServiceInstancesChangedListener.this.onEvent(retryEvent);
+            if (retryCount < 3) {
+                ServiceInstancesChangedListener.this.onEvent(retryEvent);","[{'comment': 'maybe record some detail log is more acceptable', 'commenter': 'wangchengming666'}]"
10297,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java,"@@ -168,8 +168,13 @@ private synchronized void doOnEvent(ServiceInstancesChangedEvent event) {
                     // cancel last retryFuture because only one retryFuture will be canceled at destroy().
                     retryFuture.cancel(true);
                 }
-                retryFuture = scheduler.schedule(new AddressRefreshRetryTask(retryPermission, event.getServiceName()), 10_000L, TimeUnit.MILLISECONDS);
-                logger.warn(""Address refresh try task submitted"");
+
+                int retryCount = 0;
+                if (event instanceof RetryServiceInstancesChangedEvent) {
+                    retryCount = ((RetryServiceInstancesChangedEvent) event).getRetryCount() + 1;
+                }
+","[{'comment': 'Whether the logic for judging whether the number of retries exceeds the maximum value can be placed before executing the schedule task. Not when the task is executed, that is, it is found after 10s that the number of times exceeded\r\n\r\n重试次数是否超过最大值的判断逻辑是否可以放在执行schedule任务前。而非执行任务的时候即10s后才发现超过次数。\r\n\r\n', 'commenter': 'BurningCN'}, {'comment': 'got it', 'commenter': 'chenziqiang666'}]"
10311,dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/MetadataInfoTest.java,"@@ -161,4 +163,26 @@ public void testJsonFormat() {
         System.out.println(JsonUtils.getJson().toJson(metadataInfo2));
 
     }
+
+    @Test
+    public void testCal() {
+        MetadataInfo metadataInfo = new MetadataInfo(""demo"");
+
+        // export normal url again
+        metadataInfo.addService(url);
+
+        metadataInfo.calAndGetRevision();
+
+        metadataInfo.addService(url2);
+
+        metadataInfo.calAndGetRevision();
+
+        metadataInfo.addService(url3);
+
+        metadataInfo.calAndGetRevision();
+
+        JSONObject object = JSON.parseObject(metadataInfo.getContent());","[{'comment': 'Use JsonUtil, prevent directly use fastjson', 'commenter': 'AlbumenJ'}]"
10318,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java,"@@ -60,6 +67,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
 
     @Override
     public void channelActive(ChannelHandlerContext ctx) throws Exception {
+//        NettyChannel ch = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);","[{'comment': 'remove useless code.', 'commenter': 'CrazyHZM'}]"
10318,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java,"@@ -32,21 +36,24 @@
 import java.util.List;
 import java.util.Set;
 
-public class PortUnificationServerHandler extends ByteToMessageDecoder {
+public class NettyPortUnificationServerHandler extends ByteToMessageDecoder {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(
-        PortUnificationServerHandler.class);
+        NettyPortUnificationServerHandler.class);
 
     private final ChannelGroup channels;
 
     private final SslContext sslCtx;
     private final URL url;
+    private final ChannelHandler handler;
     private final boolean detectSsl;
     private final List<WireProtocol> protocols;
 
-    public PortUnificationServerHandler(URL url, SslContext sslCtx, boolean detectSsl,
-        List<WireProtocol> protocols, ChannelGroup channels) {
+    public NettyPortUnificationServerHandler(URL url, SslContext sslCtx, boolean detectSsl,
+                                             List<WireProtocol> protocols, ChannelGroup channels,
+                                             ChannelHandler handler) {
         this.url = url;
+        this.handler = handler;","[{'comment': 'remove useless code.', 'commenter': 'CrazyHZM'}]"
10318,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/PortUnificationExchanger.java,"@@ -28,20 +31,25 @@
 public class PortUnificationExchanger {
 
     private static final Logger log = LoggerFactory.getLogger(PortUnificationExchanger.class);
-    private static final ConcurrentMap<String, PortUnificationServer> servers = new ConcurrentHashMap<>();
+    private static final ConcurrentMap<String, AbstractPortUnificationServer> servers = new ConcurrentHashMap<>();","[{'comment': 'replace `AbstractPortUnificationServer` with `RemotingServer`', 'commenter': 'CrazyHZM'}]"
10318,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/AbstractWireProtocol.java,"@@ -16,14 +16,13 @@
  */
 package org.apache.dubbo.remoting.api;
 
-import io.netty.handler.codec.http2.Http2FrameLogger;
+public abstract class AbstractWireProtocol implements WireProtocol {
 
-import static io.netty.handler.logging.LogLevel.DEBUG;
+    private final ProtocolDetector detector;
 
-public abstract class Http2WireProtocol implements WireProtocol {
-    public static final Http2FrameLogger CLIENT_LOGGER = new Http2FrameLogger(DEBUG, ""H2_CLIENT"");
-    public static final Http2FrameLogger SERVER_LOGGER = new Http2FrameLogger(DEBUG, ""H2_SERVER"");
-    private final ProtocolDetector detector = new Http2ProtocolDetector();
+    protected AbstractWireProtocol(ProtocolDetector detector) {","[{'comment': 'replace `protected` with `public` ', 'commenter': 'CrazyHZM'}]"
10318,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/PortUnificationTransporter.java,"@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.api.pu;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Adaptive;
+import org.apache.dubbo.common.extension.ExtensionScope;
+import org.apache.dubbo.common.extension.SPI;
+import org.apache.dubbo.remoting.ChannelHandler;
+import org.apache.dubbo.remoting.Client;
+import org.apache.dubbo.remoting.Constants;
+import org.apache.dubbo.remoting.RemotingException;
+
+@SPI(value = ""pu_netty"", scope = ExtensionScope.FRAMEWORK)","[{'comment': 'It can be represented by `netty`\r\n', 'commenter': 'CrazyHZM'}]"
10318,dubbo-remoting/dubbo-remoting-netty4/src/test/java/org/apache/dubbo/remoting/transport/netty4/DefaultCodec.java,"@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.transport.netty4;
+
+import org.apache.dubbo.remoting.Channel;
+import org.apache.dubbo.remoting.Codec2;
+import org.apache.dubbo.remoting.buffer.ChannelBuffer;
+
+import java.io.IOException;
+
+public class DefaultCodec implements Codec2 {","[{'comment': 'Why add an empty implementation？', 'commenter': 'EarthChen'}, {'comment': 'super class of AbstractPortUnificationServer need a codec implemention, or throw Exception if it can\'t find. This implemention is to make PortUnificationServer work normal.  \r\n\r\n<img width=""1110"" alt=""image"" src=""https://user-images.githubusercontent.com/47651330/179340317-a02ce626-85fb-4bf2-8727-d7b27f76883f.png"">\r\n', 'commenter': 'TrueAbc'}, {'comment': 'And for now codec of triple is alse an empty implemention. Codec is to make encoding and decoding independent from specific NIO framework. And in future, to make triple protocol independent from netty4.(Maybe a new PortUnificationServer implementing with other NIO framework) we will need to implement a codec for triple. ', 'commenter': 'TrueAbc'}]"
10318,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java,"@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.api.pu;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.remoting.ChannelHandler;
+import org.apache.dubbo.remoting.RemotingException;
+import org.apache.dubbo.remoting.api.WireProtocol;
+import org.apache.dubbo.remoting.transport.AbstractServer;
+
+import java.util.List;
+
+public abstract class AbstractPortUnificationServer extends AbstractServer {
+    private final List<WireProtocol> protocols;
+
+    public AbstractPortUnificationServer(URL url, ChannelHandler handler) throws RemotingException {
+        super(url, handler);
+        this.protocols = ExtensionLoader.getExtensionLoader(WireProtocol.class)","[{'comment': '避免直接使用`ExtensionLoader.getExtensionLoader` 静态方法，通过 scopeModel 去获取', 'commenter': 'AlbumenJ'}]"
10318,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/DefaultPuHandler.java,"@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.api.pu;
+
+import org.apache.dubbo.remoting.Channel;
+import org.apache.dubbo.remoting.ChannelHandler;
+import org.apache.dubbo.remoting.RemotingException;
+
+public class DefaultPuHandler implements ChannelHandler {","[{'comment': '这个类的作用是什么', 'commenter': 'AlbumenJ'}, {'comment': '<img width=""893"" alt=""image"" src=""https://user-images.githubusercontent.com/47651330/179909238-d9d24612-083c-4972-88b6-223fdad2142f.png"">\r\nWhen Protocol want to create a portunificationServer, URL and  ChannelHandler are needed. For triple protocol, we don\'t have this class, so create a defaultPuHandler that do nothing. \r\nAnd  some util tests alse need this.', 'commenter': 'TrueAbc'}]"
10318,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/PortUnificationTransporter.java,"@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.api.pu;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Adaptive;
+import org.apache.dubbo.common.extension.ExtensionScope;
+import org.apache.dubbo.common.extension.SPI;
+import org.apache.dubbo.remoting.ChannelHandler;
+import org.apache.dubbo.remoting.Client;
+import org.apache.dubbo.remoting.Constants;
+import org.apache.dubbo.remoting.RemotingException;
+
+@SPI(value = ""netty"", scope = ExtensionScope.FRAMEWORK)","[{'comment': 'value 去掉', 'commenter': 'AlbumenJ'}]"
10318,dubbo-remoting/dubbo-remoting-netty4/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.remoting.Codec2,"@@ -0,0 +1,2 @@
+tri=org.apache.dubbo.remoting.transport.netty4.DefaultCodec
+empty=org.apache.dubbo.remoting.transport.netty4.DefaultCodec","[{'comment': ""`dubbo-remoting-netty4` module don't depends on triple related content "", 'commenter': 'CrazyHZM'}]"
10338,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/AbstractServiceNameMapping.java,"@@ -60,7 +62,13 @@ public abstract class AbstractServiceNameMapping implements ServiceNameMapping,
 
     public AbstractServiceNameMapping(ApplicationModel applicationModel) {
         this.applicationModel = applicationModel;
-        this.mappingCacheManager = new MappingCacheManager("""",
+        boolean fileCache = true;
+        Optional<ApplicationConfig> application = applicationModel.getApplicationConfigManager().getApplication();
+        if(application.isPresent()) {
+            fileCache = Boolean.TRUE.equals(application.get().getEnableFileCache()) ? true : false;","[{'comment': 'replaced with `Boolean.parseBoolean`', 'commenter': 'AlbumenJ'}, {'comment': 'application.get().getEnableFileCache() type is Boolean，how to use Boolean.parseBoolean', 'commenter': 'owen200008'}]"
10338,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/MappingCacheManager.java,"@@ -36,7 +36,7 @@ public static MappingCacheManager getInstance(ScopeModel scopeModel) {
         return scopeModel.getBeanFactory().getOrRegisterBean(MappingCacheManager.class);
     }
 
-    public MappingCacheManager(String name, ScheduledExecutorService executorService) {
+    public MappingCacheManager(boolean fileCache, String name, ScheduledExecutorService executorService) {","[{'comment': 'rename `fileCache` field to `enableFileCached`', 'commenter': 'AlbumenJ'}, {'comment': 'Sorry, I have made a spelling mistake. The proper filed name is `enableFileCache` which means whether enable file cache or not.', 'commenter': 'AlbumenJ'}, {'comment': 'OK', 'commenter': 'owen200008'}]"
10354,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java,"@@ -76,8 +73,6 @@ public ModuleModel(ApplicationModel applicationModel, boolean isInternal) {
     protected void initialize() {
         super.initialize();
         this.serviceRepository = new ModuleServiceRepository(this);
-        this.moduleConfigManager = new ModuleConfigManager(this);
-        this.moduleConfigManager.initialize();","[{'comment': 'Consistent with `applicationModel`, `ModuleConfigManager` is instantiated and initialized through spi.\r\n和`applicationModel`保持一致，`ModuleConfigManager`通过spi的方式进行实例化以及初始化。', 'commenter': 'BurningCN'}]"
10354,dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java,"@@ -835,11 +845,23 @@ private T injectExtension(T instance) {
                     continue;
                 }
                 /**
-                 * Check {@link DisableInject} to see if we need auto injection for this property
+                 * Check {@link DisableInject} to see if we need auto-injection for this property
                  */
                 if (method.isAnnotationPresent(DisableInject.class)) {
                     continue;
                 }
+
+                // When spiXXX implements ScopeModelAware, ExtensionAccessorAware,
+                // the setXXX of ScopeModelAware and ExtensionAccessorAware does not need to be injected
+                if (method.getDeclaringClass() == ScopeModelAware.class) {
+                    continue;
+                }
+                if (instance instanceof ScopeModelAware || instance instanceof ExtensionAccessorAware) {
+                    if (ignoredInjectMethodsDesc.contains(ReflectUtils.getDesc(method))) {
+                        continue;
+                    }
+                }
+","[{'comment': '第一个if的作用是：一个`spi`实现类/接口 `implements ScopeModelAware`，但是没有重写`ScopeModelAware`的相关方法（直接继承`ScopeModelAware`的`setXXX`方法），则满足该if条件，不需要考虑注入，直接`continue`。\r\n\r\n第二个if的作用是：如果`spi`实现类重写或实现了 `ScopeModelAware`或者`ExtensionAccessorAware` 的 `setXXX`方法，也不需要考虑注入，直接`continue`。', 'commenter': 'BurningCN'}]"
10354,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/FrameworkModel.java,"@@ -123,7 +123,6 @@ protected void onDestroy() {
         // notify destroy and clean framework resources
         // see org.apache.dubbo.config.deploy.FrameworkModelCleaner
         notifyDestroy();
-        checkApplicationDestroy();","[{'comment': 'why remove this?', 'commenter': 'AlbumenJ'}, {'comment': 'checkApplicationDestroy has been called on line 121\r\n![image](https://user-images.githubusercontent.com/43363120/180680575-43055339-0169-4ea6-a700-34a2c312ca77.png)\r\n', 'commenter': 'BurningCN'}]"
10354,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java,"@@ -61,9 +61,6 @@ public ModuleModel(ApplicationModel applicationModel, boolean isInternal) {
         }
 
         initialize();
-        Assert.notNull(serviceRepository, ""ModuleServiceRepository can not be null"");
-        Assert.notNull(moduleConfigManager, ""ModuleConfigManager can not be null"");
-        Assert.assertTrue(moduleConfigManager.isInitialized(), ""ModuleConfigManager can not be initialized"");","[{'comment': 'why remove this line?', 'commenter': 'AlbumenJ'}, {'comment': 'Of course, it can be reserved, but I just want to unify it with `ApplicationModule`.(`ApplicationModule` does not check its `configManager` and  `serviceRepository`)', 'commenter': 'BurningCN'}, {'comment': 'It would be better that add this check to `ApplicationModel`', 'commenter': 'AlbumenJ'}, {'comment': '> It would be better that add this check to `ApplicationModel`\r\n\r\ndone', 'commenter': 'BurningCN'}]"
10356,dubbo-common/src/main/java/org/apache/dubbo/config/AbstractReferenceConfig.java,"@@ -82,6 +83,15 @@ public abstract class AbstractReferenceConfig extends AbstractInterfaceConfig {
      */
     protected String providedBy;
 
+    /**
+     * The service port of the provider, the default is the triple port of the {@link ProtocolConfig#port}.
+     * In mesh mode: by default, dubbo will think that the ports of the consumer and the provider are the same.
+     * If the tri port of the consumer and the provider are inconsistent, please specify the tri port of provider on the consumer side
+     *
+     * @since 3.1.0
+     */
+    protected Integer providerPort;","[{'comment': 'Need to consider the multi-port situation.\r\n', 'commenter': 'CrazyHZM'}]"
10356,dubbo-common/src/main/java/org/apache/dubbo/config/ApplicationConfig.java,"@@ -203,6 +204,12 @@ public class ApplicationConfig extends AbstractConfig {
 
     private Boolean enableEmptyProtection;
 
+    /**
+     * enable mesh mode
+     * @since 3.1.0
+     */
+    private Boolean meshEnable;","[{'comment': '`meshEnable` should be the behavior of the consumer and should be placed in the configuration of the consumer level\r\n', 'commenter': 'CrazyHZM'}]"
10356,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanBuilder.java,"@@ -198,6 +198,11 @@ public ReferenceBeanBuilder setProvidedBy(String providedBy) {
         return this;
     }
 
+    public ReferenceBeanBuilder setProviderPort(Integer providerPort) {
+        attributes.put(ReferenceAttributes.PROVIDER_PORT, providerPort);
+        return this;
+    }
+","[{'comment': 'Remove useless code.', 'commenter': 'CrazyHZM'}]"
10356,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceAttributes.java,"@@ -52,6 +52,8 @@ public interface ReferenceAttributes {
 
     String PROVIDED_BY = ""providedBy"";
 
+    String PROVIDER_PORT = ""providerPort"";
+","[{'comment': 'Remove useless code.', 'commenter': 'CrazyHZM'}]"
10356,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -439,6 +448,65 @@ private T createProxy(Map<String, String> referenceParameters) {
         return (T) proxyFactory.getProxy(invoker, ProtocolUtils.isGeneric(generic));
     }
 
+    /**
+     * if enable mesh mode, handle url.
+     *
+     * @param referenceParameters referenceParameters
+     */
+    private void meshModeHandleUrl(Map<String, String> referenceParameters) {
+        if (!checkMeshConfig(referenceParameters)) {
+            return;
+        }
+        if (StringUtils.isNotEmpty(url)) {
+            // user specified URL, could be peer-to-peer address, or register center's address.
+            if (logger.isInfoEnabled()) {
+                logger.info(""The url already exists, mesh no longer processes url: "" + url);
+            }
+            return;
+        }
+
+        // get pod namespace
+        String podNamespace;
+        if (StringUtils.isEmpty(System.getenv(""POD_NAMESPACE""))) {
+            if (logger.isWarnEnabled()) {
+                logger.warn(""Can not get env variable: POD_NAMESPACE, it may not be running in the K8S environment , "" +
+                        ""finally use 'default' replace"");
+            }
+            podNamespace = ""default"";
+        } else {
+            podNamespace = System.getenv(""POD_NAMESPACE"");
+        }
+
+        // url port, default 80.
+        AtomicInteger port = new AtomicInteger(DEFAULT_MESH_PORT);","[{'comment': 'Why use `AtomicInteger`?', 'commenter': 'CrazyHZM'}]"
10356,dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java,"@@ -546,4 +546,26 @@ public interface CommonConstants {
 
     String PREFER_JSON_FRAMEWORK_NAME = ""dubbo.json-framework.prefer"";
 
+    /**
+     * @since 3.1.0
+     */
+    String MESH_ENABLE = ""mesh-enable"";
+
+    /**
+     * @since 3.1.0
+     */
+    Integer DEFAULT_MESH_PORT = 80;","[{'comment': ""Can we make the default mesh port the same as triple's default port? I think the default `80` port is not helpful for users using Triple, which is probably the most common case."", 'commenter': 'chickenlj'}]"
10361,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/WireProtocol.java,"@@ -28,7 +29,7 @@ public interface WireProtocol {
 
     ProtocolDetector detector();
 
-    void configServerPipeline(URL url, ChannelPipeline pipeline, SslContext sslContext);
+    void configServerPipeline(URL url, ChannelOperator operator);
 
     void configClientPipeline(URL url, ChannelPipeline pipeline, SslContext sslContext);","[{'comment': 'The method should be modified.', 'commenter': 'CrazyHZM'}]"
10361,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/WireProtocol.java,"@@ -28,7 +29,7 @@ public interface WireProtocol {
 
     ProtocolDetector detector();
 
-    void configServerPipeline(URL url, ChannelPipeline pipeline, SslContext sslContext);
+    void configServerPipeline(URL url, ChannelOperator operator);","[{'comment': 'Replace `configServerPipeline` with `configServerProtocolHandler`', 'commenter': 'CrazyHZM'}]"
10361,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/DefaultTriCodec.java,"@@ -16,20 +16,8 @@
  */
 package org.apache.dubbo.rpc.protocol.tri;
 
-import org.apache.dubbo.remoting.Channel;
-import org.apache.dubbo.remoting.Codec2;
-import org.apache.dubbo.remoting.buffer.ChannelBuffer;
-import java.io.IOException;
+import org.apache.dubbo.remoting.api.pu.DefaultCodec;
 
-public class DefaultTriCodec implements Codec2 {
+public class DefaultTriCodec extends DefaultCodec {","[{'comment': ""Don't add repeated classes. `DefaultTriCodec` should be solved when `DefaultCodec` exists."", 'commenter': 'CrazyHZM'}]"
10361,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConfigOperator.java,"@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.transport.netty4;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.remoting.Channel;
+import org.apache.dubbo.remoting.ChannelHandler;
+import org.apache.dubbo.remoting.Codec2;
+import org.apache.dubbo.remoting.api.pu.ChannelHandlerPretender;
+import org.apache.dubbo.remoting.api.pu.ChannelOperator;
+import org.apache.dubbo.remoting.api.pu.DefaultCodec;
+
+import java.net.InetSocketAddress;
+import java.util.List;
+
+public class NettyConfigOperator implements ChannelOperator {
+
+    public NettyConfigOperator(NettyChannel channel, ChannelHandler handler) {
+        this.channel = channel;
+        this.handler = handler;
+    }
+
+    @Override
+    public void configChannelHandler(List<ChannelHandler> handlerList) {
+        if(channel instanceof NettyChannel) {
+            URL url = channel.getUrl();
+            Codec2 codec2 = url.getOrDefaultFrameworkModel().getExtensionLoader(Codec2.class).
+                getExtension(url.getProtocol());
+            if (!(codec2 instanceof DefaultCodec)){
+                NettyCodecAdapter codec = new NettyCodecAdapter(codec2, channel.getUrl(), handler);
+                ((NettyChannel) channel).getNioChannel().pipeline().addLast(
+                    codec.getDecoder()
+                ).addLast(
+                    codec.getEncoder()
+                );
+            }
+
+            for (ChannelHandler handler: handlerList) {
+                if (handler instanceof ChannelHandlerPretender) {
+                    Object realHandler = ((ChannelHandlerPretender) handler).getRealHandler();
+                    if(realHandler instanceof io.netty.channel.ChannelHandler) {
+                        ((NettyChannel) channel).getNioChannel().pipeline().addLast(
+                            (io.netty.channel.ChannelHandler) realHandler
+                        );
+                    }
+                }
+            }
+
+            // triple的codec和channel handler都是default的，不进行任何操作(装饰了一些transporter层的功能),
+            // todo 这里需要区分客户端和服务端
+            if( isClientSide(channel)){
+                //todo 客户端的配置操作
+            }else {
+                NettyServerHandler sh = new NettyServerHandler(channel.getUrl(), handler);
+                ((NettyChannel) channel).getNioChannel().pipeline().addLast(
+                    sh
+                );
+            }
+        }
+    }
+
+    private boolean isClientSide(Channel channel) {
+        InetSocketAddress address = channel.getRemoteAddress();
+        URL url = channel.getUrl();
+        return url.getPort() == address.getPort() &&
+            NetUtils.filterLocalHost(channel.getUrl().getIp())
+                .equals(NetUtils.filterLocalHost(address.getAddress().getHostAddress()));
+    }","[{'comment': '`url.getSide()` can be used to determine whether it is the client.', 'commenter': 'CrazyHZM'}]"
10361,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConfigOperator.java,"@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.transport.netty4;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.remoting.Channel;
+import org.apache.dubbo.remoting.ChannelHandler;
+import org.apache.dubbo.remoting.Codec2;
+import org.apache.dubbo.remoting.api.pu.ChannelHandlerPretender;
+import org.apache.dubbo.remoting.api.pu.ChannelOperator;
+import org.apache.dubbo.remoting.api.pu.DefaultCodec;
+
+import java.net.InetSocketAddress;
+import java.util.List;
+
+public class NettyConfigOperator implements ChannelOperator {
+
+    public NettyConfigOperator(NettyChannel channel, ChannelHandler handler) {
+        this.channel = channel;
+        this.handler = handler;
+    }
+
+    @Override
+    public void configChannelHandler(List<ChannelHandler> handlerList) {
+        if(channel instanceof NettyChannel) {
+            URL url = channel.getUrl();
+            Codec2 codec2 = url.getOrDefaultFrameworkModel().getExtensionLoader(Codec2.class).
+                getExtension(url.getProtocol());
+            if (!(codec2 instanceof DefaultCodec)){
+                NettyCodecAdapter codec = new NettyCodecAdapter(codec2, channel.getUrl(), handler);
+                ((NettyChannel) channel).getNioChannel().pipeline().addLast(
+                    codec.getDecoder()
+                ).addLast(
+                    codec.getEncoder()
+                );
+            }
+
+            for (ChannelHandler handler: handlerList) {
+                if (handler instanceof ChannelHandlerPretender) {
+                    Object realHandler = ((ChannelHandlerPretender) handler).getRealHandler();
+                    if(realHandler instanceof io.netty.channel.ChannelHandler) {
+                        ((NettyChannel) channel).getNioChannel().pipeline().addLast(
+                            (io.netty.channel.ChannelHandler) realHandler
+                        );
+                    }
+                }
+            }
+
+            // triple的codec和channel handler都是default的，不进行任何操作(装饰了一些transporter层的功能),
+            // todo 这里需要区分客户端和服务端
+            if( isClientSide(channel)){
+                //todo 客户端的配置操作","[{'comment': 'Use English description.', 'commenter': 'CrazyHZM'}]"
10361,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConfigOperator.java,"@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.transport.netty4;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.remoting.Channel;
+import org.apache.dubbo.remoting.ChannelHandler;
+import org.apache.dubbo.remoting.Codec2;
+import org.apache.dubbo.remoting.api.pu.ChannelHandlerPretender;
+import org.apache.dubbo.remoting.api.pu.ChannelOperator;
+import org.apache.dubbo.remoting.api.pu.DefaultCodec;
+
+import java.util.List;
+
+public class NettyConfigOperator implements ChannelOperator {
+
+    public NettyConfigOperator(NettyChannel channel, ChannelHandler handler) {
+        this.channel = channel;
+        this.handler = handler;
+    }
+
+    @Override
+    public void configChannelHandler(List<ChannelHandler> handlerList) {
+        if(channel instanceof NettyChannel) {","[{'comment': 'remove useless logic.', 'commenter': 'CrazyHZM'}]"
10361,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConfigOperator.java,"@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.transport.netty4;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.remoting.Channel;
+import org.apache.dubbo.remoting.ChannelHandler;
+import org.apache.dubbo.remoting.Codec2;
+import org.apache.dubbo.remoting.api.pu.ChannelHandlerPretender;
+import org.apache.dubbo.remoting.api.pu.ChannelOperator;
+import org.apache.dubbo.remoting.api.pu.DefaultCodec;
+
+import java.util.List;
+
+public class NettyConfigOperator implements ChannelOperator {
+
+    public NettyConfigOperator(NettyChannel channel, ChannelHandler handler) {
+        this.channel = channel;
+        this.handler = handler;
+    }
+
+    @Override
+    public void configChannelHandler(List<ChannelHandler> handlerList) {
+        if(channel instanceof NettyChannel) {
+            URL url = channel.getUrl();
+            Codec2 codec2 = url.getOrDefaultFrameworkModel().getExtensionLoader(Codec2.class).
+                getExtension(url.getProtocol());
+            if (!(codec2 instanceof DefaultCodec)){
+                NettyCodecAdapter codec = new NettyCodecAdapter(codec2, channel.getUrl(), handler);
+                ((NettyChannel) channel).getNioChannel().pipeline().addLast(
+                    codec.getDecoder()
+                ).addLast(
+                    codec.getEncoder()
+                );
+            }
+
+            for (ChannelHandler handler: handlerList) {
+                if (handler instanceof ChannelHandlerPretender) {
+                    Object realHandler = ((ChannelHandlerPretender) handler).getRealHandler();
+                    if(realHandler instanceof io.netty.channel.ChannelHandler) {
+                        ((NettyChannel) channel).getNioChannel().pipeline().addLast(
+                            (io.netty.channel.ChannelHandler) realHandler
+                        );
+                    }
+                }
+            }
+
+            // todo distinguish between client and server channel
+            if( isClientSide(channel).equalsIgnoreCase(CommonConstants.CONSUMER)){
+                //todo config client channel handler
+            }else if (isClientSide(channel).equalsIgnoreCase(CommonConstants.PROVIDER)){
+                NettyServerHandler sh = new NettyServerHandler(channel.getUrl(), handler);
+                ((NettyChannel) channel).getNioChannel().pipeline().addLast(
+                    sh
+                );
+            }
+        }
+    }
+
+    private String isClientSide(Channel channel) {
+        return channel.getUrl().getSide("""");
+    }","[{'comment': 'The method name should correspond to the method behavior, why not just judge here.\r\n\r\n', 'commenter': 'CrazyHZM'}]"
10361,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConfigOperator.java,"@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.transport.netty4;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.remoting.Channel;
+import org.apache.dubbo.remoting.ChannelHandler;
+import org.apache.dubbo.remoting.Codec2;
+import org.apache.dubbo.remoting.api.pu.ChannelHandlerPretender;
+import org.apache.dubbo.remoting.api.pu.ChannelOperator;
+import org.apache.dubbo.remoting.api.pu.DefaultCodec;
+
+import java.util.List;
+
+public class NettyConfigOperator implements ChannelOperator {
+
+    public NettyConfigOperator(NettyChannel channel, ChannelHandler handler) {
+        this.channel = channel;
+        this.handler = handler;
+    }
+
+    @Override
+    public void configChannelHandler(List<ChannelHandler> handlerList) {
+        if(channel instanceof NettyChannel) {
+            URL url = channel.getUrl();
+            Codec2 codec2 = url.getOrDefaultFrameworkModel().getExtensionLoader(Codec2.class).
+                getExtension(url.getProtocol());
+            if (!(codec2 instanceof DefaultCodec)){
+                NettyCodecAdapter codec = new NettyCodecAdapter(codec2, channel.getUrl(), handler);
+                ((NettyChannel) channel).getNioChannel().pipeline().addLast(
+                    codec.getDecoder()
+                ).addLast(
+                    codec.getEncoder()
+                );
+            }
+
+            for (ChannelHandler handler: handlerList) {
+                if (handler instanceof ChannelHandlerPretender) {
+                    Object realHandler = ((ChannelHandlerPretender) handler).getRealHandler();
+                    if(realHandler instanceof io.netty.channel.ChannelHandler) {
+                        ((NettyChannel) channel).getNioChannel().pipeline().addLast(
+                            (io.netty.channel.ChannelHandler) realHandler
+                        );
+                    }
+                }
+            }
+
+            // todo distinguish between client and server channel
+            if( isClientSide(channel).equalsIgnoreCase(CommonConstants.CONSUMER)){
+                //todo config client channel handler
+            }else if (isClientSide(channel).equalsIgnoreCase(CommonConstants.PROVIDER)){
+                NettyServerHandler sh = new NettyServerHandler(channel.getUrl(), handler);
+                ((NettyChannel) channel).getNioChannel().pipeline().addLast(
+                    sh
+                );
+            }
+        }
+    }
+
+    private String isClientSide(Channel channel) {
+        return channel.getUrl().getSide("""");
+    }
+
+    private final Channel channel;
+    private ChannelHandler handler;","[{'comment': 'Attribute to the front.\r\n', 'commenter': 'CrazyHZM'}]"
10368,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/XdsInitializationException.java,"@@ -0,0 +1,12 @@
+package org.apache.dubbo.registry.xds;","[{'comment': 'add apache license', 'commenter': 'wangchengming666'}, {'comment': 'Thank you for your remind, chengming.', 'commenter': 'chenyanlann'}]"
10368,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/bootstrap/BootstrapperImpl.java,"@@ -0,0 +1,164 @@
+package org.apache.dubbo.registry.xds.util.bootstrap;
+
+import io.envoyproxy.envoy.config.core.v3.Node;
+import io.grpc.ChannelCredentials;
+import io.grpc.internal.JsonParser;
+import io.grpc.internal.JsonUtil;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.registry.xds.XdsInitializationException;
+
+import javax.annotation.Nullable;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+class BootstrapperImpl extends Bootstrapper {
+
+    static final String BOOTSTRAP_PATH_SYS_ENV_VAR = ""GRPC_XDS_BOOTSTRAP"";
+    static String bootstrapPathFromEnvVar = System.getenv(BOOTSTRAP_PATH_SYS_ENV_VAR);
+
+    private static final Logger logger = LoggerFactory.getLogger(BootstrapperImpl.class);
+    private FileReader reader = LocalFileReader.INSTANCE;
+
+    private static final String SERVER_FEATURE_XDS_V3 = ""xds_v3"";
+    private static final String SERVER_FEATURE_IGNORE_RESOURCE_DELETION = ""ignore_resource_deletion"";
+
+    public BootstrapInfo bootstrap() throws XdsInitializationException {
+        String filePath = bootstrapPathFromEnvVar;
+        String fileContent = null;
+        if (filePath != null) {
+            try {
+                fileContent = reader.readFile(filePath);
+            } catch (IOException e) {
+                throw new XdsInitializationException(""Fail to read bootstrap file"", e);
+            }
+        }
+        if (fileContent == null) throw new XdsInitializationException(""Cannot find bootstrap configuration"");
+
+        Map<String, ?> rawBootstrap;
+        try {
+            rawBootstrap = (Map<String, ?>) JsonParser.parse(fileContent);
+        } catch (IOException e) {
+            throw new XdsInitializationException(""Failed to parse JSON"", e);
+        }
+        return bootstrap(rawBootstrap);","[{'comment': '或许你可以在这里对接XdsServiceDiscoveryFactory，然后你看下这个createDiscovery这个方法，里面的doInitialize', 'commenter': 'wangchengming666'}]"
10368,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/bootstrap/BootstrapperImpl.java,"@@ -0,0 +1,180 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.xds.util.bootstrap;
+
+import io.envoyproxy.envoy.config.core.v3.Node;
+import io.grpc.ChannelCredentials;
+import io.grpc.internal.JsonParser;
+import io.grpc.internal.JsonUtil;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.registry.xds.XdsInitializationException;
+
+import javax.annotation.Nullable;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+class BootstrapperImpl extends Bootstrapper {
+
+    static final String BOOTSTRAP_PATH_SYS_ENV_VAR = ""GRPC_XDS_BOOTSTRAP"";
+    static String bootstrapPathFromEnvVar = System.getenv(BOOTSTRAP_PATH_SYS_ENV_VAR);
+
+    private static final Logger logger = LoggerFactory.getLogger(BootstrapperImpl.class);
+    private FileReader reader = LocalFileReader.INSTANCE;
+
+    private static final String SERVER_FEATURE_XDS_V3 = ""xds_v3"";
+    private static final String SERVER_FEATURE_IGNORE_RESOURCE_DELETION = ""ignore_resource_deletion"";
+
+    public BootstrapInfo bootstrap() throws XdsInitializationException {
+        String filePath = bootstrapPathFromEnvVar;
+        String fileContent = null;
+        if (filePath != null) {
+            try {
+                fileContent = reader.readFile(filePath);
+            } catch (IOException e) {
+                throw new XdsInitializationException(""Fail to read bootstrap file"", e);
+            }
+        }
+        if (fileContent == null) throw new XdsInitializationException(""Cannot find bootstrap configuration"");
+
+        Map<String, ?> rawBootstrap;
+        try {
+            rawBootstrap = (Map<String, ?>) JsonParser.parse(fileContent);
+        } catch (IOException e) {
+            throw new XdsInitializationException(""Failed to parse JSON"", e);
+        }
+        return bootstrap(rawBootstrap);
+    }
+
+    @Override
+    BootstrapInfo bootstrap(Map<String, ?> rawData) throws XdsInitializationException {
+        BootstrapInfo.Builder builder = new BootstrapInfoImpl.Builder();
+
+        List<?> rawServerConfigs = JsonUtil.getList(rawData, ""xds_servers"");","[{'comment': '这里用了很多的`?`，是因为类型都是未知的吗，是不是可以考虑用泛型替代呢', 'commenter': 'wangchengming666'}]"
10368,dubbo-xds/src/test/java/org/apache/dubbo/registry/xds/util/bootstrap/BootstrapperTest.java,"@@ -0,0 +1,124 @@
+package org.apache.dubbo.registry.xds.util.bootstrap;
+
+import org.apache.dubbo.registry.xds.XdsInitializationException;
+import org.hamcrest.MatcherAssert;
+
+import java.io.IOException;
+import java.util.List;
+
+import static org.apache.dubbo.registry.xds.util.bootstrap.BootstrapperImpl.BOOTSTRAP_PATH_SYS_ENV_VAR;
+import static org.hamcrest.Matchers.equalTo;
+
+public class BootstrapperTest {","[{'comment': 'use junit', 'commenter': 'wangchengming666'}]"
10368,dubbo-xds/src/test/java/org/apache/dubbo/registry/xds/util/bootstrap/BootstrapperTest.java,"@@ -0,0 +1,124 @@
+package org.apache.dubbo.registry.xds.util.bootstrap;
+
+import org.apache.dubbo.registry.xds.XdsInitializationException;
+import org.hamcrest.MatcherAssert;
+
+import java.io.IOException;
+import java.util.List;
+
+import static org.apache.dubbo.registry.xds.util.bootstrap.BootstrapperImpl.BOOTSTRAP_PATH_SYS_ENV_VAR;
+import static org.hamcrest.Matchers.equalTo;
+
+public class BootstrapperTest {
+    public static void main(String[] args) throws XdsInitializationException {
+        String rawData = ""{\n"" +
+            ""  \""xds_servers\"": [\n"" +
+            ""    {\n"" +
+            ""      \""server_uri\"": \""unix:///etc/istio/proxy/XDS\"",\n"" +
+            ""      \""channel_creds\"": [\n"" +
+            ""        {\n"" +
+            ""          \""type\"": \""insecure\""\n"" +
+            ""        }\n"" +
+            ""      ],\n"" +
+            ""      \""server_features\"": [\n"" +
+            ""        \""xds_v3\""\n"" +
+            ""      ]\n"" +
+            ""    }\n"" +
+            ""  ],\n"" +
+            ""  \""node\"": {\n"" +
+            ""    \""id\"": \""sidecar~172.17.0.4~dubbo-demo-consumer-deployment-grpc-agent-58585cb9cd-gp79p.dubbo-demo~dubbo-demo.svc.cluster.local\"",\n"" +
+            ""    \""metadata\"": {\n"" +
+            ""      \""ANNOTATIONS\"": {\n"" +
+            ""        \""inject.istio.io/templates\"": \""grpc-agent\"",\n"" +
+            ""        \""kubernetes.io/config.seen\"": \""2022-07-19T12:53:29.742565722Z\"",\n"" +
+            ""        \""kubernetes.io/config.source\"": \""api\"",\n"" +
+            ""        \""prometheus.io/path\"": \""/stats/prometheus\"",\n"" +
+            ""        \""prometheus.io/port\"": \""15020\"",\n"" +
+            ""        \""prometheus.io/scrape\"": \""true\"",\n"" +
+            ""        \""proxy.istio.io/config\"": \""{\\\""holdApplicationUntilProxyStarts\\\"": true}\"",\n"" +
+            ""        \""proxy.istio.io/overrides\"": \""{\\\""containers\\\"":[{\\\""name\\\"":\\\""app\\\"",\\\""image\\\"":\\\""gcr.io/istio-testing/app:latest\\\"",\\\""args\\\"":[\\\""--metrics=15014\\\"",\\\""--port\\\"",\\\""18080\\\"",\\\""--tcp\\\"",\\\""19090\\\"",\\\""--xds-grpc-server=17070\\\"",\\\""--grpc\\\"",\\\""17070\\\"",\\\""--grpc\\\"",\\\""17171\\\"",\\\""--port\\\"",\\\""3333\\\"",\\\""--port\\\"",\\\""8080\\\"",\\\""--version\\\"",\\\""v1\\\"",\\\""--crt=/cert.crt\\\"",\\\""--key=/cert.key\\\""],\\\""ports\\\"":[{\\\""containerPort\\\"":17070,\\\""protocol\\\"":\\\""TCP\\\""},{\\\""containerPort\\\"":17171,\\\""protocol\\\"":\\\""TCP\\\""},{\\\""containerPort\\\"":8080,\\\""protocol\\\"":\\\""TCP\\\""},{\\\""name\\\"":\\\""tcp-health-port\\\"",\\\""containerPort\\\"":3333,\\\""protocol\\\"":\\\""TCP\\\""}],\\\""env\\\"":[{\\\""name\\\"":\\\""INSTANCE_IP\\\"",\\\""valueFrom\\\"":{\\\""fieldRef\\\"":{\\\""apiVersion\\\"":\\\""v1\\\"",\\\""fieldPath\\\"":\\\""status.podIP\\\""}}}],\\\""resources\\\"":{},\\\""volumeMounts\\\"":[{\\\""name\\\"":\\\""kube-api-access-2tknx\\\"",\\\""readOnly\\\"":true,\\\""mountPath\\\"":\\\""/var/run/secrets/kubernetes.io/serviceaccount\\\""}],\\\""livenessProbe\\\"":{\\\""tcpSocket\\\"":{\\\""port\\\"":\\\""tcp-health-port\\\""},\\\""initialDelaySeconds\\\"":10,\\\""timeoutSeconds\\\"":1,\\\""periodSeconds\\\"":10,\\\""successThreshold\\\"":1,\\\""failureThreshold\\\"":10},\\\""readinessProbe\\\"":{\\\""httpGet\\\"":{\\\""path\\\"":\\\""/\\\"",\\\""port\\\"":8080,\\\""scheme\\\"":\\\""HTTP\\\""},\\\""initialDelaySeconds\\\"":1,\\\""timeoutSeconds\\\"":1,\\\""periodSeconds\\\"":2,\\\""successThreshold\\\"":1,\\\""failureThreshold\\\"":10},\\\""startupProbe\\\"":{\\\""tcpSocket\\\"":{\\\""port\\\"":\\\""tcp-health-port\\\""},\\\""timeoutSeconds\\\"":1,\\\""periodSeconds\\\"":10,\\\""successThreshold\\\"":1,\\\""failureThreshold\\\"":10},\\\""terminationMessagePath\\\"":\\\""/dev/termination-log\\\"",\\\""terminationMessagePolicy\\\"":\\\""File\\\"",\\\""imagePullPolicy\\\"":\\\""Always\\\"",\\\""securityContext\\\"":{\\\""runAsUser\\\"":1338,\\\""runAsGroup\\\"":1338}},{\\\""name\\\"":\\\""dubbo-demo-consumer\\\"",\\\""image\\\"":\\\""dockeddocking/dubbo:consumer.v1.0\\\"",\\\""command\\\"":[\\\""sh\\\"",\\\""-c\\\"",\\\""java $JAVA_OPTS -jar dubbo-demo-consumer.jar \\\""],\\\""resources\\\"":{},\\\""volumeMounts\\\"":[{\\\""name\\\"":\\\""kube-api-access-2tknx\\\"",\\\""readOnly\\\"":true,\\\""mountPath\\\"":\\\""/var/run/secrets/kubernetes.io/serviceaccount\\\""}],\\\""terminationMessagePath\\\"":\\\""/dev/termination-log\\\"",\\\""terminationMessagePolicy\\\"":\\\""File\\\"",\\\""imagePullPolicy\\\"":\\\""Always\\\""}]}\"",\n"" +
+            ""        \""sidecar.istio.io/rewriteAppHTTPProbers\"": \""false\"",\n"" +
+            ""        \""sidecar.istio.io/status\"": \""{\\\""initContainers\\\"":null,\\\""containers\\\"":[\\\""app\\\"",\\\""dubbo-demo-consumer\\\"",\\\""istio-proxy\\\""],\\\""volumes\\\"":[\\\""workload-socket\\\"",\\\""workload-certs\\\"",\\\""istio-xds\\\"",\\\""istio-data\\\"",\\\""istio-podinfo\\\"",\\\""istio-token\\\"",\\\""istiod-ca-cert\\\""],\\\""imagePullSecrets\\\"":null,\\\""revision\\\"":\\\""default\\\""}\""\n"" +
+            ""      },\n"" +
+            ""      \""APP_CONTAINERS\"": \""app,dubbo-demo-consumer\"",\n"" +
+            ""      \""CLUSTER_ID\"": \""Kubernetes\"",\n"" +
+            ""      \""ENVOY_PROMETHEUS_PORT\"": 15090,\n"" +
+            ""      \""ENVOY_STATUS_PORT\"": 15021,\n"" +
+            ""      \""GENERATOR\"": \""grpc\"",\n"" +
+            ""      \""INSTANCE_IPS\"": \""172.17.0.4\"",\n"" +
+            ""      \""INTERCEPTION_MODE\"": \""REDIRECT\"",\n"" +
+            ""      \""ISTIO_PROXY_SHA\"": \""2b6009118109b480e1d5abf3188fd7d9c0c0acf0\"",\n"" +
+            ""      \""ISTIO_VERSION\"": \""1.14.1\"",\n"" +
+            ""      \""LABELS\"": {\n"" +
+            ""        \""app\"": \""dubbo-demo-consumer-dev\"",\n"" +
+            ""        \""pod-template-hash\"": \""58585cb9cd\"",\n"" +
+            ""        \""service.istio.io/canonical-name\"": \""dubbo-demo-consumer-dev\"",\n"" +
+            ""        \""service.istio.io/canonical-revision\"": \""v1\"",\n"" +
+            ""        \""version\"": \""v1\""\n"" +
+            ""      },\n"" +
+            ""      \""MESH_ID\"": \""cluster.local\"",\n"" +
+            ""      \""NAME\"": \""dubbo-demo-consumer-deployment-grpc-agent-58585cb9cd-gp79p\"",\n"" +
+            ""      \""NAMESPACE\"": \""dubbo-demo\"",\n"" +
+            ""      \""OWNER\"": \""kubernetes://apis/apps/v1/namespaces/dubbo-demo/deployments/dubbo-demo-consumer-deployment-grpc-agent\"",\n"" +
+            ""      \""PILOT_SAN\"": [\n"" +
+            ""        \""istiod.istio-system.svc\""\n"" +
+            ""      ],\n"" +
+            ""      \""POD_PORTS\"": \""[{\\\""containerPort\\\"":17070,\\\""protocol\\\"":\\\""TCP\\\""},{\\\""containerPort\\\"":17171,\\\""protocol\\\"":\\\""TCP\\\""},{\\\""containerPort\\\"":8080,\\\""protocol\\\"":\\\""TCP\\\""},{\\\""name\\\"":\\\""tcp-health-port\\\"",\\\""containerPort\\\"":3333,\\\""protocol\\\"":\\\""TCP\\\""}]\"",\n"" +
+            ""      \""PROV_CERT\"": \""var/run/secrets/istio/root-cert.pem\"",\n"" +
+            ""      \""PROXY_CONFIG\"": {\n"" +
+            ""        \""binaryPath\"": \""/usr/local/bin/envoy\"",\n"" +
+            ""        \""concurrency\"": 2,\n"" +
+            ""        \""configPath\"": \""./etc/istio/proxy\"",\n"" +
+            ""        \""controlPlaneAuthPolicy\"": \""MUTUAL_TLS\"",\n"" +
+            ""        \""discoveryAddress\"": \""istiod.istio-system.svc:15012\"",\n"" +
+            ""        \""drainDuration\"": \""45s\"",\n"" +
+            ""        \""holdApplicationUntilProxyStarts\"": true,\n"" +
+            ""        \""parentShutdownDuration\"": \""60s\"",\n"" +
+            ""        \""proxyAdminPort\"": 15000,\n"" +
+            ""        \""serviceCluster\"": \""istio-proxy\"",\n"" +
+            ""        \""statNameLength\"": 189,\n"" +
+            ""        \""statusPort\"": 15020,\n"" +
+            ""        \""terminationDrainDuration\"": \""5s\"",\n"" +
+            ""        \""tracing\"": {\n"" +
+            ""          \""zipkin\"": {\n"" +
+            ""            \""address\"": \""zipkin.istio-system:9411\""\n"" +
+            ""          }\n"" +
+            ""        }\n"" +
+            ""      },\n"" +
+            ""      \""SERVICE_ACCOUNT\"": \""default\"",\n"" +
+            ""      \""WORKLOAD_NAME\"": \""dubbo-demo-consumer-deployment-grpc-agent\""\n"" +
+            ""    },\n"" +
+            ""    \""locality\"": {},\n"" +
+            ""    \""UserAgentVersionType\"": null\n"" +
+            ""  },\n"" +
+            ""  \""certificate_providers\"": {\n"" +
+            ""    \""default\"": {\n"" +
+            ""      \""plugin_name\"": \""file_watcher\"",\n"" +
+            ""      \""config\"": {\n"" +
+            ""        \""certificate_file\"": \""/var/lib/istio/data/cert-chain.pem\"",\n"" +
+            ""        \""private_key_file\"": \""/var/lib/istio/data/key.pem\"",\n"" +
+            ""        \""ca_certificate_file\"": \""/var/lib/istio/data/root-cert.pem\"",\n"" +
+            ""        \""refresh_interval\"": \""900s\""\n"" +
+            ""      }\n"" +
+            ""    }\n"" +
+            ""  },\n"" +
+            ""  \""server_listener_resource_name_template\"": \""xds.istio.io/grpc/lds/inbound/%s\""\n"" +
+            ""}"";
+        BootstrapperImpl.bootstrapPathFromEnvVar = """";
+        BootstrapperImpl bootstrapper = new BootstrapperImpl();
+        bootstrapper.setFileReader(createFileReader(rawData));
+        Bootstrapper.BootstrapInfo info = bootstrapper.bootstrap();
+        List<Bootstrapper.ServerInfo> serverInfoList = info.servers();
+        MatcherAssert.assertThat(serverInfoList.get(0).target(), equalTo(""unix:///etc/istio/proxy/XDS""));","[{'comment': 'use Assertions.assertEquals', 'commenter': 'wangchengming666'}, {'comment': 'Thank you, chengming, I have involved Junit.', 'commenter': 'chenyanlann'}]"
10368,dubbo-xds/pom.xml,"@@ -84,6 +84,18 @@
             <groupId>org.bouncycastle</groupId>
             <artifactId>bcprov-ext-jdk15on</artifactId>
         </dependency>
+        <dependency>","[{'comment': 'in dubbo-parent has org.junit.jupiter', 'commenter': 'wangchengming666'}, {'comment': 'Thank you, chengming, I have changed this.', 'commenter': 'chenyanlann'}]"
10370,dubbo-common/src/main/java/org/apache/dubbo/common/json/impl/AbstractJSONImpl.java,"@@ -0,0 +1,222 @@
+package org.apache.dubbo.common.json.impl;","[{'comment': 'Please add ASF license header for this file', 'commenter': 'AlbumenJ'}, {'comment': 'ok', 'commenter': 'chenziqiang666'}]"
10380,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java,"@@ -104,6 +104,13 @@ public void afterPropertiesSet() throws Exception {
         moduleModel.getDeployer().setPending();
     }
 
+    @Override
+    public void unexport() {
+        ModuleModel moduleModel = DubboBeanUtils.getModuleModel(applicationContext);
+        moduleModel.getConfigManager().removeConfig(this);","[{'comment': 'ServiceBean/Config has removed from configManger in here \r\n![image](https://user-images.githubusercontent.com/43363120/181440418-de42482c-5501-4f0e-951b-bd2dffedf75c.png)\r\n', 'commenter': 'BurningCN'}, {'comment': 'it only destroy call', 'commenter': 'owen200008'}, {'comment': '你可以试下 unexport 然后再export 同样的service', 'commenter': 'owen200008'}, {'comment': '正常就应该是在ModuleModel销毁的时候对configManger做清空操作的。\r\nServiceConfig的export和unexport内部都不应该对configManager进行添加或者移除操作。\r\n', 'commenter': 'BurningCN'}, {'comment': '应该这个词有点太随便了\r\n当一个ref unexport的时候\r\n1. config里面是否还要保留着这个ref相关的信息\r\n2. 因为保存了相关的信息那么同样接口的ref就无法再创建了，是否合适\r\n\r\n当然这个都是要跟设计有关，但是从来没说过一个service和ref是单例的，只有在destroy才需要销毁，至少2.7.x的service和ref的生命周期是跟unexport相关的', 'commenter': 'owen200008'}, {'comment': '我想了下，我刚才的理解还是有些偏差的。刚看了下每次ReferenceConfig#destroy的时候也会从configManager移除，所以对应ServiceConfig#unexport应该也有。不过我想这个逻辑是不是放在ServiceConfig里，而不是ServiceBean里？（比如用户直接以api的方式配置一个ServiceConfig，压根就没用spring相关的）', 'commenter': 'BurningCN'}, {'comment': '写这里原因是，加入是bean做的，所以删除也由它管理', 'commenter': 'owen200008'}, {'comment': '可以看如下demo，不是通过ServiceBean的方式，直接是ServiceConfig。\r\n我上面表达的意思是Spring配置方式不是ServiceBean/Config唯一加入configManager的方式。如果按照如下这配置方式，按照目前pr的修改逻辑，在unexport就不会从configManager移除了。\r\n\r\n![image](https://user-images.githubusercontent.com/43363120/181582137-12c2bfab-aa4d-4aa1-871c-7b0b85724956.png)\r\n', 'commenter': 'BurningCN'}, {'comment': '加入和删除一起迁移到父类我觉得是OK的\r\n目前还是保持统一在bean中加入和删除更合适', 'commenter': 'owen200008'}, {'comment': '> 应该这个词有点太随便了 当一个ref unexport的时候\r\n> \r\n> 1. config里面是否还要保留着这个ref相关的信息\r\n> 2. 因为保存了相关的信息那么同样接口的ref就无法再创建了，是否合适\r\n> \r\n> 当然这个都是要跟设计有关，但是从来没说过一个service和ref是单例的，只有在destroy才需要销毁，至少2.7.x的service和ref的生命周期是跟unexport相关的\r\n\r\n我又想了下，针对你上面提到的。在ModuleDeployer销毁的时候，在每个ServiceConfig#unexport发生之后就立马做了configManager的remove操作（所以你说的12情况都不存在），只是这个时机没有放在unexport里面。而且目前unexport操作目前基本都是在ModuleDeployer销毁时调用的，除非说使用者自己去执行了unexport，才出现你说的情况，但一般使用者不会去这么做。\r\n\r\n目前的设计是执行export之前，ServiceConfig已经加入到了configManager，unexport之后才将ServiceConfig从configManager移除，即export和unexport内部都没有关注对configManager的添加或移除操作。\r\n\r\n不过按照目前的修改，将ServiceConfig的从configManager的移除逻辑放在unexport方法中也没问题。\r\n', 'commenter': 'BurningCN'}, {'comment': '这里需要考虑下循环依赖的问题，ModuleModel.destroy -> foreach -> ServiceBean.unexport -> ModuleModel.remove', 'commenter': 'AlbumenJ'}]"
10395,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java,"@@ -170,6 +171,6 @@ public void configClientPipeline(URL url, ChannelPipeline pipeline, SslContext s
             .build();
         final Http2MultiplexHandler handler = new Http2MultiplexHandler(
             new TripleClientHandler(frameworkModel));
-        pipeline.addLast(codec, handler, new TripleTailHandler());
+        pipeline.addLast(new TelnetHeaderConsumer(), codec, handler, new TripleTailHandler());","[{'comment': 'why add it here？', 'commenter': 'EarthChen'}, {'comment': ""For a telnet connection,  pu server need to send prompt message to the client(pu server don't know client protocol type, may triple, may telnet of qos). If client is a triple client, this decoder is responsible for consume prompt message which is useless for triple client(or will cause wrong tcp stream unpack).  \r\n\r\n- I am investigating telnet protocol and telnet command so that client could send some message to server once connected. "", 'commenter': 'TrueAbc'}, {'comment': 'why `pu server need to send prompt message to the client`?', 'commenter': 'EarthChen'}]"
10395,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java,"@@ -102,6 +104,14 @@ private void startQosServer(URL url) {
                     ""dubbo.properties or XML/spring-boot configuration."");
                 return;
             }
+            // frameModel of mock url is null
+            FrameworkModel frameworkModel1= url.getOrDefaultFrameworkModel();
+            if (frameworkModel1 != null) {
+                WireProtocol protocol1 = frameworkModel1.getExtensionLoader(WireProtocol.class).getExtension(""qos"");
+                if(protocol1 != null) {
+                    ((QosWireProtocol) protocol1).SetQosEnable(true);","[{'comment': 'This will cause it to be turned on forever.\r\n', 'commenter': 'CrazyHZM'}, {'comment': ""if qosEnable is not true, this logic won't work. and default flag for qoswireProtocol to enable qos detector in pu server is false."", 'commenter': 'TrueAbc'}]"
10395,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java,"@@ -102,6 +104,14 @@ private void startQosServer(URL url) {
                     ""dubbo.properties or XML/spring-boot configuration."");
                 return;
             }
+            // frameModel of mock url is null
+            FrameworkModel frameworkModel1= url.getOrDefaultFrameworkModel();","[{'comment': '`frameworkModel` already exists\r\n', 'commenter': 'CrazyHZM'}]"
10395,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/pu/QosDetector.java,"@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.qos.pu;
+
+import org.apache.dubbo.remoting.api.ProtocolDetector;
+import org.apache.dubbo.remoting.buffer.ChannelBuffer;
+import org.apache.dubbo.rpc.model.FrameworkModel;
+
+public class QosDetector implements ProtocolDetector {
+
+    private final QosHTTP1Detector qosHTTP1Detector = new QosHTTP1Detector();
+    private final TelnetDetector telnetDetector = new TelnetDetector();
+    private boolean QosEnableFlag = false;
+
+    public void setQosEnableFlag(boolean qosEnableFlag) {
+        QosEnableFlag = qosEnableFlag;
+    }
+
+    @Override
+    public Result detect(ChannelBuffer in) {
+        if(!QosEnableFlag) {
+            return Result.UNRECOGNIZED;
+        }
+        Result h1Res = qosHTTP1Detector.detect(in);
+        if(h1Res.equals(Result.RECOGNIZED)) {
+            return h1Res;
+        }
+        Result telRes = telnetDetector.detect(in);
+        if(telRes.equals(Result.RECOGNIZED)) {
+            return telRes;
+        }
+        if(h1Res.equals(Result.NEED_MORE_DATA) || telRes.equals(Result.NEED_MORE_DATA)) {
+            return Result.NEED_MORE_DATA;
+        }
+        return Result.UNRECOGNIZED;
+    }
+
+    public void setFrameWorkModel(FrameworkModel frameworkModel) {
+        this.telnetDetector.setFrameworkModel(frameworkModel);
+    }","[{'comment': 'implements `ScopeModelAware`', 'commenter': 'CrazyHZM'}, {'comment': 'This interface is implemeted by QosWireProtocol. And in QosWireProtocol of this method, it invokes the method of QosDetector.  Just like triple protocol, TripleHttp2Protocol(WireProtocol) implements this interface.', 'commenter': 'TrueAbc'}, {'comment': 'move to constructor', 'commenter': 'AlbumenJ'}]"
10395,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/pu/TelnetDetector.java,"@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.qos.pu;
+
+import org.apache.dubbo.qos.command.BaseCommand;
+import org.apache.dubbo.qos.command.CommandContext;
+import org.apache.dubbo.qos.command.decoder.TelnetCommandDecoder;
+import org.apache.dubbo.remoting.api.ProtocolDetector;
+import org.apache.dubbo.remoting.buffer.ChannelBuffer;
+import org.apache.dubbo.rpc.model.FrameworkModel;
+
+import io.netty.util.CharsetUtil;
+
+
+public class TelnetDetector implements ProtocolDetector {
+
+    private FrameworkModel frameworkModel;
+    private final int MaxSize = 2048;
+
+    public void setFrameworkModel(FrameworkModel frameworkModel) {
+        this.frameworkModel = frameworkModel;
+    }
+
+    @Override
+    public Result detect(ChannelBuffer in) {
+        if (in.readableBytes() >= MaxSize) {
+            return Result.UNRECOGNIZED;
+        }
+        // if no \n is found and in.len() is ok, NEED_MORE_DATA
+        ChannelBuffer back = in.copy();
+        byte[] backBytes = new byte[back.readableBytes()];
+        back.getBytes(back.readerIndex(), backBytes);
+
+        String s = new String(backBytes, CharsetUtil.UTF_8);
+        s = s.trim(); // trim /r/n to let parser work for the input","[{'comment': 'Comment code style should be unified.\r\n', 'commenter': 'CrazyHZM'}]"
10395,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/pu/TelnetDetector.java,"@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.qos.pu;
+
+import org.apache.dubbo.qos.command.BaseCommand;
+import org.apache.dubbo.qos.command.CommandContext;
+import org.apache.dubbo.qos.command.decoder.TelnetCommandDecoder;
+import org.apache.dubbo.remoting.api.ProtocolDetector;
+import org.apache.dubbo.remoting.buffer.ChannelBuffer;
+import org.apache.dubbo.remoting.buffer.ChannelBuffers;
+import org.apache.dubbo.remoting.buffer.HeapChannelBuffer;
+import org.apache.dubbo.rpc.model.FrameworkModel;
+
+import io.netty.util.CharsetUtil;
+
+import static java.lang.Math.min;
+
+
+public class TelnetDetector implements ProtocolDetector {
+
+    private FrameworkModel frameworkModel;
+    private final int MaxSize = 2048;
+    private final ChannelBuffer AytPreface = new HeapChannelBuffer(new byte[]{(byte) 0xff, (byte) 0xf6});
+
+    public void setFrameworkModel(FrameworkModel frameworkModel) {
+        this.frameworkModel = frameworkModel;
+    }","[{'comment': 'move to constructor', 'commenter': 'AlbumenJ'}]"
10413,dubbo-registry/dubbo-registry-multiple/src/test/java/org/apache/dubbo/registry/multiple/MultipleRegistry2S2RTest.java,"@@ -144,8 +145,7 @@ public void testSubscription() throws InterruptedException {
 
         String path = ""/dubbo/"" + SERVICE2_NAME + ""/providers"";
         List<String> providerList = zookeeperClient.getChildren(path);
-        Assertions.assertTrue(!providerList.isEmpty());
-        System.out.println(providerList.get(0));","[{'comment': 'System.out is useless in unit test. So remove this.', 'commenter': 'AlbumenJ'}, {'comment': 'ok', 'commenter': 'chenziqiang666'}]"
10414,README.md,"@@ -10,7 +10,8 @@
 [![Twitter Follow](https://img.shields.io/twitter/follow/ApacheDubbo.svg?label=Follow&style=social&logoWidth=0)](https://twitter.com/intent/follow?screen_name=ApacheDubbo)
 [![Gitter](https://badges.gitter.im/alibaba/dubbo.svg)](https://gitter.im/alibaba/dubbo?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)
 
-Apache Dubbo is a high-performance, Java-based open-source RPC framework. Please visit the [official site](http://dubbo.apache.org) for the quick start guide and documentation, as well as the [wiki](https://github.com/apache/dubbo/wiki) for news, FAQ, and release notes.
+Apache Dubbo is a high-performance, Java-based open-source RPC framework. Please visit the [official site](http://dubbo.apache.org) for 
+the quick start guide and documentation, as well as the [wiki](https://github.com/apache/dubbo/wiki) for news, FAQ, and release notes.","[{'comment': 'why change this line', 'commenter': 'AlbumenJ'}]"
10414,dubbo-common/src/main/java/org/apache/dubbo/common/concurrent/Rejector.java,"@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.concurrent;
+
+import org.apache.dubbo.common.threadpool.MemorySafeLinkedBlockingQueue;
+
+/**
+ * RejectHandler, it works when you need to custom reject action in {@link MemorySafeLinkedBlockingQueue}.
+ *
+ * @see AbortPolicy
+ * @see DiscardPolicy
+ * @see DiscardOldestPolicy
+ */
+public interface Rejector<E> {
+
+    /**
+     * Method that may be invoked by a {@link MemorySafeLinkedBlockingQueue} when {@link MemorySafeLinkedBlockingQueue#hasRemainedMemory}
+     * return true. This may occur when no more memory are available because their bounds would be exceeded.
+     *
+     * <p>In the absence of other alternatives, the method may throw an unchecked
+     * {@link RejectException}, which will be propagated to the caller.
+     *
+     * @param e     the element requested to be added
+     * @param queue the queue attempting to add this element
+     *
+     * @throws RejectException if there is no more memory
+     */
+    void reject(E e, MemorySafeLinkedBlockingQueue<E> queue);","[{'comment': '`MemorySafeLinkedBlockingQueue` => `Queue` would be better?', 'commenter': 'AlbumenJ'}, {'comment': 'if there is no more memory will be throw RejectException', 'commenter': 'TigerTurbo'}, {'comment': ""I mean it's better to change the signature of this function to `void reject(E e, Queue<E> queue)`. The `Rejector` here should not be coupled with actual queue types like `MemorySafeLinkedBlockingQueue`."", 'commenter': 'AlbumenJ'}]"
10414,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/MemorySafeLinkedBlockingQueue.java,"@@ -69,6 +78,15 @@ public int getMaxFreeMemory() {
         return maxFreeMemory;
     }
 
+    /**
+     * set the rejector.
+     *
+     * @param rejector the rejector
+     */
+    public void setRejector(final Rejector<E> rejector) {
+        this.rejector = rejector;
+    }","[{'comment': 'How can the user change this field?', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'TigerTurbo'}, {'comment': 'new出来这个队列，再set进去，如下图所示\r\n![image](https://user-images.githubusercontent.com/20652962/183797095-c82e5d6e-d306-4075-a4d5-073a3b6ec220.png)\r\n', 'commenter': 'TigerTurbo'}]"
10431,dubbo-filter/dubbo-filter-validation/src/main/java/org/apache/dubbo/validation/support/jvalidation/JValidator.java,"@@ -290,6 +290,8 @@ public void validate(String methodName, Class<?>[] parameterTypes, Object[] argu
                 logger.info(""Failed to validate service: "" + clazz.getName() + "", method: "" + methodName + "", cause: "" + violations);
                 throw new ConstraintViolationException(""Failed to validate service: "" + clazz.getName() + "", method: "" + methodName + "", cause: "" + violations, violations);
             }
+        } catch (ConstraintViolationException e) {
+            throw e;","[{'comment': '`javax.validation.ConstraintViolationException` might have potential serialization issue. Should be converted.', 'commenter': 'AlbumenJ'}]"
10434,dubbo-filter/dubbo-filter-validation/src/main/java/org/apache/dubbo/validation/support/jvalidation/JValidator.java,"@@ -275,30 +275,30 @@ public void validate(String methodName, Class<?>[] parameterTypes, Object[] argu
             groups.add(1, clazz);
 
             // convert list to array
-            Class<?>[] classgroups = groups.toArray(new Class[groups.size()]);
+            Class<?>[] classGroups = groups.toArray(new Class[groups.size()]);
 
             Object parameterBean = getMethodParameterBean(clazz, method, arguments);
             if (parameterBean != null) {
-                violations.addAll(validator.validate(parameterBean, classgroups ));
+                violations.addAll(validator.validate(parameterBean, classGroups));
             }
 
             for (Object arg : arguments) {
-                validate(violations, arg, classgroups);
-            }
-
-            if (!violations.isEmpty()) {
-                logger.info(""Failed to validate service: "" + clazz.getName() + "", method: "" + methodName + "", cause: "" + violations);
-                throw new ConstraintViolationException(""Failed to validate service: "" + clazz.getName() + "", method: "" + methodName + "", cause: "" + violations, violations);
+                validate(violations, arg, classGroups);
             }
         } catch (ValidationException e) {
             // only use exception's message to avoid potential serialization issue
             throw new ValidationException(e.getMessage());","[{'comment': '`javax.validation.ConstraintViolationException` might have potential serialization issue. Should be converted.', 'commenter': 'AlbumenJ'}]"
10456,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java,"@@ -97,7 +97,7 @@ public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
                 String generic = inv.getAttachment(GENERIC_KEY);
 
                 if (StringUtils.isBlank(generic)) {
-                    generic = RpcContext.getClientAttachment().getAttachment(GENERIC_KEY);
+                    generic = RpcContext.getServerAttachment().getAttachment(GENERIC_KEY);
                 }","[{'comment': '这段逻辑应该是为了适配之前 http/hessian 协议的实现的，由于老的实现是直接用的 RpcContext.getContext().setAttachment(GENERIC_KEY, xxx) 来配置的，所以这个修改后会影响正常使用。最好这里是能有一个 fallback 的逻辑，从 invocation => server attachment => client attachment。', 'commenter': 'AlbumenJ'}, {'comment': 'OK~', 'commenter': 'liufeiyu1002'}]"
10474,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java,"@@ -49,16 +53,18 @@ public class NettyPortUnificationServerHandler extends ByteToMessageDecoder {
     private final ChannelHandler handler;
     private final boolean detectSsl;
     private final List<WireProtocol> protocols;
+    private Map<String, Channel> dubboChannels;","[{'comment': 'The duties of `dubboChannels` and `ChannelGroup` are the same. Need to consider merging.', 'commenter': 'CrazyHZM'}, {'comment': 'dubboChannels can make pu server manage channels defined in dubbo, Default Group channel have ability of reconnect.  Both  are needed, i just adjust NettyChannel and merge them as dubboChannels.', 'commenter': 'TrueAbc'}]"
10474,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboWireProtocol.java,"@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.dubbo;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.remoting.ChannelHandler;
+import org.apache.dubbo.remoting.api.AbstractWireProtocol;
+import org.apache.dubbo.remoting.api.pu.ChannelOperator;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@Activate
+public class DubboWireProtocol extends AbstractWireProtocol {
+    public DubboWireProtocol() {
+        super(new DubboDetector());
+    }
+
+
+    @Override
+    public void configServerProtocolHandler(URL url, ChannelOperator operator) {
+        List<ChannelHandler> handlers = new ArrayList<>();
+        operator.configChannelHandler(handlers);","[{'comment': 'Add comment why is the handler empty', 'commenter': 'CrazyHZM'}]"
10481,dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java,"@@ -398,7 +400,7 @@ private CtConstructor getCtConstructor(Constructor<?> c) throws NotFoundExceptio
         return getCtClass(c.getDeclaringClass()).getConstructor(ReflectUtils.getDesc(c));
     }
 
-    public static interface DC {
+    public interface DC {","[{'comment': 'do not modify this line', 'commenter': 'AlbumenJ'}, {'comment': ""done\r\nI don't know why some ci were cancelled, can you help to re-trigger it?\r\n"", 'commenter': 'BurningCN'}]"
10498,dubbo-common/src/main/java/org/apache/dubbo/config/annotation/DubboReference.java,"@@ -63,6 +63,7 @@
  * }
  * </pre>
  *
+ * @author 15841","[{'comment': 'remove author tag, thx', 'commenter': 'AlbumenJ'}]"
10499,dubbo-common/src/main/java/org/apache/dubbo/common/constants/MetricsConstants.java,"@@ -20,9 +20,87 @@ public interface MetricsConstants {
 
     String PROTOCOL_PROMETHEUS = ""prometheus"";
 
-    String AGGREGATION_ENABLE = ""aggregation.enable"";
+    String TAG_IP = ""ip"";
 
-    String AGGREGATION_BUCKET_NUM = ""aggregation.bucket.num"";
+    String TAG_HOSTNAME = ""hostname"";
 
-    String AGGREGATION_TIME_WINDOW_SECONDS = ""aggregation.time.window.seconds"";
+    String TAG_APPLICATION_NAME = ""application.name"";
+
+    String TAG_INTERFACE_KEY = ""interface"";
+
+    String TAG_METHOD_KEY = ""method"";
+
+    String TAG_GROUP_KEY = ""group"";
+
+    String TAG_VERSION_KEY = ""version"";
+
+    String ENABLE_JVM_METRICS_KEY = ""enable.jvm.metrics"";
+
+    String AGGREGATION_COLLECTOR_KEY = ""aggregation"";
+
+    String AGGREGATION_ENABLED_KEY = ""aggregation.enabled"";
+
+    String AGGREGATION_BUCKET_NUM_KEY = ""aggregation.bucket.num"";
+
+    String AGGREGATION_TIME_WINDOW_SECONDS_KEY = ""aggregation.time.window.seconds"";
+
+    String PROMETHEUS_EXPORTER_ENABLED_KEY = ""prometheus.exporter.enabled"";
+
+    String PROMETHEUS_EXPORTER_ENABLE_HTTP_SERVICE_DISCOVERY_KEY = ""prometheus.exporter.enable.http.service.discovery"";
+
+    String PROMETHEUS_EXPORTER_HTTP_SERVICE_DISCOVERY_URL_KEY = ""prometheus.exporter.http.service.discovery.url"";
+
+    String PROMETHEUS_EXPORTER_METRICS_PORT_KEY = ""prometheus.exporter.metrics.port"";
+
+    String PROMETHEUS_EXPORTER_METRICS_PATH_KEY = ""prometheus.exporter.metrics.path"";
+
+    String PROMETHEUS_PUSHGATEWAY_ENABLED_KEY = ""prometheus.pushgateway.enabled"";
+
+    String PROMETHEUS_PUSHGATEWAY_BASE_URL_KEY = ""prometheus.pushgateway.base.url"";
+
+    String PROMETHEUS_PUSHGATEWAY_USERNAME_KEY = ""prometheus.pushgateway.username"";
+
+    String PROMETHEUS_PUSHGATEWAY_PASSWORD_KEY = ""prometheus.pushgateway.password"";
+
+    String PROMETHEUS_PUSHGATEWAY_PUSH_INTERVAL_KEY = ""prometheus.pushgateway.push.interval"";
+
+    String PROMETHEUS_PUSHGATEWAY_JOB_KEY = ""prometheus.pushgateway.job"";
+
+    int PROMETHEUS_DEFAULT_METRICS_PORT = 20888;
+
+    String PROMETHEUS_DEFAULT_METRICS_PATH = ""/metrics"";
+
+    int PROMETHEUS_DEFAULT_PUSH_INTERVAL = 30;
+
+    String PROMETHEUS_DEFAULT_JOB_NAME = ""default_dubbo_job"";
+
+    String[] METRIC_REQUESTS_TOTAL = new String[]{ ""requests.total"", ""Total Requests"" };
+
+    String[] METRIC_REQUESTS_SUCCEED = new String[]{ ""requests.succeed"", ""Succeed Requests"" };
+
+    String[] METRIC_REQUESTS_FAILED = new String[]{ ""requests.failed"", ""Failed Requests"" };
+
+    String[] METRIC_REQUESTS_PROCESSING = new String[]{ ""requests.processing"", ""Processing Requests"" };
+
+    String[] METRIC_REQUESTS_TOTAL_AGG = new String[]{ ""requests.total.aggregate"", ""Aggregated Total Requests"" };
+
+    String[] METRIC_REQUESTS_SUCCEED_AGG = new String[]{ ""requests.succeed.aggregate"", ""Aggregated Succeed Requests"" };
+
+    String[] METRIC_REQUESTS_FAILED_AGG = new String[]{ ""requests.failed.aggregate"", ""Aggregated Failed Requests"" };
+
+    String[] METRIC_QPS = new String[]{ ""qps"", ""Query Per Seconds"" };
+
+    String[] METRIC_RT_LAST = new String[]{ ""rt.last"", ""Last Response Time"" };
+
+    String[] METRIC_RT_MIN = new String[]{ ""rt.min"", ""Min Response Time"" };
+
+    String[] METRIC_RT_MAX = new String[]{ ""rt.max"", ""Max Response Time"" };
+
+    String[] METRIC_RT_TOTAL = new String[]{ ""rt.total"", ""Total Response Time"" };
+
+    String[] METRIC_RT_AVG = new String[]{ ""rt.avg"", ""Average Response Time"" };
+
+    String[] METRIC_RT_P99 = new String[]{ ""rt.p99"", ""Response Time P99"" };
+
+    String[] METRIC_RT_P95 = new String[]{ ""rt.p95"", ""Response Time P95"" };","[{'comment': 'Abstracting out, for example, with types such as enumerations, it makes no sense to define them in terms of arrays.', 'commenter': 'CrazyHZM'}, {'comment': 'Array already split.', 'commenter': 'Henrik-Yao'}]"
10499,dubbo-common/src/main/java/org/apache/dubbo/common/metrics/collector/DefaultMetricsCollector.java,"@@ -0,0 +1,194 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.metrics.collector;
+
+import org.apache.dubbo.common.metrics.event.MetricsEvent;
+import org.apache.dubbo.common.metrics.event.RTEvent;
+import org.apache.dubbo.common.metrics.event.RequestEvent;
+import org.apache.dubbo.common.metrics.listener.MetricsListener;
+import org.apache.dubbo.common.metrics.model.MethodMetric;
+import org.apache.dubbo.common.metrics.model.sample.GaugeMetricSample;
+import org.apache.dubbo.common.metrics.model.sample.MetricSample;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.LongAccumulator;
+
+import static org.apache.dubbo.common.constants.MetricsConstants.METRIC_REQUESTS_TOTAL;
+import static org.apache.dubbo.common.constants.MetricsConstants.METRIC_REQUESTS_SUCCEED;
+import static org.apache.dubbo.common.constants.MetricsConstants.METRIC_REQUESTS_FAILED;
+import static org.apache.dubbo.common.constants.MetricsConstants.METRIC_REQUESTS_PROCESSING;
+import static org.apache.dubbo.common.constants.MetricsConstants.METRIC_RT_LAST;
+import static org.apache.dubbo.common.constants.MetricsConstants.METRIC_RT_MIN;
+import static org.apache.dubbo.common.constants.MetricsConstants.METRIC_RT_MAX;
+import static org.apache.dubbo.common.constants.MetricsConstants.METRIC_RT_TOTAL;
+import static org.apache.dubbo.common.constants.MetricsConstants.METRIC_RT_AVG;
+import static org.apache.dubbo.common.metrics.model.MetricsCategory.REQUESTS;
+import static org.apache.dubbo.common.metrics.model.MetricsCategory.RT;
+
+/**
+ * Default implementation of {@link MetricsCollector}
+ */
+public class DefaultMetricsCollector implements MetricsCollector {
+
+    private Boolean collectEnabled = false;
+    private final List<MetricsListener> listeners = new ArrayList<>();
+    private final ApplicationModel applicationModel;
+    private final String applicationName;
+
+    private final Map<MethodMetric, AtomicLong> totalRequests = new ConcurrentHashMap<>();
+    private final Map<MethodMetric, AtomicLong> succeedRequests = new ConcurrentHashMap<>();
+    private final Map<MethodMetric, AtomicLong> failedRequests = new ConcurrentHashMap<>();
+    private final Map<MethodMetric, AtomicLong> processingRequests = new ConcurrentHashMap<>();
+
+    private final Map<MethodMetric, AtomicLong> lastRT = new ConcurrentHashMap<>();
+    private final Map<MethodMetric, LongAccumulator> minRT = new ConcurrentHashMap<>();
+    private final Map<MethodMetric, LongAccumulator> maxRT = new ConcurrentHashMap<>();
+    private final Map<MethodMetric, AtomicLong> avgRT = new ConcurrentHashMap<>();
+    private final Map<MethodMetric, AtomicLong> totalRT = new ConcurrentHashMap<>();
+    private final Map<MethodMetric, AtomicLong> rtCount = new ConcurrentHashMap<>();
+
+    public DefaultMetricsCollector(ApplicationModel applicationModel) {
+        this.applicationModel = applicationModel;
+        this.applicationName = applicationModel.getApplicationName();
+    }
+
+    public void setCollectEnabled(Boolean collectEnabled) {
+        this.collectEnabled = collectEnabled;
+    }","[{'comment': 'Will dynamic start/stop be supported here, if so, `collectEnabled` should be an atomic operation, if not, this method should be removed and set in the constructor', 'commenter': 'CrazyHZM'}, {'comment': 'Atomic operation used.', 'commenter': 'Henrik-Yao'}]"
10499,dubbo-common/src/main/java/org/apache/dubbo/common/metrics/event/MetricsEvent.java,"@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.metrics.event;
+
+/**
+ * BaseMetricsEvent.
+ */
+public abstract class MetricsEvent {
+
+    /**
+     * Metric object. (eg. {@link org.apache.dubbo.common.metrics.model.MethodMetric})
+     */
+    protected transient Object source;
+
+    public MetricsEvent(Object source) {
+        if (source == null)
+            throw new IllegalArgumentException(""null source"");
+","[{'comment': 'Note the code style, add `{}`', 'commenter': 'CrazyHZM'}, {'comment': 'The format has been modified, thanks.', 'commenter': 'Henrik-Yao'}]"
10508,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java,"@@ -67,29 +67,28 @@ public abstract class AbstractServiceDiscovery implements ServiceDiscovery {
     protected ApplicationModel applicationModel;
 
     public AbstractServiceDiscovery(ApplicationModel applicationModel, URL registryURL) {
-        this(applicationModel.getApplicationName(), registryURL);
-        this.applicationModel = applicationModel;","[{'comment': '70行对应构造方法内部使用的`ApplicationModel`为`ApplicationModel.defaultModel()`，而非使用是71行的`ApplicationModel`。从而使得在调用`getCacheNameSuffix()`使用的是`defaultModule`的`appName`。', 'commenter': 'BurningCN'}]"
10508,dubbo-common/src/main/java/org/apache/dubbo/common/extension/support/MultiInstanceActivateComparator.java,"@@ -17,159 +17,13 @@
 
 package org.apache.dubbo.common.extension.support;
 
-import org.apache.dubbo.common.extension.Activate;
 import org.apache.dubbo.common.extension.ExtensionDirector;
-import org.apache.dubbo.common.extension.ExtensionLoader;
-import org.apache.dubbo.common.extension.SPI;
-import org.apache.dubbo.common.utils.ArrayUtils;
 
 import java.util.List;
-import java.util.Comparator;
-import java.util.Map;
-import java.util.Arrays;
-import java.util.concurrent.ConcurrentHashMap;
 
-public class MultiInstanceActivateComparator implements Comparator<Class<?>> {
-
-    private final List<ExtensionDirector> extensionDirectors;
-    private final Map<Class<?>, ActivateInfo> activateInfoMap = new ConcurrentHashMap<>();
+public class MultiInstanceActivateComparator extends ActivateComparator {
 
     public MultiInstanceActivateComparator(List<ExtensionDirector> extensionDirectors) {
-        this.extensionDirectors = extensionDirectors;
-    }
-
-    @Override
-    public int compare(Class o1, Class o2) {
-        if (o1 == null && o2 == null) {
-            return 0;
-        }
-        if (o1 == null) {
-            return -1;
-        }
-        if (o2 == null) {
-            return 1;
-        }
-        if (o1.equals(o2)) {
-            return 0;
-        }
-
-        Class<?> inf = findSpi(o1);
-
-        ActivateInfo a1 = parseActivate(o1);
-        ActivateInfo a2 = parseActivate(o2);
-
-        if ((a1.applicableToCompare() || a2.applicableToCompare()) && inf != null) {
-
-
-            if (a1.applicableToCompare()) {
-                String n2 = null;
-                for (ExtensionDirector director : extensionDirectors) {
-                    ExtensionLoader<?> extensionLoader = director.getExtensionLoader(inf);
-                    n2 = extensionLoader.getExtensionName(o2);
-                    if (n2 != null) {
-                        break;
-                    }
-                }
-                if (a1.isLess(n2)) {
-                    return -1;
-                }
-
-                if (a1.isMore(n2)) {
-                    return 1;
-                }
-            }
-
-            if (a2.applicableToCompare()) {
-                String n1 = null;
-                for (ExtensionDirector director : extensionDirectors) {
-                    ExtensionLoader<?> extensionLoader = director.getExtensionLoader(inf);
-                    n1 = extensionLoader.getExtensionName(o1);
-                    if (n1 != null) {
-                        break;
-                    }
-                }
-
-                if (a2.isLess(n1)) {
-                    return 1;
-                }
-
-                if (a2.isMore(n1)) {
-                    return -1;
-                }
-            }
-
-            return a1.order > a2.order ? 1 : -1;
-        }
-
-        // In order to avoid the problem of inconsistency between the loading order of two filters
-        // in different loading scenarios without specifying the order attribute of the filter,
-        // when the order is the same, compare its filterName
-        if (a1.order > a2.order) {
-            return 1;
-        } else if (a1.order == a2.order) {
-            return o1.getSimpleName().compareTo(o2.getSimpleName()) > 0 ? 1 : -1;
-        } else {
-            return -1;
-        }
-    }
-
-    private Class<?> findSpi(Class<?> clazz) {
-        if (clazz.getInterfaces().length == 0) {
-            return null;
-        }
-
-        for (Class<?> intf : clazz.getInterfaces()) {
-            if (intf.isAnnotationPresent(SPI.class)) {
-                return intf;
-            }
-            Class<?> result = findSpi(intf);
-            if (result != null) {
-                return result;
-            }
-        }
-
-        return null;
-    }
-
-    private ActivateInfo parseActivate(Class<?> clazz) {
-        ActivateInfo info = activateInfoMap.get(clazz);
-        if (info != null) {
-            return info;
-        }
-        info = new ActivateInfo();
-        if (clazz.isAnnotationPresent(Activate.class)) {
-            Activate activate = clazz.getAnnotation(Activate.class);
-            info.before = activate.before();
-            info.after = activate.after();
-            info.order = activate.order();
-        } else if (clazz.isAnnotationPresent(com.alibaba.dubbo.common.extension.Activate.class)) {
-            com.alibaba.dubbo.common.extension.Activate activate = clazz.getAnnotation(
-                com.alibaba.dubbo.common.extension.Activate.class);
-            info.before = activate.before();
-            info.after = activate.after();
-            info.order = activate.order();
-        } else {
-            info.order = 0;
-        }
-        activateInfoMap.put(clazz, info);
-        return info;
-    }
-
-    private static class ActivateInfo {
-        private String[] before;
-        private String[] after;
-        private int order;
-
-        private boolean applicableToCompare() {
-            return ArrayUtils.isNotEmpty(before) || ArrayUtils.isNotEmpty(after);
-        }
-
-        private boolean isLess(String name) {
-            return Arrays.asList(before).contains(name);
-        }
-
-        private boolean isMore(String name) {
-            return Arrays.asList(after).contains(name);
-        }
+        super(extensionDirectors);","[{'comment': '直接删掉这个类了吧，已经没有独立存在的作用了', 'commenter': 'AlbumenJ'}]"
10512,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java,"@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.filter;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.metrics.collector.DefaultMetricsCollector;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER;
+
+@Activate(group = PROVIDER, order = -1)
+public class MetricsFilter implements Filter, ScopeModelAware {
+
+    private DefaultMetricsCollector collector = null;
+
+    private ApplicationModel applicationModel;
+
+    @Override
+    public void setApplicationModel(ApplicationModel applicationModel) {
+        this.applicationModel = applicationModel;
+
+        collector = applicationModel.getBeanFactory().getBean(DefaultMetricsCollector.class);
+    }
+
+    @Override
+    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
+        if (collector == null || !collector.isCollectEnabled()) {
+            return invoker.invoke(invocation);
+        }
+
+        String serviceUniqueName = invocation.getTargetServiceUniqueName();
+        String methodName = invocation.getMethodName();
+        String group = null;
+        String interfaceAndVersion;
+        String[] arr = serviceUniqueName.split(""/"");
+        if (arr.length == 2) {
+            group = arr[0];
+            interfaceAndVersion = arr[1];
+        } else {
+            interfaceAndVersion = arr[0];
+        }
+
+        String[] ivArr = interfaceAndVersion.split("":"");
+        String interfaceName = ivArr[0];
+        String version = ivArr.length == 2 ? ivArr[1] : null;
+        collector.increaseTotalRequests(interfaceName, methodName, group, version);
+        collector.increaseProcessingRequests(interfaceName, methodName, group, version);
+
+        Long startTime = System.currentTimeMillis();
+        try {
+            Result invoke = invoker.invoke(invocation);
+            collector.increaseSucceedRequests(interfaceName, methodName, group, version);
+            return invoke;
+        } catch (RpcException e) {
+            collector.increaseFailedRequests(interfaceName, methodName, group, version);","[{'comment': 'handle error in onError', 'commenter': 'AlbumenJ'}]"
10512,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java,"@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.filter;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.metrics.collector.DefaultMetricsCollector;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER;
+
+@Activate(group = PROVIDER, order = -1)
+public class MetricsFilter implements Filter, ScopeModelAware {
+
+    private DefaultMetricsCollector collector = null;
+
+    private ApplicationModel applicationModel;
+
+    @Override
+    public void setApplicationModel(ApplicationModel applicationModel) {
+        this.applicationModel = applicationModel;
+
+        collector = applicationModel.getBeanFactory().getBean(DefaultMetricsCollector.class);
+    }
+
+    @Override
+    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
+        if (collector == null || !collector.isCollectEnabled()) {
+            return invoker.invoke(invocation);
+        }
+
+        String serviceUniqueName = invocation.getTargetServiceUniqueName();
+        String methodName = invocation.getMethodName();
+        String group = null;
+        String interfaceAndVersion;
+        String[] arr = serviceUniqueName.split(""/"");
+        if (arr.length == 2) {
+            group = arr[0];
+            interfaceAndVersion = arr[1];
+        } else {
+            interfaceAndVersion = arr[0];
+        }
+
+        String[] ivArr = interfaceAndVersion.split("":"");
+        String interfaceName = ivArr[0];
+        String version = ivArr.length == 2 ? ivArr[1] : null;
+        collector.increaseTotalRequests(interfaceName, methodName, group, version);
+        collector.increaseProcessingRequests(interfaceName, methodName, group, version);
+
+        Long startTime = System.currentTimeMillis();
+        try {
+            Result invoke = invoker.invoke(invocation);
+            collector.increaseSucceedRequests(interfaceName, methodName, group, version);
+            return invoke;
+        } catch (RpcException e) {
+            collector.increaseFailedRequests(interfaceName, methodName, group, version);
+            throw e;
+        } finally {
+            Long endTime = System.currentTimeMillis();
+            Long rt = endTime - startTime;
+            collector.addRT(interfaceName, methodName, group, version, rt);
+            collector.decreaseProcessingRequests(interfaceName, methodName, group, version);","[{'comment': 'handle in onResponse', 'commenter': 'AlbumenJ'}]"
10533,dubbo-common/src/main/java/org/apache/dubbo/common/constants/ProviderConstants.java,"@@ -0,0 +1,16 @@
+package org.apache.dubbo.common.constants;
+
+/**
+ * Provider Constants
+ *
+ * @author XS <tonycody@qq.com>
+ * @date: 2022/9/1 16:59:53
+ * @since 1.0","[{'comment': 'remove these tags pls', 'commenter': 'AlbumenJ'}]"
10533,dubbo-common/src/main/java/org/apache/dubbo/common/constants/ProviderConstants.java,"@@ -0,0 +1,16 @@
+package org.apache.dubbo.common.constants;","[{'comment': 'Please add ASF license header to all files', 'commenter': 'AlbumenJ'}]"
10533,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"@@ -110,13 +110,7 @@
 import static org.apache.dubbo.registry.Constants.REGISTER_KEY;
 import static org.apache.dubbo.registry.Constants.REGISTRY_RETRY_PERIOD_KEY;
 import static org.apache.dubbo.registry.Constants.SIMPLIFIED_KEY;
-import static org.apache.dubbo.remoting.Constants.BIND_IP_KEY;
-import static org.apache.dubbo.remoting.Constants.BIND_PORT_KEY;
-import static org.apache.dubbo.remoting.Constants.CHECK_KEY;
-import static org.apache.dubbo.remoting.Constants.CODEC_KEY;
-import static org.apache.dubbo.remoting.Constants.CONNECTIONS_KEY;
-import static org.apache.dubbo.remoting.Constants.EXCHANGER_KEY;
-import static org.apache.dubbo.remoting.Constants.SERIALIZATION_KEY;
+import static org.apache.dubbo.remoting.Constants.*;","[{'comment': 'do not use comma import', 'commenter': 'AlbumenJ'}]"
10533,dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvokerAvailableTest.java,"@@ -151,6 +151,26 @@ public void test_Lazy_ChannelReadOnly() throws Exception {
         Assertions.assertFalse(invoker.isAvailable());
     }
 
+    /**
+     * The test prefer serialization
+     *
+     * @throws Exception 异常","[{'comment': 'comment in eng', 'commenter': 'AlbumenJ'}]"
10533,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/AbstractServiceBuilder.java,"@@ -211,11 +216,22 @@ public B warmup(Integer warmup) {
         return getThis();
     }
 
-    public  B serialization(String serialization) {
+    public B serialization(String serialization) {
         this.serialization = serialization;
         return getThis();
     }
 
+    /**
+     * The prefer serialization type
+     *
+     * @param preferSerialization 喜欢序列化","[{'comment': 'comment in eng', 'commenter': 'AlbumenJ'}]"
10533,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/utils/UrlUtils.java,"@@ -18,7 +18,15 @@
 package org.apache.dubbo.remoting.utils;
 
 import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.serialize.support.DefaultSerializationSelector;
+import org.apache.dubbo.common.utils.StringUtils;
 import org.apache.dubbo.remoting.Constants;
+import org.apache.dubbo.remoting.transport.CodecSupport;
+
+import java.util.*;","[{'comment': 'do not use comma import', 'commenter': 'AlbumenJ'}]"
10538,dubbo-registry/dubbo-registry-multicast/src/test/java/org/apache/dubbo/registry/multicast/MulticastRegistryTest.java,"@@ -39,7 +39,7 @@
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
-public class MulticastRegistryTest {","[{'comment': 'Why change this file', 'commenter': 'AlbumenJ'}, {'comment': ""Since Junit 5, it supports classes which has package private access, so it's redundant, and I have Sonarlint installed, it complaints the modifier..."", 'commenter': 'win120a'}]"
10538,dubbo-common/src/test/java/org/apache/dubbo/common/utils/NetUtilsTest.java,"@@ -42,51 +42,51 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-public class NetUtilsTest {","[{'comment': 'Why change this file', 'commenter': 'AlbumenJ'}, {'comment': 'Same as above...', 'commenter': 'win120a'}, {'comment': 'Do I need to revert or ...?', 'commenter': 'win120a'}]"
10544,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java,"@@ -231,6 +231,8 @@ public void onNext(DiscoveryResponse value) {
         @Override
         public void onError(Throwable t) {
             logger.error(""xDS Client received error message! detail:"", t);
+            StreamObserver<DiscoveryRequest> requestObserver = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(requestId));
+            requestObserverMap.put(requestId, requestObserver);","[{'comment': '这里需要检查下 Throwable 的类型，同时做下重试的速率限制', 'commenter': 'AlbumenJ'}, {'comment': '> 这里需要检查下 Throwable 的类型，同时做下重试的速率限制\r\n\r\n做了一些修改，please help review', 'commenter': 'wucheng1997'}]"
10544,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java,"@@ -231,6 +234,16 @@ public void onNext(DiscoveryResponse value) {
         @Override
         public void onError(Throwable t) {
             logger.error(""xDS Client received error message! detail:"", t);
+
+            if (t instanceof StatusRuntimeException) {
+                try {
+                    StreamObserver<DiscoveryRequest> requestObserver = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(requestId));
+                    requestObserverMap.put(requestId, requestObserver);","[{'comment': '这块重建后不需要重新发起请求吗？\r\n重试的逻辑可以整合一起管理，包括网络抖动那些', 'commenter': 'AlbumenJ'}, {'comment': '> 这块重建后不需要重新发起请求吗？ 重试的逻辑可以整合一起管理，包括网络抖动那些\r\n\r\n这里没有重建xdsChannel，实际上这个xdsChannel一直是有效的，出问题是因为observer在执行了onError方法之后，无法在执行onNext，导致了出现后面observer无法工作，无法感知路由变化。所以我这里新建了一个observer。等下一次与istio通信就可以正常工作。\r\n\r\nchannel的一些重试等操作在grpc中应该已经有实现。我看前面是线程定时10s拉取一次，如果中间出现网络问题应该也不影响。\r\n', 'commenter': 'wucheng1997'}, {'comment': '这个问题在 envoy 和 istio-agent 是怎么解决的？感觉通过报错然后重建这个方式不太好（不过onError还是要处理的）', 'commenter': 'AlbumenJ'}, {'comment': 'https://github.com/grpc/grpc-java/issues/9522\r\n目前看来这个observer的onError方法是在grpc层实现的，这里是没办法修改，在目前的实现方案，能做的只能是重试，envoy的实现也是new connection，我修改了一下，看一下这种实现是否合理一些。', 'commenter': 'wucheng1997'}]"
10567,dubbo-xds/pom.xml,"@@ -50,16 +50,19 @@
         <dependency>
             <groupId>io.grpc</groupId>
             <artifactId>grpc-protobuf</artifactId>
+            <version>1.47.0</version>","[{'comment': 'dependency version should be managed within `dubbo-dependencies-bom`', 'commenter': 'AlbumenJ'}]"
10567,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/XdsChannel.java,"@@ -16,26 +16,38 @@
  */
 package org.apache.dubbo.registry.xds.util;
 
+import io.grpc.*;","[{'comment': 'do not use comma import', 'commenter': 'AlbumenJ'}, {'comment': '这里最好别用`*`', 'commenter': 'wangchengming666'}]"
10567,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/XdsChannel.java,"@@ -46,17 +49,30 @@ public class XdsChannel {
     protected XdsChannel(URL url) {
         ManagedChannel managedChannel = null;
         try {
-            XdsCertificateSigner signer = url.getOrDefaultApplicationModel().getExtensionLoader(XdsCertificateSigner.class)
-                .getExtension(url.getParameter(""signer"", ""istio""));
-            XdsCertificateSigner.CertPair certPair = signer.GenerateCert(url);
-            SslContext context = GrpcSslContexts.forClient()
-                .trustManager(InsecureTrustManagerFactory.INSTANCE)
-                .keyManager(new ByteArrayInputStream(certPair.getPublicKey().getBytes(StandardCharsets.UTF_8)),
-                    new ByteArrayInputStream(certPair.getPrivateKey().getBytes(StandardCharsets.UTF_8)))
-                .build();
-            managedChannel = NettyChannelBuilder.forAddress(url.getHost(), url.getPort()).sslContext(context)
-                .build();
-        } catch (SSLException e) {
+            if(!url.getParameter(""useAgent"",false)) {","[{'comment': 'Please use the dash formatted variable name `use-agent` and define it as a constant.\r\n\r\nAlso, we need a demo and documentation introducing the usage of this key and the whole bootstrap file.', 'commenter': 'chickenlj'}, {'comment': 'There is more information in https://github.com/apache/dubbo/pull/10567#issue-1364376188', 'commenter': 'chenyanlann'}]"
10587,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java,"@@ -312,4 +316,13 @@ private int calculateTimeout(Invocation invocation, String methodName) {
         return timeout;
     }
 
+    private void initWriteQueueIfNecessary(Channel channel) {","[{'comment': 'This method may be unnecessary cuz `setChannel` already exists when `StreamChannel` created', 'commenter': 'guohao'}]"
10587,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/WriteQueue.java,"@@ -31,17 +31,31 @@
 public class WriteQueue {
 
     static final int DEQUE_CHUNK_SIZE = 128;
-    private final Channel channel;
+    private volatile Channel channel;","[{'comment': ""This `channel` cloud be deleted cuz parent channel can be got from `cmd`'s stream channel"", 'commenter': 'guohao'}]"
10589,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java,"@@ -48,38 +49,21 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept
         if (collector == null || !collector.isCollectEnabled()) {
             return invoker.invoke(invocation);
         }
+        MetricsCollectExecutor collectorExecutor = new MetricsCollectExecutor(collector, invocation);","[{'comment': 'This line of code appears in multiple places, can you extract it?', 'commenter': 'Henrik-Yao'}, {'comment': '已处理', 'commenter': 'jojocodeX'}]"
10589,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java,"@@ -0,0 +1,82 @@
+package org.apache.dubbo.metrics.filter;
+
+import org.apache.dubbo.common.metrics.collector.DefaultMetricsCollector;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.RpcException;
+
+public class MetricsCollectExecutor {
+
+    private DefaultMetricsCollector collector;
+
+    private Invocation              invocation;
+
+    private String                  interfaceName;
+
+    private String                  methodName;
+
+    private String                  group;
+
+    private String                  version;
+
+
+    private static final String     METRIC_FILTER_START_TIME = ""metric_filter_start_time"";","[{'comment': 'This line of code can be placed in src/main/java/org/apache/dubbo/common/constants/MetricsConstants.java', 'commenter': 'Henrik-Yao'}, {'comment': '已处理', 'commenter': 'jojocodeX'}]"
10589,dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/filter/MetricsFilterTest.java,"@@ -154,7 +163,11 @@ public void testMissingVersion() {
         invocation.setMethodName(METHOD_NAME);
         invocation.setParameterTypes(new Class[]{String.class});
 
-        filter.invoke(invoker, invocation);
+        Result result = filter.invoke(invoker, invocation);
+
+        filter.onResponse(result, invoker, invocation);
+","[{'comment': 'It is recommended to use format checking to remove extra blank lines.', 'commenter': 'Henrik-Yao'}, {'comment': '已处理', 'commenter': 'jojocodeX'}]"
10589,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java,"@@ -0,0 +1,82 @@
+package org.apache.dubbo.metrics.filter;","[{'comment': ""apache's open source protocol should be copy-pasted in the file header."", 'commenter': 'Henrik-Yao'}, {'comment': '已处理', 'commenter': 'jojocodeX'}]"
10589,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java,"@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.filter;
+import org.apache.dubbo.common.metrics.collector.DefaultMetricsCollector;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.RpcException;
+
+import static org.apache.dubbo.common.constants.MetricsConstants.METRIC_FILTER_START_TIME;
+
+public class MetricsCollectExecutor {
+
+    private final DefaultMetricsCollector collector;
+
+    private final Invocation              invocation;
+
+    private String                        interfaceName;
+
+    private String                        methodName;
+
+    private String                        group;
+
+    private String                        version;
+
+
+    public MetricsCollectExecutor(DefaultMetricsCollector collector, Invocation invocation) {
+        init(invocation);
+
+        this.collector = collector;
+
+        this.invocation = invocation;
+    }
+
+    public void beforeExecute() {
+        collector.increaseTotalRequests(interfaceName, methodName, group, version);
+        collector.increaseProcessingRequests(interfaceName, methodName, group, version);
+        invocation.put(METRIC_FILTER_START_TIME, System.currentTimeMillis());
+    }
+
+    public void postExecute() {
+        collector.increaseSucceedRequests(interfaceName, methodName, group, version);
+        endExecute();
+    }
+
+    public void throwExecute(Throwable throwable){
+        if (throwable instanceof RpcException) {
+            collector.increaseFailedRequests(interfaceName, methodName, group, version);
+        }","[{'comment': '需要处理非 RpcException 的情况，通过 onError 过来的基本都是框架异常\r\nonResponse 是业务正常返回（包括业务正常返回、业务抛异常返回），这里可能需要独立判断采集下', 'commenter': 'AlbumenJ'}, {'comment': '是否可以这样理解为，在非rpc异常的情况下，不需要统计rt时间', 'commenter': 'jojocodeX'}, {'comment': '已处理', 'commenter': 'jojocodeX'}]"
10602,dubbo-common/src/main/java/org/apache/dubbo/config/ProtocolConfig.java,"@@ -200,6 +200,11 @@ public class ProtocolConfig extends AbstractConfig {
 
     private Boolean sslEnabled;
 
+    /*
+     * Extra Protocol for this service, using Port Unification Server
+     */
+    private String extProtocol;","[{'comment': 'Should support multiple protocols.', 'commenter': 'CrazyHZM'}, {'comment': 'adjust logic in ServiceConfig.exportUrl, extProtocol is now ""tri,dubbo,other-protocol"" format', 'commenter': 'TrueAbc'}]"
10602,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -580,6 +581,24 @@ private void exportUrl(URL url, List<URL> registryURLs) {
 
             // export to remote if the config is not local (export to local only when config is local)
             if (!SCOPE_LOCAL.equalsIgnoreCase(scope)) {
+                // export to extra protocol is used in remote export
+                String extProtocol = url.getParameter(""ext.protocol"", """");","[{'comment': 'Where do you get the value of `ext.protocol` from?', 'commenter': 'CrazyHZM'}, {'comment': 'This is a new attribute of ProtocolConfig.java. Can be set in both xml and java code. And finally loaded into url object. So we could get this attribute here.\r\n<img width=""771"" alt=""image"" src=""https://user-images.githubusercontent.com/47651330/189880671-7668b372-ee46-4193-957a-6f131859102e.png"">\r\n<img width=""522"" alt=""image"" src=""https://user-images.githubusercontent.com/47651330/189881572-94afc7f7-bc6a-448c-a538-097e83e711ca.png"">\r\n\r\n', 'commenter': 'TrueAbc'}]"
10602,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java,"@@ -23,10 +23,16 @@
 import org.apache.dubbo.remoting.transport.AbstractServer;
 
 import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 public abstract class AbstractPortUnificationServer extends AbstractServer {
     private final List<WireProtocol> protocols;
 
+    private final Map<String, URL> urlMapper = new ConcurrentHashMap<>();
+
+    private final Map<String, ChannelHandler> handlerMapper = new ConcurrentHashMap<>();","[{'comment': 'Naming needs to be enhanced for readability, such as `supportedUrls`, and be annotated to describe the use.', 'commenter': 'CrazyHZM'}]"
10602,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/pu/AbstractPortUnificationServer.java,"@@ -36,4 +42,18 @@ public List<WireProtocol> getProtocols() {
         return protocols;
     }
 
+    public void addNewURL(URL url, ChannelHandler handler) {
+        this.urlMapper.put(url.getProtocol(), url);
+        this.handlerMapper.put(url.getProtocol(), handler);
+    }
+
+    protected Map<String, URL> getUrlMapper() {
+        // this getter is just used by implementation of this class
+        return urlMapper;
+    }
+
+    public Map<String, ChannelHandler> getHandlerMapper() {
+        // this getter is just used by implementation of this class
+        return handlerMapper;
+    }","[{'comment': 'Naming needs to be enhanced for readability.', 'commenter': 'CrazyHZM'}]"
10602,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,"@@ -364,6 +367,9 @@ private ProtocolServer createServer(URL url) {
             // enable heartbeat by default
             .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))
             .addParameter(CODEC_KEY, DubboCodec.NAME)
+            //todo
+            // enable pu server by default, this config should be closed when merging
+            .addParameter(IS_PU_SERVER_KEY, Boolean.TRUE.toString())","[{'comment': 'Why is it enabled by default for now?', 'commenter': 'CrazyHZM'}, {'comment': 'This line should be deleted finally. For now, this line is used to make all dubbo protocol test cases use pu server.', 'commenter': 'TrueAbc'}]"
10602,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/WireProtocol.java,"@@ -34,4 +34,6 @@ public interface WireProtocol {
     void configClientPipeline(URL url, ChannelPipeline pipeline, SslContext sslContext);
 
     void close();
+
+    String protocolName();","[{'comment': '`ExtensionLoader.getExtensionName()` can solve this problem.', 'commenter': 'CrazyHZM'}]"
10605,dubbo-reactive/pom.xml,"@@ -0,0 +1,55 @@
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>org.apache.dubbo</groupId>
+        <artifactId>dubbo-parent</artifactId>
+        <version>${revision}</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
+
+    <artifactId>dubbo-reactive</artifactId>
+    <name>${project.artifactId}</name>
+    <description>The reactive module of triple protocol</description>
+
+    <properties>
+        <skip_maven_deploy>false</skip_maven_deploy>
+        <reactive.version>1.0.4</reactive.version>
+        <reactor.version>3.4.19</reactor.version>","[{'comment': 'version should be managed in dubbo-dependencies-bom', 'commenter': 'AlbumenJ'}]"
10613,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -764,15 +764,14 @@ public void preDestroy() {
             }
             onStopping();
 
+            unregisterServiceInstance();
             destroyRegistries();
-            destroyServiceDiscoveries();","[{'comment': 'Why remove this line?', 'commenter': 'AlbumenJ'}, {'comment': 'ServiceDiscoveries have been destroyed in destroyRegistries() and removed from registries', 'commenter': 'howie-xu'}]"
10622,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metrics/DefaultMetricsServiceExporter.java,"@@ -0,0 +1,107 @@
+package org.apache.dubbo.config.metrics;","[{'comment': 'Please add ASF license header', 'commenter': 'AlbumenJ'}]"
10622,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/ExportServiceConfigBuilder.java,"@@ -0,0 +1,212 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.config.bootstrap.builders;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CORE_THREADS_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_PROTOCOL;
+import static org.apache.dubbo.common.constants.CommonConstants.THREADPOOL_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.THREADS_KEY;
+import static org.apache.dubbo.remoting.Constants.BIND_PORT_KEY;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.function.Consumer;
+
+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.Assert;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.config.ApplicationConfig;
+import org.apache.dubbo.config.ProtocolConfig;
+import org.apache.dubbo.config.RegistryConfig;
+import org.apache.dubbo.config.ServiceConfig;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.ProtocolServer;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+public class ExportServiceConfigBuilder<T> {","[{'comment': 'More worried about the abuse of `ExportServiceConfigBuilder`. Are we thinking about opening this API to the public?', 'commenter': 'CrazyHZM'}, {'comment': '考虑到当前这个类只提供内部使用，对命名进行了一定调整', 'commenter': 'jojocodeX'}]"
10622,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java,"@@ -0,0 +1,210 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.config.bootstrap.builders;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CORE_THREADS_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.DUBBO_PROTOCOL;
+import static org.apache.dubbo.common.constants.CommonConstants.THREADPOOL_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.THREADS_KEY;
+import static org.apache.dubbo.remoting.Constants.BIND_PORT_KEY;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.function.Consumer;
+
+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.common.utils.Assert;
+import org.apache.dubbo.common.utils.CollectionUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.config.ApplicationConfig;
+import org.apache.dubbo.config.ProtocolConfig;
+import org.apache.dubbo.config.RegistryConfig;
+import org.apache.dubbo.config.ServiceConfig;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.ProtocolServer;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+public class InternalServiceConfigBuilder<T> {
+
+    private final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(getClass());
+
+    private final ApplicationModel applicationModel;
+    private String  protocol;
+    private Integer port;
+    private String registryId;
+    private Class<T> interfaceClass;
+    private T   ref;
+
+    private InternalServiceConfigBuilder(ApplicationModel applicationModel) {
+        this.applicationModel = applicationModel;
+    }
+
+    public static <T> InternalServiceConfigBuilder<T> newBuilder(ApplicationModel applicationModel) {
+        return new InternalServiceConfigBuilder<>(applicationModel);
+    }
+
+
+
+    public InternalServiceConfigBuilder<T> interfaceClass(Class<T> interfaceClass) {
+        this.interfaceClass = interfaceClass;
+        return getThis();
+    }
+
+    public InternalServiceConfigBuilder<T> ref(T ref) {
+        this.ref = ref;
+        return getThis();
+    }
+
+    public InternalServiceConfigBuilder<T> registryId(String registryId) {
+        this.registryId = registryId;
+        return getThis();
+    }
+    
+    public InternalServiceConfigBuilder<T> protocol(String protocol, String key) {
+        if (StringUtils.isEmpty(protocol)) {
+            Map<String, String> params = getApplicationConfig().getParameters();
+            if (CollectionUtils.isNotEmptyMap(params)) {
+                protocol = getApplicationConfig().getParameters().get(key);
+            }
+        }
+        this.protocol = StringUtils.isNotEmpty(protocol) ? protocol : DUBBO_PROTOCOL;
+
+        return getThis();
+    }
+
+    public InternalServiceConfigBuilder<T> port(Integer specPort, String key) {
+        Assert.notEmptyString(this.protocol,""export protocol is null"");
+        Assert.notNull(this.interfaceClass,""export interfaceClass is null"");
+
+        if (specPort != null) {
+            this.port = specPort;
+            return getThis();
+        }
+        Map<String, String> params = getApplicationConfig().getParameters();
+        if (CollectionUtils.isNotEmptyMap(params)) {
+            String rawPort = getApplicationConfig().getParameters().get(key);
+            if (StringUtils.isNotEmpty(rawPort)) {
+                specPort = Integer.parseInt(rawPort);
+            }
+        }
+
+        if (specPort == null || specPort < -1) {
+            try {
+                if (logger.isInfoEnabled()) {
+                    logger.info(interfaceClass.getName()+""Service Port hasn't been set will use default protocol defined in protocols."");
+                }
+
+                Protocol protocol = applicationModel.getExtensionLoader(Protocol.class).getExtension(this.protocol);
+                if (protocol != null && protocol.getServers() != null) {
+                    Iterator<ProtocolServer> it = protocol.getServers().iterator();
+                    // export service may export before normal service export, it.hasNext() will return false.
+                    // so need use specified protocol port.
+                    if (it.hasNext()) {
+                        ProtocolServer server = it.next();
+                        String rawPort = server.getUrl().getParameter(BIND_PORT_KEY);
+                        if (rawPort == null) {
+                            String addr = server.getAddress();
+                            rawPort = addr.substring(addr.indexOf("":"") + 1);
+                        }
+                        this.port = Integer.parseInt(rawPort);
+                    } else {
+                        Integer protocolPort = getProtocolConfig().getPort();
+                        if (null != protocolPort && protocolPort != -1) {
+                            this.port = protocolPort;
+                        }
+                    }
+                }
+            } catch (Exception e) {
+                logger.error(""5-16"", ""invalid specified "" + protocol + ""  protocol"", """", ""Failed to find any valid protocol, will use random port to export metadata service."");","[{'comment': 'log out `e`', 'commenter': 'AlbumenJ'}]"
10622,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java,"@@ -68,9 +54,17 @@ public ConfigurableMetadataServiceExporter(ApplicationModel applicationModel, Me
 
     public synchronized ConfigurableMetadataServiceExporter export() {
         if (serviceConfig == null || !isExported()) {
-            this.serviceConfig = buildServiceConfig();
+            this.serviceConfig = InternalServiceConfigBuilder.<MetadataService>newBuilder(applicationModel)
+                .interfaceClass(MetadataService.class)
+                .protocol(getApplicationConfig().getMetadataServiceProtocol(), METADATA_SERVICE_PROTOCOL_KEY)
+                .port(getApplicationConfig().getMetadataServicePort(), METADATA_SERVICE_PORT_KEY)
+                .registryId(""internal-metadata-registry"")
+                .ref(metadataService)
+                .build(configConsumer -> configConsumer.setMethods(generateMethodConfig()));","[{'comment': 'Why do methods need to be treated differently? Could we achieve the same purpose by adding a `methods` method in the ServiceConfig Builder?', 'commenter': 'chickenlj'}, {'comment': '这个逻辑是以往就存在的逻辑，MetricsService也需要导出服务，在导出的时候有许多共性的特征，所以对当前代码进行了抽取。之所以会声明，服务发现的过程中，方法内部在获取实例服务时会调用些方法进行变更操作。在真正导出时，对于这种特殊的方法，并没有统一处理，我理解应该是为了解决此问题，才会进行声明式设置', 'commenter': 'jojocodeX'}, {'comment': 'MethodConfig generated can be different per use case, so better be customizable for each call.', 'commenter': 'chickenlj'}]"
10636,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleExceptionWrapperUtils.java,"@@ -0,0 +1,131 @@
+package org.apache.dubbo.rpc.protocol.tri;","[{'comment': 'Please add ASF license header for all newly created files', 'commenter': 'AlbumenJ'}, {'comment': ""> Please add ASF license header for all newly created files\r\n\r\nMaybe we can use apache/skywalking-eyes/header@main to automatically add ASF license header to newly created files in GitHub action. I'm willing to submit a PR if needed, thanks."", 'commenter': 'llnancy'}, {'comment': ""> > Please add ASF license header for all newly created files\r\n> \r\n> Maybe we can use apache/skywalking-eyes/header@main to automatically add ASF license header to newly created files in GitHub action. I'm willing to submit a PR if needed, thanks.\r\n\r\n@sunchaser-lilu go ahead~"", 'commenter': 'AlbumenJ'}]"
10636,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleExceptionWrapperUtils.java,"@@ -0,0 +1,131 @@
+package org.apache.dubbo.rpc.protocol.tri;
+
+import com.google.protobuf.ByteString;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.serialize.MultipleSerialization;
+import org.apache.dubbo.common.serialize.support.DefaultSerializationSelector;
+import org.apache.dubbo.config.Constants;
+import org.apache.dubbo.rpc.model.PackableMethod;
+import org.apache.dubbo.triple.TripleWrapper;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+
+import static org.apache.dubbo.remoting.Constants.SERIALIZATION_KEY;
+
+
+public class TripleExceptionWrapperUtils {
+
+    private final WrapExceptionResponsePack wrapExceptionResponsePack;
+    private final WrapExceptionResponseUnpack wrapExceptionResponseUnPack;
+
+    public WrapExceptionResponsePack getWrapExceptionResponsePack() {
+        return wrapExceptionResponsePack;
+    }
+
+    public WrapExceptionResponseUnpack getWrapExceptionResponseUnPack() {
+        return wrapExceptionResponseUnPack;
+    }
+
+    public byte[] packRequest(Object request) throws IOException {
+        return getWrapExceptionResponsePack().pack(request);
+    }
+
+    public Object unPackRequest(byte[] bytes) throws IOException, ClassNotFoundException {
+        return getWrapExceptionResponseUnPack().unpack(bytes);
+    }
+
+    public TripleExceptionWrapperUtils(Object object, URL url, String serializeName) {
+        final MultipleSerialization serialization = url.getOrDefaultFrameworkModel()
+            .getExtensionLoader(MultipleSerialization.class)
+            .getExtension(url.getParameter(Constants.MULTI_SERIALIZATION_KEY,
+                CommonConstants.DEFAULT_KEY));
+        String returnType = null;
+        if (object != null) {
+            returnType = object.getClass().getName();
+        }
+        this.wrapExceptionResponsePack = new WrapExceptionResponsePack(serialization,
+            url, returnType);
+        this.wrapExceptionResponseUnPack = new WrapExceptionResponseUnpack(serialization, url);
+    }
+
+    public static TripleExceptionWrapperUtils init(Object object, URL url) {
+        final String serializeName = url.getParameter(SERIALIZATION_KEY,
+            DefaultSerializationSelector.getDefaultRemotingSerialization());
+        TripleExceptionWrapperUtils tripleExceptionWrapperUtils = new TripleExceptionWrapperUtils(
+            object, url, serializeName);
+        return tripleExceptionWrapperUtils;
+    }
+
+    private static String convertHessianFromWrapper(String serializeType) {
+        if (TripleConstant.HESSIAN4.equals(serializeType)) {
+            return TripleConstant.HESSIAN2;
+        }
+        return serializeType;
+    }
+
+    private static class WrapExceptionResponsePack implements PackableMethod.Pack {
+
+        private final MultipleSerialization multipleSerialization;
+        private final URL url;
+        private final String returnType;
+        String serialize = ""hessian4"";
+
+        private WrapExceptionResponsePack(MultipleSerialization multipleSerialization, URL url,
+                                          String returnType) {
+            this.multipleSerialization = multipleSerialization;
+            this.url = url;
+            this.returnType = returnType;
+        }
+
+        @Override
+        public byte[] pack(Object obj) throws IOException {
+            ByteArrayOutputStream bos = new ByteArrayOutputStream();
+            multipleSerialization.serialize(url, serialize, null, obj, bos);
+            return TripleWrapper.TripleExceptionWrapper.newBuilder()
+                .setSerialization(serialize)
+                .setClassName(obj.getClass().getSimpleName())
+                .setData(ByteString.copyFrom(bos.toByteArray()))
+                .build()
+                .toByteArray();
+        }
+    }
+
+    private static class WrapExceptionResponseUnpack implements PackableMethod.UnPack {
+
+        private final MultipleSerialization serialization;
+        private final URL url;
+
+        private WrapExceptionResponseUnpack(MultipleSerialization serialization, URL url) {
+            this.serialization = serialization;
+            this.url = url;
+        }
+
+        @Override
+        public Object unpack(byte[] data) throws IOException, ClassNotFoundException {
+
+            TripleWrapper.TripleExceptionWrapper wrapper = TripleWrapper.TripleExceptionWrapper.parseFrom(
+                data);
+            final String serializeType = convertHessianFromWrapper(wrapper.getSerialization());
+            ByteArrayInputStream bais = new ByteArrayInputStream(wrapper.getData().toByteArray());
+            return serialization.deserialize(url, serializeType, wrapper.getClassName(), bais);
+        }
+    }
+
+//    public static void main(String[] args) throws IOException, ClassNotFoundException {
+//        ScoreException exception = new ScoreException();
+//        URL url = URL.valueOf(""www.baidu.com"");
+//        TripleExceptionWrapperUtils tripleExceptionWrapperUtils = TripleExceptionWrapperUtils.init(new ScoreException(), url);
+//        byte[] tripleExceptionWrapperBytes = tripleExceptionWrapperUtils.packRequest(exception);
+//        CharSequence msg = StreamUtils.encodeBase64ASCII(tripleExceptionWrapperBytes);
+//        msg = TriRpcStatus.encodeMessage((String) msg);
+//        msg = TriRpcStatus.decodeMessage(msg.toString());
+//        byte[] tripleExceptionWrapperDecodeBytes = StreamUtils.decodeASCIIByte(msg);
+////        TripleExceptionWrapperUtils tripleExceptionWrapperUtils2 = TripleExceptionWrapperUtils.init(new ScoreException(), url);
+//        Object object1 = tripleExceptionWrapperUtils.unPackRequest(tripleExceptionWrapperDecodeBytes);
+//        System.out.println(object1 instanceof ScoreException);
+//        System.out.println(object1);
+//    }","[{'comment': 'remove unused code', 'commenter': 'AlbumenJ'}]"
10636,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java,"@@ -283,7 +286,23 @@ private TriRpcStatus statusFromTrailers(Http2Headers trailers) {
             final Integer intStatus = trailers.getInt(TripleHeaderEnum.STATUS_KEY.getHeader());
             TriRpcStatus status = intStatus == null ? null : TriRpcStatus.fromCode(intStatus);
             if (status != null) {
-                final CharSequence message = trailers.get(TripleHeaderEnum.MESSAGE_KEY.getHeader());
+                CharSequence message = trailers.get(TripleHeaderEnum.MESSAGE_KEY.getHeader());
+                CharSequence messageException = trailers.get(TripleHeaderEnum.EXCEPTION_KEY.getHeader());
+                if (messageException != null) {
+                    String decodeMessageException = TriRpcStatus.decodeMessage(messageException.toString());
+                    byte[] decodeMessageExceptionByte = StreamUtils.decodeASCIIByte(decodeMessageException);
+                    TripleExceptionWrapperUtils tripleExceptionWrapperUtils = TripleExceptionWrapperUtils.
+                        init(null, URL.valueOf(""TEST""));
+                    Object messageExceptionObj = null;
+                    try {
+                        messageExceptionObj = tripleExceptionWrapperUtils.unPackRequest(decodeMessageExceptionByte);
+                    } catch (Exception e) {
+                        e.printStackTrace();","[{'comment': 'use logger', 'commenter': 'AlbumenJ'}]"
10636,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java,"@@ -283,7 +286,23 @@ private TriRpcStatus statusFromTrailers(Http2Headers trailers) {
             final Integer intStatus = trailers.getInt(TripleHeaderEnum.STATUS_KEY.getHeader());
             TriRpcStatus status = intStatus == null ? null : TriRpcStatus.fromCode(intStatus);
             if (status != null) {
-                final CharSequence message = trailers.get(TripleHeaderEnum.MESSAGE_KEY.getHeader());
+                CharSequence message = trailers.get(TripleHeaderEnum.MESSAGE_KEY.getHeader());
+                CharSequence messageException = trailers.get(TripleHeaderEnum.EXCEPTION_KEY.getHeader());
+                if (messageException != null) {
+                    String decodeMessageException = TriRpcStatus.decodeMessage(messageException.toString());
+                    byte[] decodeMessageExceptionByte = StreamUtils.decodeASCIIByte(decodeMessageException);
+                    TripleExceptionWrapperUtils tripleExceptionWrapperUtils = TripleExceptionWrapperUtils.
+                        init(null, URL.valueOf(""TEST""));","[{'comment': 'Should this utils be a field of the stream?', 'commenter': 'AlbumenJ'}]"
10636,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java,"@@ -21,13 +21,11 @@
 import org.apache.dubbo.common.logger.Logger;
 import org.apache.dubbo.common.logger.LoggerFactory;
 import org.apache.dubbo.common.utils.StringUtils;
-import org.apache.dubbo.rpc.HeaderFilter;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.PathResolver;
-import org.apache.dubbo.rpc.TriRpcStatus;
+import org.apache.dubbo.rpc.*;","[{'comment': 'do not use comma import', 'commenter': 'AlbumenJ'}]"
10636,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java,"@@ -190,6 +189,19 @@ private Http2Headers getTrailers(TriRpcStatus rpcStatus, Map<String, Object> att
                 StreamUtils.encodeBase64ASCII(status.toByteArray()));
             return headers;
         }
+
+        URL url = URL.valueOf(""TEST"");
+        TripleExceptionWrapperUtils tripleExceptionWrapperUtils = TripleExceptionWrapperUtils.init(throwable, url);
+        try {
+            byte[] exceptionBytes = tripleExceptionWrapperUtils.packRequest(throwable);
+            String exceptionMessage = StreamUtils.encodeBase64ASCII(exceptionBytes);
+            exceptionMessage = TriRpcStatus.encodeMessage(exceptionMessage);
+            headers.set(TripleHeaderEnum.EXCEPTION_KEY.getHeader(),
+                exceptionMessage);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }","[{'comment': 'same', 'commenter': 'AlbumenJ'}]"
10636,dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/support/IGreeterException.java,"@@ -0,0 +1,12 @@
+package org.apache.dubbo.rpc.protocol.tri.support;
+
+public class IGreeterException extends Exception {
+        //异常信息","[{'comment': 'comment in eng', 'commenter': 'AlbumenJ'}]"
10649,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceInstance.java,"@@ -286,20 +288,15 @@ public MetadataInfo getServiceMetadata() {
     @Override
     public void setServiceMetadata(MetadataInfo serviceMetadata) {
         this.serviceMetadata = serviceMetadata;
-        this.instanceAddressURL = null;
+        this.instanceAddressURL.clear();
     }
 
     @Override
     public InstanceAddressURL toURL(String protocol) {
-        if(instanceAddressURL == null) {
-            instanceAddressURL = new HashMap<>();
-        }
-        InstanceAddressURL result = instanceAddressURL.getOrDefault(protocol, null);
-        if (result == null) {
-            instanceAddressURL.put(protocol, new InstanceAddressURL(this, serviceMetadata, protocol));
-            result = instanceAddressURL.get(protocol);
-        }
-        return result;
+        return instanceAddressURL.computeIfAbsent(protocol, key -> {
+            final InstanceAddressURL url = new InstanceAddressURL(this, serviceMetadata, protocol);
+            return url;
+        } );","[{'comment': 'replace it  with lambda', 'commenter': 'CrazyHZM'}]"
10649,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceInstance.java,"@@ -71,7 +73,7 @@ public class DefaultServiceInstance implements ServiceInstance {
     private transient Map<String, String> extendParams;
     private transient List<Endpoint> endpoints;
     private transient ApplicationModel applicationModel;
-    private transient Map<String, InstanceAddressURL> instanceAddressURL;
+    private transient ConcurrentMap<String, InstanceAddressURL> instanceAddressURL = new ConcurrentHashMap<>();","[{'comment': 'ConcurrentMap changed to Map', 'commenter': 'CrazyHZM'}]"
10658,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleIsolationExecutorSupport.java,"@@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.tri.transport;
+
+import io.netty.handler.codec.http2.Http2Headers;
+import org.apache.dubbo.common.ServiceKey;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;
+import org.apache.dubbo.rpc.executor.AbstractIsolationExecutorSupport;
+
+public class TripleIsolationExecutorSupport extends AbstractIsolationExecutorSupport {
+    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(TripleIsolationExecutorSupport.class);
+
+    public TripleIsolationExecutorSupport(URL url) {
+        super(url);
+    }
+
+    @Override
+    protected ServiceKey getServiceKey(Object data) {","[{'comment': 'The servicekey seems to have been obtained in onheader, can it be reused? But there is a problem here, onheader is already in the business thread pool, you may need to pay attention', 'commenter': 'EarthChen'}]"
10658,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java,"@@ -109,6 +107,8 @@ public void onDataRead(ChannelHandlerContext ctx, Http2DataFrame msg) throws Exc
     }
 
     public void onHeadersRead(ChannelHandlerContext ctx, Http2HeadersFrame msg) throws Exception {
+        Executor executor = executorSupport.getExecutor(msg);","[{'comment': 'I think that the calculation of the thread pool can be put into the onheader method, and the previous part of the logic can be executed in the eventloop. (Only basic judgment, no complex logic)', 'commenter': 'EarthChen'}]"
10666,.github/workflows/build-and-test-3.1.yml,"@@ -282,3 +282,37 @@ jobs:
           path: test/jobs/
       - name: ""Merge test result""
         run: ./test/scripts/merge-test-results.sh
+
+  intergration-benchmark:
+    runs-on: ubuntu-18.04
+    timeout-minutes: 30
+
+    strategy:
+      matrix:
+        target: [ ""dubbo-fastjson"",""dubbo-gson"",""dubbo-grpc"",""dubbo-hessianlite"",""dubbo-kryo"",""dubbo-native-hessian"",""dubbo-protobuf-json"",""dubbo-triple"" ]
+    steps:
+      - uses: actions/checkout@v2
+        with:
+          repository: 'apache/dubbo-benchmark'
+          ref: master
+      - name: Set up JDK 8
+        uses: actions/setup-java@v2
+        with:
+          java-version: '8'
+          distribution: 'adopt'
+
+      - name: Prepare base
+        run: mvn clean package -DskipTests=true -pl benchmark-base,client-base,server-base","[{'comment': 'dubbo version should be replaced to the latest snapshot version', 'commenter': 'AlbumenJ'}]"
10672,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java,"@@ -125,11 +126,18 @@ public void configServerProtocolHandler(URL url, ChannelOperator operator) {
                     DEFAULT_MAX_HEADER_LIST_SIZE)))
             .frameLogger(SERVER_LOGGER)
             .build();
+        //增加自定义流控","[{'comment': 'plz use English', 'commenter': 'EarthChen'}]"
10672,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java,"@@ -71,6 +71,9 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
             onHeadersRead(ctx, (Http2HeadersFrame) msg);
         } else if (msg instanceof Http2DataFrame) {
             onDataRead(ctx, (Http2DataFrame) msg);
+            //服务端读完数据，更新流控窗口","[{'comment': 'onDataRead is async, so is unused', 'commenter': 'EarthChen'}]"
10672,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2LocalFlowController.java,"@@ -0,0 +1,640 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri;
+import static io.netty.handler.codec.http2.Http2CodecUtil.CONNECTION_STREAM_ID;
+import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_INITIAL_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_INITIAL_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2Error.FLOW_CONTROL_ERROR;
+import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
+import static io.netty.handler.codec.http2.Http2Exception.connectionError;
+import static io.netty.handler.codec.http2.Http2Exception.streamError;
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
+import static java.lang.Math.max;
+import static java.lang.Math.min;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http2.*;
+import io.netty.handler.codec.http2.Http2Exception.CompositeStreamException;
+import io.netty.handler.codec.http2.Http2Exception.StreamException;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.UnstableApi;
+
+@UnstableApi
+public class TriHttp2LocalFlowController implements Http2LocalFlowController {
+    /**
+     * The default ratio of window size to initial window size below which a {@code WINDOW_UPDATE}
+     * is sent to expand the window.
+     */
+    public static final float DEFAULT_WINDOW_UPDATE_RATIO = 0.5f;
+
+    private final Http2Connection connection;
+    private final Http2Connection.PropertyKey stateKey;
+    private Http2FrameWriter frameWriter;
+    private ChannelHandlerContext ctx;
+    private float windowUpdateRatio;
+    private int initialWindowSize = DEFAULT_WINDOW_SIZE;
+
+    public TriHttp2LocalFlowController(Http2Connection connection) {
+        this(connection, DEFAULT_WINDOW_UPDATE_RATIO, false);
+    }
+
+    public TriHttp2LocalFlowController(Http2Connection connection,
+                                           float windowUpdateRatio,
+                                           boolean autoRefillConnectionWindow) {
+        this.connection = checkNotNull(connection, ""connection"");
+        windowUpdateRatio(windowUpdateRatio);
+
+        // Add a flow state for the connection.
+        stateKey = connection.newKey();
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState connectionState = autoRefillConnectionWindow ?
+            new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.AutoRefillState(connection.connectionStream(), initialWindowSize) :
+            new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.DefaultState(connection.connectionStream(), initialWindowSize);
+        connection.connectionStream().setProperty(stateKey, connectionState);
+
+        // Register for notification of new streams.
+        connection.addListener(new Http2ConnectionAdapter() {
+            @Override
+            public void onStreamAdded(Http2Stream stream) {
+                // Unconditionally used the reduced flow control state because it requires no object allocation
+                // and the DefaultFlowState will be allocated in onStreamActive.
+                stream.setProperty(stateKey, REDUCED_FLOW_STATE);
+            }
+
+            @Override
+            public void onStreamActive(Http2Stream stream) {
+                // Need to be sure the stream's initial window is adjusted for SETTINGS
+                // frames which may have been exchanged while it was in IDLE
+                stream.setProperty(stateKey, new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.DefaultState(stream, initialWindowSize));
+            }
+
+            @Override
+            public void onStreamClosed(Http2Stream stream) {
+                try {
+                    // When a stream is closed, consume any remaining bytes so that they
+                    // are restored to the connection window.
+                    org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state = state(stream);
+                    int unconsumedBytes = state.unconsumedBytes();
+                    if (ctx != null && unconsumedBytes > 0) {
+                        if (consumeAllBytes(state, unconsumedBytes)) {
+                            // As the user has no real control on when this callback is used we should better
+                            // call flush() if we produced any window update to ensure we not stale.
+                            ctx.flush();
+                        }
+                    }
+                } catch (Http2Exception e) {
+                    PlatformDependent.throwException(e);
+                } finally {
+                    // Unconditionally reduce the amount of memory required for flow control because there is no
+                    // object allocation costs associated with doing so and the stream will not have any more
+                    // local flow control state to keep track of anymore.
+                    stream.setProperty(stateKey, REDUCED_FLOW_STATE);
+                }
+            }
+        });
+    }
+
+    @Override
+    public TriHttp2LocalFlowController frameWriter(Http2FrameWriter frameWriter) {
+        this.frameWriter = checkNotNull(frameWriter, ""frameWriter"");
+        return this;
+    }
+
+    @Override
+    public void channelHandlerContext(ChannelHandlerContext ctx) {
+        this.ctx = checkNotNull(ctx, ""ctx"");
+    }
+
+    @Override
+    public void initialWindowSize(int newWindowSize) throws Http2Exception {
+        assert ctx == null || ctx.executor().inEventLoop();
+        int delta = newWindowSize - initialWindowSize;
+        initialWindowSize = newWindowSize;
+
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.WindowUpdateVisitor visitor = new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.WindowUpdateVisitor(delta);
+        connection.forEachActiveStream(visitor);
+        visitor.throwIfError();
+    }
+
+    @Override
+    public int initialWindowSize() {
+        return initialWindowSize;
+    }
+
+    @Override
+    public int windowSize(Http2Stream stream) {
+        return state(stream).windowSize();
+    }
+
+    @Override
+    public int initialWindowSize(Http2Stream stream) {
+        return state(stream).initialWindowSize();
+    }
+
+    @Override
+    public void incrementWindowSize(Http2Stream stream, int delta) throws Http2Exception {
+        assert ctx != null && ctx.executor().inEventLoop();
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state = state(stream);
+        // Just add the delta to the stream-specific initial window size so that the next time the window
+        // expands it will grow to the new initial size.
+        state.incrementInitialStreamWindow(delta);
+        state.writeWindowUpdateIfNeeded();
+    }
+
+    @Override
+    public boolean consumeBytes(Http2Stream stream, int numBytes) throws Http2Exception {
+        assert ctx != null && ctx.executor().inEventLoop();
+        checkPositiveOrZero(numBytes, ""numBytes"");
+        if (numBytes == 0) {
+            return false;
+        }
+        //use triple flowcontroller
+        if(!(Thread.currentThread().getStackTrace()[2].getClassName().endsWith(""BiStreamServerCallListener"") || Thread.currentThread().getStackTrace()[2].getClassName().endsWith(""AbstractServerCallListener""))){
+            return false;
+        }
+        // Streams automatically consume all remaining bytes when they are closed, so just ignore
+        // if already closed.
+        if (stream != null && !isClosed(stream)) {
+            if (stream.id() == CONNECTION_STREAM_ID) {
+                throw new UnsupportedOperationException(""Returning bytes for the connection window is not supported"");
+            }
+
+            return consumeAllBytes(state(stream), numBytes);
+        }
+        return false;
+    }
+
+    private boolean consumeAllBytes(org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state, int numBytes) throws Http2Exception {
+        return connectionState().consumeBytes(numBytes) | state.consumeBytes(numBytes);
+    }
+
+    @Override
+    public int unconsumedBytes(Http2Stream stream) {
+        return state(stream).unconsumedBytes();
+    }
+
+    private static void checkValidRatio(float ratio) {
+        if (Double.compare(ratio, 0.0) <= 0 || Double.compare(ratio, 1.0) >= 0) {
+            throw new IllegalArgumentException(""Invalid ratio: "" + ratio);
+        }
+    }
+
+    /**
+     * The window update ratio is used to determine when a window update must be sent. If the ratio
+     * of bytes processed since the last update has meet or exceeded this ratio then a window update will
+     * be sent. This is the global window update ratio that will be used for new streams.
+     * @param ratio the ratio to use when checking if a {@code WINDOW_UPDATE} is determined necessary for new streams.
+     * @throws IllegalArgumentException If the ratio is out of bounds (0, 1).
+     */
+    public void windowUpdateRatio(float ratio) {
+        assert ctx == null || ctx.executor().inEventLoop();
+        checkValidRatio(ratio);
+        windowUpdateRatio = ratio;
+    }
+
+    /**
+     * The window update ratio is used to determine when a window update must be sent. If the ratio
+     * of bytes processed since the last update has meet or exceeded this ratio then a window update will
+     * be sent. This is the global window update ratio that will be used for new streams.
+     */
+    public float windowUpdateRatio() {
+        return windowUpdateRatio;
+    }
+
+    /**
+     * The window update ratio is used to determine when a window update must be sent. If the ratio
+     * of bytes processed since the last update has meet or exceeded this ratio then a window update will
+     * be sent. This window update ratio will only be applied to {@code streamId}.
+     * <p>
+     * Note it is the responsibly of the caller to ensure that the the
+     * initial {@code SETTINGS} frame is sent before this is called. It would
+     * be considered a {@link Http2Error#PROTOCOL_ERROR} if a {@code WINDOW_UPDATE}
+     * was generated by this method before the initial {@code SETTINGS} frame is sent.
+     * @param stream the stream for which {@code ratio} applies to.
+     * @param ratio the ratio to use when checking if a {@code WINDOW_UPDATE} is determined necessary.
+     * @throws Http2Exception If a protocol-error occurs while generating {@code WINDOW_UPDATE} frames
+     */
+    public void windowUpdateRatio(Http2Stream stream, float ratio) throws Http2Exception {
+        assert ctx != null && ctx.executor().inEventLoop();
+        checkValidRatio(ratio);
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state = state(stream);
+        state.windowUpdateRatio(ratio);
+        state.writeWindowUpdateIfNeeded();
+    }
+
+    /**
+     * The window update ratio is used to determine when a window update must be sent. If the ratio
+     * of bytes processed since the last update has meet or exceeded this ratio then a window update will
+     * be sent. This window update ratio will only be applied to {@code streamId}.
+     * @throws Http2Exception If no stream corresponding to {@code stream} could be found.
+     */
+    public float windowUpdateRatio(Http2Stream stream) throws Http2Exception {
+        return state(stream).windowUpdateRatio();
+    }
+
+    @Override
+    public void receiveFlowControlledFrame(Http2Stream stream, ByteBuf data, int padding,
+                                           boolean endOfStream) throws Http2Exception {
+        assert ctx != null && ctx.executor().inEventLoop();
+        int dataLength = data.readableBytes() + padding;
+
+        // Apply the connection-level flow control
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState connectionState = connectionState();
+        connectionState.receiveFlowControlledFrame(dataLength);
+
+        if (stream != null && !isClosed(stream)) {
+            // Apply the stream-level flow control
+            org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state = state(stream);
+            state.endOfStream(endOfStream);
+            state.receiveFlowControlledFrame(dataLength);
+        } else if (dataLength > 0) {
+            // Immediately consume the bytes for the connection window.
+            connectionState.consumeBytes(dataLength);
+        }
+    }
+
+    private org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState connectionState() {
+        return connection.connectionStream().getProperty(stateKey);
+    }
+
+    private org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state(Http2Stream stream) {
+        return stream.getProperty(stateKey);
+    }
+
+    private static boolean isClosed(Http2Stream stream) {
+        return stream.state() == Http2Stream.State.CLOSED;
+    }
+
+    /**
+     * Flow control state that does autorefill of the flow control window when the data is
+     * received.
+     */
+    private final class AutoRefillState extends org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.DefaultState {
+        AutoRefillState(Http2Stream stream, int initialWindowSize) {
+            super(stream, initialWindowSize);
+        }
+
+        @Override
+        public void receiveFlowControlledFrame(int dataLength) throws Http2Exception {
+            super.receiveFlowControlledFrame(dataLength);
+            // Need to call the super to consume the bytes, since this.consumeBytes does nothing.
+            super.consumeBytes(dataLength);
+        }
+
+        @Override
+        public boolean consumeBytes(int numBytes) throws Http2Exception {
+            // Do nothing, since the bytes are already consumed upon receiving the data.
+            return false;
+        }
+    }
+
+    /**
+     * Flow control window state for an individual stream.
+     */
+    private class DefaultState implements org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState {
+        private final Http2Stream stream;
+
+        /**
+         * The actual flow control window that is decremented as soon as {@code DATA} arrives.
+         */
+        private int window;
+
+        /**
+         * A view of {@link #window} that is used to determine when to send {@code WINDOW_UPDATE}
+         * frames. Decrementing this window for received {@code DATA} frames is delayed until the
+         * application has indicated that the data has been fully processed. This prevents sending
+         * a {@code WINDOW_UPDATE} until the number of processed bytes drops below the threshold.
+         */
+        private int processedWindow;
+
+        /**
+         * This is what is used to determine how many bytes need to be returned relative to {@link #processedWindow}.
+         * Each stream has their own initial window size.
+         */
+        private int initialStreamWindowSize;
+
+        /**
+         * This is used to determine when {@link #processedWindow} is sufficiently far away from
+         * {@link #initialStreamWindowSize} such that a {@code WINDOW_UPDATE} should be sent.
+         * Each stream has their own window update ratio.
+         */
+        private float streamWindowUpdateRatio;
+
+        private int lowerBound;
+        private boolean endOfStream;
+
+        DefaultState(Http2Stream stream, int initialWindowSize) {
+            this.stream = stream;
+            window(initialWindowSize);
+            streamWindowUpdateRatio = windowUpdateRatio;
+        }
+
+        @Override
+        public void window(int initialWindowSize) {
+            assert ctx == null || ctx.executor().inEventLoop();
+            window = processedWindow = initialStreamWindowSize = initialWindowSize;
+        }
+
+        @Override
+        public int windowSize() {
+            return window;
+        }
+
+        @Override
+        public int initialWindowSize() {
+            return initialStreamWindowSize;
+        }
+
+        @Override
+        public void endOfStream(boolean endOfStream) {
+            this.endOfStream = endOfStream;
+        }
+
+        @Override
+        public float windowUpdateRatio() {
+            return streamWindowUpdateRatio;
+        }
+
+        @Override
+        public void windowUpdateRatio(float ratio) {
+            assert ctx == null || ctx.executor().inEventLoop();
+            streamWindowUpdateRatio = ratio;
+        }
+
+        @Override
+        public void incrementInitialStreamWindow(int delta) {
+            // Clip the delta so that the resulting initialStreamWindowSize falls within the allowed range.
+            int newValue = (int) min(MAX_INITIAL_WINDOW_SIZE,
+                max(MIN_INITIAL_WINDOW_SIZE, initialStreamWindowSize + (long) delta));
+            delta = newValue - initialStreamWindowSize;
+
+            initialStreamWindowSize += delta;
+        }
+
+        @Override
+        public void incrementFlowControlWindows(int delta) throws Http2Exception {
+            if (delta > 0 && window > MAX_INITIAL_WINDOW_SIZE - delta) {
+                throw streamError(stream.id(), FLOW_CONTROL_ERROR,
+                    ""Flow control window overflowed for stream: %d"", stream.id());
+            }
+
+            window += delta;
+            processedWindow += delta;
+            lowerBound = delta < 0 ? delta : 0;
+        }
+
+        @Override
+        public void receiveFlowControlledFrame(int dataLength) throws Http2Exception {
+            assert dataLength >= 0;
+
+            // Apply the delta. Even if we throw an exception we want to have taken this delta into account.
+            window -= dataLength;
+
+            // Window size can become negative if we sent a SETTINGS frame that reduces the
+            // size of the transfer window after the peer has written data frames.
+            // The value is bounded by the length that SETTINGS frame decrease the window.
+            // This difference is stored for the connection when writing the SETTINGS frame
+            // and is cleared once we send a WINDOW_UPDATE frame.
+            if (window < lowerBound) {
+                throw streamError(stream.id(), FLOW_CONTROL_ERROR,
+                    ""Flow control window exceeded for stream: %d"", stream.id());
+            }
+        }
+
+        private void returnProcessedBytes(int delta) throws Http2Exception {
+            if (processedWindow - delta < window) {
+                throw streamError(stream.id(), INTERNAL_ERROR,
+                    ""Attempting to return too many bytes for stream %d"", stream.id());
+            }
+            processedWindow -= delta;
+        }
+
+        @Override
+        public boolean consumeBytes(int numBytes) throws Http2Exception {
+            // Return the bytes processed and update the window.
+            returnProcessedBytes(numBytes);
+            return writeWindowUpdateIfNeeded();
+        }
+
+        @Override
+        public int unconsumedBytes() {
+            return processedWindow - window;
+        }
+
+        @Override
+        public boolean writeWindowUpdateIfNeeded() throws Http2Exception {
+            if (endOfStream || initialStreamWindowSize <= 0 ||
+                // If the stream is already closed there is no need to try to write a window update for it.
+                isClosed(stream)) {
+                return false;
+            }
+
+            int threshold = (int) (initialStreamWindowSize * streamWindowUpdateRatio);
+            if (processedWindow <= threshold) {
+                writeWindowUpdate();
+                return true;
+            }
+            return false;
+        }
+
+        /**
+         * Called to perform a window update for this stream (or connection). Updates the window size back
+         * to the size of the initial window and sends a window update frame to the remote endpoint.
+         */
+        private void writeWindowUpdate() throws Http2Exception {
+            // Expand the window for this stream back to the size of the initial window.
+            int deltaWindowSize = initialStreamWindowSize - processedWindow;
+            try {
+                incrementFlowControlWindows(deltaWindowSize);
+            } catch (Throwable t) {
+                throw connectionError(INTERNAL_ERROR, t,
+                    ""Attempting to return too many bytes for stream %d"", stream.id());
+            }
+
+            System.out.println(""send window update id: "" + stream.id() + "" size: "" + deltaWindowSize);
+            StackTraceElement[] str = Thread.currentThread().getStackTrace();
+            for(int i = 0; i< 15; i++){
+                System.out.println(""send window update id: "" + stream.id() + "" class: "" + str[i].getClassName());","[{'comment': 'should be replaced to logger. sout here is not allow', 'commenter': 'AlbumenJ'}]"
10672,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ServerStreamServerCallListener.java,"@@ -34,11 +40,19 @@ public void onReturn(Object value) {
     }
 
     @Override
-    public void onMessage(Object message) {
+    public void onMessage(Object message,DefaultHttp2WindowUpdateFrame stream, Http2Connection connection) {","[{'comment': 'Can these parameters not be added to the interface?', 'commenter': 'EarthChen'}, {'comment': 'If it is necessary to add DefaultHttp2WindowUpdateFrame, can it be replaced with an interface?', 'commenter': 'EarthChen'}]"
10672,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ServerStreamServerCallListener.java,"@@ -34,11 +40,19 @@ public void onReturn(Object value) {
     }
 
     @Override
-    public void onMessage(Object message) {
+    public void onMessage(Object message,DefaultHttp2WindowUpdateFrame stream, Http2Connection connection) {
         if (message instanceof Object[]) {
             message = ((Object[]) message)[0];
         }
         invocation.setArguments(new Object[]{message, responseObserver});
+        invocation.setAttachment(""tri-connection"",connection);","[{'comment': 'Is it possible to pass parameters transparently without invocation?', 'commenter': 'EarthChen'}]"
10672,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/frame/TriDecoder.java,"@@ -37,23 +39,38 @@ public class TriDecoder implements Deframer {
     private boolean inDelivery = false;
     private boolean closing;
     private boolean closed;
-
+    private Http2Connection connection;
     private int requiredLength = HEADER_LENGTH;
 
+    private int flowControlledBytes;
+
+    private Http2FrameStream stream;","[{'comment': 'It seems that these parameters can be obtained in `onRawMessage`', 'commenter': 'EarthChen'}]"
10672,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/BiStreamServerCallListener.java,"@@ -41,13 +49,27 @@ public void onReturn(Object value) {
 
     @Override
     public void onMessage(Object message) {
-        if (message instanceof Object[]) {
-            message = ((Object[]) message)[0];
+        if (((TripleFlowControlFrame) message).getInstance() instanceof Object[]) {","[{'comment': 'the message is must be TripleFlowControlFrame？', 'commenter': 'EarthChen'}, {'comment': 'in my test,it must be TripleFlowControlFrame,but I added type judgment in the latest version。', 'commenter': 'asa3311'}]"
10672,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/UnaryServerCallListener.java,"@@ -37,11 +49,15 @@ public void onReturn(Object value) {
 
     @Override
     public void onMessage(Object message) {
-        if (message instanceof Object[]) {
-            invocation.setArguments((Object[]) message);
+        if (((TripleFlowControlFrame) message).getInstance() instanceof Object[]) {","[{'comment': 'same', 'commenter': 'EarthChen'}, {'comment': 'in my test,it must be TripleFlowControlFrame,but I added type judgment in the latest version。', 'commenter': 'asa3311'}]"
10672,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java,"@@ -112,15 +112,18 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
     public void onDataRead(ChannelHandlerContext ctx, Http2DataFrame msg) throws Exception {
         final TripleServerStream tripleServerStream = ctx.channel().attr(SERVER_STREAM_KEY)
             .get();
-        tripleServerStream.transportObserver.onData(msg.content(), msg.isEndStream());
+        tripleServerStream.transportObserver.onData(msg, msg.isEndStream());
     }
 
     public void onHeadersRead(ChannelHandlerContext ctx, Http2HeadersFrame msg) throws Exception {
         TripleServerStream tripleServerStream = new TripleServerStream(ctx.channel(),
             frameworkModel, executor,
             pathResolver, acceptEncoding, filters);
         ctx.channel().attr(SERVER_STREAM_KEY).set(tripleServerStream);
-        tripleServerStream.transportObserver.onHeader(msg.headers(), msg.isEndStream());
+
+        //transmit connection to triple invoke to flowcontrol
+        Http2Connection connection = (Http2Connection)ctx.channel().attr(AttributeKey.valueOf(""tri-connection"")).get();","[{'comment': 'Change AttributeKey to a constant', 'commenter': 'EarthChen'}, {'comment': 'done', 'commenter': 'asa3311'}]"
10683,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/annotation/QosServer.java,"@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.qos.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Prompt to add dubbo qos dependency. If you know qos dependency is needed or it has been added,
+ * you don't have to write this annotation.
+ */
+@Retention(RetentionPolicy.SOURCE)
+@Target(ElementType.TYPE)
+public @interface QosServer {
+}","[{'comment': 'Was it better to use a logger to log out when user config `dubbo.application.qos-xxx` if dubbo-qos denendency is absent?', 'commenter': 'AlbumenJ'}, {'comment': '`dubbo.application.qos-enable` has default value `true`. Does it make user think qos should start even though there is no any qos configuration (system property, dubbo.properties, xml or springboot autoconfigure) in project?', 'commenter': 'pandaapo'}, {'comment': ""How about this:  when user don't config `dubbo.application.qos-enable=false` and there is no dubbo-qos dependency, use a logger to output tips?"", 'commenter': 'pandaapo'}, {'comment': 'ok.\r\n\r\nI think it would be better to log out what current environment have / do not have as a info message. Including `dubbo-qos`, `dubbo-registry-xxx`, `dubbo-rpc-xxx`...', 'commenter': 'AlbumenJ'}, {'comment': 'Made changes as you said. \r\nWould you review it again? @AlbumenJ ', 'commenter': 'pandaapo'}]"
10683,dubbo-common/src/main/java/org/apache/dubbo/config/context/ConfigManager.java,"@@ -295,6 +295,14 @@ private void checkConfigs() {
             }
             protocolPortMap.put(port, protocol);
         }
+
+        // Log the current configurations.
+        logger.info(""The current configurations or effective configurations are as follows:"");
+        for (Class<? extends AbstractConfig> configType : multipleConfigTypes) {
+            getConfigs(configType).stream().forEach((config) -> {
+                logger.info(config.toString());
+            });
+        }","[{'comment': 'Will this work?', 'commenter': 'AlbumenJ'}, {'comment': ""Yes. It's like\r\n![1665376365193](https://user-images.githubusercontent.com/35672972/194799740-1a291f5d-bc43-439e-b736-cb11f96d0c75.png)\r\n"", 'commenter': 'pandaapo'}]"
10686,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -478,16 +478,21 @@ private void meshModeHandleUrl(Map<String, String> referenceParameters) {
             }
             return;
         }
-        // get pod namespace
-        String podNamespace;
-        if (StringUtils.isEmpty(System.getenv(""POD_NAMESPACE""))) {
-            if (logger.isWarnEnabled()) {
-                logger.warn(CONFIG_FAILED_LOAD_ENV_VARIABLE, """", """", ""Can not get env variable: POD_NAMESPACE, it may not be running in the K8S environment , "" +
-                    ""finally use 'default' replace."");
+
+        // get provider namespace if @DubboReference present
+        String podNamespace = Optional.ofNullable(referenceParameters.get(RegistryConstants.PROVIDER_NAMESPACE)).orElse(null);","[{'comment': 'why use `Optional.ofNullable`', 'commenter': 'AlbumenJ'}, {'comment': 'why use `Optional.ofNullable`', 'commenter': 'AlbumenJ'}, {'comment': 'avoid npe', 'commenter': 'niejian'}, {'comment': '`Optional.ofNullable(referenceParameters.get(RegistryConstants.PROVIDER_NAMESPACE))` could not avoid NPE when referenceParameters is null', 'commenter': 'AlbumenJ'}, {'comment': '看代码变量referenceParameters  不会为空的吧`ReferenceConfig#appendConfig (376)`,  那这个判断是不是可以优化成 `referenceParameters.getOrDefault(""xxx"", null)` 来做吧？\r\n\r\n![image](https://user-images.githubusercontent.com/7080323/192661943-09fdd8c9-d21e-46f5-bcc8-b0867c8314dd.png)', 'commenter': 'niejian'}, {'comment': 'get', 'commenter': 'niejian'}, {'comment': '直接 get 就行了呀，默认空就是返回 null\r\n\r\n另外下面 `null == podNamespace` 最好换成 StringUtils.isNotEmpty', 'commenter': 'AlbumenJ'}, {'comment': '已经改了', 'commenter': 'niejian'}]"
10726,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/frame/MessageFramer.java,"@@ -0,0 +1,55 @@
+package org.apache.dubbo.rpc.protocol.tri.frame;
+
+import org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;
+import org.apache.dubbo.rpc.protocol.tri.command.EndStreamQueueCommand;
+import org.apache.dubbo.rpc.protocol.tri.transport.WriteQueue;
+
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+/**","[{'comment': 'remove', 'commenter': 'EarthChen'}]"
10726,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/ClientStream.java,"@@ -69,9 +69,7 @@ default void onComplete(TriRpcStatus status, Map<String, Object> attachments,
 
     /**
      * No more data will be sent, half close this stream to wait server response.
-     *
-     * @return a future of send result
      */
-    Future<?> halfClose();
+    void halfClose();","[{'comment': 'why change?', 'commenter': 'EarthChen'}]"
10726,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/buffer/WritableBuffer.java,"@@ -0,0 +1,65 @@
+/*
+ * Copyright 2015 The gRPC Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.remoting.buffer;
+
+/**
+ * An interface for a byte buffer that can only be written to.
+ * {@link WritableBuffer}s are a generic way to transfer bytes to
+ * the concrete network transports, like Netty and OkHttp.
+ */
+public interface WritableBuffer {
+
+  /**
+   * Appends {@code length} bytes to the buffer from the source
+   * array starting at {@code srcIndex}.
+   *
+   * @throws IndexOutOfBoundsException
+   *         if the specified {@code srcIndex} is less than {@code 0},
+   *         if {@code srcIndex + length} is greater than
+   *            {@code src.length}, or
+   *         if {@code length} is greater than {@link #writableBytes()}
+   */
+  void write(byte[] src, int srcIndex, int length);
+
+  /**
+   * Appends a single byte to the buffer.  This is slow so don't call it.
+   */
+  void write(byte b);
+
+
+    /**","[{'comment': 'format', 'commenter': 'EarthChen'}]"
10726,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/frame/Framer.java,"@@ -0,0 +1,32 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri.frame;
+
+import io.netty.channel.ChannelFuture;
+import org.apache.dubbo.rpc.protocol.tri.compressor.Compressor;
+
+public interface Framer {","[{'comment': 'format & comment..', 'commenter': 'EarthChen'}]"
10726,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java,"@@ -131,33 +139,39 @@ public SocketAddress remoteAddress() {
         return parent.remoteAddress();
     }
 
-
     @Override
-    public ChannelFuture sendMessage(byte[] message, int compressFlag, boolean eos) {
-        final DataQueueCommand cmd = DataQueueCommand.createGrpcCommand(message, false,
-            compressFlag);
-        return this.writeQueue.enqueue(cmd)
-            .addListener(future -> {
-                    if (!future.isSuccess()) {
-                        cancelByLocal(
-                            TriRpcStatus.INTERNAL.withDescription(""Client write message failed"")
-                                .withCause(future.cause())
-                        );
-                        transportException(future.cause());
-                    }
-                }
-            );
+    public Future<?> sendMessage(byte[] message) {
+        framer.writePayload(message);
+        return parent.newSucceededFuture();","[{'comment': ""future doesn't seem to make sense here."", 'commenter': 'EarthChen'}]"
10726,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/command/FrameQueueCommand.java,"@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri.command;
+
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPromise;
+import io.netty.handler.codec.http2.Http2StreamFrame;
+
+public class FrameQueueCommand extends QueuedCommand {","[{'comment': 'What does this cmd do？', 'commenter': 'EarthChen'}, {'comment': '构建Http2StreamFrame的逻辑放入业务线程，eventloop线程只发送Http2StreamFrame', 'commenter': 'owen200008'}]"
10726,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/command/FrameQueueCommand.java,"@@ -18,15 +18,25 @@
 package org.apache.dubbo.rpc.protocol.tri.command;
 
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
+import io.netty.handler.codec.http2.Http2StreamFrame;
 
-public abstract class QueuedCommand {
+public class FrameQueueCommand {","[{'comment': 'I recommend that the different child cmd not be deleted, the design is used to mask the h2 data structure', 'commenter': 'EarthChen'}]"
10728,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/Netty4BatchWriteQueue.java,"@@ -0,0 +1,79 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.transport.netty4;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelPromise;
+import io.netty.channel.EventLoop;
+import org.apache.dubbo.common.BatchExecutorQueue;
+
+/**
+ * netty4 batch write queue
+ *
+ * @author icodening
+ * @date 2022.10.11","[{'comment': 'pls remove `author` and `date` ', 'commenter': 'AlbumenJ'}, {'comment': 'OK ', 'commenter': 'icodening'}]"
10730,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java,"@@ -196,4 +197,12 @@ public ConsumerModel registerInternalConsumer(Class<?> internalService, URL url)
         serviceRepository.registerConsumer(consumerModel);
         return consumerModel;
     }
+
+    public boolean isBindSpring() {","[{'comment': 'rename to `isLifeCycleManagedExternally`', 'commenter': 'AlbumenJ'}]"
10730,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java,"@@ -77,7 +82,44 @@ public void run() {
     }
 
     private void doDestroy() {
-        applicationModel.destroy();
+        boolean hasModuleBindSpring = false;
+        // check if any modules are bound to Spring
+        for (ModuleModel module: applicationModel.getModuleModels()) {
+            if (module.isBindSpring()) {
+                hasModuleBindSpring = true;
+                break;
+            }
+        }
+        if (hasModuleBindSpring) {","[{'comment': 'log out to notice user that dubbo is waiting spring to shutdown', 'commenter': 'AlbumenJ'}]"
10730,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/DubboShutdownHook.java,"@@ -77,7 +82,44 @@ public void run() {
     }
 
     private void doDestroy() {
-        applicationModel.destroy();
+        boolean hasModuleBindSpring = false;
+        // check if any modules are bound to Spring
+        for (ModuleModel module: applicationModel.getModuleModels()) {
+            if (module.isBindSpring()) {
+                hasModuleBindSpring = true;
+                break;
+            }
+        }
+        if (hasModuleBindSpring) {
+            int timeout = ConfigurationUtils.getServerShutdownTimeout(applicationModel);
+            if (timeout > 0) {
+                long start = System.currentTimeMillis();
+                /**
+                 * To avoid shutdown conflicts between Dubbo and Spring,
+                 * wait for the modules bound to Spring to be handled by Spring util timeout.
+                 */
+                while (!applicationModel.isDestroyed() && hasModuleBindSpring
+                    && (System.currentTimeMillis() - start) < timeout) {
+                    try {
+                        TimeUnit.MILLISECONDS.sleep(10);
+                        hasModuleBindSpring = false;
+                        if (!applicationModel.isDestroyed()) {
+                            for (ModuleModel module: applicationModel.getModuleModels()) {
+                                if (module.isBindSpring()) {
+                                    hasModuleBindSpring = true;
+                                    break;
+                                }
+                            }
+                        }
+                    } catch (InterruptedException e) {
+                        logger.warn(e.getMessage(), e);
+                    }
+                }
+            }
+        }
+        if (!applicationModel.isDestroyed()) {","[{'comment': 'log out if wait spring failed', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/AdaptiveLoadBalanceFilter.java,"@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.filter.support;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.profiler.Profiler;
+import org.apache.dubbo.common.profiler.ProfilerEntry;
+import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.*;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.cluster.loadbalance.AdaptiveLoadBalance;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.*;
+
+/**
+ * if the load balance is adaptive ,set attachment to get the metrics of the server
+ * @see Filter
+ * @see RpcContext
+ */
+@Activate(group = CONSUMER, order = -200000)
+public class AdaptiveLoadBalanceFilter implements ClusterFilter, ClusterFilter.Listener {
+
+    /**
+     * uses a single worker thread operating off an bounded queue
+     */
+    private static final ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(1024),","[{'comment': 'should be lazy init or use dubbo shared executor', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/AdaptiveLoadBalanceFilter.java,"@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.filter.support;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.profiler.Profiler;
+import org.apache.dubbo.common.profiler.ProfilerEntry;
+import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.cluster.loadbalance.AdaptiveLoadBalance;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+import static org.apache.dubbo.common.constants.CommonConstants.LOADBALANCE_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;
+
+/**
+ * if the load balance is adaptive ,set attachment to get the metrics of the server
+ * @see org.apache.dubbo.rpc.Filter
+ * @see org.apache.dubbo.rpc.RpcContext
+ */
+@Activate(group = CONSUMER, order = -200000)
+public class AdaptiveLoadBalanceFilter implements ClusterFilter, ClusterFilter.Listener {
+
+    /**
+     * uses a single worker thread operating off an bounded queue
+     */
+    private ThreadPoolExecutor executor;
+
+    public AdaptiveLoadBalanceFilter(ApplicationModel applicationModel) {
+        executor = new ThreadPoolExecutor(1, 1, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(1024),
+            new NamedInternalThreadFactory(""Dubbo-framework-loadbalance-adaptive"", true), new ThreadPoolExecutor.DiscardOldestPolicy());","[{'comment': 'should not create executor by default when user do not use this', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/AdaptiveLoadBalanceFilter.java,"@@ -0,0 +1,126 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.filter.support;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.profiler.Profiler;
+import org.apache.dubbo.common.profiler.ProfilerEntry;
+import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.cluster.loadbalance.AdaptiveLoadBalance;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+import static org.apache.dubbo.common.constants.CommonConstants.LOADBALANCE_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;
+
+/**
+ * if the load balance is adaptive ,set attachment to get the metrics of the server
+ * @see org.apache.dubbo.rpc.Filter
+ * @see org.apache.dubbo.rpc.RpcContext
+ */
+@Activate(group = CONSUMER, order = -200000)
+public class AdaptiveLoadBalanceFilter implements ClusterFilter, ClusterFilter.Listener {
+
+    /**
+     * uses a single worker thread operating off an bounded queue
+     */
+    private ThreadPoolExecutor executor = null;
+
+    private ThreadPoolExecutor getExecutor(){
+        if (null == executor) {
+            synchronized (this) {
+                if (null == executor) {
+                    executor = new ThreadPoolExecutor(1, 1, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(1024),
+                        new NamedInternalThreadFactory(""Dubbo-framework-loadbalance-adaptive"", true), new ThreadPoolExecutor.DiscardOldestPolicy());","[{'comment': 'Register to `org.apache.dubbo.common.resource.GlobalResourcesRepository#registerDisposable`', 'commenter': 'AlbumenJ'}]"
10745,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AdaptiveMetrics.java,"@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc;
+
+import org.apache.dubbo.common.utils.StringUtils;
+
+import java.util.Map;
+import java.util.Optional;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * adaptive Metrics statistics.
+ */
+public class AdaptiveMetrics {
+
+    private static final ConcurrentMap<String, AdaptiveMetrics> METRICS_STATISTICS = new ConcurrentHashMap<String,","[{'comment': 'Should not use static field to store status in Dubbo. Use scope bean instead', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/AdaptiveLoadBalanceFilter.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.filter.support;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.profiler.Profiler;
+import org.apache.dubbo.common.profiler.ProfilerEntry;
+import org.apache.dubbo.common.resource.GlobalResourcesRepository;
+import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.cluster.loadbalance.AdaptiveLoadBalance;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+import static org.apache.dubbo.common.constants.CommonConstants.LOADBALANCE_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;
+
+/**
+ * if the load balance is adaptive ,set attachment to get the metrics of the server
+ * @see org.apache.dubbo.rpc.Filter
+ * @see org.apache.dubbo.rpc.RpcContext
+ */
+@Activate(group = CONSUMER, order = -200000)","[{'comment': '```suggestion\r\n@Activate(group = CONSUMER, order = -200000, value = {""loadbalance:adaptive""})\r\n```', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/AdaptiveLoadBalanceFilter.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.filter.support;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.profiler.Profiler;
+import org.apache.dubbo.common.profiler.ProfilerEntry;
+import org.apache.dubbo.common.resource.GlobalResourcesRepository;
+import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.cluster.loadbalance.AdaptiveLoadBalance;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+import static org.apache.dubbo.common.constants.CommonConstants.LOADBALANCE_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;
+
+/**
+ * if the load balance is adaptive ,set attachment to get the metrics of the server
+ * @see org.apache.dubbo.rpc.Filter
+ * @see org.apache.dubbo.rpc.RpcContext
+ */
+@Activate(group = CONSUMER, order = -200000)
+public class AdaptiveLoadBalanceFilter implements ClusterFilter, ClusterFilter.Listener , ScopeModelAware {
+
+    /**
+     * uses a single worker thread operating off an bounded queue
+     */
+    private ThreadPoolExecutor executor = null;
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Override
+    public void setApplicationModel(ApplicationModel scopeModel) {","[{'comment': 'replace to constructor', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/AdaptiveLoadBalanceFilter.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.filter.support;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.profiler.Profiler;
+import org.apache.dubbo.common.profiler.ProfilerEntry;
+import org.apache.dubbo.common.resource.GlobalResourcesRepository;
+import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.cluster.loadbalance.AdaptiveLoadBalance;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+import static org.apache.dubbo.common.constants.CommonConstants.LOADBALANCE_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;
+
+/**
+ * if the load balance is adaptive ,set attachment to get the metrics of the server
+ * @see org.apache.dubbo.rpc.Filter
+ * @see org.apache.dubbo.rpc.RpcContext
+ */
+@Activate(group = CONSUMER, order = -200000)
+public class AdaptiveLoadBalanceFilter implements ClusterFilter, ClusterFilter.Listener , ScopeModelAware {
+
+    /**
+     * uses a single worker thread operating off an bounded queue
+     */
+    private ThreadPoolExecutor executor = null;
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Override
+    public void setApplicationModel(ApplicationModel scopeModel) {
+        AdaptiveMetrics bean = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        if (bean == null) {
+            scopeModel.getBeanFactory().registerBean(new AdaptiveMetrics());","[{'comment': 'Add into `ScopeBeanInitializer`', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/AdaptiveLoadBalanceFilter.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.filter.support;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.profiler.Profiler;
+import org.apache.dubbo.common.profiler.ProfilerEntry;
+import org.apache.dubbo.common.resource.GlobalResourcesRepository;
+import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.cluster.loadbalance.AdaptiveLoadBalance;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+import static org.apache.dubbo.common.constants.CommonConstants.LOADBALANCE_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;
+
+/**
+ * if the load balance is adaptive ,set attachment to get the metrics of the server
+ * @see org.apache.dubbo.rpc.Filter
+ * @see org.apache.dubbo.rpc.RpcContext
+ */
+@Activate(group = CONSUMER, order = -200000)
+public class AdaptiveLoadBalanceFilter implements ClusterFilter, ClusterFilter.Listener , ScopeModelAware {
+
+    /**
+     * uses a single worker thread operating off an bounded queue
+     */
+    private ThreadPoolExecutor executor = null;
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Override
+    public void setApplicationModel(ApplicationModel scopeModel) {
+        AdaptiveMetrics bean = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        if (bean == null) {
+            scopeModel.getBeanFactory().registerBean(new AdaptiveMetrics());
+        }
+        this.scopeModel = scopeModel;
+    }
+
+    private ThreadPoolExecutor getExecutor(){
+        if (null == executor) {
+            synchronized (this) {
+                if (null == executor) {
+                    executor = new ThreadPoolExecutor(1, 1, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(1024),
+                        new NamedInternalThreadFactory(""Dubbo-framework-loadbalance-adaptive"", true), new ThreadPoolExecutor.DiscardOldestPolicy());
+                    GlobalResourcesRepository.getInstance().registerDisposable(() -> this.executor.shutdown());
+                }
+            }
+        }
+        return executor;
+    }
+
+    private AdaptiveMetrics getAdaptiveMetricsInstance(){
+        if (adaptiveMetrics == null) {
+            adaptiveMetrics = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        }
+        return adaptiveMetrics;
+    }","[{'comment': 'move to constructor', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/AdaptiveLoadBalanceFilter.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.filter.support;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.profiler.Profiler;
+import org.apache.dubbo.common.profiler.ProfilerEntry;
+import org.apache.dubbo.common.resource.GlobalResourcesRepository;
+import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.cluster.loadbalance.AdaptiveLoadBalance;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+import static org.apache.dubbo.common.constants.CommonConstants.LOADBALANCE_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;
+
+/**
+ * if the load balance is adaptive ,set attachment to get the metrics of the server
+ * @see org.apache.dubbo.rpc.Filter
+ * @see org.apache.dubbo.rpc.RpcContext
+ */
+@Activate(group = CONSUMER, order = -200000)
+public class AdaptiveLoadBalanceFilter implements ClusterFilter, ClusterFilter.Listener , ScopeModelAware {
+
+    /**
+     * uses a single worker thread operating off an bounded queue
+     */
+    private ThreadPoolExecutor executor = null;
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Override
+    public void setApplicationModel(ApplicationModel scopeModel) {
+        AdaptiveMetrics bean = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        if (bean == null) {
+            scopeModel.getBeanFactory().registerBean(new AdaptiveMetrics());
+        }
+        this.scopeModel = scopeModel;
+    }","[{'comment': 'move to constructor', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/AdaptiveLoadBalanceFilter.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.filter.support;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.profiler.Profiler;
+import org.apache.dubbo.common.profiler.ProfilerEntry;
+import org.apache.dubbo.common.resource.GlobalResourcesRepository;
+import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.cluster.loadbalance.AdaptiveLoadBalance;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+import static org.apache.dubbo.common.constants.CommonConstants.LOADBALANCE_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;
+
+/**
+ * if the load balance is adaptive ,set attachment to get the metrics of the server
+ * @see org.apache.dubbo.rpc.Filter
+ * @see org.apache.dubbo.rpc.RpcContext
+ */
+@Activate(group = CONSUMER, order = -200000)
+public class AdaptiveLoadBalanceFilter implements ClusterFilter, ClusterFilter.Listener , ScopeModelAware {
+
+    /**
+     * uses a single worker thread operating off an bounded queue
+     */
+    private ThreadPoolExecutor executor = null;
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Override
+    public void setApplicationModel(ApplicationModel scopeModel) {
+        AdaptiveMetrics bean = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        if (bean == null) {
+            scopeModel.getBeanFactory().registerBean(new AdaptiveMetrics());
+        }
+        this.scopeModel = scopeModel;
+    }
+
+    private ThreadPoolExecutor getExecutor(){
+        if (null == executor) {
+            synchronized (this) {
+                if (null == executor) {
+                    executor = new ThreadPoolExecutor(1, 1, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(1024),
+                        new NamedInternalThreadFactory(""Dubbo-framework-loadbalance-adaptive"", true), new ThreadPoolExecutor.DiscardOldestPolicy());
+                    GlobalResourcesRepository.getInstance().registerDisposable(() -> this.executor.shutdown());
+                }
+            }
+        }
+        return executor;
+    }
+
+    private AdaptiveMetrics getAdaptiveMetricsInstance(){
+        if (adaptiveMetrics == null) {
+            adaptiveMetrics = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        }
+        return adaptiveMetrics;
+    }
+
+    @Override
+    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
+        return invoker.invoke(invocation);
+    }
+
+    private String buildServiceKey(Invocation invocation){
+        return invocation.getInvoker().getUrl().getAddress() + "":"" + invocation.getProtocolServiceKey();","[{'comment': 'replace to StringBuilder and set initial size to improve performance', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/AdaptiveLoadBalanceFilter.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.filter.support;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.profiler.Profiler;
+import org.apache.dubbo.common.profiler.ProfilerEntry;
+import org.apache.dubbo.common.resource.GlobalResourcesRepository;
+import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.cluster.loadbalance.AdaptiveLoadBalance;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+import static org.apache.dubbo.common.constants.CommonConstants.LOADBALANCE_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;
+
+/**
+ * if the load balance is adaptive ,set attachment to get the metrics of the server
+ * @see org.apache.dubbo.rpc.Filter
+ * @see org.apache.dubbo.rpc.RpcContext
+ */
+@Activate(group = CONSUMER, order = -200000)
+public class AdaptiveLoadBalanceFilter implements ClusterFilter, ClusterFilter.Listener , ScopeModelAware {
+
+    /**
+     * uses a single worker thread operating off an bounded queue
+     */
+    private ThreadPoolExecutor executor = null;
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Override
+    public void setApplicationModel(ApplicationModel scopeModel) {
+        AdaptiveMetrics bean = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        if (bean == null) {
+            scopeModel.getBeanFactory().registerBean(new AdaptiveMetrics());
+        }
+        this.scopeModel = scopeModel;
+    }
+
+    private ThreadPoolExecutor getExecutor(){
+        if (null == executor) {
+            synchronized (this) {
+                if (null == executor) {
+                    executor = new ThreadPoolExecutor(1, 1, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(1024),
+                        new NamedInternalThreadFactory(""Dubbo-framework-loadbalance-adaptive"", true), new ThreadPoolExecutor.DiscardOldestPolicy());
+                    GlobalResourcesRepository.getInstance().registerDisposable(() -> this.executor.shutdown());
+                }
+            }
+        }
+        return executor;
+    }
+
+    private AdaptiveMetrics getAdaptiveMetricsInstance(){
+        if (adaptiveMetrics == null) {
+            adaptiveMetrics = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        }
+        return adaptiveMetrics;
+    }
+
+    @Override
+    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
+        return invoker.invoke(invocation);
+    }
+
+    private String buildServiceKey(Invocation invocation){
+        return invocation.getInvoker().getUrl().getAddress() + "":"" + invocation.getProtocolServiceKey();
+        //return url.getAddress() + ProtocolUtils.serviceKey(url.getPort(), url.getPath(), url.getVersion(), url.getGroup());
+    }
+
+    @Override
+    public void onResponse(Result appResponse, Invoker<?> invoker, Invocation invocation) {
+
+        try {
+            if (StringUtils.isNotEmpty(invoker.getUrl().getParameter(LOADBALANCE_KEY))
+                && AdaptiveLoadBalance.NAME.equals(invoker.getUrl().getParameter(LOADBALANCE_KEY))) {
+                getAdaptiveMetricsInstance().addConsumerSuccess(buildServiceKey(invocation));
+            }
+            String attachment = appResponse.getAttachment(Constants.ADAPTIVE_LOADBALANCE_ATTACHMENT_KEY);
+            if (StringUtils.isNotEmpty(attachment)) {
+                String[] parties = COMMA_SPLIT_PATTERN.split(attachment);
+                if (parties.length == 0) {
+                    return;
+                }
+                Map<String, String> metricsMap = new HashMap<>();
+                for (String party : parties) {
+                    String[] groups = party.split("":"");
+                    if (groups.length != 2) {
+                        continue;
+                    }
+                    metricsMap.put(groups[0], groups[1]);
+                }
+                ProfilerEntry profilerEntry = (ProfilerEntry) invocation.getAttributes().get(Profiler.PROFILER_KEY);","[{'comment': 'handle NPE if `profilerEntry` is null', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AdaptiveLoadBalance.java,"@@ -0,0 +1,140 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.TimeoutCountDown;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+import org.apache.dubbo.rpc.support.RpcUtils;
+
+import java.util.List;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.TIME_COUNTDOWN_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_TIMEOUT;
+
+/**
+ * AdaptiveLoadBalance
+ * </p>
+ */
+public class AdaptiveLoadBalance extends AbstractLoadBalance implements ScopeModelAware {
+
+    public static final String NAME = ""adaptive"";
+
+    //default key
+    private String attachmentKey = ""mem,load"";
+
+    private final int default_timeout = 30_000;
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Override
+    public void setApplicationModel(ApplicationModel scopeModel){
+        AdaptiveMetrics bean = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        if (bean == null) {
+            scopeModel.getBeanFactory().registerBean(new AdaptiveMetrics());
+        }
+        this.scopeModel = scopeModel;
+    }","[{'comment': 'move to constructor', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AdaptiveLoadBalance.java,"@@ -0,0 +1,140 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.TimeoutCountDown;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+import org.apache.dubbo.rpc.support.RpcUtils;
+
+import java.util.List;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.TIME_COUNTDOWN_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_TIMEOUT;
+
+/**
+ * AdaptiveLoadBalance
+ * </p>
+ */
+public class AdaptiveLoadBalance extends AbstractLoadBalance implements ScopeModelAware {
+
+    public static final String NAME = ""adaptive"";
+
+    //default key
+    private String attachmentKey = ""mem,load"";
+
+    private final int default_timeout = 30_000;
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Override
+    public void setApplicationModel(ApplicationModel scopeModel){
+        AdaptiveMetrics bean = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        if (bean == null) {
+            scopeModel.getBeanFactory().registerBean(new AdaptiveMetrics());
+        }","[{'comment': 'use `ScopeBeanInitializer`', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AdaptiveLoadBalance.java,"@@ -0,0 +1,140 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.TimeoutCountDown;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+import org.apache.dubbo.rpc.support.RpcUtils;
+
+import java.util.List;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.TIME_COUNTDOWN_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_TIMEOUT;
+
+/**
+ * AdaptiveLoadBalance
+ * </p>
+ */
+public class AdaptiveLoadBalance extends AbstractLoadBalance implements ScopeModelAware {
+
+    public static final String NAME = ""adaptive"";
+
+    //default key
+    private String attachmentKey = ""mem,load"";
+
+    private final int default_timeout = 30_000;
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Override
+    public void setApplicationModel(ApplicationModel scopeModel){
+        AdaptiveMetrics bean = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        if (bean == null) {
+            scopeModel.getBeanFactory().registerBean(new AdaptiveMetrics());
+        }
+        this.scopeModel = scopeModel;
+    }
+
+    private AdaptiveMetrics getAdaptiveMetricsInstance(){
+        if (adaptiveMetrics == null) {
+            adaptiveMetrics = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        }
+        return adaptiveMetrics;
+    }
+
+    @Override
+    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
+        Invoker invoker = selectByP2C(invokers,url,invocation);
+        invocation.setAttachment(Constants.ADAPTIVE_LOADBALANCE_ATTACHMENT_KEY,attachmentKey);","[{'comment': 'use `attribute` would better?', 'commenter': 'AlbumenJ'}, {'comment': 'Need to pass parameters to provider', 'commenter': 'ningboliu'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AdaptiveLoadBalance.java,"@@ -0,0 +1,140 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.TimeoutCountDown;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+import org.apache.dubbo.rpc.support.RpcUtils;
+
+import java.util.List;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.TIME_COUNTDOWN_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_TIMEOUT;
+
+/**
+ * AdaptiveLoadBalance
+ * </p>
+ */
+public class AdaptiveLoadBalance extends AbstractLoadBalance implements ScopeModelAware {
+
+    public static final String NAME = ""adaptive"";
+
+    //default key
+    private String attachmentKey = ""mem,load"";
+
+    private final int default_timeout = 30_000;
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Override
+    public void setApplicationModel(ApplicationModel scopeModel){
+        AdaptiveMetrics bean = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        if (bean == null) {
+            scopeModel.getBeanFactory().registerBean(new AdaptiveMetrics());
+        }
+        this.scopeModel = scopeModel;
+    }
+
+    private AdaptiveMetrics getAdaptiveMetricsInstance(){
+        if (adaptiveMetrics == null) {
+            adaptiveMetrics = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        }
+        return adaptiveMetrics;
+    }
+
+    @Override
+    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
+        Invoker invoker = selectByP2C(invokers,url,invocation);
+        invocation.setAttachment(Constants.ADAPTIVE_LOADBALANCE_ATTACHMENT_KEY,attachmentKey);
+        getAdaptiveMetricsInstance().addConsumerReq(buildServiceKey(invoker,invocation));
+        getAdaptiveMetricsInstance().setPickTime(buildServiceKey(invoker,invocation),System.currentTimeMillis());
+
+        return invoker;
+    }
+
+    private <T> Invoker<T> selectByP2C(List<Invoker<T>> invokers, URL url, Invocation invocation){
+        int length = invokers.size();
+        if(length == 1) {
+            return invokers.get(0);
+        }
+
+        if(length == 2) {
+            return chooseLowLoadInvoker(invokers.get(0),invokers.get(1),invocation);
+        }
+
+        int pos1 = ThreadLocalRandom.current().nextInt(length);
+        int pos2 = ThreadLocalRandom.current().nextInt(length);
+        while(pos1 == pos2) {
+            pos2 = ThreadLocalRandom.current().nextInt(length);
+        }
+
+        return chooseLowLoadInvoker(invokers.get(pos1),invokers.get(pos2),invocation);
+    }
+
+    private String buildServiceKey(Invoker<?> invoker,Invocation invocation){
+        URL url = invoker.getUrl();
+        return url.getAddress() + "":"" + invocation.getProtocolServiceKey();
+    }","[{'comment': 'cache this in invocation attribute', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AdaptiveLoadBalance.java,"@@ -0,0 +1,140 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.TimeoutCountDown;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+import org.apache.dubbo.rpc.support.RpcUtils;
+
+import java.util.List;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.TIME_COUNTDOWN_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_TIMEOUT;
+
+/**
+ * AdaptiveLoadBalance
+ * </p>
+ */
+public class AdaptiveLoadBalance extends AbstractLoadBalance implements ScopeModelAware {
+
+    public static final String NAME = ""adaptive"";
+
+    //default key
+    private String attachmentKey = ""mem,load"";
+
+    private final int default_timeout = 30_000;
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Override
+    public void setApplicationModel(ApplicationModel scopeModel){
+        AdaptiveMetrics bean = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        if (bean == null) {
+            scopeModel.getBeanFactory().registerBean(new AdaptiveMetrics());
+        }
+        this.scopeModel = scopeModel;
+    }
+
+    private AdaptiveMetrics getAdaptiveMetricsInstance(){
+        if (adaptiveMetrics == null) {
+            adaptiveMetrics = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        }
+        return adaptiveMetrics;
+    }
+
+    @Override
+    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
+        Invoker invoker = selectByP2C(invokers,url,invocation);
+        invocation.setAttachment(Constants.ADAPTIVE_LOADBALANCE_ATTACHMENT_KEY,attachmentKey);
+        getAdaptiveMetricsInstance().addConsumerReq(buildServiceKey(invoker,invocation));
+        getAdaptiveMetricsInstance().setPickTime(buildServiceKey(invoker,invocation),System.currentTimeMillis());
+
+        return invoker;
+    }
+
+    private <T> Invoker<T> selectByP2C(List<Invoker<T>> invokers, URL url, Invocation invocation){
+        int length = invokers.size();
+        if(length == 1) {
+            return invokers.get(0);
+        }
+
+        if(length == 2) {
+            return chooseLowLoadInvoker(invokers.get(0),invokers.get(1),invocation);
+        }
+
+        int pos1 = ThreadLocalRandom.current().nextInt(length);
+        int pos2 = ThreadLocalRandom.current().nextInt(length);
+        while(pos1 == pos2) {
+            pos2 = ThreadLocalRandom.current().nextInt(length);
+        }
+
+        return chooseLowLoadInvoker(invokers.get(pos1),invokers.get(pos2),invocation);
+    }
+
+    private String buildServiceKey(Invoker<?> invoker,Invocation invocation){
+        URL url = invoker.getUrl();
+        return url.getAddress() + "":"" + invocation.getProtocolServiceKey();
+    }
+
+    private int getTimeout(Invoker<?> invoker, Invocation invocation) {
+        URL url = invoker.getUrl();
+        Object countdown = RpcContext.getClientAttachment().getObjectAttachment(TIME_COUNTDOWN_KEY);
+        int timeout;
+        if (countdown == null) {
+            timeout = (int) RpcUtils.getTimeout(url, invocation.getMethodName(), RpcContext.getClientAttachment(), DEFAULT_TIMEOUT);
+        } else {
+            TimeoutCountDown timeoutCountDown = (TimeoutCountDown) countdown;
+            timeout = (int) timeoutCountDown.timeRemaining(TimeUnit.MILLISECONDS);
+        }
+        return timeout;","[{'comment': ""why read current invocation's timeout?"", 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AdaptiveLoadBalance.java,"@@ -0,0 +1,140 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.TimeoutCountDown;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+import org.apache.dubbo.rpc.support.RpcUtils;
+
+import java.util.List;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.TIME_COUNTDOWN_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_TIMEOUT;
+
+/**
+ * AdaptiveLoadBalance
+ * </p>
+ */
+public class AdaptiveLoadBalance extends AbstractLoadBalance implements ScopeModelAware {
+
+    public static final String NAME = ""adaptive"";
+
+    //default key
+    private String attachmentKey = ""mem,load"";
+
+    private final int default_timeout = 30_000;
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Override
+    public void setApplicationModel(ApplicationModel scopeModel){
+        AdaptiveMetrics bean = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        if (bean == null) {
+            scopeModel.getBeanFactory().registerBean(new AdaptiveMetrics());
+        }
+        this.scopeModel = scopeModel;
+    }
+
+    private AdaptiveMetrics getAdaptiveMetricsInstance(){
+        if (adaptiveMetrics == null) {
+            adaptiveMetrics = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        }
+        return adaptiveMetrics;
+    }
+
+    @Override
+    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
+        Invoker invoker = selectByP2C(invokers,url,invocation);
+        invocation.setAttachment(Constants.ADAPTIVE_LOADBALANCE_ATTACHMENT_KEY,attachmentKey);
+        getAdaptiveMetricsInstance().addConsumerReq(buildServiceKey(invoker,invocation));
+        getAdaptiveMetricsInstance().setPickTime(buildServiceKey(invoker,invocation),System.currentTimeMillis());
+
+        return invoker;
+    }
+
+    private <T> Invoker<T> selectByP2C(List<Invoker<T>> invokers, URL url, Invocation invocation){
+        int length = invokers.size();
+        if(length == 1) {
+            return invokers.get(0);
+        }
+
+        if(length == 2) {
+            return chooseLowLoadInvoker(invokers.get(0),invokers.get(1),invocation);
+        }
+
+        int pos1 = ThreadLocalRandom.current().nextInt(length);
+        int pos2 = ThreadLocalRandom.current().nextInt(length);
+        while(pos1 == pos2) {
+            pos2 = ThreadLocalRandom.current().nextInt(length);
+        }
+
+        return chooseLowLoadInvoker(invokers.get(pos1),invokers.get(pos2),invocation);
+    }
+
+    private String buildServiceKey(Invoker<?> invoker,Invocation invocation){
+        URL url = invoker.getUrl();
+        return url.getAddress() + "":"" + invocation.getProtocolServiceKey();
+    }
+
+    private int getTimeout(Invoker<?> invoker, Invocation invocation) {
+        URL url = invoker.getUrl();
+        Object countdown = RpcContext.getClientAttachment().getObjectAttachment(TIME_COUNTDOWN_KEY);
+        int timeout;
+        if (countdown == null) {
+            timeout = (int) RpcUtils.getTimeout(url, invocation.getMethodName(), RpcContext.getClientAttachment(), DEFAULT_TIMEOUT);
+        } else {
+            TimeoutCountDown timeoutCountDown = (TimeoutCountDown) countdown;
+            timeout = (int) timeoutCountDown.timeRemaining(TimeUnit.MILLISECONDS);
+        }
+        return timeout;
+    }
+
+    private <T> Invoker<T> chooseLowLoadInvoker(Invoker<T> invoker1,Invoker<T> invoker2,Invocation invocation){
+        int weight1 = getWeight(invoker1, invocation);
+        int weight2 = getWeight(invoker2, invocation);
+        int timeout1 = getTimeout(invoker2, invocation);","[{'comment': 'Are there some spell mistakes?', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/AdaptiveLoadBalanceFilter.java,"@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.filter.support;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.resource.GlobalResourcesRepository;
+import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.cluster.loadbalance.AdaptiveLoadBalance;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+import static org.apache.dubbo.common.constants.CommonConstants.LOADBALANCE_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;
+
+/**
+ * if the load balance is adaptive ,set attachment to get the metrics of the server
+ * @see org.apache.dubbo.rpc.Filter
+ * @see org.apache.dubbo.rpc.RpcContext
+ */
+@Activate(group = CONSUMER, order = -200000, value = {""loadbalance:adaptive""})
+public class AdaptiveLoadBalanceFilter implements ClusterFilter, ClusterFilter.Listener {","[{'comment': 'Move this filter to implement `Filter` would be better. The implementation are related with the actual provider address.', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/AdaptiveLoadBalanceFilter.java,"@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.filter.support;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.resource.GlobalResourcesRepository;
+import org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Constants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.cluster.loadbalance.AdaptiveLoadBalance;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+import static org.apache.dubbo.common.constants.CommonConstants.LOADBALANCE_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;
+
+/**
+ * if the load balance is adaptive ,set attachment to get the metrics of the server
+ * @see org.apache.dubbo.rpc.Filter
+ * @see org.apache.dubbo.rpc.RpcContext
+ */
+@Activate(group = CONSUMER, order = -200000, value = {""loadbalance:adaptive""})
+public class AdaptiveLoadBalanceFilter implements ClusterFilter, ClusterFilter.Listener {
+
+    /**
+     * uses a single worker thread operating off an bounded queue
+     */
+    private ThreadPoolExecutor executor = null;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    public AdaptiveLoadBalanceFilter(ApplicationModel scopeModel) {
+        adaptiveMetrics = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+    }
+
+    private ThreadPoolExecutor getExecutor(){
+        if (null == executor) {
+            synchronized (this) {
+                if (null == executor) {
+                    executor = new ThreadPoolExecutor(1, 1, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(1024),
+                        new NamedInternalThreadFactory(""Dubbo-framework-loadbalance-adaptive"", true), new ThreadPoolExecutor.DiscardOldestPolicy());
+                    GlobalResourcesRepository.getInstance().registerDisposable(() -> this.executor.shutdown());
+                }
+            }
+        }
+        return executor;
+    }
+
+    @Override
+    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
+        return invoker.invoke(invocation);
+    }
+
+    private String buildServiceKey(Invocation invocation){
+        StringBuilder sb = new StringBuilder(128);
+        sb.append(invocation.getInvoker().getUrl().getAddress()).append("":"").append(invocation.getProtocolServiceKey());
+        return sb.toString();
+        //return url.getAddress() + ProtocolUtils.serviceKey(url.getPort(), url.getPath(), url.getVersion(), url.getGroup());
+    }
+
+    private String getServiceKey(Invocation invocation){
+
+        String key = (String) invocation.getAttributes().get(invocation.getInvoker());
+        if (StringUtils.isNotEmpty(key)){
+            return key;
+        }
+
+        key = buildServiceKey(invocation);
+        invocation.getAttributes().put(invocation.getInvoker(),key);
+        return key;
+    }","[{'comment': 'Will this key be reused?', 'commenter': 'AlbumenJ'}, {'comment': 'used 2 times', 'commenter': 'ningboliu'}]"
10745,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/AdaptiveLoadBalanceTest.java,"@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.MethodOrderer;
+import org.junit.jupiter.api.Order;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestMethodOrder;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
+class AdaptiveLoadBalanceTest extends LoadBalanceBaseTest {
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Test
+    @Order(0)
+    void testSelectByWeight() {
+        int sumInvoker1 = 0;
+        int sumInvoker2 = 0;
+        int sumInvoker3 = 0;
+        int loop = 10000;
+
+        ApplicationModel scopeModel = ApplicationModel.defaultModel();
+
+        AdaptiveLoadBalance lb = new AdaptiveLoadBalance(scopeModel);
+        for (int i = 0; i < loop; i++) {
+            Invoker selected = lb.select(weightInvokers, null, weightTestInvocation);
+
+            if (selected.getUrl().getProtocol().equals(""test1"")) {
+                sumInvoker1++;
+            }
+
+            if (selected.getUrl().getProtocol().equals(""test2"")) {
+                sumInvoker2++;
+            }
+
+            if (selected.getUrl().getProtocol().equals(""test3"")) {
+                sumInvoker3++;
+            }
+        }
+
+        // 1 : 9 : 6
+        System.out.println(sumInvoker1);
+        System.out.println(sumInvoker2);
+        System.out.println(sumInvoker3);
+        Assertions.assertEquals(sumInvoker1 + sumInvoker2 + sumInvoker3, loop, ""select failed!"");
+    }
+
+    private String buildServiceKey(Invoker invoker){
+        URL url = invoker.getUrl();
+        return url.getAddress() + "":"" + invocation.getProtocolServiceKey();
+    }
+
+    private AdaptiveMetrics getAdaptiveMetricsInstance(){
+        if (adaptiveMetrics == null) {
+            adaptiveMetrics = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        }
+        return adaptiveMetrics;
+    }
+
+    @Test
+    @Order(1)
+    void testSelectByAdaptive() throws NoSuchFieldException, IllegalAccessException {
+        int sumInvoker1 = 0;
+        int sumInvoker2 = 0;
+        int sumInvoker5 = 0;
+        int loop = 10000;
+
+        scopeModel = ApplicationModel.defaultModel();
+        AdaptiveLoadBalance lb = new AdaptiveLoadBalance(scopeModel);
+
+        lb.select(weightInvokersSR, null, weightTestInvocation);
+
+        for (int i = 0; i < loop; i++) {
+            Invoker selected = lb.select(weightInvokersSR, null, weightTestInvocation);
+
+            Map<String, String> metricsMap = new HashMap<>();
+            String idKey = buildServiceKey(selected);
+
+            if (selected.getUrl().getProtocol().equals(""test1"")) {
+                sumInvoker1++;
+                metricsMap.put(""rt"", ""10"");
+                metricsMap.put(""load"", ""10"");
+                metricsMap.put(""curTime"", String.valueOf(System.currentTimeMillis()-10));
+                getAdaptiveMetricsInstance().addConsumerSuccess(idKey);
+            }
+
+            if (selected.getUrl().getProtocol().equals(""test2"")) {
+                sumInvoker2++;
+                metricsMap.put(""rt"", ""100"");
+                metricsMap.put(""load"", ""40"");
+                metricsMap.put(""curTime"", String.valueOf(System.currentTimeMillis()-100));
+                getAdaptiveMetricsInstance().addConsumerSuccess(idKey);
+            }
+
+            if (selected.getUrl().getProtocol().equals(""test5"")) {
+                metricsMap.put(""rt"", ""5000"");
+                metricsMap.put(""load"", ""400"");//400%
+                metricsMap.put(""curTime"", String.valueOf(System.currentTimeMillis() - 5000));
+
+                getAdaptiveMetricsInstance().addErrorReq(idKey);
+                sumInvoker5++;
+            }
+            getAdaptiveMetricsInstance().setProviderMetrics(idKey,metricsMap);
+
+        }
+        Map<Invoker<LoadBalanceBaseTest>, Integer> weightMap = weightInvokersSR.stream()
+            .collect(Collectors.toMap(Function.identity(), e -> Integer.valueOf(e.getUrl().getParameter(""weight""))));
+        Integer totalWeight = weightMap.values().stream().reduce(0, Integer::sum);
+        // max deviation = expectWeightValue * 2
+        int expectWeightValue = loop / totalWeight;
+        int maxDeviation = expectWeightValue * 2;
+        double beta = 0.5;
+        //这个估算值并不准确
+        double ewma1 = beta * 50 + (1 - beta) * 10;
+        double ewma2 = beta * 50 + (1 - beta) * 100;
+        double ewma5 = beta * 50 + (1 - beta) * 5000;
+
+        AtomicInteger weight1 = new AtomicInteger();
+        AtomicInteger weight2 = new AtomicInteger();
+        AtomicInteger weight5 = new AtomicInteger();
+        weightMap.forEach((k, v) ->{
+            if (k.getUrl().getProtocol().equals(""test1"")){
+                weight1.set(v);
+            }
+            else if (k.getUrl().getProtocol().equals(""test2"")){
+                weight2.set(v);
+            }
+            else if (k.getUrl().getProtocol().equals(""test5"")){
+                weight5.set(v);
+            }
+        });
+
+        System.out.println(sumInvoker1);
+        System.out.println(sumInvoker2);
+        System.out.println(sumInvoker5);","[{'comment': 'Print here is useless', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/AdaptiveLoadBalanceTest.java,"@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.MethodOrderer;
+import org.junit.jupiter.api.Order;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestMethodOrder;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
+class AdaptiveLoadBalanceTest extends LoadBalanceBaseTest {
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Test
+    @Order(0)
+    void testSelectByWeight() {
+        int sumInvoker1 = 0;
+        int sumInvoker2 = 0;
+        int sumInvoker3 = 0;
+        int loop = 10000;
+
+        ApplicationModel scopeModel = ApplicationModel.defaultModel();
+
+        AdaptiveLoadBalance lb = new AdaptiveLoadBalance(scopeModel);
+        for (int i = 0; i < loop; i++) {
+            Invoker selected = lb.select(weightInvokers, null, weightTestInvocation);
+
+            if (selected.getUrl().getProtocol().equals(""test1"")) {
+                sumInvoker1++;
+            }
+
+            if (selected.getUrl().getProtocol().equals(""test2"")) {
+                sumInvoker2++;
+            }
+
+            if (selected.getUrl().getProtocol().equals(""test3"")) {
+                sumInvoker3++;
+            }
+        }
+
+        // 1 : 9 : 6
+        System.out.println(sumInvoker1);
+        System.out.println(sumInvoker2);
+        System.out.println(sumInvoker3);
+        Assertions.assertEquals(sumInvoker1 + sumInvoker2 + sumInvoker3, loop, ""select failed!"");
+    }
+
+    private String buildServiceKey(Invoker invoker){
+        URL url = invoker.getUrl();
+        return url.getAddress() + "":"" + invocation.getProtocolServiceKey();
+    }
+
+    private AdaptiveMetrics getAdaptiveMetricsInstance(){
+        if (adaptiveMetrics == null) {
+            adaptiveMetrics = scopeModel.getBeanFactory().getBean(AdaptiveMetrics.class);
+        }
+        return adaptiveMetrics;
+    }
+
+    @Test
+    @Order(1)
+    void testSelectByAdaptive() throws NoSuchFieldException, IllegalAccessException {
+        int sumInvoker1 = 0;
+        int sumInvoker2 = 0;
+        int sumInvoker5 = 0;
+        int loop = 10000;
+
+        scopeModel = ApplicationModel.defaultModel();
+        AdaptiveLoadBalance lb = new AdaptiveLoadBalance(scopeModel);
+
+        lb.select(weightInvokersSR, null, weightTestInvocation);
+
+        for (int i = 0; i < loop; i++) {
+            Invoker selected = lb.select(weightInvokersSR, null, weightTestInvocation);
+
+            Map<String, String> metricsMap = new HashMap<>();
+            String idKey = buildServiceKey(selected);
+
+            if (selected.getUrl().getProtocol().equals(""test1"")) {
+                sumInvoker1++;
+                metricsMap.put(""rt"", ""10"");
+                metricsMap.put(""load"", ""10"");
+                metricsMap.put(""curTime"", String.valueOf(System.currentTimeMillis()-10));
+                getAdaptiveMetricsInstance().addConsumerSuccess(idKey);
+            }
+
+            if (selected.getUrl().getProtocol().equals(""test2"")) {
+                sumInvoker2++;
+                metricsMap.put(""rt"", ""100"");
+                metricsMap.put(""load"", ""40"");
+                metricsMap.put(""curTime"", String.valueOf(System.currentTimeMillis()-100));
+                getAdaptiveMetricsInstance().addConsumerSuccess(idKey);
+            }
+
+            if (selected.getUrl().getProtocol().equals(""test5"")) {
+                metricsMap.put(""rt"", ""5000"");
+                metricsMap.put(""load"", ""400"");//400%
+                metricsMap.put(""curTime"", String.valueOf(System.currentTimeMillis() - 5000));
+
+                getAdaptiveMetricsInstance().addErrorReq(idKey);
+                sumInvoker5++;
+            }
+            getAdaptiveMetricsInstance().setProviderMetrics(idKey,metricsMap);
+
+        }
+        Map<Invoker<LoadBalanceBaseTest>, Integer> weightMap = weightInvokersSR.stream()
+            .collect(Collectors.toMap(Function.identity(), e -> Integer.valueOf(e.getUrl().getParameter(""weight""))));
+        Integer totalWeight = weightMap.values().stream().reduce(0, Integer::sum);
+        // max deviation = expectWeightValue * 2
+        int expectWeightValue = loop / totalWeight;
+        int maxDeviation = expectWeightValue * 2;
+        double beta = 0.5;
+        //这个估算值并不准确","[{'comment': 'comment in English', 'commenter': 'AlbumenJ'}]"
10745,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/AdaptiveLoadBalanceTest.java,"@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.loadbalance;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.AdaptiveMetrics;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.MethodOrderer;
+import org.junit.jupiter.api.Order;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestMethodOrder;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
+class AdaptiveLoadBalanceTest extends LoadBalanceBaseTest {
+
+    private ApplicationModel scopeModel;
+
+    private AdaptiveMetrics adaptiveMetrics;
+
+    @Test
+    @Order(0)
+    void testSelectByWeight() {
+        int sumInvoker1 = 0;
+        int sumInvoker2 = 0;
+        int sumInvoker3 = 0;
+        int loop = 10000;
+
+        ApplicationModel scopeModel = ApplicationModel.defaultModel();
+
+        AdaptiveLoadBalance lb = new AdaptiveLoadBalance(scopeModel);
+        for (int i = 0; i < loop; i++) {
+            Invoker selected = lb.select(weightInvokers, null, weightTestInvocation);
+
+            if (selected.getUrl().getProtocol().equals(""test1"")) {
+                sumInvoker1++;
+            }
+
+            if (selected.getUrl().getProtocol().equals(""test2"")) {
+                sumInvoker2++;
+            }
+
+            if (selected.getUrl().getProtocol().equals(""test3"")) {
+                sumInvoker3++;
+            }
+        }
+
+        // 1 : 9 : 6
+        System.out.println(sumInvoker1);
+        System.out.println(sumInvoker2);
+        System.out.println(sumInvoker3);","[{'comment': 'Print is useless in unit test', 'commenter': 'AlbumenJ'}]"
10748,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2LocalFlowController.java,"@@ -0,0 +1,644 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the ""License""); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri;
+import static io.netty.handler.codec.http2.Http2CodecUtil.CONNECTION_STREAM_ID;
+import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_INITIAL_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_INITIAL_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2Error.FLOW_CONTROL_ERROR;
+import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
+import static io.netty.handler.codec.http2.Http2Exception.connectionError;
+import static io.netty.handler.codec.http2.Http2Exception.streamError;
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
+import static java.lang.Math.max;
+import static java.lang.Math.min;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http2.Http2StreamVisitor;
+import io.netty.handler.codec.http2.Http2Exception;
+import io.netty.handler.codec.http2.Http2ConnectionAdapter;
+import io.netty.handler.codec.http2.Http2Connection;
+import io.netty.handler.codec.http2.Http2Exception.CompositeStreamException;
+import io.netty.handler.codec.http2.Http2Exception.StreamException;
+import io.netty.handler.codec.http2.Http2FrameWriter;
+import io.netty.handler.codec.http2.Http2LocalFlowController;
+import io.netty.handler.codec.http2.Http2Stream;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.UnstableApi;
+
+
+/**
+ * This design is learning from {@see io.netty.handler.codec.http2.DefaultHttp2LocalFlowController} which is in Netty.
+ */
+@UnstableApi
+public class TriHttp2LocalFlowController implements Http2LocalFlowController {
+    /**
+     * The default ratio of window size to initial window size below which a {@code WINDOW_UPDATE}
+     * is sent to expand the window.
+     */
+    public static final float DEFAULT_WINDOW_UPDATE_RATIO = 0.5f;
+
+    private final Http2Connection connection;
+    private final Http2Connection.PropertyKey stateKey;
+    private Http2FrameWriter frameWriter;
+    private ChannelHandlerContext ctx;
+    private float windowUpdateRatio;
+    private int initialWindowSize = DEFAULT_WINDOW_SIZE;
+
+    public TriHttp2LocalFlowController(Http2Connection connection) {
+        this(connection, DEFAULT_WINDOW_UPDATE_RATIO, false);
+    }
+
+    public TriHttp2LocalFlowController(Http2Connection connection,
+                                       float windowUpdateRatio,
+                                       boolean autoRefillConnectionWindow) {
+        this.connection = checkNotNull(connection, ""connection"");
+        windowUpdateRatio(windowUpdateRatio);
+
+        // Add a flow state for the connection.
+        stateKey = connection.newKey();
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState connectionState = autoRefillConnectionWindow ?
+            new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.AutoRefillState(connection.connectionStream(), initialWindowSize) :","[{'comment': 'Remove unnecessary qualification', 'commenter': 'guohao'}, {'comment': 'Why not enable AutoRefillState by default ?', 'commenter': 'guohao'}, {'comment': '> Remove unnecessary qualification\r\n\r\ndone', 'commenter': 'asa3311'}, {'comment': '> Why not enable AutoRefillState by default ?\r\n\r\nthis code from netty', 'commenter': 'asa3311'}]"
10748,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2LocalFlowController.java,"@@ -0,0 +1,644 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the ""License""); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri;
+import static io.netty.handler.codec.http2.Http2CodecUtil.CONNECTION_STREAM_ID;
+import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_INITIAL_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_INITIAL_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2Error.FLOW_CONTROL_ERROR;
+import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
+import static io.netty.handler.codec.http2.Http2Exception.connectionError;
+import static io.netty.handler.codec.http2.Http2Exception.streamError;
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
+import static java.lang.Math.max;
+import static java.lang.Math.min;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http2.Http2StreamVisitor;
+import io.netty.handler.codec.http2.Http2Exception;
+import io.netty.handler.codec.http2.Http2ConnectionAdapter;
+import io.netty.handler.codec.http2.Http2Connection;
+import io.netty.handler.codec.http2.Http2Exception.CompositeStreamException;
+import io.netty.handler.codec.http2.Http2Exception.StreamException;
+import io.netty.handler.codec.http2.Http2FrameWriter;
+import io.netty.handler.codec.http2.Http2LocalFlowController;
+import io.netty.handler.codec.http2.Http2Stream;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.UnstableApi;
+
+
+/**
+ * This design is learning from {@see io.netty.handler.codec.http2.DefaultHttp2LocalFlowController} which is in Netty.
+ */
+@UnstableApi
+public class TriHttp2LocalFlowController implements Http2LocalFlowController {
+    /**
+     * The default ratio of window size to initial window size below which a {@code WINDOW_UPDATE}
+     * is sent to expand the window.
+     */
+    public static final float DEFAULT_WINDOW_UPDATE_RATIO = 0.5f;
+
+    private final Http2Connection connection;
+    private final Http2Connection.PropertyKey stateKey;
+    private Http2FrameWriter frameWriter;
+    private ChannelHandlerContext ctx;
+    private float windowUpdateRatio;
+    private int initialWindowSize = DEFAULT_WINDOW_SIZE;","[{'comment': 'WindowSize should be set to \r\n`config.getInt(H2_SETTINGS_INITIAL_WINDOW_SIZE_KEY, DEFAULT_WINDOW_INIT_SIZE)\r\n`\r\n`org.apache.dubbo.rpc.protocol.tri.TripleHttp2Protocol#DEFAULT_WINDOW_INIT_SIZE`', 'commenter': 'guohao'}, {'comment': 'done', 'commenter': 'asa3311'}]"
10748,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2LocalFlowController.java,"@@ -0,0 +1,644 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the ""License""); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri;
+import static io.netty.handler.codec.http2.Http2CodecUtil.CONNECTION_STREAM_ID;
+import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_INITIAL_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_INITIAL_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2Error.FLOW_CONTROL_ERROR;
+import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
+import static io.netty.handler.codec.http2.Http2Exception.connectionError;
+import static io.netty.handler.codec.http2.Http2Exception.streamError;
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
+import static java.lang.Math.max;
+import static java.lang.Math.min;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http2.Http2StreamVisitor;
+import io.netty.handler.codec.http2.Http2Exception;
+import io.netty.handler.codec.http2.Http2ConnectionAdapter;
+import io.netty.handler.codec.http2.Http2Connection;
+import io.netty.handler.codec.http2.Http2Exception.CompositeStreamException;
+import io.netty.handler.codec.http2.Http2Exception.StreamException;
+import io.netty.handler.codec.http2.Http2FrameWriter;
+import io.netty.handler.codec.http2.Http2LocalFlowController;
+import io.netty.handler.codec.http2.Http2Stream;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.UnstableApi;
+
+
+/**
+ * This design is learning from {@see io.netty.handler.codec.http2.DefaultHttp2LocalFlowController} which is in Netty.
+ */
+@UnstableApi
+public class TriHttp2LocalFlowController implements Http2LocalFlowController {
+    /**
+     * The default ratio of window size to initial window size below which a {@code WINDOW_UPDATE}
+     * is sent to expand the window.
+     */
+    public static final float DEFAULT_WINDOW_UPDATE_RATIO = 0.5f;
+
+    private final Http2Connection connection;
+    private final Http2Connection.PropertyKey stateKey;
+    private Http2FrameWriter frameWriter;
+    private ChannelHandlerContext ctx;
+    private float windowUpdateRatio;
+    private int initialWindowSize = DEFAULT_WINDOW_SIZE;
+
+    public TriHttp2LocalFlowController(Http2Connection connection) {
+        this(connection, DEFAULT_WINDOW_UPDATE_RATIO, false);
+    }
+
+    public TriHttp2LocalFlowController(Http2Connection connection,
+                                       float windowUpdateRatio,
+                                       boolean autoRefillConnectionWindow) {
+        this.connection = checkNotNull(connection, ""connection"");
+        windowUpdateRatio(windowUpdateRatio);
+
+        // Add a flow state for the connection.
+        stateKey = connection.newKey();
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState connectionState = autoRefillConnectionWindow ?
+            new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.AutoRefillState(connection.connectionStream(), initialWindowSize) :
+            new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.DefaultState(connection.connectionStream(), initialWindowSize);
+        connection.connectionStream().setProperty(stateKey, connectionState);
+
+        // Register for notification of new streams.
+        connection.addListener(new Http2ConnectionAdapter() {
+            @Override
+            public void onStreamAdded(Http2Stream stream) {
+                // Unconditionally used the reduced flow control state because it requires no object allocation
+                // and the DefaultFlowState will be allocated in onStreamActive.
+                stream.setProperty(stateKey, REDUCED_FLOW_STATE);
+            }
+
+            @Override
+            public void onStreamActive(Http2Stream stream) {
+                // Need to be sure the stream's initial window is adjusted for SETTINGS
+                // frames which may have been exchanged while it was in IDLE
+                stream.setProperty(stateKey, new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.DefaultState(stream, initialWindowSize));
+            }
+
+            @Override
+            public void onStreamClosed(Http2Stream stream) {
+                try {
+                    // When a stream is closed, consume any remaining bytes so that they
+                    // are restored to the connection window.
+                    org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state = state(stream);
+                    int unconsumedBytes = state.unconsumedBytes();
+                    if (ctx != null && unconsumedBytes > 0) {
+                        if (consumeAllBytes(state, unconsumedBytes)) {
+                            // As the user has no real control on when this callback is used we should better
+                            // call flush() if we produced any window update to ensure we not stale.
+                            ctx.flush();
+                        }
+                    }
+                } catch (Http2Exception e) {
+                    PlatformDependent.throwException(e);
+                } finally {
+                    // Unconditionally reduce the amount of memory required for flow control because there is no
+                    // object allocation costs associated with doing so and the stream will not have any more
+                    // local flow control state to keep track of anymore.
+                    stream.setProperty(stateKey, REDUCED_FLOW_STATE);
+                }
+            }
+        });
+    }
+
+    @Override
+    public TriHttp2LocalFlowController frameWriter(Http2FrameWriter frameWriter) {
+        this.frameWriter = checkNotNull(frameWriter, ""frameWriter"");
+        return this;
+    }
+
+    @Override
+    public void channelHandlerContext(ChannelHandlerContext ctx) {
+        this.ctx = checkNotNull(ctx, ""ctx"");
+    }
+
+    @Override
+    public void initialWindowSize(int newWindowSize) throws Http2Exception {
+        assert ctx == null || ctx.executor().inEventLoop();
+        int delta = newWindowSize - initialWindowSize;
+        initialWindowSize = newWindowSize;
+
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.WindowUpdateVisitor visitor = new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.WindowUpdateVisitor(delta);
+        connection.forEachActiveStream(visitor);
+        visitor.throwIfError();
+    }
+
+    @Override
+    public int initialWindowSize() {
+        return initialWindowSize;
+    }
+
+    @Override
+    public int windowSize(Http2Stream stream) {
+        return state(stream).windowSize();
+    }
+
+    @Override
+    public int initialWindowSize(Http2Stream stream) {
+        return state(stream).initialWindowSize();
+    }
+
+    @Override
+    public void incrementWindowSize(Http2Stream stream, int delta) throws Http2Exception {
+        assert ctx != null && ctx.executor().inEventLoop();
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state = state(stream);
+        // Just add the delta to the stream-specific initial window size so that the next time the window
+        // expands it will grow to the new initial size.
+        state.incrementInitialStreamWindow(delta);
+        state.writeWindowUpdateIfNeeded();
+    }
+
+    public boolean consumeTriBytes(Http2Stream stream, int numBytes)  throws Http2Exception {","[{'comment': 'Seems `return value` is unused', 'commenter': 'guohao'}, {'comment': 'change to void', 'commenter': 'asa3311'}]"
10748,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2LocalFlowController.java,"@@ -0,0 +1,644 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the ""License""); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri;
+import static io.netty.handler.codec.http2.Http2CodecUtil.CONNECTION_STREAM_ID;
+import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_INITIAL_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_INITIAL_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2Error.FLOW_CONTROL_ERROR;
+import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
+import static io.netty.handler.codec.http2.Http2Exception.connectionError;
+import static io.netty.handler.codec.http2.Http2Exception.streamError;
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
+import static java.lang.Math.max;
+import static java.lang.Math.min;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http2.Http2StreamVisitor;
+import io.netty.handler.codec.http2.Http2Exception;
+import io.netty.handler.codec.http2.Http2ConnectionAdapter;
+import io.netty.handler.codec.http2.Http2Connection;
+import io.netty.handler.codec.http2.Http2Exception.CompositeStreamException;
+import io.netty.handler.codec.http2.Http2Exception.StreamException;
+import io.netty.handler.codec.http2.Http2FrameWriter;
+import io.netty.handler.codec.http2.Http2LocalFlowController;
+import io.netty.handler.codec.http2.Http2Stream;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.UnstableApi;
+
+
+/**
+ * This design is learning from {@see io.netty.handler.codec.http2.DefaultHttp2LocalFlowController} which is in Netty.
+ */
+@UnstableApi
+public class TriHttp2LocalFlowController implements Http2LocalFlowController {
+    /**
+     * The default ratio of window size to initial window size below which a {@code WINDOW_UPDATE}
+     * is sent to expand the window.
+     */
+    public static final float DEFAULT_WINDOW_UPDATE_RATIO = 0.5f;
+
+    private final Http2Connection connection;
+    private final Http2Connection.PropertyKey stateKey;
+    private Http2FrameWriter frameWriter;
+    private ChannelHandlerContext ctx;
+    private float windowUpdateRatio;
+    private int initialWindowSize = DEFAULT_WINDOW_SIZE;
+
+    public TriHttp2LocalFlowController(Http2Connection connection) {
+        this(connection, DEFAULT_WINDOW_UPDATE_RATIO, false);
+    }
+
+    public TriHttp2LocalFlowController(Http2Connection connection,
+                                       float windowUpdateRatio,
+                                       boolean autoRefillConnectionWindow) {
+        this.connection = checkNotNull(connection, ""connection"");
+        windowUpdateRatio(windowUpdateRatio);
+
+        // Add a flow state for the connection.
+        stateKey = connection.newKey();
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState connectionState = autoRefillConnectionWindow ?
+            new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.AutoRefillState(connection.connectionStream(), initialWindowSize) :
+            new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.DefaultState(connection.connectionStream(), initialWindowSize);
+        connection.connectionStream().setProperty(stateKey, connectionState);
+
+        // Register for notification of new streams.
+        connection.addListener(new Http2ConnectionAdapter() {
+            @Override
+            public void onStreamAdded(Http2Stream stream) {
+                // Unconditionally used the reduced flow control state because it requires no object allocation
+                // and the DefaultFlowState will be allocated in onStreamActive.
+                stream.setProperty(stateKey, REDUCED_FLOW_STATE);
+            }
+
+            @Override
+            public void onStreamActive(Http2Stream stream) {
+                // Need to be sure the stream's initial window is adjusted for SETTINGS
+                // frames which may have been exchanged while it was in IDLE
+                stream.setProperty(stateKey, new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.DefaultState(stream, initialWindowSize));
+            }
+
+            @Override
+            public void onStreamClosed(Http2Stream stream) {
+                try {
+                    // When a stream is closed, consume any remaining bytes so that they
+                    // are restored to the connection window.
+                    org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state = state(stream);
+                    int unconsumedBytes = state.unconsumedBytes();
+                    if (ctx != null && unconsumedBytes > 0) {
+                        if (consumeAllBytes(state, unconsumedBytes)) {
+                            // As the user has no real control on when this callback is used we should better
+                            // call flush() if we produced any window update to ensure we not stale.
+                            ctx.flush();
+                        }
+                    }
+                } catch (Http2Exception e) {
+                    PlatformDependent.throwException(e);
+                } finally {
+                    // Unconditionally reduce the amount of memory required for flow control because there is no
+                    // object allocation costs associated with doing so and the stream will not have any more
+                    // local flow control state to keep track of anymore.
+                    stream.setProperty(stateKey, REDUCED_FLOW_STATE);
+                }
+            }
+        });
+    }
+
+    @Override
+    public TriHttp2LocalFlowController frameWriter(Http2FrameWriter frameWriter) {
+        this.frameWriter = checkNotNull(frameWriter, ""frameWriter"");
+        return this;
+    }
+
+    @Override
+    public void channelHandlerContext(ChannelHandlerContext ctx) {
+        this.ctx = checkNotNull(ctx, ""ctx"");
+    }
+
+    @Override
+    public void initialWindowSize(int newWindowSize) throws Http2Exception {
+        assert ctx == null || ctx.executor().inEventLoop();
+        int delta = newWindowSize - initialWindowSize;
+        initialWindowSize = newWindowSize;
+
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.WindowUpdateVisitor visitor = new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.WindowUpdateVisitor(delta);
+        connection.forEachActiveStream(visitor);
+        visitor.throwIfError();
+    }
+
+    @Override
+    public int initialWindowSize() {
+        return initialWindowSize;
+    }
+
+    @Override
+    public int windowSize(Http2Stream stream) {
+        return state(stream).windowSize();
+    }
+
+    @Override
+    public int initialWindowSize(Http2Stream stream) {
+        return state(stream).initialWindowSize();
+    }
+
+    @Override
+    public void incrementWindowSize(Http2Stream stream, int delta) throws Http2Exception {
+        assert ctx != null && ctx.executor().inEventLoop();
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state = state(stream);
+        // Just add the delta to the stream-specific initial window size so that the next time the window
+        // expands it will grow to the new initial size.
+        state.incrementInitialStreamWindow(delta);
+        state.writeWindowUpdateIfNeeded();
+    }
+
+    public boolean consumeTriBytes(Http2Stream stream, int numBytes)  throws Http2Exception {
+        //because triple thread do consume ,so delete ctx.executor().inEventLoop()
+        assert ctx != null ;
+        //     assert ctx != null && ctx.executor().inEventLoop();
+        checkPositiveOrZero(numBytes, ""numBytes"");
+        if (numBytes == 0) {
+            return false;
+        }
+        // Streams automatically consume all remaining bytes when they are closed, so just ignore
+        // if already closed.
+        if (stream != null && !isClosed(stream)) {
+            if (stream.id() == CONNECTION_STREAM_ID) {
+                throw new UnsupportedOperationException(""Returning bytes for the connection window is not supported"");
+            }
+
+            return consumeAllBytes(state(stream), numBytes);
+        }
+        return false;
+    }
+
+    @Override
+    public boolean consumeBytes(Http2Stream stream, int numBytes) throws Http2Exception {
+        return false;
+    }
+
+    private boolean consumeAllBytes(org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state, int numBytes) throws Http2Exception {
+        return connectionState().consumeBytes(numBytes) | state.consumeBytes(numBytes);
+    }
+
+    @Override
+    public int unconsumedBytes(Http2Stream stream) {
+        return state(stream).unconsumedBytes();
+    }
+
+    private static void checkValidRatio(float ratio) {
+        if (Double.compare(ratio, 0.0) <= 0 || Double.compare(ratio, 1.0) >= 0) {
+            throw new IllegalArgumentException(""Invalid ratio: "" + ratio);
+        }
+    }
+
+    /**
+     * The window update ratio is used to determine when a window update must be sent. If the ratio
+     * of bytes processed since the last update has meet or exceeded this ratio then a window update will
+     * be sent. This is the global window update ratio that will be used for new streams.
+     * @param ratio the ratio to use when checking if a {@code WINDOW_UPDATE} is determined necessary for new streams.
+     * @throws IllegalArgumentException If the ratio is out of bounds (0, 1).
+     */
+    public void windowUpdateRatio(float ratio) {
+        assert ctx == null || ctx.executor().inEventLoop();
+        checkValidRatio(ratio);
+        windowUpdateRatio = ratio;
+    }
+
+    /**
+     * The window update ratio is used to determine when a window update must be sent. If the ratio
+     * of bytes processed since the last update has meet or exceeded this ratio then a window update will
+     * be sent. This is the global window update ratio that will be used for new streams.
+     */
+    public float windowUpdateRatio() {
+        return windowUpdateRatio;
+    }
+
+    /**
+     * The window update ratio is used to determine when a window update must be sent. If the ratio
+     * of bytes processed since the last update has meet or exceeded this ratio then a window update will
+     * be sent. This window update ratio will only be applied to {@code streamId}.
+     * <p>
+     * Note it is the responsibly of the caller to ensure that the the
+     * initial {@code SETTINGS} frame is sent before this is called. It would
+     * be considered a {@link Http2Error#PROTOCOL_ERROR} if a {@code WINDOW_UPDATE}
+     * was generated by this method before the initial {@code SETTINGS} frame is sent.
+     * @param stream the stream for which {@code ratio} applies to.
+     * @param ratio the ratio to use when checking if a {@code WINDOW_UPDATE} is determined necessary.
+     * @throws Http2Exception If a protocol-error occurs while generating {@code WINDOW_UPDATE} frames
+     */
+    public void windowUpdateRatio(Http2Stream stream, float ratio) throws Http2Exception {
+        assert ctx != null && ctx.executor().inEventLoop();
+        checkValidRatio(ratio);
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state = state(stream);
+        state.windowUpdateRatio(ratio);
+        state.writeWindowUpdateIfNeeded();
+    }
+
+    /**
+     * The window update ratio is used to determine when a window update must be sent. If the ratio
+     * of bytes processed since the last update has meet or exceeded this ratio then a window update will
+     * be sent. This window update ratio will only be applied to {@code streamId}.
+     * @throws Http2Exception If no stream corresponding to {@code stream} could be found.
+     */
+    public float windowUpdateRatio(Http2Stream stream) throws Http2Exception {
+        return state(stream).windowUpdateRatio();
+    }
+
+    @Override
+    public void receiveFlowControlledFrame(Http2Stream stream, ByteBuf data, int padding,
+                                           boolean endOfStream) throws Http2Exception {
+        assert ctx != null && ctx.executor().inEventLoop();
+        int dataLength = data.readableBytes() + padding;
+
+        // Apply the connection-level flow control
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState connectionState = connectionState();
+        connectionState.receiveFlowControlledFrame(dataLength);
+
+        if (stream != null && !isClosed(stream)) {
+            // Apply the stream-level flow control
+            org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state = state(stream);
+            state.endOfStream(endOfStream);
+            state.receiveFlowControlledFrame(dataLength);
+        } else if (dataLength > 0) {
+            // Immediately consume the bytes for the connection window.
+            connectionState.consumeBytes(dataLength);
+        }
+    }
+
+    private org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState connectionState() {
+        return connection.connectionStream().getProperty(stateKey);
+    }
+
+    private org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state(Http2Stream stream) {
+        return stream.getProperty(stateKey);
+    }
+
+    private static boolean isClosed(Http2Stream stream) {
+        return stream.state() == Http2Stream.State.CLOSED;
+    }
+
+    /**
+     * Flow control state that does autorefill of the flow control window when the data is
+     * received.
+     */
+    private final class AutoRefillState extends org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.DefaultState {
+        AutoRefillState(Http2Stream stream, int initialWindowSize) {
+            super(stream, initialWindowSize);
+        }
+
+        @Override
+        public void receiveFlowControlledFrame(int dataLength) throws Http2Exception {
+            super.receiveFlowControlledFrame(dataLength);
+            // Need to call the super to consume the bytes, since this.consumeBytes does nothing.
+            super.consumeBytes(dataLength);
+        }
+
+        @Override
+        public boolean consumeBytes(int numBytes) throws Http2Exception {
+            // Do nothing, since the bytes are already consumed upon receiving the data.
+            return false;
+        }
+    }
+
+    /**
+     * Flow control window state for an individual stream.
+     */
+    private class DefaultState implements org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState {
+        private final Http2Stream stream;
+
+        /**
+         * The actual flow control window that is decremented as soon as {@code DATA} arrives.
+         */
+        private int window;
+
+        /**
+         * A view of {@link #window} that is used to determine when to send {@code WINDOW_UPDATE}
+         * frames. Decrementing this window for received {@code DATA} frames is delayed until the
+         * application has indicated that the data has been fully processed. This prevents sending
+         * a {@code WINDOW_UPDATE} until the number of processed bytes drops below the threshold.
+         */
+        private int processedWindow;
+
+        /**
+         * This is what is used to determine how many bytes need to be returned relative to {@link #processedWindow}.
+         * Each stream has their own initial window size.
+         */
+        private int initialStreamWindowSize;
+
+        /**
+         * This is used to determine when {@link #processedWindow} is sufficiently far away from
+         * {@link #initialStreamWindowSize} such that a {@code WINDOW_UPDATE} should be sent.
+         * Each stream has their own window update ratio.
+         */
+        private float streamWindowUpdateRatio;
+
+        private int lowerBound;
+        private boolean endOfStream;
+
+        DefaultState(Http2Stream stream, int initialWindowSize) {
+            this.stream = stream;
+            window(initialWindowSize);
+            streamWindowUpdateRatio = windowUpdateRatio;
+        }
+
+        @Override
+        public void window(int initialWindowSize) {
+            assert ctx == null || ctx.executor().inEventLoop();
+            window = processedWindow = initialStreamWindowSize = initialWindowSize;
+        }
+
+        @Override
+        public int windowSize() {
+            return window;
+        }
+
+        @Override
+        public int initialWindowSize() {
+            return initialStreamWindowSize;
+        }
+
+        @Override
+        public void endOfStream(boolean endOfStream) {
+            this.endOfStream = endOfStream;
+        }
+
+        @Override
+        public float windowUpdateRatio() {
+            return streamWindowUpdateRatio;
+        }
+
+        @Override
+        public void windowUpdateRatio(float ratio) {
+            assert ctx == null || ctx.executor().inEventLoop();
+            streamWindowUpdateRatio = ratio;
+        }
+
+        @Override
+        public void incrementInitialStreamWindow(int delta) {
+            // Clip the delta so that the resulting initialStreamWindowSize falls within the allowed range.
+            int newValue = (int) min(MAX_INITIAL_WINDOW_SIZE,
+                max(MIN_INITIAL_WINDOW_SIZE, initialStreamWindowSize + (long) delta));
+            delta = newValue - initialStreamWindowSize;
+
+            initialStreamWindowSize += delta;
+        }
+
+        @Override
+        public void incrementFlowControlWindows(int delta) throws Http2Exception {
+            if (delta > 0 && window > MAX_INITIAL_WINDOW_SIZE - delta) {
+                throw streamError(stream.id(), FLOW_CONTROL_ERROR,
+                    ""Flow control window overflowed for stream: %d"", stream.id());
+            }
+
+            window += delta;
+            processedWindow += delta;
+            lowerBound = delta < 0 ? delta : 0;","[{'comment': '\r\n```suggestion\r\n            lowerBound = Math.min(delta, 0);\r\n```', 'commenter': 'guohao'}, {'comment': 'done', 'commenter': 'asa3311'}]"
10748,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationPostProcessor.java,"@@ -354,7 +355,12 @@ private void processScannedBeanDefinition(BeanDefinitionHolder beanDefinitionHol
     private Annotation findServiceAnnotation(Class<?> beanClass) {
         return serviceAnnotationTypes
                 .stream()
-                .map(annotationType -> findAnnotation(beanClass, annotationType))
+            .map(annotationType ->","[{'comment': 'seems it is unrelated ', 'commenter': 'guohao'}, {'comment': 'Removed', 'commenter': 'asa3311'}]"
10748,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServiceContext.java,"@@ -186,6 +186,9 @@ public List<URL> getUrls() {
     @Override
     public void setUrls(List<URL> urls) {
         this.urls = urls;
+        if (!urls.isEmpty()) {","[{'comment': 'seems it is unrelated', 'commenter': 'guohao'}, {'comment': 'Removed', 'commenter': 'asa3311'}]"
10748,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java,"@@ -99,7 +99,14 @@ protected Result doInvoke(final Invocation invocation) throws Throwable {
         }
         try {
             boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);
+
             int timeout = calculateTimeout(invocation, methodName);
+            if (timeout <= 0) {","[{'comment': 'seems it is unrelated', 'commenter': 'guohao'}, {'comment': 'Removed', 'commenter': 'asa3311'}]"
10748,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java,"@@ -108,7 +115,7 @@ protected Result doInvoke(final Invocation invocation) throws Throwable {
             } else {
                 ExecutorService executor = getCallbackExecutor(getUrl(), inv);
                 CompletableFuture<AppResponse> appResponseFuture =
-                        currentClient.request(inv, timeout, executor).thenApply(obj -> (AppResponse) obj);
+                    currentClient.request(inv, timeout, executor).thenApply(obj -> (AppResponse) obj);","[{'comment': 'no need to  fmt ', 'commenter': 'guohao'}, {'comment': 'Removed', 'commenter': 'asa3311'}]"
10748,dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmInvoker.java,"@@ -102,7 +102,15 @@ public Result doInvoke(Invocation invocation) throws Throwable {
         if (serverHasToken) {
             invocation.setAttachment(Constants.TOKEN_KEY, serverURL.getParameter(Constants.TOKEN_KEY));
         }
-        invocation.setAttachment(TIMEOUT_KEY, calculateTimeout(invocation, invocation.getMethodName()));
+
+        int timeout = calculateTimeout(invocation, invocation.getMethodName());","[{'comment': 'seems it is unrelated', 'commenter': 'guohao'}, {'comment': 'Removed', 'commenter': 'asa3311'}]"
10748,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2LocalFlowController.java,"@@ -0,0 +1,648 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the ""License""); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri;
+import static io.netty.handler.codec.http2.Http2CodecUtil.CONNECTION_STREAM_ID;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_INITIAL_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_INITIAL_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2Error.FLOW_CONTROL_ERROR;
+import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
+import static io.netty.handler.codec.http2.Http2Exception.connectionError;
+import static io.netty.handler.codec.http2.Http2Exception.streamError;
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
+import static java.lang.Math.max;
+import static java.lang.Math.min;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http2.Http2StreamVisitor;
+import io.netty.handler.codec.http2.Http2Exception;
+import io.netty.handler.codec.http2.Http2ConnectionAdapter;
+import io.netty.handler.codec.http2.Http2Connection;
+import io.netty.handler.codec.http2.Http2Exception.CompositeStreamException;
+import io.netty.handler.codec.http2.Http2Exception.StreamException;
+import io.netty.handler.codec.http2.Http2FrameWriter;
+import io.netty.handler.codec.http2.Http2LocalFlowController;
+import io.netty.handler.codec.http2.Http2Stream;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.UnstableApi;
+import org.apache.dubbo.common.config.Configuration;
+import org.apache.dubbo.common.config.ConfigurationUtils;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import static org.apache.dubbo.rpc.Constants.H2_SETTINGS_INITIAL_WINDOW_SIZE_KEY;
+/**
+ * This design is learning from {@see io.netty.handler.codec.http2.DefaultHttp2LocalFlowController} which is in Netty.
+ */
+@UnstableApi
+public class TriHttp2LocalFlowController implements Http2LocalFlowController {
+    /**
+     * The default ratio of window size to initial window size below which a {@code WINDOW_UPDATE}
+     * is sent to expand the window.
+     */
+    public static final float DEFAULT_WINDOW_UPDATE_RATIO = 0.5f;
+
+    private final Http2Connection connection;
+    private final Http2Connection.PropertyKey stateKey;
+    private Http2FrameWriter frameWriter;
+    private ChannelHandlerContext ctx;
+    private float windowUpdateRatio;
+    private Configuration config = ConfigurationUtils.getGlobalConfiguration(
+        ApplicationModel.defaultModel());
+    private int initialWindowSize = config.getInt(H2_SETTINGS_INITIAL_WINDOW_SIZE_KEY, DEFAULT_WINDOW_SIZE);
+
+    public TriHttp2LocalFlowController(Http2Connection connection) {
+        this(connection, DEFAULT_WINDOW_UPDATE_RATIO, false);
+    }
+
+    public TriHttp2LocalFlowController(Http2Connection connection,
+                                       float windowUpdateRatio,
+                                       boolean autoRefillConnectionWindow) {
+        this.connection = checkNotNull(connection, ""connection"");
+        windowUpdateRatio(windowUpdateRatio);
+
+        // Add a flow state for the connection.
+        stateKey = connection.newKey();
+        FlowState connectionState = autoRefillConnectionWindow ?
+                new AutoRefillState(connection.connectionStream(), initialWindowSize) :
+                new DefaultState(connection.connectionStream(), initialWindowSize);
+        connection.connectionStream().setProperty(stateKey, connectionState);
+
+        // Register for notification of new streams.
+        connection.addListener(new Http2ConnectionAdapter() {
+            @Override
+            public void onStreamAdded(Http2Stream stream) {
+                // Unconditionally used the reduced flow control state because it requires no object allocation
+                // and the DefaultFlowState will be allocated in onStreamActive.
+                stream.setProperty(stateKey, REDUCED_FLOW_STATE);
+            }
+
+            @Override
+            public void onStreamActive(Http2Stream stream) {
+                // Need to be sure the stream's initial window is adjusted for SETTINGS
+                // frames which may have been exchanged while it was in IDLE
+                stream.setProperty(stateKey, new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.DefaultState(stream, initialWindowSize));","[{'comment': 'import', 'commenter': 'guohao'}, {'comment': 'done', 'commenter': 'asa3311'}]"
10748,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2LocalFlowController.java,"@@ -0,0 +1,648 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the ""License""); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri;
+import static io.netty.handler.codec.http2.Http2CodecUtil.CONNECTION_STREAM_ID;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_INITIAL_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_INITIAL_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2Error.FLOW_CONTROL_ERROR;
+import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
+import static io.netty.handler.codec.http2.Http2Exception.connectionError;
+import static io.netty.handler.codec.http2.Http2Exception.streamError;
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
+import static java.lang.Math.max;
+import static java.lang.Math.min;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http2.Http2StreamVisitor;
+import io.netty.handler.codec.http2.Http2Exception;
+import io.netty.handler.codec.http2.Http2ConnectionAdapter;
+import io.netty.handler.codec.http2.Http2Connection;
+import io.netty.handler.codec.http2.Http2Exception.CompositeStreamException;
+import io.netty.handler.codec.http2.Http2Exception.StreamException;
+import io.netty.handler.codec.http2.Http2FrameWriter;
+import io.netty.handler.codec.http2.Http2LocalFlowController;
+import io.netty.handler.codec.http2.Http2Stream;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.UnstableApi;
+import org.apache.dubbo.common.config.Configuration;
+import org.apache.dubbo.common.config.ConfigurationUtils;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import static org.apache.dubbo.rpc.Constants.H2_SETTINGS_INITIAL_WINDOW_SIZE_KEY;
+/**
+ * This design is learning from {@see io.netty.handler.codec.http2.DefaultHttp2LocalFlowController} which is in Netty.
+ */
+@UnstableApi
+public class TriHttp2LocalFlowController implements Http2LocalFlowController {
+    /**
+     * The default ratio of window size to initial window size below which a {@code WINDOW_UPDATE}
+     * is sent to expand the window.
+     */
+    public static final float DEFAULT_WINDOW_UPDATE_RATIO = 0.5f;
+
+    private final Http2Connection connection;
+    private final Http2Connection.PropertyKey stateKey;
+    private Http2FrameWriter frameWriter;
+    private ChannelHandlerContext ctx;
+    private float windowUpdateRatio;
+    private Configuration config = ConfigurationUtils.getGlobalConfiguration(
+        ApplicationModel.defaultModel());
+    private int initialWindowSize = config.getInt(H2_SETTINGS_INITIAL_WINDOW_SIZE_KEY, DEFAULT_WINDOW_SIZE);
+
+    public TriHttp2LocalFlowController(Http2Connection connection) {
+        this(connection, DEFAULT_WINDOW_UPDATE_RATIO, false);
+    }
+
+    public TriHttp2LocalFlowController(Http2Connection connection,
+                                       float windowUpdateRatio,
+                                       boolean autoRefillConnectionWindow) {
+        this.connection = checkNotNull(connection, ""connection"");
+        windowUpdateRatio(windowUpdateRatio);
+
+        // Add a flow state for the connection.
+        stateKey = connection.newKey();
+        FlowState connectionState = autoRefillConnectionWindow ?
+                new AutoRefillState(connection.connectionStream(), initialWindowSize) :
+                new DefaultState(connection.connectionStream(), initialWindowSize);
+        connection.connectionStream().setProperty(stateKey, connectionState);
+
+        // Register for notification of new streams.
+        connection.addListener(new Http2ConnectionAdapter() {
+            @Override
+            public void onStreamAdded(Http2Stream stream) {
+                // Unconditionally used the reduced flow control state because it requires no object allocation
+                // and the DefaultFlowState will be allocated in onStreamActive.
+                stream.setProperty(stateKey, REDUCED_FLOW_STATE);
+            }
+
+            @Override
+            public void onStreamActive(Http2Stream stream) {
+                // Need to be sure the stream's initial window is adjusted for SETTINGS
+                // frames which may have been exchanged while it was in IDLE
+                stream.setProperty(stateKey, new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.DefaultState(stream, initialWindowSize));
+            }
+
+            @Override
+            public void onStreamClosed(Http2Stream stream) {
+                try {
+                    // When a stream is closed, consume any remaining bytes so that they
+                    // are restored to the connection window.
+                    org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.FlowState state = state(stream);
+                    int unconsumedBytes = state.unconsumedBytes();
+                    if (ctx != null && unconsumedBytes > 0) {
+                        if (consumeAllBytes(state, unconsumedBytes)) {
+                            // As the user has no real control on when this callback is used we should better
+                            // call flush() if we produced any window update to ensure we not stale.
+                            ctx.flush();
+                        }
+                    }
+                } catch (Http2Exception e) {
+                    PlatformDependent.throwException(e);
+                } finally {
+                    // Unconditionally reduce the amount of memory required for flow control because there is no
+                    // object allocation costs associated with doing so and the stream will not have any more
+                    // local flow control state to keep track of anymore.
+                    stream.setProperty(stateKey, REDUCED_FLOW_STATE);
+                }
+            }
+        });
+    }
+
+    @Override
+    public TriHttp2LocalFlowController frameWriter(Http2FrameWriter frameWriter) {
+        this.frameWriter = checkNotNull(frameWriter, ""frameWriter"");
+        return this;
+    }
+
+    @Override
+    public void channelHandlerContext(ChannelHandlerContext ctx) {
+        this.ctx = checkNotNull(ctx, ""ctx"");
+    }
+
+    @Override
+    public void initialWindowSize(int newWindowSize) throws Http2Exception {
+        assert ctx == null || ctx.executor().inEventLoop();
+        int delta = newWindowSize - initialWindowSize;
+        initialWindowSize = newWindowSize;
+
+        org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.WindowUpdateVisitor visitor = new org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController.WindowUpdateVisitor(delta);","[{'comment': 'import', 'commenter': 'guohao'}, {'comment': 'done', 'commenter': 'asa3311'}]"
10748,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java,"@@ -192,8 +192,15 @@ StreamObserver<Object> streamCall(ClientCall call,
     AsyncRpcResult invokeUnary(MethodDescriptor methodDescriptor, Invocation invocation,
         ClientCall call) {
         ExecutorService callbackExecutor = getCallbackExecutor(getUrl(), invocation);
+
         int timeout = calculateTimeout(invocation, invocation.getMethodName());
+        if (timeout <= 0) {","[{'comment': 'same question, and DRY', 'commenter': 'guohao'}, {'comment': 'Removed', 'commenter': 'asa3311'}]"
10748,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java,"@@ -48,6 +48,7 @@
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
 
+","[{'comment': 'no need to fmt', 'commenter': 'guohao'}, {'comment': 'done', 'commenter': 'asa3311'}]"
10781,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockInvoker.java,"@@ -194,9 +194,11 @@ public static Object getMockObject(ExtensionDirector extensionDirector, String m
                 + "", please check if there's mock class or instance implementing interface ""
                 + serviceType.getName(), e);
         }
-        if (mockClass == null || !serviceType.isAssignableFrom(mockClass)) {
-            throw new IllegalStateException(""The mock class "" + mockClass.getName() +
-                "" not implement interface "" + serviceType.getName());
+        if (mockClass == null) {
+            throw new IllegalStateException(""not implement interface "" + serviceType.getName());","[{'comment': 'log out `mockService` to help users find out why', 'commenter': 'AlbumenJ'}, {'comment': 'mockService perhaps null', 'commenter': 'zhangzq7'}, {'comment': 'How about log out if is not null?', 'commenter': 'AlbumenJ'}]"
10793,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/PenetrateAttachmentSelector.java,"@@ -29,6 +29,7 @@ public interface PenetrateAttachmentSelector {
      *
      * @return attachment pass to next hop
      */
-    Map<String, Object> select();
+    Map<String, Object> select(Invocation invocation);
+    Map<String, Object> selectReverse(Invocation invocation);","[{'comment': 'Add `RpcContextAttachment serverAttachement / clientResponse` param', 'commenter': 'AlbumenJ'}]"
10793,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java,"@@ -63,6 +63,20 @@ protected RpcContextAttachment initialValue() {
         }
     };
 
+    private static final InternalThreadLocal<RpcContextAttachment> CLIENT_RESPONSE_LOCAL = new InternalThreadLocal<RpcContextAttachment>() {
+        @Override
+        protected RpcContextAttachment initialValue() {
+            return new RpcContextAttachment();
+        }
+    };
+
+    private static final InternalThreadLocal<RpcContextAttachment> SERVER_RESPONSE_LOCAL = new InternalThreadLocal<RpcContextAttachment>() {
+        @Override
+        protected RpcContextAttachment initialValue() {
+            return new RpcContextAttachment();
+        }
+    };","[{'comment': 'Remove `SERVER_LOCAL`. Adapt those apis into `CLIENT_RESPONSE_LOCAL` and `SERVER_RESPONSE_LOCAL`', 'commenter': 'AlbumenJ'}]"
10798,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/ConsumerContextFilter.java,"@@ -116,8 +114,9 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept
     @Override
     public void onResponse(Result appResponse, Invoker<?> invoker, Invocation invocation) {
         // pass attachments to result
-        RpcContext.getServerContext().setObjectAttachments(appResponse.getObjectAttachments());
-
+        Map<String, Object> map = appResponse.getObjectAttachments();
+        RpcContext.getClientResponseContext().setObjectAttachments(map);
+        RpcContext.getServerContext().setObjectAttachments(map);","[{'comment': 'should not call this method here', 'commenter': 'AlbumenJ'}]"
10798,dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcContext.java,"@@ -47,9 +47,19 @@ public static RpcContext getContext() {
     public static RpcContext getServerContext() {
         return new RpcContext(org.apache.dubbo.rpc.RpcContext.getServerContext());
     }
+    public static RpcContext getClientResponseContext() {
+        return new RpcContext(org.apache.dubbo.rpc.RpcContext.getClientResponseContext());
+    }
+
+    public static RpcContext getServerResponseContext() {
+        return new RpcContext(org.apache.dubbo.rpc.RpcContext.getServerResponseContext());
+    }
+    public static void removeClientResponseContext() {
+        org.apache.dubbo.rpc.RpcContext.removeClientResponseContext();
+    }
 
-    public static void removeServerContext() {
-        org.apache.dubbo.rpc.RpcContext.removeServerContext();","[{'comment': 'recover this API', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java,"@@ -56,7 +56,27 @@ public class RpcContext {
     /**
      * use internal thread local to improve performance
      */
-    private static final InternalThreadLocal<RpcContextAttachment> SERVER_LOCAL = new InternalThreadLocal<RpcContextAttachment>() {
+    private static final RpcContext AGENT_SERVER_CONTEXT = new RpcContextAttachment() {
+        @Override
+        public RpcContextAttachment setObjectAttachment(String key, Object value) {
+            if (value == null) {
+                attachments.remove(key);
+            } else {
+                RpcContext.getServerResponseContext().setAttachment(key, value);
+                attachments.put(key, value);
+            }
+            return this;
+        }","[{'comment': 'create a new class file for this', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcContext.java,"@@ -56,7 +56,27 @@ public class RpcContext {
     /**
      * use internal thread local to improve performance
      */
-    private static final InternalThreadLocal<RpcContextAttachment> SERVER_LOCAL = new InternalThreadLocal<RpcContextAttachment>() {
+    private static final RpcContext AGENT_SERVER_CONTEXT = new RpcContextAttachment() {
+        @Override
+        public RpcContextAttachment setObjectAttachment(String key, Object value) {
+            if (value == null) {
+                attachments.remove(key);
+            } else {
+                RpcContext.getServerResponseContext().setAttachment(key, value);
+                attachments.put(key, value);
+            }
+            return this;
+        }
+    };","[{'comment': 'override all methods in RpcContextAttachment, and proxy to serverResponse / clientResponse', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServerContextAttachment.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.util.Map;
+
+public class RpcServerContextAttachment extends RpcContextAttachment{
+    private static final RpcContextAttachment AGENT_SERVER_CONTEXT = new RpcContextAttachment() {
+        @Override
+        public RpcContextAttachment setObjectAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setObjectAttachment(key, value);
+        }
+
+        @Override
+        protected void setAsyncContext(AsyncContext asyncContext) {
+            RpcContext.getServerResponseContext().setAsyncContext(asyncContext);
+        }
+
+        @Override
+        public boolean isAsyncStarted() {
+            return RpcContext.getServerResponseContext().isAsyncStarted();
+        }
+
+        @Override
+        public boolean stopAsync() {
+            return RpcContext.getServerResponseContext().stopAsync();
+        }
+
+        @Override
+        public AsyncContext getAsyncContext() {
+            return RpcContext.getClientResponseContext().getAsyncContext();
+        }
+
+        @Override
+        public String getAttachment(String key) {
+            return RpcContext.getClientResponseContext().getAttachment(key);","[{'comment': 'Get from `serverResponse` first and then fall back to `clientResponse`', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServerContextAttachment.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.util.Map;
+
+public class RpcServerContextAttachment extends RpcContextAttachment{
+    private static final RpcContextAttachment AGENT_SERVER_CONTEXT = new RpcContextAttachment() {
+        @Override
+        public RpcContextAttachment setObjectAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setObjectAttachment(key, value);
+        }
+
+        @Override
+        protected void setAsyncContext(AsyncContext asyncContext) {
+            RpcContext.getServerResponseContext().setAsyncContext(asyncContext);
+        }
+
+        @Override
+        public boolean isAsyncStarted() {
+            return RpcContext.getServerResponseContext().isAsyncStarted();
+        }
+
+        @Override
+        public boolean stopAsync() {
+            return RpcContext.getServerResponseContext().stopAsync();
+        }
+
+        @Override
+        public AsyncContext getAsyncContext() {
+            return RpcContext.getClientResponseContext().getAsyncContext();
+        }
+
+        @Override
+        public String getAttachment(String key) {
+            return RpcContext.getClientResponseContext().getAttachment(key);
+        }
+
+        @Override
+        public Object getObjectAttachment(String key) {
+            return RpcContext.getClientResponseContext().getObjectAttachment(key);","[{'comment': 'Get from `serverResponse` first and then fall back to `clientResponse`', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServerContextAttachment.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.util.Map;
+
+public class RpcServerContextAttachment extends RpcContextAttachment{
+    private static final RpcContextAttachment AGENT_SERVER_CONTEXT = new RpcContextAttachment() {
+        @Override
+        public RpcContextAttachment setObjectAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setObjectAttachment(key, value);
+        }
+
+        @Override
+        protected void setAsyncContext(AsyncContext asyncContext) {
+            RpcContext.getServerResponseContext().setAsyncContext(asyncContext);
+        }
+
+        @Override
+        public boolean isAsyncStarted() {
+            return RpcContext.getServerResponseContext().isAsyncStarted();
+        }
+
+        @Override
+        public boolean stopAsync() {
+            return RpcContext.getServerResponseContext().stopAsync();
+        }
+
+        @Override
+        public AsyncContext getAsyncContext() {
+            return RpcContext.getClientResponseContext().getAsyncContext();
+        }
+
+        @Override
+        public String getAttachment(String key) {
+            return RpcContext.getClientResponseContext().getAttachment(key);
+        }
+
+        @Override
+        public Object getObjectAttachment(String key) {
+            return RpcContext.getClientResponseContext().getObjectAttachment(key);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, String value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment removeAttachment(String key) {
+            return RpcContext.getServerResponseContext().removeAttachment(key);","[{'comment': 'Remove in both `serverResponse` and `clientResponse`', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServerContextAttachment.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.util.Map;
+
+public class RpcServerContextAttachment extends RpcContextAttachment{
+    private static final RpcContextAttachment AGENT_SERVER_CONTEXT = new RpcContextAttachment() {
+        @Override
+        public RpcContextAttachment setObjectAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setObjectAttachment(key, value);
+        }
+
+        @Override
+        protected void setAsyncContext(AsyncContext asyncContext) {
+            RpcContext.getServerResponseContext().setAsyncContext(asyncContext);
+        }
+
+        @Override
+        public boolean isAsyncStarted() {
+            return RpcContext.getServerResponseContext().isAsyncStarted();
+        }
+
+        @Override
+        public boolean stopAsync() {
+            return RpcContext.getServerResponseContext().stopAsync();
+        }
+
+        @Override
+        public AsyncContext getAsyncContext() {
+            return RpcContext.getClientResponseContext().getAsyncContext();
+        }
+
+        @Override
+        public String getAttachment(String key) {
+            return RpcContext.getClientResponseContext().getAttachment(key);
+        }
+
+        @Override
+        public Object getObjectAttachment(String key) {
+            return RpcContext.getClientResponseContext().getObjectAttachment(key);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, String value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment removeAttachment(String key) {
+            return RpcContext.getServerResponseContext().removeAttachment(key);
+        }
+
+        @Override
+        public Map<String, String> getAttachments() {
+            return RpcContext.getServerResponseContext().getAttachments();","[{'comment': 'Create a new map, add all attachments from `clientResponse` and `serverResponse`. `serverResponse` should override `clientResponse`.', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServerContextAttachment.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.util.Map;
+
+public class RpcServerContextAttachment extends RpcContextAttachment{
+    private static final RpcContextAttachment AGENT_SERVER_CONTEXT = new RpcContextAttachment() {
+        @Override
+        public RpcContextAttachment setObjectAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setObjectAttachment(key, value);
+        }
+
+        @Override
+        protected void setAsyncContext(AsyncContext asyncContext) {
+            RpcContext.getServerResponseContext().setAsyncContext(asyncContext);
+        }
+
+        @Override
+        public boolean isAsyncStarted() {
+            return RpcContext.getServerResponseContext().isAsyncStarted();
+        }
+
+        @Override
+        public boolean stopAsync() {
+            return RpcContext.getServerResponseContext().stopAsync();
+        }
+
+        @Override
+        public AsyncContext getAsyncContext() {
+            return RpcContext.getClientResponseContext().getAsyncContext();
+        }
+
+        @Override
+        public String getAttachment(String key) {
+            return RpcContext.getClientResponseContext().getAttachment(key);
+        }
+
+        @Override
+        public Object getObjectAttachment(String key) {
+            return RpcContext.getClientResponseContext().getObjectAttachment(key);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, String value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment removeAttachment(String key) {
+            return RpcContext.getServerResponseContext().removeAttachment(key);
+        }
+
+        @Override
+        public Map<String, String> getAttachments() {
+            return RpcContext.getServerResponseContext().getAttachments();
+        }
+
+        @Override
+        public Map<String, Object> getObjectAttachments() {
+            return RpcContext.getServerResponseContext().getObjectAttachments();","[{'comment': 'Create a new map, add all attachments from `clientResponse` and `serverResponse`. `serverResponse` should override `clientResponse`.', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServerContextAttachment.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.util.Map;
+
+public class RpcServerContextAttachment extends RpcContextAttachment{
+    private static final RpcContextAttachment AGENT_SERVER_CONTEXT = new RpcContextAttachment() {
+        @Override
+        public RpcContextAttachment setObjectAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setObjectAttachment(key, value);
+        }
+
+        @Override
+        protected void setAsyncContext(AsyncContext asyncContext) {
+            RpcContext.getServerResponseContext().setAsyncContext(asyncContext);
+        }
+
+        @Override
+        public boolean isAsyncStarted() {
+            return RpcContext.getServerResponseContext().isAsyncStarted();
+        }
+
+        @Override
+        public boolean stopAsync() {
+            return RpcContext.getServerResponseContext().stopAsync();
+        }
+
+        @Override
+        public AsyncContext getAsyncContext() {
+            return RpcContext.getClientResponseContext().getAsyncContext();
+        }
+
+        @Override
+        public String getAttachment(String key) {
+            return RpcContext.getClientResponseContext().getAttachment(key);
+        }
+
+        @Override
+        public Object getObjectAttachment(String key) {
+            return RpcContext.getClientResponseContext().getObjectAttachment(key);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, String value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment removeAttachment(String key) {
+            return RpcContext.getServerResponseContext().removeAttachment(key);
+        }
+
+        @Override
+        public Map<String, String> getAttachments() {
+            return RpcContext.getServerResponseContext().getAttachments();
+        }
+
+        @Override
+        public Map<String, Object> getObjectAttachments() {
+            return RpcContext.getServerResponseContext().getObjectAttachments();
+        }
+
+        @Override
+        public RpcContextAttachment setAttachments(Map<String, String> attachment) {
+            return RpcContext.getServerResponseContext().setAttachments(attachment);
+        }
+
+        @Override
+        public RpcContextAttachment setObjectAttachments(Map<String, Object> attachment) {
+            return RpcContext.getServerResponseContext().setObjectAttachments(attachment);
+        }
+
+        @Override
+        public void clearAttachments() {
+            RpcContext.getServerResponseContext().clearAttachments();","[{'comment': 'Clear both `serverResponse` and `clientResponse`', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServerContextAttachment.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.util.Map;
+
+public class RpcServerContextAttachment extends RpcContextAttachment{
+    private static final RpcContextAttachment AGENT_SERVER_CONTEXT = new RpcContextAttachment() {
+        @Override
+        public RpcContextAttachment setObjectAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setObjectAttachment(key, value);
+        }
+
+        @Override
+        protected void setAsyncContext(AsyncContext asyncContext) {
+            RpcContext.getServerResponseContext().setAsyncContext(asyncContext);
+        }
+
+        @Override
+        public boolean isAsyncStarted() {
+            return RpcContext.getServerResponseContext().isAsyncStarted();
+        }
+
+        @Override
+        public boolean stopAsync() {
+            return RpcContext.getServerResponseContext().stopAsync();
+        }
+
+        @Override
+        public AsyncContext getAsyncContext() {
+            return RpcContext.getClientResponseContext().getAsyncContext();
+        }
+
+        @Override
+        public String getAttachment(String key) {
+            return RpcContext.getClientResponseContext().getAttachment(key);
+        }
+
+        @Override
+        public Object getObjectAttachment(String key) {
+            return RpcContext.getClientResponseContext().getObjectAttachment(key);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, String value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment removeAttachment(String key) {
+            return RpcContext.getServerResponseContext().removeAttachment(key);
+        }
+
+        @Override
+        public Map<String, String> getAttachments() {
+            return RpcContext.getServerResponseContext().getAttachments();
+        }
+
+        @Override
+        public Map<String, Object> getObjectAttachments() {
+            return RpcContext.getServerResponseContext().getObjectAttachments();
+        }
+
+        @Override
+        public RpcContextAttachment setAttachments(Map<String, String> attachment) {
+            return RpcContext.getServerResponseContext().setAttachments(attachment);
+        }
+
+        @Override
+        public RpcContextAttachment setObjectAttachments(Map<String, Object> attachment) {
+            return RpcContext.getServerResponseContext().setObjectAttachments(attachment);
+        }
+
+        @Override
+        public void clearAttachments() {
+            RpcContext.getServerResponseContext().clearAttachments();
+        }
+
+        @Override
+        public Map<String, Object> get() {
+            return RpcContext.getServerResponseContext().get();","[{'comment': 'Deprecated method. Proxy it to getAttachements()', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServerContextAttachment.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.util.Map;
+
+public class RpcServerContextAttachment extends RpcContextAttachment{
+    private static final RpcContextAttachment AGENT_SERVER_CONTEXT = new RpcContextAttachment() {
+        @Override
+        public RpcContextAttachment setObjectAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setObjectAttachment(key, value);
+        }
+
+        @Override
+        protected void setAsyncContext(AsyncContext asyncContext) {
+            RpcContext.getServerResponseContext().setAsyncContext(asyncContext);
+        }
+
+        @Override
+        public boolean isAsyncStarted() {
+            return RpcContext.getServerResponseContext().isAsyncStarted();
+        }
+
+        @Override
+        public boolean stopAsync() {
+            return RpcContext.getServerResponseContext().stopAsync();
+        }
+
+        @Override
+        public AsyncContext getAsyncContext() {
+            return RpcContext.getClientResponseContext().getAsyncContext();
+        }
+
+        @Override
+        public String getAttachment(String key) {
+            return RpcContext.getClientResponseContext().getAttachment(key);
+        }
+
+        @Override
+        public Object getObjectAttachment(String key) {
+            return RpcContext.getClientResponseContext().getObjectAttachment(key);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, String value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment removeAttachment(String key) {
+            return RpcContext.getServerResponseContext().removeAttachment(key);
+        }
+
+        @Override
+        public Map<String, String> getAttachments() {
+            return RpcContext.getServerResponseContext().getAttachments();
+        }
+
+        @Override
+        public Map<String, Object> getObjectAttachments() {
+            return RpcContext.getServerResponseContext().getObjectAttachments();
+        }
+
+        @Override
+        public RpcContextAttachment setAttachments(Map<String, String> attachment) {
+            return RpcContext.getServerResponseContext().setAttachments(attachment);
+        }
+
+        @Override
+        public RpcContextAttachment setObjectAttachments(Map<String, Object> attachment) {
+            return RpcContext.getServerResponseContext().setObjectAttachments(attachment);
+        }
+
+        @Override
+        public void clearAttachments() {
+            RpcContext.getServerResponseContext().clearAttachments();
+        }
+
+        @Override
+        public Map<String, Object> get() {
+            return RpcContext.getServerResponseContext().get();
+        }
+
+        @Override
+        public RpcContextAttachment set(String key, Object value) {
+            return RpcContext.getServerResponseContext().set(key, value);","[{'comment': 'Deprecated method. Proxy it to `setAttachment`', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServerContextAttachment.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.util.Map;
+
+public class RpcServerContextAttachment extends RpcContextAttachment{
+    private static final RpcContextAttachment AGENT_SERVER_CONTEXT = new RpcContextAttachment() {
+        @Override
+        public RpcContextAttachment setObjectAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setObjectAttachment(key, value);
+        }
+
+        @Override
+        protected void setAsyncContext(AsyncContext asyncContext) {
+            RpcContext.getServerResponseContext().setAsyncContext(asyncContext);
+        }
+
+        @Override
+        public boolean isAsyncStarted() {
+            return RpcContext.getServerResponseContext().isAsyncStarted();
+        }
+
+        @Override
+        public boolean stopAsync() {
+            return RpcContext.getServerResponseContext().stopAsync();
+        }
+
+        @Override
+        public AsyncContext getAsyncContext() {
+            return RpcContext.getClientResponseContext().getAsyncContext();
+        }
+
+        @Override
+        public String getAttachment(String key) {
+            return RpcContext.getClientResponseContext().getAttachment(key);
+        }
+
+        @Override
+        public Object getObjectAttachment(String key) {
+            return RpcContext.getClientResponseContext().getObjectAttachment(key);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, String value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment removeAttachment(String key) {
+            return RpcContext.getServerResponseContext().removeAttachment(key);
+        }
+
+        @Override
+        public Map<String, String> getAttachments() {
+            return RpcContext.getServerResponseContext().getAttachments();
+        }
+
+        @Override
+        public Map<String, Object> getObjectAttachments() {
+            return RpcContext.getServerResponseContext().getObjectAttachments();
+        }
+
+        @Override
+        public RpcContextAttachment setAttachments(Map<String, String> attachment) {
+            return RpcContext.getServerResponseContext().setAttachments(attachment);
+        }
+
+        @Override
+        public RpcContextAttachment setObjectAttachments(Map<String, Object> attachment) {
+            return RpcContext.getServerResponseContext().setObjectAttachments(attachment);
+        }
+
+        @Override
+        public void clearAttachments() {
+            RpcContext.getServerResponseContext().clearAttachments();
+        }
+
+        @Override
+        public Map<String, Object> get() {
+            return RpcContext.getServerResponseContext().get();
+        }
+
+        @Override
+        public RpcContextAttachment set(String key, Object value) {
+            return RpcContext.getServerResponseContext().set(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment remove(String key) {
+            return RpcContext.getServerResponseContext().remove(key);","[{'comment': 'Deprecated method. Proxy it to `removeAttachment`', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServerContextAttachment.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.util.Map;
+
+public class RpcServerContextAttachment extends RpcContextAttachment{
+    private static final RpcContextAttachment AGENT_SERVER_CONTEXT = new RpcContextAttachment() {
+        @Override
+        public RpcContextAttachment setObjectAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setObjectAttachment(key, value);
+        }
+
+        @Override
+        protected void setAsyncContext(AsyncContext asyncContext) {
+            RpcContext.getServerResponseContext().setAsyncContext(asyncContext);
+        }
+
+        @Override
+        public boolean isAsyncStarted() {
+            return RpcContext.getServerResponseContext().isAsyncStarted();
+        }
+
+        @Override
+        public boolean stopAsync() {
+            return RpcContext.getServerResponseContext().stopAsync();
+        }
+
+        @Override
+        public AsyncContext getAsyncContext() {
+            return RpcContext.getClientResponseContext().getAsyncContext();
+        }
+
+        @Override
+        public String getAttachment(String key) {
+            return RpcContext.getClientResponseContext().getAttachment(key);
+        }
+
+        @Override
+        public Object getObjectAttachment(String key) {
+            return RpcContext.getClientResponseContext().getObjectAttachment(key);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, String value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment removeAttachment(String key) {
+            return RpcContext.getServerResponseContext().removeAttachment(key);
+        }
+
+        @Override
+        public Map<String, String> getAttachments() {
+            return RpcContext.getServerResponseContext().getAttachments();
+        }
+
+        @Override
+        public Map<String, Object> getObjectAttachments() {
+            return RpcContext.getServerResponseContext().getObjectAttachments();
+        }
+
+        @Override
+        public RpcContextAttachment setAttachments(Map<String, String> attachment) {
+            return RpcContext.getServerResponseContext().setAttachments(attachment);
+        }
+
+        @Override
+        public RpcContextAttachment setObjectAttachments(Map<String, Object> attachment) {
+            return RpcContext.getServerResponseContext().setObjectAttachments(attachment);
+        }
+
+        @Override
+        public void clearAttachments() {
+            RpcContext.getServerResponseContext().clearAttachments();
+        }
+
+        @Override
+        public Map<String, Object> get() {
+            return RpcContext.getServerResponseContext().get();
+        }
+
+        @Override
+        public RpcContextAttachment set(String key, Object value) {
+            return RpcContext.getServerResponseContext().set(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment remove(String key) {
+            return RpcContext.getServerResponseContext().remove(key);
+        }
+
+        @Override
+        public Object get(String key) {
+            return RpcContext.getServerResponseContext().get(key);","[{'comment': 'Deprecated method. Proxy it to `getAttachment`', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServerContextAttachment.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.util.Map;
+
+public class RpcServerContextAttachment extends RpcContextAttachment{
+    private static final RpcContextAttachment AGENT_SERVER_CONTEXT = new RpcContextAttachment() {
+        @Override
+        public RpcContextAttachment setObjectAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setObjectAttachment(key, value);
+        }
+
+        @Override
+        protected void setAsyncContext(AsyncContext asyncContext) {
+            RpcContext.getServerResponseContext().setAsyncContext(asyncContext);
+        }
+
+        @Override
+        public boolean isAsyncStarted() {
+            return RpcContext.getServerResponseContext().isAsyncStarted();
+        }
+
+        @Override
+        public boolean stopAsync() {
+            return RpcContext.getServerResponseContext().stopAsync();
+        }
+
+        @Override
+        public AsyncContext getAsyncContext() {
+            return RpcContext.getClientResponseContext().getAsyncContext();
+        }
+
+        @Override
+        public String getAttachment(String key) {
+            return RpcContext.getClientResponseContext().getAttachment(key);
+        }
+
+        @Override
+        public Object getObjectAttachment(String key) {
+            return RpcContext.getClientResponseContext().getObjectAttachment(key);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, String value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment removeAttachment(String key) {
+            return RpcContext.getServerResponseContext().removeAttachment(key);
+        }
+
+        @Override
+        public Map<String, String> getAttachments() {
+            return RpcContext.getServerResponseContext().getAttachments();
+        }
+
+        @Override
+        public Map<String, Object> getObjectAttachments() {
+            return RpcContext.getServerResponseContext().getObjectAttachments();
+        }
+
+        @Override
+        public RpcContextAttachment setAttachments(Map<String, String> attachment) {
+            return RpcContext.getServerResponseContext().setAttachments(attachment);
+        }
+
+        @Override
+        public RpcContextAttachment setObjectAttachments(Map<String, Object> attachment) {
+            return RpcContext.getServerResponseContext().setObjectAttachments(attachment);
+        }
+
+        @Override
+        public void clearAttachments() {
+            RpcContext.getServerResponseContext().clearAttachments();
+        }
+
+        @Override
+        public Map<String, Object> get() {
+            return RpcContext.getServerResponseContext().get();
+        }
+
+        @Override
+        public RpcContextAttachment set(String key, Object value) {
+            return RpcContext.getServerResponseContext().set(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment remove(String key) {
+            return RpcContext.getServerResponseContext().remove(key);
+        }
+
+        @Override
+        public Object get(String key) {
+            return RpcContext.getServerResponseContext().get(key);
+        }
+
+        @Override
+        public RpcContextAttachment copyOf(boolean needCopy) {
+            return RpcContext.getServerResponseContext().copyOf(needCopy);","[{'comment': 'Internal method, should not be called. Throw exception directly. BTW, check the usage.', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServerContextAttachment.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.util.Map;
+
+public class RpcServerContextAttachment extends RpcContextAttachment{
+    private static final RpcContextAttachment AGENT_SERVER_CONTEXT = new RpcContextAttachment() {
+        @Override
+        public RpcContextAttachment setObjectAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setObjectAttachment(key, value);
+        }
+
+        @Override
+        protected void setAsyncContext(AsyncContext asyncContext) {
+            RpcContext.getServerResponseContext().setAsyncContext(asyncContext);
+        }
+
+        @Override
+        public boolean isAsyncStarted() {
+            return RpcContext.getServerResponseContext().isAsyncStarted();
+        }
+
+        @Override
+        public boolean stopAsync() {
+            return RpcContext.getServerResponseContext().stopAsync();
+        }
+
+        @Override
+        public AsyncContext getAsyncContext() {
+            return RpcContext.getClientResponseContext().getAsyncContext();
+        }
+
+        @Override
+        public String getAttachment(String key) {
+            return RpcContext.getClientResponseContext().getAttachment(key);
+        }
+
+        @Override
+        public Object getObjectAttachment(String key) {
+            return RpcContext.getClientResponseContext().getObjectAttachment(key);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, String value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment setAttachment(String key, Object value) {
+            return RpcContext.getServerResponseContext().setAttachment(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment removeAttachment(String key) {
+            return RpcContext.getServerResponseContext().removeAttachment(key);
+        }
+
+        @Override
+        public Map<String, String> getAttachments() {
+            return RpcContext.getServerResponseContext().getAttachments();
+        }
+
+        @Override
+        public Map<String, Object> getObjectAttachments() {
+            return RpcContext.getServerResponseContext().getObjectAttachments();
+        }
+
+        @Override
+        public RpcContextAttachment setAttachments(Map<String, String> attachment) {
+            return RpcContext.getServerResponseContext().setAttachments(attachment);
+        }
+
+        @Override
+        public RpcContextAttachment setObjectAttachments(Map<String, Object> attachment) {
+            return RpcContext.getServerResponseContext().setObjectAttachments(attachment);
+        }
+
+        @Override
+        public void clearAttachments() {
+            RpcContext.getServerResponseContext().clearAttachments();
+        }
+
+        @Override
+        public Map<String, Object> get() {
+            return RpcContext.getServerResponseContext().get();
+        }
+
+        @Override
+        public RpcContextAttachment set(String key, Object value) {
+            return RpcContext.getServerResponseContext().set(key, value);
+        }
+
+        @Override
+        public RpcContextAttachment remove(String key) {
+            return RpcContext.getServerResponseContext().remove(key);
+        }
+
+        @Override
+        public Object get(String key) {
+            return RpcContext.getServerResponseContext().get(key);
+        }
+
+        @Override
+        public RpcContextAttachment copyOf(boolean needCopy) {
+            return RpcContext.getServerResponseContext().copyOf(needCopy);
+        }
+
+        @Override
+        protected boolean isValid() {
+            return RpcContext.getServerResponseContext().isValid();","[{'comment': 'Internal method, should not be called. Throw exception directly. BTW, check the usage.', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java,"@@ -58,6 +62,13 @@
  */
 @Activate(group = PROVIDER, order = Integer.MIN_VALUE)
 public class ContextFilter implements Filter, Filter.Listener {
+    private Set<PenetrateAttachmentSelector> supportedSelectors;
+
+    public ContextFilter() {
+        ApplicationModel applicationModel = ApplicationModel.defaultModel();
+        ExtensionLoader<PenetrateAttachmentSelector> selectorExtensionLoader = applicationModel.getExtensionLoader(PenetrateAttachmentSelector.class);","[{'comment': '```suggestion\r\n    public ContextFilter(ApplicationModel applicationModel) {\r\n        ExtensionLoader<PenetrateAttachmentSelector> selectorExtensionLoader = applicationModel.getExtensionLoader(PenetrateAttachmentSelector.class);\r\n```', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/PenetrateAttachmentSelectorMock.java,"@@ -16,17 +16,24 @@
  */
 package org.apache.dubbo.rpc.support;
 
+import org.apache.dubbo.rpc.Invocation;
 import org.apache.dubbo.rpc.PenetrateAttachmentSelector;
 import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcContextAttachment;
 
 import java.util.Map;
 
 public class PenetrateAttachmentSelectorMock implements PenetrateAttachmentSelector {
 
     @Override
-    public Map<String, Object> select() {
+    public Map<String, Object> select(Invocation invocation, RpcContextAttachment clientAttachment, RpcContextAttachment serverAttachment) {
         Map<String, Object> objectAttachments = RpcContext.getServerAttachment().getObjectAttachments();
         objectAttachments.put(""testKey"", ""testVal"");
         return objectAttachments;
     }
+
+    @Override
+    public Map<String, Object> selectReverse(Invocation invocation, RpcContextAttachment clientResponseContext, RpcContextAttachment serverResponseContext) {
+        return null;
+    }","[{'comment': 'Add some test cases for this', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServerContextAttachment.java,"@@ -0,0 +1,253 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.Objects;
+
+public class RpcServerContextAttachment extends RpcContextAttachment {
+    @Override
+    public RpcContextAttachment copyOf(boolean needCopy) {
+        throw new RuntimeException(""copyOf internal method, should not be invoke"");
+    }
+
+    @Override
+    protected boolean isValid() {
+        throw new RuntimeException(""isValid of is internal method, should not be invoke"");
+    }
+
+    @Override
+    public RpcContextAttachment setObjectAttachment(String key, Object value) {
+        return (RpcContextAttachment) getObjectAttachments().put(key, value);
+    }
+
+    @Override
+    protected void setAsyncContext(AsyncContext asyncContext) {
+        RpcContext.getServerResponseContext().setAsyncContext(asyncContext);
+    }
+
+    @Override
+    public boolean isAsyncStarted() {
+        return RpcContext.getServerResponseContext().isAsyncStarted();
+    }
+
+    @Override
+    public boolean stopAsync() {
+        return RpcContext.getServerResponseContext().stopAsync();
+    }
+
+    @Override
+    public AsyncContext getAsyncContext() {
+        return RpcContext.getClientResponseContext().getAsyncContext();
+    }
+
+    @Override
+    public String getAttachment(String key) {
+        return (String) getObjectAttachment(key);
+    }
+
+    @Override
+    public Object getObjectAttachment(String key) {
+        return getAttachmentObjectMap().get(key);
+    }
+
+    @Override
+    public RpcContextAttachment setAttachment(String key, String value) {
+        return (RpcContextAttachment) getAttachmentObjectMap().put(key, value);
+//        return RpcContext.getServerResponseContext().setAttachment(key, value);
+    }
+
+    @Override
+    public RpcContextAttachment setAttachment(String key, Object value) {
+        return (RpcContextAttachment) getObjectAttachments().put(key, value);
+    }
+
+    @Override
+    public RpcContextAttachment removeAttachment(String key) {
+        return (RpcContextAttachment) getAttachmentObjectMap().remove(key);
+    }
+
+    @Override
+    public Map<String, String> getAttachments() {
+        return getAttachmentMap();
+    }
+
+    @Override
+    public Map<String, Object> getObjectAttachments() {
+        return getAttachmentObjectMap();
+    }
+
+    @Override
+    public RpcContextAttachment setAttachments(Map<String, String> attachment) {
+        getAttachmentMap().putAll(attachment);
+        return (RpcContextAttachment) getAttachmentMap();
+    }
+
+    @Override
+    public RpcContextAttachment setObjectAttachments(Map<String, Object> attachment) {
+        getAttachmentObjectMap().putAll(attachment);
+        return (RpcContextAttachment) getAttachmentObjectMap();
+    }
+
+    @Override
+    public void clearAttachments() {
+        getAttachmentMap().clear();
+    }
+
+    public Map<String, String> getAttachmentMap() {
+        return new AttachmentMap(this);
+    }
+
+    public Map<String, Object> getAttachmentObjectMap() {
+        return new AttachmentMap(this);
+    }
+
+    @Override
+    public Map<String, Object> get() {
+        return getObjectAttachments();
+    }
+
+    @Override
+    public RpcContextAttachment set(String key, Object value) {
+        return setAttachment(key, value);
+    }
+
+    @Override
+    public RpcContextAttachment remove(String key) {
+        return removeAttachment(key);
+    }
+
+    @Override
+    public Object get(String key) {
+        return getAttachment(key);
+    }
+
+    static class AttachmentMap implements Map {
+        private RpcServerContextAttachment rpcServerContextAttachment;
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) {
+                return true;
+            }
+            if (o == null || getClass() != o.getClass()) {
+                return false;
+            }
+            RpcServerContextAttachment.AttachmentMap that = (RpcServerContextAttachment.AttachmentMap) o;
+            return Objects.equals(rpcServerContextAttachment, that.rpcServerContextAttachment);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(rpcServerContextAttachment);
+        }
+
+        public AttachmentMap(RpcServerContextAttachment rpcServerContextAttachment) {
+            Map<String, String> attachmentMap = this;
+            attachmentMap.putAll(getAllAttachmentMap());","[{'comment': 'what is the purpose of these two lines', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCallListener.java,"@@ -50,12 +50,14 @@ public void invoke() {
         RpcContext.restoreCancellationContext(cancellationContext);
         InetSocketAddress remoteAddress = (InetSocketAddress) invocation.getAttributes()
             .remove(AbstractServerCall.REMOTE_ADDRESS_KEY);
+        RpcContext.getServerResponseContext().setRemoteAddress(remoteAddress);
         RpcContext.getServerContext().setRemoteAddress(remoteAddress);","[{'comment': '```suggestion\r\n        RpcContext.getServiceContext().setRemoteAddress(remoteAddress);\r\n```', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCallListener.java,"@@ -50,12 +50,14 @@ public void invoke() {
         RpcContext.restoreCancellationContext(cancellationContext);
         InetSocketAddress remoteAddress = (InetSocketAddress) invocation.getAttributes()
             .remove(AbstractServerCall.REMOTE_ADDRESS_KEY);
+        RpcContext.getServerResponseContext().setRemoteAddress(remoteAddress);
         RpcContext.getServerContext().setRemoteAddress(remoteAddress);
         String remoteApp = (String) invocation.getAttributes()
             .remove(TripleHeaderEnum.CONSUMER_APP_NAME_KEY);
         if (null != remoteApp) {
+            RpcContext.getServerResponseContext().setRemoteApplicationName(remoteApp);
             RpcContext.getServerContext().setRemoteApplicationName(remoteApp);","[{'comment': '```suggestion\r\n        RpcContext.getServiceContext().setRemoteApplicationName(remoteApp);\r\n```', 'commenter': 'AlbumenJ'}]"
10798,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCallListener.java,"@@ -50,12 +50,14 @@ public void invoke() {
         RpcContext.restoreCancellationContext(cancellationContext);
         InetSocketAddress remoteAddress = (InetSocketAddress) invocation.getAttributes()
             .remove(AbstractServerCall.REMOTE_ADDRESS_KEY);
+        RpcContext.getServerResponseContext().setRemoteAddress(remoteAddress);
         RpcContext.getServerContext().setRemoteAddress(remoteAddress);
         String remoteApp = (String) invocation.getAttributes()
             .remove(TripleHeaderEnum.CONSUMER_APP_NAME_KEY);
         if (null != remoteApp) {
+            RpcContext.getServerResponseContext().setRemoteApplicationName(remoteApp);
             RpcContext.getServerContext().setRemoteApplicationName(remoteApp);
-        }
+        };","[{'comment': '```suggestion\r\n        }\r\n```', 'commenter': 'AlbumenJ'}]"
10811,dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStreamTest.java,"@@ -109,12 +110,13 @@ public void progress() {
         headers.set(TripleHeaderEnum.STATUS_KEY.getHeader(), TriRpcStatus.OK.code.code + """");
         headers.set(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader(),
             TripleHeaderEnum.CONTENT_PROTO.getHeader());
-        transportListener.onHeader(headers, false);
+        transportListener.onHeader(headers, false,null);
         Assertions.assertTrue(listener.started);
         stream.request(2);
         byte[] data = new byte[]{0, 0, 0, 0, 1, 1};
         final ByteBuf buf = Unpooled.wrappedBuffer(data);
-        transportListener.onData(buf, false);
+        Http2DataFrame fame =  new DefaultHttp2DataFrame(buf);","[{'comment': 'typo', 'commenter': 'guohao'}, {'comment': ""Didn't understand"", 'commenter': 'asa3311'}]"
10811,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java,"@@ -173,12 +173,14 @@ public final void onComplete() {
     }
 
     @Override
-    public final void onMessage(byte[] message) {
+    public final void onMessage(TripleFlowControlFrame data) {","[{'comment': '`FlowControlFrame` should not be known by `Call` class', 'commenter': 'guohao'}, {'comment': 'change to object', 'commenter': 'asa3311'}]"
10811,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleFlowControlFrame.java,"@@ -0,0 +1,80 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri;
+import io.netty.handler.codec.http2.Http2Connection;
+import io.netty.handler.codec.http2.Http2WindowUpdateFrame;
+
+public class TripleFlowControlFrame {
+
+    private Http2Connection http2Connection;
+
+    private int windowSizeIncrement;
+
+    private Http2WindowUpdateFrame http2WindowUpdateFrame;
+
+    private byte[] message;
+
+    private Object instance;
+
+    public TripleFlowControlFrame(Http2Connection http2Connection, int windowSizeIncrement, Http2WindowUpdateFrame http2WindowUpdateFrame, byte[] message){","[{'comment': 'Decouple `message` bytes , instance and flow control related field maybe better', 'commenter': 'guohao'}]"
10811,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriHttp2RemoteFlowController.java,"@@ -0,0 +1,794 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the ""License""); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri;
+
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.internal.UnstableApi;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import io.netty.handler.codec.http2.Http2Error;
+import static io.netty.handler.codec.http2.Http2Error.FLOW_CONTROL_ERROR;
+import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
+import static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;
+import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_WINDOW_SIZE;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_WEIGHT;
+import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_WEIGHT;
+import io.netty.handler.codec.http2.WeightedFairQueueByteDistributor;
+import io.netty.handler.codec.http2.StreamByteDistributor;
+import io.netty.handler.codec.http2.Http2StreamVisitor;
+import io.netty.handler.codec.http2.Http2Exception;
+import io.netty.handler.codec.http2.Http2ConnectionAdapter;
+import io.netty.handler.codec.http2.Http2Connection;
+import io.netty.handler.codec.http2.Http2RemoteFlowController;
+import io.netty.handler.codec.http2.Http2Stream;
+import org.apache.dubbo.common.config.Configuration;
+import org.apache.dubbo.common.config.ConfigurationUtils;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import static io.netty.handler.codec.http2.Http2Exception.streamError;
+import static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_LOCAL;
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
+import static java.lang.Math.max;
+import static java.lang.Math.min;
+import static org.apache.dubbo.rpc.Constants.H2_SETTINGS_INITIAL_WINDOW_SIZE_KEY;
+
+/**
+ * This design is learning from {@see io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController} which is in Netty.
+ */
+@UnstableApi","[{'comment': 'TLDR, why copy instead just use netty directly?', 'commenter': 'guohao'}, {'comment': 'because netty directly will consumeBytes to when received data, i use new function consumeTriBytes to instead it. so it can consumeBytes when after dubbo invoke.', 'commenter': 'asa3311'}]"
10811,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCallListener.java,"@@ -46,7 +47,7 @@ public AbstractServerCallListener(RpcInvocation invocation, Invoker<?> invoker,
         this.responseObserver = responseObserver;
     }
 
-    public void invoke() {
+    public void invoke(TripleFlowControlFrame tripleFlowControlBean) {","[{'comment': '`call` may only need a common `data` class as param, no need to know flow control', 'commenter': 'guohao'}, {'comment': 'change to object', 'commenter': 'asa3311'}]"
10811,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCallListener.java,"@@ -59,6 +60,12 @@ public void invoke() {
         final long stInMillis = System.currentTimeMillis();
         try {
             final Result response = invoker.invoke(invocation);
+            //unary and serverstream add flowcontrol update windowsize
+            if(null != tripleFlowControlBean && null != tripleFlowControlBean.getHttp2Connection() && tripleFlowControlBean.getWindowSizeIncrement() > 0 && null != tripleFlowControlBean.getHttp2WindowUpdateFrame()){","[{'comment': 'This may lead to queueing on IO when `inovke` is slow', 'commenter': 'guohao'}, {'comment': 'is removed ', 'commenter': 'asa3311'}]"
10811,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/BiStreamServerCallListener.java,"@@ -16,22 +16,28 @@
  */
 
 package org.apache.dubbo.rpc.protocol.tri.call;
-
+import io.netty.handler.codec.http2.Http2WindowUpdateFrame;
+import io.netty.handler.codec.http2.Http2Connection;
+import org.apache.dubbo.common.logger.Logger;
+import org.apache.dubbo.common.logger.LoggerFactory;
 import org.apache.dubbo.common.stream.StreamObserver;
 import org.apache.dubbo.rpc.Invoker;
 import org.apache.dubbo.rpc.RpcInvocation;
 import org.apache.dubbo.rpc.TriRpcStatus;
 import org.apache.dubbo.rpc.protocol.tri.observer.ServerCallToObserverAdapter;
-
+import org.apache.dubbo.rpc.protocol.tri.TriHttp2LocalFlowController;
+import org.apache.dubbo.rpc.protocol.tri.TripleFlowControlFrame;
 public class BiStreamServerCallListener extends AbstractServerCallListener {
 
     private StreamObserver<Object> requestObserver;
 
+    private static final Logger LOGGER = LoggerFactory.getLogger(BiStreamServerCallListener.class);
+
     public BiStreamServerCallListener(RpcInvocation invocation, Invoker<?> invoker,
         ServerCallToObserverAdapter<Object> responseObserver) {
         super(invocation, invoker, responseObserver);
         invocation.setArguments(new Object[]{responseObserver});
-        invoke();
+        invoke(null);","[{'comment': '🙅 to pass `null`', 'commenter': 'guohao'}, {'comment': 'done', 'commenter': 'asa3311'}]"
10818,dubbo-dependencies-bom/pom.xml,"@@ -203,11 +212,57 @@
                 <artifactId>netty</artifactId>
                 <version>${netty_version}</version>
             </dependency>
+
             <dependency>
                 <groupId>io.netty</groupId>
                 <artifactId>netty-all</artifactId>
                 <version>${netty4_version}</version>
             </dependency>
+<!--            <dependency>-->
+<!--                <groupId>io.netty</groupId>-->
+<!--                <artifactId>netty-codec</artifactId>-->
+<!--                <version>${netty4_version}</version>-->
+<!--            </dependency>-->
+<!--            <dependency>-->
+<!--                <groupId>io.netty</groupId>-->
+<!--                <artifactId>netty-handler</artifactId>-->
+<!--                <version>${netty4_version}</version>-->
+<!--            </dependency>-->
+<!--            <dependency>-->
+<!--                <groupId>io.netty</groupId>-->
+<!--                <artifactId>netty-codec-http2</artifactId>-->
+<!--                <version>${netty4_version}</version>-->
+<!--            </dependency>-->
+
+<!--            <dependency>-->
+<!--                <groupId>io.netty</groupId>-->
+<!--                <artifactId>netty-transport-native-epoll</artifactId>-->
+<!--                <version>${netty4_version}</version>-->
+<!--                <classifier>linux-x86_64</classifier>-->
+<!--                <scope>runtime</scope>-->
+<!--            </dependency>-->
+<!--            <dependency>-->
+<!--                <groupId>io.netty</groupId>-->
+<!--                <artifactId>netty-transport-native-epoll</artifactId>-->
+<!--                <version>${netty4_version}</version>-->
+<!--                <classifier>linux-aarch_64</classifier>-->
+<!--                <scope>runtime</scope>-->
+<!--            </dependency>-->
+<!--            <dependency>-->
+<!--                <groupId>io.netty</groupId>-->
+<!--                <artifactId>netty-transport-native-kqueue</artifactId>-->
+<!--                <version>${netty4_version}</version>-->
+<!--                <classifier>osx-x86_64</classifier>-->
+<!--                <scope>runtime</scope>-->
+<!--            </dependency>-->
+<!--            <dependency>-->
+<!--                <groupId>io.netty</groupId>-->
+<!--                <artifactId>netty-transport-native-kqueue</artifactId>-->
+<!--                <version>${netty4_version}</version>-->
+<!--                <classifier>osx-aarch_64</classifier>-->
+<!--                <scope>runtime</scope>-->
+<!--            </dependency>-->
+","[{'comment': 'remove unused code', 'commenter': 'AlbumenJ'}]"
10818,dubbo-remoting/dubbo-remoting-api/pom.xml,"@@ -42,7 +42,25 @@
         </dependency>
         <dependency>
             <groupId>io.netty</groupId>
-            <artifactId>netty-all</artifactId>
+            <artifactId>netty-codec</artifactId>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-handler</artifactId>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-transport</artifactId>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-transport-native-epoll</artifactId>
+            <version>4.1.72.Final</version>","[{'comment': 'version should be managed in dubbo-dependenies-bom', 'commenter': 'AlbumenJ'}]"
10818,dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/stub/StubInvocationUtilTest.java,"@@ -1,299 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.rpc.stub;
-
-import org.apache.dubbo.common.URL;
-import org.apache.dubbo.common.stream.StreamObserver;
-import org.apache.dubbo.rpc.Invocation;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.model.ConsumerModel;
-import org.apache.dubbo.rpc.model.MethodDescriptor;
-import org.apache.dubbo.rpc.model.ServiceDescriptor;
-import org.apache.dubbo.rpc.support.DemoService;
-
-import org.junit.jupiter.api.Assertions;
-import org.junit.jupiter.api.Test;
-import org.mockito.Mockito;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static org.junit.jupiter.api.Assertions.fail;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.Mockito.when;
-
-class StubInvocationUtilTest {
-
-    @Test
-    void unaryCall() throws Throwable {
-        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);
-        URL url = Mockito.mock(URL.class);
-        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
-        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
-        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
-        when(url.getServiceModel())
-            .thenReturn(consumerModel);
-        when(url.getServiceInterface())
-            .thenReturn(DemoService.class.getName());
-        when(url.getProtocolServiceKey())
-            .thenReturn(DemoService.class.getName());
-        when(invoker.getUrl())
-            .thenReturn(url);
-        when(invoker.getInterface())
-            .thenReturn(DemoService.class);
-        Result result = Mockito.mock(Result.class);
-        when(invoker.invoke(any(Invocation.class)))
-            .thenReturn(result);
-        String response = ""response"";
-        when(result.recreate()).thenReturn(response);
-        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
-        when(method.getParameterClasses())
-            .thenReturn(new Class[]{String.class});
-        when(method.getMethodName())
-            .thenReturn(""sayHello"");
-        String request = ""request"";
-        Object ret = StubInvocationUtil.unaryCall(invoker, method, request);
-        Assertions.assertEquals(response, ret);
-    }
-
-    @Test
-    void unaryCall2() throws Throwable {
-        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);
-        URL url = Mockito.mock(URL.class);
-        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
-        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
-        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
-        when(url.getServiceModel())
-            .thenReturn(consumerModel);
-        when(url.getServiceInterface())
-            .thenReturn(DemoService.class.getName());
-        when(url.getProtocolServiceKey())
-            .thenReturn(DemoService.class.getName());
-        when(invoker.getUrl())
-            .thenReturn(url);
-        when(invoker.getInterface())
-            .thenReturn(DemoService.class);
-        Result result = Mockito.mock(Result.class);
-        when(invoker.invoke(any(Invocation.class)))
-            .thenThrow(new RuntimeException(""a""))
-            .thenThrow(new Error(""b""));
-        String response = ""response"";
-        when(result.recreate()).thenReturn(response);
-        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
-        when(method.getParameterClasses())
-            .thenReturn(new Class[]{String.class});
-        when(method.getMethodName())
-            .thenReturn(""sayHello"");
-        String request = ""request"";
-        try {
-            StubInvocationUtil.unaryCall(invoker, method, request);
-            fail();
-        }catch (Throwable t){
-            // pass
-        }
-        try {
-            StubInvocationUtil.unaryCall(invoker, method, request);
-            fail();
-        }catch (Throwable t){
-            // pass
-        }
-    }
-
-    @Test
-    void testUnaryCall() throws Throwable {
-        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);
-        URL url = Mockito.mock(URL.class);
-        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
-        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
-        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
-        when(url.getServiceModel())
-            .thenReturn(consumerModel);
-        when(url.getServiceInterface())
-            .thenReturn(DemoService.class.getName());
-        when(url.getProtocolServiceKey())
-            .thenReturn(DemoService.class.getName());
-        when(invoker.getUrl())
-            .thenReturn(url);
-        when(invoker.getInterface())
-            .thenReturn(DemoService.class);
-        Result result = Mockito.mock(Result.class);
-        String response = ""response"";
-        when(invoker.invoke(any(Invocation.class)))
-            .then(invocationOnMock -> result);
-        when(result.recreate()).thenReturn(response);
-        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
-        when(method.getParameterClasses())
-            .thenReturn(new Class[]{String.class});
-        when(method.getMethodName())
-            .thenReturn(""sayHello"");
-        String request = ""request"";
-        CountDownLatch latch = new CountDownLatch(1);
-        AtomicReference<Object> atomicReference = new AtomicReference<>();
-        StreamObserver<Object> responseObserver = new StreamObserver<Object>() {
-            @Override
-            public void onNext(Object data) {
-                atomicReference.set(data);
-            }
-
-            @Override
-            public void onError(Throwable throwable) {
-            }
-
-            @Override
-            public void onCompleted() {
-                latch.countDown();
-            }
-        };
-        StubInvocationUtil.unaryCall(invoker, method, request, responseObserver);
-        latch.await(1, TimeUnit.SECONDS);
-        Assertions.assertEquals(response, atomicReference.get());
-    }
-
-    @Test
-    void biOrClientStreamCall() throws InterruptedException {
-        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);
-        URL url = Mockito.mock(URL.class);
-        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
-        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
-        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
-        when(url.getServiceModel())
-            .thenReturn(consumerModel);
-        when(url.getServiceInterface())
-            .thenReturn(DemoService.class.getName());
-        when(url.getProtocolServiceKey())
-            .thenReturn(DemoService.class.getName());
-        when(invoker.getUrl())
-            .thenReturn(url);
-        when(invoker.getInterface())
-            .thenReturn(DemoService.class);
-        Result result = Mockito.mock(Result.class);
-        String response = ""response"";
-
-        when(invoker.invoke(any(Invocation.class)))
-            .then(invocationOnMock -> {
-                Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
-                StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[0];
-                observer.onNext(response);
-                observer.onCompleted();
-                when(result.recreate()).then(invocationOnMock1 -> new StreamObserver<Object>() {
-                    @Override
-                    public void onNext(Object data) {
-                        observer.onNext(data);
-                    }
-
-                    @Override
-                    public void onError(Throwable throwable) {
-
-                    }
-
-                    @Override
-                    public void onCompleted() {
-                        observer.onCompleted();
-                    }
-                });
-                return result;
-            });
-        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
-        when(method.getParameterClasses())
-            .thenReturn(new Class[]{String.class});
-        when(method.getMethodName())
-            .thenReturn(""sayHello"");
-        String request = ""request"";
-        CountDownLatch latch = new CountDownLatch(11);
-        StreamObserver<Object> responseObserver = new StreamObserver<Object>() {
-            @Override
-            public void onNext(Object data) {
-                latch.countDown();
-            }
-
-            @Override
-            public void onError(Throwable throwable) {
-            }
-
-            @Override
-            public void onCompleted() {
-                latch.countDown();
-            }
-        };
-        StreamObserver<Object> observer = StubInvocationUtil.biOrClientStreamCall(invoker, method,
-            responseObserver);
-        for (int i = 0; i < 10; i++) {
-            observer.onNext(request);
-        }
-        observer.onCompleted();
-        Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
-    }
-
-    @Test
-    void serverStreamCall() throws InterruptedException {
-        Invoker<DemoService> invoker = Mockito.mock(Invoker.class);
-        URL url = Mockito.mock(URL.class);
-        ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
-        ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
-        when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
-        when(url.getServiceModel())
-            .thenReturn(consumerModel);
-        when(url.getServiceInterface())
-            .thenReturn(DemoService.class.getName());
-        when(url.getProtocolServiceKey())
-            .thenReturn(DemoService.class.getName());
-        when(invoker.getUrl())
-            .thenReturn(url);
-        when(invoker.getInterface())
-            .thenReturn(DemoService.class);
-        Result result = Mockito.mock(Result.class);
-        String response = ""response"";
-        when(invoker.invoke(any(Invocation.class)))
-            .then(invocationOnMock -> {
-                Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
-                StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];
-                for (int i = 0; i < 10; i++) {
-                    observer.onNext(response);
-                }
-                observer.onCompleted();
-                return result;
-            });
-        MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
-        when(method.getParameterClasses())
-            .thenReturn(new Class[]{String.class});
-        when(method.getMethodName())
-            .thenReturn(""sayHello"");
-        String request = ""request"";
-        CountDownLatch latch = new CountDownLatch(11);
-        StreamObserver<Object> responseObserver = new StreamObserver<Object>() {
-            @Override
-            public void onNext(Object data) {
-                latch.countDown();
-            }
-
-            @Override
-            public void onError(Throwable throwable) {
-            }
-
-            @Override
-            public void onCompleted() {
-                latch.countDown();
-            }
-        };
-        StubInvocationUtil.serverStreamCall(invoker, method, request, responseObserver);
-        Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
-    }
-
-}","[{'comment': 'Why remove this class', 'commenter': 'AlbumenJ'}]"
10818,dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/stub/StubInvocationUtilTest.java,"@@ -0,0 +1,297 @@
+///*
+// * Licensed to the Apache Software Foundation (ASF) under one or more
+// * contributor license agreements.  See the NOTICE file distributed with
+// * this work for additional information regarding copyright ownership.
+// * The ASF licenses this file to You under the Apache License, Version 2.0
+// * (the ""License""); you may not use this file except in compliance with
+// * the License.  You may obtain a copy of the License at
+// *
+// *     http://www.apache.org/licenses/LICENSE-2.0
+// *
+// * Unless required by applicable law or agreed to in writing, software
+// * distributed under the License is distributed on an ""AS IS"" BASIS,
+// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// * See the License for the specific language governing permissions and
+// * limitations under the License.
+// */
+//
+//package org.apache.dubbo.rpc;
+//
+//import org.apache.dubbo.common.URL;
+//import org.apache.dubbo.common.stream.StreamObserver;
+//import org.apache.dubbo.rpc.model.ConsumerModel;","[{'comment': 'Why remove this class', 'commenter': 'AlbumenJ'}]"
10818,dubbo-remoting/dubbo-remoting-api/pom.xml,"@@ -42,7 +42,24 @@
         </dependency>
         <dependency>
             <groupId>io.netty</groupId>
-            <artifactId>netty-all</artifactId>
+            <artifactId>netty-codec</artifactId>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-handler</artifactId>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-transport</artifactId>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-transport-native-epoll</artifactId>
+            <classifier>linux-x86_64</classifier>","[{'comment': 'should this filed change to os auto detected', 'commenter': 'AlbumenJ'}]"
10819,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/PortUnificationExchanger.java,"@@ -36,6 +39,8 @@ public class PortUnificationExchanger {
     private static final ErrorTypeAwareLogger log = LoggerFactory.getErrorTypeAwareLogger(PortUnificationExchanger.class);
     private static final ConcurrentMap<String, RemotingServer> servers = new ConcurrentHashMap<>();
 
+    private static volatile ConnectionManager connectionManager;","[{'comment': 'Just assign it directly in the property, because `PortUnificationExchanger` is a singleton, `MultiplexProtocolConnectionManager` is also a singleton\r\n', 'commenter': 'CrazyHZM'}]"
10819,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/PortUnificationExchanger.java,"@@ -55,6 +60,22 @@ public static RemotingServer bind(URL url, ChannelHandler handler) {
         return servers.get(url.getAddress());
     }
 
+    public static AbstractConnectionClient connect(URL url, ChannelHandler handler) {
+        if (connectionManager == null) {
+            synchronized (PortUnificationExchanger.class) {
+                if (connectionManager == null) {
+                    connectionManager = url.getOrDefaultFrameworkModel().getExtensionLoader(ConnectionManager.class)
+                            .getExtension(MultiplexProtocolConnectionManager.NAME);
+                }
+            }
+        }
+
+        final AbstractConnectionClient connectionClient;
+        connectionClient = connectionManager.connect(url, handler);","[{'comment': 'This logic should be done in `NettyPortUnificationTransporter`\r\n', 'commenter': 'CrazyHZM'}]"
10819,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java,"@@ -173,8 +178,12 @@ public void configClientPipeline(URL url, ChannelPipeline pipeline, SslContext s
                     DEFAULT_MAX_HEADER_LIST_SIZE)))
             .frameLogger(CLIENT_LOGGER)
             .build();
-        final Http2MultiplexHandler handler = new Http2MultiplexHandler(
-            new TripleClientHandler(frameworkModel));
-        pipeline.addLast(codec, handler, new TripleTailHandler());
+        final Http2MultiplexHandler handler = new Http2MultiplexHandler(new SimpleChannelInboundHandler<Object>() {
+            @Override
+            protected void channelRead0(ChannelHandlerContext ctx, Object msg) {
+                logger.debug(""triple client get msg from Http2MultiplexHandler: "" + msg);","[{'comment': 'Remove unused log', 'commenter': 'CrazyHZM'}]"
10819,dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyPortUnificationTransporter.java,"@@ -33,7 +33,7 @@ public AbstractPortUnificationServer bind(URL url, ChannelHandler handler) throw
     }
 
     @Override
-    public Client connect(URL url, ChannelHandler handler) throws RemotingException {
+    public AbstractConnectionClient connect(URL url, ChannelHandler handler) throws RemotingException {
         return null;
     }","[{'comment': 'Behavior should be consistent with dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationTransporter.java\r\n', 'commenter': 'CrazyHZM'}]"
10819,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHttp2Protocol.java,"@@ -173,8 +178,12 @@ public void configClientPipeline(URL url, ChannelPipeline pipeline, SslContext s
                     DEFAULT_MAX_HEADER_LIST_SIZE)))
             .frameLogger(CLIENT_LOGGER)
             .build();
-        final Http2MultiplexHandler handler = new Http2MultiplexHandler(
-            new TripleClientHandler(frameworkModel));
-        pipeline.addLast(codec, handler, new TripleTailHandler());
+        final Http2MultiplexHandler handler = new Http2MultiplexHandler(new SimpleChannelInboundHandler<Object>() {
+            @Override
+            protected void channelRead0(ChannelHandlerContext ctx, Object msg) {
+                // Do nothing.
+            }
+        });
+        pipeline.addLast(codec, handler, new TripleClientHandler(frameworkModel), new TripleTailHandler());","[{'comment': 'If there is no special reason, this logic does not need to be changed.', 'commenter': 'CrazyHZM'}]"
10819,dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyConnectionClient.java,"@@ -0,0 +1,91 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.remoting.transport.netty;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.remoting.ChannelHandler;
+import org.apache.dubbo.remoting.RemotingException;
+import org.apache.dubbo.remoting.api.connection.AbstractConnectionClient;
+
+import org.jboss.netty.channel.Channel;
+
+public class NettyConnectionClient extends AbstractConnectionClient {
+
+    public NettyConnectionClient(URL url, ChannelHandler handler) throws RemotingException {
+        super(url, handler);
+    }
+
+    @Override
+    protected void initConnectionClient() {
+    }
+
+    @Override
+    public boolean isAvailable() {
+        return false;
+    }
+
+    @Override
+    public void createConnectingPromise() {
+    }
+
+    @Override
+    public void addCloseListener(Runnable func) {
+    }
+
+    @Override
+    public void onConnected(Object channel) {
+    }
+
+    @Override
+    public void onGoaway(Object channel) {
+    }
+
+    @Override","[{'comment': 'Shall we throw exception if users use netty3?', 'commenter': 'AlbumenJ'}, {'comment': '![image](https://user-images.githubusercontent.com/56248584/201877637-31c26621-a2d7-46f6-bbe9-606827f42636.png)\r\nI have removed netty3/NettyConnectionClient and add an Exception in netty3/NettyPortUnificationTransporter', 'commenter': 'conghuhu'}]"
10839,dubbo-common/src/main/java/org/apache/dubbo/common/config/SystemConfiguration.java,"@@ -18,15 +18,27 @@
 
 
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 /**
- * Configuration from system properties
+ * FIXME: is this really necessary? PropertiesConfiguration should have already covered this:
+ *
+ * @See ConfigUtils#getProperty(String)
+ * @see PropertiesConfiguration
  */
 public class SystemConfiguration implements Configuration {
 
+    private final Map<String, Object> cache = new ConcurrentHashMap<>();
+
     @Override
     public Object getInternalProperty(String key) {
-        return System.getProperty(key);
+        if (cache.containsKey(key)) {
+            return cache.get(key);
+        } else {
+            Object val = System.getProperty(key);
+            cache.putIfAbsent(key, val);","[{'comment': 'val may null here', 'commenter': 'AlbumenJ'}]"
10846,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java,"@@ -175,10 +177,75 @@ private String getSpecifiedProtocol() {
         if (StringUtils.isEmpty(protocol)) {
             Map<String, String> params = getApplicationConfig().getParameters();
             if (CollectionUtils.isNotEmptyMap(params)) {
-                protocol = getApplicationConfig().getParameters().get(METADATA_SERVICE_PROTOCOL_KEY);
+                protocol = params.get(METADATA_SERVICE_PROTOCOL_KEY);
             }
         }
 
+        return StringUtils.isNotEmpty(protocol) ? protocol : getRelatedOrDefaultProtocol();
+    }
+
+    /**
+     * Get other configured protocol from environment in priority order. If get nothing, use default dubbo.
+     *
+     * @return
+     */
+    private String getRelatedOrDefaultProtocol() {
+        String protocol = """";
+        // <dubbo:consumer/>
+        Collection<ConsumerConfig> consumers = applicationModel.getDefaultModule().getConfigManager().getConsumers();","[{'comment': 'read all modules (except internal  module)', 'commenter': 'AlbumenJ'}]"
10846,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java,"@@ -175,10 +177,75 @@ private String getSpecifiedProtocol() {
         if (StringUtils.isEmpty(protocol)) {
             Map<String, String> params = getApplicationConfig().getParameters();
             if (CollectionUtils.isNotEmptyMap(params)) {
-                protocol = getApplicationConfig().getParameters().get(METADATA_SERVICE_PROTOCOL_KEY);
+                protocol = params.get(METADATA_SERVICE_PROTOCOL_KEY);
             }
         }
 
+        return StringUtils.isNotEmpty(protocol) ? protocol : getRelatedOrDefaultProtocol();
+    }
+
+    /**
+     * Get other configured protocol from environment in priority order. If get nothing, use default dubbo.
+     *
+     * @return
+     */
+    private String getRelatedOrDefaultProtocol() {
+        String protocol = """";
+        // <dubbo:consumer/>
+        Collection<ConsumerConfig> consumers = applicationModel.getDefaultModule().getConfigManager().getConsumers();
+        if (CollectionUtils.isNotEmpty(consumers)) {
+            for (ConsumerConfig config : consumers) {
+                protocol = config.getProtocol();
+                if (StringUtils.isNotEmpty(protocol)) {
+                    break;
+                }
+            }
+        }
+        // <dubbo:provider/>
+        if (StringUtils.isEmpty(protocol)) {
+            Collection<ProviderConfig> providers = applicationModel.getDefaultModule().getConfigManager().getProviders();
+            if (CollectionUtils.isNotEmpty(providers)) {
+                for (ProviderConfig config : providers) {
+                    ProtocolConfig protocolConfig = config.getProtocol();
+                    protocol = protocolConfig != null ? protocolConfig.getName() : """";
+                    if (StringUtils.isNotEmpty(protocol)) {
+                        break;
+                    } else {
+                        List<ProtocolConfig> protocols = config.getProtocols();
+                        if (CollectionUtils.isNotEmpty(protocols)) {
+                            for (ProtocolConfig protocolCfg : protocols) {
+                                protocol = protocolCfg.getName();
+                                if (StringUtils.isNotEmpty(protocol)) {
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        // <dubbo:protocol/>
+        if (StringUtils.isEmpty(protocol)) {
+            Collection<ProtocolConfig> protocols = applicationModel.getDefaultModule().getConfigManager().getProtocols();","[{'comment': '```suggestion\r\n            Collection<ProtocolConfig> protocols = applicationModel.getApplicationConfigManager().getProtocols();\r\n```', 'commenter': 'AlbumenJ'}]"
10846,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java,"@@ -175,10 +178,82 @@ private String getSpecifiedProtocol() {
         if (StringUtils.isEmpty(protocol)) {
             Map<String, String> params = getApplicationConfig().getParameters();
             if (CollectionUtils.isNotEmptyMap(params)) {
-                protocol = getApplicationConfig().getParameters().get(METADATA_SERVICE_PROTOCOL_KEY);
+                protocol = params.get(METADATA_SERVICE_PROTOCOL_KEY);
             }
         }
 
+        return StringUtils.isNotEmpty(protocol) ? protocol : getRelatedOrDefaultProtocol();
+    }
+
+    /**
+     * Get other configured protocol from environment in priority order. If get nothing, use default dubbo.
+     *
+     * @return
+     */
+    private String getRelatedOrDefaultProtocol() {
+        String protocol = """";
+        // <dubbo:consumer/>
+        List<ModuleModel> moduleModels = applicationModel.getPubModuleModels();
+        breakPoint:","[{'comment': 'Do not use `breakPoint` and `break breakPoint` in Dubbo, pls. \r\nIt would be better to replaced with lambda.', 'commenter': 'AlbumenJ'}]"
10846,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java,"@@ -175,10 +178,82 @@ private String getSpecifiedProtocol() {
         if (StringUtils.isEmpty(protocol)) {
             Map<String, String> params = getApplicationConfig().getParameters();
             if (CollectionUtils.isNotEmptyMap(params)) {
-                protocol = getApplicationConfig().getParameters().get(METADATA_SERVICE_PROTOCOL_KEY);
+                protocol = params.get(METADATA_SERVICE_PROTOCOL_KEY);
             }
         }
 
+        return StringUtils.isNotEmpty(protocol) ? protocol : getRelatedOrDefaultProtocol();
+    }
+
+    /**
+     * Get other configured protocol from environment in priority order. If get nothing, use default dubbo.
+     *
+     * @return
+     */
+    private String getRelatedOrDefaultProtocol() {
+        String protocol = """";
+        // <dubbo:consumer/>
+        List<ModuleModel> moduleModels = applicationModel.getPubModuleModels();
+        breakPoint:
+        for (ModuleModel moduleModel : moduleModels) {
+            Collection<ConsumerConfig> consumers = moduleModel.getConfigManager().getConsumers();
+            if (CollectionUtils.isNotEmpty(consumers)) {
+                for (ConsumerConfig config : consumers) {
+                    protocol = config.getProtocol();
+                    if (StringUtils.isNotEmpty(protocol)) {
+                        break breakPoint;
+                    }
+                }
+            }
+        }","[{'comment': '```suggestion\r\n        protocol = moduleModels.stream()\r\n                .map(ModuleModel::getConfigManager)\r\n                .map(ModuleConfigManager::getConsumers)\r\n                .filter(CollectionUtils::isNotEmpty)\r\n                .flatMap(Collection::stream)\r\n                .map(ConsumerConfig::getProtocol)\r\n                .filter(StringUtils::isNotEmpty)\r\n                .findFirst()\r\n                .orElse(null);\r\n```', 'commenter': 'AlbumenJ'}, {'comment': 'Thank you for your review.', 'commenter': 'pandaapo'}]"
10853,dubbo-distribution/dubbo-all/pom.xml,"@@ -468,6 +468,16 @@
                                     <include>org.apache.dubbo:dubbo-compiler</include>
                                     <include>org.apache.dubbo:dubbo-kubernetes</include>
                                     <include>org.apache.dubbo:dubbo-xds</include>
+                                    <include>org.apache.dubbo:dubbo-filter</include>
+                                    <include>org.apache.dubbo:dubbo-filter-cache</include>
+                                    <include>org.apache.dubbo:dubbo-filter-validation</include>
+                                    <include>org.apache.dubbo:dubbo-spring-boot</include>
+                                    <include>org.apache.dubbo:dubbo-spring-boot-compatible</include>
+                                    <include>org.apache.dubbo:dubbo-spring-boot-autoconfigure-compatible</include>
+                                    <include>org.apache.dubbo:dubbo-spring-boot-autoconfigure</include>
+                                    <include>org.apache.dubbo:dubbo-spring-boot-starter</include>
+                                    <include>org.apache.dubbo:dubbo-spring-boot-actuator-compatible</include>
+                                    <include>org.apache.dubbo:dubbo-spring-boot-actuator</include>","[{'comment': '`dubbo-spring-boot` should not be shaded into `dubbo-all`', 'commenter': 'AlbumenJ'}]"
10853,dubbo-distribution/dubbo-all/pom.xml,"@@ -1119,6 +1129,42 @@
                                         META-INF/dubbo/internal/org.apache.dubbo.validation.Validation
                                     </resource>
                                 </transformer>
+                                <transformer
+                                    implementation=""org.apache.maven.plugins.shade.resource.AppendingTransformer"">
+                                    <resource>
+                                        META-INF/services/org.apache.dubbo.common.extension.LoadingStrategy
+                                    </resource>
+                                </transformer>
+                                <transformer
+                                    implementation=""org.apache.maven.plugins.shade.resource.AppendingTransformer"">
+                                    <resource>
+                                        META-INF/dubbo/internal/org.apache.dubbo.metadata.rest.ServiceRestMetadataResolver
+                                    </resource>
+                                </transformer>
+                                <transformer
+                                    implementation=""org.apache.maven.plugins.shade.resource.AppendingTransformer"">
+                                    <resource>
+                                        META-INF/dubbo/internal/org.apache.dubbo.registry.client.metadata.ServiceInstanceNotificationCustomizer","[{'comment': 'Try define a plugin to check if transformers are comprehensive.', 'commenter': 'AlbumenJ'}]"
10854,dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java,"@@ -600,4 +600,8 @@ public interface CommonConstants {
      *
      */
     String DUBBO_JSTACK_MAXLINE = ""dubbo.jstack-dump.max-line"";
+
+
+    String ENCODE_IN_IO_THREAD_KEY = ""encode.in.io"";
+    boolean DEFAULT_ENCODE_IN_IO_THREAD = true;","[{'comment': 'why not set `false` as default', 'commenter': 'AlbumenJ'}, {'comment': 'I think this is a new feature, maybe use `false` as default', 'commenter': 'icodening'}, {'comment': ""If this doesn't break usage for some users, we can enable it by default. By the way, this PR will be merged into the `3.2` branch, which can accept some breaking changes."", 'commenter': 'AlbumenJ'}, {'comment': 'OK , get', 'commenter': 'icodening'}]"
10855,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java,"@@ -113,7 +117,8 @@ private ProtocolConfig generateMetadataProtocol() {
 
         ProtocolConfig protocolConfig = new ProtocolConfig();
         protocolConfig.setName(specifiedProtocol);
-
+        String serialization = getSerialization(specifiedProtocol);
+        protocolConfig.setSerialization(serialization);","[{'comment': 'Maybe we can merge all of the config from exist protocol config, or directly reuse(if user do not specify different port).', 'commenter': 'AlbumenJ'}, {'comment': 'BTW, please add some uts to verify this', 'commenter': 'AlbumenJ'}, {'comment': '> BTW, please add some uts to verify this\r\n\r\nWe should do this, but need to establish a priority for the configuration reads', 'commenter': 'funky-eyes'}]"
10855,dubbo-common/src/main/java/org/apache/dubbo/config/ProtocolConfig.java,"@@ -579,4 +582,28 @@ public String getExtProtocol() {
     public void setExtProtocol(String extProtocol) {
         this.extProtocol = extProtocol;
     }
+
+    public void mergeProtocol(ProtocolConfig protocolConfig) {","[{'comment': 'add some unit test cases for this', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'funky-eyes'}]"
10855,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java,"@@ -146,6 +145,9 @@ private ProtocolConfig generateMetadataProtocol() {
         } else {
             protocolConfig.setPort(port);
         }
+        
+        applicationModel.getApplicationConfigManager().getProtocol(specifiedProtocol)
+            .ifPresent(protocolConfig::mergeProtocol);","[{'comment': 'Will this override `port` configuration?', 'commenter': 'AlbumenJ'}, {'comment': '> Will this override `port` configuration?\r\n\r\nNo, it will only work on variables with null values', 'commenter': 'funky-eyes'}]"
10885,dubbo-dependencies-bom/pom.xml,"@@ -180,7 +180,7 @@
         <portlet_version>2.0</portlet_version>
         <maven_flatten_version>1.1.0</maven_flatten_version>
         <commons_compress_version>1.21</commons_compress_version>
-        <revision>3.2.0-beta.1-SNAPSHOT</revision>
+        <revision>3.3</revision>","[{'comment': 'Why change this line', 'commenter': 'AlbumenJ'}, {'comment': 'just ignore it', 'commenter': 'aamingaa'}]"
10885,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java,"@@ -139,48 +132,43 @@ public long observeResource(Set<String> resourceNames, Consumer<T> consumer) {
         consumer.accept(getResource(resourceNames));
 
         // channel reused
-        StreamObserver<DiscoveryRequest> requestObserver = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(request));
+        StreamObserver<DiscoveryRequest> requestObserver = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(request, consumer));
         requestObserverMap.put(request, requestObserver);
 
-        ScheduledFuture<?> scheduledFuture = pollingExecutor.scheduleAtFixedRate(() -> {
-            try {
-                // origin request, may changed by updateObserve
-                Set<String> names = requestParam.get(request);
-
-                // use future to get async result, future complete on StreamObserver onNext
-                CompletableFuture<T> future = new CompletableFuture<>();
-                streamResult.put(request, future);
-
-                // observer reused
-                StreamObserver<DiscoveryRequest> observer = requestObserverMap.get(request);
-
-                if (observer == null) {
-                    observer = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(request));
-                    requestObserverMap.put(request, observer);
-                }
-
-                // send request to control panel
-                observer.onNext(buildDiscoveryRequest(names));
-
-                try {
-                    // get result
-                    consumer.accept(future.get());
-                } catch (InterruptedException | ExecutionException e) {
-                    logger.error(""Error occur when request control panel."");
-                } finally {
-                    // close observer
-                    //requestObserver.onCompleted();
-
-                    // remove temp
-                    streamResult.remove(request);
-                }
-            } catch (Throwable t) {
-                logger.error(""Error when requesting observe data. Type: "" + getTypeUrl(), t);
-            }
-        }, pollingTimeout, pollingTimeout, TimeUnit.SECONDS);
+        try {
+            // origin request, may changed by updateObserve
+            Set<String> names = requestParam.get(request);
+
+            // use future to get async result, future complete on StreamObserver onNext
+            CompletableFuture<T> future = new CompletableFuture<>();
+            streamResult.put(request, future);
+
+            // observer reused
+            StreamObserver<DiscoveryRequest> observer = requestObserverMap.get(request);
 
-        observeScheduledMap.put(request, scheduledFuture);
+            if (observer == null) {
+                observer = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(request, consumer));
+                requestObserverMap.put(request, observer);
+            }
 
+            // send request to control panel
+            observer.onNext(buildDiscoveryRequest(names));
+
+//            try {
+//                // get result
+//                consumer.accept(future.get());
+//            } catch (InterruptedException | ExecutionException e) {
+//                logger.error(""Error occur when request control panel."");
+//            } finally {
+//                // close observer
+//                //requestObserver.onCompleted();
+//
+//                // remove temp
+//                streamResult.remove(request);
+//            }","[{'comment': 'remove unused code', 'commenter': 'AlbumenJ'}]"
10885,dubbo-dependencies-bom/pom.xml,"@@ -142,7 +142,7 @@
         <tomcat_embed_version>8.5.78</tomcat_embed_version>
         <jetcd_version>0.5.3</jetcd_version>
         <nacos_version>2.1.0</nacos_version>
-        <grpc.version>1.47.0</grpc.version>
+        <grpc.version>1.41.0</grpc.version>","[{'comment': 'Why lower the grpc version?', 'commenter': 'CrazyHZM'}, {'comment': ""because the 1.47.0 version can't send ca request to envoy"", 'commenter': 'aamingaa'}]"
10885,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/PilotExchanger.java,"@@ -45,61 +46,51 @@ public class PilotExchanger {
     private ListenerResult listenerResult;
 
     private RouteResult routeResult;
-
-    private final AtomicLong observeRouteRequest = new AtomicLong(-1);
-
-    private final Map<String, Long> domainObserveRequest = new ConcurrentHashMap<>();
+    private final AtomicBoolean isRdsObserve = new AtomicBoolean(false);
+    private final HashSet<String> domainObserveRequest = new HashSet<>();
 
     private final Map<String, Set<Consumer<Set<Endpoint>>>> domainObserveConsumer = new ConcurrentHashMap<>();
 
     private PilotExchanger(URL url) {
         xdsChannel = new XdsChannel(url);
-        int pollingPoolSize = url.getParameter(""pollingPoolSize"", 10);
         int pollingTimeout = url.getParameter(""pollingTimeout"", 10);
-        LdsProtocol ldsProtocol = new LdsProtocol(xdsChannel, NodeBuilder.build(), pollingPoolSize, pollingTimeout);
-        this.rdsProtocol = new RdsProtocol(xdsChannel, NodeBuilder.build(), pollingPoolSize, pollingTimeout);
-        this.edsProtocol = new EdsProtocol(xdsChannel, NodeBuilder.build(), pollingPoolSize, pollingTimeout);
+        LdsProtocol ldsProtocol = new LdsProtocol(xdsChannel, NodeBuilder.build(), pollingTimeout);
+        this.rdsProtocol = new RdsProtocol(xdsChannel, NodeBuilder.build(), pollingTimeout);
+        this.edsProtocol = new EdsProtocol(xdsChannel, NodeBuilder.build(), pollingTimeout);
 
         this.listenerResult = ldsProtocol.getListeners();
         this.routeResult = rdsProtocol.getResource(listenerResult.getRouteConfigNames());
 
         // Observer RDS update
         if (CollectionUtils.isNotEmpty(listenerResult.getRouteConfigNames())) {
-            this.observeRouteRequest.set(createRouteObserve());
+            createRouteObserve();
+            isRdsObserve.set(true);
         }
+
         // Observe LDS updated
         ldsProtocol.observeListeners((newListener) -> {
             // update local cache
             if (!newListener.equals(listenerResult)) {
                 this.listenerResult = newListener;
                 // update RDS observation
-                synchronized (observeRouteRequest) {
-                    if (observeRouteRequest.get() == -1) {
-                        this.observeRouteRequest.set(createRouteObserve());
-                    } else {
-                        rdsProtocol.updateObserve(observeRouteRequest.get(), newListener.getRouteConfigNames());
-                    }
+                synchronized (isRdsObserve) {","[{'comment': 'Why sync on a atomic boolean object?', 'commenter': 'AlbumenJ'}]"
10885,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java,"@@ -93,103 +65,23 @@ public AbstractProtocol(XdsChannel xdsChannel, Node node, int pollingPoolSize, i
      */
     public abstract String getTypeUrl();
 
+    public abstract boolean isExistResource(Set<String> resourceNames);
+
+    public abstract T getCacheResource(Set<String> resourceNames);
+
+    public abstract StreamObserver<DiscoveryRequest> getStreamObserver();
     @Override
     public T getResource(Set<String> resourceNames) {
-        long request = requestId.getAndIncrement();
         resourceNames = resourceNames == null ? Collections.emptySet() : resourceNames;
-
-        // Store Request Parameter, which will be used for ACK
-        requestParam.put(request, resourceNames);
-
-        // create observer
-        StreamObserver<DiscoveryRequest> requestObserver = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(request));
-
-        // use future to get async result
-        CompletableFuture<T> future = new CompletableFuture<>();
-        requestObserverMap.put(request, requestObserver);
-        streamResult.put(request, future);
-
-        // send request to control panel
-        requestObserver.onNext(buildDiscoveryRequest(resourceNames));
-
-        try {
-            // get result
-            return future.get();
-        } catch (InterruptedException | ExecutionException e) {
-            logger.error(REGISTRY_ERROR_REQUEST_XDS, """", """", ""Error occur when request control panel."");
-            return null;
-        } finally {
-            // close observer
-            //requestObserver.onCompleted();
-
-            // remove temp
-            streamResult.remove(request);
-            requestObserverMap.remove(request);
-            requestParam.remove(request);
-        }
+        return getCacheResource(resourceNames);
     }
-
     @Override
-    public long observeResource(Set<String> resourceNames, Consumer<T> consumer) {
-        long request = requestId.getAndIncrement();
+    public void observeResource(Set<String> resourceNames, Consumer<T> consumer) {
         resourceNames = resourceNames == null ? Collections.emptySet() : resourceNames;
-
-        // Store Request Parameter, which will be used for ACK
-        requestParam.put(request, resourceNames);
-
         // call once for full data
         consumer.accept(getResource(resourceNames));
-
-        // channel reused
-        StreamObserver<DiscoveryRequest> requestObserver = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(request));
-        requestObserverMap.put(request, requestObserver);
-
-        ScheduledFuture<?> scheduledFuture = pollingExecutor.scheduleAtFixedRate(() -> {
-            try {
-                // origin request, may changed by updateObserve
-                Set<String> names = requestParam.get(request);
-
-                // use future to get async result, future complete on StreamObserver onNext
-                CompletableFuture<T> future = new CompletableFuture<>();
-                streamResult.put(request, future);
-
-                // observer reused
-                StreamObserver<DiscoveryRequest> observer = requestObserverMap.get(request);
-
-                if (observer == null) {
-                    observer = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(request));
-                    requestObserverMap.put(request, observer);
-                }
-
-                // send request to control panel
-                observer.onNext(buildDiscoveryRequest(names));
-
-                try {
-                    // get result
-                    consumer.accept(future.get());
-                } catch (InterruptedException | ExecutionException e) {
-                    logger.error(REGISTRY_ERROR_REQUEST_XDS, """", """", ""Error occur when request control panel."");
-                } finally {
-                    // close observer
-                    //requestObserver.onCompleted();
-
-                    // remove temp
-                    streamResult.remove(request);
-                }
-            } catch (Throwable t) {
-                logger.error(REGISTRY_ERROR_REQUEST_XDS, """", """", ""Error when requesting observe data. Type: "" + getTypeUrl(), t);
-            }
-        }, pollingTimeout, pollingTimeout, TimeUnit.SECONDS);
-
-        observeScheduledMap.put(request, scheduledFuture);
-
-        return request;
-    }
-
-    @Override
-    public void updateObserve(long request, Set<String> resourceNames) {
-        // send difference in resourceNames
-        requestParam.put(request, resourceNames);
+        this.observeResourcesName = resourceNames;
+        this.observeConsumer = consumer;","[{'comment': 'Should support multi observe.\r\nE.g. Consumer 1 consumer resource names 1. Consumer 2 consumer resource names 2.', 'commenter': 'AlbumenJ'}]"
10885,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/impl/EdsProtocol.java,"@@ -43,15 +48,61 @@ public class EdsProtocol extends AbstractProtocol<EndpointResult, DeltaEndpoint>
 
     private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(EdsProtocol.class);
 
-    public EdsProtocol(XdsChannel xdsChannel, Node node, int pollingPoolSize, int pollingTimeout) {
-        super(xdsChannel, node, pollingPoolSize, pollingTimeout);
+    private StreamObserver<DiscoveryRequest> requestObserver;
+
+    private HashMap<String, Object> resourcesMap = new HashMap<>();
+
+
+    public EdsProtocol(XdsChannel xdsChannel, Node node, int pollingTimeout) {
+        super(xdsChannel, node, pollingTimeout);
     }
 
     @Override
     public String getTypeUrl() {
         return ""type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment"";
     }
 
+    @Override
+    public boolean isExistResource(Set<String> resourceNames) {
+        for (String resourceName : resourceNames) {
+            if (!resourcesMap.containsKey(resourceName)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public EndpointResult getCacheResource(Set<String> resourceNames) {
+        Set<Endpoint> resourceSet = new HashSet<>();
+        if (!resourceNames.isEmpty() && isExistResource(resourceNames)) {
+            for (String resourceName : resourceNames) {
+                resourceSet.addAll((Set<Endpoint>) resourcesMap.get(resourceName));
+            }
+        } else {
+            CompletableFuture<EndpointResult> future = new CompletableFuture<>();
+            if (requestObserver == null) {
+                requestObserver = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(future));
+            }","[{'comment': '`future` will never get response if `requestObserver` is not null when `resourceNames` update.', 'commenter': 'AlbumenJ'}]"
10885,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/impl/LdsProtocol.java,"@@ -32,27 +34,75 @@
 import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds;
 import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;
 
-import java.util.Collections;
-import java.util.Objects;
+import java.util.HashMap;
 import java.util.Set;
-import java.util.function.Consumer;
+import java.util.Objects;
+import java.util.HashSet;
+import java.util.Collections;
+import java.util.concurrent.CompletableFuture;
 import java.util.stream.Collectors;
+import java.util.function.Consumer;
 
 import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_ERROR_RESPONSE_XDS;
 
 public class LdsProtocol extends AbstractProtocol<ListenerResult, DeltaListener> {
-
     private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(LdsProtocol.class);
 
-    public LdsProtocol(XdsChannel xdsChannel, Node node, int pollingPoolSize, int pollingTimeout) {
-        super(xdsChannel, node, pollingPoolSize, pollingTimeout);
+    private StreamObserver<DiscoveryRequest> requestObserver;
+
+    private CompletableFuture<ListenerResult> future;
+    public LdsProtocol(XdsChannel xdsChannel, Node node, int pollingTimeout) {
+        super(xdsChannel, node, pollingTimeout);
     }
 
     @Override
     public String getTypeUrl() {
         return ""type.googleapis.com/envoy.config.listener.v3.Listener"";
     }
 
+    private HashMap<String, Object> resourcesMap = new HashMap<>();
+
+    @Override
+    public boolean isExistResource(Set<String> resourceNames) {
+        for (String resourceName : resourceNames) {
+            if (!resourcesMap.containsKey(resourceName)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public ListenerResult getCacheResource(Set<String> resourceNames) {
+        Set<String> resourceSet = new HashSet<>();
+        if (!resourceNames.isEmpty() && isExistResource(resourceNames)) {
+            for (String resourceName : resourceNames) {
+                resourceSet.add((String) resourcesMap.get(resourceName));
+            }
+        } else {
+            if (requestObserver == null) {
+                future = new CompletableFuture<>();
+                requestObserver = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(future));
+            }
+            resourceNames.addAll(resourcesMap.keySet());
+            requestObserver.onNext(buildDiscoveryRequest(resourceNames));
+            try {
+                return future.get();
+            } catch (InterruptedException e) {
+                logger.error(""InterruptedException occur when request control panel. error={}"", e);
+                Thread.currentThread().interrupt();
+            }  catch (Exception e) {
+                logger.error(""Error occur when request control panel. error=. "",e);
+            }
+        }
+        return new ListenerResult(resourceSet);
+    }","[{'comment': 'Move this method impl to `AbstractProtocol`.', 'commenter': 'AlbumenJ'}]"
10885,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/impl/RdsProtocol.java,"@@ -43,22 +46,73 @@ public class RdsProtocol extends AbstractProtocol<RouteResult, DeltaRoute> {
 
     private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(RdsProtocol.class);
 
-    public RdsProtocol(XdsChannel xdsChannel, Node node, int pollingPoolSize, int pollingTimeout) {
-        super(xdsChannel, node, pollingPoolSize, pollingTimeout);
+    private StreamObserver<DiscoveryRequest> requestObserver;
+
+    private HashMap<String, Object> resourcesMap = new HashMap<>();","[{'comment': 'Use concurrent map', 'commenter': 'AlbumenJ'}]"
10885,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java,"@@ -16,182 +16,127 @@
  */
 package org.apache.dubbo.registry.xds.util.protocol;
 
+
 import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;
+
+
 import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.NamedThreadFactory;
+import org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository;
 import org.apache.dubbo.registry.xds.util.XdsChannel;
-
 import io.envoyproxy.envoy.config.core.v3.Node;
 import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;
 import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;
 import io.grpc.stub.StreamObserver;
+import org.apache.dubbo.rpc.model.ApplicationModel;
 
 import java.util.Collections;
-import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.CompletableFuture;
+import java.util.List;
+import java.util.Map;
+import java.util.ArrayList;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ExecutionException;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
 import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_ERROR_REQUEST_XDS;
 
-public abstract class AbstractProtocol<T, S extends DeltaResource<T>> implements XdsProtocol<T> {
+public abstract class AbstractProtocol<T, S extends DeltaResource<T>, R> implements XdsProtocol<T> {
 
     private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(AbstractProtocol.class);
 
-    protected final XdsChannel xdsChannel;
+    protected XdsChannel xdsChannel;
 
     protected final Node node;
 
-    /**
-     * Store Request Parameter ( resourceNames )
-     * K - requestId, V - resourceNames
-     */
-    protected final Map<Long, Set<String>> requestParam = new ConcurrentHashMap<>();
-
-    /**
-     * Store ADS Request Observer ( StreamObserver in Streaming Request )
-     * K - requestId, V - StreamObserver
-     */
-    private final Map<Long, StreamObserver<DiscoveryRequest>> requestObserverMap = new ConcurrentHashMap<>();
-
-    /**
-     * Store Delta-ADS Request Observer ( StreamObserver in Streaming Request )
-     * K - requestId, V - StreamObserver
-     */
-    private final Map<Long, ScheduledFuture<?>> observeScheduledMap = new ConcurrentHashMap<>();
-
-    /**
-     * Store CompletableFuture for Request ( used to fetch async result in ResponseObserver )
-     * K - requestId, V - CompletableFuture
-     */
-    private final Map<Long, CompletableFuture<T>> streamResult = new ConcurrentHashMap<>();
+    private final int pollingTimeout;","[{'comment': 'rename to `checkInterval`', 'commenter': 'AlbumenJ'}]"
10885,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java,"@@ -16,182 +16,127 @@
  */
 package org.apache.dubbo.registry.xds.util.protocol;
 
+
 import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;
+
+
 import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.NamedThreadFactory;
+import org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository;
 import org.apache.dubbo.registry.xds.util.XdsChannel;
-
 import io.envoyproxy.envoy.config.core.v3.Node;
 import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;
 import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;
 import io.grpc.stub.StreamObserver;
+import org.apache.dubbo.rpc.model.ApplicationModel;
 
 import java.util.Collections;
-import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.CompletableFuture;
+import java.util.List;
+import java.util.Map;
+import java.util.ArrayList;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ExecutionException;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
 import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_ERROR_REQUEST_XDS;
 
-public abstract class AbstractProtocol<T, S extends DeltaResource<T>> implements XdsProtocol<T> {
+public abstract class AbstractProtocol<T, S extends DeltaResource<T>, R> implements XdsProtocol<T> {
 
     private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(AbstractProtocol.class);
 
-    protected final XdsChannel xdsChannel;
+    protected XdsChannel xdsChannel;
 
     protected final Node node;
 
-    /**
-     * Store Request Parameter ( resourceNames )
-     * K - requestId, V - resourceNames
-     */
-    protected final Map<Long, Set<String>> requestParam = new ConcurrentHashMap<>();
-
-    /**
-     * Store ADS Request Observer ( StreamObserver in Streaming Request )
-     * K - requestId, V - StreamObserver
-     */
-    private final Map<Long, StreamObserver<DiscoveryRequest>> requestObserverMap = new ConcurrentHashMap<>();
-
-    /**
-     * Store Delta-ADS Request Observer ( StreamObserver in Streaming Request )
-     * K - requestId, V - StreamObserver
-     */
-    private final Map<Long, ScheduledFuture<?>> observeScheduledMap = new ConcurrentHashMap<>();
-
-    /**
-     * Store CompletableFuture for Request ( used to fetch async result in ResponseObserver )
-     * K - requestId, V - CompletableFuture
-     */
-    private final Map<Long, CompletableFuture<T>> streamResult = new ConcurrentHashMap<>();
+    private final int pollingTimeout;
 
-    private final ScheduledExecutorService pollingExecutor;
+    private final Object consumerObserveMapUpdate = new Object();","[{'comment': 'Replace to `ReentrantLock`', 'commenter': 'AlbumenJ'}]"
10885,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java,"@@ -16,182 +16,127 @@
  */
 package org.apache.dubbo.registry.xds.util.protocol;
 
+
 import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;
+
+
 import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.NamedThreadFactory;
+import org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository;
 import org.apache.dubbo.registry.xds.util.XdsChannel;
-
 import io.envoyproxy.envoy.config.core.v3.Node;
 import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;
 import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;
 import io.grpc.stub.StreamObserver;
+import org.apache.dubbo.rpc.model.ApplicationModel;
 
 import java.util.Collections;
-import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.CompletableFuture;
+import java.util.List;
+import java.util.Map;
+import java.util.ArrayList;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ExecutionException;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
 import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_ERROR_REQUEST_XDS;
 
-public abstract class AbstractProtocol<T, S extends DeltaResource<T>> implements XdsProtocol<T> {
+public abstract class AbstractProtocol<T, S extends DeltaResource<T>, R> implements XdsProtocol<T> {
 
     private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(AbstractProtocol.class);
 
-    protected final XdsChannel xdsChannel;
+    protected XdsChannel xdsChannel;
 
     protected final Node node;
 
-    /**
-     * Store Request Parameter ( resourceNames )
-     * K - requestId, V - resourceNames
-     */
-    protected final Map<Long, Set<String>> requestParam = new ConcurrentHashMap<>();
-
-    /**
-     * Store ADS Request Observer ( StreamObserver in Streaming Request )
-     * K - requestId, V - StreamObserver
-     */
-    private final Map<Long, StreamObserver<DiscoveryRequest>> requestObserverMap = new ConcurrentHashMap<>();
-
-    /**
-     * Store Delta-ADS Request Observer ( StreamObserver in Streaming Request )
-     * K - requestId, V - StreamObserver
-     */
-    private final Map<Long, ScheduledFuture<?>> observeScheduledMap = new ConcurrentHashMap<>();
-
-    /**
-     * Store CompletableFuture for Request ( used to fetch async result in ResponseObserver )
-     * K - requestId, V - CompletableFuture
-     */
-    private final Map<Long, CompletableFuture<T>> streamResult = new ConcurrentHashMap<>();
+    private final int pollingTimeout;
 
-    private final ScheduledExecutorService pollingExecutor;
+    private final Object consumerObserveMapUpdate = new Object();
 
-    private final int pollingTimeout;
+    private Set<String> observeResourcesName;
 
-    protected final static AtomicLong requestId = new AtomicLong(0);
+    private final Map<Set<String>, List<Consumer<T>>> consumerObserveMap = new ConcurrentHashMap<>();
 
-    public AbstractProtocol(XdsChannel xdsChannel, Node node, int pollingPoolSize, int pollingTimeout) {
+    public AbstractProtocol(XdsChannel xdsChannel, Node node, int pollingTimeout) {
         this.xdsChannel = xdsChannel;
         this.node = node;
-        this.pollingExecutor = new ScheduledThreadPoolExecutor(pollingPoolSize, new NamedThreadFactory(""Dubbo-registry-xds""));
         this.pollingTimeout = pollingTimeout;
     }
 
+    protected Map<String, R> resourcesMap = new ConcurrentHashMap<>();
+
+    private CompletableFuture<T> future;
+
+    private StreamObserver<DiscoveryRequest> requestObserver;
+
     /**
      * Abstract method to obtain Type-URL from sub-class
      *
      * @return Type-URL of xDS
      */
     public abstract String getTypeUrl();
 
-    @Override
-    public T getResource(Set<String> resourceNames) {
-        long request = requestId.getAndIncrement();
-        resourceNames = resourceNames == null ? Collections.emptySet() : resourceNames;
-
-        // Store Request Parameter, which will be used for ACK
-        requestParam.put(request, resourceNames);
-
-        // create observer
-        StreamObserver<DiscoveryRequest> requestObserver = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(request));
-
-        // use future to get async result
-        CompletableFuture<T> future = new CompletableFuture<>();
-        requestObserverMap.put(request, requestObserver);
-        streamResult.put(request, future);
-
-        // send request to control panel
-        requestObserver.onNext(buildDiscoveryRequest(resourceNames));
-
-        try {
-            // get result
-            return future.get();
-        } catch (InterruptedException | ExecutionException e) {
-            logger.error(REGISTRY_ERROR_REQUEST_XDS, """", """", ""Error occur when request control panel."");
-            return null;
-        } finally {
-            // close observer
-            //requestObserver.onCompleted();
-
-            // remove temp
-            streamResult.remove(request);
-            requestObserverMap.remove(request);
-            requestParam.remove(request);
-        }
-    }
+    public abstract boolean isExistResource(Set<String> resourceNames);","[{'comment': 'Remove this abstract method. Should be handled in `AbstractProtocol`.', 'commenter': 'AlbumenJ'}]"
10885,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java,"@@ -16,182 +16,127 @@
  */
 package org.apache.dubbo.registry.xds.util.protocol;
 
+
 import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;
+
+
 import org.apache.dubbo.common.logger.LoggerFactory;
-import org.apache.dubbo.common.utils.NamedThreadFactory;
+import org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository;
 import org.apache.dubbo.registry.xds.util.XdsChannel;
-
 import io.envoyproxy.envoy.config.core.v3.Node;
 import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;
 import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;
 import io.grpc.stub.StreamObserver;
+import org.apache.dubbo.rpc.model.ApplicationModel;
 
 import java.util.Collections;
-import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.CompletableFuture;
+import java.util.List;
+import java.util.Map;
+import java.util.ArrayList;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ExecutionException;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
 import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_ERROR_REQUEST_XDS;
 
-public abstract class AbstractProtocol<T, S extends DeltaResource<T>> implements XdsProtocol<T> {
+public abstract class AbstractProtocol<T, S extends DeltaResource<T>, R> implements XdsProtocol<T> {
 
     private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(AbstractProtocol.class);
 
-    protected final XdsChannel xdsChannel;
+    protected XdsChannel xdsChannel;
 
     protected final Node node;
 
-    /**
-     * Store Request Parameter ( resourceNames )
-     * K - requestId, V - resourceNames
-     */
-    protected final Map<Long, Set<String>> requestParam = new ConcurrentHashMap<>();
-
-    /**
-     * Store ADS Request Observer ( StreamObserver in Streaming Request )
-     * K - requestId, V - StreamObserver
-     */
-    private final Map<Long, StreamObserver<DiscoveryRequest>> requestObserverMap = new ConcurrentHashMap<>();
-
-    /**
-     * Store Delta-ADS Request Observer ( StreamObserver in Streaming Request )
-     * K - requestId, V - StreamObserver
-     */
-    private final Map<Long, ScheduledFuture<?>> observeScheduledMap = new ConcurrentHashMap<>();
-
-    /**
-     * Store CompletableFuture for Request ( used to fetch async result in ResponseObserver )
-     * K - requestId, V - CompletableFuture
-     */
-    private final Map<Long, CompletableFuture<T>> streamResult = new ConcurrentHashMap<>();
+    private final int pollingTimeout;
 
-    private final ScheduledExecutorService pollingExecutor;
+    private final Object consumerObserveMapUpdate = new Object();
 
-    private final int pollingTimeout;
+    private Set<String> observeResourcesName;
 
-    protected final static AtomicLong requestId = new AtomicLong(0);
+    private final Map<Set<String>, List<Consumer<T>>> consumerObserveMap = new ConcurrentHashMap<>();
 
-    public AbstractProtocol(XdsChannel xdsChannel, Node node, int pollingPoolSize, int pollingTimeout) {
+    public AbstractProtocol(XdsChannel xdsChannel, Node node, int pollingTimeout) {
         this.xdsChannel = xdsChannel;
         this.node = node;
-        this.pollingExecutor = new ScheduledThreadPoolExecutor(pollingPoolSize, new NamedThreadFactory(""Dubbo-registry-xds""));
         this.pollingTimeout = pollingTimeout;
     }
 
+    protected Map<String, R> resourcesMap = new ConcurrentHashMap<>();
+
+    private CompletableFuture<T> future;
+
+    private StreamObserver<DiscoveryRequest> requestObserver;
+
     /**
      * Abstract method to obtain Type-URL from sub-class
      *
      * @return Type-URL of xDS
      */
     public abstract String getTypeUrl();
 
-    @Override
-    public T getResource(Set<String> resourceNames) {
-        long request = requestId.getAndIncrement();
-        resourceNames = resourceNames == null ? Collections.emptySet() : resourceNames;
-
-        // Store Request Parameter, which will be used for ACK
-        requestParam.put(request, resourceNames);
-
-        // create observer
-        StreamObserver<DiscoveryRequest> requestObserver = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(request));
-
-        // use future to get async result
-        CompletableFuture<T> future = new CompletableFuture<>();
-        requestObserverMap.put(request, requestObserver);
-        streamResult.put(request, future);
-
-        // send request to control panel
-        requestObserver.onNext(buildDiscoveryRequest(resourceNames));
-
-        try {
-            // get result
-            return future.get();
-        } catch (InterruptedException | ExecutionException e) {
-            logger.error(REGISTRY_ERROR_REQUEST_XDS, """", """", ""Error occur when request control panel."");
-            return null;
-        } finally {
-            // close observer
-            //requestObserver.onCompleted();
-
-            // remove temp
-            streamResult.remove(request);
-            requestObserverMap.remove(request);
-            requestParam.remove(request);
-        }
-    }
+    public abstract boolean isExistResource(Set<String> resourceNames);
 
-    @Override
-    public long observeResource(Set<String> resourceNames, Consumer<T> consumer) {
-        long request = requestId.getAndIncrement();
-        resourceNames = resourceNames == null ? Collections.emptySet() : resourceNames;
+    public abstract void updateResourceCollection(R resourceCollection, Set<String> resourceNames);
 
-        // Store Request Parameter, which will be used for ACK
-        requestParam.put(request, resourceNames);
-
-        // call once for full data
-        consumer.accept(getResource(resourceNames));
+    public abstract R getResourceCollection();
 
-        // channel reused
-        StreamObserver<DiscoveryRequest> requestObserver = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(request));
-        requestObserverMap.put(request, requestObserver);
+    public abstract T getDsResult(R resourceCollection);
 
-        ScheduledFuture<?> scheduledFuture = pollingExecutor.scheduleAtFixedRate(() -> {
+    public T getCacheResource(Set<String> resourceNames) {
+        R resourceCollection = getResourceCollection();
+        if (!resourceNames.isEmpty() && isExistResource(resourceNames)) {
+            updateResourceCollection(resourceCollection, resourceNames);
+        } else {
+            if (requestObserver == null) {
+                future = new CompletableFuture<>();
+                requestObserver = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(future));","[{'comment': 'remove this `future`', 'commenter': 'AlbumenJ'}, {'comment': 'Observe resource in `consumerObserveMap`', 'commenter': 'AlbumenJ'}]"
10885,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java,"@@ -248,13 +196,30 @@ private void returnResult(T result) {
 
         @Override
         public void onCompleted() {
-            logger.info(""xDS Client completed, requestId: "" + requestId);
-            clear();
-        }
-
-        private void clear() {
-            requestObserverMap.remove(requestId);
+            logger.info(""xDS Client completed"");
         }
     }
 
+    private void triggerReConnectTask() {
+        AtomicBoolean isConnectFail = new AtomicBoolean(false);
+        ScheduledExecutorService scheduledFuture = ApplicationModel.defaultModel().getFrameworkModel().getBeanFactory()
+            .getBean(FrameworkExecutorRepository.class).getSharedScheduledExecutor();","[{'comment': 'Should fetch `ApplicationModel` in contructor. `ApplicationModel.defaultModel()` is forbidden here.', 'commenter': 'AlbumenJ'}]"
10885,dubbo-xds/src/test/java/org/apache/dubbo/registry/xds/istio/IstioEnvMock.java,"@@ -0,0 +1,47 @@
+package org.apache.dubbo.registry.xds.istio;","[{'comment': 'Add ASF license header for all of the newly created files', 'commenter': 'AlbumenJ'}]"
10885,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/protocol/AbstractProtocol.java,"@@ -45,153 +42,120 @@
 
     private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(AbstractProtocol.class);
 
-    protected final XdsChannel xdsChannel;
+    protected XdsChannel xdsChannel;
 
     protected final Node node;
 
-    /**
-     * Store Request Parameter ( resourceNames )
-     * K - requestId, V - resourceNames
-     */
-    protected final Map<Long, Set<String>> requestParam = new ConcurrentHashMap<>();
+    private final int checkInterval;
 
-    /**
-     * Store ADS Request Observer ( StreamObserver in Streaming Request )
-     * K - requestId, V - StreamObserver
-     */
-    private final Map<Long, StreamObserver<DiscoveryRequest>> requestObserverMap = new ConcurrentHashMap<>();
+    private final ReentrantLock lock = new ReentrantLock();
 
-    /**
-     * Store Delta-ADS Request Observer ( StreamObserver in Streaming Request )
-     * K - requestId, V - StreamObserver
-     */
-    private final Map<Long, ScheduledFuture<?>> observeScheduledMap = new ConcurrentHashMap<>();
-
-    /**
-     * Store CompletableFuture for Request ( used to fetch async result in ResponseObserver )
-     * K - requestId, V - CompletableFuture
-     */
-    private final Map<Long, CompletableFuture<T>> streamResult = new ConcurrentHashMap<>();
+    private Set<String> observeResourcesName;
 
-    private final ScheduledExecutorService pollingExecutor;
+    private final Map<Set<String>, List<Consumer<T>>> consumerObserveMap = new ConcurrentHashMap<>();
 
-    private final int pollingTimeout;
+    private ApplicationModel applicationModel;
 
-    protected final static AtomicLong requestId = new AtomicLong(0);
-
-    public AbstractProtocol(XdsChannel xdsChannel, Node node, int pollingPoolSize, int pollingTimeout) {
+    public AbstractProtocol(XdsChannel xdsChannel, Node node, int checkInterval, ApplicationModel applicationModel) {
         this.xdsChannel = xdsChannel;
         this.node = node;
-        this.pollingExecutor = new ScheduledThreadPoolExecutor(pollingPoolSize, new NamedThreadFactory(""Dubbo-registry-xds""));
-        this.pollingTimeout = pollingTimeout;
+        this.checkInterval = checkInterval;
+        this.applicationModel = applicationModel;
     }
 
+    protected Map<String, Object> resourcesMap = new ConcurrentHashMap<>();
+
+    private StreamObserver<DiscoveryRequest> requestObserver;
+
     /**
      * Abstract method to obtain Type-URL from sub-class
      *
      * @return Type-URL of xDS
      */
     public abstract String getTypeUrl();
 
-    @Override
-    public T getResource(Set<String> resourceNames) {
-        long request = requestId.getAndIncrement();
-        resourceNames = resourceNames == null ? Collections.emptySet() : resourceNames;
-
-        // Store Request Parameter, which will be used for ACK
-        requestParam.put(request, resourceNames);
-
-        // create observer
-        StreamObserver<DiscoveryRequest> requestObserver = xdsChannel.createDeltaDiscoveryRequest(new ResponseObserver(request));
-
-        // use future to get async result
-        CompletableFuture<T> future = new CompletableFuture<>();
-        requestObserverMap.put(request, requestObserver);
-        streamResult.put(request, future);
+    public abstract T getDsResult(Set<String> resourceNames);
 
-        // send request to control panel
-        requestObserver.onNext(buildDiscoveryRequest(resourceNames));
+//    public abstract T getDsResult();
 
-        try {
-            // get result
-            return future.get();
-        } catch (InterruptedException | ExecutionException e) {
-            logger.error(REGISTRY_ERROR_REQUEST_XDS, """", """", ""Error occur when request control panel."");
-            return null;
-        } finally {
-            // close observer
-            //requestObserver.onCompleted();
-
-            // remove temp
-            streamResult.remove(request);
-            requestObserverMap.remove(request);
-            requestParam.remove(request);
+    public boolean isExistResource(Set<String> resourceNames) {
+        for (String resourceName : resourceNames) {
+            if ("""".equals(resourceName)) {","[{'comment': '```suggestion\r\n            if (StringUtils.isEmpty(resourceName)) {\r\n```', 'commenter': 'AlbumenJ'}]"
10885,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/PilotExchanger.java,"@@ -26,85 +26,81 @@
 import org.apache.dubbo.registry.xds.util.protocol.message.EndpointResult;
 import org.apache.dubbo.registry.xds.util.protocol.message.ListenerResult;
 import org.apache.dubbo.registry.xds.util.protocol.message.RouteResult;
+import org.apache.dubbo.rpc.model.ApplicationModel;
 
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
 public class PilotExchanger {
 
-    private final XdsChannel xdsChannel;
+    protected final XdsChannel xdsChannel;
 
-    private final RdsProtocol rdsProtocol;
+    protected final LdsProtocol ldsProtocol;
 
-    private final EdsProtocol edsProtocol;
+    protected final RdsProtocol rdsProtocol;
 
-    private ListenerResult listenerResult;
+    protected final EdsProtocol edsProtocol;
 
-    private RouteResult routeResult;
+    protected ListenerResult listenerResult;
 
-    private final AtomicLong observeRouteRequest = new AtomicLong(-1);
+    protected RouteResult routeResult;
 
-    private final Map<String, Long> domainObserveRequest = new ConcurrentHashMap<>();
+    private final AtomicBoolean isRdsObserve = new AtomicBoolean(false);
+    private final HashSet<String> domainObserveRequest = new HashSet<>();
 
     private final Map<String, Set<Consumer<Set<Endpoint>>>> domainObserveConsumer = new ConcurrentHashMap<>();
 
-    private PilotExchanger(URL url) {
+    protected PilotExchanger(URL url) {
         xdsChannel = new XdsChannel(url);
-        int pollingPoolSize = url.getParameter(""pollingPoolSize"", 10);
         int pollingTimeout = url.getParameter(""pollingTimeout"", 10);
-        LdsProtocol ldsProtocol = new LdsProtocol(xdsChannel, NodeBuilder.build(), pollingPoolSize, pollingTimeout);
-        this.rdsProtocol = new RdsProtocol(xdsChannel, NodeBuilder.build(), pollingPoolSize, pollingTimeout);
-        this.edsProtocol = new EdsProtocol(xdsChannel, NodeBuilder.build(), pollingPoolSize, pollingTimeout);
+        ApplicationModel applicationModel = ApplicationModel.defaultModel();","[{'comment': '```suggestion\r\n        ApplicationModel applicationModel = url.getorDefaultApplicationModel();\r\n```', 'commenter': 'AlbumenJ'}]"
10921,dubbo-common/src/main/java/org/apache/dubbo/common/URL.java,"@@ -499,8 +529,15 @@ public String getPath() {
     }
 
     public URL setPath(String path) {
-        URLAddress newURLAddress = urlAddress.setPath(path);
-        return returnURL(newURLAddress);
+        URL url;
+        if (urlAddress == null) {
+            url = new URL();
+            url.setPath(path);
+        } else {
+            URLAddress newURLAddress = urlAddress.setPath(path);
+            url = returnURL(newURLAddress);
+        }
+        return url;","[{'comment': '```suggestion\r\n        if (urlAddress == null) {\r\n            return new ServiceConfigURL(getProtocol(), getHost(), getPort(), path, getParameters());\r\n        } else {\r\n            URLAddress newURLAddress = urlAddress.setPath(path);\r\n            return returnURL(newURLAddress);\r\n        }\r\n```', 'commenter': 'AlbumenJ'}]"
10921,dubbo-common/src/main/java/org/apache/dubbo/common/URL.java,"@@ -458,12 +480,20 @@ public URL setAddress(String address) {
         } else {
             host = address;
         }
-        URLAddress newURLAddress = urlAddress.setAddress(host, port);
-        return returnURL(newURLAddress);
+        URL url;
+        if (urlAddress == null) {
+            url = new URL();
+            url.setHost(host);
+            url.setPort(port);
+        } else {
+            URLAddress newURLAddress = urlAddress.setAddress(host, port);
+            url = returnURL(newURLAddress);
+        }
+        return url;","[{'comment': '```suggestion\r\n        if (urlAddress == null) {\r\n            return new ServiceConfigURL(getProtocol(), host, port, getPath(), getParameters());\r\n        } else {\r\n            URLAddress newURLAddress = urlAddress.setAddress(host, port);\r\n            return returnURL(newURLAddress);\r\n        }\r\n```', 'commenter': 'AlbumenJ'}]"
10921,dubbo-common/src/main/java/org/apache/dubbo/common/URL.java,"@@ -435,8 +450,15 @@ public int getPort() {
     }
 
     public URL setPort(int port) {
-        URLAddress newURLAddress = urlAddress.setPort(port);
-        return returnURL(newURLAddress);
+        URL url;
+        if (urlAddress == null) {
+            url = new URL();
+            url.setPort(port);
+        } else {
+            URLAddress newURLAddress = urlAddress.setPort(port);
+            url = returnURL(newURLAddress);
+        }
+        return url;","[{'comment': '```suggestion\r\n        if (urlAddress == null) {\r\n            return new ServiceConfigURL(getProtocol(), getHost(), port, getPath(), getParameters());\r\n        } else {\r\n            URLAddress newURLAddress = urlAddress.setPort(port);\r\n            return returnURL(newURLAddress);\r\n        }\r\n```', 'commenter': 'AlbumenJ'}]"
10921,dubbo-common/src/main/java/org/apache/dubbo/common/URL.java,"@@ -425,8 +433,15 @@ public String getHost() {
     }
 
     public URL setHost(String host) {
-        URLAddress newURLAddress = urlAddress.setHost(host);
-        return returnURL(newURLAddress);
+        URL url;
+        if (urlAddress == null) {
+            url = new URL();
+            url.setHost(host);
+        } else {
+            URLAddress newURLAddress = urlAddress.setHost(host);
+            url = returnURL(newURLAddress);
+        }
+        return url;","[{'comment': '```suggestion\r\n```suggestion\r\n        if (urlAddress == null) {\r\n            return new ServiceConfigURL(getProtocol(), host, getPort(), getPath(), getParameters());\r\n        } else {\r\n            URLAddress newURLAddress = urlAddress.setHost(host);\r\n            return returnURL(newURLAddress);\r\n        }\r\n```\r\n```', 'commenter': 'AlbumenJ'}]"
10921,dubbo-common/src/main/java/org/apache/dubbo/common/URL.java,"@@ -425,8 +433,13 @@ public String getHost() {
     }
 
     public URL setHost(String host) {
-        URLAddress newURLAddress = urlAddress.setHost(host);
-        return returnURL(newURLAddress);
+```suggestion","[{'comment': 'remove this breaking line', 'commenter': 'AlbumenJ'}]"
10921,dubbo-common/src/main/java/org/apache/dubbo/common/URL.java,"@@ -367,8 +367,16 @@ public String getPassword() {
     }
 
     public URL setPassword(String password) {
-        URLAddress newURLAddress = urlAddress.setPassword(password);
-        return returnURL(newURLAddress);
+
+        URL url;
+        if (urlAddress == null) {
+            url = new URL();
+            url.setPassword(password);
+        } else {
+            URLAddress newURLAddress = urlAddress.setPassword(password);
+            url = returnURL(newURLAddress);
+        }
+        return url;","[{'comment': '```suggestion\r\n        if (urlAddress == null) {\r\n            return new ServiceConfigURL(getProtocol(), getHost(), port, getPath(), getParameters()).setPassword(password);\r\n        } else {\r\n            URLAddress newURLAddress = urlAddress.setPassword(password);\r\n            return returnURL(newURLAddress);\r\n        }\r\n```', 'commenter': 'AlbumenJ'}, {'comment': 'BTW, please fix `setUsername`, `setProtocol` and etc', 'commenter': 'AlbumenJ'}]"
10921,dubbo-common/src/main/java/org/apache/dubbo/common/URL.java,"@@ -349,26 +349,38 @@ public String getProtocol() {
     }
 
     public URL setProtocol(String protocol) {
-        URLAddress newURLAddress = urlAddress.setProtocol(protocol);
-        return returnURL(newURLAddress);
+        if (urlAddress == null) {
+            return new ServiceConfigURL(getProtocol(), getHost(), getPort(), getPath(), getParameters());","[{'comment': '```suggestion\r\n            return new ServiceConfigURL(protocol, getHost(), getPort(), getPath(), getParameters());\r\n```', 'commenter': 'AlbumenJ'}]"
10937,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java,"@@ -231,14 +231,14 @@ private void refreshInvoker(List<URL> invokerUrls) {
             }
             // use local reference to avoid NPE as this.cachedInvokerUrls will be set null by destroyAllInvokers().
             Set<URL> localCachedInvokerUrls = this.cachedInvokerUrls;
-            if (invokerUrls.isEmpty() && localCachedInvokerUrls != null) {
-
-                // 1-4 Empty address.
-                logger.warn(REGISTRY_EMPTY_ADDRESS, ""configuration "", """",
-                    ""Service"" + serviceKey + "" received empty address list with no EMPTY protocol set, trigger empty protection."");
-
-                invokerUrls.addAll(localCachedInvokerUrls);
+            if (invokerUrls.isEmpty()) {
+                if(localCachedInvokerUrls != null){
+                    // 1-4 Empty address.","[{'comment': '这个修改从代码编译后的效果上来看是一样的', 'commenter': 'AlbumenJ'}, {'comment': '> 这个修改从代码编译后的效果上来看是一样的\r\n\r\n![image](https://user-images.githubusercontent.com/16596043/201807631-2fd923ba-dcd6-4b83-98fc-fc49722d1fd1.png)\r\n\r\n![image](https://user-images.githubusercontent.com/16596043/201807800-eb744914-e6f9-4a8b-a82f-35c3b7d2dc16.png)\r\n\r\n', 'commenter': 'haoxz11'}, {'comment': '不然zk注册中心下，消费者启动会报大量告警；\r\n\r\n![image](https://user-images.githubusercontent.com/16596043/201808386-ec6dddda-6955-4272-a78a-cdbfef6f51b4.png)\r\n', 'commenter': 'haoxz11'}, {'comment': 'get', 'commenter': 'AlbumenJ'}]"
10937,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java,"@@ -231,14 +231,14 @@ private void refreshInvoker(List<URL> invokerUrls) {
             }
             // use local reference to avoid NPE as this.cachedInvokerUrls will be set null by destroyAllInvokers().
             Set<URL> localCachedInvokerUrls = this.cachedInvokerUrls;
-            if (invokerUrls.isEmpty() && localCachedInvokerUrls != null) {
-
-                // 1-4 Empty address.
-                logger.warn(REGISTRY_EMPTY_ADDRESS, ""configuration "", """",
-                    ""Service"" + serviceKey + "" received empty address list with no EMPTY protocol set, trigger empty protection."");
-
-                invokerUrls.addAll(localCachedInvokerUrls);
+            if (invokerUrls.isEmpty()) {
+                if(localCachedInvokerUrls != null){
+                    // 1-4 Empty address.
+                    logger.warn(REGISTRY_EMPTY_ADDRESS, ""configuration "", """",
+                        ""Service"" + serviceKey + "" received empty address list with no EMPTY protocol set, trigger empty protection."");
 
+                    invokerUrls.addAll(localCachedInvokerUrls);
+                }","[{'comment': '```suggestion\r\n            if (invokerUrls.isEmpty()) {\r\n                if (localCachedInvokerUrls != null && !localCachedInvokerUrls.isEmpty()) {\r\n                    // if the previous invokerUrls is not empty, warn and use the previous invokerUrls instead.\r\n                    \r\n                    // 1-4 Empty address.\r\n                    logger.warn(REGISTRY_EMPTY_ADDRESS, ""configuration "", """",\r\n                        ""Service"" + serviceKey + "" received empty address list with no EMPTY protocol set, trigger empty protection."");\r\n\r\n                    invokerUrls.addAll(localCachedInvokerUrls);\r\n                } // else, if the previous invokerUrls is empty, do nothing.\r\n            } else {\r\n                // cache if invokerUrls is not empty\r\n                localCachedInvokerUrls = new HashSet<>();\r\n                localCachedInvokerUrls.addAll(invokerUrls);//Cached invoker urls, convenient for comparison\r\n                this.cachedInvokerUrls = localCachedInvokerUrls;\r\n            }\r\n```\r\n\r\nPlease add some comment', 'commenter': 'AlbumenJ'}, {'comment': 'Agree with @AlbumenJ \r\nA small suggestion:  use `CollectionUtils.isNotEmpty` to judge empty', 'commenter': 'CrazyHZM'}]"
10941,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java,"@@ -307,9 +306,8 @@ public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, C
     }
 
     @Override
-    public PropertyValues postProcessPropertyValues(
-            PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {
-
+    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)","[{'comment': '`InstantiationAwareBeanPostProcessor#postProcessPropertyValues` removed as of Spring Framework 6.0.0, in favor of `postProcessProperties` method.', 'commenter': 'weixsun'}]"
10941,dubbo-spring-boot/dubbo-spring-boot-actuator/src/main/resources/META-INF/spring.factories,"@@ -1,2 +0,0 @@
-org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
-org.apache.dubbo.spring.boot.actuate.autoconfigure.DubboEndpointAnnotationAutoConfiguration","[{'comment': '`org.springframework.boot.autoconfigure.AutoConfiguration.imports ` is only supported after springboot 2.7.x. If this is removed, it will affect the compatibility of lower versions, so consider whether there is a way to accommodate both uses', 'commenter': 'CrazyHZM'}, {'comment': 'Done', 'commenter': 'weixsun'}]"
10941,dubbo-config/dubbo-config-spring/src/test/java/org/apache/dubbo/config/spring/EmbeddedZooKeeper.java,"@@ -83,7 +83,7 @@ public class EmbeddedZooKeeper implements SmartLifecycle {
      * Construct an EmbeddedZooKeeper with a random port.
      */
     public EmbeddedZooKeeper() {
-        clientPort = SocketUtils.findAvailableTcpPort();
+        clientPort = TestSocketUtils.findAvailableTcpPort();","[{'comment': '`SocketUtils` has been removed in Spring Framework 6.0 M3. see [spring-projects/spring-framework#28052](https://github.com/spring-projects/spring-framework/issues/28052)\r\n\r\n', 'commenter': 'weixsun'}]"
10941,.github/workflows/build-and-test-pr.yml,"@@ -53,7 +53,7 @@ jobs:
       - uses: actions/setup-java@v3
         with:
           distribution: 'zulu'
-          java-version: 8
+          java-version: 17","[{'comment': 'We want to ensure compatibility with JDK8, here should not update the jdk version, if necessary, should add a ci action', 'commenter': 'CrazyHZM'}, {'comment': 'Yeah, the reason for this is that it is the most convenient way to verify the support for Spring 6 and Spring Boot 3, and now it has been reverted.', 'commenter': 'weixsun'}]"
10941,dubbo-test/dubbo-test-common/src/main/java/org/apache/dubbo/test/common/utils/TestSocketUtils.java,"@@ -0,0 +1,109 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */","[{'comment': 'Save the origin license header if this file is copy from other repo', 'commenter': 'AlbumenJ'}, {'comment': ""it's done."", 'commenter': 'weixsun'}]"
10941,dubbo-spring-boot/dubbo-spring-boot-compatible/actuator/src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports,"@@ -0,0 +1,3 @@
+org.apache.dubbo.spring.boot.actuate.autoconfigure.DubboEndpointAutoConfiguration
+org.apache.dubbo.spring.boot.actuate.autoconfigure.DubboHealthIndicatorAutoConfiguration
+org.apache.dubbo.spring.boot.actuate.autoconfigure.DubboEndpointMetadataAutoConfiguration","[{'comment': 'I am more worried about compatibility issues in lower versions, such as version 2.7, which supports both AutoConfiguration.imports and spring.facts, whether it will be loaded twice.', 'commenter': 'CrazyHZM'}, {'comment': ""@CrazyHZM Don't worry, in Spring Boot 2.7.x, the `AutoConfiguration.imports` and `spring.factories` files will indeed be loaded at the same time, but they will all add to `Set<String> classNames`.\r\n\r\ndetails see https://github.com/spring-projects/spring-boot/commit/08022ba86efa294f77574bda07851901b6c2b520"", 'commenter': 'weixsun'}]"
10947,dubbo-common/src/main/java/org/apache/dubbo/config/RegistryConfig.java,"@@ -184,6 +184,16 @@ public class RegistryConfig extends AbstractConfig {
 
     private Boolean enableEmptyProtection;
 
+    private String secure;
+
+    public String getSecure() {
+        return secure;
+    }
+
+    public void setSecure(String secure) {
+        this.secure = secure;
+    }
+","[{'comment': 'Add definition to spring xsd', 'commenter': 'AlbumenJ'}, {'comment': 'Also add to dubbo-website', 'commenter': 'AlbumenJ'}]"
10947,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/XdsChannel.java,"@@ -55,16 +55,21 @@ protected XdsChannel(URL url) {
         ManagedChannel managedChannel = null;
         try {
             if (!url.getParameter(USE_AGENT, false)) {
-                XdsCertificateSigner signer = url.getOrDefaultApplicationModel().getExtensionLoader(XdsCertificateSigner.class)
-                    .getExtension(url.getParameter(""signer"", ""istio""));
-                XdsCertificateSigner.CertPair certPair = signer.GenerateCert(url);
-                SslContext context = GrpcSslContexts.forClient()
-                    .trustManager(InsecureTrustManagerFactory.INSTANCE)
-                    .keyManager(new ByteArrayInputStream(certPair.getPublicKey().getBytes(StandardCharsets.UTF_8)),
-                        new ByteArrayInputStream(certPair.getPrivateKey().getBytes(StandardCharsets.UTF_8)))
-                    .build();
-                managedChannel = NettyChannelBuilder.forAddress(url.getHost(), url.getPort()).sslContext(context)
-                    .build();
+                if(""plaintext"".equals(url.getParameter(""secure""))){","[{'comment': 'exact to constants', 'commenter': 'AlbumenJ'}]"
10956,dubbo-xds/src/main/java/org/apache/dubbo/rpc/cluster/router/xds/XdsScopeModelInitializer.java,"@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.xds;
+
+import org.apache.dubbo.common.beans.factory.ScopeBeanFactory;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.FrameworkModel;
+import org.apache.dubbo.rpc.model.ModuleModel;
+import org.apache.dubbo.rpc.model.ScopeModelInitializer;
+
+public class XdsScopeModelInitializer implements ScopeModelInitializer {
+
+    @Override
+    public void initializeFrameworkModel(FrameworkModel frameworkModel) {
+
+    }
+
+    @Override
+    public void initializeApplicationModel(ApplicationModel applicationModel) {
+
+    }
+
+    @Override
+    public void initializeModuleModel(ModuleModel moduleModel) {
+        ScopeBeanFactory beanFactory = moduleModel.getBeanFactory();
+        beanFactory.registerBean(RdsRouteRuleManager.class);
+        beanFactory.registerBean(EdsEndpointManager.class);","[{'comment': 'Move to application model level', 'commenter': 'AlbumenJ'}]"
10997,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/DubboMetrics.java,"@@ -0,0 +1,39 @@
+package org.apache.dubbo.metrics;","[{'comment': 'Please add ASF license header to this file', 'commenter': 'AlbumenJ'}]"
10997,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/DubboMetrics.java,"@@ -0,0 +1,39 @@
+package org.apache.dubbo.metrics;
+
+import io.micrometer.core.instrument.Gauge;
+import io.micrometer.core.instrument.MeterRegistry;
+import io.micrometer.core.instrument.binder.MeterBinder;
+import org.apache.dubbo.common.utils.NamedThreadFactory;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * @author songxiaosheng","[{'comment': 'Remove this tag, pls', 'commenter': 'AlbumenJ'}]"
10997,dubbo-spring-boot/dubbo-spring-boot-actuator/src/main/java/org/apache/dubbo/spring/boot/actuate/mertics/DubboMetricsBinder.java,"@@ -0,0 +1,31 @@
+package org.apache.dubbo.spring.boot.actuate.mertics;","[{'comment': 'Please add ASF license header to this file', 'commenter': 'AlbumenJ'}]"
10997,dubbo-spring-boot/dubbo-spring-boot-actuator/src/main/java/org/apache/dubbo/spring/boot/actuate/autoconfigure/DubboMetricsAutoConfiguration.java,"@@ -0,0 +1,29 @@
+package org.apache.dubbo.spring.boot.actuate.autoconfigure;","[{'comment': 'Please add ASF license header to this file', 'commenter': 'AlbumenJ'}]"
10997,dubbo-spring-boot/dubbo-spring-boot-actuator/src/main/java/org/apache/dubbo/spring/boot/actuate/autoconfigure/DubboMetricsAutoConfiguration.java,"@@ -0,0 +1,29 @@
+package org.apache.dubbo.spring.boot.actuate.autoconfigure;
+
+import io.micrometer.core.instrument.MeterRegistry;
+import org.apache.dubbo.metrics.DubboMetrics;
+import org.apache.dubbo.spring.boot.actuate.mertics.DubboMetricsBinder;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+
+
+/**
+ * @author songxiaosheng","[{'comment': 'remove this tag pls', 'commenter': 'AlbumenJ'}]"
11012,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/MetricsCollectExecutor.java,"@@ -88,6 +90,10 @@ private void endExecute(Supplier<Boolean> rtStat){
     private void init(Invocation invocation) {
         String serviceUniqueName = invocation.getTargetServiceUniqueName();
         String methodName = invocation.getMethodName();
+        if (invocation instanceof RpcInvocation &&
+            isGenericCall(((RpcInvocation) invocation).getParameterTypesDesc(), methodName)) {
+            methodName = (String) invocation.getArguments()[0];","[{'comment': 'Check the length of the Arguments array to prevent out-of-bounds index addresses.', 'commenter': 'CrazyHZM'}, {'comment': 'When generalizing call, the number of parameters must be 3, but it is possible for the array to be out of bounds for some unknown reasons. I will add a check to avoid it.', 'commenter': 'twz007'}, {'comment': '@CrazyHZM I solved it, please check the following.', 'commenter': 'twz007'}]"
11021,dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-provider/pom.xml,"@@ -133,6 +132,26 @@
             <artifactId>log4j</artifactId>
         </dependency>
 
+        <!-- Observability -->
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-metrics-api</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>io.micrometer</groupId>
+            <artifactId>micrometer-tracing-bridge-otel</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>io.opentelemetry</groupId>
+            <artifactId>opentelemetry-exporter-zipkin</artifactId>
+            <version>1.20.0</version>","[{'comment': 'Version should be managed in `dubbo-dependencies-bom`', 'commenter': 'AlbumenJ'}, {'comment': 'I removed that to simplify the example', 'commenter': 'marcingrzejszczak'}]"
11021,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/observation/DubboClientContext.java,"@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metrics.filter.observation;
+
+import java.util.Map;
+import java.util.Objects;
+
+import io.micrometer.observation.transport.SenderContext;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContextAttachment;
+
+/**
+ * Provider context for RPC.
+ *
+ * @author Marcin Grzejszczak","[{'comment': 'Please remove this tag due to the apache way', 'commenter': 'AlbumenJ'}]"
11021,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/observation/ObservationSenderFilter.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metrics.filter.observation;
+
+import io.micrometer.observation.Observation;
+import io.micrometer.observation.ObservationRegistry;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.rpc.BaseFilter;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcContextAttachment;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+
+/**
+ * A {@link Filter} that creates an {@link Observation} around the outgoing message.
+ *
+ * @author Marcin Grzejszczak
+ */
+@Activate(group = CONSUMER, order = -1)
+public class ObservationSenderFilter implements Filter, BaseFilter.Listener, ScopeModelAware {","[{'comment': '```suggestion\r\npublic class ObservationSenderFilter implements ClusterFilter, BaseFilter.Listener, ScopeModelAware {\r\n```', 'commenter': 'AlbumenJ'}, {'comment': 'BTW, change the spi definition to META-INF/dubbo/internal/org.apache.dubbo.rpc.cluster.filter.ClusterFilter\r\n\r\nNote: only for consumer filter', 'commenter': 'AlbumenJ'}, {'comment': 'Oops i think i did that for the other filter too', 'commenter': 'marcingrzejszczak'}]"
11021,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/observation/ObservationSenderFilter.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metrics.filter.observation;
+
+import io.micrometer.observation.Observation;
+import io.micrometer.observation.ObservationRegistry;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.rpc.BaseFilter;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcContextAttachment;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+
+/**
+ * A {@link Filter} that creates an {@link Observation} around the outgoing message.
+ *
+ * @author Marcin Grzejszczak
+ */
+@Activate(group = CONSUMER, order = -1)
+public class ObservationSenderFilter implements Filter, BaseFilter.Listener, ScopeModelAware {
+
+    private ObservationRegistry observationRegistry = ObservationRegistry.NOOP;
+
+    private DubboProviderObservationConvention providerObservationConvention = null;
+
+    @Override
+    public void setApplicationModel(ApplicationModel applicationModel) {
+        observationRegistry = applicationModel.getBeanFactory().getBean(ObservationRegistry.class);
+        providerObservationConvention = applicationModel.getBeanFactory().getBean(DubboProviderObservationConvention.class);
+    }
+
+    @Override
+    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
+        if (observationRegistry == null) {
+            return invoker.invoke(invocation);
+        }
+        RpcContextAttachment context = RpcContext.getClientAttachment();
+        DubboClientContext senderContext = new DubboClientContext(context, invoker, invocation);","[{'comment': 'A better to fetch attachment is from `invocation.getAttachments()`', 'commenter': 'AlbumenJ'}]"
11021,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/observation/ObservationSenderFilter.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metrics.filter.observation;
+
+import io.micrometer.observation.Observation;
+import io.micrometer.observation.ObservationRegistry;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.rpc.BaseFilter;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcContextAttachment;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+
+/**
+ * A {@link Filter} that creates an {@link Observation} around the outgoing message.
+ *
+ * @author Marcin Grzejszczak
+ */
+@Activate(group = CONSUMER, order = -1)","[{'comment': 'Should we split this filter into two filter? One for time span collection.(The order could be the lowest, and will be executed more early.) Another for attachment collection.(The order could be the highest, and to get all attachment set by other filters.)', 'commenter': 'AlbumenJ'}, {'comment': ""They are both connected. When we're doing an observation we need to have access to the attachments so that we mutate those. We instrument only once and the handlers will do the attachment mutation on start and on stop of the observation. Unless I'm missing sth..."", 'commenter': 'marcingrzejszczak'}]"
11021,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/observation/DefaultDubboServerObservationConvention.java,"@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metrics.filter.observation;
+
+import io.micrometer.common.KeyValues;
+
+/**
+ * Default implementation of the {@link DubboConsumerObservationConvention}.
+ */
+public class DefaultDubboServerObservationConvention extends AbstractDefaultDubboObservationConvention implements DubboConsumerObservationConvention {","[{'comment': 'Hi, I think `DefaultDubboServerObservationConvention` should implements `DubboProviderObservationConvention`, not `DubboConsumerObservationConvention`', 'commenter': 'conghuhu'}, {'comment': ""To tell you the truth I'm completely confused with how dubbo understands receiver and sender (aka client and server aka producer consumer). I think that with this setup I've managed to get proper results in Zipkin (which doesn't mean that I've done this properly)"", 'commenter': 'marcingrzejszczak'}, {'comment': 'Yes, there is no problem with the function, but it may prefer client as consumer semantically', 'commenter': 'conghuhu'}, {'comment': ""I've changed the names to `Server` and `Client` instead of `Provider` and `Consumer`"", 'commenter': 'marcingrzejszczak'}]"
11021,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/observation/DefaultDubboClientObservationConvention.java,"@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metrics.filter.observation;
+
+import io.micrometer.common.KeyValues;
+
+/**
+ * Default implementation of the {@link DubboProviderObservationConvention}.
+ */
+public class DefaultDubboClientObservationConvention extends AbstractDefaultDubboObservationConvention implements DubboProviderObservationConvention {","[{'comment': 'Hi, I think `DefaultDubboClientObservationConvention` should implements `DubboConsumerObservationConvention`, not `DubboProviderObservationConvention`', 'commenter': 'conghuhu'}]"
11021,dubbo-metrics/dubbo-metrics-api/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.rpc.cluster.filter.ClusterFilter,"@@ -0,0 +1,2 @@
+observationreceiver=org.apache.dubbo.metrics.filter.observation.ObservationReceiverFilter","[{'comment': '`ObservationReceiverFilter` is implements `Filter`, so it needs to be placed in `org.apache.dubbo.rpc.Filter`, or the ObservationReceiverFilter will not take effect.\r\nWhen I tested locally, I found that the invoke method of the filter was not called.\r\n![image](https://user-images.githubusercontent.com/56248584/211202038-64296c05-ae67-43fe-a9a5-0f6c09f55ed5.png)\r\n', 'commenter': 'conghuhu'}, {'comment': 'See the comments below I made on Filter and ClusterFilter', 'commenter': 'chickenlj'}, {'comment': 'This needs to be changed, because `ObservationReceiverFilter` is implements `Filter`.\r\nAs shown in the figure, put it in the configuration file of `org.apache.dubbo.rpc.Filter`', 'commenter': 'conghuhu'}, {'comment': '> This needs to be changed, because `ObservationReceiverFilter` is implements `Filter`. As shown in the figure, put it in the configuration file of `org.apache.dubbo.rpc.Filter`\r\n\r\nWould implementing `org.apache.dubbo.rpc.ClusterFilter` be better?', 'commenter': 'chickenlj'}, {'comment': '`org.apache.dubbo.rpc.ClusterFilter` should be applied to consumer, but `ObservationReceiverFilter` is provider.\r\nSo `ObservationReceiverFilter` shoule implement `Filter`', 'commenter': 'conghuhu'}]"
11021,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/observation/ObservationSenderFilter.java,"@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metrics.filter.observation;
+
+import io.micrometer.observation.Observation;
+import io.micrometer.observation.ObservationRegistry;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.rpc.BaseFilter;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcContextAttachment;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+
+/**
+ * A {@link Filter} that creates an {@link Observation} around the outgoing message.
+ */
+@Activate(group = CONSUMER, order = -1)
+public class ObservationSenderFilter implements ClusterFilter, BaseFilter.Listener, ScopeModelAware {","[{'comment': 'I have a question, why does `ObservationSenderFilter` implements `ClusterFilter` not `Filter`. \r\nAre there any special considerations？', 'commenter': 'conghuhu'}, {'comment': '> I have a question, why does `ObservationSenderFilter` implements `ClusterFilter` not `Filter`. Are there any special considerations？\r\n@marcingrzejszczak ', 'commenter': 'conghuhu'}, {'comment': '![image](https://user-images.githubusercontent.com/18097545/211710004-65df4943-df70-4964-83b3-aa43e5121e2c.png)\r\n\r\nAbove is how `ClusterFilter` and `Filter` work.  Most of the time, we recommend implementing `ClusterFilter` for it generates fewer instances, especially when working in a large cluster with lots of instances. Only consider implementing `Filter` when you have customized needs for different instances.', 'commenter': 'chickenlj'}, {'comment': ""ok, that's my mistake"", 'commenter': 'conghuhu'}]"
11021,dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/filter/observation/ObservationSenderFilterTest.java,"@@ -0,0 +1,65 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.filter.observation;
+
+import io.micrometer.common.KeyValues;
+import io.micrometer.core.tck.MeterRegistryAssert;
+import io.micrometer.tracing.test.simple.SpansAssert;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.assertj.core.api.BDDAssertions;
+
+class ObservationSenderFilterTest extends AbstractObservationFilterTest {
+
+    @Override
+    public SampleTestRunnerConsumer yourCode() throws Exception {
+        return (buildingBlocks, meterRegistry) -> {
+            setupConfig();
+            setupAttachments();
+
+            filter.invoke(invoker, invocation);
+
+            BDDAssertions.then(RpcContext.getClientAttachment().getAttachment(""X-B3-TraceId"")).isNotEmpty();","[{'comment': 'Unit test is error in here.\r\nI think DubboClientContext and DubboServerContext should be changed as follows: \r\n![image](https://user-images.githubusercontent.com/56248584/212853055-0c47a3b3-926b-4177-aaac-2c1a63ab0f8d.png)\r\n', 'commenter': 'conghuhu'}]"
11021,dubbo-metrics/dubbo-metrics-api/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.rpc.cluster.filter.ClusterFilter,"@@ -0,0 +1,2 @@
+observationreceiver=org.apache.dubbo.metrics.filter.observation.ObservationReceiverFilter
+observationsender=org.apache.dubbo.metrics.filter.observation.ObservationSenderFilter","[{'comment': 'I found some problems with the location of the resources folder:\r\n![image](https://user-images.githubusercontent.com/56248584/212855602-526e733b-52de-400c-8e44-9de90025b956.png)\r\n', 'commenter': 'conghuhu'}, {'comment': '```\r\n➜  dubbo-metrics git:(micrometerObservation) tree\r\n.\r\n├── dubbo-metrics-api\r\n│\xa0\xa0 ├── pom.xml\r\n│\xa0\xa0 └── src\r\n│\xa0\xa0     ├── main\r\n│\xa0\xa0     │\xa0\xa0 ├── java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0 └── org\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0     └── apache\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0         └── dubbo\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0             └── metrics\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 ├── AbstractMetricsReporterFactory.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 ├── AbstractMetricsReporter.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 ├── aggregate\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0 ├── TimeWindowCounter.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0 └── TimeWindowQuantile.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 ├── collector\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0 └── AggregateMetricsCollector.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 ├── DubboMetrics.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 ├── filter\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0 ├── MetricsCollectExecutor.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0 ├── MetricsFilter.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0 └── observation\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0     ├── AbstractDefaultDubboObservationConvention.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0     ├── DefaultDubboClientObservationConvention.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0     ├── DefaultDubboServerObservationConvention.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0     ├── DubboClientContext.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0     ├── DubboConsumerObservationConvention.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0     ├── DubboObservation.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0     ├── DubboProviderObservationConvention.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0     ├── DubboServerContext.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0     ├── ObservationReceiverFilter.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 │\xa0\xa0     └── ObservationSenderFilter.java\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                 └── service\r\n│\xa0\xa0     │\xa0\xa0 │\xa0\xa0                     └── DefaultMetricsService.java\r\n│\xa0\xa0     │\xa0\xa0 └── resources\r\n│\xa0\xa0     │\xa0\xa0     └── META-INF\r\n│\xa0\xa0     │\xa0\xa0         └── dubbo\r\n│\xa0\xa0     │\xa0\xa0             └── internal\r\n│\xa0\xa0     │\xa0\xa0                 ├── org.apache.dubbo.common.metrics.service.MetricsService\r\n│\xa0\xa0     │\xa0\xa0                 └── org.apache.dubbo.rpc.cluster.filter.ClusterFilter\r\n```\r\n\r\nThis looks good to me', 'commenter': 'marcingrzejszczak'}, {'comment': 'OK, ignore this first', 'commenter': 'conghuhu'}]"
11021,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/observation/ObservationSenderFilter.java,"@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metrics.filter.observation;
+
+import io.micrometer.observation.Observation;
+import io.micrometer.observation.ObservationRegistry;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.rpc.BaseFilter;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcContextAttachment;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+
+/**
+ * A {@link Filter} that creates an {@link Observation} around the outgoing message.
+ */
+@Activate(group = CONSUMER, order = -1)
+public class ObservationSenderFilter implements ClusterFilter, BaseFilter.Listener, ScopeModelAware {
+
+    private ObservationRegistry observationRegistry = ObservationRegistry.NOOP;
+
+    private DubboClientObservationConvention clientObservationConvention = null;
+
+    @Override
+    public void setApplicationModel(ApplicationModel applicationModel) {
+        observationRegistry = applicationModel.getBeanFactory().getBean(ObservationRegistry.class);
+        clientObservationConvention = applicationModel.getBeanFactory().getBean(DubboClientObservationConvention.class);
+    }","[{'comment': '```suggestion\r\n    public ObservationSenderFilter(ApplicationModel applicationModel) {\r\n        observationRegistry = applicationModel.getBeanFactory().getBean(ObservationRegistry.class);\r\n        clientObservationConvention = applicationModel.getBeanFactory().getBean(DubboClientObservationConvention.class);\r\n    }\r\n```\r\n\r\nUse constructor instead is better, which can prevent NPE in initial.\r\n\r\nBTW, as for test, you can use `ApplicationModel.defaultModel()` for test purpose. `defaultModel` is only for test or compatible purpose and should be prevented to being used for production code.', 'commenter': 'AlbumenJ'}]"
11021,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/observation/DubboClientContext.java,"@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metrics.filter.observation;
+
+import java.util.Objects;
+
+import io.micrometer.observation.transport.SenderContext;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcContextAttachment;
+
+/**
+ * Provider context for RPC.
+ */
+public class DubboClientContext extends SenderContext<RpcContextAttachment> {
+
+    private final RpcContextAttachment rpcContextAttachment;
+
+    private final Invoker<?> invoker;
+
+    private final Invocation invocation;
+
+    public DubboClientContext(RpcContextAttachment rpcContextAttachment, Invoker<?> invoker, Invocation invocation) {
+        super((map, key, value) -> Objects.requireNonNull(map).setAttachment(key, value));
+        this.rpcContextAttachment = rpcContextAttachment;
+        this.invoker = invoker;
+        this.invocation = invocation;
+        setCarrier(rpcContextAttachment);
+    }","[{'comment': '```suggestion\r\n    public DubboClientContext(Invoker<?> invoker, Invocation invocation) {\r\n        super((map, key, value) -> Objects.requireNonNull(map).setAttachment(key, value));\r\n        this.invoker = invoker;\r\n        this.invocation = invocation;\r\n        setCarrier(invocation);\r\n    }\r\n```\r\n\r\nDirectly set attachments, which can be send to remote, by `invocation.setAttachment`. `RpcContextAttachment` is design as a user-mode API, not for framework itself.', 'commenter': 'AlbumenJ'}]"
11021,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/filter/observation/AbstractDefaultDubboObservationConvention.java,"@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metrics.filter.observation;
+
+import io.micrometer.common.KeyValues;
+import io.micrometer.common.docs.KeyName;
+import io.micrometer.common.lang.Nullable;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.RpcContextAttachment;
+
+import static org.apache.dubbo.metrics.filter.observation.DubboObservation.LowCardinalityKeyNames.NET_PEER_NAME;
+import static org.apache.dubbo.metrics.filter.observation.DubboObservation.LowCardinalityKeyNames.NET_PEER_PORT;
+import static org.apache.dubbo.metrics.filter.observation.DubboObservation.LowCardinalityKeyNames.RPC_METHOD;
+import static org.apache.dubbo.metrics.filter.observation.DubboObservation.LowCardinalityKeyNames.RPC_SERVICE;
+import static org.apache.dubbo.metrics.filter.observation.DubboObservation.LowCardinalityKeyNames.RPC_SYSTEM;
+
+class AbstractDefaultDubboObservationConvention {
+    KeyValues getLowCardinalityKeyValues(Invocation invocation, RpcContextAttachment rpcContextAttachment) {
+        KeyValues keyValues = KeyValues.of(RPC_SYSTEM.withValue(""apache_dubbo""));
+        String serviceName = StringUtils.hasText(invocation.getServiceName()) ? invocation.getServiceName() : readServiceName(invocation.getTargetServiceUniqueName());
+        keyValues = appendNonNull(keyValues, RPC_SERVICE, serviceName);
+        keyValues = appendNonNull(keyValues, RPC_METHOD, invocation.getMethodName());
+        keyValues = appendNonNull(keyValues, NET_PEER_NAME, rpcContextAttachment.getRemoteHostName());
+        if (rpcContextAttachment.getRemotePort() == 0) {
+            return keyValues;
+        }
+        int port = rpcContextAttachment.getRemotePort() != 0 ? rpcContextAttachment.getRemotePort() : rpcContextAttachment.getLocalPort();
+        return appendNonNull(keyValues, NET_PEER_PORT, String.valueOf(port));
+    }
+
+    private KeyValues appendNonNull(KeyValues keyValues, KeyName keyName, @Nullable String value) {
+        if (value != null) {
+            return keyValues.and(keyName.withValue(value));
+        }
+        return keyValues;
+    }
+
+    String getContextualName(Invocation invocation, RpcContextAttachment rpcContextAttachment) {
+        String serviceName = StringUtils.hasText(invocation.getServiceName()) ? invocation.getServiceName() : readServiceName(invocation.getTargetServiceUniqueName());
+        String method = StringUtils.hasText(rpcContextAttachment.getMethodName()) ? rpcContextAttachment.getMethodName() : invocation.getMethodName();
+        return serviceName + ""/"" + method;
+    }","[{'comment': '`Invocation` would be a higher priority. Can ignore `rpcContextAttachment` here.', 'commenter': 'AlbumenJ'}]"
11023,dubbo-test/dubbo-test-integration/dubbo-integration-provider/pom.xml,"@@ -0,0 +1,133 @@
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the ""License""); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+  -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>org.apache.dubbo</groupId>
+        <artifactId>dubbo-test-integration</artifactId>
+        <version>${revision}</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
+    <artifactId>dubbo-integration-provider</artifactId>
+    <packaging>jar</packaging>
+    <name>${project.artifactId}</name>
+    <description>The integration provider module of dubbo project</description>
+    <properties>","[{'comment': 'Was it better to move this test to apache/dubbo-samples?', 'commenter': 'AlbumenJ'}, {'comment': ""`dubbo-demo` is for users while `dubbo-test` is for maintainers. \r\n\r\nIn this PR,`dubbo-demo` has been tailored for demonstrasting purpose with each module focusing on one use case. For`dubbo-test`, it is ok for us to add some more complicated use cases to validate changes, it's much cheaper for maintainers to verify changes than running from a separate repo. "", 'commenter': 'chickenlj'}]"
11038,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -180,23 +179,22 @@ public void doUnregister(final URL url) {
 
     @Override
     public void doSubscribe(final URL url, final NotifyListener listener) {
-        NacosAggregateListener nacosAggregateListener = new NacosAggregateListener(listener);
-        originToAggregateListener.computeIfAbsent(url, k -> new ConcurrentHashMap<>()).put(listener, nacosAggregateListener);
-
-        Set<String> serviceNames = getServiceNames(url, nacosAggregateListener);
+        Set<String> serviceNames = getServiceNames(url, listener);
 
         //Set corresponding serviceNames for easy search later
         if (isServiceNamesWithCompatibleMode(url)) {
             for (String serviceName : serviceNames) {
                 NacosInstanceManageUtil.setCorrespondingServiceNames(serviceName, serviceNames);
             }
         }
-        doSubscribe(url, nacosAggregateListener, serviceNames);
+
+        doSubscribe(url, listener, serviceNames);
     }
 
-    private void doSubscribe(final URL url, final NacosAggregateListener listener, final Set<String> serviceNames) {
+    private void doSubscribe(final URL url, final NotifyListener listener, final Set<String> serviceNames) {
         execute(namingService -> {
             if (isServiceNamesWithCompatibleMode(url)) {
+                List<Instance> allCorrespondingInstanceList = Lists.newArrayList();","[{'comment': 'Please remove guava usage', 'commenter': 'AlbumenJ'}, {'comment': '已修改', 'commenter': 'hujun-w-2'}]"
11051,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/LocalHostPermitHandler.java,"@@ -16,33 +16,81 @@
  */
 package org.apache.dubbo.qos.server.handler;
 
-import org.apache.dubbo.qos.common.QosConstants;
-
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
+import org.apache.dubbo.common.utils.CIDRUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.qos.common.QosConstants;
 
+import java.net.InetAddress;
 import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.function.Predicate;
 
 public class LocalHostPermitHandler extends ChannelHandlerAdapter {","[{'comment': 'Pls rename this class', 'commenter': 'AlbumenJ'}, {'comment': 'Renamed.', 'commenter': 'Koooooo-7'}]"
11051,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/LocalHostPermitHandler.java,"@@ -16,33 +16,81 @@
  */
 package org.apache.dubbo.qos.server.handler;
 
-import org.apache.dubbo.qos.common.QosConstants;
-
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
+import org.apache.dubbo.common.utils.CIDRUtils;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.apache.dubbo.qos.common.QosConstants;
 
+import java.net.InetAddress;
 import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.function.Predicate;
 
 public class LocalHostPermitHandler extends ChannelHandlerAdapter {
 
     // true means to accept foreign IP
     private  boolean acceptForeignIp;
 
-    public LocalHostPermitHandler(boolean acceptForeignIp) {
+    // the whitelist of foreign IP when acceptForeignIp = false, the delimiter is colon(,)
+    // support specific ip and an ip range from CIDR specification
+    private String acceptForeignIpWhitelist;
+    private Predicate<String> whitelistPredicate = foreignIp -> false;
+
+    public LocalHostPermitHandler(boolean acceptForeignIp, String foreignIpWhitelist) {
         this.acceptForeignIp = acceptForeignIp;
+        this.acceptForeignIpWhitelist = foreignIpWhitelist;
+        if (StringUtils.isNotEmpty(foreignIpWhitelist)) {
+            whitelistPredicate = Arrays.stream(foreignIpWhitelist.split("",""))
+                .map(String::trim)
+                .filter(StringUtils::isNotEmpty)
+                .map(item -> (Predicate<String>) (foreignIp) -> {
+                    try {
+                        if (!item.contains(""/"")) {
+                            return StringUtils.isEquals(item, foreignIp);
+                        }
+                        return new CIDRUtils(item).isInRange(foreignIp);","[{'comment': 'use `org.apache.dubbo.common.utils.NetUtils#matchIpExpression`', 'commenter': 'AlbumenJ'}, {'comment': 'Updated, a tricky part, hard code port to -1.', 'commenter': 'Koooooo-7'}]"
11063,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvoker.java,"@@ -29,11 +29,9 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
+import java.util.concurrent.*;","[{'comment': 'Please fix code style', 'commenter': 'CrazyHZM'}, {'comment': 'done', 'commenter': 'zeusbee'}]"
11063,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvoker.java,"@@ -83,26 +81,29 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L
             }
             RpcContext.getServiceContext().setInvokers((List) selected);
             final AtomicInteger count = new AtomicInteger();
-            final BlockingQueue<Object> ref = new LinkedBlockingQueue<>(1);
-            for (final Invoker<T> invoker : selected) {
+            final CountDownLatch countDownLatch = new CountDownLatch(1);
+            AtomicReference<Object> result = new AtomicReference<>();
+            selected.forEach(invoker -> {","[{'comment': 'It looks like `CompletableFuture.anyOf` can satisfy this requirement.', 'commenter': 'CrazyHZM'}, {'comment': '> \r\n\r\ni think so', 'commenter': 'EarthChen'}, {'comment': 'need consider  exception case\r\nn provider  first n-1 exceptions need to be ignored', 'commenter': 'zeusbee'}]"
11063,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvoker.java,"@@ -83,28 +85,31 @@ public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, L
             }
             RpcContext.getServiceContext().setInvokers((List) selected);
             final AtomicInteger count = new AtomicInteger();
-            final BlockingQueue<Object> ref = new LinkedBlockingQueue<>(1);
-            for (final Invoker<T> invoker : selected) {
+            final CountDownLatch countDownLatch = new CountDownLatch(1);
+            AtomicReference<Object> result = new AtomicReference<>();","[{'comment': 'What is the advantage of changing LinkedBlockingQueue to CountDownLatch and AtomicReference?', 'commenter': 'CrazyHZM'}, {'comment': 'The expression is different. Theoretically, the performance is the same', 'commenter': 'zeusbee'}, {'comment': 'If there is no gain, my suggestion is to not change this part.\r\n', 'commenter': 'CrazyHZM'}, {'comment': '> If there is no gain, my suggestion is to not change this part.\r\n\r\ndone', 'commenter': 'zeusbee'}]"
11076,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/annotation/Cmd.java,"@@ -55,4 +58,57 @@
      * @return command order in help
      */
     int sort() default 0;
+
+    /**
+     * Command required access permission level
+     *
+     * @return command permission level
+     */
+    PermissionLevel requiredPermissionLevel() default PermissionLevel.PROTECTED;
+
+    enum PermissionLevel {
+        /**
+         * the lowest permission level, can access with
+         * anonymousAccessPermissionLevel=PUBLIC / anonymousAccessPermissionLevel=1 or higher
+         */
+        PUBLIC(1),
+        /**
+         * the middle permission level, default permission for each cmd
+         */
+        PROTECTED(2),
+        /**
+         * the highest permission level, suppose only the localhost can access this command
+         */
+        PRIVATE(3),
+
+        /**
+         * It is the reserved default anonymous permission level, can not access any command
+         */
+        NONE(Integer.MIN_VALUE),
+
+        ;
+        private final int level;
+","[{'comment': 'Move out as a public class', 'commenter': 'AlbumenJ'}, {'comment': 'updated.', 'commenter': 'Koooooo-7'}]"
11076,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultAnonymousAccessPermissionChecker.java,"@@ -0,0 +1,28 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.qos.command;
+
+import org.apache.dubbo.qos.command.annotation.Cmd;
+
+public class DefaultAnonymousAccessPermissionChecker implements PermissionChecker {
+    public static final DefaultAnonymousAccessPermissionChecker INSTANCE = new DefaultAnonymousAccessPermissionChecker();
+
+    @Override
+    public boolean access(CommandContext commandContext, Cmd.PermissionLevel defaultCmdRequiredPermissionLevel) {
+        return commandContext.hasPermission(defaultCmdRequiredPermissionLevel);
+    }
+}","[{'comment': 'Is it really necessary to create this class separately.', 'commenter': 'AlbumenJ'}, {'comment': 'I suppose the `PermissionChecker` is an extension point  to allow user custom the permission check function if necessary. ', 'commenter': 'Koooooo-7'}, {'comment': 'Add `qosPermissionChecker ` as extension key.', 'commenter': 'Koooooo-7'}]"
11076,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java,"@@ -116,6 +118,7 @@ private void startQosServer(URL url) {
             int port = url.getParameter(QOS_PORT, QosConstants.DEFAULT_PORT);
             boolean acceptForeignIp = Boolean.parseBoolean(url.getParameter(ACCEPT_FOREIGN_IP, ""false""));
             String acceptForeignIpWhitelist = url.getParameter(ACCEPT_FOREIGN_IP_WHITELIST, StringUtils.EMPTY_STRING);
+            String anonymousAccessPermissionLevel = url.getParameter(ANONYMOUS_ACCESS_PERMISSION_LEVEL, PermissionLevel.NONE.name());","[{'comment': 'Default level could be public.', 'commenter': 'AlbumenJ'}, {'comment': 'updated.', 'commenter': 'Koooooo-7'}]"
11084,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/service/TriBuiltinService.java,"@@ -67,6 +74,11 @@ public void init() {
         }
     }
 
+    public boolean enable(){
+        return config.getBoolean(TRI_BUILTIN_SERVICE_INIT, false);","[{'comment': 'Can we check if users has add the `protobuf-java` dependency?', 'commenter': 'AlbumenJ'}, {'comment': 'First of all, we do not know the real whole sets of versions that works fine, and in the future as protobuf-java update, we may need hava a glance at this; on the other hand, i think give the load permissions to user is a better choice.', 'commenter': 'wlazjr'}]"
11088,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeHandler.java,"@@ -82,15 +87,31 @@ void handleRequest(final ExchangeChannel channel, Request req) throws RemotingEx
         Response res = new Response(req.getId(), req.getVersion());
         if (req.isBroken()) {
             Object data = req.getData();
+            Throwable error = req.getError();
 
             String msg;
             if (data == null) {
                 msg = null;
-            } else if (data instanceof Throwable) {
-                msg = StringUtils.toString((Throwable) data);
             } else {
                 msg = data.toString();
             }
+
+            if (error != null) {
+                msg = StringUtils.toString(error);
+                // Give ExceptionProcessors a chance to retry request handle or custom exception information.
+                String exPs = ApplicationModel.defaultModel().getCurrentConfig().getParameters().get(EXCEPTION_PROCESSOR_KEY);
+                if (StringUtils.isNotBlank(exPs)) {
+                    ExtensionLoader<ExceptionProcessor> extensionLoader = ApplicationModel.defaultModel().getDefaultModule().getExtensionLoader(ExceptionProcessor.class);
+                    ExceptionProcessor expProcessor = extensionLoader.getOrDefaultExtension(exPs);","[{'comment': 'Prevent use `ApplicationModel.defaultModel()` here.', 'commenter': 'AlbumenJ'}, {'comment': 'use System.getProperty instead', 'commenter': 'wxbty'}]"
11088,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcInvocation.java,"@@ -85,23 +91,68 @@ public DecodeableRpcInvocation(FrameworkModel frameworkModel, Channel channel, R
         this.request = request;
         this.inputStream = is;
         this.serializationType = id;
-        this.callbackServiceCodecFactory = CacheableSupplier.newSupplier(()->
+        this.callbackServiceCodecFactory = CacheableSupplier.newSupplier(() ->
             new CallbackServiceCodec(frameworkModel));
     }
 
+
+    public ObjectInput getObjectInput() {
+        return objectInput;
+    }
+
+    public void setObjectInput(ObjectInput objectInput) {
+        this.objectInput = objectInput;
+    }
+
     @Override
     public void decode() throws Exception {
+        boolean finishDecode = false;
         if (!hasDecoded && channel != null && inputStream != null) {
             try {
                 decode(channel, inputStream);
+                finishDecode = true;
             } catch (Throwable e) {
-                if (log.isWarnEnabled()) {
+                if (log.isWarnEnabled() && !(e instanceof ServiceNotFoundException)) {
                     log.warn(PROTOCOL_FAILED_DECODE, """", """", ""Decode rpc invocation failed: "" + e.getMessage(), e);
                 }
                 request.setBroken(true);
-                request.setData(e);
+                request.setError(e);
             } finally {
                 hasDecoded = true;
+                if (finishDecode) {
+                    ObjectInput in = getObjectInput();
+                    if (in instanceof Cleanable) {
+                        ((Cleanable) in).cleanup();
+                    }
+                }
+                // Whether the process ends normally or abnormally (retry at most once), resources must be released
+            }
+        }
+    }
+
+    @Override
+    public void retry() {
+
+        String exPs = ApplicationModel.defaultModel().getCurrentConfig().getParameters().get(EXCEPTION_PROCESSOR_KEY);","[{'comment': '`DecodeableRpcInvocation` here is a framework level class, and cannot get application model here.', 'commenter': 'AlbumenJ'}]"
11088,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeHandler.java,"@@ -82,15 +87,31 @@ void handleRequest(final ExchangeChannel channel, Request req) throws RemotingEx
         Response res = new Response(req.getId(), req.getVersion());
         if (req.isBroken()) {
             Object data = req.getData();
+            Throwable error = req.getError();
 
             String msg;
             if (data == null) {
                 msg = null;
-            } else if (data instanceof Throwable) {
-                msg = StringUtils.toString((Throwable) data);
             } else {
                 msg = data.toString();
             }
+
+            if (error != null) {
+                msg = StringUtils.toString(error);
+                // Give ExceptionProcessors a chance to retry request handle or custom exception information.
+                String exPs = System.getProperty(EXCEPTION_PROCESSOR_KEY);
+                if (StringUtils.isNotBlank(exPs)) {
+                    ExtensionLoader<ExceptionProcessor> extensionLoader = ApplicationModel.defaultModel().getDefaultModule().getExtensionLoader(ExceptionProcessor.class);
+                    ExceptionProcessor expProcessor = extensionLoader.getOrDefaultExtension(exPs);
+                    boolean handleError = expProcessor.shouldHandleError(error);
+                    if (handleError) {
+                        // Allow to custom error message, return directly
+                        // Or interrupt, reHandle the process, process req, and continue to return normal information
+                        msg = Optional.ofNullable(expProcessor.wrapAndHandleException(channel, req)).orElse(msg);","[{'comment': 'Is it necessary to add catch here? There will be non-RetryHandleException leaks.', 'commenter': 'mytang0'}, {'comment': 'RetryHandleException will be thrown up and caught here in DecodeHandler, which is specially designed\r\n\r\n```java\r\npublic void received(Channel channel, Object message) throws RemotingException {\r\n    doRecveived(message);\r\n    try {\r\n        handler.received(channel, message);\r\n    } catch (RetryHandleException e) {\r\n        if (message instanceof Request) {\r\n            Request request = (Request) message;\r\n            retry(request.getData());\r\n        } else {\r\n            // Retry only once, and only Request will throw an RetryHandleException\r\n            throw new RemotingException(channel, ""Unknown error encountered when retry handle: "" + e.getMessage());\r\n        }\r\n        handler.received(channel, message);\r\n    }\r\n}\r\n```\r\n\r\n\r\n', 'commenter': 'wxbty'}]"
11088,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/DecodeHandler.java,"@@ -38,19 +39,33 @@ public DecodeHandler(ChannelHandler handler) {
 
     @Override
     public void received(Channel channel, Object message) throws RemotingException {
+        doRecveived(message);
+
+
+        try {
+            handler.received(channel, message);
+        } catch (RetryHandleException e) {
+            if (message instanceof Request) {
+                Request request = (Request) message;
+                retry(request.getData());","[{'comment': 'The catch problem is the same as above', 'commenter': 'mytang0'}]"
11088,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/DecodeHandler.java,"@@ -38,19 +39,33 @@ public DecodeHandler(ChannelHandler handler) {
 
     @Override
     public void received(Channel channel, Object message) throws RemotingException {
+        doRecveived(message);
+
+
+        try {
+            handler.received(channel, message);
+        } catch (RetryHandleException e) {
+            if (message instanceof Request) {
+                Request request = (Request) message;
+                retry(request.getData());
+            } else {
+                // Retry only once, and only Request will throw an RetryHandleException
+                throw new RemotingException(channel, ""Unknown error encountered when retry handle: "" + e.getMessage());
+            }
+            handler.received(channel, message);","[{'comment': ""Should 'retry once handler.received' be part of the retry implementation, rather than a separate public part."", 'commenter': 'mytang0'}, {'comment': ""I don't quite understand what you mean, is there any hidden danger here?"", 'commenter': 'wxbty'}]"
11088,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/ExceptionProcessor.java,"@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.remoting;
+
+import org.apache.dubbo.common.extension.SPI;
+import org.apache.dubbo.remoting.exchange.ExchangeChannel;
+import org.apache.dubbo.remoting.exchange.Request;
+
+import java.util.Map;
+
+/**
+ * <p>Interface for handling exceptions in specific spi-extended classes.
+ *
+ * <p>Mainly works in the decode phase {@link Decodeable#decode()},
+ * and can only handle exception types in this phase.
+ *
+ * <p>Allow three kinds of customized operations, customize abnormal results and return,
+ * customize normal results and return, interrupt and retry the process.
+ *
+ * @since 3.2.0
+ */
+@SPI","[{'comment': '```suggestion\r\n@SPI(scope = FRAMEWORK)\r\n```', 'commenter': 'AlbumenJ'}]"
11088,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeHandler.java,"@@ -82,15 +87,31 @@ void handleRequest(final ExchangeChannel channel, Request req) throws RemotingEx
         Response res = new Response(req.getId(), req.getVersion());
         if (req.isBroken()) {
             Object data = req.getData();
+            Throwable error = req.getError();
 
             String msg;
             if (data == null) {
                 msg = null;
-            } else if (data instanceof Throwable) {
-                msg = StringUtils.toString((Throwable) data);
             } else {
                 msg = data.toString();
             }
+
+            if (error != null) {
+                msg = StringUtils.toString(error);
+                // Give ExceptionProcessors a chance to retry request handle or custom exception information.
+                String exPs = System.getProperty(EXCEPTION_PROCESSOR_KEY);
+                if (StringUtils.isNotBlank(exPs)) {
+                    ExtensionLoader<ExceptionProcessor> extensionLoader = ApplicationModel.defaultModel().getDefaultModule().getExtensionLoader(ExceptionProcessor.class);","[{'comment': '```suggestion\r\n                    ExtensionLoader<ExceptionProcessor> extensionLoader = channel.getUrl().getOrDefaultFrameworkMode().getExtensionLoader(ExceptionProcessor.class);\r\n```', 'commenter': 'AlbumenJ'}]"
11088,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/Request.java,"@@ -41,6 +41,9 @@ public class Request {
 
     private Object mData;
 
+    private Throwable mError;
+
+","[{'comment': 'Can we reuse data for error purpose', 'commenter': 'AlbumenJ'}, {'comment': 'When an SNF exception occurs, we need to store the decoded content in the request object, and store the error tag at the same time. At this time, only one field may be troublesome.  If can solve this problem, we can reuse.\r\n\r\n```java\r\ntry {\r\n    handler.received(channel, message);\r\n} catch (RetryHandleException e) {\r\n    if (message instanceof Request) {\r\n        Request request = (Request) message;\r\n        retry(request.getData()); //Here  requires partially decoded content\r\n    } else {\r\n        throw new RemotingException(channel, ""Unknown error encountered when retry handle: "" + e.getMessage());\r\n    }\r\n    handler.received(channel, message);\r\n}\r\n```\r\n\r\n\r\n', 'commenter': 'wxbty'}, {'comment': 'Removed the merror field.  PTAL', 'commenter': 'wxbty'}]"
11088,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java,"@@ -152,12 +154,31 @@ protected Object decodeBody(Channel channel, InputStream is, byte[] header) thro
                 } else {
                     req = new HeartBeatRequest(id);
                     DecodeableRpcInvocation inv;
+                    String exPs = System.getProperty(EXCEPTION_PROCESSOR_KEY);
+                    boolean existExpHandler = false;
+                    ExtensionLoader<ExceptionProcessor> extensionLoader;
+                    ExceptionProcessor expProcessor = null;
+                    if (StringUtils.isNotBlank(exPs)) {
+                        existExpHandler = true;
+                        extensionLoader = channel.getUrl().getApplicationModel().getExtensionLoader(ExceptionProcessor.class);","[{'comment': '```suggestion\r\n                        extensionLoader = channel.getUrl().getFrameworkModel().getExtensionLoader(ExceptionProcessor.class);\r\n```', 'commenter': 'AlbumenJ'}, {'comment': 'channel.getUrl() does not have a getApplicationModel method, use getOrDefault instead', 'commenter': 'wxbty'}]"
11088,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/ExceptionProcessor.java,"@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.dubbo;
+
+import org.apache.dubbo.common.extension.SPI;
+import org.apache.dubbo.remoting.Channel;
+import org.apache.dubbo.remoting.Decodeable;
+import org.apache.dubbo.remoting.exchange.Request;
+import org.apache.dubbo.rpc.model.FrameworkModel;
+
+import java.io.InputStream;
+
+import static org.apache.dubbo.common.extension.ExtensionScope.FRAMEWORK;
+
+/**
+ * <p>Interface for custom decoding logic in specific spi-extended classes.
+ *
+ * <p>Mainly works in decode phase {@link Decodeable#decode()},
+ * and can only handle exception types in this phase.
+ *
+ *
+ * @since 3.2.0
+ */
+@SPI(scope = FRAMEWORK)
+public interface ExceptionProcessor {
+
+    /**
+     *  Get an enhanced DecodeableRpcInvocation subclass to allow custom decode.
+     *  The parameters are the same as {@link DecodeableRpcInvocation}
+     */
+    DecodeableRpcInvocation getRetryDecodeableRpcInvocation(FrameworkModel frameworkModel, Channel channel, Request req, InputStream is, byte proto);","[{'comment': '```suggestion\r\n    DecodeableRpcInvocation getRetryDecodeableRpcInvocation(Channel channel, Request req, InputStream is, byte proto);\r\n```\r\n`frameworkModel` here is useless. ExceptionProcessor itself is a framework model SPI.', 'commenter': 'AlbumenJ'}, {'comment': 'indeed', 'commenter': 'wxbty'}]"
11088,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java,"@@ -152,12 +154,31 @@ protected Object decodeBody(Channel channel, InputStream is, byte[] header) thro
                 } else {
                     req = new HeartBeatRequest(id);
                     DecodeableRpcInvocation inv;
+                    String exPs = System.getProperty(EXCEPTION_PROCESSOR_KEY);
+                    boolean existExpHandler = false;
+                    ExtensionLoader<ExceptionProcessor> extensionLoader;
+                    ExceptionProcessor expProcessor = null;
+                    if (StringUtils.isNotBlank(exPs)) {
+                        existExpHandler = true;
+                        extensionLoader = channel.getUrl().getOrDefaultFrameworkModel().getExtensionLoader(ExceptionProcessor.class);
+                        expProcessor = extensionLoader.getOrDefaultExtension(exPs);
+                    }
+","[{'comment': 'Cached in constructor to prevent performance hit', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'wxbty'}]"
11088,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java,"@@ -73,10 +75,13 @@ public class DubboCodec extends ExchangeCodec {
     private static final AtomicBoolean decodeInUserThreadLogged = new AtomicBoolean(false);
     private final CallbackServiceCodec callbackServiceCodec;
     private final FrameworkModel frameworkModel;
+    private ByteAccessor customByteAccessor;
 
     public DubboCodec(FrameworkModel frameworkModel) {
         this.frameworkModel = frameworkModel;
         callbackServiceCodec = new CallbackServiceCodec(frameworkModel);
+        Optional.ofNullable(System.getProperty(BYTE_ACCESSOR_KEY))
+            .ifPresent(spiKey -> customByteAccessor = frameworkModel.getExtensionLoader(ByteAccessor.class).getOrDefaultExtension(spiKey));","[{'comment': '```suggestion\r\n        customByteAccessor = Optional.ofNullable(System.getProperty(BYTE_ACCESSOR_KEY))\r\n            .filter(StringUtils::isNotBlank)\r\n            .map(key -> frameworkModel.getExtensionLoader(ByteAccessor.class).getExtension(key))\r\n            .orElse(null);\r\n```', 'commenter': 'AlbumenJ'}]"
11094,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java,"@@ -118,46 +118,88 @@ private URL configureDeprecated(URL url) {
 
     private URL configureIfMatch(String host, URL url) {
         if (ANYHOST_VALUE.equals(configuratorUrl.getHost()) || host.equals(configuratorUrl.getHost())) {
-            // TODO, to support wildcards
-            String providers = configuratorUrl.getParameter(OVERRIDE_PROVIDERS_KEY);
-            if (StringUtils.isEmpty(providers) || providers.contains(url.getAddress()) || providers.contains(ANYHOST_VALUE)) {
-                String configApplication = configuratorUrl.getApplication(configuratorUrl.getUsername());
-                String currentApplication = url.getApplication(url.getUsername());
-                if (configApplication == null || ANY_VALUE.equals(configApplication)
-                        || configApplication.equals(currentApplication)) {
-                    Set<String> conditionKeys = new HashSet<String>();
-                    conditionKeys.add(CATEGORY_KEY);
-                    conditionKeys.add(Constants.CHECK_KEY);
-                    conditionKeys.add(DYNAMIC_KEY);
-                    conditionKeys.add(ENABLED_KEY);
-                    conditionKeys.add(GROUP_KEY);
-                    conditionKeys.add(VERSION_KEY);
-                    conditionKeys.add(APPLICATION_KEY);
-                    conditionKeys.add(SIDE_KEY);
-                    conditionKeys.add(CONFIG_VERSION_KEY);
-                    conditionKeys.add(COMPATIBLE_CONFIG_KEY);
-                    conditionKeys.add(INTERFACES);
-                    for (Map.Entry<String, String> entry : configuratorUrl.getParameters().entrySet()) {
-                        String key = entry.getKey();
-                        String value = entry.getValue();
-                        boolean startWithTilde = startWithTilde(key);
-                        if (startWithTilde || APPLICATION_KEY.equals(key) || SIDE_KEY.equals(key)) {
-                            if (startWithTilde) {
-                                conditionKeys.add(key);
-                            }
-                            if (value != null && !ANY_VALUE.equals(value)
-                                    && !value.equals(url.getParameter(startWithTilde ? key.substring(1) : key))) {
-                                return url;
-                            }
+            if (isV27ConditionMatchOrUnset(url)) {
+                Set<String> conditionKeys = genConditionKeys();
+                String apiVersion = configuratorUrl.getParameter(CONFIG_VERSION_KEY);
+                if (""v3.0"".equals(apiVersion)) {","[{'comment': 'The version should be judged to be ≥3.0, not equal to 3.0, which will cause problems with later versions, such as 4.0...', 'commenter': 'CrazyHZM'}]"
11094,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AbstractStateRouter.java,"@@ -83,7 +87,7 @@ public StateRouter<T> getNextRouter() {
 
     @Override
     public void notify(BitList<Invoker<T>> invokers) {
-        // default empty implement
+        this.invokers = invokers;","[{'comment': 'Should not depend on notify here. Some routers will override notify method.', 'commenter': 'AlbumenJ'}]"
11094,dubbo-cluster/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.rpc.cluster.router.state.StateRouterFactory,"@@ -2,5 +2,7 @@ tag=org.apache.dubbo.rpc.cluster.router.tag.TagStateRouterFactory
 condition=org.apache.dubbo.rpc.cluster.router.condition.ConditionStateRouterFactory
 service=org.apache.dubbo.rpc.cluster.router.condition.config.ServiceStateRouterFactory
 app=org.apache.dubbo.rpc.cluster.router.condition.config.AppStateRouterFactory
+provider-app=org.apache.dubbo.rpc.cluster.router.condition.config.ProviderAppStateRouterFactory
+script-app=org.apache.dubbo.rpc.cluster.router.script.config.AppScriptRouterFactory","[{'comment': 'Script router should not enabled by default.', 'commenter': 'AlbumenJ'}]"
11094,dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java,"@@ -131,4 +131,8 @@ public boolean isErrorEnabled() {
         return logger.isEnabledFor(Level.ERROR);
     }
 
+    // test purpose only","[{'comment': 'Useless?', 'commenter': 'AlbumenJ'}]"
11094,dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java,"@@ -125,4 +125,9 @@ public boolean isWarnEnabled() {
     public boolean isErrorEnabled() {
         return logger.isErrorEnabled();
     }
+
+    // test purpose only","[{'comment': 'Useless?', 'commenter': 'AlbumenJ'}]"
11094,dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java,"@@ -679,14 +679,43 @@ public static void setInterface(MulticastSocket multicastSocket, boolean preferI
         }
     }
 
-    public static boolean matchIpExpression(String pattern, String host, int port) throws UnknownHostException {
+    /**
+     * Check if address matches with specified pattern, currently only supports ipv4, use {@link this#matchIpExpression(String, String, int)} for ipv6 addresses.
+     *
+     * @param pattern cird pattern
+     * @param address 'ip:port'
+     * @return true if address matches with the pattern
+     */
+    public static boolean matchIpExpression(String pattern, String address) throws UnknownHostException {
+        if (address == null) {
+            return false;
+        }
+
+        String host = address;
+        int port = 0;
+        // only works for ipv4 address with 'ip:port' format
+        if (address.endsWith("":"")) {","[{'comment': 'Should be `contains`?', 'commenter': 'AlbumenJ'}]"
11094,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java,"@@ -82,7 +82,7 @@
     /**
      * Initialization at construction time, assertion not null, and always assign non-null value
      */
-    protected final URL directoryUrl;
+    protected URL directoryUrl;","[{'comment': 'Add `volatile`', 'commenter': 'AlbumenJ'}]"
11094,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java,"@@ -41,12 +45,15 @@
 import static org.apache.dubbo.common.constants.RegistryConstants.DYNAMIC_KEY;
 import static org.apache.dubbo.rpc.cluster.Constants.CONFIG_VERSION_KEY;
 import static org.apache.dubbo.rpc.cluster.Constants.OVERRIDE_PROVIDERS_KEY;
+import static org.apache.dubbo.rpc.cluster.Constants.RULE_VERSION_V30;
+import static org.apache.dubbo.rpc.cluster.configurator.parser.model.ConfiguratorConfig.MATCH_CONDITION;
 
 /**
  * AbstractConfigurator
  */
 public abstract class AbstractConfigurator implements Configurator {
-
+    public static final ErrorTypeAwareLogger errorLogger = LoggerFactory.getErrorTypeAwareLogger(AbstractConfigurator.class);
+    public static final Logger logger = LoggerFactory.getLogger(AbstractConfigurator.class);","[{'comment': 'remove this logger', 'commenter': 'AlbumenJ'}]"
11094,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java,"@@ -41,12 +45,15 @@
 import static org.apache.dubbo.common.constants.RegistryConstants.DYNAMIC_KEY;
 import static org.apache.dubbo.rpc.cluster.Constants.CONFIG_VERSION_KEY;
 import static org.apache.dubbo.rpc.cluster.Constants.OVERRIDE_PROVIDERS_KEY;
+import static org.apache.dubbo.rpc.cluster.Constants.RULE_VERSION_V30;
+import static org.apache.dubbo.rpc.cluster.configurator.parser.model.ConfiguratorConfig.MATCH_CONDITION;
 
 /**
  * AbstractConfigurator
  */
 public abstract class AbstractConfigurator implements Configurator {
-
+    public static final ErrorTypeAwareLogger errorLogger = LoggerFactory.getErrorTypeAwareLogger(AbstractConfigurator.class);","[{'comment': 'should be private', 'commenter': 'AlbumenJ'}]"
11099,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/AbstractWireProtocol.java,"@@ -35,7 +34,7 @@ public ProtocolDetector detector() {
     }
 
     @Override
-    public void configClientPipeline(URL url, ChannelOperator operator, SslContext sslContext) {
+    public void configClientPipeline(URL url, ChannelOperator operator, ContextOperator contextOperator) {","[{'comment': 'ContextOperator seems to have no actual usage scenarios?\r\n', 'commenter': 'CrazyHZM'}]"
11108,dubbo-metadata/dubbo-metadata-annotation-rest/src/main/java/org/apache/dubbo/metadata/annotation/rest/ApplicationPath.java,"@@ -0,0 +1,77 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
+ *
+ * Copyright (c) 2010-2015 Oracle and/or its affiliates. All rights reserved.
+ *
+ * The contents of this file are subject to the terms of either the GNU
+ * General Public License Version 2 only (""GPL"") or the Common Development
+ * and Distribution License(""CDDL"") (collectively, the ""License"").  You
+ * may not use this file except in compliance with the License.  You can
+ * obtain a copy of the License at
+ * http://glassfish.java.net/public/CDDL+GPL_1_1.html
+ * or packager/legal/LICENSE.txt.  See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ * When distributing the software, include this License Header Notice in each
+ * file and include the License file at packager/legal/LICENSE.txt.
+ *
+ * GPL Classpath Exception:
+ * Oracle designates this particular file as subject to the ""Classpath""
+ * exception as provided by Oracle in the GPL Version 2 section of the License
+ * file that accompanied this code.
+ *
+ * Modifications:
+ * If applicable, add the following below the License Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * ""Portions Copyright [year] [name of copyright owner]""
+ *
+ * Contributor(s):
+ * If you wish your version of this file to be governed by only the CDDL or
+ * only the GPL Version 2, indicate your decision by adding ""[Contributor]
+ * elects to include this software in this distribution under the [CDDL or GPL
+ * Version 2] license.""  If you don't indicate a single choice of license, a
+ * recipient has the option to distribute your version of this file under
+ * either the CDDL, the GPL Version 2 or to extend the choice of license to
+ * its licensees as provided above.  However, if you add GPL Version 2 code
+ * and therefore, elected the GPL Version 2 license, then the option applies
+ * only if the new code is made subject to such option by the copyright
+ * holder.
+ */
+
+package org.apache.dubbo.metadata.annotation.rest;
+
+import javax.ws.rs.Path;
+import java.lang.annotation.*;
+
+/**
+ * Identifies the application path that serves as the base URI
+ * for all resource URIs provided by {@link javax.ws.rs.Path}. May only be
+ * applied to a subclass of {@link javax.ws.rs.core.Application}.
+ *
+ * <p>When published in a Servlet container, the value of the application path
+ * may be overridden using a servlet-mapping element in the web.xml.</p>
+ *
+ * @author Paul Sandoz
+ * @author Marc Hadley
+ * @see javax.ws.rs.core.Application
+ * @see Path
+ * @since 1.1
+ */
+@Documented
+@Target({ElementType.TYPE})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface ApplicationPath {
+
+    /**
+     * Defines the base URI for all resource URIs. A trailing '/' character will
+     * be automatically appended if one is not present.
+     *
+     * <p>The supplied value is automatically percent
+     * encoded to conform to the {@code path} production of
+     * {@link <a href=""http://tools.ietf.org/html/rfc3986#section-3.3"">RFC 3986 section 3.3</a>}.
+     * Note that percent encoded values are allowed in the value, an
+     * implementation will recognize such values and will not double
+     * encode the '%' character.</p>
+     */
+    String value();
+}","[{'comment': 'Use jar dependency instead', 'commenter': 'AlbumenJ'}]"
11108,dubbo-common/src/test/java/org/apache/dubbo/common/vo/UserVo.java,"@@ -0,0 +1,68 @@
+package org.apache.dubbo.common.vo;","[{'comment': 'Add ASF license header for all newly created files', 'commenter': 'AlbumenJ'}]"
11108,dubbo-demo/dubbo-demo-interface/src/main/java/org/apache/dubbo/demo/RestDemoService.java,"@@ -16,6 +16,8 @@
  */
 package org.apache.dubbo.demo;
 
+import org.jboss.resteasy.annotations.Body;","[{'comment': 'remove unused import', 'commenter': 'AlbumenJ'}]"
11108,dubbo-remoting/dubbo-remoting-http/pom.xml,"@@ -59,5 +59,13 @@
             <version>4.5.5</version>
             <scope>test</scope>
         </dependency>
+
+        <!-- https://mvnrepository.com/artifact/com.squareup.okhttp3/okhttp -->","[{'comment': 'remove this tag', 'commenter': 'AlbumenJ'}]"
11108,dubbo-remoting/dubbo-remoting-http/pom.xml,"@@ -59,5 +59,13 @@
             <version>4.5.5</version>
             <scope>test</scope>
         </dependency>
+
+        <!-- https://mvnrepository.com/artifact/com.squareup.okhttp3/okhttp -->
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>okhttp</artifactId>
+            <scope>provided</scope>
+        </dependency>","[{'comment': 'Add dependency version to `dubbo-dependencies-bom`', 'commenter': 'AlbumenJ'}]"
11108,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/factory/AbstractHttpClientFactory.java,"@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.rest.factory;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.remoting.http.RestClient;
+import org.apache.dubbo.remoting.http.config.HttpClientConfig;
+import org.apache.dubbo.rpc.RpcException;
+
+/**
+ * AbstractHttpClientFactory
+ */
+public abstract class AbstractHttpClientFactory implements RestClientFactory {","[{'comment': 'should be moved to `dubbo-remoting-rest`', 'commenter': 'AlbumenJ'}]"
11108,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/factory/RestClientFactory.java,"@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.rest.factory;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Adaptive;
+import org.apache.dubbo.common.extension.ExtensionScope;
+import org.apache.dubbo.common.extension.SPI;
+import org.apache.dubbo.remoting.Constants;
+import org.apache.dubbo.remoting.http.RestClient;
+import org.apache.dubbo.rpc.RpcException;
+
+/**
+ * RestClientFactory. (API/SPI, Singleton, ThreadSafe)
+ */
+@SPI(value = ""okhttp"", scope = ExtensionScope.FRAMEWORK)
+public interface RestClientFactory {","[{'comment': 'should be moved to `dubbo-remoting-rest`', 'commenter': 'AlbumenJ'}]"
11108,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/factory/impl/ApacheHttpClientFactory.java,"@@ -0,0 +1,23 @@
+package org.apache.dubbo.rpc.protocol.rest.factory.impl;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.remoting.http.RestClient;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.protocol.rest.factory.AbstractHttpClientFactory;
+
+@Activate(value = ""apacheHttpclient"")
+public class ApacheHttpClientFactory extends AbstractHttpClientFactory {","[{'comment': 'should be moved to `dubbo-remoting-rest`', 'commenter': 'AlbumenJ'}]"
11108,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/factory/impl/OkHttpClientFactory.java,"@@ -0,0 +1,19 @@
+package org.apache.dubbo.rpc.protocol.rest.factory.impl;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.remoting.http.RestClient;
+import org.apache.dubbo.remoting.http.okhttp.OKHttpRestClient;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.protocol.rest.factory.AbstractHttpClientFactory;
+
+@Activate(""okhttp"")
+public class OkHttpClientFactory extends AbstractHttpClientFactory {","[{'comment': 'should be moved to `dubbo-remoting-rest`', 'commenter': 'AlbumenJ'}]"
11108,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/request/convert/OkHttpRequestConvert.java,"@@ -0,0 +1,69 @@
+package org.apache.dubbo.rpc.protocol.rest.request.convert;
+
+import okhttp3.*;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Adaptive;
+import org.apache.dubbo.metadata.rest.RestMethodMetadata;
+import org.apache.dubbo.metadata.rest.media.MediaType;
+import org.apache.dubbo.remoting.http.okhttp.OKHttpRestClient;
+import org.apache.dubbo.rpc.protocol.rest.annotation.consumer.RequestTemplate;
+import org.apache.dubbo.rpc.protocol.rest.constans.RestConstant;
+import org.apache.dubbo.rpc.protocol.rest.message.HttpMessageCodec;
+import org.apache.dubbo.rpc.protocol.rest.request.BaseConvert;
+
+import java.util.Collection;
+import java.util.Map;
+
+@Adaptive(""okhttp"")
+public class OkHttpRequestConvert extends BaseConvert<Request, Response, OKHttpRestClient> {","[{'comment': 'should be moved to `dubbo-remoting-rest`', 'commenter': 'AlbumenJ'}]"
11108,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/request/convert/RequestConvert.java,"@@ -0,0 +1,24 @@
+package org.apache.dubbo.rpc.protocol.rest.request.convert;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Adaptive;
+import org.apache.dubbo.common.extension.SPI;
+import org.apache.dubbo.metadata.rest.RestMethodMetadata;
+import org.apache.dubbo.remoting.RemotingException;
+import org.apache.dubbo.rpc.protocol.rest.annotation.consumer.RequestTemplate;
+import org.apache.dubbo.rpc.protocol.rest.request.client.ClientFacade;
+
+@SPI
+public interface RequestConvert<REQ, RES, CLIENT> extends ClientFacade<REQ, RES> {","[{'comment': 'should be moved to `dubbo-remoting-rest`', 'commenter': 'AlbumenJ'}]"
11108,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java,"@@ -72,17 +57,14 @@ public class RestProtocol extends AbstractProxyProtocol {
 
     private final RestServerFactory serverFactory = new RestServerFactory();
 
-    private final Map<String, ReferenceCountedClient> clients = new ConcurrentHashMap<>();
+    private final Map<String, ReferenceCountedClient<? extends RestClient>> clients = new ConcurrentHashMap<>();
 
-    private volatile ConnectionMonitor connectionMonitor;
+    private final RestClientFactory clientFactory = FrameworkModel.defaultModel().getExtensionLoader(RestClientFactory.class).getAdaptiveExtension();
 
     public RestProtocol() {","[{'comment': '```suggestion\r\n    public RestProtocol(FrameworkModel frameworkModel) {\r\n```', 'commenter': 'AlbumenJ'}]"
11108,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/request/convert/RequestConvert.java,"@@ -0,0 +1,24 @@
+package org.apache.dubbo.rpc.protocol.rest.request.convert;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Adaptive;
+import org.apache.dubbo.common.extension.SPI;
+import org.apache.dubbo.metadata.rest.RestMethodMetadata;
+import org.apache.dubbo.remoting.RemotingException;
+import org.apache.dubbo.rpc.protocol.rest.annotation.consumer.RequestTemplate;
+import org.apache.dubbo.rpc.protocol.rest.request.client.ClientFacade;
+
+@SPI
+public interface RequestConvert<REQ, RES, CLIENT> extends ClientFacade<REQ, RES> {
+
+    @Adaptive
+    RequestConvert createRequestConvert(URL url, CLIENT restClient, RestMethodMetadata restMethodMetadata);","[{'comment': 'exact to a factory class', 'commenter': 'AlbumenJ'}]"
11108,dubbo-common/src/main/java/org/apache/dubbo/common/json/impl/FastJson2Impl.java,"@@ -49,5 +59,35 @@ public <T> List<T> toJavaList(String json, Class<T> clazz) {
     public String toJson(Object obj) {
         return com.alibaba.fastjson2.JSON.toJSONString(obj, JSONWriter.Feature.WriteEnumsUsingName);
     }
+
+    @Override
+    public <T> T parseObject(byte[] bytes, Class<T> clazz) {
+        return com.alibaba.fastjson2.JSON.parseObject(bytes, clazz);
+    }
+
+    @Override
+    public <T> T parseObject(InputStream inputStream, Class<T> clazz) {
+        return com.alibaba.fastjson2.JSON.parseObject(inputStream, fastJsonConfig.getCharset(), clazz);
+
+    }
+
+    @Override
+    public <T> void serializeObject(OutputStream outputStream, Object value) throws Exception {
+        ByteArrayOutputStream outnew = new ByteArrayOutputStream();
+        SerializeFilter[] globalFilters = this.fastJsonConfig.getSerializeFilters();
+        List<SerializeFilter> allFilters = new ArrayList(Arrays.asList(globalFilters));
+
+
+        if (value instanceof FastJsonContainer) {
+            FastJsonContainer fastJsonContainer = (FastJsonContainer) value;
+            PropertyPreFilters filters = fastJsonContainer.getFilters();
+            allFilters.addAll(filters.getFilters());
+            value = fastJsonContainer.getValue();
+        }
+        com.alibaba.fastjson2.JSON.writeTo(outnew, value);","[{'comment': 'Why not use `outputStream` directly here', 'commenter': 'icodening'}]"
11108,dubbo-common/src/main/java/org/apache/dubbo/common/json/impl/FastJsonImpl.java,"@@ -49,4 +60,38 @@ public <T> List<T> toJavaList(String json, Class<T> clazz) {
     public String toJson(Object obj) {
         return com.alibaba.fastjson.JSON.toJSONString(obj, SerializerFeature.DisableCircularReferenceDetect);
     }
+
+    @Override
+    public <T> T parseObject(byte[] bytes, Class<T> clazz) {
+        return com.alibaba.fastjson.JSON.parseObject(bytes, clazz);
+    }
+
+    @Override
+    public <T> T parseObject(InputStream inputStream, Class<T> clazz) throws Exception {
+        return com.alibaba.fastjson.JSON.parseObject(inputStream, fastJsonConfig.getCharset(), clazz);
+    }
+
+    @Override
+    public <T> void serializeObject(OutputStream outputStream, Object value) throws Exception {
+
+        ByteArrayOutputStream outnew = new ByteArrayOutputStream();
+        SerializeFilter[] globalFilters = this.fastJsonConfig.getSerializeFilters();
+        List<SerializeFilter> allFilters = new ArrayList(Arrays.asList(globalFilters));
+
+
+        if (value instanceof FastJsonContainer) {
+            FastJsonContainer fastJsonContainer = (FastJsonContainer) value;
+            PropertyPreFilters filters = fastJsonContainer.getFilters();
+            allFilters.addAll(filters.getFilters());
+            value = fastJsonContainer.getValue();
+        }
+        JSON.writeJSONStringWithFastJsonConfig(outnew, this.fastJsonConfig.getCharset(), value,","[{'comment': 'same as above. `FastJson2Impl:87`', 'commenter': 'icodening'}]"
11108,dubbo-common/src/main/java/org/apache/dubbo/common/json/impl/GsonImpl.java,"@@ -21,7 +21,9 @@
 import com.google.gson.Gson;
 import com.google.gson.reflect.TypeToken;
 
+import java.io.*;","[{'comment': ""don't use `import java.io.*`"", 'commenter': 'icodening'}]"
11108,dubbo-common/src/test/java/org/apache/dubbo/common/utils/JsonUtilsTest.java,"@@ -278,4 +282,40 @@ public Class<?> loadClass(String name) throws ClassNotFoundException {
         Thread.currentThread().setContextClassLoader(originClassLoader);
         JsonUtils.setJson(null);
     }
+
+    @Test
+    public void TestStream() throws Exception {
+        UserVo instance = UserVo.getInstance();
+        byte[] bytes = new byte[4];
+        for (int i = 0; i < bytes.length; i++) {
+            bytes[i] = (byte) i;
+        }
+
+        List<Object> objects = Arrays.asList(instance, 1, ""dubbo"", bytes);
+
+        List<JSON> jsons = Arrays.asList(new GsonImpl(), new JacksonImpl(), new FastJson2Impl(), new FastJsonImpl());
+
+        for (int i = 0; i < objects.size(); i++) {
+
+            for (JSON json : jsons) {
+
+                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+                Object value = objects.get(i);
+                json.serializeObject(byteArrayOutputStream, value);
+
+                ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
+                Object object1 = json.parseObject(byteArrayInputStream, value.getClass());
+
+                if (value.getClass().isArray()) {
+                    Arrays.equals((byte[]) value, (byte[]) object1);","[{'comment': 'use assert', 'commenter': 'icodening'}]"
11108,dubbo-common/src/test/java/org/apache/dubbo/common/utils/JsonUtilsTest.java,"@@ -278,4 +282,40 @@ public Class<?> loadClass(String name) throws ClassNotFoundException {
         Thread.currentThread().setContextClassLoader(originClassLoader);
         JsonUtils.setJson(null);
     }
+
+    @Test
+    public void TestStream() throws Exception {
+        UserVo instance = UserVo.getInstance();
+        byte[] bytes = new byte[4];
+        for (int i = 0; i < bytes.length; i++) {
+            bytes[i] = (byte) i;
+        }
+
+        List<Object> objects = Arrays.asList(instance, 1, ""dubbo"", bytes);
+
+        List<JSON> jsons = Arrays.asList(new GsonImpl(), new JacksonImpl(), new FastJson2Impl(), new FastJsonImpl());
+
+        for (int i = 0; i < objects.size(); i++) {
+
+            for (JSON json : jsons) {
+
+                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+                Object value = objects.get(i);
+                json.serializeObject(byteArrayOutputStream, value);
+
+                ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
+                Object object1 = json.parseObject(byteArrayInputStream, value.getClass());
+
+                if (value.getClass().isArray()) {
+                    Arrays.equals((byte[]) value, (byte[]) object1);
+                } else {
+                    Assertions.assertEquals(object1, value);","[{'comment': 'plz exchange param position', 'commenter': 'icodening'}]"
11108,dubbo-demo/dubbo-demo-interface/src/main/java/org/apache/dubbo/demo/RestDemoService.java,"@@ -16,18 +16,20 @@
  */
 package org.apache.dubbo.demo;
 
-import javax.ws.rs.Consumes;
-import javax.ws.rs.GET;
-import javax.ws.rs.POST;
-import javax.ws.rs.Path;
-import javax.ws.rs.QueryParam;
+
+import po.TestPO;
+
+import javax.ws.rs.*;","[{'comment': ""don't use import *"", 'commenter': 'icodening'}]"
11108,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/rest/AbstractServiceRestMetadataResolver.java,"@@ -36,6 +28,14 @@
 import java.util.Set;
 import java.util.function.Consumer;
 
+import org.apache.dubbo.common.utils.MethodComparator;","[{'comment': 'unnecessary changes', 'commenter': 'icodening'}]"
11108,dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java,"@@ -19,13 +19,7 @@
 import org.apache.dubbo.config.annotation.DubboService;
 
 import org.springframework.http.MediaType;
-import org.springframework.web.bind.annotation.GetMapping;
-import org.springframework.web.bind.annotation.PathVariable;
-import org.springframework.web.bind.annotation.PostMapping;
-import org.springframework.web.bind.annotation.RequestBody;
-import org.springframework.web.bind.annotation.RequestHeader;
-import org.springframework.web.bind.annotation.RequestParam;
-import org.springframework.web.bind.annotation.RestController;
+import org.springframework.web.bind.annotation.*;","[{'comment': ""don't use import *"", 'commenter': 'icodening'}]"
11108,dubbo-metadata/dubbo-metadata-api/pom.xml,"@@ -45,13 +45,13 @@
             <version>${project.parent.version}</version>
         </dependency>
 
-        <!-- Test dependencies -->
-        <dependency>
-            <groupId>org.apache.dubbo</groupId>
-            <artifactId>dubbo-configcenter-zookeeper</artifactId>
-            <version>${project.parent.version}</version>
-            <scope>test</scope>
-        </dependency>
+<!--        &lt;!&ndash; Test dependencies &ndash;&gt;-->","[{'comment': 'remove this', 'commenter': 'EarthChen'}]"
11108,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/rest/NoAnnotatedParameterRequestTagProcessor.java,"@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metadata.rest;
+
+import org.apache.dubbo.common.extension.SPI;
+import org.apache.dubbo.metadata.rest.media.MediaType;
+
+import java.lang.reflect.Parameter;
+
+@SPI","[{'comment': 'set scope', 'commenter': 'EarthChen'}]"
11108,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/message/HttpMessageDecode.java,"@@ -0,0 +1,24 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.rest.message;
+
+
+public interface HttpMessageDecode{
+
+    Object decode(byte[] body, Class targetType) throws Exception;","[{'comment': 'Use generic replacement', 'commenter': 'EarthChen'}]"
11108,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/message/HttpMessageEncode.java,"@@ -0,0 +1,29 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.rest.message;
+
+
+import org.apache.dubbo.common.URL;
+
+import java.io.ByteArrayOutputStream;
+
+
+public interface HttpMessageEncode {
+
+    void encode(ByteArrayOutputStream outputStream, Object unSerializedBody, URL url) throws Exception;","[{'comment': 'replace outputstream', 'commenter': 'EarthChen'}]"
11118,dubbo-xds/src/main/java/org/apache/dubbo/rpc/cluster/router/xds/rule/XdsDomainResult.java,"@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.xds.rule;
+
+import io.envoyproxy.envoy.config.route.v3.VirtualHost;
+
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * @author : MentosL
+ * @date : 2022/12/11 21:29
+ */","[{'comment': 'Please remove this tag', 'commenter': 'AlbumenJ'}, {'comment': 'already update', 'commenter': 'MentosL'}]"
11144,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/AbstractProxyInvoker.java,"@@ -97,6 +99,11 @@ public Result invoke(Invocation invocation) throws RpcException {
                 }
             }
 
+            Map<String, String> invocationAttachments = invocation.getAttachments();
+            if (CollectionUtils.isNotEmptyMap(invocationAttachments)) {
+                RpcContext.getClientAttachment().getObjectAttachments().putAll(invocationAttachments);
+            }
+","[{'comment': 'It would be better to replace the way to get attachment in customized filter of rest protocol to  `org.apache.dubbo.rpc.RpcServiceContext#getInvocation` to get the origin invocation.', 'commenter': 'AlbumenJ'}, {'comment': 'Why does the AbstractProxyInvoker on the provider side use ClientAttachment?', 'commenter': 'wxbty'}]"
11144,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ContextFilter.java,"@@ -125,7 +126,11 @@ public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcExcept
         }
 
         if (invocation instanceof RpcInvocation) {
-            ((RpcInvocation) invocation).setInvoker(invoker);
+            RpcInvocation rpcInvocation = (RpcInvocation) invocation;
+            rpcInvocation.setInvoker(invoker);
+            //write all attachments back;
+            rpcInvocation.getObjectAttachments().putAll(context.getObjectAttachments());
+","[{'comment': 'It would be better to fill in the attachment when creating rpcInvocation, so as to avoid the performance loss caused by multiple coverage. If it is to pass information from the rest filter, you can extend a field in RpcServiceContext, obtain it in AbstractProxyInvoker and use it when creating a new invocation.', 'commenter': 'AlbumenJ'}]"
11144,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/proxy/InvokerInvocationHandler.java,"@@ -68,6 +70,8 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl
         }
         RpcInvocation rpcInvocation = new RpcInvocation(serviceModel, method.getName(), invoker.getInterface().getName(), protocolServiceKey, method.getParameterTypes(), args);
 
+        rpcInvocation.setObjectAttachments(new HashMap<>(RpcContext.getServerAttachment().getObjectAttachments()));
+","[{'comment': '![image](https://user-images.githubusercontent.com/9292748/208692430-21ae5410-7169-4dd1-ad48-b6b8d4cf7a87.png)\r\n\r\nWrap invoker would be better.\r\n\r\nSee org/apache/dubbo/rpc/protocol/AbstractProxyProtocol.java:91', 'commenter': 'AlbumenJ'}]"
11177,dubbo-common/src/test/java/org/apache/dubbo/common/model/person/PersonMap.java,"@@ -0,0 +1,29 @@
+package org.apache.dubbo.common.model.person;","[{'comment': 'Please add ASF license header', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'xieshouyu'}]"
11228,dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLoggerAdapter.java,"@@ -26,11 +26,32 @@
 
 import java.io.File;
 import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Map;
 
 public class Log4jLoggerAdapter implements LoggerAdapter {
 
     private File file;
 
+    private static final Map<Level, org.apache.log4j.Level> toLevel = new HashMap<>();
+    private static final Map<org.apache.log4j.Level, Level> toApacheLevel = new HashMap<>();
+
+    static {
+        toLevel.put(Level.ALL, org.apache.log4j.Level.ALL);
+        toLevel.put(Level.TRACE, org.apache.log4j.Level.TRACE);
+        toLevel.put(Level.DEBUG, org.apache.log4j.Level.DEBUG);
+        toLevel.put(Level.INFO, org.apache.log4j.Level.INFO);
+        toLevel.put(Level.WARN, org.apache.log4j.Level.WARN);
+        toLevel.put(Level.ERROR, org.apache.log4j.Level.ERROR);
+
+        toApacheLevel.put(org.apache.log4j.Level.ALL, Level.ALL);
+        toApacheLevel.put(org.apache.log4j.Level.TRACE, Level.TRACE);
+        toApacheLevel.put(org.apache.log4j.Level.DEBUG, Level.DEBUG);
+        toApacheLevel.put(org.apache.log4j.Level.INFO, Level.INFO);
+        toApacheLevel.put(org.apache.log4j.Level.WARN, Level.WARN);
+        toApacheLevel.put(org.apache.log4j.Level.ERROR, Level.ERROR);","[{'comment': ""This may cause `NoClassDefFoundError` if log4j's dependency is absent."", 'commenter': 'AlbumenJ'}, {'comment': 'you re right', 'commenter': 'baerwang'}]"
11240,dubbo-common/src/main/java/org/apache/dubbo/common/constants/LoggerCodeConstants.java,"@@ -230,6 +230,8 @@ public interface LoggerCodeConstants {
 
     String CLUSTER_FAILED_GROUP_MERGE = ""2-20"";
 
+    String CLUSTER_METHOD_DEPRECATED = ""2-21"";
+","[{'comment': 'Please submit a PR related with this code in apache/dubbo-website.', 'commenter': 'AlbumenJ'}]"
11249,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java,"@@ -80,6 +82,16 @@ public int getDefaultPort() {
         return 50051;
     }
 
+
+    private static boolean hasProtobuf() {
+        try {
+            Class.forName(Message.class.getName());","[{'comment': '```suggestion\r\n            Class.forName(""com.google.protobuf.Message"");\r\n```\r\n\r\n这里应该用全限定名更合适吧…… 要不然 JVM 抛出的会是 NoClassDefFoundError。\r\n', 'commenter': 'win120a'}]"
11249,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java,"@@ -36,6 +36,7 @@
 import org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;
 import org.apache.dubbo.rpc.protocol.tri.service.TriBuiltinService;
 
+import com.google.protobuf.Message;","[{'comment': '```suggestion\r\n```', 'commenter': 'win120a'}]"
11249,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/AbstractStream.java,"@@ -30,8 +30,23 @@ public abstract class AbstractStream implements Stream {
     protected final Executor executor;
     protected final FrameworkModel frameworkModel;
 
+
+    public static final boolean HAS_PROTOBUF = hasProtobuf();
+
+    public static final boolean GRPC_STATUS_DETAIL_ENABLED = HAS_PROTOBUF;
+
     public AbstractStream(Executor executor, FrameworkModel frameworkModel) {
         this.executor = new SerializingExecutor(executor);
         this.frameworkModel = frameworkModel;
     }
+
+
+    private static boolean hasProtobuf() {
+        try {
+            Class.forName(""com.google.protobuf.Message"");","[{'comment': 'use `org.apache.dubbo.common.utils.ClassUtils#forName(java.lang.String)`', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'EarthChen'}]"
11326,dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConcurrentHashMapUtils.java,"@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.utils;
+
+import java.util.concurrent.ConcurrentMap;
+import java.util.function.Function;
+
+/**
+ * ConcurrentHashMap util
+ */
+
+public class ConcurrentHashMapUtils {
+
+    private static final boolean IS_JAVA8;
+
+    static {
+        IS_JAVA8 = System.getProperty(""java.version"").startsWith(""1.8."");","[{'comment': 'Should we try catch here to prevent `ConcurrentHashMapUtils` init failed?', 'commenter': 'AlbumenJ'}, {'comment': '@AlbumenJ good idea,i will fix it and re-submit later.', 'commenter': 'mxsm'}]"
11352,dubbo-common/src/main/java/org/apache/dubbo/common/metrics/event/MetricsEventMulticaster.java,"@@ -0,0 +1,10 @@
+package org.apache.dubbo.common.metrics.event;
+
+import org.apache.dubbo.common.metrics.listener.MetricsListener;","[{'comment': 'please  add  apache license', 'commenter': 'songxiaosheng'}, {'comment': 'Please see the last submission, the same as the following', 'commenter': 'wxbty'}]"
11352,dubbo-common/src/main/java/org/apache/dubbo/common/metrics/event/SimpleMetricsEventMulticaster.java,"@@ -0,0 +1,40 @@
+package org.apache.dubbo.common.metrics.event;","[{'comment': 'please add apache license', 'commenter': 'songxiaosheng'}]"
11352,dubbo-common/src/main/java/org/apache/dubbo/common/metrics/model/ServiceInfo.java,"@@ -0,0 +1,70 @@
+package org.apache.dubbo.common.metrics.model;","[{'comment': 'please add apache license', 'commenter': 'songxiaosheng'}]"
11352,dubbo-common/src/main/java/org/apache/dubbo/common/metrics/event/SimpleMetricsEventMulticaster.java,"@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.metrics.event;
+
+import org.apache.dubbo.common.metrics.listener.MetricsListener;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class SimpleMetricsEventMulticaster implements MetricsEventMulticaster {
+
+    private SimpleMetricsEventMulticaster() {
+    }
+
+    private static volatile SimpleMetricsEventMulticaster instance;","[{'comment': 'sonar check failed https://sonarcloud.io/project/issues?resolved=false&types=BUG&pullRequest=11352&id=apache_dubbo&open=AYXJm2-LLb6JIPCAVFwc&tab=code\r\n\r\n ', 'commenter': 'songxiaosheng'}]"
11352,dubbo-dependencies-bom/pom.xml,"@@ -184,7 +184,7 @@
         <portlet_version>2.0</portlet_version>
         <maven_flatten_version>1.1.0</maven_flatten_version>
         <commons_compress_version>1.21</commons_compress_version>
-        <revision>3.2.0-beta.4-SNAPSHOT</revision>
+        <revision>3.2.0-beta.11-SNAPSHOT</revision>","[{'comment': 'version  is bad', 'commenter': 'songxiaosheng'}, {'comment': 'revert this line', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'wxbty'}]"
11352,dubbo-dependencies/dubbo-dependencies-zookeeper-curator5/pom.xml,"@@ -32,7 +32,7 @@
     <packaging>pom</packaging>
 
     <properties>
-        <revision>3.2.0-beta.4-SNAPSHOT</revision>","[{'comment': 'version  is  bad', 'commenter': 'songxiaosheng'}]"
11352,dubbo-dependencies/dubbo-dependencies-zookeeper/pom.xml,"@@ -32,7 +32,7 @@
     <packaging>pom</packaging>
 
     <properties>
-        <revision>3.2.0-beta.4-SNAPSHOT</revision>
+        <revision>3.2.0-beta.11-SNAPSHOT</revision>","[{'comment': 'version  is  bad', 'commenter': 'songxiaosheng'}]"
11352,dubbo-common/src/main/java/org/apache/dubbo/common/metrics/model/ServiceInfo.java,"@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.metrics.model;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class ServiceInfo {
+
+    private static final Map<String, ServiceInfo> caches = new ConcurrentHashMap<>();
+    private static final int maxSize = 200;
+
+    private String interfaceName;
+    private String methodName;
+    private String group;
+    private String version;
+
+    private ServiceInfo(String interfaceName, String methodName, String group, String version) {
+        this.interfaceName = interfaceName;
+        this.methodName = methodName;
+        this.group = group;
+        this.version = version;
+    }
+
+    public static ServiceInfo getInstance(String interfaceName, String methodName, String group, String version) {","[{'comment': 'Can we just simply use `Invocation` here?', 'commenter': 'AlbumenJ'}]"
11360,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/ChannelHandlerDispatcher.java,"@@ -41,12 +43,15 @@ public ChannelHandlerDispatcher() {
     }
 
     public ChannelHandlerDispatcher(ChannelHandler... handlers) {
+        // if varargs is used, the type of handlers is ChannelHandler[] and it is not null
+        // so we should filter the null object
         this(handlers == null ? null : Arrays.asList(handlers));
     }
 
     public ChannelHandlerDispatcher(Collection<ChannelHandler> handlers) {
         if (CollectionUtils.isNotEmpty(handlers)) {
-            this.channelHandlers.addAll(handlers);
+            // filter null object
+            this.channelHandlers.addAll(handlers.stream().filter(Objects::nonNull).collect(Collectors.toSet()));","[{'comment': '```suggestion\r\n            handlers.stream().filter(Objects::nonNull).foreach(this.channelHandlers::add);\r\n```', 'commenter': 'AlbumenJ'}, {'comment': 'the channelHandlers is a CopyOnWriteArraySet, when we edit the value , CopyOnWriteArraySet will create a new list, so I think that we should use addAll', 'commenter': 'KamToHung'}]"
11390,dubbo-common/src/main/java/org/apache/dubbo/config/annotation/DubboProvidedbBy.java,"@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.config.annotation;
+
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Class-level annotation used for declaring Dubbo interface.
+ * @DubboProvidedbBy(""dubbo-samples-xds-provider"")
+ * public interface GreetingService {
+ *     String sayHello(String name);
+ * }
+ *
+ * @Component(""annotatedConsumer"")
+ * public class GreetingServiceConsumer {
+ *     @DubboReference(version = ""1.0.0"")
+ *     private GreetingService greetingService;
+ * }
+ */
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.TYPE})
+@Inherited
+public @interface DubboProvidedbBy {","[{'comment': '```suggestion\r\npublic @interface ProvidedbBy {\r\n```', 'commenter': 'AlbumenJ'}]"
11390,dubbo-common/src/main/java/org/apache/dubbo/config/annotation/ProvidedbBy.java,"@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.config.annotation;
+
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Class-level annotation used for declaring Dubbo interface.
+ * @DubboProvidedbBy(""dubbo-samples-xds-provider"")
+ * public interface GreetingService {
+ *     String sayHello(String name);
+ * }
+ *
+ * @Component(""annotatedConsumer"")
+ * public class GreetingServiceConsumer {
+ *     @DubboReference(version = ""1.0.0"")
+ *     private GreetingService greetingService;
+ * }
+ */
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.TYPE})
+@Inherited
+public @interface ProvidedbBy {","[{'comment': '```suggestion\r\npublic @interface ProvidedBy {\r\n```', 'commenter': 'AlbumenJ'}]"
11390,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -518,9 +518,8 @@ private boolean checkMeshConfig(Map<String, String> referenceParameters) {
 
         String providedBy = referenceParameters.get(PROVIDED_BY);
         if (StringUtils.isEmpty(providedBy)) {
-            throw new IllegalStateException(""In mesh mode, the providedBy of ReferenceConfig is must be set"");
+            throw new IllegalStateException(""In mesh mode, the providedBy or dubboProvidedBy of ReferenceConfig is must be set"");","[{'comment': '```suggestion\r\n            throw new IllegalStateException(""In mesh mode, the providedBy of ReferenceConfig is must be set"");\r\n```', 'commenter': 'AlbumenJ'}]"
11390,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceAttributes.java,"@@ -51,7 +51,6 @@ public interface ReferenceAttributes {
     String PARAMETERS = ""parameters"";
 
     String PROVIDED_BY = ""providedBy"";
-","[{'comment': 'revert', 'commenter': 'AlbumenJ'}]"
11390,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanSupport.java,"@@ -78,6 +79,17 @@ public static void convertReferenceProps(Map<String, Object> attributes, Class d
             interfaceName = defaultInterfaceClass.getName();
         }
         Assert.notEmptyString(interfaceName, ""The interface class or name of reference was not found"");
+        Class<?> clazz = ClassUtils.resolveClass(interfaceName, defaultInterfaceClass.getClassLoader());","[{'comment': '```suggestion\r\n        Class<?> clazz = getInterfaceClass();\r\n```', 'commenter': 'AlbumenJ'}]"
11390,dubbo-common/src/main/java/org/apache/dubbo/config/annotation/ProvidedBy.java,"@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.config.annotation;
+
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Class-level annotation used for declaring Dubbo interface.
+ * @DubboProvidedbBy(""dubbo-samples-xds-provider"")","[{'comment': '```suggestion\r\n * @ProvidedBy(""dubbo-samples-xds-provider"")\r\n```', 'commenter': 'AlbumenJ'}]"
11418,dubbo-common/src/main/java/org/apache/dubbo/config/SecureConfig.java,"@@ -0,0 +1,21 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.config;
+
+public class SecureConfig extends AbstractConfig{","[{'comment': 'What is the purpose of defining this class?', 'commenter': 'AlbumenJ'}, {'comment': '到时考虑到一些安全的配置，现阶段暂时不需要，已经移出', 'commenter': 'jojocodeX'}]"
11418,dubbo-plugin/dubbo-spring-security/src/main/java/org/apache/dubbo/spring/security/filter/ContextHolderParametersSelectedTransferFilter.java,"@@ -0,0 +1,77 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.spring.security.filter;
+
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.cluster.filter.ClusterFilter;
+import org.apache.dubbo.spring.security.filter.condition.AndFilterConditionMatcher;
+import org.apache.dubbo.spring.security.filter.condition.FilterConditionMatcher;
+import org.apache.dubbo.spring.security.filter.condition.FilterConditionMatcherOnClass;
+import org.apache.dubbo.spring.security.utils.SecurityNames;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+
+import static org.apache.dubbo.spring.security.utils.SecurityNames.SECURITY_AUTHENTICATION_CONTEXT_KEY;
+import static org.apache.dubbo.spring.security.utils.SecurityNames.SECURITY_CONTEXT_HOLDER_CLASS_NAME;
+
+@Activate(group = CommonConstants.CONSUMER, order = -1)
+public class ContextHolderParametersSelectedTransferFilter
+    extends AndFilterConditionMatcher implements ConditionFilter, ClusterFilter {
+
+    public static List<FilterConditionMatcher> conditionMatchers = new ArrayList<>();
+
+    static{
+        conditionMatchers.add(new FilterConditionMatcherOnClass(SECURITY_CONTEXT_HOLDER_CLASS_NAME){","[{'comment': 'Prevent use `static` in Dubbo for multi instance status purpose.', 'commenter': 'AlbumenJ'}, {'comment': '检查在加载时就已经决定了，没有必要实例化过程中检查', 'commenter': 'jojocodeX'}]"
11418,dubbo-plugin/dubbo-spring-security/src/main/java/org/apache/dubbo/spring/security/utils/ObjectMapperCodec.java,"@@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.spring.security.utils;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.dubbo.common.utils.StringUtils;
+import org.springframework.security.jackson2.CoreJackson2Module;
+
+final public class ObjectMapperCodec {
+
+    private static final ObjectMapper mapper = new ObjectMapper();
+
+    static{
+        mapper.registerModule(new CoreJackson2Module());
+    }
+
+    private ObjectMapperCodec(){}","[{'comment': '```suggestion\r\n    private final ObjectMapper mapper = new ObjectMapper();\r\n\r\n    public ObjectMapperCodec(){\r\n        mapper.registerModule(new CoreJackson2Module());\r\n    }\r\n```', 'commenter': 'AlbumenJ'}, {'comment': 'ok', 'commenter': 'jojocodeX'}]"
11433,README.md,"@@ -167,10 +167,10 @@ The consumer will print out `hi, dubbo` on the screen.
 
 ### Next steps
 
-* [Your first Dubbo application](https://dubbo.apache.org/blog/2018/08/07/dubbo-101/) - A 101 tutorial to reveal more details, with the same code above.
-* [Dubbo user manual](https://dubbo.apache.org/docs/v2.7/user/preface/background/) - How to use Dubbo and all its features.
-* [Dubbo developer guide](https://dubbo.apache.org/docs/v2.7/dev/build/) - How to involve in Dubbo development.
-* [Dubbo admin manual](https://dubbo.apache.org/docs/v2.7/admin/install/provider-demo/) - How to admin and manage Dubbo services.
+* [Your first Dubbo application](https://cn.dubbo.apache.org/en/blog/2018/08/07/dubbo-101/) - A 101 tutorial to reveal more details, with the same code above.
+* [Dubbo user manual](https://cn.dubbo.apache.org/en/overview/what/) - How to use Dubbo and all its features.
+* [Dubbo developer guide](https://cn.dubbo.apache.org/en/docs3-v2/java-sdk/) - How to involve in Dubbo development.
+* [Dubbo admin manual](https://cn.dubbo.apache.org/zh/docsv2.7/admin/ops/) - How to admin and manage Dubbo services.","[{'comment': '```suggestion\r\n* [Your first Dubbo application](https://dubbo.apache.org/en/blog/2018/08/07/dubbo-101/) - A 101 tutorial to reveal more details, with the same code above.\r\n* [Dubbo user manual](https://dubbo.apache.org/en/overview/what/) - How to use Dubbo and all its features.\r\n* [Dubbo developer guide](https://dubbo.apache.org/en/docs3-v2/java-sdk/) - How to involve in Dubbo development.\r\n* [Dubbo admin manual](https://dubbo.apache.org/zh/docsv2.7/admin/ops/) - How to admin and manage Dubbo services.\r\n```', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'Phixsura'}]"
11452,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilterConsumer.java,"@@ -0,0 +1,54 @@
+package org.apache.dubbo.metrics.filter;
+
+import org.apache.dubbo.common.extension.Activate;
+
+import org.apache.dubbo.metrics.collector.DefaultMetricsCollector;
+import org.apache.dubbo.rpc.*;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import java.util.function.Consumer;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+
+
+@Activate(group =CONSUMER, order = -1)
+public class MetricsFilterConsumer implements Filter, BaseFilter.Listener, ScopeModelAware {","[{'comment': 'Replace with `ClusterFilter`', 'commenter': 'AlbumenJ'}, {'comment': 'ok\r\n', 'commenter': 'lcb11'}]"
11452,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilterConsumer.java,"@@ -0,0 +1,54 @@
+package org.apache.dubbo.metrics.filter;","[{'comment': 'Please add ASF license header', 'commenter': 'AlbumenJ'}, {'comment': 'ok ', 'commenter': 'lcb11'}]"
11452,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilterConsumer.java,"@@ -0,0 +1,54 @@
+package org.apache.dubbo.metrics.filter;
+
+import org.apache.dubbo.common.extension.Activate;
+
+import org.apache.dubbo.metrics.collector.DefaultMetricsCollector;
+import org.apache.dubbo.rpc.*;","[{'comment': 'do not use comma import', 'commenter': 'AlbumenJ'}, {'comment': 'ok, I will change this', 'commenter': 'lcb11'}]"
11452,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilterConsumer.java,"@@ -0,0 +1,54 @@
+package org.apache.dubbo.metrics.filter;
+
+import org.apache.dubbo.common.extension.Activate;
+
+import org.apache.dubbo.metrics.collector.DefaultMetricsCollector;
+import org.apache.dubbo.rpc.*;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import java.util.function.Consumer;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+
+
+@Activate(group =CONSUMER, order = -1)
+public class MetricsFilterConsumer implements Filter, BaseFilter.Listener, ScopeModelAware {
+
+    DefaultMetricsCollector collector=null;
+    ApplicationModel applicationModel=null;
+
+    @Override
+    public void setApplicationModel(ApplicationModel applicationModel) {","[{'comment': '```suggestion\r\n    public MetricsFilterConsumer(ApplicationModel applicationModel) {\r\n```', 'commenter': 'AlbumenJ'}]"
11452,dubbo-test/dubbo-test-check/pom.xml,"@@ -83,6 +83,12 @@
             <artifactId>async-http-client</artifactId>
             <version>${async.http.client.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-common</artifactId>
+            <version>3.2.0-beta.4</version>
+            <scope>compile</scope>
+        </dependency>","[{'comment': 'What is the purpose of changing this', 'commenter': 'AlbumenJ'}, {'comment': ""sorry,  I didn't know this was change."", 'commenter': 'lcb11'}, {'comment': 'Still exist', 'commenter': 'AlbumenJ'}]"
11452,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/ClusterFilter.java,"@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metrics.filter;
+
+import org.apache.dubbo.common.extension.Activate;
+
+import org.apache.dubbo.metrics.collector.DefaultMetricsCollector;
+import org.apache.dubbo.rpc.BaseFilter;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import java.util.function.Consumer;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+
+
+@Activate(group = CONSUMER, order = -1)
+public class ClusterFilter implements Filter, BaseFilter.Listener, ScopeModelAware {
+
+    DefaultMetricsCollector collector=null;
+    ApplicationModel applicationModel=null;","[{'comment': '```suggestion\r\n    private final DefaultMetricsCollector collector;\r\n    private final ApplicationModel applicationModel;\r\n```', 'commenter': 'AlbumenJ'}, {'comment': 'ok\r\n', 'commenter': 'lcb11'}]"
11452,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java,"@@ -143,9 +144,17 @@ private void onRequestEvent(RequestEvent event) {
     @Override
     public List<MetricSample> collect() {
         List<MetricSample> list = new ArrayList<>();
-        collectRequests(list);
-        collectQPS(list);
-        collectRT(list);
+
+        if(RpcContext.getContext().isConsumerSide()){","[{'comment': 'This method is used to report and collect all data without if filtering', 'commenter': 'songxiaosheng'}]"
11452,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/DefaultMetricsCollector.java,"@@ -63,100 +64,123 @@ public Boolean isCollectEnabled() {
     }
 
     public void increaseTotalRequests(String applicationName, Invocation invocation) {
-        increaseAndPublishEvent(applicationName, MetricsEvent.Type.TOTAL, invocation);
+        increaseAndPublishEvent(applicationName, RequestEvent.Type.TOTAL, invocation);","[{'comment': 'please use MetricsEvent', 'commenter': 'songxiaosheng'}]"
11452,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/DefaultMetricsCollector.java,"@@ -63,100 +64,123 @@ public Boolean isCollectEnabled() {
     }
 
     public void increaseTotalRequests(String applicationName, Invocation invocation) {
-        increaseAndPublishEvent(applicationName, MetricsEvent.Type.TOTAL, invocation);
+        increaseAndPublishEvent(applicationName, RequestEvent.Type.TOTAL, invocation);
     }
 
     public void increaseSucceedRequests(String applicationName, Invocation invocation) {
-        increaseAndPublishEvent(applicationName, MetricsEvent.Type.SUCCEED, invocation);
+        increaseAndPublishEvent(applicationName, RequestEvent.Type.SUCCEED, invocation);
     }
 
     public void increaseUnknownFailedRequests(String applicationName, Invocation invocation) {
-        increaseAndPublishEvent(applicationName, MetricsEvent.Type.UNKNOWN_FAILED, invocation);
+        increaseAndPublishEvent(applicationName, RequestEvent.Type.UNKNOWN_FAILED, invocation);
     }
 
     public void businessFailedRequests(String applicationName, Invocation invocation) {
-        increaseAndPublishEvent(applicationName, MetricsEvent.Type.BUSINESS_FAILED, invocation);
+        increaseAndPublishEvent(applicationName, RequestEvent.Type.BUSINESS_FAILED, invocation);
     }
 
     public void timeoutRequests(String applicationName, Invocation invocation) {
-        increaseAndPublishEvent(applicationName,MetricsEvent.Type.REQUEST_TIMEOUT, invocation);
+        increaseAndPublishEvent(applicationName,RequestEvent.Type.REQUEST_TIMEOUT, invocation);
     }
 
     public void limitRequests(String applicationName, Invocation invocation) {
-        increaseAndPublishEvent(applicationName,MetricsEvent.Type.REQUEST_LIMIT, invocation);
+        increaseAndPublishEvent(applicationName,RequestEvent.Type.REQUEST_LIMIT, invocation);
     }
 
     public void increaseProcessingRequests(String applicationName, Invocation invocation) {
-        increaseAndPublishEvent(applicationName,MetricsEvent.Type.PROCESSING, invocation);
+        increaseAndPublishEvent(applicationName,RequestEvent.Type.PROCESSING, invocation);
     }
 
     public void decreaseProcessingRequests(String applicationName, Invocation invocation) {
-        decreaseAndPublishEvent(applicationName,MetricsEvent.Type.PROCESSING, invocation);
+        decreaseAndPublishEvent(applicationName,RequestEvent.Type.PROCESSING, invocation);
     }
 
     public void totalFailedRequests(String applicationName, Invocation invocation) {
-        increaseAndPublishEvent(applicationName,MetricsEvent.Type.TOTAL_FAILED, invocation);
+        increaseAndPublishEvent(applicationName,RequestEvent.Type.TOTAL_FAILED, invocation);
     }
 
-    private void increaseAndPublishEvent(String applicationName, MetricsEvent.Type total, Invocation invocation) {
+    private void increaseAndPublishEvent(String applicationName, RequestEvent.Type total, Invocation invocation) {
         this.eventMulticaster.publishEvent(doExecute(total, statHandler -> statHandler.increase(applicationName,invocation)));
     }
 
-    private void decreaseAndPublishEvent(String applicationName, MetricsEvent.Type type, Invocation invocation) {
-        this.eventMulticaster.publishEvent(doExecute(type, statHandler -> statHandler.decrease(applicationName,invocation)));
+    private void decreaseAndPublishEvent(String applicationName, RequestEvent.Type total, Invocation invocation) {
+        this.eventMulticaster.publishEvent(doExecute(total, statHandler -> statHandler.decrease(applicationName,invocation)));
     }
 
     public void addRT(String applicationName,Invocation invocation, Long responseTime) {
         this.eventMulticaster.publishEvent(stats.addRtAndRetrieveEvent(applicationName,invocation, responseTime));
     }
-    public void addApplicationInfo(String applicationName, String version) {
-        doExecute(MetricsEvent.Type.APPLICATION_INFO, statHandler -> statHandler.addApplication(applicationName,version));
-    }
+
     @Override
     public List<MetricSample> collect() {
         List<MetricSample> list = new ArrayList<>();
-        collectApplication(list);
-        collectRequests(list);
-        collectRT(list);
+        if(RpcContext.getContext().isProviderSide()){
+            collectRequests(list);
+            collectRT(list);
+        }else {
+            collectConsumerRequests(list);
+            collectConsumerRT(list);
 
-        return list;
-    }
-
-    private void collectApplication(List<MetricSample> list) {
-        doCollect(MetricsEvent.Type.APPLICATION_INFO, MetricsStatHandler::get).filter(e -> !e.isEmpty())
-            .ifPresent(map -> map.forEach((k, v) -> list.add(new GaugeMetricSample(MetricsKey.APPLICATION_METRIC_INFO, k.getTags(),
-                APPLICATION, v::get))));
+        }
 
 
+        return list;
     }
 
     private void collectRequests(List<MetricSample> list) {
-        doCollect(MetricsEvent.Type.TOTAL, MetricsStatHandler::get).filter(e -> !e.isEmpty())
+        doCollect(RequestEvent.Type.TOTAL, MetricsStatHandler::get).filter(e -> !e.isEmpty())","[{'comment': 'please use MetricsEvent', 'commenter': 'songxiaosheng'}]"
11452,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/ClusterFilter.java,"@@ -0,0 +1,71 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metrics.filter;
+
+import org.apache.dubbo.common.extension.Activate;
+
+import org.apache.dubbo.metrics.collector.DefaultMetricsCollector;
+import org.apache.dubbo.rpc.BaseFilter;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ScopeModelAware;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+
+
+@Activate(group = CONSUMER, order = -1)
+public class ClusterFilter implements Filter, BaseFilter.Listener, ScopeModelAware {","[{'comment': 'please rename ClusterFilter to ConsumerMetricsFilter ', 'commenter': 'songxiaosheng'}, {'comment': 'Rename.\r\n`ClusterFilter` is duplicated.', 'commenter': 'AlbumenJ'}]"
11452,dubbo-rpc/dubbo-rpc-triple/pom.xml,"@@ -92,6 +92,11 @@
             <version>${reactor.version}</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>","[{'comment': 'remove this dependency', 'commenter': 'songxiaosheng'}]"
11452,dubbo-rpc/dubbo-rpc-triple/pom.xml,"@@ -113,6 +118,7 @@
                 <artifactId>protobuf-maven-plugin</artifactId>
                 <version>0.6.1</version>
                 <configuration>
+                    <!--suppress UnresolvedMavenProperty -->","[{'comment': 'remove this comment', 'commenter': 'songxiaosheng'}]"
11452,dubbo-test/dubbo-test-check/pom.xml,"@@ -83,6 +83,12 @@
             <artifactId>async-http-client</artifactId>
             <version>${async.http.client.version}</version>
         </dependency>
+        <dependency>","[{'comment': 'remove this dependency', 'commenter': 'songxiaosheng'}]"
11452,dubbo-metrics/dubbo-metrics-default/src/test/java/org/apache/dubbo/metrics/filter/MetricsFilterTest.java,"@@ -26,11 +26,7 @@
 import org.apache.dubbo.metrics.model.MetricsKey;
 import org.apache.dubbo.metrics.model.sample.GaugeMetricSample;
 import org.apache.dubbo.metrics.model.sample.MetricSample;
-import org.apache.dubbo.rpc.AppResponse;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.RpcException;
-import org.apache.dubbo.rpc.RpcInvocation;
+import org.apache.dubbo.rpc.*;","[{'comment': 'Do not use comma import.\r\nYou can import code style config in `codestyle` folder.', 'commenter': 'AlbumenJ'}]"
11452,dubbo-rpc/dubbo-rpc-triple/pom.xml,"@@ -92,6 +92,11 @@
             <version>${reactor.version}</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo</artifactId>
+            <version>3.2.0-beta.4</version>
+        </dependency>","[{'comment': '`dubbo-rpc-triple` should not depends on `dubbo-all`', 'commenter': 'AlbumenJ'}]"
11493,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/TimeAble.java,"@@ -0,0 +1,8 @@
+package org.apache.dubbo.metrics.event;","[{'comment': 'please add apache license', 'commenter': 'songxiaosheng'}]"
11493,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/TimePair.java,"@@ -0,0 +1,23 @@
+package org.apache.dubbo.metrics.model;","[{'comment': 'please add apache license', 'commenter': 'songxiaosheng'}]"
11493,dubbo-metrics/dubbo-metrics-registry/src/main/java/org/apache/dubbo/metrics/registry/event/RegistryRegisterSuccessEvent.java,"@@ -0,0 +1,11 @@
+package org.apache.dubbo.metrics.registry.event;","[{'comment': 'please add apache license', 'commenter': 'songxiaosheng'}]"
11493,dubbo-metrics/dubbo-metrics-registry/src/main/java/org/apache/dubbo/metrics/registry/event/RegistryRegisterEvent.java,"@@ -0,0 +1,12 @@
+package org.apache.dubbo.metrics.registry.event;","[{'comment': 'please add apache license', 'commenter': 'songxiaosheng'}, {'comment': 'please add apache license', 'commenter': 'songxiaosheng'}]"
11493,dubbo-metrics/dubbo-metrics-registry/src/main/java/org/apache/dubbo/metrics/registry/event/SubscribeListener.java,"@@ -0,0 +1,59 @@
+package org.apache.dubbo.metrics.registry.event;","[{'comment': 'please add apache license', 'commenter': 'songxiaosheng'}]"
11493,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -358,14 +365,27 @@ private void initMetricsService() {
         metricsServiceExporter.init();
     }
 
+    @SuppressWarnings({""rawtypes""})
     private void initMetricsReporter() {
+        ScopeBeanFactory beanFactory = applicationModel.getBeanFactory();","[{'comment': 'please use create collector in FrameworkModel to share collector instance ', 'commenter': 'songxiaosheng'}]"
11493,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/BaseMetricsEventMulticaster.java,"@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.event;
+
+import org.apache.dubbo.metrics.listener.MetricsLifeListener;
+import org.apache.dubbo.metrics.listener.MetricsListener;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.function.Consumer;
+
+public class BaseMetricsEventMulticaster implements MetricsEventMulticaster {","[{'comment': 'Is it necessary to process events asynchronously?', 'commenter': 'mytang0'}, {'comment': 'Metrics event processing only has memory operations, and synchronization can avoid complexity', 'commenter': 'wxbty'}]"
11493,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/MetricsEventMulticaster.java,"@@ -21,7 +21,11 @@
 
 public interface MetricsEventMulticaster {
 
-    void addListener(MetricsListener listener);
+    void addListener(MetricsListener<?> listener);
 
-    void publishEvent(MetricsEvent event);
+    void publishEvent(MetricsEvent<?> event);
+
+    void publishFinishEvent(MetricsEvent<?> event);","[{'comment': 'Why is the publish event split into 3 methods? Can it be distinguished by MetricsEvent.Type', 'commenter': 'mytang0'}, {'comment': 'Use eventMulticaster.publishEvent(FinishRegisterEvent) or eventMulticaster.publishFinishEvent(RegisterEvent) to indicate the end of a certain type of event, but the metric buried point scene has three fixed steps. I think publishFinishEvent is more descriptive of the life cycle', 'commenter': 'wxbty'}]"
11493,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/listener/MetricsListener.java,"@@ -17,17 +17,24 @@
 
 package org.apache.dubbo.metrics.listener;
 
+import org.apache.dubbo.common.extension.SPI;
 import org.apache.dubbo.metrics.event.MetricsEvent;
 
 /**
  * Metrics Listener.
  */
-public interface MetricsListener {
+@SPI
+public interface MetricsListener<E extends MetricsEvent<?>> {
+
+    default boolean isSupport(MetricsEvent<?> event) {","[{'comment': 'Please add a comment.', 'commenter': 'mytang0'}]"
11493,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/TimePair.java,"@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.model;
+
+public class TimePair {
+
+    private final long begin;
+    private long end;
+
+    public TimePair(long currentTimeMillis) {","[{'comment': ""Is it more appropriate to change 'public' to 'private'"", 'commenter': 'mytang0'}]"
11493,dubbo-metrics/dubbo-metrics-registry/src/main/java/org/apache/dubbo/metrics/registry/collector/RegistryMetricsCollector.java,"@@ -0,0 +1,134 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.registry.collector;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.config.ReferenceConfigBase;
+import org.apache.dubbo.config.context.ConfigManager;
+import org.apache.dubbo.metrics.collector.ApplicationMetricsCollector;
+import org.apache.dubbo.metrics.collector.MetricsCollector;
+import org.apache.dubbo.metrics.event.MetricsEvent;
+import org.apache.dubbo.metrics.event.MetricsEventMulticaster;
+import org.apache.dubbo.metrics.listener.MetricsLifeListener;
+import org.apache.dubbo.metrics.model.sample.MetricSample;
+import org.apache.dubbo.metrics.registry.collector.stat.RegistryStatComposite;
+import org.apache.dubbo.metrics.registry.event.RegistryEvent;
+import org.apache.dubbo.metrics.registry.event.RegistryMetricsEventMulticaster;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.ConsumerModel;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+
+
+/**
+ * Registry implementation of {@link MetricsCollector}
+ */
+@Activate
+public class RegistryMetricsCollector implements ApplicationMetricsCollector<RegistryEvent.Type>, MetricsLifeListener<RegistryEvent> {
+
+    private Boolean collectEnabled = null;
+    private final RegistryStatComposite stats;
+    private final MetricsEventMulticaster registryMulticaster;
+    private final ApplicationModel applicationModel;
+
+    public RegistryMetricsCollector(ApplicationModel applicationModel) {
+        this.stats = new RegistryStatComposite();
+        this.registryMulticaster = new RegistryMetricsEventMulticaster();
+        this.applicationModel = applicationModel;
+    }
+
+    public void setCollectEnabled(Boolean collectEnabled) {
+        if (collectEnabled != null) {
+            this.collectEnabled = collectEnabled;
+        }
+    }
+
+    public boolean isCollectEnabled() {
+        if (collectEnabled == null) {
+            ConfigManager configManager = applicationModel.getApplicationConfigManager();
+            configManager.getMetrics().ifPresent(metricsConfig -> setCollectEnabled(metricsConfig.getEnableRegistry()));
+        }
+        return Optional.ofNullable(collectEnabled).orElse(false);
+    }
+
+    public void setNum(RegistryEvent.Type registryType, String applicationName, Map<String, Integer> lastNumMap) {
+        lastNumMap.forEach((serviceKey, num) ->
+            this.stats.setServiceKey(registryType, applicationName, serviceKey, num));
+    }
+
+
+    @Override
+    public void increment(RegistryEvent.Type registryType, String applicationName) {
+        this.stats.increment(registryType, applicationName);
+    }
+
+    @Override
+    public void addRT(String applicationName, String registryOpType, Long responseTime) {
+        stats.calcRt(applicationName, registryOpType, responseTime);
+    }
+
+    @Override
+    public List<MetricSample> collect() {
+        if (!isCollectEnabled()) {
+            new ArrayList<>();
+        }
+        List<MetricSample> list = new ArrayList<>();
+        list.addAll(stats.exportNumMetrics());
+        list.addAll(stats.exportRtMetrics());
+        //Dictionary url statistics
+        statsDictionary();
+        list.addAll(stats.exportSkMetrics());
+
+        return list;
+    }
+
+    private void statsDictionary() {
+        Collection<ConsumerModel> consumerModels = applicationModel.getApplicationServiceRepository().allConsumerModels();
+        for (ConsumerModel consumerModel : consumerModels) {
+            ReferenceConfigBase<?> referenceConfig = consumerModel.getReferenceConfig();
+            this.stats.setServiceKey(RegistryEvent.Type.D_TOTAL, applicationModel.getApplicationName(), consumerModel.getServiceKey(), referenceConfig.getInvokerNum());","[{'comment': 'Get invokers size from consumer model.\r\nSee `org.apache.dubbo.qos.command.impl.Ls`.', 'commenter': 'AlbumenJ'}]"
11493,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -772,4 +774,24 @@ public Invoker<?> getInvoker() {
     public Runnable getDestroyRunner() {
         return this::destroy;
     }
+
+    @Override
+    public int getInvokerNum() {
+        Invoker<?> invoker = getInvoker();
+        if (invoker instanceof MigrationInvoker) {
+            AbstractDirectory<?> directory = (AbstractDirectory<?>) ((MigrationInvoker<?>) invoker).getDirectory();
+            return directory.getAllInvokers().size();
+        }
+        return super.getInvokerNum();
+    }
+
+    @Override
+    public int getValidInvokerNum() {
+        Invoker<?> invoker = getInvoker();
+        if (invoker instanceof MigrationInvoker) {
+            AbstractDirectory<?> directory = (AbstractDirectory<?>) ((MigrationInvoker<?>) invoker).getDirectory();
+            return directory.getValidInvokers().size();
+        }
+        return super.getValidInvokerNum();
+    }
 }","[{'comment': '`ReferenceConfig` itself should not depends on `MigrationInvoker`.\r\nGet invokers size from consumer model.\r\nSee `org.apache.dubbo.qos.command.impl.Ls`.', 'commenter': 'AlbumenJ'}]"
11493,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -358,15 +365,33 @@ private void initMetricsService() {
         metricsServiceExporter.init();
     }
 
+    @SuppressWarnings({""rawtypes""})
     private void initMetricsReporter() {
-        DefaultMetricsCollector collector =
-            applicationModel.getFrameworkModel().getBeanFactory().getOrRegisterBean(DefaultMetricsCollector.class);
+
+        ScopeBeanFactory beanFactory = applicationModel.getFrameworkModel().getBeanFactory();
         MetricsConfig metricsConfig = configManager.getMetrics().orElse(null);
+        this.eventMulticaster = beanFactory.getOrRegisterBean(SimpleMetricsEventMulticaster.class);
+
         // TODO compatible with old usage of metrics, remove protocol check after new metrics is ready for use.
         if (metricsConfig != null && PROTOCOL_PROMETHEUS.equals(metricsConfig.getProtocol())) {
+
+            DefaultMetricsCollector collector =
+                beanFactory.getOrRegisterBean(DefaultMetricsCollector.class);
             collector.setCollectEnabled(true);
-            collector.addApplicationInfo(applicationModel.getApplicationName(), Version.getVersion());
+            eventMulticaster.setAvailable();
+
+            List<MetricsListener> metricsListeners = applicationModel.getExtensionLoader(MetricsListener.class)
+                .getActivateExtensions();
+            metricsListeners.forEach(this.eventMulticaster::addListener);
+
+            List<MetricsCollector> customizeCollectors = applicationModel.getExtensionLoader(MetricsCollector.class)
+                .getActivateExtensions();
+            for (MetricsCollector customizeCollector : customizeCollectors) {
+                beanFactory.registerBean(customizeCollector);
+            }","[{'comment': ""Refactor `MetricsListener` and `MetricsCollector` to scope bean. If there is more that one implmentation, introduce a factory to hold `MetricsListener` and `MetricsCollector`. Depends on `tExtensionLoader`'s siglton may cause some unexpected result."", 'commenter': 'AlbumenJ'}]"
11493,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MetricsKey.java,"@@ -54,8 +54,32 @@ public enum MetricsKey {
     THREAD_POOL_ACTIVE_SIZE(""dubbo.thread.pool.active.size"",""Thread Pool Active Size""),
     THREAD_POOL_THREAD_COUNT(""dubbo.thread.pool.thread.count"",""Thread Pool Thread Count""),
     THREAD_POOL_QUEUE_SIZE(""dubbo.thread.pool.queue.size"",""Thread Pool Queue Size""),
+    // register metrics key
+    REGISTER_METRIC_REQUESTS(""dubbo.registry.register.requests.total"", ""Total Register Requests""),
+    REGISTER_METRIC_REQUESTS_SUCCEED(""dubbo.registry.register.requests.succeed.total"", ""Succeed Register Requests""),
+    REGISTER_METRIC_REQUESTS_FAILED(""dubbo.registry.register.requests.failed.total"", ""Failed Register Requests""),
+
+    // subscribe metrics key
+    SUBSCRIBE_METRIC_REQUESTS(""dubbo.registry.subscribe.requests.total"", ""Total Subscribe Requests""),
+    SUBSCRIBE_METRIC_REQUESTS_SUCCEED(""dubbo.registry.subscribe.requests.succeed.total"", ""Succeed Subscribe Requests""),
+    SUBSCRIBE_METRIC_REQUESTS_FAILED(""dubbo.registry.subscribe.requests.failed.total"", ""Failed Subscribe Requests""),","[{'comment': '这里不是要记录什么时候订阅，而是记录在某个时间点下总共有多少个订阅数已经提交了', 'commenter': 'AlbumenJ'}]"
11493,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MetricsKey.java,"@@ -54,8 +54,32 @@ public enum MetricsKey {
     THREAD_POOL_ACTIVE_SIZE(""dubbo.thread.pool.active.size"",""Thread Pool Active Size""),
     THREAD_POOL_THREAD_COUNT(""dubbo.thread.pool.thread.count"",""Thread Pool Thread Count""),
     THREAD_POOL_QUEUE_SIZE(""dubbo.thread.pool.queue.size"",""Thread Pool Queue Size""),
+    // register metrics key
+    REGISTER_METRIC_REQUESTS(""dubbo.registry.register.requests.total"", ""Total Register Requests""),
+    REGISTER_METRIC_REQUESTS_SUCCEED(""dubbo.registry.register.requests.succeed.total"", ""Succeed Register Requests""),
+    REGISTER_METRIC_REQUESTS_FAILED(""dubbo.registry.register.requests.failed.total"", ""Failed Register Requests""),
+
+    // subscribe metrics key
+    SUBSCRIBE_METRIC_REQUESTS(""dubbo.registry.subscribe.requests.total"", ""Total Subscribe Requests""),
+    SUBSCRIBE_METRIC_REQUESTS_SUCCEED(""dubbo.registry.subscribe.requests.succeed.total"", ""Succeed Subscribe Requests""),
+    SUBSCRIBE_METRIC_REQUESTS_FAILED(""dubbo.registry.subscribe.requests.failed.total"", ""Failed Subscribe Requests""),
+
+    // directory metrics key
+    DIRECTORY_METRIC_NUM(""dubbo.registry.directory.num.total"", ""Total directory urls""),
+    DIRECTORY_METRIC_NUM_VALID(""dubbo.registry.directory.num.valid.total"", ""Valid directory urls""),
+    DIRECTORY_METRIC_NUM_UN_VALID(""dubbo.registry.directory.num.un_valid.total"", ""UnValid directory urls""),","[{'comment': 'Collect total, valid, invokersToReconnect, disabledInvokers count', 'commenter': 'AlbumenJ'}]"
11513,NOTICE,"@@ -4,11 +4,35 @@ Copyright 2018-2023 The Apache Software Foundation
 This product includes software developed at
 The Apache Software Foundation (http://www.apache.org/).
 
-This product contains code form the Netty Project:
+This product contains code from the Netty Project:
 
 The Netty Project
 =================
 Please visit the Netty web site for more information:
   * http://netty.io/
 
 Copyright 2014 The Netty Project
+
+This product contains code from The Project Lombok, which is licensed under MIT License:
+
+/*
+ * Copyright (C) 2018-2021 The Project Lombok Authors.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the ""Software""), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */","[{'comment': 'No need to add notice if there is not NOTICE file in https://github.com/projectlombok/lombok.', 'commenter': 'AlbumenJ'}]"
11513,dubbo-annotation-processor/src/main/java/org/apache/dubbo/annotation/handler/DeprecatedHandler.java,"@@ -0,0 +1,247 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.annotation.handler;
+
+import org.apache.dubbo.annotation.AnnotationProcessingHandler;
+import org.apache.dubbo.annotation.AnnotationProcessorContext;
+import org.apache.dubbo.annotation.constant.DeprecatedHandlerConstants;
+import org.apache.dubbo.annotation.util.ASTUtils;
+
+import com.sun.tools.javac.code.Flags;
+import com.sun.tools.javac.code.Symbol;
+import com.sun.tools.javac.code.Types;
+import com.sun.tools.javac.tree.JCTree;
+import com.sun.tools.javac.tree.TreeMaker;
+import com.sun.tools.javac.tree.TreeTranslator;
+import com.sun.tools.javac.util.List;
+import com.sun.tools.javac.util.ListBuffer;
+
+import javax.lang.model.element.Element;
+import java.lang.annotation.Annotation;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Handles @Deprecated annotation and adds logger warn call to the methods that are annotated with it.
+ */
+public class DeprecatedHandler implements AnnotationProcessingHandler {
+
+    @Override
+    public Set<Class<? extends Annotation>> getAnnotationsToHandle() {
+        return new HashSet<>(
+            Collections.singletonList(Deprecated.class)
+        );
+    }
+
+    @Override
+    public void process(Set<Element> elements, AnnotationProcessorContext apContext) {
+        for (Element element : elements) {
+            // Only interested in methods.
+            if (!(element instanceof Symbol.MethodSymbol)) {
+                continue;
+            }
+
+            Symbol.ClassSymbol classSymbol = (Symbol.ClassSymbol) element.getEnclosingElement();
+
+            ASTUtils.addImportStatement(apContext, classSymbol, ""org.apache.dubbo.common.logger"", ""LoggerFactory"");
+            ASTUtils.addImportStatement(apContext, classSymbol, ""org.apache.dubbo.common.logger"", ""ErrorTypeAwareLogger"");
+            ASTUtils.addImportStatement(apContext, classSymbol, ""org.apache.dubbo.common"", ""DeprecatedMethodInvocationCounter"");","[{'comment': 'Just insert `DeprecatedMethodCollector.collect(xxx)` here. Log and count in `DeprecatedMethodCollector.collect`.', 'commenter': 'AlbumenJ'}]"
11513,dubbo-annotation-processor/src/main/java/org/apache/dubbo/annotation/permit/Permit.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.annotation.permit;
+
+/*
+ * Authored by Project Lombok and licensed by MIT License, which is attached below:
+ *
+ * Copyright (C) 2018-2021 The Project Lombok Authors.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the ""Software""), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */","[{'comment': 'Leave the origin license here and add exclude in license checker.', 'commenter': 'AlbumenJ'}]"
11517,dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/MetadataInfoTest.java,"@@ -31,11 +31,7 @@
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static org.apache.dubbo.common.constants.CommonConstants.APPLICATION_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;
-import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;
+import static org.apache.dubbo.common.constants.CommonConstants.*;","[{'comment': 'Do not use comma import.\r\nYou can import ide code style config in `codestyle` folder.', 'commenter': 'AlbumenJ'}, {'comment': 'Ok, this problem has been fixed in  [164e31c]', 'commenter': 'mytang0'}, {'comment': 'dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/MetadataInfoTest.java', 'commenter': 'AlbumenJ'}, {'comment': ""> MetadataInfoTest\r\n\r\nSorry, I'll fix it right away."", 'commenter': 'mytang0'}, {'comment': 'Done, submitted.', 'commenter': 'mytang0'}]"
11517,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/header/HeaderExchangeChannel.java,"@@ -126,11 +126,16 @@ public CompletableFuture<Object> request(Object request, int timeout, ExecutorSe
         if (closed) {
             throw new RemotingException(this.getLocalAddress(), null, ""Failed to send request "" + request + "", cause: The channel "" + this + "" is closed!"");
         }
-        // create request.
-        Request req = new Request();
-        req.setVersion(Version.getProtocolVersion());
-        req.setTwoWay(true);
-        req.setData(request);
+        Request req;
+        if (request instanceof Request) {
+            req = (Request) request;
+        } else {
+            // create request.
+            req = new Request();
+            req.setVersion(Version.getProtocolVersion());
+            req.setTwoWay(true);
+            req.setData(request);","[{'comment': 'What is the purpose of changing this?', 'commenter': 'AlbumenJ'}, {'comment': '> What is the purpose of changing this?\r\n\r\nIn order to get the payload on the provider side, I added an attribute to the Request. The value of payload will be set in DubboInvoker.', 'commenter': 'mytang0'}]"
11517,dubbo-common/src/main/java/org/apache/dubbo/config/annotation/DubboService.java,"@@ -323,4 +323,9 @@
      * @return
      */
     String executor() default """";
+
+    /**
+     * Payload max length.
+     */
+    String payload() default """";","[{'comment': 'Why not use the int type, consistent with the previous one?', 'commenter': 'wxbty'}, {'comment': '> Why not use the int type, consistent with the previous one?\r\n\r\nThank you. Yes, I started using int and later made changes to be consistent with dubbo.xsd\r\n', 'commenter': 'mytang0'}]"
11517,dubbo-demo/dubbo-demo-annotation/dubbo-demo-annotation-provider/src/main/java/org/apache/dubbo/demo/provider/DemoServiceImpl.java,"@@ -25,7 +25,7 @@
 
 import java.util.concurrent.CompletableFuture;
 
-@DubboService
+@DubboService(payload = ""1024"")","[{'comment': 'No need to add the usage method in the demo.\r\n', 'commenter': 'CrazyHZM'}, {'comment': 'Ok, i fix', 'commenter': 'mytang0'}]"
11517,dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-provider/src/main/resources/spring/dubbo-provider.xml,"@@ -44,5 +44,8 @@
                    ref=""restDemoService"" protocol=""rest""/>
     <dubbo:service delay=""5000"" version=""1.0.0"" timeout=""5000"" interface=""org.apache.dubbo.demo.TripleService""
                    ref=""tripleService"" protocol=""tri""/>
+    <dubbo:service delay=""5000"" version=""2.0.0"" group=""greeting"" timeout=""5000""
+                   interface=""org.apache.dubbo.demo.GreetingService""
+                   ref=""greetingService"" protocol=""dubbo"" payload=""1024""/>","[{'comment': 'the same as above.\r\n', 'commenter': 'CrazyHZM'}]"
11521,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/GrpcHttp2Protocol.java,"@@ -0,0 +1,7 @@
+package org.apache.dubbo.rpc.protocol.tri;","[{'comment': 'Missing Apache License header here.', 'commenter': 'chickenlj'}, {'comment': 'Also the following 3 files.', 'commenter': 'chickenlj'}]"
11522,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -772,4 +774,26 @@ public Invoker<?> getInvoker() {
     public Runnable getDestroyRunner() {
         return this::destroy;
     }
+
+    @Override
+    @Parameter(excluded = true, attribute = false)
+    public int getInvokerNum() {
+        Invoker<?> invoker = getInvoker();
+        if (invoker instanceof MigrationInvoker) {
+            AbstractDirectory<?> directory = (AbstractDirectory<?>) ((MigrationInvoker<?>) invoker).getDirectory();
+            return directory.getAllInvokers().size();
+        }
+        return super.getInvokerNum();
+    }
+
+    @Override
+    @Parameter(excluded = true, attribute = false)
+    public int getValidInvokerNum() {
+        Invoker<?> invoker = getInvoker();
+        if (invoker instanceof MigrationInvoker) {
+            AbstractDirectory<?> directory = (AbstractDirectory<?>) ((MigrationInvoker<?>) invoker).getDirectory();
+            return directory.getValidInvokers().size();
+        }
+        return super.getValidInvokerNum();
+    }","[{'comment': 'https://github.com/apache/dubbo/pull/11493#pullrequestreview-1296730732', 'commenter': 'AlbumenJ'}]"
11522,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -357,13 +363,27 @@ private void initMetricsService() {
         metricsServiceExporter.init();
     }
 
+    @SuppressWarnings({""rawtypes""})
     private void initMetricsReporter() {
-        DefaultMetricsCollector collector =
-            applicationModel.getFrameworkModel().getBeanFactory().getOrRegisterBean(DefaultMetricsCollector.class);
+        ScopeBeanFactory beanFactory = applicationModel.getFrameworkModel().getBeanFactory();
+        DefaultMetricsCollector collector = beanFactory.getOrRegisterBean(DefaultMetricsCollector.class);
         MetricsConfig metricsConfig = configManager.getMetrics().orElse(null);
+        this.eventMulticaster = beanFactory.getOrRegisterBean(SimpleMetricsEventMulticaster.class);
+
         // TODO compatible with old usage of metrics, remove protocol check after new metrics is ready for use.
         if (metricsConfig != null && PROTOCOL_PROMETHEUS.equals(metricsConfig.getProtocol())) {
             collector.setCollectEnabled(true);
+
+            List<MetricsListener> metricsListeners = applicationModel.getExtensionLoader(MetricsListener.class)
+                .getActivateExtensions();
+            metricsListeners.forEach(this.eventMulticaster::addListener);
+
+            List<MetricsCollector> customizeCollectors = applicationModel.getExtensionLoader(MetricsCollector.class)
+                .getActivateExtensions();
+            for (MetricsCollector customizeCollector : customizeCollectors) {
+                beanFactory.registerBean(customizeCollector);
+            }
+","[{'comment': 'https://github.com/apache/dubbo/pull/11493#pullrequestreview-1296730732', 'commenter': 'AlbumenJ'}]"
11522,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -358,9 +363,11 @@ private void initMetricsService() {
     }
 
     private void initMetricsReporter() {
-        DefaultMetricsCollector collector =
-            applicationModel.getFrameworkModel().getBeanFactory().getOrRegisterBean(DefaultMetricsCollector.class);
+        ScopeBeanFactory beanFactory = applicationModel.getFrameworkModel().getBeanFactory();
+        DefaultMetricsCollector collector = beanFactory.getOrRegisterBean(DefaultMetricsCollector.class);
         MetricsConfig metricsConfig = configManager.getMetrics().orElse(null);
+        beanFactory.registerBean(GlobalMetricsEventMulticaster.class);
+","[{'comment': 'Move to `org.apache.dubbo.rpc.model.ScopeModelInitializer` like `org.apache.dubbo.config.ConfigScopeModelInitializer`, `org.apache.dubbo.registry.RegistryScopeModelInitializer` and `org.apache.dubbo.common.CommonScopeModelInitializer`.', 'commenter': 'AlbumenJ'}]"
11522,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/GlobalMetricsEventMulticaster.java,"@@ -0,0 +1,42 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.event;
+
+import org.apache.dubbo.common.beans.factory.ScopeBeanFactory;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.metrics.collector.MetricsCollector;
+import org.apache.dubbo.rpc.model.FrameworkModel;
+
+import java.util.List;
+
+public class GlobalMetricsEventMulticaster extends SimpleMetricsEventMulticaster {
+
+    public GlobalMetricsEventMulticaster(FrameworkModel frameworkModel) {
+        ScopeBeanFactory beanFactory = frameworkModel.getBeanFactory();
+        ExtensionLoader<MetricsCollector> extensionLoader = frameworkModel.getExtensionLoader(MetricsCollector.class);
+        if (extensionLoader != null) {
+            List<MetricsCollector> customizeCollectors = extensionLoader
+                .getActivateExtensions();
+            for (MetricsCollector customizeCollector : customizeCollectors) {
+                beanFactory.registerBean(customizeCollector);","[{'comment': 'Why register to beanFactory?', 'commenter': 'AlbumenJ'}, {'comment': 'Here (AbstractMetricsReporter.java) can be obtained dynamically,\r\nwas hardcoded before', 'commenter': 'wxbty'}]"
11531,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"@@ -420,8 +420,9 @@ private Map<String, String> appendConfig() {
 
     @SuppressWarnings({""unchecked""})
     private T createProxy(Map<String, String> referenceParameters) {
+        URL curUrl;
         if (shouldJvmRefer(referenceParameters)) {
-            createInvokerForLocal(referenceParameters);
+            curUrl = createInvokerForLocal(referenceParameters);","[{'comment': 'Remove create local invoker here', 'commenter': 'AlbumenJ'}, {'comment': 'done\r\n', 'commenter': 'Phixsura'}]"
11531,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java,"@@ -0,0 +1,191 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.cluster.support.wrapper;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.url.component.ServiceConfigURL;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.rpc.Exporter;
+import org.apache.dubbo.rpc.ExporterListener;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.ClusterInvoker;
+import org.apache.dubbo.rpc.cluster.Directory;
+import org.apache.dubbo.rpc.listener.ExporterChangeListener;
+import org.apache.dubbo.rpc.listener.InjvmExporterListener;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static org.apache.dubbo.rpc.Constants.GENERIC_KEY;
+import static org.apache.dubbo.rpc.Constants.LOCAL_PROTOCOL;
+import static org.apache.dubbo.rpc.Constants.SCOPE_KEY;
+import static org.apache.dubbo.rpc.Constants.SCOPE_REMOTE;
+import static org.apache.dubbo.rpc.Constants.SCOPE_LOCAL;
+import static org.apache.dubbo.rpc.cluster.Constants.PEER_KEY;
+
+/**
+ * A ClusterInvoker that selects between local and remote invokers at runtime.
+ */
+public class ScopeClusterInvoker<T> implements ClusterInvoker<T>, ExporterChangeListener {
+
+    private Protocol protocolSPI;
+    private final Directory<T> directory;
+    private final Invoker<T> invoker;
+    private final AtomicBoolean isExported;
+    private volatile Invoker<T> injvmInvoker;
+    private volatile InjvmExporterListener injvmExporterListener;
+
+    private final Object createLock = new Object();
+
+
+    public ScopeClusterInvoker(Directory<T> directory, Invoker<T> invoker) {
+        this.directory = directory;
+        this.invoker = invoker;
+        this.isExported = new AtomicBoolean(false);
+        init();
+    }
+
+    private void init() {
+        if (injvmInvoker == null && LOCAL_PROTOCOL.equals(getRegistryUrl().getProtocol())) {
+            isExported.compareAndSet(false, true);
+            injvmInvoker = invoker;
+        }
+        protocolSPI = getUrl().getApplicationModel().getExtensionLoader(Protocol.class).getAdaptiveExtension();
+        injvmExporterListener = (InjvmExporterListener) getUrl().getApplicationModel().getExtensionLoader(ExporterListener.class).getExtension(""injvm"");
+        injvmExporterListener.addExporterChangeListener(this, getUrl().getServiceKey());
+    }
+
+    @Override
+    public URL getUrl() {
+        return directory.getConsumerUrl();
+    }
+
+    @Override
+    public URL getRegistryUrl() {
+        return directory.getUrl();
+    }
+
+    @Override
+    public Directory<T> getDirectory() {
+        return directory;
+    }
+
+    @Override
+    public boolean isDestroyed() {
+        return directory.isDestroyed();
+    }
+
+    @Override
+    public boolean isAvailable() {
+        if (injvmExporterListener == null) {
+            injvmExporterListener = (InjvmExporterListener) getUrl().getApplicationModel().getExtensionLoader(ExporterListener.class).getExtension(LOCAL_PROTOCOL);
+        }
+        injvmExporterListener.addExporterChangeListener(this, getUrl().getServiceKey());
+        return isExported.get() || directory.isAvailable();
+    }
+
+    @Override
+    public void destroy() {
+        if (injvmExporterListener != null) {
+            injvmExporterListener.removeExporterChangeListener(getUrl().getServiceKey());
+        }
+        this.invoker.destroy();
+    }
+
+    @Override
+    public Class<T> getInterface() {
+        return directory.getInterface();
+    }
+
+    @Override
+    public Result invoke(Invocation invocation) throws RpcException {
+        Boolean peer = (Boolean) getUrl().getAttribute(PEER_KEY);
+        if (peer != null && peer) {
+            return invoker.invoke(invocation);
+        }
+        String scope = getUrl().getParameter(SCOPE_KEY);
+        if (shouldInvokeInjvm(getUrl().getParameter(LOCAL_PROTOCOL), scope)) {","[{'comment': '`peer`, `scope` 和 `local` 这几个 key 的判断是不是可以提前到 init 做', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'Phixsura'}]"
11531,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java,"@@ -0,0 +1,191 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.cluster.support.wrapper;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.url.component.ServiceConfigURL;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.rpc.Exporter;
+import org.apache.dubbo.rpc.ExporterListener;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.ClusterInvoker;
+import org.apache.dubbo.rpc.cluster.Directory;
+import org.apache.dubbo.rpc.listener.ExporterChangeListener;
+import org.apache.dubbo.rpc.listener.InjvmExporterListener;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static org.apache.dubbo.rpc.Constants.GENERIC_KEY;
+import static org.apache.dubbo.rpc.Constants.LOCAL_PROTOCOL;
+import static org.apache.dubbo.rpc.Constants.SCOPE_KEY;
+import static org.apache.dubbo.rpc.Constants.SCOPE_REMOTE;
+import static org.apache.dubbo.rpc.Constants.SCOPE_LOCAL;
+import static org.apache.dubbo.rpc.cluster.Constants.PEER_KEY;
+
+/**
+ * A ClusterInvoker that selects between local and remote invokers at runtime.
+ */
+public class ScopeClusterInvoker<T> implements ClusterInvoker<T>, ExporterChangeListener {
+
+    private Protocol protocolSPI;
+    private final Directory<T> directory;
+    private final Invoker<T> invoker;
+    private final AtomicBoolean isExported;
+    private volatile Invoker<T> injvmInvoker;
+    private volatile InjvmExporterListener injvmExporterListener;
+
+    private final Object createLock = new Object();
+
+
+    public ScopeClusterInvoker(Directory<T> directory, Invoker<T> invoker) {
+        this.directory = directory;
+        this.invoker = invoker;
+        this.isExported = new AtomicBoolean(false);
+        init();
+    }
+
+    private void init() {
+        if (injvmInvoker == null && LOCAL_PROTOCOL.equals(getRegistryUrl().getProtocol())) {
+            isExported.compareAndSet(false, true);
+            injvmInvoker = invoker;
+        }
+        protocolSPI = getUrl().getApplicationModel().getExtensionLoader(Protocol.class).getAdaptiveExtension();
+        injvmExporterListener = (InjvmExporterListener) getUrl().getApplicationModel().getExtensionLoader(ExporterListener.class).getExtension(""injvm"");
+        injvmExporterListener.addExporterChangeListener(this, getUrl().getServiceKey());
+    }
+
+    @Override
+    public URL getUrl() {
+        return directory.getConsumerUrl();
+    }
+
+    @Override
+    public URL getRegistryUrl() {
+        return directory.getUrl();
+    }
+
+    @Override
+    public Directory<T> getDirectory() {
+        return directory;
+    }
+
+    @Override
+    public boolean isDestroyed() {
+        return directory.isDestroyed();
+    }
+
+    @Override
+    public boolean isAvailable() {
+        if (injvmExporterListener == null) {
+            injvmExporterListener = (InjvmExporterListener) getUrl().getApplicationModel().getExtensionLoader(ExporterListener.class).getExtension(LOCAL_PROTOCOL);
+        }
+        injvmExporterListener.addExporterChangeListener(this, getUrl().getServiceKey());
+        return isExported.get() || directory.isAvailable();
+    }
+
+    @Override
+    public void destroy() {
+        if (injvmExporterListener != null) {
+            injvmExporterListener.removeExporterChangeListener(getUrl().getServiceKey());
+        }
+        this.invoker.destroy();
+    }
+
+    @Override
+    public Class<T> getInterface() {
+        return directory.getInterface();
+    }
+
+    @Override
+    public Result invoke(Invocation invocation) throws RpcException {
+        Boolean peer = (Boolean) getUrl().getAttribute(PEER_KEY);
+        if (peer != null && peer) {
+            return invoker.invoke(invocation);
+        }
+        String scope = getUrl().getParameter(SCOPE_KEY);
+        if (shouldInvokeInjvm(getUrl().getParameter(LOCAL_PROTOCOL), scope)) {
+            return injvmInvoker.invoke(invocation);
+        }
+        return invoker.invoke(invocation);
+    }
+
+    private boolean shouldInvokeInjvm(String isInjvm, String scope) {
+        if (Boolean.TRUE.toString().equals(isInjvm)) {","[{'comment': 'equalsIgnoreCase', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'Phixsura'}]"
11531,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java,"@@ -0,0 +1,191 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.cluster.support.wrapper;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.url.component.ServiceConfigURL;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.rpc.Exporter;
+import org.apache.dubbo.rpc.ExporterListener;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.ClusterInvoker;
+import org.apache.dubbo.rpc.cluster.Directory;
+import org.apache.dubbo.rpc.listener.ExporterChangeListener;
+import org.apache.dubbo.rpc.listener.InjvmExporterListener;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static org.apache.dubbo.rpc.Constants.GENERIC_KEY;
+import static org.apache.dubbo.rpc.Constants.LOCAL_PROTOCOL;
+import static org.apache.dubbo.rpc.Constants.SCOPE_KEY;
+import static org.apache.dubbo.rpc.Constants.SCOPE_REMOTE;
+import static org.apache.dubbo.rpc.Constants.SCOPE_LOCAL;
+import static org.apache.dubbo.rpc.cluster.Constants.PEER_KEY;
+
+/**
+ * A ClusterInvoker that selects between local and remote invokers at runtime.
+ */
+public class ScopeClusterInvoker<T> implements ClusterInvoker<T>, ExporterChangeListener {
+
+    private Protocol protocolSPI;
+    private final Directory<T> directory;
+    private final Invoker<T> invoker;
+    private final AtomicBoolean isExported;
+    private volatile Invoker<T> injvmInvoker;
+    private volatile InjvmExporterListener injvmExporterListener;
+
+    private final Object createLock = new Object();
+
+
+    public ScopeClusterInvoker(Directory<T> directory, Invoker<T> invoker) {
+        this.directory = directory;
+        this.invoker = invoker;
+        this.isExported = new AtomicBoolean(false);
+        init();
+    }
+
+    private void init() {
+        if (injvmInvoker == null && LOCAL_PROTOCOL.equals(getRegistryUrl().getProtocol())) {
+            isExported.compareAndSet(false, true);
+            injvmInvoker = invoker;
+        }
+        protocolSPI = getUrl().getApplicationModel().getExtensionLoader(Protocol.class).getAdaptiveExtension();
+        injvmExporterListener = (InjvmExporterListener) getUrl().getApplicationModel().getExtensionLoader(ExporterListener.class).getExtension(""injvm"");
+        injvmExporterListener.addExporterChangeListener(this, getUrl().getServiceKey());
+    }
+
+    @Override
+    public URL getUrl() {
+        return directory.getConsumerUrl();
+    }
+
+    @Override
+    public URL getRegistryUrl() {
+        return directory.getUrl();
+    }
+
+    @Override
+    public Directory<T> getDirectory() {
+        return directory;
+    }
+
+    @Override
+    public boolean isDestroyed() {
+        return directory.isDestroyed();
+    }
+
+    @Override
+    public boolean isAvailable() {
+        if (injvmExporterListener == null) {
+            injvmExporterListener = (InjvmExporterListener) getUrl().getApplicationModel().getExtensionLoader(ExporterListener.class).getExtension(LOCAL_PROTOCOL);
+        }
+        injvmExporterListener.addExporterChangeListener(this, getUrl().getServiceKey());
+        return isExported.get() || directory.isAvailable();
+    }
+
+    @Override
+    public void destroy() {
+        if (injvmExporterListener != null) {
+            injvmExporterListener.removeExporterChangeListener(getUrl().getServiceKey());
+        }
+        this.invoker.destroy();
+    }
+
+    @Override
+    public Class<T> getInterface() {
+        return directory.getInterface();
+    }
+
+    @Override
+    public Result invoke(Invocation invocation) throws RpcException {
+        Boolean peer = (Boolean) getUrl().getAttribute(PEER_KEY);
+        if (peer != null && peer) {
+            return invoker.invoke(invocation);
+        }
+        String scope = getUrl().getParameter(SCOPE_KEY);
+        if (shouldInvokeInjvm(getUrl().getParameter(LOCAL_PROTOCOL), scope)) {
+            return injvmInvoker.invoke(invocation);
+        }
+        return invoker.invoke(invocation);
+    }
+
+    private boolean shouldInvokeInjvm(String isInjvm, String scope) {
+        if (Boolean.TRUE.toString().equals(isInjvm)) {
+            return isInjvmExported(scope);
+        } else if (isInjvm == null) {
+            return isInjvmExportedAndNotRemoteOrGeneric(scope);
+        }
+        return false;
+    }
+
+    private boolean isInjvmExportedAndNotRemoteOrGeneric(String scope) {
+        return !SCOPE_REMOTE.equalsIgnoreCase(scope) &&
+            !getUrl().getParameter(GENERIC_KEY, false) && isInjvmExported(scope);
+    }
+
+    private boolean isInjvmExported(String scope) {
+        if (!isExported.get() && SCOPE_LOCAL.equalsIgnoreCase(scope)) {
+            throw new RpcException(""Local service has not been exposed yet!"");
+        }
+        return isExported.get();
+    }
+
+
+    private Invoker<T> createInjvmInvoker() {
+        URL url = new ServiceConfigURL(LOCAL_PROTOCOL, NetUtils.getLocalHost(), getUrl().getPort(), getInterface().getName(), getUrl().getParameters());
+        url = url.setScopeModel(getUrl().getScopeModel());
+        url = url.setServiceModel(getUrl().getServiceModel());
+        return protocolSPI.refer(getInterface(), url);
+    }
+
+    @Override
+    public void onExporterChangeExport(Exporter<?> exporter) {
+        if (isExported.get()) {
+            return;
+        }
+        if (getUrl().getServiceKey().equals(exporter.getInvoker().getUrl().getServiceKey())
+            && exporter.getInvoker().getUrl().getProtocol().equals(LOCAL_PROTOCOL)) {
+            isExported.compareAndSet(false, true);
+        }
+        if (isExported.get() && injvmInvoker == null) {
+            if (injvmInvoker == null) {
+                synchronized (createLock) {
+                    if (injvmInvoker == null) {
+                        injvmInvoker = createInjvmInvoker();
+                    }
+                }
+            }
+        }","[{'comment': '这里的时序问题可能导致 invoke 的时候 NPE', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'Phixsura'}]"
11531,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java,"@@ -0,0 +1,191 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.cluster.support.wrapper;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.url.component.ServiceConfigURL;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.rpc.Exporter;
+import org.apache.dubbo.rpc.ExporterListener;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.ClusterInvoker;
+import org.apache.dubbo.rpc.cluster.Directory;
+import org.apache.dubbo.rpc.listener.ExporterChangeListener;
+import org.apache.dubbo.rpc.listener.InjvmExporterListener;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static org.apache.dubbo.rpc.Constants.GENERIC_KEY;
+import static org.apache.dubbo.rpc.Constants.LOCAL_PROTOCOL;
+import static org.apache.dubbo.rpc.Constants.SCOPE_KEY;
+import static org.apache.dubbo.rpc.Constants.SCOPE_REMOTE;
+import static org.apache.dubbo.rpc.Constants.SCOPE_LOCAL;
+import static org.apache.dubbo.rpc.cluster.Constants.PEER_KEY;
+
+/**
+ * A ClusterInvoker that selects between local and remote invokers at runtime.
+ */
+public class ScopeClusterInvoker<T> implements ClusterInvoker<T>, ExporterChangeListener {
+
+    private Protocol protocolSPI;
+    private final Directory<T> directory;
+    private final Invoker<T> invoker;
+    private final AtomicBoolean isExported;
+    private volatile Invoker<T> injvmInvoker;
+    private volatile InjvmExporterListener injvmExporterListener;
+
+    private final Object createLock = new Object();
+
+
+    public ScopeClusterInvoker(Directory<T> directory, Invoker<T> invoker) {
+        this.directory = directory;
+        this.invoker = invoker;
+        this.isExported = new AtomicBoolean(false);
+        init();
+    }
+
+    private void init() {
+        if (injvmInvoker == null && LOCAL_PROTOCOL.equals(getRegistryUrl().getProtocol())) {
+            isExported.compareAndSet(false, true);
+            injvmInvoker = invoker;
+        }
+        protocolSPI = getUrl().getApplicationModel().getExtensionLoader(Protocol.class).getAdaptiveExtension();
+        injvmExporterListener = (InjvmExporterListener) getUrl().getApplicationModel().getExtensionLoader(ExporterListener.class).getExtension(""injvm"");
+        injvmExporterListener.addExporterChangeListener(this, getUrl().getServiceKey());
+    }
+
+    @Override
+    public URL getUrl() {
+        return directory.getConsumerUrl();
+    }
+
+    @Override
+    public URL getRegistryUrl() {
+        return directory.getUrl();
+    }
+
+    @Override
+    public Directory<T> getDirectory() {
+        return directory;
+    }
+
+    @Override
+    public boolean isDestroyed() {
+        return directory.isDestroyed();
+    }
+
+    @Override
+    public boolean isAvailable() {
+        if (injvmExporterListener == null) {
+            injvmExporterListener = (InjvmExporterListener) getUrl().getApplicationModel().getExtensionLoader(ExporterListener.class).getExtension(LOCAL_PROTOCOL);
+        }
+        injvmExporterListener.addExporterChangeListener(this, getUrl().getServiceKey());
+        return isExported.get() || directory.isAvailable();
+    }
+
+    @Override
+    public void destroy() {
+        if (injvmExporterListener != null) {
+            injvmExporterListener.removeExporterChangeListener(getUrl().getServiceKey());
+        }
+        this.invoker.destroy();
+    }
+
+    @Override
+    public Class<T> getInterface() {
+        return directory.getInterface();
+    }
+
+    @Override
+    public Result invoke(Invocation invocation) throws RpcException {
+        Boolean peer = (Boolean) getUrl().getAttribute(PEER_KEY);
+        if (peer != null && peer) {
+            return invoker.invoke(invocation);
+        }
+        String scope = getUrl().getParameter(SCOPE_KEY);
+        if (shouldInvokeInjvm(getUrl().getParameter(LOCAL_PROTOCOL), scope)) {
+            return injvmInvoker.invoke(invocation);
+        }
+        return invoker.invoke(invocation);
+    }
+
+    private boolean shouldInvokeInjvm(String isInjvm, String scope) {
+        if (Boolean.TRUE.toString().equals(isInjvm)) {
+            return isInjvmExported(scope);
+        } else if (isInjvm == null) {
+            return isInjvmExportedAndNotRemoteOrGeneric(scope);
+        }
+        return false;
+    }
+
+    private boolean isInjvmExportedAndNotRemoteOrGeneric(String scope) {
+        return !SCOPE_REMOTE.equalsIgnoreCase(scope) &&
+            !getUrl().getParameter(GENERIC_KEY, false) && isInjvmExported(scope);
+    }
+
+    private boolean isInjvmExported(String scope) {
+        if (!isExported.get() && SCOPE_LOCAL.equalsIgnoreCase(scope)) {
+            throw new RpcException(""Local service has not been exposed yet!"");
+        }
+        return isExported.get();
+    }
+
+
+    private Invoker<T> createInjvmInvoker() {
+        URL url = new ServiceConfigURL(LOCAL_PROTOCOL, NetUtils.getLocalHost(), getUrl().getPort(), getInterface().getName(), getUrl().getParameters());
+        url = url.setScopeModel(getUrl().getScopeModel());
+        url = url.setServiceModel(getUrl().getServiceModel());
+        return protocolSPI.refer(getInterface(), url);
+    }
+
+    @Override
+    public void onExporterChangeExport(Exporter<?> exporter) {
+        if (isExported.get()) {
+            return;
+        }
+        if (getUrl().getServiceKey().equals(exporter.getInvoker().getUrl().getServiceKey())
+            && exporter.getInvoker().getUrl().getProtocol().equals(LOCAL_PROTOCOL)) {
+            isExported.compareAndSet(false, true);
+        }
+        if (isExported.get() && injvmInvoker == null) {
+            if (injvmInvoker == null) {
+                synchronized (createLock) {
+                    if (injvmInvoker == null) {
+                        injvmInvoker = createInjvmInvoker();
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public void onExporterChangeUnExport(Exporter<?> exporter) {
+        if (getUrl().getServiceKey().equals(exporter.getInvoker().getUrl().getServiceKey())
+            && exporter.getInvoker().getUrl().getProtocol().equals(LOCAL_PROTOCOL)) {
+            isExported.compareAndSet(true, false);","[{'comment': '需要销毁已有的 injvmInvoker', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'Phixsura'}]"
11531,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/listener/InjvmExporterListener.java,"@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.listener;
+
+import org.apache.dubbo.rpc.Exporter;
+import org.apache.dubbo.rpc.RpcException;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class InjvmExporterListener extends ExporterListenerAdapter {
+
+    private final Map<String, ExporterChangeListener> exporterChangeListeners = new ConcurrentHashMap<>();
+
+    private final Map<String, Exporter<?>> exporters = new ConcurrentHashMap<>();
+
+    @Override
+    public void exported(Exporter<?> exporter) throws RpcException {
+        String serviceKey = exporter.getInvoker().getUrl().getServiceKey();
+        exporters.putIfAbsent(exporter.getInvoker().getUrl().getServiceKey(), exporter);","[{'comment': '需要考虑同一个服务多订阅的情况', 'commenter': 'AlbumenJ'}, {'comment': '这里不应该是只考虑本地调用吗，也不需要经过网络传输，InjvmExporter 只会被当前的服务引用所订阅，理应不会出现多个订阅者的情况。而且每个服务只会暴露一个 InjvmExporter 实例，因此也不存在同一个服务多个 InjvmExporter 实例的情况', 'commenter': 'Phixsura'}, {'comment': 'done', 'commenter': 'Phixsura'}]"
11531,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java,"@@ -0,0 +1,211 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.cluster.support.wrapper;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.url.component.ServiceConfigURL;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.rpc.Exporter;
+import org.apache.dubbo.rpc.ExporterListener;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.Cluster;
+import org.apache.dubbo.rpc.cluster.ClusterInvoker;
+import org.apache.dubbo.rpc.cluster.Directory;
+import org.apache.dubbo.rpc.cluster.directory.StaticDirectory;
+import org.apache.dubbo.rpc.listener.ExporterChangeListener;
+import org.apache.dubbo.rpc.listener.InjvmExporterListener;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static org.apache.dubbo.rpc.Constants.GENERIC_KEY;
+import static org.apache.dubbo.rpc.Constants.LOCAL_KEY;
+import static org.apache.dubbo.rpc.Constants.LOCAL_PROTOCOL;
+import static org.apache.dubbo.rpc.Constants.SCOPE_KEY;
+import static org.apache.dubbo.rpc.Constants.SCOPE_REMOTE;
+import static org.apache.dubbo.rpc.Constants.SCOPE_LOCAL;
+import static org.apache.dubbo.rpc.cluster.Constants.PEER_KEY;
+
+/**
+ * A ClusterInvoker that selects between local and remote invokers at runtime.
+ */
+public class ScopeClusterInvoker<T> implements ClusterInvoker<T>, ExporterChangeListener {
+
+    private Protocol protocolSPI;
+    private final Directory<T> directory;
+    private final Invoker<T> invoker;
+    private final AtomicBoolean isExported;
+    private volatile Invoker<T> injvmInvoker;
+    private volatile InjvmExporterListener injvmExporterListener;
+
+    private boolean peerFlag;
+
+    private boolean injvmFlag;
+
+    private final Object createLock = new Object();
+
+
+    public ScopeClusterInvoker(Directory<T> directory, Invoker<T> invoker) {
+        this.directory = directory;
+        this.invoker = invoker;
+        this.isExported = new AtomicBoolean(false);
+        init();
+    }
+
+    private void init() {
+        Boolean peer = (Boolean) getUrl().getAttribute(PEER_KEY);
+        String isInjvm = getUrl().getParameter(LOCAL_PROTOCOL);
+        if (peer != null && peer) {
+            peerFlag = true;
+            return;
+        }
+        if (injvmInvoker == null && LOCAL_PROTOCOL.equalsIgnoreCase(getRegistryUrl().getProtocol())) {
+            injvmInvoker = invoker;
+            isExported.compareAndSet(false, true);
+            injvmFlag = true;
+            return;
+        }
+        if (Boolean.TRUE.toString().equalsIgnoreCase(isInjvm) || LOCAL_KEY.equalsIgnoreCase(getUrl().getParameter(SCOPE_KEY))) {
+            injvmFlag = true;
+        } else if (isInjvm == null) {
+            injvmFlag = isNotRemoteOrGeneric();
+        }
+        if (injvmFlag) {
+            protocolSPI = getUrl().getApplicationModel().getExtensionLoader(Protocol.class).getAdaptiveExtension();
+            injvmExporterListener = (InjvmExporterListener) getUrl().getApplicationModel().getExtensionLoader(ExporterListener.class).getExtension(LOCAL_PROTOCOL);","[{'comment': 'Convert ExporterListener into a scope bean.', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'Phixsura'}]"
11531,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java,"@@ -0,0 +1,213 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.cluster.support.wrapper;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.url.component.ServiceConfigURL;
+import org.apache.dubbo.common.utils.NetUtils;
+import org.apache.dubbo.rpc.Exporter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Protocol;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.Cluster;
+import org.apache.dubbo.rpc.cluster.ClusterInvoker;
+import org.apache.dubbo.rpc.cluster.Directory;
+import org.apache.dubbo.rpc.cluster.directory.StaticDirectory;
+import org.apache.dubbo.rpc.listener.ExporterChangeListener;
+import org.apache.dubbo.rpc.listener.InjvmExporterListener;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static org.apache.dubbo.rpc.Constants.GENERIC_KEY;
+import static org.apache.dubbo.rpc.Constants.LOCAL_KEY;
+import static org.apache.dubbo.rpc.Constants.LOCAL_PROTOCOL;
+import static org.apache.dubbo.rpc.Constants.SCOPE_KEY;
+import static org.apache.dubbo.rpc.Constants.SCOPE_REMOTE;
+import static org.apache.dubbo.rpc.Constants.SCOPE_LOCAL;
+import static org.apache.dubbo.rpc.cluster.Constants.PEER_KEY;
+
+/**
+ * A ClusterInvoker that selects between local and remote invokers at runtime.
+ */
+public class ScopeClusterInvoker<T> implements ClusterInvoker<T>, ExporterChangeListener {
+
+    private Protocol protocolSPI;
+    private final Directory<T> directory;
+    private final Invoker<T> invoker;
+    private final AtomicBoolean isExported;
+    private volatile Invoker<T> injvmInvoker;
+    private volatile InjvmExporterListener injvmExporterListener;
+
+    private boolean peerFlag;
+
+    private boolean injvmFlag;
+
+    private final Object createLock = new Object();
+
+
+    public ScopeClusterInvoker(Directory<T> directory, Invoker<T> invoker) {
+        this.directory = directory;
+        this.invoker = invoker;
+        this.isExported = new AtomicBoolean(false);
+        init();
+    }
+
+    private void init() {
+        Boolean peer = (Boolean) getUrl().getAttribute(PEER_KEY);
+        String isInjvm = getUrl().getParameter(LOCAL_PROTOCOL);
+        if (peer != null && peer) {
+            peerFlag = true;
+            return;
+        }
+        if (injvmInvoker == null && LOCAL_PROTOCOL.equalsIgnoreCase(getRegistryUrl().getProtocol())) {
+            injvmInvoker = invoker;
+            isExported.compareAndSet(false, true);
+            injvmFlag = true;
+            return;
+        }
+        if (Boolean.TRUE.toString().equalsIgnoreCase(isInjvm) || LOCAL_KEY.equalsIgnoreCase(getUrl().getParameter(SCOPE_KEY))) {
+            injvmFlag = true;
+        } else if (isInjvm == null) {
+            injvmFlag = isNotRemoteOrGeneric();
+        }
+
+        protocolSPI = getUrl().getApplicationModel().getExtensionLoader(Protocol.class).getAdaptiveExtension();
+        injvmExporterListener = getUrl().getOrDefaultFrameworkModel().getBeanFactory().getBean(InjvmExporterListener.class);
+        injvmExporterListener.addExporterChangeListener(this, getUrl().getServiceKey());
+    }
+
+    @Override
+    public URL getUrl() {
+        return directory.getConsumerUrl();
+    }
+
+    @Override
+    public URL getRegistryUrl() {
+        return directory.getUrl();
+    }
+
+    @Override
+    public Directory<T> getDirectory() {
+        return directory;
+    }
+
+    @Override
+    public boolean isDestroyed() {
+        return directory.isDestroyed();
+    }
+
+    @Override
+    public boolean isAvailable() {
+        return isExported.get() || directory.isAvailable();
+    }
+
+    @Override
+    public void destroy() {
+        if (injvmExporterListener != null) {
+            injvmExporterListener.removeExporterChangeListener(this, getUrl().getServiceKey());
+        }
+        destroyInjvmInvoker();
+        this.invoker.destroy();
+    }
+
+    @Override
+    public Class<T> getInterface() {
+        return directory.getInterface();
+    }
+
+    @Override
+    public Result invoke(Invocation invocation) throws RpcException {
+        if (peerFlag) {
+            return invoker.invoke(invocation);
+        }
+        if (isInjvmExported() && injvmFlag) {
+            return injvmInvoker.invoke(invocation);
+        }
+        return invoker.invoke(invocation);
+    }
+
+    private boolean isNotRemoteOrGeneric() {
+        return !SCOPE_REMOTE.equalsIgnoreCase(getUrl().getParameter(SCOPE_KEY)) &&
+            !getUrl().getParameter(GENERIC_KEY, false);
+    }
+
+    private boolean isInjvmExported() {
+        Boolean localInvoke = RpcContext.getServiceContext().getLocalInvoke();","[{'comment': '`RpcContext.getServiceContext().getLocalInvoke()` here should only effect **one** invocation.\r\nIf `null`, ignore.\r\nIf `false`, force remote.\r\nIf `true`, force local.', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'Phixsura'}]"
11533,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java,"@@ -251,7 +250,7 @@ protected void onDestroy() {
         frameworkModel.tryDestroyProtocols();
 
         // 4. destroy application resources
-        for (ModuleModel moduleModel : new ArrayList<>(moduleModels)) {
+        for (ModuleModel moduleModel : moduleModels) {","[{'comment': 'Do not change this line. Prevent ConcurrentModificationException here.', 'commenter': 'AlbumenJ'}, {'comment': '`moduleModel.destroy` will remove itself in `moduleModels`', 'commenter': 'AlbumenJ'}, {'comment': ""Hello, I think that moduleModels is CopyOnWriteArrayList, and it returned iterator provides a snapshot of the state of the list, it's not ConcurrentModificationException so we do not to prevent. \r\nWe can use list.remove() but not iterator.remove()\r\nI write a test int ApplicationModelTest.\r\nPlease check again"", 'commenter': 'KamToHung'}]"
11533,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -230,9 +230,8 @@ private void registerShutdownHook() {
     private void initModuleDeployers() {
         // make sure created default module
         applicationModel.getDefaultModule();
-        // copy modules and initialize avoid ConcurrentModificationException if add new module
-        List<ModuleModel> moduleModels = new ArrayList<>(applicationModel.getModuleModels());
-        for (ModuleModel moduleModel : moduleModels) {
+        // deployer initialize
+        for (ModuleModel moduleModel : applicationModel.getModuleModels()) {","[{'comment': 'Also for here.', 'commenter': 'AlbumenJ'}, {'comment': '```java\r\n    public List<ModuleModel> getModuleModels() {\r\n        return Collections.unmodifiableList(moduleModels);\r\n    }\r\n```\r\ngetModuleModels method is return Collections.unmodifiableList, so I think that we can remove new ArrayList<>()', 'commenter': 'KamToHung'}]"
11543,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java,"@@ -140,9 +141,21 @@ private ExecutorService createExecutor(URL url) {
         return (ExecutorService) extensionAccessor.getExtensionLoader(ThreadPool.class).getAdaptiveExtension().getExecutor(url);
     }
 
+    private Map<Integer, ExecutorService> getExecutors(URL url) {
+        Map<Integer, ExecutorService> executors;
+        // if it's on the provider side and has user-defined services, use biz service executor first, avoid using internal executor
+        if (PROVIDER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY))
+            && data.containsKey(EXECUTOR_SERVICE_COMPONENT_KEY)) {
+            executors = data.get(EXECUTOR_SERVICE_COMPONENT_KEY);
+        } else {
+            executors = data.get(getExecutorKey(url));
+        }
+        return executors;
+    }
+","[{'comment': 'I have a question that why `ServiceDescriptor serviceDescriptor = applicationModel.getInternalModule().getServiceRepository().lookupService(url.getServiceInterface());` not work?', 'commenter': 'AlbumenJ'}, {'comment': 'Because `url.getServiceInterface()` always returns MetadataService, when the MetadataService is first loaded.\r\n', 'commenter': 'sadlay'}, {'comment': '\r\n\r\n![image](https://user-images.githubusercontent.com/38170721/220063942-df1905f7-5e0a-4fb9-b737-f577c5a2d647.png)\r\n\r\nThe `PortUnificationExchanger#reset` method will return a new url instead of updating, so the Map in `AbstractPortUnificationServer#supportedUrls` will not be changed.\r\n\r\n![image](https://user-images.githubusercontent.com/38170721/220063744-cfd5a94a-3550-4f0c-accb-3d7cbc1293dc.png)\r\n\r\nin  `NettyPortUnificationServerHandler#decode` , **localUrl** is set by the value in **urlMapper**, not the updated **url**\r\n\r\n![image](https://user-images.githubusercontent.com/38170721/220062213-c6948393-9f43-40f0-bccf-d795aee49ca9.png)\r\n\r\nSo the url is still MetadataService.', 'commenter': 'sadlay'}]"
11572,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java,"@@ -390,12 +393,19 @@ public byte[] pack(Object obj) throws IOException {
             }
             final TripleCustomerProtocolWapper.TripleRequestWrapper.Builder builder = TripleCustomerProtocolWapper.TripleRequestWrapper.Builder.newBuilder();
             builder.setSerializeType(serialize);
-            for (Object argument : arguments) {
-                builder.addArgTypes(argument.getClass().getName());
+
+            if (arguments == null || arguments.length == 0){
+                return new byte[0];","[{'comment': 'serialization type lost', 'commenter': 'icodening'}, {'comment': '好的', 'commenter': 'jojocodeX'}]"
11572,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java,"@@ -370,14 +369,18 @@ private static class WrapRequestPack implements Pack {
         private final URL url;
         private final boolean singleArgument;
 
+        private Class<?>[] actualRequestTypes;","[{'comment': 'Please add the final modifier', 'commenter': 'mytang0'}]"
11572,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java,"@@ -390,12 +393,27 @@ public byte[] pack(Object obj) throws IOException {
             }
             final TripleCustomerProtocolWapper.TripleRequestWrapper.Builder builder = TripleCustomerProtocolWapper.TripleRequestWrapper.Builder.newBuilder();
             builder.setSerializeType(serialize);
-            for (Object argument : arguments) {
-                builder.addArgTypes(argument.getClass().getName());
+
+            for (int i = 0 ; i < arguments.length; i++) {","[{'comment': 'You can consider doing a length check on arguments and types to avoid overflow.', 'commenter': 'mytang0'}]"
11572,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java,"@@ -390,12 +393,27 @@ public byte[] pack(Object obj) throws IOException {
             }
             final TripleCustomerProtocolWapper.TripleRequestWrapper.Builder builder = TripleCustomerProtocolWapper.TripleRequestWrapper.Builder.newBuilder();
             builder.setSerializeType(serialize);
-            for (Object argument : arguments) {
-                builder.addArgTypes(argument.getClass().getName());
+
+            for (int i = 0 ; i < arguments.length; i++) {
+                Object argument = arguments[i];
+                String paramTypeName;
+                Class<?> paramTypeClass;
+
+                if (argument == null) {
+                    paramTypeName = actualRequestTypes[i].getName();
+                    paramTypeClass = actualRequestTypes[i];
+                }else{
+                    paramTypeName = arguments[i].getClass().getName();
+                    paramTypeClass = arguments[i].getClass();
+                }
+","[{'comment': 'The parameter type has been passed in, so there is no need to use arguments[i].getClass()', 'commenter': 'mytang0'}]"
11572,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java,"@@ -390,12 +393,19 @@ public byte[] pack(Object obj) throws IOException {
             }
             final TripleCustomerProtocolWapper.TripleRequestWrapper.Builder builder = TripleCustomerProtocolWapper.TripleRequestWrapper.Builder.newBuilder();
             builder.setSerializeType(serialize);
-            for (Object argument : arguments) {
-                builder.addArgTypes(argument.getClass().getName());
+
+            if (arguments == null || arguments.length == 0){
+                return new byte[0];
+            }
+
+            for (int i = 0; i < arguments.length; i++) {
+                builder.addArgTypes(actualRequestTypes[i].getName());
                 ByteArrayOutputStream bos = new ByteArrayOutputStream();
-                multipleSerialization.serialize(url, serialize, argument.getClass(), argument, bos);
+                multipleSerialization.serialize(url, serialize, actualRequestTypes[i],","[{'comment': 'argument is null,  serialization type lost', 'commenter': 'wangtu'}]"
11574,dubbo-common/src/main/java/org/apache/dubbo/common/Version.java,"@@ -61,6 +66,15 @@ public final class Version {
     static {
         // check if there's duplicated jar
         Version.checkDuplicate(Version.class);
+
+        // get dubbo version and last commit id
+        Properties properties =
+            ConfigUtils.loadProperties(Collections.emptySet(), ""META-INF/version"");
+
+        VERSION = Optional.ofNullable(properties.getProperty(""git.build.version""))
+            .filter(StringUtils::isNotBlank)
+            .orElseGet(() -> getVersion(Version.class, """"));
+        LATEST_COMMIT_ID = Optional.ofNullable(properties.getProperty(""git.commit.id.full"")).orElse("""");","[{'comment': 'Catch `Throwable` here to prevent `NoDefError`', 'commenter': 'AlbumenJ'}, {'comment': 'OK', 'commenter': 'mytang0'}, {'comment': '> Catch `Throwable` here to prevent `NoDefError`\r\n\r\nI see Catch Throwable in ConfigUtils.loadProperties', 'commenter': 'mytang0'}]"
11574,pom.xml,"@@ -800,6 +801,11 @@
                     <artifactId>jetty-maven-plugin</artifactId>
                     <version>${maven_jetty_version}</version>
                 </plugin>
+                <plugin>
+                    <groupId>pl.project13.maven</groupId>
+                    <artifactId>git-commit-id-plugin</artifactId>
+                    <version>${maven_git_version}</version>
+                </plugin>","[{'comment': '`git-commit-id-plugin` is under LGPL-3.0 license. We should not depends on it due to apache 3rd license policy.\r\n\r\nhttps://github.com/git-commit-id/git-commit-id-maven-plugin\r\nhttps://www.apache.org/legal/resolved.html', 'commenter': 'AlbumenJ'}, {'comment': '可以参考第三方框架的做法，通过插件的形式，在编译期就生成相应的文件，运行时直接读取指定的文件，最终输出类似这样的信息\r\n+ spring-boot-test.version=0.0.1-SNAPSHOT\r\n+ spring-boot-test.buildDate=2023-02-15 23\\:21\\:10 +0800\r\n+ spring-boot-test.commitDate=2022-05-27 09\\:35\\:11 +0800\r\n+ spring-boot-test.shortCommitHash=a56b7a4\r\nspring-boot-+ test.longCommitHash=a56b7a406ad963d29c93b77f3d0e61abb0c80f6b\r\n+ spring-boot-test.repoStatus=dirty\r\n', 'commenter': 'jojocodeX'}, {'comment': '> 可以参考第三方框架的做法，通过插件的形式，在编译期就生成相应的文件，运行时直接读取指定的文件，最终输出类似这样的信息\r\n> \r\n> * spring-boot-test.version=0.0.1-SNAPSHOT\r\n> * spring-boot-test.buildDate=2023-02-15 23:21:10 +0800\r\n> * spring-boot-test.commitDate=2022-05-27 09:35:11 +0800\r\n> * spring-boot-test.shortCommitHash=a56b7a4\r\n>   spring-boot-+ test.longCommitHash=a56b7a406ad963d29c93b77f3d0e61abb0c80f6b\r\n> * spring-boot-test.repoStatus=dirty\r\n\r\nYes, it is great', 'commenter': 'mytang0'}]"
11574,dubbo-common/pom.xml,"@@ -100,8 +100,38 @@
             <groupId>javax.annotation</groupId>
             <artifactId>javax.annotation-api</artifactId>
         </dependency>
-
-
     </dependencies>
 
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-antrun-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>get-version-infos</id>
+                        <phase>compile</phase>
+                        <configuration>
+                            <failOnError>false</failOnError>","[{'comment': 'Should enable `failOnError` in `release` profile', 'commenter': 'AlbumenJ'}, {'comment': 'Ok', 'commenter': 'mytang0'}]"
11579,dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-consumer/pom.xml,"@@ -140,9 +140,18 @@
         </dependency>
         <dependency>
             <groupId>io.micrometer</groupId>
-            <artifactId>micrometer-tracing-bridge-otel</artifactId>
+            <artifactId>micrometer-tracing-bridge-brave</artifactId>","[{'comment': 'Out of curiosity - why the change?', 'commenter': 'marcingrzejszczak'}, {'comment': 'I tested on the demo, but I forgot to rollback', 'commenter': 'ShenFeng312'}, {'comment': ""No problem, it doesn't matter which one you're using"", 'commenter': 'marcingrzejszczak'}]"
11579,dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/annotation/ConditionalOnDubboTracingEnable.java,"@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.spring.boot.observability.annotation;
+
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+
+/**
+ * @author shenfeng
+ */
+@Target({ElementType.TYPE,ElementType.METHOD})
+@Retention(RetentionPolicy.RUNTIME)
+@Inherited
+@Documented
+@ConditionalOnProperty(prefix = ""dubbo.tracing"", name = ""enabled"", matchIfMissing = true)
+public @interface ConditionalOnDubboTracingEnable {","[{'comment': '`Enable` or `Enabled` ?', 'commenter': 'marcingrzejszczak'}, {'comment': ""Enabled,I'm sorry I forgot to test when  enabled is false"", 'commenter': 'ShenFeng312'}]"
11579,dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/DubboMicrometerTracingAutoConfiguration.java,"@@ -0,0 +1,79 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.spring.boot.observability.autoconfigure;
+
+import io.micrometer.tracing.Tracer;
+import io.micrometer.tracing.handler.DefaultTracingObservationHandler;
+import io.micrometer.tracing.handler.PropagatingReceiverTracingObservationHandler;
+import io.micrometer.tracing.handler.PropagatingSenderTracingObservationHandler;
+import io.micrometer.tracing.propagation.Propagator;
+import org.apache.dubbo.spring.boot.observability.annotation.ConditionalOnDubboTracingEnable;
+import org.springframework.boot.autoconfigure.AutoConfigureAfter;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.context.annotation.Bean;
+import org.springframework.core.annotation.Order;
+
+/**
+ * copy form {@link org.springframework.boot.actuate.autoconfigure.tracing.MicrometerTracingAutoConfiguration}","[{'comment': ""You can mention that this class is available starting from Boot 3.0. It's not available if you're using Boot < 3.0"", 'commenter': 'marcingrzejszczak'}, {'comment': 'thank you', 'commenter': 'ShenFeng312'}]"
11579,dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/brave/BraveAutoConfiguration.java,"@@ -0,0 +1,245 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.spring.boot.observability.autoconfigure.brave;
+
+import brave.CurrentSpanCustomizer;
+import brave.SpanCustomizer;
+import brave.Tracing;
+import brave.TracingCustomizer;
+import brave.baggage.BaggageField;
+import brave.baggage.BaggagePropagation;
+import brave.baggage.BaggagePropagationConfig;
+import brave.baggage.BaggagePropagationCustomizer;
+import brave.baggage.CorrelationScopeCustomizer;
+import brave.baggage.CorrelationScopeDecorator;
+import brave.context.slf4j.MDCScopeDecorator;
+import brave.handler.SpanHandler;
+import brave.propagation.B3Propagation;
+import brave.propagation.CurrentTraceContext;
+import brave.propagation.CurrentTraceContextCustomizer;
+import brave.propagation.Propagation;
+import brave.propagation.ThreadLocalCurrentTraceContext;
+import brave.sampler.Sampler;
+import io.micrometer.tracing.Tracer;
+import io.micrometer.tracing.brave.bridge.BraveBaggageManager;
+import io.micrometer.tracing.brave.bridge.BraveCurrentTraceContext;
+import io.micrometer.tracing.brave.bridge.BravePropagator;
+import io.micrometer.tracing.brave.bridge.BraveSpanCustomizer;
+import io.micrometer.tracing.brave.bridge.BraveTracer;
+import io.micrometer.tracing.brave.bridge.CompositeSpanHandler;
+import io.micrometer.tracing.brave.bridge.W3CPropagation;
+import io.micrometer.tracing.exporter.SpanExportingPredicate;
+import io.micrometer.tracing.exporter.SpanFilter;
+import io.micrometer.tracing.exporter.SpanReporter;
+import org.apache.dubbo.spring.boot.observability.annotation.ConditionalOnDubboTracingEnable;
+import org.apache.dubbo.spring.boot.observability.autoconfigure.DubboMicrometerTracingAutoConfiguration;
+import org.apache.dubbo.spring.boot.observability.config.DubboTracingProperties;
+import org.springframework.beans.factory.ObjectProvider;
+import org.springframework.boot.autoconfigure.AutoConfiguration;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.boot.context.properties.EnableConfigurationProperties;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.core.Ordered;
+import org.springframework.core.annotation.Order;
+import org.springframework.core.env.Environment;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+
+/**
+ * @author shenfeng","[{'comment': ""You can mention that this is a copy from Boot 3.0 setup and I would schedule this for removal once you upgrade to Boot 3 since you don't want to maintain this copy forever"", 'commenter': 'marcingrzejszczak'}]"
11579,dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/brave/BraveAutoConfiguration.java,"@@ -0,0 +1,245 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.spring.boot.observability.autoconfigure.brave;
+
+import brave.CurrentSpanCustomizer;
+import brave.SpanCustomizer;
+import brave.Tracing;
+import brave.TracingCustomizer;
+import brave.baggage.BaggageField;
+import brave.baggage.BaggagePropagation;
+import brave.baggage.BaggagePropagationConfig;
+import brave.baggage.BaggagePropagationCustomizer;
+import brave.baggage.CorrelationScopeCustomizer;
+import brave.baggage.CorrelationScopeDecorator;
+import brave.context.slf4j.MDCScopeDecorator;
+import brave.handler.SpanHandler;
+import brave.propagation.B3Propagation;
+import brave.propagation.CurrentTraceContext;
+import brave.propagation.CurrentTraceContextCustomizer;
+import brave.propagation.Propagation;
+import brave.propagation.ThreadLocalCurrentTraceContext;
+import brave.sampler.Sampler;
+import io.micrometer.tracing.Tracer;
+import io.micrometer.tracing.brave.bridge.BraveBaggageManager;
+import io.micrometer.tracing.brave.bridge.BraveCurrentTraceContext;
+import io.micrometer.tracing.brave.bridge.BravePropagator;
+import io.micrometer.tracing.brave.bridge.BraveSpanCustomizer;
+import io.micrometer.tracing.brave.bridge.BraveTracer;
+import io.micrometer.tracing.brave.bridge.CompositeSpanHandler;
+import io.micrometer.tracing.brave.bridge.W3CPropagation;
+import io.micrometer.tracing.exporter.SpanExportingPredicate;
+import io.micrometer.tracing.exporter.SpanFilter;
+import io.micrometer.tracing.exporter.SpanReporter;
+import org.apache.dubbo.spring.boot.observability.annotation.ConditionalOnDubboTracingEnable;
+import org.apache.dubbo.spring.boot.observability.autoconfigure.DubboMicrometerTracingAutoConfiguration;
+import org.apache.dubbo.spring.boot.observability.config.DubboTracingProperties;
+import org.springframework.beans.factory.ObjectProvider;
+import org.springframework.boot.autoconfigure.AutoConfiguration;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.boot.context.properties.EnableConfigurationProperties;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.core.Ordered;
+import org.springframework.core.annotation.Order;
+import org.springframework.core.env.Environment;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+
+/**
+ * @author shenfeng
+ */
+@AutoConfiguration(before = DubboMicrometerTracingAutoConfiguration.class, afterName = ""org.springframework.boot.actuate.autoconfigure.tracing.BraveAutoConfiguration"")
+@ConditionalOnClass({ Tracer.class, BraveTracer.class })
+@EnableConfigurationProperties(DubboTracingProperties.class)
+@ConditionalOnDubboTracingEnable
+public class BraveAutoConfiguration {
+
+    private static final BraveBaggageManager BRAVE_BAGGAGE_MANAGER = new BraveBaggageManager();
+
+    /**
+     * Default value for application name if {@code spring.application.name} is not set.
+     */
+    private static final String DEFAULT_APPLICATION_NAME = ""application"";
+
+    @Bean
+    @ConditionalOnMissingBean
+    @Order(Ordered.HIGHEST_PRECEDENCE)
+    CompositeSpanHandler compositeSpanHandler(ObjectProvider<SpanExportingPredicate> predicates,
+                                              ObjectProvider<SpanReporter> reporters, ObjectProvider<SpanFilter> filters) {
+        return new CompositeSpanHandler(predicates.orderedStream().collect(Collectors.toList()),
+            reporters.orderedStream().collect(Collectors.toList()),
+            filters.orderedStream().collect(Collectors.toList()));
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    public Tracing braveTracing(Environment environment, List<SpanHandler> spanHandlers,
+                                List<TracingCustomizer> tracingCustomizers, CurrentTraceContext currentTraceContext,
+                                Propagation.Factory propagationFactory, Sampler sampler) {
+        String applicationName = environment.getProperty(""spring.application.name"", DEFAULT_APPLICATION_NAME);
+        Tracing.Builder builder = Tracing.newBuilder().currentTraceContext(currentTraceContext).traceId128Bit(true)
+            .supportsJoin(false).propagationFactory(propagationFactory).sampler(sampler)
+            .localServiceName(applicationName);
+        spanHandlers.forEach(builder::addSpanHandler);
+        for (TracingCustomizer tracingCustomizer : tracingCustomizers) {
+            tracingCustomizer.customize(builder);
+        }
+        return builder.build();
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    public brave.Tracer braveTracer(Tracing tracing) {
+        return tracing.tracer();
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    public CurrentTraceContext braveCurrentTraceContext(List<CurrentTraceContext.ScopeDecorator> scopeDecorators,
+                                                        List<CurrentTraceContextCustomizer> currentTraceContextCustomizers) {
+        ThreadLocalCurrentTraceContext.Builder builder = ThreadLocalCurrentTraceContext.newBuilder();
+        scopeDecorators.forEach(builder::addScopeDecorator);
+        for (CurrentTraceContextCustomizer currentTraceContextCustomizer : currentTraceContextCustomizers) {
+            currentTraceContextCustomizer.customize(builder);
+        }
+        return builder.build();
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    public Sampler braveSampler(DubboTracingProperties properties) {
+        return Sampler.create((float) properties.getRatio());
+    }
+
+    @Bean
+    @ConditionalOnMissingBean(io.micrometer.tracing.Tracer.class)
+    BraveTracer braveTracerBridge(brave.Tracer tracer, CurrentTraceContext currentTraceContext) {
+        return new BraveTracer(tracer, new BraveCurrentTraceContext(currentTraceContext), BRAVE_BAGGAGE_MANAGER);
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    BravePropagator bravePropagator(Tracing tracing) {
+        return new BravePropagator(tracing);
+    }
+
+    @Bean
+    @ConditionalOnMissingBean(SpanCustomizer.class)
+    CurrentSpanCustomizer currentSpanCustomizer(Tracing tracing) {
+        return CurrentSpanCustomizer.create(tracing);
+    }
+
+    @Bean
+    @ConditionalOnMissingBean(io.micrometer.tracing.SpanCustomizer.class)
+    BraveSpanCustomizer braveSpanCustomizer(SpanCustomizer spanCustomizer) {
+        return new BraveSpanCustomizer(spanCustomizer);
+    }
+
+//    @Configuration(proxyBeanMethods = false)","[{'comment': 'Why is this commented out?', 'commenter': 'marcingrzejszczak'}, {'comment': ""> Why is this commented out?\r\n\r\nI forget to clean this,I'm so sorry"", 'commenter': 'ShenFeng312'}]"
11579,dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/otel/OpenTelemetryAutoConfiguration.java,"@@ -0,0 +1,223 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.spring.boot.observability.autoconfigure.otel;
+
+import io.micrometer.tracing.SpanCustomizer;
+import io.micrometer.tracing.exporter.SpanExportingPredicate;
+import io.micrometer.tracing.exporter.SpanFilter;
+import io.micrometer.tracing.exporter.SpanReporter;
+import io.micrometer.tracing.otel.bridge.CompositeSpanExporter;
+import io.micrometer.tracing.otel.bridge.EventListener;
+import io.micrometer.tracing.otel.bridge.EventPublishingContextWrapper;
+import io.micrometer.tracing.otel.bridge.OtelBaggageManager;
+import io.micrometer.tracing.otel.bridge.OtelCurrentTraceContext;
+import io.micrometer.tracing.otel.bridge.OtelPropagator;
+import io.micrometer.tracing.otel.bridge.OtelSpanCustomizer;
+import io.micrometer.tracing.otel.bridge.OtelTracer;
+import io.micrometer.tracing.otel.bridge.Slf4JEventListener;
+import io.micrometer.tracing.otel.propagation.BaggageTextMapPropagator;
+import io.opentelemetry.api.OpenTelemetry;
+import io.opentelemetry.api.baggage.propagation.W3CBaggagePropagator;
+import io.opentelemetry.api.common.Attributes;
+import io.opentelemetry.api.trace.Tracer;
+import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator;
+import io.opentelemetry.context.ContextStorage;
+import io.opentelemetry.context.propagation.ContextPropagators;
+import io.opentelemetry.context.propagation.TextMapPropagator;
+import io.opentelemetry.extension.trace.propagation.B3Propagator;
+import io.opentelemetry.sdk.OpenTelemetrySdk;
+import io.opentelemetry.sdk.resources.Resource;
+import io.opentelemetry.sdk.trace.SdkTracerProvider;
+import io.opentelemetry.sdk.trace.SdkTracerProviderBuilder;
+import io.opentelemetry.sdk.trace.SpanProcessor;
+import io.opentelemetry.sdk.trace.export.BatchSpanProcessor;
+import io.opentelemetry.sdk.trace.export.SpanExporter;
+import io.opentelemetry.sdk.trace.samplers.Sampler;
+import io.opentelemetry.semconv.resource.attributes.ResourceAttributes;
+import org.apache.dubbo.spring.boot.observability.annotation.ConditionalOnDubboTracingEnable;
+import org.apache.dubbo.spring.boot.observability.autoconfigure.DubboMicrometerTracingAutoConfiguration;
+import org.apache.dubbo.spring.boot.observability.config.DubboTracingProperties;
+import org.springframework.beans.factory.ObjectProvider;
+import org.springframework.boot.autoconfigure.AutoConfiguration;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.boot.context.properties.EnableConfigurationProperties;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.core.env.Environment;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+
+@AutoConfiguration(before = DubboMicrometerTracingAutoConfiguration.class, afterName = ""org.springframework.boot.actuate.autoconfigure.tracing.OpenTelemetryAutoConfiguration"")
+@ConditionalOnDubboTracingEnable
+@ConditionalOnClass({OtelTracer.class, SdkTracerProvider.class, OpenTelemetry.class})
+@EnableConfigurationProperties(DubboTracingProperties.class)
+public class OpenTelemetryAutoConfiguration {","[{'comment': 'Same remarks as for Brave', 'commenter': 'marcingrzejszczak'}]"
11579,dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/config/DubboTracingProperties.java,"@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.spring.boot.observability.config;
+
+
+import org.springframework.boot.context.properties.ConfigurationProperties;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author shenfeng
+ */
+@ConfigurationProperties(prefix = ""dubbo.tracing"")
+public class DubboTracingProperties {
+    private boolean enable = true;
+    private String baggage = ""W3C"";","[{'comment': 'is this even used?', 'commenter': 'marcingrzejszczak'}, {'comment': 'it is used in  `BraveAutoConfiguration` and `OpenTelemetryAutoConfiguration`', 'commenter': 'ShenFeng312'}, {'comment': 'AFAIR that code was commented out', 'commenter': 'marcingrzejszczak'}]"
11579,dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/config/DubboTracingProperties.java,"@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.spring.boot.observability.config;
+
+
+import org.springframework.boot.context.properties.ConfigurationProperties;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author shenfeng
+ */
+@ConfigurationProperties(prefix = ""dubbo.tracing"")
+public class DubboTracingProperties {
+    private boolean enable = true;","[{'comment': '`enabled` instead of `enable` ?', 'commenter': 'marcingrzejszczak'}, {'comment': ""yes!  thank you ,I'm sorry for my bad english"", 'commenter': 'ShenFeng312'}]"
11579,dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/resources/META-INF/spring-configuration-metadata.json,"@@ -0,0 +1,35 @@
+{
+  ""groups"": [
+    {
+      ""name"": ""dubbo.tracing"",
+      ""type"": ""org.apache.dubbo.spring.boot.observability.config.DubboTracingProperties"",
+      ""sourceType"": ""org.apache.dubbo.spring.boot.observability.config.DubboTracingProperties""
+    }
+  ],
+  ""properties"": [
+    {
+      ""name"": ""dubbo.tracing.baggage"",","[{'comment': 'Is this related to baggage really or context propagation type? Cause how baggage is done is related to context propagation type really', 'commenter': 'marcingrzejszczak'}, {'comment': 'Can i rename it to dubbo.tracing.propagation?', 'commenter': 'ShenFeng312'}, {'comment': 'This is how we do it in Boot - https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/tracing/TracingProperties.java#L171 `management.tracing.propagation.type`', 'commenter': 'marcingrzejszczak'}, {'comment': '> This is how we do it in Boot - https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/tracing/TracingProperties.java#L171 `management.tracing.propagation.type`\r\n\r\nOK', 'commenter': 'ShenFeng312'}]"
11579,dubbo-spring-boot/pom.xml,"@@ -57,6 +58,11 @@
                 <type>pom</type>
                 <scope>import</scope>
             </dependency>
+            <dependency>
+                <groupId>io.micrometer</groupId>
+                <artifactId>micrometer-core</artifactId>
+                <version>1.10.3</version>","[{'comment': '1.10.4 is the latest', 'commenter': 'marcingrzejszczak'}]"
11579,dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-consumer/pom.xml,"@@ -143,6 +143,15 @@
             <artifactId>micrometer-tracing-bridge-otel</artifactId>
         </dependency>
 
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-spring-boot-observability-starter</artifactId>
+        </dependency>
+
+<!--        <dependency>-->","[{'comment': 'You can remove this then, right?', 'commenter': 'marcingrzejszczak'}]"
11579,dubbo-demo/dubbo-demo-spring-boot/dubbo-demo-spring-boot-provider/pom.xml,"@@ -141,7 +141,15 @@
             <groupId>io.micrometer</groupId>
             <artifactId>micrometer-tracing-bridge-otel</artifactId>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-spring-boot-observability-starter</artifactId>
+        </dependency>
 
+<!--        <dependency>-->","[{'comment': 'You can remove this then, right?', 'commenter': 'marcingrzejszczak'}, {'comment': 'yes', 'commenter': 'ShenFeng312'}]"
11579,dubbo-spring-boot/pom.xml,"@@ -57,6 +58,11 @@
                 <type>pom</type>
                 <scope>import</scope>
             </dependency>
+            <dependency>
+                <groupId>io.micrometer</groupId>
+                <artifactId>micrometer-core</artifactId>
+                <version>1.10.4</version>","[{'comment': 'Should put the version in properties?', 'commenter': 'conghuhu'}]"
11579,dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/DubboObservationAutoConfiguration.java,"@@ -0,0 +1,155 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.spring.boot.observability.autoconfigure;
+
+import io.micrometer.core.instrument.MeterRegistry;
+import io.micrometer.core.instrument.observation.DefaultMeterObservationHandler;
+import io.micrometer.core.instrument.observation.MeterObservationHandler;
+import io.micrometer.observation.Observation;
+import io.micrometer.observation.ObservationHandler;
+import io.micrometer.observation.ObservationRegistry;
+import io.micrometer.tracing.Tracer;
+import io.micrometer.tracing.handler.TracingAwareMeterObservationHandler;
+import io.micrometer.tracing.handler.TracingObservationHandler;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.spring.boot.observability.annotation.ConditionalOnDubboTracingEnable;
+import org.springframework.beans.BeansException;
+import org.springframework.beans.factory.BeanFactory;
+import org.springframework.beans.factory.BeanFactoryAware;
+import org.springframework.beans.factory.ObjectProvider;
+import org.springframework.beans.factory.SmartInitializingSingleton;
+import org.springframework.boot.autoconfigure.AutoConfiguration;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+
+import java.util.Arrays;
+
+
+/**
+ * Register observationRegistry to ApplicationModel.
+ * Create observationRegistry when you are using Boot <3.0 or you are not using spring-boot-starter-actuator
+ * @author shenfeng
+ */
+@AutoConfiguration(after =DubboMicrometerTracingAutoConfiguration.class,afterName = ""org.springframework.boot.actuate.autoconfigure.observation.ObservationAutoConfiguration"")
+@ConditionalOnDubboTracingEnable
+public class DubboObservationAutoConfiguration implements BeanFactoryAware, SmartInitializingSingleton {
+
+    public DubboObservationAutoConfiguration( ApplicationModel applicationModel){","[{'comment': 'Remove space.', 'commenter': 'conghuhu'}]"
11579,dubbo-demo/dubbo-demo-spring-boot/pom.xml,"@@ -36,7 +36,26 @@
         <maven.compiler.source>8</maven.compiler.source>
         <maven.compiler.target>8</maven.compiler.target>
         <skip_maven_deploy>true</skip_maven_deploy>
+        <spring-boot.version>2.7.8</spring-boot.version>
         <spring-boot-maven-plugin.version>2.7.8</spring-boot-maven-plugin.version>
     </properties>
+    <dependencyManagement>
+        <dependencies>
+            <dependency>
+                <groupId>org.springframework.boot</groupId>
+                <artifactId>spring-boot-dependencies</artifactId>
+                <version>${spring-boot.version}</version>
+                <type>pom</type>
+                <scope>import</scope>
+            </dependency>
+            <dependency>
+                <groupId>io.micrometer</groupId>
+                <artifactId>micrometer-core</artifactId>
+                <version>1.10.4</version>","[{'comment': 'refactor this version  to properties', 'commenter': 'songxiaosheng'}]"
11579,dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/otel/OpenTelemetryAutoConfiguration.java,"@@ -0,0 +1,257 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.spring.boot.observability.autoconfigure.otel;
+
+import io.micrometer.tracing.SpanCustomizer;
+import io.micrometer.tracing.exporter.SpanExportingPredicate;
+import io.micrometer.tracing.exporter.SpanFilter;
+import io.micrometer.tracing.exporter.SpanReporter;
+import io.micrometer.tracing.otel.bridge.CompositeSpanExporter;
+import io.micrometer.tracing.otel.bridge.EventListener;
+import io.micrometer.tracing.otel.bridge.EventPublishingContextWrapper;
+import io.micrometer.tracing.otel.bridge.OtelBaggageManager;
+import io.micrometer.tracing.otel.bridge.OtelCurrentTraceContext;
+import io.micrometer.tracing.otel.bridge.OtelPropagator;
+import io.micrometer.tracing.otel.bridge.OtelSpanCustomizer;
+import io.micrometer.tracing.otel.bridge.OtelTracer;
+import io.micrometer.tracing.otel.bridge.Slf4JBaggageEventListener;
+import io.micrometer.tracing.otel.bridge.Slf4JEventListener;
+import io.micrometer.tracing.otel.propagation.BaggageTextMapPropagator;
+import io.opentelemetry.api.OpenTelemetry;
+import io.opentelemetry.api.baggage.propagation.W3CBaggagePropagator;
+import io.opentelemetry.api.common.Attributes;
+import io.opentelemetry.api.trace.Tracer;
+import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator;
+import io.opentelemetry.context.ContextStorage;
+import io.opentelemetry.context.propagation.ContextPropagators;
+import io.opentelemetry.context.propagation.TextMapPropagator;
+import io.opentelemetry.extension.trace.propagation.B3Propagator;
+import io.opentelemetry.sdk.OpenTelemetrySdk;
+import io.opentelemetry.sdk.resources.Resource;
+import io.opentelemetry.sdk.trace.SdkTracerProvider;
+import io.opentelemetry.sdk.trace.SdkTracerProviderBuilder;
+import io.opentelemetry.sdk.trace.SpanProcessor;
+import io.opentelemetry.sdk.trace.export.BatchSpanProcessor;
+import io.opentelemetry.sdk.trace.export.SpanExporter;
+import io.opentelemetry.sdk.trace.samplers.Sampler;
+import io.opentelemetry.semconv.resource.attributes.ResourceAttributes;
+import org.apache.dubbo.spring.boot.observability.annotation.ConditionalOnDubboTracingEnable;
+import org.apache.dubbo.spring.boot.observability.autoconfigure.DubboMicrometerTracingAutoConfiguration;
+import org.apache.dubbo.spring.boot.observability.config.DubboTracingProperties;
+import org.springframework.beans.factory.ObjectProvider;
+import org.springframework.boot.autoconfigure.AutoConfiguration;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.boot.context.properties.EnableConfigurationProperties;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.core.env.Environment;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+
+/**
+ * provider OpenTelemetry when you are using Boot <3.0 or you are not using spring-boot-starter-actuator
+ * @author shenfeng
+ */
+@AutoConfiguration(before = DubboMicrometerTracingAutoConfiguration.class, afterName = ""org.springframework.boot.actuate.autoconfigure.tracing.OpenTelemetryAutoConfiguration"")
+@ConditionalOnDubboTracingEnable
+@ConditionalOnClass({OtelTracer.class, SdkTracerProvider.class, OpenTelemetry.class})
+@EnableConfigurationProperties(DubboTracingProperties.class)
+public class OpenTelemetryAutoConfiguration {
+
+    /**
+     * Default value for application name if {@code spring.application.name} is not set.
+     */
+    private static final String DEFAULT_APPLICATION_NAME = ""application"";
+
+    private final DubboTracingProperties dubboTracingProperties;
+
+    OpenTelemetryAutoConfiguration(DubboTracingProperties dubboTracingProperties) {
+        this.dubboTracingProperties = dubboTracingProperties;
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    OpenTelemetry openTelemetry(SdkTracerProvider sdkTracerProvider, ContextPropagators contextPropagators) {
+        return OpenTelemetrySdk.builder().setTracerProvider(sdkTracerProvider).setPropagators(contextPropagators)
+            .build();
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    SdkTracerProvider otelSdkTracerProvider(Environment environment, ObjectProvider<SpanProcessor> spanProcessors,
+                                            Sampler sampler) {
+        String applicationName = environment.getProperty(""spring.application.name"", DEFAULT_APPLICATION_NAME);
+        SdkTracerProviderBuilder builder = SdkTracerProvider.builder().setSampler(sampler)
+            .setResource(Resource.create(Attributes.of(ResourceAttributes.SERVICE_NAME, applicationName)));
+        spanProcessors.orderedStream().forEach(builder::addSpanProcessor);
+        return builder.build();
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    ContextPropagators otelContextPropagators(ObjectProvider<TextMapPropagator> textMapPropagators) {
+        return ContextPropagators.create(TextMapPropagator.composite(textMapPropagators.orderedStream().collect(Collectors.toList())));
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    Sampler otelSampler() {
+        Sampler rootSampler = Sampler.traceIdRatioBased(this.dubboTracingProperties.getSampling().getProbability());
+        return Sampler.parentBased(rootSampler);
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    SpanProcessor otelSpanProcessor(ObjectProvider<SpanExporter> spanExporters,","[{'comment': 'I see that there is no @ConditionalOnMissingBean in the latest springboot3: \r\n![image](https://user-images.githubusercontent.com/56248584/221387428-ad73cad3-ae16-4eef-9561-8287681da315.png)\r\n', 'commenter': 'conghuhu'}, {'comment': '`OpenTelemetryAutoConfiguration` is after `org.springframework.boot.actuate.autoconfigure.tracing.OpenTelemetryAutoConfiguration`,so we need add  `@ConditionalOnMissingBean` use springboot3 default', 'commenter': 'ShenFeng312'}]"
11579,dubbo-spring-boot/dubbo-spring-boot-observability-starter/src/main/java/org/apache/dubbo/spring/boot/observability/autoconfigure/otel/OpenTelemetryAutoConfiguration.java,"@@ -0,0 +1,257 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.spring.boot.observability.autoconfigure.otel;
+
+import io.micrometer.tracing.SpanCustomizer;
+import io.micrometer.tracing.exporter.SpanExportingPredicate;
+import io.micrometer.tracing.exporter.SpanFilter;
+import io.micrometer.tracing.exporter.SpanReporter;
+import io.micrometer.tracing.otel.bridge.CompositeSpanExporter;
+import io.micrometer.tracing.otel.bridge.EventListener;
+import io.micrometer.tracing.otel.bridge.EventPublishingContextWrapper;
+import io.micrometer.tracing.otel.bridge.OtelBaggageManager;
+import io.micrometer.tracing.otel.bridge.OtelCurrentTraceContext;
+import io.micrometer.tracing.otel.bridge.OtelPropagator;
+import io.micrometer.tracing.otel.bridge.OtelSpanCustomizer;
+import io.micrometer.tracing.otel.bridge.OtelTracer;
+import io.micrometer.tracing.otel.bridge.Slf4JBaggageEventListener;
+import io.micrometer.tracing.otel.bridge.Slf4JEventListener;
+import io.micrometer.tracing.otel.propagation.BaggageTextMapPropagator;
+import io.opentelemetry.api.OpenTelemetry;
+import io.opentelemetry.api.baggage.propagation.W3CBaggagePropagator;
+import io.opentelemetry.api.common.Attributes;
+import io.opentelemetry.api.trace.Tracer;
+import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator;
+import io.opentelemetry.context.ContextStorage;
+import io.opentelemetry.context.propagation.ContextPropagators;
+import io.opentelemetry.context.propagation.TextMapPropagator;
+import io.opentelemetry.extension.trace.propagation.B3Propagator;
+import io.opentelemetry.sdk.OpenTelemetrySdk;
+import io.opentelemetry.sdk.resources.Resource;
+import io.opentelemetry.sdk.trace.SdkTracerProvider;
+import io.opentelemetry.sdk.trace.SdkTracerProviderBuilder;
+import io.opentelemetry.sdk.trace.SpanProcessor;
+import io.opentelemetry.sdk.trace.export.BatchSpanProcessor;
+import io.opentelemetry.sdk.trace.export.SpanExporter;
+import io.opentelemetry.sdk.trace.samplers.Sampler;
+import io.opentelemetry.semconv.resource.attributes.ResourceAttributes;
+import org.apache.dubbo.spring.boot.observability.annotation.ConditionalOnDubboTracingEnable;
+import org.apache.dubbo.spring.boot.observability.autoconfigure.DubboMicrometerTracingAutoConfiguration;
+import org.apache.dubbo.spring.boot.observability.config.DubboTracingProperties;
+import org.springframework.beans.factory.ObjectProvider;
+import org.springframework.boot.autoconfigure.AutoConfiguration;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.boot.context.properties.EnableConfigurationProperties;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.core.env.Environment;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+
+/**
+ * provider OpenTelemetry when you are using Boot <3.0 or you are not using spring-boot-starter-actuator
+ * @author shenfeng
+ */
+@AutoConfiguration(before = DubboMicrometerTracingAutoConfiguration.class, afterName = ""org.springframework.boot.actuate.autoconfigure.tracing.OpenTelemetryAutoConfiguration"")
+@ConditionalOnDubboTracingEnable
+@ConditionalOnClass({OtelTracer.class, SdkTracerProvider.class, OpenTelemetry.class})
+@EnableConfigurationProperties(DubboTracingProperties.class)
+public class OpenTelemetryAutoConfiguration {
+
+    /**
+     * Default value for application name if {@code spring.application.name} is not set.
+     */
+    private static final String DEFAULT_APPLICATION_NAME = ""application"";
+
+    private final DubboTracingProperties dubboTracingProperties;
+
+    OpenTelemetryAutoConfiguration(DubboTracingProperties dubboTracingProperties) {
+        this.dubboTracingProperties = dubboTracingProperties;
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    OpenTelemetry openTelemetry(SdkTracerProvider sdkTracerProvider, ContextPropagators contextPropagators) {
+        return OpenTelemetrySdk.builder().setTracerProvider(sdkTracerProvider).setPropagators(contextPropagators)
+            .build();
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    SdkTracerProvider otelSdkTracerProvider(Environment environment, ObjectProvider<SpanProcessor> spanProcessors,
+                                            Sampler sampler) {
+        String applicationName = environment.getProperty(""spring.application.name"", DEFAULT_APPLICATION_NAME);
+        SdkTracerProviderBuilder builder = SdkTracerProvider.builder().setSampler(sampler)
+            .setResource(Resource.create(Attributes.of(ResourceAttributes.SERVICE_NAME, applicationName)));
+        spanProcessors.orderedStream().forEach(builder::addSpanProcessor);
+        return builder.build();
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    ContextPropagators otelContextPropagators(ObjectProvider<TextMapPropagator> textMapPropagators) {
+        return ContextPropagators.create(TextMapPropagator.composite(textMapPropagators.orderedStream().collect(Collectors.toList())));
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    Sampler otelSampler() {
+        Sampler rootSampler = Sampler.traceIdRatioBased(this.dubboTracingProperties.getSampling().getProbability());
+        return Sampler.parentBased(rootSampler);
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    SpanProcessor otelSpanProcessor(ObjectProvider<SpanExporter> spanExporters,
+                                    ObjectProvider<SpanExportingPredicate> spanExportingPredicates, ObjectProvider<SpanReporter> spanReporters,
+                                    ObjectProvider<SpanFilter> spanFilters) {
+        return BatchSpanProcessor.builder(new CompositeSpanExporter(spanExporters.orderedStream().collect(Collectors.toList()),
+            spanExportingPredicates.orderedStream().collect(Collectors.toList()), spanReporters.orderedStream().collect(Collectors.toList()),
+            spanFilters.orderedStream().collect(Collectors.toList()))).build();
+    }
+
+    @Bean
+    @ConditionalOnMissingBean
+    Tracer otelTracer(OpenTelemetry openTelemetry) {
+        return openTelemetry.getTracer(""org.apache.dubbo"");","[{'comment': 'Could we add the Dubbo version:\r\n![image](https://user-images.githubusercontent.com/56248584/221387480-ada681b2-d1d7-490b-b931-dfd76f627a14.png)\r\n', 'commenter': 'conghuhu'}]"
11591,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadPoolMetricsSampler.java,"@@ -16,28 +16,27 @@
  */
 package org.apache.dubbo.metrics.collector.sample;
 
+import org.apache.dubbo.common.store.DataStore;
 import org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository;
 import org.apache.dubbo.metrics.collector.DefaultMetricsCollector;
 import org.apache.dubbo.metrics.model.MetricsKey;
 import org.apache.dubbo.metrics.model.ThreadPoolMetric;
 import org.apache.dubbo.metrics.model.sample.GaugeMetricSample;
 import org.apache.dubbo.metrics.model.sample.MetricSample;
 
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Optional;
-import java.util.Set;
+import java.util.*;","[{'comment': ""don't use * import"", 'commenter': 'songxiaosheng'}]"
11591,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadPoolMetricsSampler.java,"@@ -64,6 +63,20 @@ private void collect() {
             }
         }catch(Exception ex){}
 
+        if (this.dataStore == null) {
+            this.dataStore = collector.getApplicationModel().getExtensionLoader(DataStore.class).getDefaultExtension();
+        }","[{'comment': 'Should these initialization operations be placed in the constructor', 'commenter': 'wxbty'}]"
11591,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadPoolMetricsSampler.java,"@@ -64,6 +69,20 @@ private void collect() {
             }
         }catch(Exception ex){}
 
+        if (this.dataStore == null) {
+            this.dataStore = collector.getApplicationModel().getExtensionLoader(DataStore.class).getDefaultExtension();","[{'comment': 'please add NullPointException check\r\n\r\n9Z [ERROR] org.apache.dubbo.metrics.filter.MetricsFilterTest.testMissingGroupAndVersion  Time elapsed: 0.041 s  <<< ERROR!\r\n2023-02-18T01:17:26.2131813Z java.lang.NullPointerException: Cannot invoke ""org.apache.dubbo.rpc.model.ApplicationModel.getExtensionLoader(java.lang.Class)"" because the return value of ""org.apache.dubbo.metrics.collector.DefaultMetricsCollector.getApplicationModel()"" is null\r\n2023-02-18T01:17:26.2132911Z \tat org.apache.dubbo.metrics.collector.sample.ThreadPoolMetricsSampler.collect(ThreadPoolMetricsSampler.java:73)\r\n2023-02-18T01:17:26.2133674Z \tat org.apache.dubbo.metrics.collector.sample.ThreadPoolMetricsSampler.sample(ThreadPoolMetricsSampler.java:53)\r\n2023-02-18T01:17:26.2134391Z \tat org.apache.dubbo.metrics.collector.DefaultMetricsCollector.collect(DefaultMetricsCollector.java:97)\r\n2023-02-18T01:17:26.2135048Z \tat org.apache.dubbo.metrics.filter.MetricsFilterTest.getMetricsMap(MetricsFilterTest.java:327)\r\n2023-02-18T01:17:26.2135741Z \tat org.apache.dubbo.metrics.filter.MetricsFilterTest.testMissingGroupAndVersion(MetricsFilterTest.java:284)\r\n2023-02-18T01:17:26.2136378Z \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n2023-02-18T01:17:26.2136970Z \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)', 'commenter': 'songxiaosheng'}]"
11602,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/ConfigCenterMetricsCollector.java,"@@ -0,0 +1,74 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.collector;
+
+import org.apache.dubbo.common.config.configcenter.ConfigChangeType;
+import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;
+import org.apache.dubbo.metrics.model.ConfigCenterMetric;
+import org.apache.dubbo.metrics.model.MetricsKey;
+import org.apache.dubbo.metrics.model.sample.GaugeMetricSample;
+import org.apache.dubbo.metrics.model.sample.MetricSample;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicLong;
+
+import static org.apache.dubbo.metrics.model.MetricsCategory.CONFIGCENTER;
+
+/**
+ * @author guiyi.yuan
+ * @date 2/8/23 10:06 PM","[{'comment': 'Remove these tags pls', 'commenter': 'AlbumenJ'}]"
11622,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/collector/stat/MetricsStatHandler.java,"@@ -1,36 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.dubbo.metrics.collector.stat;
-
-import org.apache.dubbo.metrics.event.MetricsEvent;
-import org.apache.dubbo.metrics.model.MethodMetric;
-import org.apache.dubbo.rpc.Invocation;
-
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicLong;
-
-public interface MetricsStatHandler {
-    Map<MethodMetric, AtomicLong> get();
-
-    MetricsEvent increase(String applicationName, Invocation invocation);
-
-    MetricsEvent decrease(String applicationName, Invocation invocation);
-
-    MetricsEvent addApplication(String applicationName);","[{'comment': 'Why remove this class?', 'commenter': 'AlbumenJ'}, {'comment': 'OK, the code is undo', 'commenter': 'jojocodeX'}]"
11624,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataServiceNameMapping.java,"@@ -73,6 +76,15 @@ public boolean hasValidMetadataCenter() {
      */
     @Override
     public boolean map(URL url) {
+        Optional<ApplicationConfig> application = applicationModel.getApplicationConfigManager().getApplication();
+        if(application.isPresent()) {
+            String metadataType = application.get().getMetadataType();
+            if (!REMOTE_METADATA_STORAGE_TYPE.equals(metadataType)) {","[{'comment': 'Service mapping is required in local mode', 'commenter': 'AlbumenJ'}]"
11628,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/SimpleMetricsCountSampler.java,"@@ -38,124 +43,120 @@
 public abstract class SimpleMetricsCountSampler<S, K, M extends Metric>
     implements MetricsCountSampler<S, K, M> {
 
-    private final ConcurrentMap<M, AtomicLong>      lastRT = new ConcurrentHashMap<>();
-    private final ConcurrentMap<M, LongAccumulator> minRT  = new ConcurrentHashMap<>();
-    private final ConcurrentMap<M, LongAccumulator> maxRT  = new ConcurrentHashMap<>();
-    private final ConcurrentMap<M, AtomicLong>      avgRT   = new ConcurrentHashMap<>();
-    private final ConcurrentMap<M, AtomicLong>      totalRT = new ConcurrentHashMap<>();
-    private final ConcurrentMap<M, AtomicLong>      rtCount = new ConcurrentHashMap<>();
+    private final ConcurrentMap<M, AtomicLong> EMPTY_COUNT = new ConcurrentHashMap<>();
 
-    private Map<K, ConcurrentMap<M, AtomicLong>> metricCounter = new ConcurrentHashMap<>();
+    private final ConcurrentMap<M, LongAccumulator> minRT = new ConcurrentHashMap<>();
+    private final ConcurrentMap<M, LongAccumulator> maxRT = new ConcurrentHashMap<>();
+
+    // lastRT, totalRT, rtCount, avgRT share a container, can utilize the system cache line
+    private final ConcurrentMap<M, AtomicLongArray> RTArray = new ConcurrentHashMap<>();","[{'comment': 'Please change the first name to lowercase', 'commenter': 'songxiaosheng'}, {'comment': 'Already fixed', 'commenter': 'mytang0'}]"
11632,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MetricsKey.java,"@@ -47,6 +47,9 @@ public enum MetricsKey {
     METRIC_RT_P99(""dubbo.%s.rt.seconds.p99"", ""Response Time P99""),
     METRIC_RT_P95(""dubbo.%s.rt.seconds.p95"", ""Response Time P95""),
 
+    PROVIDER_METRIC_RT_HISTOGRAM(""dubbo.provider.rt.seconds.histogram"", ""Response Time Histogram""),","[{'comment': 'please change provider to %s', 'commenter': 'songxiaosheng'}, {'comment': 'modified', 'commenter': 'gsralex'}]"
11632,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MetricsKey.java,"@@ -47,6 +47,9 @@ public enum MetricsKey {
     METRIC_RT_P99(""dubbo.%s.rt.seconds.p99"", ""Response Time P99""),
     METRIC_RT_P95(""dubbo.%s.rt.seconds.p95"", ""Response Time P95""),
 
+    PROVIDER_METRIC_RT_HISTOGRAM(""dubbo.%s.rt.seconds.histogram"", ""Response Time Histogram""),","[{'comment': 'please change the name  of PROVIDEER_METRIC_RT_HISTORYGRAM to   \nMETRIC_RT_HISTORYGRAM\n\nseconds may be error , need change to  milliseconds', 'commenter': 'songxiaosheng'}, {'comment': 'modified', 'commenter': 'gsralex'}]"
11638,dubbo-common/src/main/java/org/apache/dubbo/common/utils/TimeUtils.java,"@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.utils;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Provide currentTimeMillis acquisition for high-frequency access scenarios.
+ */
+public final class TimeUtils {
+
+    private static volatile long currentTimeMillis;
+
+    private static volatile boolean isTickerAlive = true;
+
+    static {
+        currentTimeMillis = System.currentTimeMillis();
+        Thread ticker = new Thread(() -> {
+            while (isTickerAlive) {
+                currentTimeMillis = System.currentTimeMillis();
+                try {
+                    TimeUnit.MILLISECONDS.sleep(1);
+                } catch (InterruptedException e) {
+                    isTickerAlive = false;
+                    Thread.currentThread().interrupt();
+                } catch (Exception ignored) {
+                    //
+                }
+            }
+        });
+        ticker.setDaemon(true);
+        ticker.setName(""time-millis-ticker-thread"");
+        ticker.start();
+        Runtime.getRuntime().addShutdownHook(new Thread(ticker::interrupt));
+    }","[{'comment': '1. Prevent add complex logic in the process of class initialization\r\n2. Start on demand', 'commenter': 'AlbumenJ'}, {'comment': '> 1. Prevent add complex logic in the process of class initialization\r\n> 2. Start on demand\r\n\r\nFixed.', 'commenter': 'mytang0'}]"
11638,dubbo-common/src/main/java/org/apache/dubbo/common/utils/TimeUtils.java,"@@ -0,0 +1,64 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.utils;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Provide currentTimeMillis acquisition for high-frequency access scenarios.
+ */
+public final class TimeUtils {
+
+    private static volatile long currentTimeMillis;
+
+    private static volatile boolean isTickerAlive = false;
+
+    private TimeUtils() {
+    }
+
+    public static long currentTimeMillis() {
+        if (!isTickerAlive) {
+            startTicker();
+        }
+        return currentTimeMillis;","[{'comment': 'Should fallback if `currentTimeMillis` is un-available here?', 'commenter': 'AlbumenJ'}, {'comment': '> Should fallback if `currentTimeMillis` is un-available here?\r\n\r\nGood. Submitted.', 'commenter': 'mytang0'}]"
11640,dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/HttpHandler.java,"@@ -34,6 +32,6 @@ public interface HttpHandler {
      * @throws IOException
      * @throws ServletException
      */
-    void handle(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;
+    void handle(REQUEST request, RESPONSE response) throws IOException, ServletException;","[{'comment': 'will throw an `java.lang.NoClassDefFoundError` if the classpath does not have `ServletException`', 'commenter': 'icodening'}, {'comment': 'ok,i will fix', 'commenter': 'suncairong163'}]"
11640,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/request/RequestFacadeFactory.java,"@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.rest.request;
+
+
+public class RequestFacadeFactory {
+    private final static String JakartaServlet = ""jakarta.servlet.http.HttpServletRequest"";
+    private final static String JavaxServlet = ""javax.servlet.http.HttpServletRequest"";
+    private final static String FullHttpRequest = ""io.netty.handler.codec.http.FullHttpRequest"";
+
+
+    public static RequestFacade createRequestFacade(Object request) {
+
+        if (tryLoad(JavaxServlet, request)) {
+
+            return new JavaxServletRequestFacade(request);
+        }
+
+        if (tryLoad(JakartaServlet, request)) {
+            return new JakartaServletRequestFacade(request);
+        }
+
+        if (tryLoad(FullHttpRequest, request)) {
+            return new NettyRequestFacade(request,null);
+        }
+
+
+
+
+
+
+        throw new RuntimeException(""no compatible  ServletRequestFacade and request type is "" + request.getClass());
+
+    }
+
+    public static boolean tryLoad(String requestClassName, Object request) {
+
+        ClassLoader classLoader = request.getClass().getClassLoader();
+
+        try {
+            Class<?> requestClass = classLoader.loadClass(requestClassName);
+
+            return requestClass.isAssignableFrom(request.getClass());
+
+        } catch (ClassNotFoundException e) {
+            return false;
+        }
+
+    }","[{'comment': 'can be replace `org.apache.dubbo.common.utils.ClassUtils#isPresent`', 'commenter': 'icodening'}, {'comment': 'ok，I will fix', 'commenter': 'suncairong163'}]"
11640,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/handler/NettyHttpHandler.java,"@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.rest.handler;
+
+import io.netty.handler.codec.http.FullHttpRequest;
+import org.apache.dubbo.metadata.rest.media.MediaType;
+import org.apache.dubbo.remoting.http.HttpHandler;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcInvocation;
+import org.apache.dubbo.rpc.protocol.rest.RPCInvocationBuilder;
+import org.apache.dubbo.rpc.protocol.rest.constans.RestConstant;
+import org.apache.dubbo.rpc.protocol.rest.exception.PathNoFoundException;
+import org.apache.dubbo.rpc.protocol.rest.exception.mapper.ExceptionMapper;
+import org.apache.dubbo.rpc.protocol.rest.message.HttpMessageCodecManager;
+import org.apache.dubbo.rpc.protocol.rest.netty.NettyHttpResponse;
+import org.apache.dubbo.rpc.protocol.rest.request.RequestFacade;
+import org.apache.dubbo.rpc.protocol.rest.request.RequestFacadeFactory;
+import org.apache.dubbo.rpc.protocol.rest.util.HttpHeaderUtil;
+import org.apache.dubbo.rpc.protocol.rest.util.MediaTypeUtil;
+import org.apache.dubbo.rpc.protocol.rest.util.Pair;
+
+import javax.servlet.ServletException;
+import java.io.IOException;
+
+public class NettyHttpHandler implements HttpHandler<FullHttpRequest, NettyHttpResponse> {
+
+    @Override
+    public void handle(FullHttpRequest nettyHttpRequest, NettyHttpResponse nettyHttpResponse) throws IOException, ServletException {
+
+        RequestFacade request = RequestFacadeFactory.createRequestFacade(nettyHttpRequest);
+//        RpcContext.getServiceContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());
+//            dispatcher.service(request, servletResponse);
+
+        Pair<RpcInvocation, Invoker> build = null;
+        try {
+            build = RPCInvocationBuilder.build(request, nettyHttpRequest, nettyHttpResponse);
+        } catch (PathNoFoundException e) {
+            nettyHttpResponse.setStatus(404);
+        }
+
+        Invoker invoker = build.getSecond();","[{'comment': 'will throw NPE if  invoke `RPCInvocationBuilder.build` error', 'commenter': 'icodening'}, {'comment': 'ok，I will fix', 'commenter': 'suncairong163'}]"
11640,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/DubboHttpProtocolServer.java,"@@ -80,12 +93,64 @@ protected ResteasyDeployment getDeployment() {
         return deployment;
     }
 
-    private class RestHandler implements HttpHandler {
+    private class RestHandler implements HttpHandler<HttpServletRequest, HttpServletResponse> {
 
         @Override
-        public void handle(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        public void handle(HttpServletRequest servletRequest, HttpServletResponse servletResponse) throws IOException, ServletException {
+
+            RequestFacade request = RequestFacadeFactory.createRequestFacade(servletRequest);
             RpcContext.getServiceContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());
-            dispatcher.service(request, response);
+//            dispatcher.service(request, servletResponse);
+
+            Pair<RpcInvocation, Invoker> build = null;
+            try {
+                build = RPCInvocationBuilder.build(request, servletRequest, servletResponse);
+            } catch (PathNoFoundException e) {
+                servletResponse.setStatus(404);
+            }
+
+            Invoker invoker = build.getSecond();","[{'comment': 'will throw NPE if invoke `RPCInvocationBuilder.build` error', 'commenter': 'icodening'}, {'comment': 'ok，I will fix', 'commenter': 'suncairong163'}]"
11640,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/PathAndInvokerMapper.java,"@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.rest;
+
+import org.apache.dubbo.metadata.rest.PathMatcher;
+import org.apache.dubbo.metadata.rest.RestMethodMetadata;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.protocol.rest.exception.PathNoFoundException;
+import org.apache.dubbo.rpc.protocol.rest.util.Pair;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class PathAndInvokerMapper {","[{'comment': 'It seems to be similar to `org.apache.dubbo.rpc.PathResolver`?', 'commenter': 'icodening'}, {'comment': '是的，这块功能上是和pathResolver一样的，但是会有些不一样的，org.apache.dubbo.rpc.PathResolver#add(String path, Invoker<?> invoker)    这块需要抽象成泛型，', 'commenter': 'suncairong163'}]"
11640,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/request/JavaxServletRequestFacade.java,"@@ -0,0 +1,297 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.rest.request;
+
+import javax.servlet.http.HttpServletRequest;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.util.Enumeration;
+import java.util.Locale;
+import java.util.Map;
+
+public class JavaxServletRequestFacade extends RequestFacade<HttpServletRequest> {
+
+
+    public JavaxServletRequestFacade(Object request) {
+        super((HttpServletRequest) request);
+    }
+
+    @Override
+    public Object getParts() throws Exception {
+        return request.getParts();
+    }
+
+    @Override
+    public Object getPart(String var1) throws Exception {
+        return request.getPart(var1);
+    }
+
+    @Override
+    public Object getCookies() {
+        return request.getCookies();
+    }
+
+
+    public long getDateHeader(String name) {
+        return request.getDateHeader(name);
+    }
+
+
+    public String getHeader(String name) {
+        return request.getHeader(name);
+    }
+
+
+    public Enumeration<String> getHeaders(String name) {
+        return request.getHeaders(name);
+    }
+
+
+    public Enumeration<String> getHeaderNames() {
+        return request.getHeaderNames();
+    }
+
+
+    public int getIntHeader(String name) {
+        return request.getIntHeader(name);
+    }
+
+
+    public String getMethod() {
+        return request.getMethod();
+    }
+
+
+    public String getPathInfo() {
+        return path;
+    }
+
+
+    public String getPathTranslated() {
+        return request.getPathTranslated();
+    }
+
+
+    public String getContextPath() {
+        return request.getContextPath();
+    }
+
+
+    public String getQueryString() {
+        return request.getQueryString();
+    }
+
+
+    public String getRemoteUser() {
+        return request.getRemoteUser();
+    }
+
+
+    public boolean isUserInRole(String role) {
+        return request.isUserInRole(role);
+    }
+
+
+    public String getRequestedSessionId() {
+        return request.getRequestedSessionId();","[{'comment': '## ""HttpServletRequest.getRequestedSessionId()"" should not be used\n\n<!--SONAR_ISSUE_KEY:AYbRFC3Dr4kLSu96UJon-->Remove use of this unsecured ""getRequestedSessionId()"" method <p>See more on <a href=""https://sonarcloud.io/project/issues?id=apache_dubbo&issues=AYbRFC3Dr4kLSu96UJon&open=AYbRFC3Dr4kLSu96UJon&pullRequest=11640"">SonarCloud</a></p>\n\n[Show more details](https://github.com/apache/dubbo/security/code-scanning/32)', 'commenter': 'github-advanced-security[bot]'}]"
11653,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ModuleModel.java,"@@ -48,7 +48,7 @@ public class ModuleModel extends ScopeModel {
     private volatile ModuleDeployer deployer;
     private boolean lifeCycleManagedExternally = false;
 
-    protected ModuleModel(ApplicationModel applicationModel) {
+    public ModuleModel(ApplicationModel applicationModel) {","[{'comment': 'revert', 'commenter': 'AlbumenJ'}]"
11653,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/ChannelHandlers.java,"@@ -33,7 +33,7 @@ public static ChannelHandler wrap(ChannelHandler handler, URL url) {
         return ChannelHandlers.getInstance().wrapInternal(handler, url);
     }
 
-    protected static ChannelHandlers getInstance() {
+    public static ChannelHandlers getInstance() {","[{'comment': 'revert', 'commenter': 'AlbumenJ'}]"
11658,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/support/ConsumerResponseContextFilter.java,"@@ -0,0 +1,78 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.filter.support;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.rpc.BaseFilter;
+import org.apache.dubbo.rpc.Filter;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.InvokeMode;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.RpcInvocation;
+
+import java.util.Map;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER;
+
+/**
+ * Pass the context returned by the provider, the largest order value makes the first call when returning,
+ * otherwise the subsequent filter will not get the context
+ *
+ * @see Filter
+ * @see RpcContext
+ */
+@Activate(group = CONSUMER, order = Integer.MAX_VALUE)
+public class ConsumerResponseContextFilter implements Filter, BaseFilter.Listener {","[{'comment': ""\r\nRpcContext  is not design for Filter developers.\r\nAll context operation in Filter should base on Invocation and Response.\r\n\r\nIf we support change RpcContext in Filter, achieving synchronization between RpcContext.clientAttachment and Invocation would be complex and inefficient.\r\n\r\nThe user's RpcContext will be converted into the initial attachment of Invocation at the entrance, and the attachment of Result will be converted into RpcContext at the exit and sent back to the user"", 'commenter': 'AlbumenJ'}]"
11665,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosNamingServiceWrapper.java,"@@ -269,14 +244,9 @@ public void deregisterInstance(String serviceName, String group, Instance instan
             InstanceInfo instanceInfo = optional.get();
             instancesInfo.getInstances().remove(instanceInfo);
 
-            try {
-                mapLock.lock();
-                if (instancesInfo.getInstances().isEmpty()) {
-                    registerStatus.remove(new InstanceId(nacosServiceName, group));
-                    instancesInfo.setValid(false);
-                }
-            } finally {
-                mapLock.unlock();
+            if (instancesInfo.getInstances().isEmpty()) {
+                registerStatus.remove(new InstanceId(nacosServiceName, group));
+                instancesInfo.setValid(false);","[{'comment': 'Operation here is not atomic', 'commenter': 'AlbumenJ'}, {'comment': '@AlbumenJ \r\nI think there is no need for atomicity guarantee here.\r\n- because the code here has already got instancesInfo lock ```instancesInfo.lock()```; \r\n- and for the modification of registerStatus ```registerStatus.remove(new InstanceId(nacosServiceName, group));```, due to the protection of the lock mechanism inside concurrenthashmap , which has the same effect as the previous mapLock.lock()', 'commenter': 'sourcelliu'}]"
11677,dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java,"@@ -375,6 +375,9 @@ protected void processExtraRefresh(String preferredPrefix, InmemoryConfiguration
     }
 
     private boolean verifyMethodConfig(MethodConfig methodConfig, Class<?> interfaceClass, boolean ignoreInvalidMethodConfig) {
+        if (!isNeedCheckMethod()) {
+            return true;
+        }","[{'comment': 'It would be better to check anyway, but warn out only instead of throw a exception.', 'commenter': 'AlbumenJ'}]"
11677,dubbo-common/src/test/java/org/apache/dubbo/config/AbstractInterfaceConfigTest.java,"@@ -236,7 +236,20 @@ void testScope() {
         Assertions.assertEquals(""scope"", interfaceConfig.getScope());
     }
 
+    @Test
+    void testVerifyMethod() {
+        InterfaceConfig interfaceConfig = new InterfaceConfig();
+        MethodConfig methodConfig = new MethodConfig();
+        methodConfig.setTimeout(5000);
+        methodConfig.setName(""sayHello"");
+        Class<?> clazz = Greeting.class;
+        boolean verifyResult = interfaceConfig.verifyMethodConfig(methodConfig, clazz, false);
+        Assertions.assertEquals(true, verifyResult);","[{'comment': '```suggestion\r\n        Assertions.assertTrue(verifyResult);\r\n```', 'commenter': 'AlbumenJ'}]"
11677,dubbo-common/src/test/java/org/apache/dubbo/config/AbstractInterfaceConfigTest.java,"@@ -236,7 +236,20 @@ void testScope() {
         Assertions.assertEquals(""scope"", interfaceConfig.getScope());
     }
 
+    @Test
+    void testVerifyMethod() {
+        InterfaceConfig interfaceConfig = new InterfaceConfig();
+        MethodConfig methodConfig = new MethodConfig();
+        methodConfig.setTimeout(5000);
+        methodConfig.setName(""sayHello"");
+        Class<?> clazz = Greeting.class;
+        boolean verifyResult = interfaceConfig.verifyMethodConfig(methodConfig, clazz, false);
+        Assertions.assertEquals(true, verifyResult);
+        boolean verifyResult2 = interfaceConfig.verifyMethodConfig(methodConfig, clazz, true);
+        Assertions.assertEquals(false, verifyResult2);","[{'comment': '```suggestion\r\n        Assertions.assertFalse(verifyResult2);\r\n```', 'commenter': 'AlbumenJ'}]"
11677,dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/MethodConfigTest.java,"@@ -431,7 +431,6 @@ void testVerifyMethodConfigOfService() {
                 .application(""demo-app"")
                 .service(serviceConfig)
                 .initialize();
-            Assertions.fail(""Method config verification should failed"");","[{'comment': 'Revert this. Safe barrier', 'commenter': 'AlbumenJ'}, {'comment': 'has change to warn', 'commenter': 'aamingaa'}]"
11677,dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java,"@@ -396,7 +396,12 @@ private boolean verifyMethodConfig(MethodConfig methodConfig, Class<?> interface
                 logger.warn(CONFIG_NO_METHOD_FOUND, """", """", msg);
                 return false;
             } else {
-                throw new IllegalStateException(msg);
+                if (!isNeedCheckMethod()) {
+                    msg = String.format(""%s generic call "", isNeedCheckMethod() ) + msg;
+                    logger.warn(CONFIG_NO_METHOD_FOUND, """", """", msg);","[{'comment': '```suggestion\r\n                    logger.warn(CONFIG_NO_METHOD_FOUND, """", """", msg);\r\n```', 'commenter': 'AlbumenJ'}]"
11709,dubbo-common/src/test/java/org/apache/dubbo/common/utils/NamedThreadFactoryTest.java,"@@ -20,16 +20,19 @@
 import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 
+import java.util.concurrent.atomic.AtomicInteger;
+
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.allOf;
 import static org.hamcrest.Matchers.containsString;
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertSame;
-import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.*;","[{'comment': 'Please revert comma import usage.\r\nOthers LGTM', 'commenter': 'AlbumenJ'}, {'comment': 'thanks, i get it', 'commenter': 'erdengk'}]"
11719,dubbo-metrics/dubbo-metrics-prometheus/src/main/java/org/apache/dubbo/metrics/prometheus/PrometheusMetricsReporterCmd.java,"@@ -0,0 +1,79 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.prometheus;
+
+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.metrics.report.MetricsReporter;
+import org.apache.dubbo.qos.command.BaseCommand;
+import org.apache.dubbo.qos.command.CommandContext;
+import org.apache.dubbo.qos.command.annotation.Cmd;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.FrameworkModel;
+
+import java.util.Optional;
+
+@Cmd(name = ""metrics"", summary = ""http report"")
+public class PrometheusMetricsReporterCmd implements BaseCommand {
+
+    private final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(PrometheusMetricsReporterCmd.class);
+
+    public FrameworkModel frameworkModel;
+
+    public PrometheusMetricsReporterCmd(FrameworkModel frameworkModel) {
+        this.frameworkModel = frameworkModel;
+    }
+
+    @Override
+    public String execute(CommandContext commandContext, String[] args) {
+        if (args == null || args.length == 0) {
+            ApplicationModel applicationModel = ApplicationModel.defaultModel();
+            return getResponseByApplication(applicationModel);
+        } else {
+            String appName = args[0];
+            Optional<ApplicationModel> modelOptional = frameworkModel.getApplicationModels().stream().filter(applicationModel -> appName.equals(applicationModel.getApplicationName())).findFirst();
+            if (modelOptional.isPresent()) {
+                return getResponseByApplication(modelOptional.get());
+            } else {
+                return ""Not exist application: "" + appName;
+            }
+        }","[{'comment': 'can we return all of the applications', 'commenter': 'AlbumenJ'}]"
11752,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java,"@@ -109,6 +110,7 @@ public synchronized ExecutorService createExecutorIfAbsent(URL url) {
             executors.put(executorCacheKey, executor);
         }
 
+        executorCacheKey= (CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY)) ? ""DubboClientHandler"" : SERVER_THREAD_POOL_NAME ) + ""-"" + executorCacheKey;","[{'comment': 'please remove thread prefix  code  in  this  class', 'commenter': 'songxiaosheng'}]"
11752,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java,"@@ -57,6 +57,7 @@
 import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_ERROR_USE_THREAD_POOL;
 import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_EXECUTORS_NO_FOUND;
 import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_UNEXPECTED_EXECUTORS_SHUTDOWN;
+import static org.apache.dubbo.config.Constants.SERVER_THREAD_POOL_NAME;","[{'comment': '<img width=""768"" alt=""image"" src=""https://user-images.githubusercontent.com/81170548/223438418-9e24625e-3cd0-4ef7-b1a0-aa0702ae30ed.png"">\r\n', 'commenter': 'songxiaosheng'}]"
11756,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/filter/DefaultFilterChainBuilderTest.java,"@@ -49,7 +49,7 @@ protected Result doInvoke(Invocation invocation) {
         };
 
         Invoker<?> invokerAfterBuild = defaultFilterChainBuilder.buildInvokerChain(invokerWithoutFilter, REFERENCE_FILTER_KEY, CONSUMER);
-        Assertions.assertTrue(invokerAfterBuild instanceof AbstractInvoker);
+//        Assertions.assertTrue(invokerAfterBuild instanceof AbstractInvoker);","[{'comment': 'remove unused code', 'commenter': 'EarthChen'}, {'comment': 'handle unused code', 'commenter': 'jojocodeX'}]"
11756,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/filter/DefaultFilterChainBuilderTest.java,"@@ -64,7 +64,7 @@ protected Result doInvoke(Invocation invocation) {
         };
         invokerAfterBuild = defaultFilterChainBuilder.buildInvokerChain(invokerWithFilter, REFERENCE_FILTER_KEY, CONSUMER);
         Assertions.assertTrue(invokerAfterBuild instanceof FilterChainBuilder.CallbackRegistrationInvoker);
-        Assertions.assertEquals(1, ((FilterChainBuilder.CallbackRegistrationInvoker<?, ?>) invokerAfterBuild).filters.size());
+//        Assertions.assertEquals(1, ((FilterChainBuilder.CallbackRegistrationInvoker<?, ?>) invokerAfterBuild).filters.size());","[{'comment': 'some', 'commenter': 'EarthChen'}, {'comment': 'handle unused code', 'commenter': 'jojocodeX'}]"
11756,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/filter/DefaultFilterChainBuilderTest.java,"@@ -84,7 +84,7 @@ protected Result doInvoke(Invocation invocation) {
         };
 
         Invoker<?> invokerAfterBuild = defaultFilterChainBuilder.buildInvokerChain(invokerWithoutFilter, REFERENCE_FILTER_KEY, CONSUMER);
-        Assertions.assertTrue(invokerAfterBuild instanceof AbstractInvoker);
+//        Assertions.assertTrue(invokerAfterBuild instanceof AbstractInvoker);","[{'comment': 'some', 'commenter': 'EarthChen'}]"
11770,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/BiStreamServerCallListener.java,"@@ -27,24 +27,32 @@ public class BiStreamServerCallListener extends AbstractServerCallListener {
 
     private StreamObserver<Object> requestObserver;
 
-    public BiStreamServerCallListener(RpcInvocation invocation, Invoker<?> invoker,
-        ServerCallToObserverAdapter<Object> responseObserver) {
+    public BiStreamServerCallListener(RpcInvocation invocation,
+                                      Invoker<?> invoker,
+                                      ServerCallToObserverAdapter<Object> responseObserver) {
         super(invocation, invoker, responseObserver);
         invocation.setArguments(new Object[]{responseObserver});
         invoke();
     }
 
     @Override
+    @SuppressWarnings(""unchecked"")
     public void onReturn(Object value) {
-        this.requestObserver = (StreamObserver<Object>) value;
+        if (value instanceof Throwable) {
+            responseObserver.onError((Throwable) value);
+        } else if (value instanceof StreamObserver) {
+            this.requestObserver = (StreamObserver<Object>) value;
+        }
     }
 
     @Override
     public void onMessage(Object message) {
         if (message instanceof Object[]) {
             message = ((Object[]) message)[0];
         }
-        requestObserver.onNext(message);
+        if (requestObserver != null) {","[{'comment': ""Making a null judgment here doesn't seem to solve the underlying problem"", 'commenter': 'EarthChen'}, {'comment': 'Yes, just bounds checked. Waiting for underlying fixes.', 'commenter': 'mytang0'}]"
11786,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java,"@@ -325,13 +328,25 @@ protected void subscribeURLs(URL url, NotifyListener listener, Set<String> servi
                 serviceListeners.put(serviceNamesKey, serviceInstancesChangedListener);
             }
 
+            ApplicationModel applicationModel = url.getApplicationModel();
+            GlobalMetricsEventMulticaster eventMulticaster = applicationModel.getBeanFactory().getBean(GlobalMetricsEventMulticaster.class);
+            TimePair timePair = TimePair.start();
+
+            eventMulticaster.publishEvent(new RegistryEvent.MetricsServiceSubscribeEvent(applicationModel, timePair, serviceKey));
             if (!serviceInstancesChangedListener.isDestroyed()) {
                 listener.addServiceListener(serviceInstancesChangedListener);
                 serviceInstancesChangedListener.addListenerAndNotify(url, listener);
-                serviceDiscovery.addServiceInstancesChangedListener(serviceInstancesChangedListener);
+                try {
+                    serviceDiscovery.addServiceInstancesChangedListener(serviceInstancesChangedListener);
+                } catch (Throwable t) {
+                    eventMulticaster.publishErrorEvent(new RegistryEvent.MetricsServiceSubscribeEvent(applicationModel, timePair, serviceKey));
+                    throw t;
+                }
+                eventMulticaster.publishFinishEvent(new RegistryEvent.MetricsServiceSubscribeEvent(applicationModel, timePair, serviceKey));","[{'comment': 'Can we exact these logic into separated method like `doExecute(Runnable)`', 'commenter': 'AlbumenJ'}, {'comment': 'Will be optimized together later', 'commenter': 'wxbty'}]"
11798,dubbo-metrics/dubbo-metrics-metadata/src/test/java/org/apache/dubbo/metrics/metadata/MetadataStatCompositeTest.java,"@@ -37,8 +37,8 @@ public class MetadataStatCompositeTest {
     void testInit() {
         MetadataStatComposite statComposite = new MetadataStatComposite();
         Assertions.assertEquals(statComposite.numStats.size(), MetadataEvent.Type.values().length);
-        //(rt)5 * (push,subscribe)2
-        Assertions.assertEquals(5 * 2, statComposite.rtStats.size());
+        //(rt)5 * (push,subscribe,store provider)2","[{'comment': ""Shouldn't the assertion here be 5*4"", 'commenter': 'wxbty'}, {'comment': ""> Shouldn't the assertion here be 5*4\r\n\r\nstoreProvider is one but not store provider \r\ni will change the comment"", 'commenter': 'dengWuuu'}]"
11798,dubbo-metrics/dubbo-metrics-metadata/src/main/java/org/apache/dubbo/metrics/metadata/event/StoreProviderMetadataListener.java,"@@ -0,0 +1,49 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.metadata.event;
+
+import org.apache.dubbo.metrics.event.MetricsEvent;
+import org.apache.dubbo.metrics.listener.MetricsLifeListener;
+
+import static org.apache.dubbo.metrics.metadata.collector.stat.MetadataStatComposite.OP_TYPE_STORE_PROVIDER;
+
+public class StoreProviderMetadataListener implements MetricsLifeListener<MetadataEvent.StoreProviderMetadataEvent> {
+
+
+    @Override
+    public boolean isSupport(MetricsEvent event) {
+        return event instanceof MetadataEvent.StoreProviderMetadataEvent && ((MetadataEvent) event).isAvailable();
+    }
+
+    @Override
+    public void onEvent(MetadataEvent.StoreProviderMetadataEvent event) {
+        event.getCollector().increment(event.getSource().getApplicationName(), MetadataEvent.Type.S_P_TOTAL);","[{'comment': 'Why does the interface level store applicationName?', 'commenter': 'wxbty'}, {'comment': '> Why does the interface level store applicationName?\r\n\r\nAfter your pr merges I will change my code', 'commenter': 'dengWuuu'}, {'comment': 'done', 'commenter': 'dengWuuu'}]"
11798,dubbo-compatible/src/main/java/com/alibaba/dubbo/config/spring/context/annotation/EnableDubbo.java,"@@ -52,7 +52,7 @@
     String[] scanBasePackages() default {};
 
     /**
-     * Type-safe alternative to {@link #scanBasePackages()} for specifying the packages to
+     * ApplicationType-safe alternative to {@link #scanBasePackages()} for specifying the packages to","[{'comment': 'Please reduce irrelevant edits，otherwise the same', 'commenter': 'wxbty'}, {'comment': 'done', 'commenter': 'dengWuuu'}]"
11806,dubbo-metrics/dubbo-metrics-prometheus/src/main/java/org/apache/dubbo/metrics/prometheus/PrometheusMetricsReporterFactory.java,"@@ -18,21 +18,48 @@
 package org.apache.dubbo.metrics.prometheus;
 
 import org.apache.dubbo.common.URL;
-import org.apache.dubbo.metrics.report.MetricsReporter;
+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;
+import org.apache.dubbo.common.logger.LoggerFactory;
 import org.apache.dubbo.metrics.report.AbstractMetricsReporterFactory;
+import org.apache.dubbo.metrics.report.MetricsReporter;
 import org.apache.dubbo.rpc.model.ApplicationModel;
 
+import static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;
+
 /**
  * MetricsReporterFactory to create PrometheusMetricsReporter.
  */
 public class PrometheusMetricsReporterFactory extends AbstractMetricsReporterFactory {
 
+    private final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(PrometheusMetricsReporterFactory.class);
+
     public PrometheusMetricsReporterFactory(ApplicationModel applicationModel) {
         super(applicationModel);
     }
 
     @Override
     public MetricsReporter createMetricsReporter(URL url) {
-        return new PrometheusMetricsReporter(url, getApplicationModel());
+        try {
+            return new PrometheusMetricsReporter(url, getApplicationModel());
+        } catch (NoClassDefFoundError ncde) {
+            String msg = ncde.getMessage();
+            if (messageContainsPrometheusMetricsReporter(msg)) {
+                logger.error(INTERNAL_ERROR, """", """", ""Failed to load class \""org.apache.dubbo.metrics.prometheus.PrometheusMetricsReporter\""."", ncde);
+                logger.error(INTERNAL_ERROR, """", """", ""Defaulting to no-operation (NOP) metricsReporter implementation"", ncde);
+                logger.error(INTERNAL_ERROR, """", """", ""Introduce the micrometer-core package to use the ability of metrics"", ncde);
+                return new NopPrometheusMetricsReporter();
+            } else {
+                logger.error(INTERNAL_ERROR, """", """", ""Failed to instantiate PrometheusMetricsReporter"", ncde);
+                throw ncde;
+            }
+        }
+    }
+
+    private static boolean messageContainsPrometheusMetricsReporter(String msg) {","[{'comment': '```suggestion\r\n    private static boolean dependenciesNotFound(String msg) {\r\n```', 'commenter': 'AlbumenJ'}]"
11841,dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/MemorySafeLinkedBlockingQueueTest.java,"@@ -55,4 +56,59 @@ void testCustomReject() {
         assertThrows(RejectException.class, () -> queue.offer(() -> {
         }));
     }
+
+    @Test
+    void testEfficiency() throws InterruptedException {
+        // if length is vert large(unit test may runs for a long time), so you may need to modify JVM param such as : -Xms=1024m -Xmx=2048m
+        // if you want to test efficiency of MemorySafeLinkedBlockingQueue, you may modify following param: length and times
+        int length = 1000, times = 1;
+
+        // LinkedBlockingQueue insert Integer: 500W * 20 times
+        long spent1 = spend(new LinkedBlockingQueue<>(), length, times);
+
+        // MemorySafeLinkedBlockingQueue insert Integer: 500W * 20 times
+        long spent2 = spend(newMemorySafeLinkedBlockingQueue(),  length, times);
+        System.gc();
+        Thread.sleep(1000);","[{'comment': 'Should prevent use `sleep` in unit test', 'commenter': 'AlbumenJ'}, {'comment': 'done, please re-check', 'commenter': 'Planeswalker23'}]"
11841,dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/MemorySafeLinkedBlockingQueueTest.java,"@@ -55,4 +56,59 @@ void testCustomReject() {
         assertThrows(RejectException.class, () -> queue.offer(() -> {
         }));
     }
+
+    @Test
+    void testEfficiency() throws InterruptedException {
+        // if length is vert large(unit test may runs for a long time), so you may need to modify JVM param such as : -Xms=1024m -Xmx=2048m
+        // if you want to test efficiency of MemorySafeLinkedBlockingQueue, you may modify following param: length and times
+        int length = 1000, times = 1;
+
+        // LinkedBlockingQueue insert Integer: 500W * 20 times
+        long spent1 = spend(new LinkedBlockingQueue<>(), length, times);
+
+        // MemorySafeLinkedBlockingQueue insert Integer: 500W * 20 times
+        long spent2 = spend(newMemorySafeLinkedBlockingQueue(),  length, times);
+        System.gc();
+        Thread.sleep(1000);
+
+        System.out.println(String.format(""LinkedBlockingQueue spent %s millis, MemorySafeLinkedBlockingQueue spent %s millis"", spent1, spent2));","[{'comment': 'Std out here is useless', 'commenter': 'AlbumenJ'}, {'comment': 'Should have at least one assert', 'commenter': 'AlbumenJ'}, {'comment': 'done, please re-check', 'commenter': 'Planeswalker23'}]"
11843,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/ApplicationMetric.java,"@@ -18,20 +18,19 @@
 package org.apache.dubbo.metrics.model;
 
 import org.apache.dubbo.common.Version;
+import org.apache.dubbo.common.constants.MetricsConstants;
 
 import java.util.HashMap;
 import java.util.Map;
 
-import static org.apache.dubbo.common.constants.MetricsConstants.TAG_APPLICATION_NAME;
-import static org.apache.dubbo.common.constants.MetricsConstants.TAG_APPLICATION_VERSION_KEY;
-import static org.apache.dubbo.common.constants.MetricsConstants.TAG_HOSTNAME;
-import static org.apache.dubbo.common.constants.MetricsConstants.TAG_IP;
+import static org.apache.dubbo.common.constants.MetricsConstants.*;","[{'comment': ""don't use  *"", 'commenter': 'songxiaosheng'}]"
11850,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java,"@@ -96,6 +102,12 @@ private static AsciiString getSchemeFromUrl(URL url) {
         return ssl ? TripleConstant.HTTPS_SCHEME : TripleConstant.HTTP_SCHEME;
     }
 
+    private static Compressor getCompressorFromEnv() {
+        Configuration configuration = ConfigurationUtils.getEnvConfiguration(ApplicationModel.defaultModel());","[{'comment': '`ApplicationModel.defaultModel()` should not be used', 'commenter': 'EarthChen'}]"
11856,dubbo-common/pom.xml,"@@ -90,6 +90,7 @@
         <dependency>
             <groupId>com.alibaba.fastjson2</groupId>
             <artifactId>fastjson2</artifactId>
+            <optional>true</optional>","[{'comment': '```suggestion\r\n`fastjson2` as default json util\r\n```', 'commenter': 'AlbumenJ'}]"
11857,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MetricsKeyWrapper.java,"@@ -17,17 +17,28 @@
 
 package org.apache.dubbo.metrics.model;
 
+import java.util.Map;
+
 /**
  * Let {@link MetricsKey MetricsKey}  output dynamic, custom string content
  */
 public class MetricsKeyWrapper {
 
+    // Register、subscribe、notify etc","[{'comment': 'can use doc comment such as /* */', 'commenter': 'songxiaosheng'}, {'comment': 'ok', 'commenter': 'wxbty'}]"
11859,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHeaderEnum.java,"@@ -46,14 +46,20 @@ public enum TripleHeaderEnum {
 
     TRI_HEADER_CONVERT(""tri-header-convert""),
 
+    TRI_HEADER_EXCEPTION_CODE(""tri-header-exception-code""),","[{'comment': '`tri-exception-code` is better', 'commenter': 'EarthChen'}]"
11859,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHeaderEnum.java,"@@ -46,14 +46,20 @@ public enum TripleHeaderEnum {
 
     TRI_HEADER_CONVERT(""tri-header-convert""),
 
+    TRI_HEADER_EXCEPTION_CODE(""tri-header-exception-code""),
+
     ;
 
     static final Map<String, TripleHeaderEnum> enumMap = new HashMap<>();
 
     static final Set<String> excludeAttachmentsSet = new HashSet<>();
 
     static {
+        Set<String> needToDeliveryHeaders = needToDeliveryHeaders();
         for (TripleHeaderEnum item : TripleHeaderEnum.values()) {
+            if (needToDeliveryHeaders.contains(item.getHeader())) {","[{'comment': ""It's better not to make special judgments here."", 'commenter': 'EarthChen'}]"
11859,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java,"@@ -142,7 +163,11 @@ private void doSendMessage(Object message) {
         }
         final byte[] data;
         try {
-            data = packableMethod.packResponse(message);
+            if (message instanceof Exception && !isNeedReturnException) {
+                data = packableMethod.packResponse(new RpcException((Exception) message));","[{'comment': 'Should exceptions be serialized directly?', 'commenter': 'EarthChen'}]"
11859,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCallListener.java,"@@ -83,6 +83,9 @@ public void invoke() {
                     responseObserver.onCompleted(TriRpcStatus.DEADLINE_EXCEEDED);
                     return;
                 }
+                if (r.getValue() instanceof Throwable) {","[{'comment': 'Can the instanceof judgment be reduced?', 'commenter': 'EarthChen'}]"
11859,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/AbstractH2TransportListener.java,"@@ -45,6 +45,26 @@ public abstract class AbstractH2TransportListener implements H2TransportListener
      * @param trailers the metadata from remote
      * @return KV pairs map
      */
+    protected Map<String, Object> exceptionHeadersToMap(Map<String, String> reserved, Supplier<Object> convertUpperHeaderSupplier) {","[{'comment': 'Can it be merged with headertoMap?', 'commenter': 'EarthChen'}]"
11859,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/UnaryServerCallListener.java,"@@ -55,12 +56,32 @@ public void onCancel(TriRpcStatus status) {
     @Override
     protected void doOnResponseHasException(Throwable t) {
         if (needWrapper) {
-            onReturn(t);
+            if (t instanceof Exception) {
+                onReturnException(t);
+            } else {
+                onReturn(t);
+            }
         } else {
             super.doOnResponseHasException(t);
         }
     }
 
+    private void onReturnException(Object value) {","[{'comment': '`Exception value` is better', 'commenter': 'icodening'}]"
11859,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/UnaryServerCallListener.java,"@@ -55,12 +59,28 @@ public void onCancel(TriRpcStatus status) {
     @Override
     protected void doOnResponseHasException(Throwable t) {
         if (needWrapper) {
-            onReturn(t);
+            if (t instanceof Exception) {","[{'comment': 'Is judgment necessary here?', 'commenter': 'EarthChen'}]"
11859,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/UnaryClientCallListener.java,"@@ -42,7 +43,8 @@ public void onClose(TriRpcStatus status, Map<String, Object> trailers) {
         AppResponse result = new AppResponse();
         result.setObjectAttachments(trailers);
         if (status.isOk()) {
-            if (appResponse instanceof Exception) {
+           Integer exceptionCode = extractExceptionCode(trailers);
+            if (exceptionCode != 0) {","[{'comment': '0 should be a constant', 'commenter': 'EarthChen'}]"
11859,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleHeaderEnum.java,"@@ -70,6 +72,12 @@ public enum TripleHeaderEnum {
 
     }
 
+    public static Map<String, TripleHeaderEnum> needToDeliveryHeaders() {","[{'comment': 'unused ?', 'commenter': 'EarthChen'}, {'comment': 'containsNeedToDeliveryHeaders use it', 'commenter': 'aamingaa'}]"
11859,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/UnaryServerCallListener.java,"@@ -34,6 +35,9 @@ public UnaryServerCallListener(RpcInvocation invocation, Invoker<?> invoker,
 
     @Override
     public void onReturn(Object value) {
+        if (value instanceof Exception) {","[{'comment': 'Seems unnecessary?', 'commenter': 'EarthChen'}]"
11859,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ClientCall.java,"@@ -53,7 +53,7 @@ interface Listener {
          * @param status   response status
          * @param trailers response trailers
          */
-        void onClose(TriRpcStatus status, Map<String, Object> trailers);
+        void onClose(TriRpcStatus status, Map<String, Object> trailers, Map<String, String> triExceptionCodeAttachments);","[{'comment': 'Is it possible to have more than one exceptionCode? Why use maps', 'commenter': 'EarthChen'}, {'comment': 'it is to make implementable', 'commenter': 'aamingaa'}]"
11863,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/EventBus.java,"@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.event;
+
+import org.apache.dubbo.common.beans.factory.ScopeBeanFactory;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+import java.util.Optional;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+/**
+ * Dispatches events to listeners, and provides ways for listeners to register themselves.
+ */
+public class EventBus {
+
+    /**
+     * Posts an event to all registered subscribers and only once.
+     *
+     * @param event event to post.
+     */
+    public static void solo(MetricsEvent event) {
+        if (event.getSource() instanceof ApplicationModel) {","[{'comment': 'It is possible that source here is not a ApplicationModel? If so, we should change these usage. Otherwise, change the type of source', 'commenter': 'AlbumenJ'}, {'comment': 'Modify it to only be used as ApplicationModel', 'commenter': 'wxbty'}]"
11873,dubbo-metrics/dubbo-metrics-prometheus/src/test/java/org/apache/dubbo/metrics/prometheus/PrometheusMetricesThreadPoolTest.java,"@@ -0,0 +1,143 @@
+package org.apache.dubbo.metrics.prometheus;","[{'comment': 'please add apache licence', 'commenter': 'songxiaosheng'}]"
11873,dubbo-metrics/dubbo-metrics-prometheus/src/test/java/org/apache/dubbo/metrics/prometheus/PrometheusMetricesThreadPoolTest.java,"@@ -0,0 +1,143 @@
+package org.apache.dubbo.metrics.prometheus;
+import com.sun.net.httpserver.HttpServer;
+import org.apache.dubbo.config.*;","[{'comment': 'please remove  *', 'commenter': 'songxiaosheng'}]"
11873,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/ThreadPoolRejectMetric.java,"@@ -0,0 +1,79 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.model;
+
+import org.apache.dubbo.common.utils.ConfigUtils;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import static org.apache.dubbo.common.constants.MetricsConstants.*;","[{'comment': 'please  remove  *', 'commenter': 'songxiaosheng'}]"
11873,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/sample/ThreadRejectMetricsCountSampler.java,"@@ -0,0 +1,65 @@
+package org.apache.dubbo.metrics.collector.sample;
+
+import org.apache.dubbo.common.utils.ConcurrentHashSet;
+import org.apache.dubbo.metrics.collector.DefaultMetricsCollector;
+import org.apache.dubbo.metrics.model.*;","[{'comment': 'please remove  *', 'commenter': 'songxiaosheng'}]"
11879,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/TripleMessageProducer.java,"@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.tri.call;
+
+import org.apache.dubbo.common.function.ThrowableSupplier;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.function.Consumer;
+
+class TripleMessageProducer implements ClientCall.MessageProducer {
+
+    private final ThrowableSupplier<Object> throwableSupplier;
+
+    private Consumer<Throwable> throwableConsumer = (throwable) -> {
+    };
+
+    private TripleMessageProducer(ThrowableSupplier<Object> throwableSupplier) {
+        this.throwableSupplier = throwableSupplier;
+    }
+
+    public TripleMessageProducer onException(Consumer<Throwable> throwableConsumer) {
+        this.throwableConsumer = throwableConsumer;
+        return this;
+    }
+
+    @Override
+    public Object getMessage() {
+        try {
+            return throwableSupplier.get();
+        } catch (Throwable t) {
+            if (throwableConsumer != null) {
+                throwableConsumer.accept(t);
+            }
+            if (t instanceof RuntimeException) {
+                throw (RuntimeException) t;
+            }
+            if (t instanceof InvocationTargetException) {
+                Throwable targetException = ((InvocationTargetException) t).getTargetException();
+                throw new RuntimeException(targetException);","[{'comment': 'Why do you need to throw at the same time as consumer?', 'commenter': 'EarthChen'}, {'comment': 'Why use runtime to wrap exceptions?', 'commenter': 'EarthChen'}]"
11884,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java,"@@ -150,7 +164,15 @@ public void decode() throws Exception {
 
     private void handleValue(ObjectInput in) throws IOException {
         try {
-            Type[] returnTypes = RpcUtils.getReturnTypes(invocation);
+            Type[] returnTypes = null;
+            if(useInvocationReturn) {
+                if(invocation instanceof RpcInvocation) {
+                    returnTypes = ((RpcInvocation) invocation).getReturnTypes();
+                }
+            }","[{'comment': 'When calling generically, the deserialization here should be implemented by GenericFilter. If there is a generic problem, PojoUtils should be modified to solve it.', 'commenter': 'AlbumenJ'}]"
11885,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/codec/ExchangeCodec.java,"@@ -497,12 +497,12 @@ protected void encodeResponseData(Channel channel, ObjectOutput out, Object data
     }
 
     private Object finishRespWhenOverPayload(Channel channel, long size, byte[] header) {
-        int payload = getPayload(channel);
-        boolean overPayload = isOverPayload(payload, size);
-        if (overPayload) {
-            long reqId = Bytes.bytes2long(header, 4);
-            byte flag = header[2];
-            if ((flag & FLAG_REQUEST) == 0) {
+        byte flag = header[2];
+        if ((flag & FLAG_REQUEST) == 0) {
+            int payload = getPayload(channel);
+            boolean overPayload = isOverPayload(payload, size);
+            if (overPayload) {
+                long reqId = Bytes.bytes2long(header, 4);","[{'comment': 'What is the purpose of changing these lines?', 'commenter': 'AlbumenJ'}, {'comment': 'If ((flag & FLAG_REQUEST) == 0) is not satisfied, there is no need to execute getPayload and isOverPayload.', 'commenter': 'mytang0'}]"
11885,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboCodec.java,"@@ -158,6 +158,11 @@ protected Object decodeBody(Channel channel, InputStream is, byte[] header) thro
                     req.setEvent(true);
                 } else {
                     req = new HeartBeatRequest(id);","[{'comment': 'Please help change to `Request` here. There is a mistake when recreating heart beat event.', 'commenter': 'AlbumenJ'}, {'comment': 'Done', 'commenter': 'mytang0'}]"
11887,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"@@ -323,7 +325,7 @@ private Set<String> getServiceNames0(URL url) {
 
         final Set<String> serviceNames;
 
-        if (serviceName.isConcrete()) { // is the concrete service name
+        if (supportLegacyServiceName && serviceName.isConcrete()) { // is the concrete service name","[{'comment': ""Will Dubbo still subscribe to the original service name when `supportLegacyServiceName` is set to `false`? Because I didn't see the place where the original serviceName is added into serviceNames."", 'commenter': 'chickenlj'}, {'comment': 'fixed', 'commenter': 'AlbumenJ'}]"
11923,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/DefaultMetricsCollector.java,"@@ -41,6 +41,7 @@ public class DefaultMetricsCollector implements MetricsCollector {
 
     private boolean collectEnabled = false;
 
+    private boolean threadpoolCollectEnabled=false;","[{'comment': '```suggestion\r\n    private volatile boolean threadpoolCollectEnabled=false;\r\n```', 'commenter': 'AlbumenJ'}]"
11923,dubbo-common/src/main/java/org/apache/dubbo/config/MetricsConfig.java,"@@ -41,6 +41,11 @@ public class MetricsConfig extends AbstractConfig {
      */
     private Boolean enableJvmMetrics;
 
+    /**
+     * Enable jvm metrics when collecting.
+     */","[{'comment': 'comment is  error\n', 'commenter': 'songxiaosheng'}]"
11923,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -369,6 +369,7 @@ private void initMetricsReporter() {
         if (metricsConfig != null && PROTOCOL_PROMETHEUS.equals(metricsConfig.getProtocol())) {
             collector.setCollectEnabled(true);
             collector.collectApplication(applicationModel);
+            collector.setThreadpoolCollectEnabled(Optional.ofNullable(metricsConfig.getEnableThreadpoolMetrics()).orElse(false));","[{'comment': 'How about enable it as default?', 'commenter': 'AlbumenJ'}]"
11965,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java,"@@ -56,60 +58,37 @@ public void setWaitingFuture(CompletableFuture<?> waitingFuture) {
         this.waitingFuture = waitingFuture;
     }
 
-    private boolean isFinished() {
-        return finished;
-    }
-
-    private void setFinished(boolean finished) {
-        this.finished = finished;
-    }
-
     public boolean isWaiting() {","[{'comment': 'no need here, to be considered', 'commenter': 'icodening'}]"
11965,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java,"@@ -127,12 +128,14 @@ protected Result doInvoke(final Invocation invocation) {
             invocation.getParameterTypes());
         ClientCall call = new TripleClientCall(connectionClient, streamExecutor,
             getUrl().getOrDefaultFrameworkModel(), writeQueue);
-
+        Executor callbackExecutor = getCallbackExecutor(getUrl(), invocation);
         AsyncRpcResult result;
         try {
             switch (methodDescriptor.getRpcType()) {
                 case UNARY:
-                    result = invokeUnary(methodDescriptor, invocation, call);
+                    call = new TripleClientCall(connectionClient, callbackExecutor,","[{'comment': 'The call should not be new twice', 'commenter': 'EarthChen'}]"
11965,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java,"@@ -56,60 +58,37 @@ public void setWaitingFuture(CompletableFuture<?> waitingFuture) {
         this.waitingFuture = waitingFuture;
     }","[{'comment': 'can be removed?', 'commenter': 'icodening'}]"
11965,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/ThreadlessExecutor.java,"@@ -38,78 +39,39 @@
 public class ThreadlessExecutor extends AbstractExecutorService {
     private static final Logger logger = LoggerFactory.getLogger(ThreadlessExecutor.class.getName());
 
-    private final BlockingQueue<Runnable> queue = new LinkedBlockingQueue<>();
+    private static final Object SHUTDOWN = new Object();
 
-    private CompletableFuture<?> waitingFuture;
+    private final Queue<Runnable> queue = new ConcurrentLinkedQueue<>();
 
-    private boolean finished = false;
-
-    private volatile boolean waiting = true;
-
-    private final Object lock = new Object();
-
-    public CompletableFuture<?> getWaitingFuture() {
-        return waitingFuture;
-    }
-
-    public void setWaitingFuture(CompletableFuture<?> waitingFuture) {
-        this.waitingFuture = waitingFuture;
-    }
-
-    private boolean isFinished() {
-        return finished;
-    }
-
-    private void setFinished(boolean finished) {
-        this.finished = finished;
-    }
-
-    public boolean isWaiting() {
-        return waiting;
-    }
-
-    private void setWaiting(boolean waiting) {
-        this.waiting = waiting;
-    }
+    private volatile Object waiter;","[{'comment': 'Only need to be visible to other threads', 'commenter': 'icodening'}]"
11981,dubbo-demo/dubbo-demo-native/dubbo-demo-native-consumer/pom.xml,"@@ -51,6 +51,14 @@
             <groupId>org.apache.dubbo</groupId>
             <artifactId>dubbo-registry-zookeeper</artifactId>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-registry-nacos</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.alibaba.nacos</groupId>
+            <artifactId>nacos-client</artifactId>
+        </dependency>","[{'comment': 'plz remove useless dependencies.', 'commenter': 'Phixsura'}]"
11981,dubbo-demo/dubbo-demo-native/dubbo-demo-native-provider/pom.xml,"@@ -50,6 +51,10 @@
             <groupId>org.apache.dubbo</groupId>
             <artifactId>dubbo-registry-zookeeper</artifactId>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-registry-nacos</artifactId>
+        </dependency>","[{'comment': 'be the same as the above.', 'commenter': 'Phixsura'}, {'comment': 'Thanks. I will fix it later.', 'commenter': 'namelessssssssssss'}]"
11981,dubbo-demo/dubbo-demo-api/dubbo-demo-api-provider/src/main/java/org/apache/dubbo/demo/provider/Application.java,"@@ -47,23 +60,47 @@ private static void startWithBootstrap() {
 
         DubboBootstrap bootstrap = DubboBootstrap.getInstance();
         bootstrap.application(new ApplicationConfig(""dubbo-demo-api-provider""))
-            .registry(new RegistryConfig(""zookeeper://127.0.0.1:2181""))
+            .registry(new RegistryConfig(REGISTRY_URL))
             .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1))
             .service(service)
             .start()
             .await();
     }
 
     private static void startWithExport() throws InterruptedException {
-        ServiceConfig<DemoServiceImpl> service = new ServiceConfig<>();
-        service.setInterface(DemoService.class);
-        service.setRef(new DemoServiceImpl());
-        service.setApplication(new ApplicationConfig(""dubbo-demo-api-provider""));
-        service.setRegistry(new RegistryConfig(""zookeeper://127.0.0.1:2181""));
-        service.setMetadataReportConfig(new MetadataReportConfig(""zookeeper://127.0.0.1:2181""));
-        service.export();
+        FrameworkModel frameworkModel = new FrameworkModel();
+        ApplicationModel applicationModel = frameworkModel.newApplication();
+        ModuleModel moduleModel = applicationModel.newModule();
+
+        RegistryConfig registryConfig = new RegistryConfig(REGISTRY_URL);
+        MetadataReportConfig metadataReportConfig = new MetadataReportConfig(METADATA_REPORT_URL);
+        ProtocolConfig protocolConfig = new ProtocolConfig(CommonConstants.DUBBO, -1);
+
+        final String registryId = ""registry-1"";
+        final String metadataId = ""metadata-1"";
+        registryConfig.setId(registryId);
+        metadataReportConfig.setId(metadataId);
+
+        ConfigManager appConfigManager = applicationModel.getApplicationConfigManager();
+        appConfigManager.setApplication(new ApplicationConfig(""dubbo-demo-api-provider-app-1""));
+        appConfigManager.addRegistry(registryConfig);
+        appConfigManager.addMetadataReport(metadataReportConfig);
+        appConfigManager.addProtocol(protocolConfig);
+
+        ModuleConfigManager moduleConfigManager = moduleModel.getConfigManager();
+        moduleConfigManager.setModule(new ModuleConfig(""dubbo-demo-api-provider-app-1-module-1""));
+
+        ServiceConfig<DemoService> serviceConfig = new ServiceConfig<>();
+        serviceConfig.setScopeModel(moduleModel);
+        serviceConfig.setProtocol(protocolConfig);
+        serviceConfig.setInterface(DemoService.class);
+        serviceConfig.setRef(new DemoServiceImpl());
+
+        moduleConfigManager.addConfig(serviceConfig);
+
+        serviceConfig.export();
 
-        System.out.println(""dubbo service started"");
         new CountDownLatch(1).await();
     }
+","[{'comment': 'Leave bootstrap here is enough', 'commenter': 'AlbumenJ'}, {'comment': 'Sure. I will fix it.', 'commenter': 'namelessssssssssss'}]"
11987,dubbo-common/src/test/java/org/apache/dubbo/common/utils/ConcurrentHashMapUtilsTest.java,"@@ -37,4 +37,17 @@ public void testComputeIfAbsent() {
         ifAbsent = ConcurrentHashMapUtils.computeIfAbsent(map, ""mxsm"", k -> ""mxsm1"");
         assertEquals(""mxsm1"", ifAbsent);
     }
+
+    @Test
+    public void issue11986Test(){
+        // https://github.com/apache/dubbo/issues/11986
+        final ConcurrentHashMap<String,Integer> map=new ConcurrentHashMap<>();
+        // // map.computeIfAbsent(""AaAa"", key->map.computeIfAbsent(""BBBB"",key2->42));
+        if (JRE.JAVA_8.isCurrentVersion()) {","[{'comment': '这里应该任何版本的 JDK 都应该可以使用吧', 'commenter': 'AlbumenJ'}, {'comment': '并不是。这个bug在JDK8下会造成循环调用，但是jdk9+修复了这个问题，解决方式是有循环调用则抛出异常。这个test在jdk8下通过，jdk9+抛出异常。', 'commenter': 'looly'}, {'comment': '那基于 junit5 的注解做两个测试吧\r\n现在 PR的 UT 只跑 JDK17，JDK 8 11 17 的全量测试只有 scheduled 的时候跑', 'commenter': 'AlbumenJ'}, {'comment': '@AlbumenJ 是这个意思么？我拆分成两个test。', 'commenter': 'looly'}, {'comment': '```\r\n    @EnabledForJreRange(max = JRE.JAVA_8)\r\n    @EnabledForJreRange(min = JRE.JAVA_9)\r\n```', 'commenter': 'AlbumenJ'}, {'comment': '写两个 test，分别通过 EnabledForJreRange 配置运行的 jdk 版本', 'commenter': 'AlbumenJ'}, {'comment': '@AlbumenJ 辛苦看下。', 'commenter': 'looly'}]"
11987,dubbo-common/src/test/java/org/apache/dubbo/common/utils/ConcurrentHashMapUtilsTest.java,"@@ -37,4 +39,31 @@ public void testComputeIfAbsent() {
         ifAbsent = ConcurrentHashMapUtils.computeIfAbsent(map, ""mxsm"", k -> ""mxsm1"");
         assertEquals(""mxsm1"", ifAbsent);
     }
+
+    @Test
+    @EnabledForJreRange(max = org.junit.jupiter.api.condition.JRE.JAVA_8)
+    public void issue11986ForJava8Test(){
+        // https://github.com/apache/dubbo/issues/11986
+        final ConcurrentHashMap<String,Integer> map=new ConcurrentHashMap<>();
+        // // map.computeIfAbsent(""AaAa"", key->map.computeIfAbsent(""BBBB"",key2->42));
+
+        // JDK8下，由于循环调用bug，会造成执行computeIfAbsent死循环问题
+        // ConcurrentHashMapUtils.computeIfAbsent用于解决此问题，保证正常执行","[{'comment': 'Please comment in English', 'commenter': 'AlbumenJ'}, {'comment': '@AlbumenJ check it, please.', 'commenter': 'looly'}]"
11987,dubbo-common/src/main/java/org/apache/dubbo/common/utils/ConcurrentHashMapUtils.java,"@@ -35,7 +35,18 @@ public static <K, V> V computeIfAbsent(ConcurrentMap<K, V> map, K key, Function<
         if (JRE.JAVA_8.isCurrentVersion()) {
             V v = map.get(key);
             if (null == v) {
-                v = map.computeIfAbsent(key, func);
+                // issue#11986 lock bug
+                // v = map.computeIfAbsent(key, func);
+
+                // this bug fix methods maybe cause `func.apply` multiple calls.
+                v = func.apply(key);","[{'comment': 'Will this allocate more memory?', 'commenter': 'AlbumenJ'}, {'comment': 'yes', 'commenter': 'looly'}, {'comment': 'Please check whether v is null.', 'commenter': 'CrazyHZM'}]"
11989,dubbo-spring-boot/dubbo-spring-boot-observability-starter/pom.xml,"@@ -69,6 +69,11 @@
             <groupId>io.micrometer</groupId>
             <artifactId>micrometer-registry-prometheus</artifactId>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-metrics-prometheus</artifactId>
+            <version>${project.version}</version>
+        </dependency>","[{'comment': 'Just add related dependency here directly. Do not transitively depend on the entire package.', 'commenter': 'AlbumenJ'}, {'comment': 'Here we use Prometheus as the default implementation, otherwise we need to introduce an additional dubbo-metrics-prometheus  package', 'commenter': 'songxiaosheng'}]"
12012,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java,"@@ -386,7 +386,9 @@ private void refreshInvokers(BitList<Invoker<T>> targetInvokers, Collection<Invo
 
     @Override
     public void addDisabledInvoker(Invoker<T> invoker) {
-        MetricsEventBus.publish(DirectorSupport.disable(applicationModel));
+        if (invoker.getInterface() != null) {
+            MetricsEventBus.publish(DirectorSupport.disable(applicationModel, invoker.getInterface().getName()));","[{'comment': 'Can we replace with the exact invokers count in the collector after modify', 'commenter': 'AlbumenJ'}, {'comment': 'ok\r\n', 'commenter': 'wxbty'}]"
12012,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java,"@@ -499,4 +501,27 @@ protected String joinValidInvokerAddresses() {
             .map(URL::getAddress)
             .collect(Collectors.joining("",""));
     }
+
+    private Map<ServiceType, Map<String, Integer>> getSummary() {
+        Map<ServiceType, Map<String, Integer>> summaryMap = new HashMap<>();
+
+        summaryMap.put(ServiceType.D_VALID, groupByServiceKey(getValidInvokers()));
+        summaryMap.put(ServiceType.D_DISABLE, groupByServiceKey(getDisabledInvokers()));
+        summaryMap.put(ServiceType.D_TO_RECONNECT, groupByServiceKey(getInvokersToReconnect()));
+        summaryMap.put(ServiceType.D_ALL, groupByServiceKey(getInvokers()));
+        return summaryMap;
+    }
+
+    private Map<String, Integer> groupByServiceKey(Collection<Invoker<T>> invokers) {
+
+        Map<String, Integer> serviceNumMap = new HashMap<>();
+        if (invokers.size() > 0) {
+            serviceNumMap = invokers.stream().filter(invoker -> invoker.getInterface() != null).collect(Collectors.groupingBy(invoker -> invoker.getInterface().getName(), Collectors.reducing(0, e -> 1, Integer::sum)));
+            if (invokers.stream().anyMatch(invoker -> invoker.getInterface() == null)) {
+                serviceNumMap.clear();","[{'comment': 'Why clear here', 'commenter': 'AlbumenJ'}, {'comment': '![image](https://user-images.githubusercontent.com/38374721/230382382-1ccd960c-16a1-4cba-a947-22d9de8a3e0c.png)\r\nAn error will be reported without this line', 'commenter': 'wxbty'}]"
12039,dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/MultipleSerialization.java,"@@ -30,6 +30,6 @@ public interface MultipleSerialization {
 
     void serialize(URL url, String serializeType, Class<?> clz, Object obj, OutputStream os) throws IOException;
 
-    Object deserialize(URL url, String serializeType, Class<?> clz, InputStream os) throws IOException, ClassNotFoundException;
+    Object deserialize(URL url, String serializeType, Class<?> clz, InputStream os, boolean isReturnTriException) throws IOException, ClassNotFoundException;","[{'comment': 'dont change this', 'commenter': 'EarthChen'}]"
12039,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/PbUnpack.java,"@@ -35,4 +35,10 @@ public Object unpack(byte[] data) throws IOException {
         final ByteArrayInputStream bais = new ByteArrayInputStream(data);
         return SingleProtobufUtils.deserialize(bais, clz);
     }
+
+
+    public Object unpack(byte[] data, boolean isReturnTriException) throws IOException {","[{'comment': 'unused ?', 'commenter': 'EarthChen'}, {'comment': 'if remove it, the compiole with fail', 'commenter': 'aamingaa'}]"
12083,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/MetricsEvent.java,"@@ -33,6 +37,8 @@ public abstract class MetricsEvent {
     private boolean available = true;
     protected TypeWrapper typeWrapper;
 
+    private final Map<String, Object> attachment = new HashMap<>(8);","[{'comment': 'Do you consider using ConcurrentHashMap here to avoid the problem of multiple threads sharing variables', 'commenter': 'songxiaosheng'}]"
12083,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/listener/MetricsServiceListener.java,"@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.listener;
+
+import org.apache.dubbo.metrics.collector.ServiceMetricsCollector;
+import org.apache.dubbo.metrics.event.TimeCounterEvent;
+import org.apache.dubbo.metrics.model.key.MetricsKey;
+import org.apache.dubbo.metrics.model.key.MetricsPlaceType;
+
+import static org.apache.dubbo.metrics.MetricsConstants.ATTACHMENT_KEY_SERVICE;
+
+public class MetricsServiceListener extends AbstractMetricsListener {
+
+    public MetricsServiceListener(MetricsKey metricsKey) {
+        super(metricsKey);
+    }
+
+    public static AbstractMetricsListener onPostEventBuild(MetricsKey metricsKey, ServiceMetricsCollector<TimeCounterEvent> collector) {
+        return AbstractMetricsListener.onEvent(metricsKey,
+            event -> collector.increment(event.appName(), event.getAttachmentValue(ATTACHMENT_KEY_SERVICE), metricsKey, 1)
+        );
+    }
+
+    public static AbstractMetricsListener onFinishEventBuild(MetricsKey metricsKey, MetricsPlaceType placeType, ServiceMetricsCollector<TimeCounterEvent> collector) {
+        return AbstractMetricsListener.onFinish(metricsKey,
+            event -> incrAndAddRt(metricsKey, placeType, collector, event)
+        );
+    }
+
+    public static AbstractMetricsListener onErrorEventBuild(MetricsKey metricsKey, MetricsPlaceType placeType, ServiceMetricsCollector<TimeCounterEvent> collector) {
+        return AbstractMetricsListener.onError(metricsKey,
+            event -> incrAndAddRt(metricsKey, placeType, collector, event)
+        );
+    }
+
+    private static void incrAndAddRt(MetricsKey metricsKey, MetricsPlaceType placeType, ServiceMetricsCollector<TimeCounterEvent> collector, TimeCounterEvent event) {
+        collector.increment(event.appName(), event.getAttachmentValue(ATTACHMENT_KEY_SERVICE), metricsKey,1);","[{'comment': 'Can magic number 1 be modified to a constant', 'commenter': 'songxiaosheng'}, {'comment': 'done', 'commenter': 'wxbty'}]"
12085,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/util/ConstraintViolationExceptionConvert.java,"@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.rest.util;
+
+import org.apache.dubbo.common.utils.ClassUtils;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.protocol.rest.RestConstraintViolation;
+import org.apache.dubbo.rpc.protocol.rest.ViolationReport;
+
+import javax.validation.ConstraintViolation;
+import javax.validation.ConstraintViolationException;
+
+public class ConstraintViolationExceptionConvert {
+
+    public static boolean violationDependency() {
+        return ClassUtils.isPresent(""javax.validation.ConstraintViolationException"", ConstraintViolationExceptionConvert.class.getClassLoader());
+    }","[{'comment': 'Should not try class forname in a class which import that class.\r\nPlease move this check to RpcExceptionMapper.java.', 'commenter': 'AlbumenJ'}]"
12089,dubbo-metrics/dubbo-metrics-api/src/test/java/org/apache/dubbo/metrics/observation/DefaultDubboClientObservationConventionTest.java,"@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metrics.observation;
+
+import io.micrometer.common.KeyValues;
+import org.apache.dubbo.metrics.observation.utils.ObservationConventionUtils;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.RpcInvocation;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+
+@SuppressWarnings(""deprecation"")","[{'comment': 'Why add SuppressWarnings in this place?', 'commenter': 'songxiaosheng'}]"
12098,dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/util/CuratorFrameworkUtils.java,"@@ -155,7 +155,7 @@ public static String getRootPath(URL registryURL) {
         if (group.equalsIgnoreCase(DEFAULT_GROUP)) {
             group = GROUP_PATH.getParameterValue(registryURL);
             if (!group.startsWith(PATH_SEPARATOR)) {
-                group = PATH_SEPARATOR + group;
+                group = PATH_SEPARATOR + group + DEFAULT_GROUP;","[{'comment': 'What would this change?', 'commenter': 'AlbumenJ'}, {'comment': '避免服务注册监听路径和接口注册路径一样，导致服务注册启动不了。\r\n因为接口注册会在子目录下创建（consumers、providers）等子目录。\r\n如果这么修改会导致旧服务无法发现，可能有更好的方式处理。', 'commenter': 'stonelion'}]"
12139,dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/FailSafeClusterInvokerTest.java,"@@ -18,11 +18,7 @@
 
 import org.apache.dubbo.common.URL;
 import org.apache.dubbo.common.utils.LogUtil;
-import org.apache.dubbo.rpc.AppResponse;
-import org.apache.dubbo.rpc.Invoker;
-import org.apache.dubbo.rpc.Result;
-import org.apache.dubbo.rpc.RpcContext;
-import org.apache.dubbo.rpc.RpcInvocation;
+import org.apache.dubbo.rpc.*;","[{'comment': 'Please revert comma import', 'commenter': 'AlbumenJ'}]"
12139,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java,"@@ -331,6 +331,8 @@ public Result invoke(final Invocation invocation) throws RpcException {
 
         InvocationProfilerUtils.enterDetailProfiler(invocation, () -> ""Router route."");
         List<Invoker<T>> invokers = list(invocation);
+
+        checkInvokers(invokers, invocation);","[{'comment': 'Exception may throws here and will case memory leak of `DetailProfiler`', 'commenter': 'AlbumenJ'}]"
12163,dubbo-common/src/main/java/org/apache/dubbo/config/ServiceConfigBase.java,"@@ -297,6 +296,22 @@ public void setInterface(Class<?> interfaceClass) {
         }
     }
 
+    public boolean containsRestProtocol() {","[{'comment': 'Insert `Overrided` annotation', 'commenter': 'AlbumenJ'}]"
12163,dubbo-common/src/main/java/org/apache/dubbo/config/AbstractInterfaceConfig.java,"@@ -374,6 +375,10 @@ protected void processExtraRefresh(String preferredPrefix, InmemoryConfiguration
 
     }
 
+    protected boolean containsRestProtocol() {","[{'comment': '```suggestion\r\n    protected boolean canSkipInterfaceCheck() {\r\n```', 'commenter': 'AlbumenJ'}, {'comment': 'BTW, add some comment for this method', 'commenter': 'AlbumenJ'}]"
12199,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java,"@@ -260,7 +265,10 @@ RequestMetadata createRequest(MethodDescriptor methodDescriptor, Invocation invo
         if (methodDescriptor instanceof PackableMethod) {
             meta.packableMethod = (PackableMethod) methodDescriptor;
         } else {
-            meta.packableMethod = ReflectionPackableMethod.init(methodDescriptor, url);
+            final String contentType = APPLICATION_GRPC + ""+"" + UrlUtils.serializationOrDefault(url);","[{'comment': 'Do not dynamically concatenate content types for now', 'commenter': 'EarthChen'}, {'comment': 'Fixed', 'commenter': 'finefuture'}]"
12199,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ReflectionAbstractServerCall.java,"@@ -116,7 +120,10 @@ public void startCall() {
             }
         }
         if (methodDescriptor != null) {
-            packableMethod = ReflectionPackableMethod.init(methodDescriptor, invoker.getUrl());
+            final URL url = invoker.getUrl();
+            packableMethod = frameworkModel.getExtensionLoader(PackableMethodFactory.class)
+                .getExtension(ConfigurationUtils.getGlobalConfiguration(frameworkModel.defaultApplication()).getString(DUBBO_PACKABLE_METHOD_FACTORY, DEFAULT_KEY))","[{'comment': ""If it's an app model, it's still going to be in the url"", 'commenter': 'EarthChen'}, {'comment': 'Fixed', 'commenter': 'finefuture'}]"
12199,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ReflectionAbstractServerCall.java,"@@ -185,7 +191,10 @@ private void trySetMethodDescriptor(byte[] data) throws IOException {
                     + serviceDescriptor.getInterfaceName()), null);
             return;
         }
-        packableMethod = ReflectionPackableMethod.init(methodDescriptor, invoker.getUrl());
+        final URL url = invoker.getUrl();
+        packableMethod = frameworkModel.getExtensionLoader(PackableMethodFactory.class)
+            .getExtension(ConfigurationUtils.getGlobalConfiguration(frameworkModel.defaultApplication()).getString(DUBBO_PACKABLE_METHOD_FACTORY, DEFAULT_KEY))","[{'comment': 'same', 'commenter': 'EarthChen'}, {'comment': 'Fixed', 'commenter': 'finefuture'}]"
12223,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/DubboMergingDigest.java,"@@ -0,0 +1,896 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */","[{'comment': 'Please leave the license from T-Digest', 'commenter': 'AlbumenJ'}, {'comment': 'ok', 'commenter': 'wxbty'}]"
12223,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/aggregate/DubboAbstractTDigest.java,"@@ -0,0 +1,70 @@
+","[{'comment': '![image](https://user-images.githubusercontent.com/9292748/236078268-26145bbf-ab56-4e40-8583-e98a97f326c0.png)\r\n\r\nAlso add NOTICE https://github.com/tdunning/t-digest/blob/main/NOTICES', 'commenter': 'AlbumenJ'}, {'comment': 'ok', 'commenter': 'wxbty'}]"
12238,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/MetricsGlobalRegistry.java,"@@ -17,13 +17,18 @@
 
 package org.apache.dubbo.metrics;
 
+import io.micrometer.core.instrument.Metrics;
 import io.micrometer.core.instrument.composite.CompositeMeterRegistry;
 
 public class MetricsGlobalRegistry {
 
     private static final CompositeMeterRegistry compositeRegistry = new CompositeMeterRegistry();
 
     public static CompositeMeterRegistry getCompositeRegistry() {
-        return compositeRegistry;
+        if (Boolean.parseBoolean(System.getProperty(""dubbo.metrics.useGlobalRegistry"", ""true""))) {","[{'comment': 'Try to get from `ApplicationModel.environment`', 'commenter': 'AlbumenJ'}, {'comment': '0', 'commenter': 'wxbty'}]"
12238,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/MetricsGlobalRegistry.java,"@@ -17,13 +17,33 @@
 
 package org.apache.dubbo.metrics;
 
+import io.micrometer.core.instrument.Metrics;
 import io.micrometer.core.instrument.composite.CompositeMeterRegistry;
+import org.apache.dubbo.config.MetricsConfig;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+import java.util.Optional;
 
 public class MetricsGlobalRegistry {
 
-    private static final CompositeMeterRegistry compositeRegistry = new CompositeMeterRegistry();
+    private static CompositeMeterRegistry compositeRegistry = new CompositeMeterRegistry();
+
+    /**
+     * Use CompositeMeterRegistry according to the following priority
+     * 1. If useGlobalRegistry is configured, use the micrometer global CompositeMeterRegistry
+     * 2. If there is a spring actuator, use spring's CompositeMeterRegistry
+     * 3. Dubbo's own CompositeMeterRegistry is used by default
+     */
+    public static CompositeMeterRegistry getCompositeRegistry(ApplicationModel applicationModel) {","[{'comment': '这个get方法可以 提供一个兼容之前版本的么 参数不需要传递默认使用默认的应用程序model  供用户使用\n\n新的方法必须传递一个参数我们需要看看如何把指标模块开放给用户集成，允许用户采集自己系统的指标', 'commenter': 'songxiaosheng'}, {'comment': 'ok', 'commenter': 'wxbty'}]"
12264,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/message/codec/ResteasyResponseCodec.java,"@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.rpc.protocol.rest.message.codec;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.utils.ClassUtils;
+import org.apache.dubbo.common.utils.JsonUtils;
+import org.apache.dubbo.metadata.rest.media.MediaType;
+import org.apache.dubbo.rpc.protocol.rest.message.HttpMessageCodec;
+
+import java.io.OutputStream;
+import java.lang.reflect.Method;
+import java.nio.charset.StandardCharsets;
+
+@Activate(onClass=""javax.ws.rs.core.Response"")
+public class ResteasyResponseCodec implements HttpMessageCodec<byte[], OutputStream> {
+
+    private Class<?> responseClass;
+    public ResteasyResponseCodec(){
+        try {
+            responseClass = ClassUtils.forName(""javax.ws.rs.core.Response"");
+        } catch (Exception exception) {
+            responseClass = null;
+        }
+    }
+
+    @Override
+    public boolean contentTypeSupport(MediaType mediaType, Class<?> targetType) {
+        return isMatch(targetType);
+    }
+
+    @Override
+    public boolean typeSupport(Class<?> targetType) {
+        return isMatch(targetType);
+    }
+
+    @Override
+    public MediaType contentType() {
+        return MediaType.APPLICATION_JSON_VALUE;
+    }
+
+    @Override
+    public Object decode(byte[] body, Class<?> targetType) throws Exception {
+
+        Class<?> builtResponse = ClassUtils.forName(""org.jboss.resteasy.specimpl.BuiltResponse"");
+
+        Object o = builtResponse.newInstance();
+
+        Method method = builtResponse.getMethod(""setEntity"", Object.class);
+
+        method.invoke(o, new String(body, StandardCharsets.UTF_8));","[{'comment': 'Handle NPE here', 'commenter': 'AlbumenJ'}]"
12273,dubbo-metrics/dubbo-metrics-default/pom.xml,"@@ -46,5 +46,11 @@
             <artifactId>micrometer-tracing-integration-test</artifactId>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-qos-api</artifactId>","[{'comment': '指标模块作为基础设施，指标模块是否可以不依赖其他的具体模块，让其他模块来依赖指标模块', 'commenter': 'songxiaosheng'}]"
12273,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -369,27 +371,47 @@ private void initMetricsService() {
     }
 
     private void initMetricsReporter() {
+        if (!isSupportMetrics()) {
+            return;
+        }
         DefaultMetricsCollector collector =
             applicationModel.getBeanFactory().getBean(DefaultMetricsCollector.class);
         Optional<MetricsConfig> configOptional = configManager.getMetrics();
-
-        // TODO compatible with old usage of metrics, remove protocol check after new metrics is ready for use.
-        if (!isSupportPrometheus()) {
-            return;
+        boolean importMetricsPrometheus;
+        try {
+            Class.forName(""io.micrometer.prometheus.PrometheusConfig"");
+            importMetricsPrometheus = true;
+        } catch (ClassNotFoundException e) {
+            importMetricsPrometheus = false;
         }
+        //If no specific metrics type is configured and there is no Prometheus dependency in the dependencies.
         MetricsConfig metricsConfig = configOptional.orElse(new MetricsConfig(applicationModel));
         if (StringUtils.isBlank(metricsConfig.getProtocol())) {
-            metricsConfig.setProtocol(PROTOCOL_PROMETHEUS);
+            metricsConfig.setProtocol(importMetricsPrometheus ? PROTOCOL_PROMETHEUS : PROTOCOL_DEFAULT);
         }
         collector.setCollectEnabled(true);
         collector.collectApplication();
         collector.setThreadpoolCollectEnabled(Optional.ofNullable(metricsConfig.getEnableThreadpool()).orElse(true));
         MetricsReporterFactory metricsReporterFactory = getExtensionLoader(MetricsReporterFactory.class).getAdaptiveExtension();
-        MetricsReporter metricsReporter = metricsReporterFactory.createMetricsReporter(metricsConfig.toUrl());
+        MetricsReporter metricsReporter = null;
+        try {
+            metricsReporter = metricsReporterFactory.createMetricsReporter(metricsConfig.toUrl());
+        } catch (IllegalStateException e) {
+            if (e.getMessage().startsWith(""No such extension org.apache.dubbo.metrics.report.MetricsReporterFactory"")) {
+                logger.warn(COMMON_METRICS_COLLECTOR_EXCEPTION, """", """", e.getMessage());
+                return;
+            } else {
+                throw e;
+            }
+        }
         metricsReporter.init();
         applicationModel.getBeanFactory().registerBean(metricsReporter);
     }
 
+    public boolean isSupportMetrics() {
+        return isClassPresent(""io.micrometer.core.instrument.MeterRegistry"");","[{'comment': 'this method is replaced by  newer method isSupportPrometheus()', 'commenter': 'songxiaosheng'}]"
12273,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/report/DefaultMetricsReporter.java,"@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.report;
+
+import io.micrometer.core.instrument.Counter;
+import io.micrometer.core.instrument.Gauge;
+import io.micrometer.core.instrument.Timer;
+import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import java.util.concurrent.TimeUnit;
+
+public class DefaultMetricsReporter extends AbstractMetricsReporter {
+
+    SimpleMeterRegistry meterRegistry = new SimpleMeterRegistry();
+
+    protected DefaultMetricsReporter(URL url, ApplicationModel applicationModel) {
+        super(url, applicationModel);
+    }
+
+    @Override
+    public String getResponse() {
+        return null;
+    }
+
+    @Override
+    public String getResponseWithName(String metricsName) {
+        //name->tags->value
+        Map<String, Map<String, Object>> result = new HashMap<>();
+        StringBuilder sb = new StringBuilder();
+        meterRegistry.getMeters().stream().filter(meter -> {
+            if (metricsName != null) {
+                return meter.getId().getName().contains(metricsName);","[{'comment': 'meter and getId and getName need add Null check', 'commenter': 'songxiaosheng'}]"
12273,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/DefaultMetricsReporterCmd.java,"@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.qos.command.impl;
+
+import org.apache.dubbo.common.utils.JsonUtils;
+import org.apache.dubbo.metrics.report.MetricsReporter;
+import org.apache.dubbo.qos.api.BaseCommand;
+import org.apache.dubbo.qos.api.Cmd;
+import org.apache.dubbo.qos.api.CommandContext;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.FrameworkModel;
+
+import java.io.CharArrayReader;
+import java.io.IOException;
+import java.io.LineNumberReader;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+
+@Cmd(name = ""metrics_default"", summary = ""reuse qos report"")","[{'comment': 'Please use the descriptive information of \'see name and know meaning\'\r\n<img width=""594"" alt=""image"" src=""https://github.com/apache/dubbo/assets/81170548/dfd3fac1-c954-4989-948a-10f39e6c7904"">\r\n', 'commenter': 'songxiaosheng'}]"
12273,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/DefaultMetricsReporterCmd.java,"@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.qos.command.impl;
+
+import org.apache.dubbo.common.utils.JsonUtils;
+import org.apache.dubbo.metrics.report.MetricsReporter;
+import org.apache.dubbo.qos.api.BaseCommand;
+import org.apache.dubbo.qos.api.Cmd;
+import org.apache.dubbo.qos.api.CommandContext;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import org.apache.dubbo.rpc.model.FrameworkModel;
+
+import java.io.CharArrayReader;
+import java.io.IOException;
+import java.io.LineNumberReader;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+
+@Cmd(name = ""metrics_default"", summary = ""reuse qos report"")
+public class DefaultMetricsReporterCmd implements BaseCommand {
+
+    public FrameworkModel frameworkModel;
+
+    public DefaultMetricsReporterCmd(FrameworkModel frameworkModel) {
+        this.frameworkModel = frameworkModel;
+    }
+
+    @Override
+    public String execute(CommandContext commandContext, String[] args) {
+        List<ApplicationModel> models = frameworkModel.getApplicationModels();
+        String result = ""There is no application with data"";
+        if (notSpecifyApplication(args)) {
+            result = useFirst(models, result, null);
+        } else if (args.length == 1) {
+            result = specifyApplication(args[0], models, null);
+        } else if (args.length == 2) {
+            result = specifyApplication(args[0], models, args[1]);
+        }
+        return result;
+    }
+
+    private boolean notSpecifyApplication(String[] args) {
+        return args == null || args.length == 0;
+    }
+
+    private String useFirst(List<ApplicationModel> models, String result, String metricsName) {
+        for (ApplicationModel model : models) {
+            String current = getResponseByApplication(model, metricsName);
+            if (getLineNumber(current) > 0) {
+                result = current;
+                break;
+            }
+        }
+        return result;
+    }
+
+    private String specifyApplication(String appName, List<ApplicationModel> models, String metricsName) {
+        if (""application_all"".equals(appName)) {
+            return allApplication(models);
+        } else {
+            return specifySingleApplication(appName, models, metricsName);
+        }
+    }
+
+    private String specifySingleApplication(String appName, List<ApplicationModel> models, String metricsName) {
+        Optional<ApplicationModel> modelOptional = models.stream()
+            .filter(applicationModel -> appName.equals(applicationModel.getApplicationName())).findFirst();
+        if (modelOptional.isPresent()) {
+            return getResponseByApplication(modelOptional.get(), metricsName);
+        } else {
+            return ""Not exist application: "" + appName;
+        }
+    }
+
+    private String allApplication(List<ApplicationModel> models) {
+        Map<String, String> appResultMap = new HashMap<>();
+        for (ApplicationModel model : models) {
+            appResultMap.put(model.getApplicationName(), getResponseByApplication(model, null));
+        }
+        return JsonUtils.toJson(appResultMap);
+    }
+
+    private String getResponseByApplication(ApplicationModel applicationModel, String metricsName) {
+        String response = ""MetricsReporter not init"";
+        MetricsReporter metricsReporter = applicationModel.getBeanFactory().getBean(MetricsReporter.class);
+        if (metricsReporter != null) {
+            metricsReporter.refreshData();
+            response = metricsReporter.getResponseWithName(metricsName);
+        }
+        return response;
+    }
+
+
+    private static long getLineNumber(String content) {
+        LineNumberReader lnr = new LineNumberReader(new CharArrayReader(content.toCharArray()));","[{'comment': 'please fix NullPointException\r\n<img width=""1178"" alt=""image"" src=""https://github.com/apache/dubbo/assets/81170548/f8845a5c-8444-478f-9020-6e7728c2b3b3"">\r\n', 'commenter': 'songxiaosheng'}]"
12280,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java,"@@ -203,7 +204,9 @@ private void doReceived(Response res) {
             this.complete(res.getResult());
         } else if (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) {
             this.completeExceptionally(new TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()));
-        } else {
+        } else if(res.getStatus() == Response.SERIALIZATION_ERROR){
+            this.completeExceptionally(new SerializationException(channel, res.getErrorMessage()));","[{'comment': '`new RpcException(SERIALIZATION_EXCEPTION, res.getErrorMessaeg())` would be enough?', 'commenter': 'AlbumenJ'}, {'comment': 'As shown in the figure below, in the invoke method of AsyncToSyncInvoker, other exceptions are uniformly converted to RpcException. If you directly create a new RpcException(SERIALIZATION_EXCEPTION, res.getErrorMessage()) and throw it at the place you mentioned, would it conflict with the existing code logic?\r\n\r\nAlso, why did building and testing fail without any error messages?\r\n\r\n![image](https://github.com/apache/dubbo/assets/8465969/ebf9a3c9-0c33-4007-92f8-f94e3d9d25cf)\r\n', 'commenter': 'xuziyang'}]"
12286,dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcResult.java,"@@ -0,0 +1,115 @@
+package com.alibaba.dubbo.rpc;
+
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Map;
+
+@Deprecated
+public class RpcResult extends Result.AbstractResult implements Serializable {
+    private static final long serialVersionUID = -6925924956850004727L;
+    private Object result;
+    private Throwable exception;
+    private Map<String, String> attachments = new HashMap();
+
+    public RpcResult() {
+    }
+
+    public RpcResult(Object result) {
+        this.result = result;
+    }
+
+    public RpcResult(Throwable exception) {
+        this.exception = exception;
+    }
+
+    public Object recreate() throws Throwable {
+        if (this.exception != null) {
+            throw this.exception;
+        } else {
+            return this.result;
+        }
+    }
+
+    /** @deprecated */
+    @Deprecated
+    public Object getResult() {
+        return this.getValue();
+    }
+
+    /** @deprecated */
+    @Deprecated
+    public void setResult(Object result) {
+        this.setValue(result);
+    }
+
+    public Object getValue() {
+        return this.result;
+    }
+
+    public void setValue(Object value) {
+        this.result = value;
+    }
+
+    public Throwable getException() {
+        return this.exception;
+    }
+
+    public void setException(Throwable e) {
+        this.exception = e;
+    }
+
+    public boolean hasException() {
+        return this.exception != null;
+    }
+
+    public Map<String, String> getAttachments() {
+        return this.attachments;
+    }
+
+    public void setAttachments(Map<String, String> map) {
+        this.attachments = (Map)(map == null ? new HashMap() : map);
+    }
+
+    public void addAttachments(Map<String, String> map) {
+        if (map != null) {
+            if (this.attachments == null) {
+                this.attachments = new HashMap();
+            }
+
+            this.attachments.putAll(map);
+        }
+
+    }
+
+    public String getAttachment(String key) {
+        return (String)this.attachments.get(key);
+    }
+
+    public String getAttachment(String key, String defaultValue) {
+        String result = (String)this.attachments.get(key);
+        if (result == null || result.length() == 0) {
+            result = defaultValue;
+        }
+
+        return result;
+    }
+
+    public void setAttachment(String key, String value) {
+        this.attachments.put(key, value);
+    }
+
+    @Override
+    public void setAttachment(String key, Object value) {
+
+    }
+
+    @Override
+    public void setObjectAttachment(String key, Object value) {
+
+    }
+
+    public String toString() {
+        return ""RpcResult [result="" + this.result + "", exception="" + this.exception + ""]"";
+    }
+}
+","[{'comment': '```suggestion\r\npublic class RpcResult extends AppResponse implements com.alibaba.dubbo.rpc.Result {\r\n    public RpcResult() {\r\n    }\r\n\r\n    public RpcResult(Object result) {\r\n        super(result);\r\n    }\r\n\r\n    public RpcResult(Throwable exception) {\r\n        super(exception);\r\n    }\r\n}\r\n\r\n```', 'commenter': 'AlbumenJ'}, {'comment': ""Thanks for your code review.\r\nI tested on my local env, and add whenCompleteWithContext's empty implement which is called in FilterChainBuilder."", 'commenter': 'wegod'}]"
12286,dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/RpcResult.java,"@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.alibaba.dubbo.rpc;
+
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Map;
+
+public class RpcResult extends AppResponse implements com.alibaba.dubbo.rpc.Result {
+    public RpcResult() {
+    }
+
+    public RpcResult(Object result) {
+        super(result);
+    }
+
+    public RpcResult(Throwable exception) {
+        super(exception);
+    }
+    
+    @Override
+    public org.apache.dubbo.rpc.Result whenCompleteWithContext(BiConsumer<org.apache.dubbo.rpc.Result, Throwable> fn) {
+        return null;
+    }","[{'comment': 'What is the purpose of adding this?', 'commenter': 'AlbumenJ'}, {'comment': ""Wait a moment, I found when dubbo3 using dubbo2's Filter, RpcResult will be handle as AsyncRpcResult. \r\nThis function whenCompleteWithContext will be changed later, more code need to fix. "", 'commenter': 'wegod'}]"
12294,dubbo-common/src/main/java/org/apache/dubbo/common/config/ConfigurationUtils.java,"@@ -173,25 +172,23 @@ public static int get(ScopeModel scopeModel, String property, int defaultValue)
 
     public static Map<String, String> parseProperties(String content) throws IOException {
         Map<String, String> map = new HashMap<>();
-        if (StringUtils.isEmpty(content)) {
-            logger.warn(COMMON_UNEXPECTED_EXCEPTION, """", """", ""Config center was specified, but no config item found."");","[{'comment': 'Why change this?', 'commenter': 'AlbumenJ'}]"
12329,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/listener/AbstractMetricsListener.java,"@@ -20,16 +20,19 @@
 import org.apache.dubbo.common.utils.ReflectionUtils;
 import org.apache.dubbo.metrics.event.MetricsEvent;
 
-import java.util.List;
+import java.util.HashMap;
+import java.util.Map;
 
 public abstract class AbstractMetricsListener<E extends MetricsEvent> implements MetricsListener<E> {
 
+    private final Map<Class<?>, Boolean> eventMatchCache = new HashMap<>();","[{'comment': 'ConcurrentHashMap here', 'commenter': 'AlbumenJ'}, {'comment': 'Fixed', 'commenter': 'finefuture'}]"
12343,dubbo-compiler/pom.xml,"@@ -37,8 +37,9 @@
 
     <dependencies>
         <dependency>
-            <groupId>com.salesforce.servicelibs</groupId>
-            <artifactId>jprotoc</artifactId>
+            <groupId>com.github.spullara.mustache.java</groupId>","[{'comment': 'format', 'commenter': 'EarthChen'}]"
12343,dubbo-compiler/README.md,"@@ -0,0 +1,20 @@
+## dubbo-complier移除jpotoc依赖","[{'comment': 'pls use english', 'commenter': 'EarthChen'}]"
12343,dubbo-compiler/src/main/java/org/apache/dubbo/gen/AbstractGenerator.java,"@@ -261,6 +261,20 @@ private List<PluginProtos.CodeGeneratorResponse.File> buildFile(ServiceContext c
         return files;
     }
 
+    protected String applyTemplate(@Nonnull String resourcePath, @Nonnull Object generatorContext) {
+        Preconditions.checkNotNull(resourcePath, ""resourcePath"");
+        Preconditions.checkNotNull(generatorContext, ""generatorContext"");
+        InputStream resource = MustacheFactory.class.getClassLoader().getResourceAsStream(resourcePath);
+        if (resource == null) {
+            throw new RuntimeException(""Could not find resource "" + resourcePath);
+        } else {
+            InputStreamReader resourceReader = new InputStreamReader(resource, Charsets.UTF_8);
+            Mustache template = MUSTACHE_FACTORY.compile(resourceReader, resourcePath);
+            return template.execute(new StringWriter(), generatorContext).toString();
+        }
+    }
+
+","[{'comment': 'I think this is the redundant blank line needs to be removed', 'commenter': 'dongxuwang'}]"
12347,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java,"@@ -119,14 +127,22 @@ public Class<T> getInterface() {
      */
     @Override
     public Result invoke(Invocation invocation) throws RpcException {
+        // When broadcasting, it should be called remotely.
+        if (BROADCAST_CLUSTER.equalsIgnoreCase(getUrl().getParameter(CLUSTER_KEY))) {
+            logger.debug(""Performing broadcast call for method: "" + invocation.getMethodName() + "" of service: "" + getUrl().getServiceKey());","[{'comment': 'Check debug enabled here', 'commenter': 'AlbumenJ'}]"
12354,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/DubboAnnotationUtils.java,"@@ -25,11 +25,7 @@
 
 import org.springframework.util.Assert;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
+import java.util.*;","[{'comment': 'Please do not use comma import', 'commenter': 'AlbumenJ'}]"
12354,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/DubboAnnotationUtils.java,"@@ -154,7 +150,7 @@ public static String resolveInterfaceName(Reference reference, Class<?> defaultI
      */
     public static Map<String, String> convertParameters(String[] parameters) {
         if (ArrayUtils.isEmpty(parameters)) {
-            return Collections.emptyMap();
+            return new HashMap<>();","[{'comment': 'Null return in `org.apache.dubbo.config.AbstractMethodConfig#getParameters` is also need to be considered', 'commenter': 'AlbumenJ'}]"
12354,dubbo-common/src/main/java/org/apache/dubbo/config/AbstractMethodConfig.java,"@@ -240,7 +242,8 @@ public void setValidation(String validation) {
     }
 
     public Map<String, String> getParameters() {
-        return parameters;
+        this.parameters = Optional.ofNullable(parameters).orElseGet(HashMap::new);","[{'comment': 'Set the newly created map to `this`.', 'commenter': 'AlbumenJ'}]"
12357,dubbo-serialization/dubbo-serialization-api/src/main/java/org/apache/dubbo/common/serialize/DefaultSerializationExceptionWrapper.java,"@@ -0,0 +1,365 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.serialize;
+
+import org.apache.dubbo.common.URL;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.Type;
+import java.util.Map;
+
+public class DefaultSerializationExceptionWrapper implements Serialization {
+
+    private final Serialization serialization;
+
+    public DefaultSerializationExceptionWrapper(Serialization serialization) {
+        if (serialization == null) {
+            throw new IllegalArgumentException(""serialization == null"");
+        }
+        this.serialization = serialization;
+    }
+
+    @Override
+    public byte getContentTypeId() {
+        return serialization.getContentTypeId();
+    }
+
+    @Override
+    public String getContentType() {
+        return serialization.getContentType();
+    }
+
+    @Override
+    public ObjectOutput serialize(URL url, OutputStream output) throws IOException {
+        ObjectOutput objectOutput = serialization.serialize(url, output);
+        return new ProxyObjectOutput(objectOutput);
+    }
+
+    @Override
+    public ObjectInput deserialize(URL url, InputStream input) throws IOException {
+        ObjectInput objectInput = serialization.deserialize(url, input);
+        return new ProxyObjectInput(objectInput);
+    }
+
+    static class ProxyObjectInput implements ObjectInput {
+
+        private final ObjectInput target;
+
+        public ProxyObjectInput(ObjectInput target) {
+            this.target = target;
+        }
+
+        @Override
+        public boolean readBool() throws IOException {
+            try {
+                return target.readBool();
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public byte readByte() throws IOException {
+            try {
+                return target.readByte();
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+
+            }
+        }
+
+        @Override
+        public short readShort() throws IOException {
+            try {
+                return target.readShort();
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+
+            }
+        }
+
+        @Override
+        public int readInt() throws IOException {
+            try {
+                return target.readInt();
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+
+            }
+        }
+
+        @Override
+        public long readLong() throws IOException {
+            try {
+                return target.readLong();
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+
+            }
+        }
+
+        @Override
+        public float readFloat() throws IOException {
+            try {
+                return target.readFloat();
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public double readDouble() throws IOException {
+            try {
+                return target.readDouble();
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public String readUTF() throws IOException {
+            try {
+                return target.readUTF();
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public byte[] readBytes() throws IOException {
+            try {
+                return target.readBytes();
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public Object readObject() throws IOException, ClassNotFoundException {
+            try {
+                return target.readObject();
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public <T> T readObject(Class<T> cls) throws IOException, ClassNotFoundException {
+            try {
+                return target.readObject(cls);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public <T> T readObject(Class<T> cls, Type type) throws IOException, ClassNotFoundException {
+            try {
+                return target.readObject(cls, type);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public Throwable readThrowable() throws IOException {
+            try {
+                return target.readThrowable();
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public String readEvent() throws IOException {
+            try {
+                return target.readEvent();
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public Map<String, Object> readAttachments() throws IOException, ClassNotFoundException {
+            try {
+                return target.readAttachments();
+            } catch (Exception e) {
+                Throwable t = handleToIOException(e);
+                if (e instanceof ClassNotFoundException) {
+                    throw e;
+                }
+                throw (IOException) t;
+            }
+        }
+    }
+
+    static class ProxyObjectOutput implements ObjectOutput {
+
+        private final ObjectOutput target;
+
+        public ProxyObjectOutput(ObjectOutput target) {
+            this.target = target;
+        }
+
+        @Override
+        public void writeBool(boolean v) throws IOException {
+            try {
+                target.writeBool(v);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public void writeByte(byte v) throws IOException {
+            try {
+                target.writeByte(v);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public void writeShort(short v) throws IOException {
+            try {
+                target.writeShort(v);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public void writeInt(int v) throws IOException {
+            try {
+                target.writeInt(v);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public void writeLong(long v) throws IOException {
+            try {
+                target.writeLong(v);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public void writeFloat(float v) throws IOException {
+            try {
+                target.writeFloat(v);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public void writeDouble(double v) throws IOException {
+            try {
+                target.writeDouble(v);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public void writeUTF(String v) throws IOException {
+            try {
+                target.writeUTF(v);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public void writeBytes(byte[] v) throws IOException {
+            try {
+                target.writeBytes(v);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public void writeBytes(byte[] v, int off, int len) throws IOException {
+            try {
+                target.writeBytes(v);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public void flushBuffer() throws IOException {
+            try {
+                target.flushBuffer();
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public void writeObject(Object obj) throws IOException {
+            try {
+                target.writeObject(obj);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public void writeThrowable(Throwable obj) throws IOException {
+            try {
+                target.writeThrowable(obj);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public void writeEvent(String data) throws IOException {
+            try {
+                target.writeEvent(data);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+
+        @Override
+        public void writeAttachments(Map<String, Object> attachments) throws IOException {
+            try {
+                target.writeAttachments(attachments);
+            } catch (Exception e) {
+                throw (IOException) handleToIOException(e);
+            }
+        }
+    }
+
+    private static Throwable handleToIOException(Exception e) {
+        Throwable t = e.getCause();
+        if (!(t instanceof IOException)) {
+            t = new IOException(new SerializationException(e));
+        }
+        return t;
+    }","[{'comment': '```suggestion\r\n    private static IOException handleToIOException(Exception e) {\r\n        if (!(e instanceof IOException)) {\r\n            return new IOException(new SerializationException(e));\r\n        }\r\n        return (IOException) e;\r\n    }\r\n```', 'commenter': 'AlbumenJ'}]"
12357,dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/codec/DeprecatedExchangeCodec.java,"@@ -282,7 +282,7 @@ protected void encodeResponse(Channel channel, OutputStream os, Response res) th
                     logger.warn(TRANSPORT_FAILED_RESPONSE, """", """", ""Fail to encode response: "" + res + "", send bad_response info instead, cause: "" + t.getMessage(), t);
 
                     Response r = new Response(res.getId(), res.getVersion());
-                    r.setStatus(Response.BAD_RESPONSE);
+                    r.setStatus(Response.SERIALIZATION_ERROR);","[{'comment': 'Check if `t` is instance of `IOException`', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'wxbty'}]"
12361,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java,"@@ -447,6 +448,12 @@ private boolean checkProtocolValid(String queryProtocols, URL providerUrl) {
                 if (providerUrl.getProtocol().equals(acceptProtocol)) {
                     accept = true;
                     break;
+                } else {
+                    try {
+                        moduleModel.getApplicationModel().getExtensionLoader(Protocol.class).getExtension(acceptProtocol);","[{'comment': 'Use `hasExtension` would be better', 'commenter': 'AlbumenJ'}]"
12361,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/FailbackRegistry.java,"@@ -366,6 +366,9 @@ protected void notify(URL url, NotifyListener listener, List<URL> urls) {
         } catch (Exception t) {
             // Record a failed registration request to a failed list
             logger.error(REGISTRY_FAILED_NOTIFY_EVENT, """", """", ""Failed to notify addresses for subscribe "" + url + "", cause: "" + t.getMessage(), t);
+            if (t instanceof SkipFailbackWrapperException) {
+                throw t;
+            }","[{'comment': 'Is these still necessary', 'commenter': 'AlbumenJ'}, {'comment': 'will remove it', 'commenter': 'wxbty'}]"
12364,dubbo-dependencies-bom/pom.xml,"@@ -190,7 +190,7 @@
         <portlet_version>2.0</portlet_version>
         <maven_flatten_version>1.5.0</maven_flatten_version>
         <commons_compress_version>1.23.0</commons_compress_version>
-        <revision>3.2.2-SNAPSHOT</revision>
+        <revision>3.2.2</revision>","[{'comment': '版本号是不是写错啦', 'commenter': 'songxiaosheng'}, {'comment': '合了其它分支代码导致，已经调整', 'commenter': 'jojocodeX'}]"
12364,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/key/MetricsKey.java,"@@ -57,7 +57,9 @@ public enum MetricsKey {
     METRIC_RT_P95(""dubbo.%s.rt.milliseconds.p95"", ""Response Time P95""),
     METRIC_RT_P90(""dubbo.%s.rt.milliseconds.p90"", ""Response Time P90""),
     METRIC_RT_P50(""dubbo.%s.rt.milliseconds.p50"", ""Response Time P50""),
-
+    METRIC_RT_INTERNAL_MIN(""dubbo.%s.rt.interval.ms.min"", ""Response min Time Window""),
+    METRIC_RT_INTERNAL_MAX(""dubbo.%s.rt.interval.ms.max"", ""Response max Time Window""),","[{'comment': '这个命名统一用聚合会不会好看点interval换成聚合', 'commenter': 'songxiaosheng'}, {'comment': '已经调整', 'commenter': 'jojocodeX'}]"
12365,dubbo-common/src/main/java/org/apache/dubbo/common/logger/helpers/MessageFormatter.java,"@@ -0,0 +1,429 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */","[{'comment': '```suggestion\r\n/**\r\n * Copyright (c) 2004-2011 QOS.ch\r\n * All rights reserved.\r\n *\r\n * Permission is hereby granted, free  of charge, to any person obtaining\r\n * a  copy  of this  software  and  associated  documentation files  (the\r\n * ""Software""), to  deal in  the Software without  restriction, including\r\n * without limitation  the rights to  use, copy, modify,  merge, publish,\r\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\r\n * permit persons to whom the Software  is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The  above  copyright  notice  and  this permission  notice  shall  be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE  SOFTWARE IS  PROVIDED  ""AS  IS"", WITHOUT  WARRANTY  OF ANY  KIND,\r\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\r\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n```\r\n\r\nLeave the license header and add license check exclusion in `pom.xml` and `.licenserc.yaml`', 'commenter': 'AlbumenJ'}]"
12389,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java,"@@ -40,20 +41,24 @@
 public class MetricsFilter implements Filter, BaseFilter.Listener, ScopeModelAware {
 
     private ApplicationModel applicationModel;
-    private final static ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(MetricsFilter.class);
+    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(MetricsFilter.class);
+    private boolean metricsEnable;
 
     @Override
     public void setApplicationModel(ApplicationModel applicationModel) {
         this.applicationModel = applicationModel;
+        this.metricsEnable = applicationModel.getApplicationConfigManager().getMetrics().map(MetricsConfig::getEnabled).orElse(false);","[{'comment': '```suggestion\r\n        this.metricsEnable = applicationModel.getApplicationConfigManager().getMetrics().map(MetricsConfig::getEnabled).orElse(true);\r\n```\r\n\r\nEnabling metrics by default can provide users with a better experience.\r\nBTW, if micrometer cannot found, Dubbo will disable metrics.', 'commenter': 'AlbumenJ'}, {'comment': 'Fixed, i think we need add some tips on user page, like : dubbo.metrics.enabled = true  to use default metrics', 'commenter': 'finefuture'}]"
12389,dubbo-config/dubbo-config-spring/src/main/resources/META-INF/dubbo.xsd,"@@ -1098,6 +1098,12 @@
                 <xsd:documentation><![CDATA[ Deprecated. No longer use. ]]></xsd:documentation>
             </xsd:annotation>
         </xsd:attribute>
+","[{'comment': '开关可以默认是true', 'commenter': 'songxiaosheng'}, {'comment': 'Fixed', 'commenter': 'finefuture'}]"
12389,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/filter/MetricsFilter.java,"@@ -40,20 +41,24 @@
 public class MetricsFilter implements Filter, BaseFilter.Listener, ScopeModelAware {
 
     private ApplicationModel applicationModel;
-    private final static ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(MetricsFilter.class);
+    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(MetricsFilter.class);
+    private boolean metricsEnable;
 
     @Override
     public void setApplicationModel(ApplicationModel applicationModel) {
         this.applicationModel = applicationModel;
+        this.metricsEnable = applicationModel.getApplicationConfigManager().getMetrics().map(MetricsConfig::getEnabled).orElse(true);
     }
 
     @Override
     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
-        try {
-            RequestEvent requestEvent = RequestEvent.toRequestEvent(applicationModel, invocation);
-            MetricsEventBus.before(requestEvent, () -> invocation.put(METRIC_FILTER_EVENT, requestEvent));
-        } catch (Throwable t) {
-            LOGGER.warn(INTERNAL_ERROR, """", """", ""Error occurred when invoke."", t);
+        if (metricsEnable) {","[{'comment': '这个开关要不要改下名字，这个只是配置RPC的开关，我们指标还有三大中心、线程池、应用等指标信息，这个开关可以只控制RPC的指标采集，可以把名字改下见名知意', 'commenter': 'songxiaosheng'}, {'comment': '改成enableRpc了', 'commenter': 'finefuture'}]"
12389,dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java,"@@ -1002,7 +1002,7 @@ void testMetaData() throws Exception {
         List<Class<? extends AbstractConfig>> configClasses = Arrays.asList(ApplicationConfig.class,
                 ConsumerConfig.class, ProviderConfig.class, ReferenceConfig.class, ServiceConfig.class,
                 ProtocolConfig.class, RegistryConfig.class, ConfigCenterConfig.class, MetadataReportConfig.class,
-                ModuleConfig.class, SslConfig.class, MetricsConfig.class, MonitorConfig.class, MethodConfig.class);
+                ModuleConfig.class, SslConfig.class, MonitorConfig.class, MethodConfig.class);","[{'comment': 'Why change this?', 'commenter': 'AlbumenJ'}, {'comment': ""Because the property enableRpc of MetricsConfig is set to true, the metadata won't be empty\r\n![image](https://github.com/apache/dubbo/assets/18413695/29f552c5-b1e1-49ed-97bb-93165cc7d301)\r\n"", 'commenter': 'finefuture'}, {'comment': 'Is there any problem if set null as default?', 'commenter': 'AlbumenJ'}, {'comment': 'Fixed', 'commenter': 'finefuture'}]"
12427,dubbo-common/src/main/java/org/apache/dubbo/common/utils/ToStringUtils.java,"@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.utils;
+
+import java.util.Arrays;
+
+public class ToStringUtils {
+
+    private ToStringUtils() {
+    }
+
+    public static String printToString(Object obj) {
+        if (obj == null) {
+            return ""null"";
+        }
+        try {
+            return JsonUtils.getJson().toJson(obj);","[{'comment': '```suggestion\r\n            return JsonUtils.toJson(obj);\r\n```', 'commenter': 'AlbumenJ'}]"
12452,dubbo-common/src/main/java/org/apache/dubbo/common/utils/HttpUtils.java,"@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.utils;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.apache.dubbo.common.utils.HttpUtils.HttpMethod.GET;
+import static org.apache.dubbo.common.utils.HttpUtils.HttpMethod.POST;
+import static org.apache.dubbo.common.utils.HttpUtils.HttpMethod.DELETE;
+import static org.apache.dubbo.common.utils.HttpUtils.HttpMethod.PUT;
+import static org.apache.dubbo.common.utils.HttpUtils.HttpMethod.HEAD;
+import static org.apache.dubbo.common.utils.HttpUtils.HttpMethod.PATCH;
+import static org.apache.dubbo.common.utils.HttpUtils.HttpMethod.OPTIONS;
+import static org.apache.dubbo.common.utils.HttpUtils.HttpMethod.TRACE;
+
+/**
+ * for http methods
+ */
+public class HttpUtils {","[{'comment': 'This class is not suitable for the dubco-common module in terms of function and methods. There is no current intersection between qos and http handling except HttpMethod, and the methods in HttpUtils are not suitable for all modules.\r\n', 'commenter': 'CrazyHZM'}, {'comment': 'ok , I will change the position', 'commenter': 'suncairong163'}]"
12452,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ProtocolDetector.java,"@@ -17,18 +17,90 @@
 package org.apache.dubbo.remoting.api;
 
 
+import org.apache.dubbo.common.URL;
 import org.apache.dubbo.remoting.buffer.ChannelBuffer;
 
 
 /**
  * Determine incoming bytes belong to the specific protocol.
- *
  */
 public interface ProtocolDetector {
+    int empty = ' ';
+
+    default Result detect(ChannelBuffer in) {
+        return Result.UNRECOGNIZED;
+    }
+
+    default Result detect(ChannelBuffer in, URL url) {","[{'comment': ""I don't see a use for url, and it shouldn't be in this interface definition.\r\n"", 'commenter': 'CrazyHZM'}, {'comment': ' 1.qos和rest 在http检测这块是有冲突的， 当Qos 和rest同时开启时， 需要进行 requestUrl 判断 ， service经过 RestProtocol 进行export时才认为 rest开启，不能通过RestProtocol的存在与否判断，这个rest开启标志通过url进行传递\r\n 2.希望detector添加 开关，通过url属性进行判断\r\n 所以就增加了这个参数\r\n', 'commenter': 'suncairong163'}, {'comment': '1. 我在想qos有关http的是不是还是需要依赖http的模块，这样才能保证所有http的实现都在一个地方，它的层级应该跟triple是一样的，应该在抽象的http之上，qos的命令应该只是rest服务接口中的一部分，但是qos命令受开关影响，举个例子，有一个AbstractHttpProtocolDetector。\r\n2. 这个判断应该是有export的时候就应该把开关传递过来，就像QosEnableFlag，但我觉得这个开关的确可以被抽象在ProtocolDetector中。', 'commenter': 'CrazyHZM'}, {'comment': 'AbstractHttpProtocolDetector 这个抽象可以的有qos和http两个实现，ProtocolDetector 直接进行enable的set,因为QosWireProtocol 这个是单例的，不同url之间开关会不会有影响？增加url参数也是想动态的进行开关，还有就是如果用户想显式的关闭某种协议就不能单单通过export判断了', 'commenter': 'suncairong163'}]"
12452,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/api/ProtocolDetector.java,"@@ -17,18 +17,90 @@
 package org.apache.dubbo.remoting.api;
 
 
+import org.apache.dubbo.common.URL;
 import org.apache.dubbo.remoting.buffer.ChannelBuffer;
 
 
 /**
  * Determine incoming bytes belong to the specific protocol.
- *
  */
 public interface ProtocolDetector {
+    int empty = ' ';
+
+    default Result detect(ChannelBuffer in) {","[{'comment': 'There is no need to change this to `default`.\r\n', 'commenter': 'CrazyHZM'}]"
12453,dubbo-common/src/main/java/org/apache/dubbo/config/nested/ExporterConfig.java,"@@ -56,14 +55,27 @@ public static class ZipkinConfig implements Serializable {
         private String endpoint;
 
         /**
-         * Connection timeout for requests to Zipkin.
+         * Connection timeout for requests to Zipkin. (seconds)
          */
-        private Duration connectTimeout = Duration.ofSeconds(1);
+        private Integer connectTimeout = 1;","[{'comment': 'Is it possible not to change this signature?', 'commenter': 'AlbumenJ'}]"
12453,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -409,26 +415,35 @@ private void initMetricsReporter() {
         }
     }
 
-    public boolean isSupportMetrics() {
-        return isClassPresent(""io.micrometer.core.instrument.MeterRegistry"");
-    }
-
-    public static boolean isSupportPrometheus() {
-        return isClassPresent(""io.micrometer.prometheus.PrometheusConfig"")
-            && isClassPresent(""io.prometheus.client.exporter.BasicAuthHttpConnectionFactory"")
-            && isClassPresent(""io.prometheus.client.exporter.HttpConnectionFactory"")
-            && isClassPresent(""io.prometheus.client.exporter.PushGateway"");
-    }
-
+    /**
+     * init ObservationRegistry(Micrometer)
+     */
+    private void initObservationRegistry() {
+        if (!ObservationSupportUtil.isSupportObservation()) {
+            if (logger.isDebugEnabled()) {
+                logger.debug(""Not found micrometer-observation or plz check the version of micrometer-observation version if already introduced, need > 1.10.0"");
+            }
+            return;
+        }
+        if (!ObservationSupportUtil.isSupportTracing()) {
+            if (logger.isDebugEnabled()) {
+                logger.debug(""Not found micrometer-tracing dependency, skip init ObservationRegistry."");
+            }
+            return;
+        }
+        Optional<TracingConfig> configOptional = configManager.getTracing();
+        if (!configOptional.isPresent() || !configOptional.get().getEnabled()) {
+            return;
+        }
 
-    private static boolean isClassPresent(String className) {
-        return ClassUtils.isPresent(className, DefaultApplicationDeployer.class.getClassLoader());
+        DubboObservationRegistry dubboObservationRegistry = new DubboObservationRegistry(applicationModel, configOptional.get());","[{'comment': 'So only when all the above three conditions are matched will we initiate DubboObservationRegistry?', 'commenter': 'chickenlj'}, {'comment': 'Yes, due to the Observation.class was proposed after version 1.10 of micrometer, when users use springroot2.x, it defaults to 1.9.x, which means Observation.class is missing. We have made the corresponding judgment and provided users with debug level log prompts.\r\n\r\nAs for Option<TracingConfig>, this is the switch that determines whether Dubbo itself has enabled the Tracing function', 'commenter': 'conghuhu'}]"
12460,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConfigOperator.java,"@@ -36,6 +37,8 @@ public class NettyConfigOperator implements ChannelOperator {
     private final Channel channel;
     private ChannelHandler handler;
 
+    private ProtocolDetector.Result detectResult;","[{'comment': ""Where will this be used? I don't seem to see a place to use it?"", 'commenter': 'CrazyHZM'}, {'comment': 'This is for the `triple` protocol to support both `http1` and  `http2`', 'commenter': 'icodening'}]"
12468,dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invoker.java,"@@ -95,5 +95,10 @@ public void destroy() {
         public org.apache.dubbo.rpc.Invoker<T> getOriginal() {
             return invoker;
         }
+        
+        @Override
+        public int hashCode() {","[{'comment': 'override equals', 'commenter': 'AlbumenJ'}, {'comment': '> override equals\r\n\r\ndone', 'commenter': 'wegod'}]"
12468,dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invoker.java,"@@ -95,5 +95,15 @@ public void destroy() {
         public org.apache.dubbo.rpc.Invoker<T> getOriginal() {
             return invoker;
         }
+        
+        @Override
+        public int hashCode() {
+            return invoker.hashCode();
+        }
+        
+        @Override
+        public boolean equals(Object o) {
+            return invoker.equals(o);","[{'comment': ""Check if target object's type is `alibaba invoker` would be better?"", 'commenter': 'AlbumenJ'}, {'comment': ""\r\n> Check if target object's type is `alibaba invoker` would be better?\r\n\r\ndone"", 'commenter': 'wegod'}]"
12470,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java,"@@ -43,6 +43,8 @@ public abstract class RegistryNotifier {
     // for the first 10 notification will be notified immediately
     private final AtomicInteger executeTime = new AtomicInteger(0);
 
+    private final AtomicInteger rawAddressesVersion = new AtomicInteger(0);","[{'comment': '```suggestion\r\n    private static final AtomicInteger rawAddressesVersion = new AtomicInteger(0);\r\n``` \r\nwould be better', 'commenter': 'AlbumenJ'}]"
12492,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java,"@@ -58,7 +62,7 @@ protected void decode(ChannelHandlerContext ctx, io.netty.handler.codec.http.Ful
 
             // business handler
             try {
-                handler.handle(requestFacade, nettyHttpResponse);
+                new NettyHttpHandler(serviceDeployer, url).handle(requestFacade, nettyHttpResponse);","[{'comment': 'This can result in constant creation of `NettyHttpHandler` instances\r\n', 'commenter': 'CrazyHZM'}]"
12492,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/handler/NettyHttpHandler.java,"@@ -76,13 +69,21 @@ public void handle(NettyRequestFacade requestFacade, NettyHttpResponse nettyHttp
         // set response
         RpcContext.getServiceContext().setResponse(nettyHttpResponse);
 
-        RpcContext.getServerAttachment().setObjectAttachment(PATH_AND_INVOKER_MAPPER, pathAndInvokerMapper);
         // TODO add request filter chain
+        Object nettyHttpRequest = requestFacade.getRequest();
+
+        RpcContext.getServiceContext().setObjectAttachment(SERVICE_DEPLOYER_ATTRIBUTE_KEY, serviceDeployer);
 
-        FullHttpRequest nettyHttpRequest = requestFacade.getRequest();
 
         try {
-            doHandler(nettyHttpRequest, nettyHttpResponse, requestFacade);
+            new RestFilter() {
+                @Override
+                public void filter(URL url, RequestFacade requestFacade, NettyHttpResponse response, RestFilterChain restFilterChain) throws Exception {
+
+                    restFilterChain.filter(url, requestFacade, response, restFilterChain);
+                }
+            }.filter(url, requestFacade, nettyHttpResponse, new RestFilterChain(restFilters));","[{'comment': ""This looks like RestFilterChain is fixed, because restFilters are fixed, I think the RestFilterChain here is not unnecessary, looking at the RestFilterChain logic, should just iterate through the execution of these `restfilter`. I don't see much logic at the moment.\r\n "", 'commenter': 'CrazyHZM'}]"
12492,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/filter/ServiceInvokeRestResponseInterceptor.java,"@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.rest.filter;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.rpc.RpcInvocation;
+import org.apache.dubbo.rpc.protocol.rest.deploy.ServiceDeployer;
+import org.apache.dubbo.rpc.protocol.rest.netty.NettyHttpResponse;
+import org.apache.dubbo.rpc.protocol.rest.request.RequestFacade;
+
+
+import static org.apache.dubbo.rpc.protocol.rest.filter.ServiceInvokeRestFilter.writeResult;
+
+/**
+ *  default RestResponseInterceptor
+ */
+@Activate(value = ""invoke"",order = Integer.MAX_VALUE)
+public class ServiceInvokeRestResponseInterceptor implements RestResponseInterceptor {
+
+    @Override
+    public void intercept(URL url, RequestFacade request, NettyHttpResponse nettyHttpResponse, Object result, RpcInvocation rpcInvocation, RestResponseInterceptorChain interceptorChain, ServiceDeployer serviceDeployer) throws Exception {
+
+        writeResult(nettyHttpResponse, request, url, result, rpcInvocation.getReturnType());
+        nettyHttpResponse.setStatus(200);
+    }
+}","[{'comment': 'This does not need to exist and may skew other non-200 results.\r\n', 'commenter': 'CrazyHZM'}]"
12492,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/filter/ServiceInvokeRestFilter.java,"@@ -0,0 +1,199 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.rest.filter;
+
+import io.netty.handler.codec.http.FullHttpRequest;
+import io.netty.handler.codec.http.HttpRequest;
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;
+import org.apache.dubbo.common.logger.LoggerFactory;
+import org.apache.dubbo.metadata.rest.RestMethodMetadata;
+import org.apache.dubbo.metadata.rest.media.MediaType;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcInvocation;
+import org.apache.dubbo.rpc.model.FrameworkModel;
+import org.apache.dubbo.rpc.protocol.rest.RestHeaderEnum;
+import org.apache.dubbo.rpc.protocol.rest.RestRPCInvocationUtil;
+import org.apache.dubbo.rpc.protocol.rest.deploy.ServiceDeployer;
+import org.apache.dubbo.rpc.protocol.rest.exception.PathNoFoundException;
+import org.apache.dubbo.rpc.protocol.rest.exception.UnSupportContentTypeException;
+import org.apache.dubbo.rpc.protocol.rest.extension.ServiceDeployerContext;
+import org.apache.dubbo.rpc.protocol.rest.message.HttpMessageCodecManager;
+import org.apache.dubbo.rpc.protocol.rest.netty.NettyHttpResponse;
+import org.apache.dubbo.rpc.protocol.rest.pair.InvokerAndRestMethodMetadataPair;
+import org.apache.dubbo.rpc.protocol.rest.pair.MessageCodecResultPair;
+import org.apache.dubbo.rpc.protocol.rest.request.NettyRequestFacade;
+import org.apache.dubbo.rpc.protocol.rest.request.RequestFacade;
+import org.apache.dubbo.rpc.protocol.rest.util.MediaTypeUtil;
+
+import java.util.List;
+
+
+@Activate(value = ""invoke"", order = Integer.MAX_VALUE)
+public class ServiceInvokeRestFilter implements RestFilter, ServiceDeployerContext {
+    private final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(getClass());
+    private static final List<RestResponseInterceptor> restResponseInterceptors = FrameworkModel.defaultModel().getExtensionLoader(RestResponseInterceptor.class).getActivateExtensions();
+
+
+    @Override
+    public void filter(URL url, RequestFacade requestFacade, NettyHttpResponse nettyHttpResponse, RestFilterChain restFilterChain) throws Exception {
+        NettyRequestFacade nettyRequestFacade = (NettyRequestFacade) requestFacade;
+
+        FullHttpRequest nettyHttpRequest = nettyRequestFacade.getRequest();
+
+        doHandler(nettyHttpRequest, nettyHttpResponse, requestFacade, url, getServiceDeployer());
+
+    }
+
+
+    private void doHandler(HttpRequest nettyHttpRequest,
+                           NettyHttpResponse nettyHttpResponse,
+                           RequestFacade request,
+                           URL url,
+                           ServiceDeployer serviceDeployer) throws Exception {
+        //  acquire metadata by request
+        InvokerAndRestMethodMetadataPair restMethodMetadataPair = RestRPCInvocationUtil.getRestMethodMetadataAndInvokerPair(request);
+
+        // path NoFound 404
+        if (restMethodMetadataPair == null) {
+            throw new PathNoFoundException(""rest service Path no found, current path info:"" + RestRPCInvocationUtil.createPathMatcher(request));
+        }
+
+        Invoker invoker = restMethodMetadataPair.getInvoker();
+
+        RestMethodMetadata restMethodMetadata = restMethodMetadataPair.getRestMethodMetadata();
+
+        // method disallowed
+        if (!restMethodMetadata.getRequest().methodAllowed(request.getMethod())) {
+            nettyHttpResponse.sendError(405, ""service require request method is : ""
+                + restMethodMetadata.getRequest().getMethod()
+                + "", but current request method is: "" + request.getMethod()
+            );
+            return;
+        }
+
+
+        // content-type  support judge,throw unSupportException
+        acceptSupportJudge(request, restMethodMetadata.getReflectMethod().getReturnType());
+
+        // build RpcInvocation
+        RpcInvocation rpcInvocation = RestRPCInvocationUtil.createBaseRpcInvocation(request, restMethodMetadata);
+
+        // parse method real args
+        RestRPCInvocationUtil.parseMethodArgs(rpcInvocation, request, nettyHttpRequest, nettyHttpResponse, restMethodMetadata);
+
+        // execute business  method invoke
+        Result result = invoker.invoke(rpcInvocation);
+
+        if (result.hasException()) {
+            Throwable exception = result.getException();
+            logger.error("""", exception.getMessage(), """", ""dubbo rest protocol provider Invoker invoke error"", exception);
+
+            if (serviceDeployer.getExceptionMapper().hasExceptionMapper(exception)) {
+                writeResult(nettyHttpResponse, request, url, serviceDeployer.getExceptionMapper().exceptionToResult(result.getException()), rpcInvocation.getReturnType());
+                nettyHttpResponse.setStatus(200);
+            } else {
+                nettyHttpResponse.sendError(500,
+                    ""\n dubbo rest business exception, error cause is: ""
+                        + result.getException().getCause()
+                        + ""\n message is: "" + result.getException().getMessage()
+                        + ""\n stacktrace is: "" + stackTraceToString(exception));
+            }
+        } else {
+
+            // invoke the intercept chain before Result  write to  response
+            new RestResponseInterceptor() {
+                @Override
+                public void intercept(URL url, RequestFacade request, NettyHttpResponse response, Object result, RpcInvocation rpcInvocation, RestResponseInterceptorChain interceptorChain, ServiceDeployer serviceDeployer) throws Exception {
+                    interceptorChain.intercept(url, request, response, result, rpcInvocation, interceptorChain, serviceDeployer);
+                }
+            }.intercept(url, request, nettyHttpResponse, result.getValue(), rpcInvocation, new RestResponseInterceptorChain(restResponseInterceptors), serviceDeployer);","[{'comment': '1. Just RestResponseInterceptor cycle call, I think it is not necessary to increase RestResponseInterceptorChain.\r\n2. RestResponseInterceptor should also handle exceptions, so you should not only support RestResponseInterceptor when there are no exceptions', 'commenter': 'CrazyHZM'}]"
12492,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteay/filter/ResteasyContainerFilterAdapter.java,"@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.rest.extension.resteay.filter;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.rpc.RpcContext;
+import org.apache.dubbo.rpc.protocol.rest.extension.ServiceDeployerContext;
+import org.apache.dubbo.rpc.protocol.rest.filter.RestFilter;
+import org.apache.dubbo.rpc.protocol.rest.extension.resteay.ResteasyContext;
+import org.apache.dubbo.rpc.protocol.rest.filter.RestFilterChain;
+import org.apache.dubbo.rpc.protocol.rest.netty.NettyHttpResponse;
+import org.apache.dubbo.rpc.protocol.rest.request.RequestFacade;
+import org.jboss.resteasy.specimpl.BuiltResponse;
+
+import javax.ws.rs.container.ContainerRequestFilter;
+import java.util.List;
+
+import static org.apache.dubbo.common.constants.CommonConstants.RESTEASY_NETTY_HTTP_REQUEST_ATTRIBUTE_KEY;
+
+
+@Activate(value = ""resteasy"", onClass = {""javax.ws.rs.container.ContainerRequestFilter"", ""org.jboss.resteasy.plugins.server.netty.NettyHttpRequest""}, order = Integer.MAX_VALUE - 1)","[{'comment': 'There is also a lack of compatibility with `javax.ws.rs.container.ContainerResponseFilter`\r\n', 'commenter': 'CrazyHZM'}]"
12492,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/intercept/DubboServerWriterInterceptorContext.java,"@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.rest.extension.resteasy.intercept;
+
+import org.jboss.resteasy.core.interception.ServerWriterInterceptorContext;
+import org.jboss.resteasy.resteasy_jaxrs.i18n.LogMessages;
+import org.jboss.resteasy.spi.HttpRequest;
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
+
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.ext.WriterInterceptor;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+public class DubboServerWriterInterceptorContext extends ServerWriterInterceptorContext {
+    public DubboServerWriterInterceptorContext(WriterInterceptor[] interceptors, ResteasyProviderFactory providerFactory, Object entity, Class type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> headers, OutputStream outputStream, HttpRequest request) {
+        super(interceptors, providerFactory, entity, type, genericType, annotations, mediaType, headers, outputStream, request);
+    }
+
+
+    @Override
+    public void proceed() throws IOException, WebApplicationException {
+        LogMessages.LOGGER.debugf(""Interceptor Context: %s,  Method : proceed"", getClass().getName());","[{'comment': ""Replace with dubbo's own logger.\r\n"", 'commenter': 'CrazyHZM'}, {'comment': 'ping @suncairong163 ', 'commenter': 'CrazyHZM'}]"
12492,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/filter/RestFilterManager.java,"@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.rest.filter;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.RpcInvocation;
+import org.apache.dubbo.rpc.model.FrameworkModel;
+import org.apache.dubbo.rpc.protocol.rest.deploy.ServiceDeployer;
+import org.apache.dubbo.rpc.protocol.rest.filter.context.RestFilterContext;
+import org.apache.dubbo.rpc.protocol.rest.filter.context.RestInterceptContext;
+import org.apache.dubbo.rpc.protocol.rest.netty.NettyHttpResponse;
+import org.apache.dubbo.rpc.protocol.rest.request.RequestFacade;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class RestFilterManager {","[{'comment': 'Each method should go back to where it was originally used and static classes are not a very good approach.\r\nFor example, executeRequestFilters and executeResponseFilters should revert to NettyHttpHandler, and restRequestFilters should be fetched from the FrameworkModel in the context. Such as the url FrameworkModel.\r\n', 'commenter': 'CrazyHZM'}]"
12503,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AsyncRpcResult.java,"@@ -183,7 +183,7 @@ public Result get() throws InterruptedException, ExecutionException {
         if (executor != null && executor instanceof ThreadlessExecutor) {
             ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;
             try {
-                while (!responseFuture.isDone()) {
+                while (!responseFuture.isDone() && !responseFuture.isCancelled() && !responseFuture.isCompletedExceptionally() && !threadlessExecutor.isShutdown()) {","[{'comment': '`isDone` include `isCompletedExceptionally` and `isCancelled`', 'commenter': 'icodening'}, {'comment': 'done', 'commenter': 'AlbumenJ'}]"
12528,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -747,23 +747,27 @@ private void startModules() {
     }
 
     @Override
-    public void prepareApplicationInstance() {
+    public void prepareApplicationInstance(ModuleModel moduleModel) {","[{'comment': 'ApplicationDeployer depends on ModuleModel might not a good design.\nBTW, if there are more than one ModuleModels, will this work not expected?', 'commenter': 'AlbumenJ'}, {'comment': ""DefaultApplicationDeployer.java\r\n```java\r\n    public void notifyModuleChanged(ModuleModel moduleModel, DeployState state) {\r\n        checkState(moduleModel, state);\r\n    }\r\n\r\n    public void checkState(ModuleModel moduleModel, DeployState moduleState) {\r\n        synchronized (stateLock) {\r\n            if (!moduleModel.isInternal() && moduleState == DeployState.STARTED) {\r\n                prepareApplicationInstance(moduleModel);\r\n            }\r\n}\r\n```\r\n\r\nIt's currently designed to work this way: \r\n1. when the state of a ModuleModel changes, it will call `notifyModuleChanged` and passes ModuleModel instance in.\r\n2. `checkState` will then check if this ModelModel isInternal, if true, `prepareApplicationInstance(moduleModel);` will be called.\r\n\r\nApplicationDeployer depends on ModuleModel mainly querying for statuses such as 'STARTED', 'isInternal', and 'hasRegistryInteraction'. All these statuses can be wrapped into an Event or something, but I think this can be further optimized with this issue https://github.com/apache/dubbo/pull/12750"", 'commenter': 'chickenlj'}]"
12528,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -368,7 +370,17 @@ protected void exported() {
                 mapServiceName(url, serviceNameMapping, scheduledExecutor);
             }
         });
+
         onExported();
+
+        if (hasRegistrySpecified()) {
+            getScopeModel().getDeployer().getApplicationDeployer().exportMetadataService();","[{'comment': 'Depends on MetadataService here might not a good design', 'commenter': 'AlbumenJ'}, {'comment': 'Consider provide a solution for this issue with https://github.com/apache/dubbo/pull/12750', 'commenter': 'chickenlj'}, {'comment': 'It seems that the full service export process can move from ServiceConfig to a new ModuleLifecycle implement? This might solve this problem', 'commenter': 'namelessssssssssss'}, {'comment': 'Yes, I think so, this might need some extra efforts to merge this change with Lifecycle mechanism.', 'commenter': 'chickenlj'}]"
12534,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/AsyncRpcResult.java,"@@ -219,6 +219,8 @@ public Result whenCompleteWithContext(BiConsumer<Result, Throwable> fn) {
         if (setFutureWhenSync || ((RpcInvocation) invocation).getInvokeMode() != InvokeMode.SYNC) {
             // Necessary! update future in context, see https://github.com/apache/dubbo/issues/9461
             RpcContext.getServiceContext().setFuture(new FutureAdapter<>(this.responseFuture));
+        } else {
+            FutureContext.getContext().clearFuture();","[{'comment': 'Clear here might not a good idea. It would be better to skip set in advance.', 'commenter': 'AlbumenJ'}, {'comment': ' i will do this', 'commenter': 'xlq20080808'}]"
12534,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java,"@@ -129,7 +130,9 @@ protected Result doInvoke(final Invocation invocation) throws Throwable {
                 CompletableFuture<AppResponse> appResponseFuture =
                     currentClient.request(request, timeout, executor).thenApply(AppResponse.class::cast);
                 // save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter
-                FutureContext.getContext().setCompatibleFuture(appResponseFuture);
+                if (((RpcInvocation) invocation).getInvokeMode() != InvokeMode.SYNC) {","[{'comment': 'Check `private static final boolean setFutureWhenSync = Boolean.parseBoolean(System.getProperty(CommonConstants.SET_FUTURE_IN_SYNC_MODE, ""true""));`', 'commenter': 'AlbumenJ'}, {'comment': 'ok', 'commenter': 'xlq20080808'}]"
12536,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/aot/Netty4ReflectionTypeDescriberRegistrar.java,"@@ -35,16 +39,20 @@ public class Netty4ReflectionTypeDescriberRegistrar implements ReflectionTypeDes
     @Override
     public List<TypeDescriber> getTypeDescribers() {
         List<TypeDescriber> typeDescribers = new ArrayList<>();
-        typeDescribers.add(buildTypeDescriberWithDeclaredMethods(NettyServerHandler.class));
-        typeDescribers.add(buildTypeDescriberWithDeclaredMethods(SslServerTlsHandler.class));
-        typeDescribers.add(buildTypeDescriberWithDeclaredMethods(NettyClientHandler.class));
-        typeDescribers.add(buildTypeDescriberWithDeclaredMethods(SslClientTlsHandler.class));
+        typeDescribers.add(buildTypeDescriberWithPublicMethod(NettyServerHandler.class));
+        typeDescribers.add(buildTypeDescriberWithPublicMethod(SslServerTlsHandler.class));
+        typeDescribers.add(buildTypeDescriberWithPublicMethod(NettyClientHandler.class));
+        typeDescribers.add(buildTypeDescriberWithPublicMethod(SslClientTlsHandler.class));
+        typeDescribers.add(buildTypeDescriberWithPublicMethod(SelectorProvider.class));
+        typeDescribers.add(buildTypeDescriberWithPublicMethod(NettyPortUnificationServerHandler.class));
+        typeDescribers.add(buildTypeDescriberWithPublicMethod(NettyChannelHandler.class));
+        typeDescribers.add(buildTypeDescriberWithPublicMethod(NettyConnectionHandler.class));
         return typeDescribers;
     }
 
-    private TypeDescriber buildTypeDescriberWithDeclaredMethods(Class<?> c){
+    private TypeDescriber buildTypeDescriberWithPublicMethod(Class<?> cl) {
         Set<MemberCategory> memberCategories = new HashSet<>();
-        memberCategories.add(MemberCategory.INVOKE_DECLARED_METHODS);
-        return new TypeDescriber(c.getName(), null, new HashSet<>(), new HashSet<>(), new HashSet<>(), memberCategories);
+        memberCategories.add(MemberCategory.INVOKE_PUBLIC_METHODS);
+        return new TypeDescriber(cl.getName(), null, new HashSet<>(), new HashSet<>(), new HashSet<>(), memberCategories);","[{'comment': 'Why change this member category?', 'commenter': 'CrazyHZM'}, {'comment': 'cause to method https://github.com/netty/netty/blob/4.1/transport/src/main/java/io/netty/channel/ChannelHandlerMask.java#L167 public is enough and reflect config for ChannelHandler in netty project  is also public, for example:\r\n\r\n```json\r\n  {\r\n    ""name"": ""io.netty.channel.ChannelDuplexHandler"",\r\n    ""condition"": {\r\n      ""typeReachable"": ""io.netty.channel.ChannelDuplexHandler""\r\n    },\r\n    ""queryAllPublicMethods"": true\r\n  }\r\n```', 'commenter': 'FoghostCn'}]"
12539,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java,"@@ -476,12 +476,14 @@ protected void destroyInvokers() {
     }
 
     private boolean addValidInvoker(Invoker<T> invoker) {
+        MetricsEventBus.publish(RegistryEvent.refreshDirectoryEvent(applicationModel, getSummary()));","[{'comment': 'Publish after add', 'commenter': 'AlbumenJ'}]"
12543,dubbo-spring-boot/dubbo-spring-boot-starters/dubbo-sentinel-spring-boot-starter/pom.xml,"@@ -0,0 +1,51 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>org.apache.dubbo</groupId>
+        <artifactId>dubbo-spring-boot-starters</artifactId>
+        <version>${revision}</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
+
+    <artifactId>dubbo-sentinel-spring-boot-starter</artifactId>
+    <version>${revision}</version>
+    <packaging>jar</packaging>
+    <description>Apache Dubbo Sentinel Spring Boot Starter</description>
+
+    <properties>
+        <sentinel.version>1.8.6</sentinel.version>
+    </properties>","[{'comment': 'Can this version be managed in dependencies bom', 'commenter': 'AlbumenJ'}, {'comment': 'Modified', 'commenter': 'conghuhu'}]"
12547,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java,"@@ -473,12 +467,12 @@ public boolean equals(Object o) {
             return false;
         }
         ServiceInstancesChangedListener that = (ServiceInstancesChangedListener) o;
-        return Objects.equals(getServiceNames(), that.getServiceNames()) && Objects.equals(listeners, that.listeners);
+        return Objects.equals(getServiceNames(), that.getServiceNames());","[{'comment': 'In different ApplicationModel, listeners are different', 'commenter': 'AlbumenJ'}, {'comment': '@AlbumenJ Should the listeners parameter be retained in equals, or should we use the ApplicationModel to determine', 'commenter': 'finefuture'}, {'comment': '> listeners parameter be retained in equals\r\n\r\nok', 'commenter': 'AlbumenJ'}]"
12582,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -513,8 +515,8 @@ private void doExportUrls(RegisterTypeEnum registerType) {
         repository.registerProvider(providerModel);
 
         List<URL> registryURLs = ConfigValidationUtils.loadRegistries(this, true);
-
-        MetricsEventBus.post(RegistryEvent.toRsEvent(module.getApplicationModel(), getUniqueServiceName(), protocols.size() * registryURLs.size()),
+        List<String> ServiceDiscoveryNames = registryURLs.stream().map(url-> url.getParameter(RegistryConstants.REGISTRY_CLUSTER_KEY)).distinct().collect(Collectors.toList());","[{'comment': '```suggestion\r\n        List<String> serviceDiscoveryNames = registryURLs.stream().map(url-> url.getParameter(RegistryConstants.REGISTRY_CLUSTER_KEY)).distinct().collect(Collectors.toList());\r\n```\r\nlower case', 'commenter': 'AlbumenJ'}, {'comment': 'ok', 'commenter': 'wxbty'}]"
12582,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -899,12 +900,16 @@ private DynamicConfiguration getDynamicConfiguration(URL connectionURL) {
     private void registerServiceInstance() {
         try {
             registered = true;
-            MetricsEventBus.post(RegistryEvent.toRegisterEvent(applicationModel),
-                () -> {
-                    ServiceInstanceMetadataUtils.registerMetadataAndInstance(applicationModel);
-                    return null;
-                }
-            );
+            List<ServiceDiscovery> serviceDiscoveries = ServiceInstanceMetadataUtils.getServiceDiscoveries(applicationModel);
+            if (serviceDiscoveries.size() > 0) {
+                MetricsEventBus.post(RegistryEvent.toRegisterEvent(applicationModel, ServiceInstanceMetadataUtils.getServiceDiscoveryNames(serviceDiscoveries)),","[{'comment': 'Move this `MetricsEventBus` into `ServiceInstanceMetadataUtils.registerMetadataAndInstance` would be better', 'commenter': 'AlbumenJ'}, {'comment': 'ok', 'commenter': 'wxbty'}]"
12582,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"@@ -513,8 +515,9 @@ private void doExportUrls(RegisterTypeEnum registerType) {
         repository.registerProvider(providerModel);
 
         List<URL> registryURLs = ConfigValidationUtils.loadRegistries(this, true);
-
-        MetricsEventBus.post(RegistryEvent.toRsEvent(getApplicationModel(), getUniqueServiceName(), protocols.size() * registryURLs.size()),            () -> {
+        List<String> serviceDiscoveryNames = registryURLs.stream().map(url-> url.getParameter(RegistryConstants.REGISTRY_CLUSTER_KEY)).distinct().collect(Collectors.toList());
+        MetricsEventBus.post(RegistryEvent.toRsEvent(getApplicationModel(), getUniqueServiceName(), protocols.size(), serviceDiscoveryNames),
+            () -> {","[{'comment': 'It is not a good idea to working on some service discovery related in `ServiceConfig`', 'commenter': 'AlbumenJ'}, {'comment': 'moved to Defaultdeploy', 'commenter': 'wxbty'}]"
12582,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MetricsSupport.java,"@@ -61,23 +62,42 @@ public class MetricsSupport {
     private static final String version = Version.getVersion();
     private static final String commitId = Version.getLastCommitId();
 
-    public static Map<String, String> applicationTags(ApplicationModel applicationModel) {
+    public static Map<String, String> applicationTags(ApplicationModel applicationModel, @Nullable Map<String, String> extraInfo) {","[{'comment': 'Add a overwrite method `Map<String, String> applicationTags(ApplicationModel applicationModel)` to prevent use `null` for caller', 'commenter': 'AlbumenJ'}, {'comment': 'ok', 'commenter': 'wxbty'}]"
12582,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java,"@@ -428,7 +434,14 @@ private void exportServiceInternal(ServiceConfigBase sc) {
             asyncExportingFutures.add(future);
         } else {
             if (!sc.isExported()) {
-                sc.export(RegisterTypeEnum.AUTO_REGISTER_BY_DEPLOYER);
+                List<URL> registryURLs = ConfigValidationUtils.loadRegistries(sc, true);","[{'comment': 'Move to `RegistryProtocol` would be better', 'commenter': 'AlbumenJ'}, {'comment': 'RegistryProtocol can only handle one, and multiple registries will be processed in a loop. Do you really want to move here?', 'commenter': 'wxbty'}]"
12582,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java,"@@ -201,7 +205,24 @@ public static void registerMetadataAndInstance(ApplicationModel applicationModel
         LOGGER.info(""Start registering instance address to registry."");
         RegistryManager registryManager = applicationModel.getBeanFactory().getBean(RegistryManager.class);
         // register service instance
-        registryManager.getServiceDiscoveries().forEach(ServiceDiscovery::register);
+        List<ServiceDiscovery> serviceDiscoveries = registryManager.getServiceDiscoveries();
+        serviceDiscoveries.forEach(ServiceDiscovery::register);
+        if (serviceDiscoveries.size() > 0) {
+            MetricsEventBus.post(RegistryEvent.toRegisterEvent(applicationModel, getServiceDiscoveryNames(serviceDiscoveries)),
+                () -> {
+                    // register service instance
+                    serviceDiscoveries.forEach(ServiceDiscovery::register);
+                    return null;
+                }
+            );
+        }
+    }
+
+    private static List<String> getServiceDiscoveryNames(List<ServiceDiscovery> serviceDiscoveries) {
+        return serviceDiscoveries
+            .stream()
+            .map(sd -> sd.getUrl().getParameter(RegistryConstants.REGISTRY_CLUSTER_KEY))","[{'comment': 'If `REGISTRY_CLUSTER` is empty, use `protocol` by default', 'commenter': 'AlbumenJ'}]"
12582,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultModuleDeployer.java,"@@ -428,7 +434,14 @@ private void exportServiceInternal(ServiceConfigBase sc) {
             asyncExportingFutures.add(future);
         } else {
             if (!sc.isExported()) {
-                sc.export(RegisterTypeEnum.AUTO_REGISTER_BY_DEPLOYER);
+                List<URL> registryURLs = ConfigValidationUtils.loadRegistries(sc, true);
+                List<String> serviceDiscoveryNames = registryURLs.stream().map(url-> url.getParameter(RegistryConstants.REGISTRY_CLUSTER_KEY)).distinct().collect(Collectors.toList());","[{'comment': 'If `REGISTRY_CLUSTER` is empty, use `protocol` by default', 'commenter': 'AlbumenJ'}]"
12635,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/RpcServiceContext.java,"@@ -201,6 +202,10 @@ public URL getUrl() {
     @Override
     public void setUrl(URL url) {
         this.url = url;
+        if (url.getSide().equals(CommonConstants.CONSUMER)) {
+            this.remoteApplicationName = url.getRemoteApplication();
+            this.setRemoteAddress(url.getHost(), url.getPort());
+        }","[{'comment': '![image](https://github.com/apache/dubbo/assets/9292748/9454d8c5-355b-4d08-851a-c468d114efae)\r\n\r\nSet remote attribute in `org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker#invokeWithContext` would be a better choice.\r\n```\r\n    private static void setRemote(Invoker<?> invoker, Invocation invocation) {\r\n        invocation.addInvokedInvoker(invoker);\r\n        RpcContext.getServiceContext().setRemoteAddress(invoker.getUrl().toInetSocketAddress());\r\n        RpcContext.getServiceContext().setRemoteApplicationName(invoker.getUrl().getRemoteApplication());\r\n    }\r\n```', 'commenter': 'AlbumenJ'}, {'comment': '@AlbumenJ hello, I have fix them,and I run the local test on filter  can get them', 'commenter': 'xixingya'}]"
12635,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboInvoker.java,"@@ -107,8 +107,6 @@ protected Result doInvoke(final Invocation invocation) throws Throwable {
 
             invocation.setAttachment(TIMEOUT_KEY, String.valueOf(timeout));
 
-            RpcContext.getServiceContext().setRemoteAddress(currentClient.getRemoteAddress());","[{'comment': '![image](https://github.com/apache/dubbo/assets/9292748/d9de2170-29e6-4644-94cb-894e491214e7)\r\n\r\nCheck style should be fixed.', 'commenter': 'AlbumenJ'}, {'comment': 'thanks,I will fix', 'commenter': 'xixingya'}]"
12657,dubbo-plugin/dubbo-plugin-cross-thread/src/main/java/org/apache/dubbo/crossthread/interceptor/RunnableOrCallableMethodInterceptor.java,"@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.crossthread.interceptor;
+
+import net.bytebuddy.asm.Advice;
+
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.rpc.RpcContext;
+
+public class RunnableOrCallableMethodInterceptor {
+
+    @Advice.OnMethodEnter
+    public static void onMethodEnter(
+        @Advice.FieldValue(value = RunnableOrCallableActivation.FIELD_NAME_DUBBO_TAG, readOnly = false) String dubboTag) {
+        // copy tag to RpcContext from RunnableOrCallable's field value
+        RpcContext.getClientAttachment().setAttachment(CommonConstants.TAG_KEY, dubboTag);
+    }
+
+    @Advice.OnMethodExit
+    public static void onMethodExit() {","[{'comment': '这个方法异常的时候会执行么', 'commenter': 'songxiaosheng'}, {'comment': '感谢提醒  ! 这里注解少写了, 修改前方法异常不会执行onMethodExit(),修改后会执行:\r\n修改前:`@Advice.OnMethodExit`\r\n修改后:`@Advice.OnMethodExit(onThrowable = Throwable.class)`', 'commenter': 'carlvine500'}]"
12659,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java,"@@ -177,7 +182,7 @@ private void onContextClosedEvent(ContextClosedEvent event) {
 
     @Override
     public int getOrder() {
-        return LOWEST_PRECEDENCE;
+        return LOWEST_PRECEDENCE - 100;","[{'comment': 'How about change to `HIGHEST_PRECEDENCE`?', 'commenter': 'AlbumenJ'}, {'comment': '提高到最高优先级也是可以的', 'commenter': 'liufeiyu1002'}, {'comment': 'Go ahead.\r\nBTW, pls add some test cases to verify this PR.', 'commenter': 'AlbumenJ'}]"
12671,dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLoggerAdapter.java,"@@ -45,6 +52,7 @@ public Level getLevel() {
 
     @Override
     public void setLevel(Level level) {
+        getLogger(Slf4jLoggerAdapter.class).warn(String.format(""The level of slf4j logger can not be set, using the default level: %s"",Slf4jLogger.getLevel(ROOT_LOGGER)));","[{'comment': 'Please follow https://dubbo.apache.org/en/docs3-v2/java-sdk/faq/intro/ to configure logger code', 'commenter': 'AlbumenJ'}, {'comment': 'hello,I just fix,can you take a look?', 'commenter': 'xixingya'}]"
12671,dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLoggerAdapter.java,"@@ -45,6 +55,7 @@ public Level getLevel() {
 
     @Override
     public void setLevel(Level level) {
+        logger.warn("""", """", """", String.format(""The level of slf4j logger current can not be set, using the default level: %s"", Slf4jLogger.getLevel(ROOT_LOGGER)));","[{'comment': 'The first parameter should be `X-X`', 'commenter': 'AlbumenJ'}, {'comment': 'I know,but I have not find a good solution,may be 7-6?', 'commenter': 'xixingya'}]"
12673,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStateRouter.java,"@@ -306,4 +309,35 @@ public void stop() {
     public void setTagRouterRule(TagRouterRule tagRouterRule) {
         this.tagRouterRule = tagRouterRule;
     }
+
+    /**
+     * select addresses by tag with level
+     * <p>
+     * example:
+     * selector=beta|team1|partner1
+     * step1.select tagAddresses with selector=beta|team1|partner1, if result is empty, then run step2
+     * step2.select tagAddresses with selector=beta|team1, if result is empty, then run step3
+     * step3.select tagAddresses with selector=beta, if result is empty, result is null
+     * </p>
+     *
+     * @param tagAddresses
+     * @param tagSelector  eg: beta|team1|partner1
+     * @return
+     */
+    public static Set<String> selectAddressByTagLevel(Map<String, Set<String>> tagAddresses, String tagSelector, boolean isForce) {
+        if (isForce || StringUtils.isNotContains(tagSelector, TAG_SEPERATOR)) {
+            return tagAddresses.get(tagSelector);
+        }
+        String[] selectors = StringUtils.split(tagSelector, TAG_SEPERATOR);
+        for (int i = selectors.length; i > 0; i--) {
+            String selectorTmp = StringUtils.join(selectors, TAG_SEPERATOR, 0, i);
+            System.out.println(selectorTmp);","[{'comment': 'please remove System.out.println', 'commenter': 'wxbty'}, {'comment': '> please remove System.out.println\r\n\r\nok', 'commenter': 'carlvine500'}]"
12673,dubbo-dependencies-bom/pom.xml,"@@ -96,7 +96,7 @@
         <javassist_version>3.29.2-GA</javassist_version>
         <bytebuddy.version>1.14.5</bytebuddy.version>
         <netty_version>3.2.10.Final</netty_version>
-        <netty4_version>4.1.92.Final</netty4_version>
+        <netty4_version>4.1.94.Final</netty4_version>","[{'comment': 'Why change the version?', 'commenter': 'wxbty'}, {'comment': '> Why change the version?\r\n\r\na issue upgrade it  , https://github.com/apache/dubbo/pull/12653\r\n\r\n4.1.92.Final has vulnerability ,  CVE-2023-34462. Severity: MEDIUM\r\nrefer : https://mvnrepository.com/artifact/io.netty/netty-handler\r\n\r\n', 'commenter': 'carlvine500'}]"
12695,dubbo-common/src/main/java/org/apache/dubbo/config/MetricsConfig.java,"@@ -61,6 +61,11 @@ public class MetricsConfig extends AbstractConfig {
      */
     private Boolean exportMetricsService;
 
+    /**
+     * Enable netty metrics.
+     */
+    private Boolean enableNetty;","[{'comment': '参考其它配置在dubbo.xsd里面也加入一下，需要支持spring配置', 'commenter': 'songxiaosheng'}]"
12695,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServer.java,"@@ -109,6 +115,27 @@ protected void doOpen() throws Throwable {
         channelFuture.syncUninterruptibly();
         channel = channelFuture.channel();
 
+        // metrics
+        ApplicationModel applicationModel = ApplicationModel.defaultModel();
+        if(isSupportMetrics()){
+            MetricsEventBus.post(NettyEvent.toNettyEvent(applicationModel), () -> {
+                Map<String, Long> dataMap = new HashMap<>();
+                dataMap.put(MetricsKey.NETTY_ALLOCATOR_HEAP_MEMORY_USED.getName(), PooledByteBufAllocator.DEFAULT.metric().usedHeapMemory());
+                dataMap.put(MetricsKey.NETTY_ALLOCATOR_DIRECT_MEMORY_USED.getName(), PooledByteBufAllocator.DEFAULT.metric().usedDirectMemory());
+                dataMap.put(MetricsKey.NETTY_ALLOCATOR_HEAP_ARENAS_NUM.getName(), (long) PooledByteBufAllocator.DEFAULT.numHeapArenas());
+                dataMap.put(MetricsKey.NETTY_ALLOCATOR_DIRECT_ARENAS_NUM.getName(), (long) PooledByteBufAllocator.DEFAULT.numDirectArenas());
+                dataMap.put(MetricsKey.NETTY_ALLOCATOR_NORMAL_CACHE_SIZE.getName(), (long) PooledByteBufAllocator.DEFAULT.normalCacheSize());
+                dataMap.put(MetricsKey.NETTY_ALLOCATOR_SMALL_CACHE_SIZE.getName(), (long) PooledByteBufAllocator.DEFAULT.smallCacheSize());
+                dataMap.put(MetricsKey.NETTY_ALLOCATOR_THREAD_LOCAL_CACHES_NUM.getName(), (long) PooledByteBufAllocator.DEFAULT.numThreadLocalCaches());
+                dataMap.put(MetricsKey.NETTY_ALLOCATOR_CHUNK_SIZE.getName(), (long) PooledByteBufAllocator.DEFAULT.chunkSize());
+                return dataMap;
+            });
+        }
+    }
+
+    private boolean isSupportMetrics() {
+        return ClassUtils.isPresent(""io.netty.buffer.PooledByteBufAllocatorMetric"", NettyServer.class.getClassLoader()) &&
+            ClassUtils.isPresent(""io.netty.handler.codec.compression.EncoderUtil"", NettyServer.class.getClassLoader());","[{'comment': '这里为何要判断EncoderUtil这个类型，没看到后面指标使用了这个类型，', 'commenter': 'songxiaosheng'}]"
12710,dubbo-metadata/dubbo-metadata-definition-protobuf/src/main/java/org/apache/dubbo/metadata/definition/protobuf/ProtobufTypeBuilder.java,"@@ -48,6 +48,8 @@ public class ProtobufTypeBuilder implements TypeBuilder, Prioritized {
      */
     private static Type STRING_LIST_TYPE;
 
+    private final boolean protobufExist;","[{'comment': '`static` may be better', 'commenter': 'icodening'}, {'comment': 'In a multi-class loader scenario, static may cause class loading exceptions', 'commenter': 'AlbumenJ'}]"
12714,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java,"@@ -196,7 +225,11 @@ private void collectMethod(List<MetricSample> list, String side, MetricsKey metr
 
     private void collectQPS(List<MetricSample> list) {
         qps.forEach((k, v) -> list.add(new GaugeMetricSample<>(MetricsKey.METRIC_QPS.getNameByType(k.getSide()),
-            MetricsKey.METRIC_QPS.getDescription(), k.getTags(), QPS, v, value -> value.get() / value.bucketLivedSeconds())));
+            MetricsKey.METRIC_QPS.getDescription(), k.getTags(), QPS, v, value -> {
+            double total = value.get();
+            long millSeconds = value.bucketLivedMillSeconds();
+            return total / millSeconds * 1000;","[{'comment': '这里毫秒转秒要除以1000', 'commenter': 'songxiaosheng'}, {'comment': '总请求数 / 总毫秒数 * 1000（s/ms）转为 1s 为单位的', 'commenter': 'AlbumenJ'}]"
12714,dubbo-common/src/main/java/org/apache/dubbo/config/nested/AggregationConfig.java,"@@ -25,6 +25,14 @@ public class AggregationConfig implements Serializable {
      */
     private Boolean enabled;
 
+    private Boolean enableQPS;
+
+    private Boolean enableRTPXX;","[{'comment': '这几个变量用驼峰命名会不会更合理', 'commenter': 'songxiaosheng'}, {'comment': 'done', 'commenter': 'AlbumenJ'}]"
12714,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java,"@@ -78,8 +85,16 @@ public AggregateMetricsCollector(ApplicationModel applicationModel) {
             if (optional.isPresent()) {
                 registerListener();
                 AggregationConfig aggregation = optional.get().getAggregation();
-                this.bucketNum = aggregation.getBucketNum() == null ? DEFAULT_BUCKET_NUM : aggregation.getBucketNum();
-                this.timeWindowSeconds = aggregation.getTimeWindowSeconds() == null ? DEFAULT_TIME_WINDOW_SECONDS : aggregation.getTimeWindowSeconds();
+                this.bucketNum = aggregation.getBucketNum() == null ?
+                    DEFAULT_BUCKET_NUM : aggregation.getBucketNum();
+                this.timeWindowSeconds = aggregation.getTimeWindowSeconds() == null ?
+                    DEFAULT_TIME_WINDOW_SECONDS : aggregation.getTimeWindowSeconds();
+                this.qpsTimeWindowMillSeconds = aggregation.getQpsTimeWindowMillSeconds() == null ?
+                    DEFAULT_QPS_TIME_WINDOW_MILL_SECONDS : aggregation.getQpsTimeWindowMillSeconds();
+                this.enableQps = aggregation.getEnableQps() == null || aggregation.getEnableQps();
+                this.enableRtPxx = aggregation.getEnableRtPxx() == null || aggregation.getEnableRtPxx();
+                this.enableRt = aggregation.getEnableRt() == null || aggregation.getEnableRt();
+                this.enableRequest = aggregation.getEnableRequest() == null || aggregation.getEnableRequest();
             }","[{'comment': 'Maybe it could be written more cohesive\r\npublic boolean getEnableQps() {\r\n        return Optional.ofNullable(enableQps).orElse(true);\r\n    }', 'commenter': 'wxbty'}, {'comment': 'done', 'commenter': 'AlbumenJ'}]"
12725,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscovery.java,"@@ -94,6 +95,13 @@ default long getDelay() {
         return getUrl().getParameter(REGISTRY_DELAY_NOTIFICATION_KEY, 5000);
     }
 
+    /**
+     * Get services is the default way for service discovery to be available
+     */
+    default boolean isAvailable() {
+        return CollectionUtils.isNotEmpty(getServices());","[{'comment': 'check if destoryed here', 'commenter': 'AlbumenJ'}, {'comment': 'This is a new method, it seems that it just replaces the empty judgment of getServices().', 'commenter': 'wxbty'}, {'comment': 'But from the definition of `isAvailable`, it is necessary to improve the `available` definition', 'commenter': 'AlbumenJ'}, {'comment': '> check if destoryed here\r\n\r\n👌🏻', 'commenter': 'xieshouyu'}]"
12730,dubbo-common/src/main/java/org/apache/dubbo/common/beans/factory/ScopeBeanFactory.java,"@@ -53,7 +54,9 @@ public class ScopeBeanFactory {
     private final List<BeanInfo> registeredBeanInfos = new CopyOnWriteArrayList<>();
     private InstantiationStrategy instantiationStrategy;
     private final AtomicBoolean destroyed = new AtomicBoolean();
-    private List<Class<?>> registeredClasses = new ArrayList<>();
+    private final List<Class<?>> registeredClasses = new ArrayList<>();
+
+    private final Map<Class<?>, Object> registeredCacheBeanMap = new ConcurrentHashMap<>(64);","[{'comment': 'Cache here should consider different bean with same class but different name', 'commenter': 'AlbumenJ'}, {'comment': 'Only beans without names are cached here. If most beans have no names, is this enough? Maybe changing the name of the map to NoNameBeanMap is more appropriate', 'commenter': 'wxbty'}, {'comment': 'Aactually is the only unique Name', 'commenter': 'wxbty'}]"
12730,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java,"@@ -234,12 +236,18 @@ public ApplicationConfig getCurrentConfig() {
     }
 
     public String getApplicationName() {
-        return getCurrentConfig().getName();
+        if (StringUtils.isBlank(this.name)) {
+            this.name = getCurrentConfig().getName();
+        }
+        return this.name;","[{'comment': ""ApplicationName and ApplicationModel's name are different"", 'commenter': 'AlbumenJ'}, {'comment': 'ok', 'commenter': 'wxbty'}]"
12730,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java,"@@ -234,12 +236,18 @@ public ApplicationConfig getCurrentConfig() {
     }
 
     public String getApplicationName() {
-        return getCurrentConfig().getName();
+        if (StringUtils.isBlank(this.applicationName)) {
+            this.applicationName = getCurrentConfig().getName();
+        }
+        return this.applicationName;","[{'comment': '`ApplicationName` in config manager may changed in runtime.', 'commenter': 'AlbumenJ'}]"
12730,dubbo-common/src/main/java/org/apache/dubbo/common/beans/factory/ScopeBeanFactory.java,"@@ -197,8 +200,16 @@ public <T> List<T> getBeansOfType(Class<T> type) {
         return currentBeans;
     }
 
+    @SuppressWarnings(""unchecked"")
     public <T> T getBean(Class<T> type) {
-        return this.getBean(null, type);
+        if (registeredCacheBeansWithUniqueName.containsKey(type)) {
+            return (T) registeredCacheBeansWithUniqueName.get(type);
+        }
+        T bean = this.getBean(null, type);
+        if (bean != null) {
+            registeredCacheBeansWithUniqueName.put(type, bean);
+        }
+        return bean;","[{'comment': 'Is there a better way to improve the performance in `BeanFactory`', 'commenter': 'AlbumenJ'}]"
12731,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscoveryFactory.java,"@@ -17,11 +17,24 @@
 package org.apache.dubbo.registry.nacos;
 
 import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.utils.ConcurrentHashMapUtils;
+import org.apache.dubbo.common.utils.StringUtils;
 import org.apache.dubbo.registry.client.AbstractServiceDiscoveryFactory;
 import org.apache.dubbo.registry.client.ServiceDiscovery;
 
+import static org.apache.dubbo.common.constants.CommonConstants.CONFIG_NAMESPACE_KEY;
+
 public class NacosServiceDiscoveryFactory extends AbstractServiceDiscoveryFactory {
 
+    @Override
+    public ServiceDiscovery getServiceDiscovery(URL registryURL) {
+        String namespace = registryURL.getParameter(CONFIG_NAMESPACE_KEY);
+        URL url = URL.valueOf(registryURL.toServiceStringWithoutResolving());
+        if (StringUtils.isNotEmpty(namespace)) {
+            url = url.addParameter(CONFIG_NAMESPACE_KEY, namespace);
+        }
+        return ConcurrentHashMapUtils.computeIfAbsent(getDiscoveries(), url.toFullString(), k -> createDiscovery(registryURL));
+    }","[{'comment': 'Create a abstract method `protected String createRegistryCacheKey(URL url)` in `AbstractServiceDiscoveryFactory` would be a better choice, which will make the behavior be consistent with `RegistryFactory`', 'commenter': 'AlbumenJ'}]"
12731,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryFactory.java,"@@ -17,15 +17,27 @@
 package org.apache.dubbo.registry.client;
 
 import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.utils.StringUtils;
 import org.apache.dubbo.common.utils.UrlUtils;
 import org.apache.dubbo.registry.Registry;
 import org.apache.dubbo.registry.support.AbstractRegistryFactory;
 
+import static org.apache.dubbo.common.constants.CommonConstants.CONFIG_NAMESPACE_KEY;
 import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_KEY;
 import static org.apache.dubbo.registry.Constants.DEFAULT_REGISTRY;
 
 public class ServiceDiscoveryRegistryFactory extends AbstractRegistryFactory {
 
+    @Override
+    protected String createRegistryCacheKey(URL url) {
+        String namespace = url.getParameter(CONFIG_NAMESPACE_KEY);
+        url = URL.valueOf(url.toServiceStringWithoutResolving());
+        if (StringUtils.isNotEmpty(namespace)) {
+            url = url.addParameter(CONFIG_NAMESPACE_KEY, namespace);
+        }
+        return url.toFullString();","[{'comment': 'How about change to `url.toFullString()` to seperate all service discoveries in `ServiceDiscoveryRegistryFactory` and `ServiceDiscovery` will cache the real implements?', 'commenter': 'AlbumenJ'}]"
12750,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/lifecycle/ApplicationConfigPostHandleLifecycle.java,"@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.config.deploy.lifecycle;
+
+import org.apache.dubbo.common.extension.Activate;
+import org.apache.dubbo.config.deploy.DefaultApplicationDeployer;
+
+/**
+ * Application config post-handle lifecycle.
+ */
+@Activate(order = -2)","[{'comment': 'Change to -2 * 1000\nThis will facilitate the implementation of new additions in the future', 'commenter': 'AlbumenJ'}]"
12750,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/lifecycle/manager/ApplicationLifecycleManager.java,"@@ -0,0 +1,80 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.config.deploy.lifecycle.manager;
+
+import org.apache.dubbo.common.deploy.DeployState;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.config.deploy.DefaultApplicationDeployer;
+import org.apache.dubbo.config.deploy.lifecycle.ApplicationLifecycle;
+import org.apache.dubbo.rpc.model.ModuleModel;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/**
+ * Application Life Manager Loader
+ */
+public class ApplicationLifecycleManager{
+
+    private final DefaultApplicationDeployer defaultApplicationDeployer;
+
+    private List<ApplicationLifecycle> sequences;
+
+    public ApplicationLifecycleManager(DefaultApplicationDeployer defaultApplicationDeployer) {
+        this.defaultApplicationDeployer = defaultApplicationDeployer;
+        sequences = loadAll();
+        sequences.forEach(applicationLifecycle -> applicationLifecycle.setApplicationDeployer(this.defaultApplicationDeployer));
+    }
+
+    public void start(AtomicBoolean hasPreparedApplicationInstance){
+        getAll().forEach(applicationLifecycle -> applicationLifecycle.start(hasPreparedApplicationInstance));
+    }
+
+    public void initialize() {
+        getAll().forEach(ApplicationLifecycle::initialize);
+    }
+
+    public void preDestroy() {
+        getAll().forEach(ApplicationLifecycle::preDestroy);
+    }
+
+    public void postDestroy() {
+        getAll().forEach(ApplicationLifecycle::postDestroy);
+    }
+
+    public void preModuleChanged(ModuleModel changedModule, DeployState changedModuleState, AtomicBoolean hasPreparedApplicationInstance) {
+        getAll().forEach(applicationLifecycle -> applicationLifecycle.preModuleChanged(changedModule, changedModuleState, hasPreparedApplicationInstance));
+    }
+
+    public void postModuleChanged(ModuleModel changedModule, DeployState changedModuleState, DeployState applicationNewState) {
+        getAll().forEach(applicationLifecycle -> applicationLifecycle.postModuleChanged(changedModule, changedModuleState, applicationNewState));
+    }
+
+    public void runRefreshServiceInstance(){
+        getAll().forEach(ApplicationLifecycle::refreshServiceInstance);
+    }
+
+    public List<ApplicationLifecycle> getAll(){
+        return this.sequences;
+    }
+
+
+    protected List<ApplicationLifecycle> loadAll() {
+        ExtensionLoader<ApplicationLifecycle> loader = defaultApplicationDeployer.getApplicationModel().getExtensionLoader(ApplicationLifecycle.class);","[{'comment': 'Cache in advanced', 'commenter': 'AlbumenJ'}]"
12750,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -1088,10 +448,22 @@ public void checkState(ModuleModel moduleModel, DeployState moduleState) {
             if (!moduleModel.isInternal() && moduleState == DeployState.STARTED) {
                 prepareApplicationInstance();
             }
+            lifecycleManager.preModuleChanged(moduleModel,moduleState,hasPreparedApplicationInstance);
             DeployState newState = calculateState();
             switch (newState) {
                 case STARTED:
-                    onStarted();
+                    if (!isStarting()) {
+                        break;
+                    }
+                    try {
+                        lifecycleManager.postModuleChanged(moduleModel, moduleState, newState);","[{'comment': ""it's a bit weird here\n\nCall `postModuleChanged` for twice?"", 'commenter': 'AlbumenJ'}, {'comment': ""It's a mistake. I'm working on it."", 'commenter': 'namelessssssssssss'}]"
12750,dubbo-common/src/main/java/org/apache/dubbo/common/deploy/DeployListenable.java,"@@ -0,0 +1,25 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.deploy;
+
+import org.apache.dubbo.rpc.model.ScopeModel;
+
+public interface DeployListenable<T extends ScopeModel> {","[{'comment': 'Is this necessary? Can we use SPI to inject automatically?', 'commenter': 'AlbumenJ'}, {'comment': 'The operations of `DeloyerListener` defined in `AbstractDeployer`, changing it will affect `ModuleDeployer`. \r\n This problem can fix in the future work about `ModuleLifecycle`, because the definition of `DeployListener` is very similer to `Application/ModuleLifecycle` :\r\n\r\n```Java\r\npublic interface DeployListener<E extends ScopeModel> {\r\n    /**\r\n     * Useful to inject some configuration like MetricsConfig, RegistryConfig, etc.\r\n     */\r\n    void onInitialize(E scopeModel);\r\n\r\n    void onStarting(E scopeModel);\r\n\r\n    void onStarted(E scopeModel);\r\n\r\n    void onStopping(E scopeModel);\r\n\r\n    void onStopped(E scopeModel);\r\n\r\n    void onFailure(E scopeModel, Throwable cause);\r\n\r\n}\r\n```\r\n\r\n```Java\r\npublic interface Lifecycle<T>{\r\n\r\n    /**\r\n     * If this lifecycle need to initialize.\r\n     */\r\n    boolean needInitialize(T context);\r\n\r\n    default void start(T context){}\r\n\r\n    default void initialize(T context){}\r\n\r\n    default void preDestroy(T context) {}\r\n\r\n    default void postDestroy(T context) {}\r\n}\r\n```', 'commenter': 'namelessssssssssss'}]"
12750,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/context/AbstractModelContext.java,"@@ -0,0 +1,94 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.config.deploy.context;
+
+import org.apache.dubbo.common.deploy.DeployListener;
+import org.apache.dubbo.common.deploy.DeployState;
+import org.apache.dubbo.rpc.model.ScopeModel;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+public abstract class AbstractModelContext<M extends ScopeModel> implements ModelContext<M> {
+
+    private final M scopeModel;","[{'comment': 'Most of these properties can be replaced with `Deployer` directly', 'commenter': 'AlbumenJ'}]"
12750,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/context/ModelContext.java,"@@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.config.deploy.context;
+
+import org.apache.dubbo.common.deploy.DeployListenable;
+import org.apache.dubbo.common.deploy.DeployListener;
+import org.apache.dubbo.common.deploy.DeployState;
+import org.apache.dubbo.rpc.model.ScopeModel;
+
+import java.util.List;
+
+/**
+ * The internal lifecycle attribute aggregate of {@link ScopeModel}.
+ * It acts as context of model lifecycle, and provides a way to trigger a model life-changing process
+ *
+ * @param <M> the type of scope model implement
+ */
+public interface ModelContext<M extends ScopeModel> extends DeployListenable<M> {","[{'comment': 'Can this Context be replaced with `Deployer`?', 'commenter': 'AlbumenJ'}]"
12761,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosNamingServiceWrapper.java,"@@ -278,7 +278,7 @@ public ListView<String> getServicesOfServer(int pageNo, int pageSize, String gro
     }
 
     public List<Instance> selectInstances(String serviceName, String group, boolean healthy) throws NacosException {
-        return apply(() -> nacosConnectionManager.getNamingService().selectInstances(handleInnerSymbol(serviceName), group, healthy));
+        return apply(() -> nacosConnectionManager.getNamingService().selectInstances(handleInnerSymbol(serviceName), group, healthy, false));","[{'comment': 'What is the purpose of change this? Dubbo will subscribe to that service after select. So `subscribe` can reuse the reqeust in one RT.', 'commenter': 'AlbumenJ'}, {'comment': ""It does't matter, i will close"", 'commenter': 'finefuture'}]"
12771,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/TpsLimitFilter.java,"@@ -28,16 +29,14 @@
 import org.apache.dubbo.rpc.filter.tps.TPSLimiter;
 import org.apache.dubbo.rpc.support.RpcUtils;
 
-import static org.apache.dubbo.rpc.Constants.TPS_LIMIT_RATE_KEY;
-
 /**
  * TpsLimitFilter limit the TPS (transaction per second) for all method of a service or a particular method.
  * Service or method url can define <b>tps</b> or <b>tps.interval</b> to control this control.It use {@link DefaultTPSLimiter}
  * as it limit checker. If a provider service method is configured with <b>tps</b>(optionally with <b>tps.interval</b>),then
  * if invocation count exceed the configured <b>tps</b> value (default is -1 which means unlimited) then invocation will get
  * RpcException.
- * */
-@Activate(group = CommonConstants.PROVIDER, value = TPS_LIMIT_RATE_KEY)
+ */
+@Activate(group = CommonConstants.PROVIDER)","[{'comment': 'Why change this line?', 'commenter': 'AlbumenJ'}]"
12774,dubbo-monitor/dubbo-monitor-api/src/main/java/org/apache/dubbo/monitor/support/CallbackMonitorFilter.java,"@@ -0,0 +1,25 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.monitor.support;
+
+import org.apache.dubbo.common.extension.Activate;
+
+import static org.apache.dubbo.common.constants.CommonConstants.CALLBACK;
+
+@Activate(group = CALLBACK)
+public class CallbackMonitorFilter extends MonitorFilter {","[{'comment': 'Why add this class?', 'commenter': 'AlbumenJ'}, {'comment': '`CallbackMonitorFilter` is the same as `MonitorClusterFilter`, because `MonitorClusterFilter` is a `ClusterFilter` that will not be loaded during a callback. Therefore, it is recommended to support the `MonitorFilter` logic on the callback side during a call to be compatible with `Skywalking`  tracking.\r\n', 'commenter': 'wuwen5'}, {'comment': '@AlbumenJ  What is your point of view, delete it?', 'commenter': 'wuwen5'}, {'comment': 'This seem a little bad smell.', 'commenter': 'AlbumenJ'}, {'comment': ""I'm not sure if the bad smell is a naming issue, I have changed it to `MonitorCallbackFilter`.\r\nIf there is any need to modify or delete, please let me know. \r\n@AlbumenJ "", 'commenter': 'wuwen5'}, {'comment': 'What I mean by bad smell is that there are codes in Dubbo that Dubbo does not need to use', 'commenter': 'AlbumenJ'}, {'comment': 'Okay, it has been deleted now, users can add it themselves.', 'commenter': 'wuwen5'}]"
12774,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java,"@@ -201,11 +207,16 @@ private Object referOrDestroyCallbackService(Channel channel, URL url, Class<?>
         if (isRefer) {
             if (proxy == null) {
                 URL referurl = URL.valueOf(""callback://"" + url.getAddress() + ""/"" + clazz.getName() + ""?"" + INTERFACE_KEY + ""="" + clazz.getName());
-                referurl = referurl.addParametersIfAbsent(url.getParameters()).removeParameter(METHODS_KEY);
+                referurl = referurl.addParametersIfAbsent(url.getParameters()).removeParameter(METHODS_KEY).addParameter(SIDE_KEY, CONSUMER_SIDE);
                 if (!isInstancesOverLimit(channel, referurl, clazz.getName(), instid, true)) {
                     url.getOrDefaultApplicationModel().getDefaultModule().getServiceRepository().registerService(clazz);
                     @SuppressWarnings(""rawtypes"")
                     Invoker<?> invoker = new ChannelWrappedInvoker(clazz, channel, referurl, String.valueOf(instid));
+
+                    FilterChainBuilder builder = getFilterChainBuilder(url);
+                    invoker = builder.buildInvokerChain(invoker, REFERENCE_FILTER_KEY, CommonConstants.CONSUMER);
+                    invoker = builder.buildInvokerChain(invoker, REFERENCE_FILTER_KEY, CommonConstants.CALLBACK);","[{'comment': ""By adding the above two lines, both ConsumerContextFilter and CallbackConsumerContextFilter will be enabled. \r\n\r\nWhat's the meaning of enable both these two filters as they have exact the same effect?"", 'commenter': 'chickenlj'}, {'comment': 'I see, CallbackConsumerContextFilter implements Filter while ConsumerContextFilter does not.', 'commenter': 'chickenlj'}]"
12776,dubbo-common/src/test/java/org/apache/dubbo/common/utils/json/Service.java,"@@ -0,0 +1,114 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.utils.json;
+
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.LocalTime;
+import java.time.ZonedDateTime;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+
+public interface Service {
+    String sayHi(String name);
+
+    List<String> testList();
+
+    int testInt();
+    int[] testIntarr();","[{'comment': 'Change to testIntArr.\r\n', 'commenter': 'CrazyHZM'}, {'comment': 'done', 'commenter': 'Skylark-hjyp'}]"
12817,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/MetricsEventBus.java,"@@ -63,27 +68,49 @@ public static <T> T post(MetricsEvent event, Supplier<T> targetSupplier) {
      */
     public static <T> T post(MetricsEvent event, Supplier<T> targetSupplier, Function<T, Boolean> trFunction) {
         T result;
-        before(event);
+        tryInvoke(() -> {
+            before(event);
+        });
         if (trFunction == null) {
             try {
                 result = targetSupplier.get();
             } catch (Throwable e) {
-                error(event);
+                tryInvoke(() -> {
+                    error(event);
+                });
                 throw e;
             }
-            after(event, result);
+            tryInvoke(() -> {
+                after(event, result);
+            });
         } else {
             // Custom failure status
             result = targetSupplier.get();
             if (trFunction.apply(result)) {
-                after(event, result);
+                tryInvoke(() -> {
+                    after(event, result);
+                });
             } else {
-                error(event);
+                tryInvoke(() -> {
+                    error(event);
+                });
             }
         }
         return result;
     }
 
+    interface TryCallBack {
+         void callback();
+    }
+
+    public static void tryInvoke(TryCallBack tryCallBack) {
+        try {
+            tryCallBack.callback();
+        } catch (Throwable e2) {
+            logger.debug(""MetricsEventBus tryInvoke error"", e2);","[{'comment': '```suggestion\r\n            logger.warn(""MetricsEventBus tryInvoke error"", e2);\r\n```\r\n\r\nwarn with error code', 'commenter': 'AlbumenJ'}]"
12834,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboSpringInitializer.java,"@@ -68,14 +68,15 @@ public static boolean remove(BeanDefinitionRegistry registry) {
     }
 
     public static boolean remove(ApplicationContext springContext) {
+        AutowireCapableBeanFactory autowireCapableBeanFactory = springContext.getAutowireCapableBeanFactory();
         for (Map.Entry<BeanDefinitionRegistry, DubboSpringInitContext> entry : contextMap.entrySet()) {
             DubboSpringInitContext initContext = entry.getValue();
             if (initContext.getApplicationContext() == springContext ||
-                initContext.getBeanFactory() == springContext.getAutowireCapableBeanFactory() ||
-                initContext.getRegistry() == springContext.getAutowireCapableBeanFactory()
+                initContext.getBeanFactory() == autowireCapableBeanFactory ||
+                initContext.getRegistry() == autowireCapableBeanFactory
             ) {
                 DubboSpringInitContext context = contextMap.remove(entry.getKey());
-                logger.info(""Unbind "" + safeGetModelDesc(context.getModuleModel()) + "" from spring container: "" +
+                logger.info(""Unbind "" + context.getModuleModel().getDesc() + "" from spring container: "" +","[{'comment': 'Is it possible throws NPE here?', 'commenter': 'AlbumenJ'}, {'comment': '> Is it possible throws NPE here?\r\n\r\nThe initContext method ensures that the context.getModuleMode() method does not return null.', 'commenter': 'kang-hl'}, {'comment': 'Remove before init may erorr?', 'commenter': 'AlbumenJ'}, {'comment': '> Remove before init may erorr?\r\n\r\nright.', 'commenter': 'kang-hl'}]"
12868,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java,"@@ -159,9 +159,9 @@ private void onRTEvent(RequestEvent event) {
         MethodMetric metric = new MethodMetric(applicationModel, event.getAttachmentValue(MetricsConstants.INVOCATION));
         long responseTime = event.getTimePair().calc();
         if (enableRt) {
-            TimeWindowQuantile quantile = ConcurrentHashMapUtils.computeIfAbsent(rt, metric,
-                k -> new TimeWindowQuantile(DEFAULT_COMPRESSION, bucketNum, timeWindowSeconds));
-            quantile.add(responseTime);
+            ConcurrentDoubleHistogram concurrentDoubleHistogram = ConcurrentHashMapUtils.computeIfAbsent(rt, metric,","[{'comment': 'Is `timeWindowSeconds` here no longer needed', 'commenter': 'AlbumenJ'}, {'comment': 'let me look look', 'commenter': 'songxiaosheng'}, {'comment': 'Sliding windows are used for aggregation statistics of minimum and maximum values. Unlike the percentile algorithm above, sliding windows use thread safe algorithms', 'commenter': 'songxiaosheng'}]"
12879,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,"@@ -265,6 +266,12 @@ Invoker<?> getInvoker(Channel channel, Invocation inv) throws RemotingException
         int port = channel.getLocalAddress().getPort();
         String path = (String) inv.getObjectAttachmentWithoutConvert(PATH_KEY);
 
+        // if the environment variable DUBBO_PORT_TO_REGISTRY is added
+        String dubboPortToRegistry = ConfigUtils.getSystemProperty(org.apache.dubbo.config.Constants.DUBBO_PORT_TO_REGISTRY);
+        if(StringUtils.isNotEmpty(dubboPortToRegistry)) {
+            port = Integer.valueOf(dubboPortToRegistry);","[{'comment': ""This may break `DUBBO_PORT_TO_REGISTRY`'s design"", 'commenter': 'AlbumenJ'}, {'comment': 'So, How to solve not found exporter in exporterMap by serviceKey?\r\n\r\ndubbo/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo\r\n/DubboProtocol.java\r\n![image](https://github.com/apache/dubbo/assets/11389933/7a31e73f-2ca4-4747-8fcf-bde7a7521b49)\r\n\r\n', 'commenter': 'lgfei'}, {'comment': 'As for https://github.com/apache/dubbo/issues/12798, it is recommended to use `dubbo.protocol.port` insteand of `DUBBO_PORT_TO_REGISTRY`', 'commenter': 'AlbumenJ'}, {'comment': 'get it', 'commenter': 'lgfei'}]"
12892,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java,"@@ -123,12 +124,56 @@ public boolean isSupport(MetricsEvent event) {
     public void onEvent(RequestEvent event) {
         if (enableQps) {
             MethodMetric metric = calcWindowCounter(event, MetricsKey.METRIC_REQUESTS);
+            if(event instanceof RequestInitEvent) {
+                onInitMetricRequest(event);
+                onInitQpsRequest(metric);
+                onInitRtRequest(metric);
+                onInitRtAgrRequest(metric);
+                return;
+            }
             TimeWindowCounter qpsCounter = ConcurrentHashMapUtils.computeIfAbsent(qps, metric,
                 methodMetric -> new TimeWindowCounter(bucketNum, qpsTimeWindowMillSeconds));
             qpsCounter.increment();
         }
     }
 
+    public void onInitMetricRequest(RequestEvent event){
+        initWindowCounter(event,MetricsKey.METRIC_REQUESTS_TOTAL_AGG);
+        initWindowCounter(event,MetricsKey.METRIC_REQUESTS_SUCCEED_AGG);
+        initWindowCounter(event,MetricsKey.METRIC_REQUESTS_FAILED_AGG);
+        initWindowCounter(event,MetricsKey.METRIC_REQUEST_BUSINESS_FAILED_AGG);
+        initWindowCounter(event,MetricsKey.METRIC_REQUESTS_TIMEOUT_AGG);
+        initWindowCounter(event,MetricsKey.METRIC_REQUESTS_LIMIT_AGG);
+        initWindowCounter(event,MetricsKey.METRIC_REQUESTS_TOTAL_FAILED_AGG);
+        initWindowCounter(event,MetricsKey.METRIC_REQUESTS_NETWORK_FAILED_AGG);
+        initWindowCounter(event,MetricsKey.METRIC_REQUESTS_CODEC_FAILED_AGG);
+        initWindowCounter(event,MetricsKey.METRIC_REQUESTS_TOTAL_SERVICE_UNAVAILABLE_FAILED_AGG);
+    }","[{'comment': 'These constants can be placed in DefaultConstants in the form of List, and then foreach does init, which can reduce duplication', 'commenter': 'wxbty'}, {'comment': 'ok', 'commenter': 'robin977'}]"
12892,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/MethodStatComposite.java,"@@ -54,6 +55,13 @@ public void initWrapper(List<MetricsKeyWrapper> metricsKeyWrappers) {
         metricsKeyWrappers.forEach(appKey -> methodNumStats.put(appKey, new ConcurrentHashMap<>()));
     }
 
+    public void initMethodKey(MetricsKeyWrapper wrapper, Invocation invocation, int size) {
+        if (!methodNumStats.containsKey(wrapper)) {
+            return;
+        }
+        methodNumStats.get(wrapper).computeIfAbsent(new MethodMetric(getApplicationModel(), invocation), k -> new AtomicLong(0L)).set(size);
+    }
+","[{'comment': 'The init method can directly set 0, no need to transfer parameters', 'commenter': 'wxbty'}]"
12892,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java,"@@ -123,12 +124,56 @@ public boolean isSupport(MetricsEvent event) {
     public void onEvent(RequestEvent event) {
         if (enableQps) {
             MethodMetric metric = calcWindowCounter(event, MetricsKey.METRIC_REQUESTS);
+            if(event instanceof RequestInitEvent) {
+                onInitMetricRequest(event);
+                onInitQpsRequest(metric);
+                onInitRtRequest(metric);
+                onInitRtAgrRequest(metric);
+                return;
+            }","[{'comment': 'RequestInitEvent and RequestEvent look different, one is triggered by app init, the other is triggered by rpc request, is it better to separate the listener?', 'commenter': 'wxbty'}]"
12892,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/MetricsInitEvent.java,"@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.metrics.event;
+import org.apache.dubbo.metrics.MetricsConstants;
+import org.apache.dubbo.metrics.model.MethodMetric;
+import org.apache.dubbo.metrics.model.MetricsSupport;
+import org.apache.dubbo.metrics.model.key.MetricsLevel;
+import org.apache.dubbo.metrics.model.key.TypeWrapper;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+import static org.apache.dubbo.metrics.MetricsConstants.ATTACHMENT_KEY_SERVICE;
+import static org.apache.dubbo.metrics.model.key.MetricsKey.METRIC_REQUESTS;
+public class MetricsInitEvent extends TimeCounterEvent {
+
+
+    public MetricsInitEvent(ApplicationModel source,TypeWrapper typeWrapper) {
+        super(source,typeWrapper);
+    }
+
+    public static MetricsInitEvent toMetricsInitEvent(ApplicationModel applicationModel, Invocation invocation) {
+        MethodMetric methodMetric = new MethodMetric(applicationModel, invocation);
+        MetricsInitEvent initEvent = new MetricsInitEvent(applicationModel, new TypeWrapper(MetricsLevel.SERVICE, METRIC_REQUESTS));
+        initEvent.putAttachment(MetricsConstants.INVOCATION, invocation);","[{'comment': 'Do not create immutable objects every time.', 'commenter': 'wxbty'}]"
12892,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/event/DefaultSubDispatcher.java,"@@ -69,7 +70,7 @@ private CategoryOverall initMethodRequest() {
                             MetricsSupport.increment(key, dynamicPlaceType, (MethodMetricsCollector) collector, event);
                             MetricsSupport.increment(MetricsKey.METRIC_REQUESTS_PROCESSING, dynamicPlaceType, (MethodMetricsCollector) collector, event);
                         })),
-                new MetricsCat(MetricsKey.METRIC_REQUESTS_SUCCEED, (key, placeType, collector) -> AbstractMetricsKeyListener.onFinish(key,
+                new MetricsCat(METRIC_REQUESTS_SUCCEED, (key, placeType, collector) -> AbstractMetricsKeyListener.onFinish(key,","[{'comment': ""Don't change that. Keep it the same as before"", 'commenter': 'wxbty'}]"
12898,README.md,"@@ -10,236 +10,69 @@
 [![Twitter Follow](https://img.shields.io/twitter/follow/ApacheDubbo.svg?label=Follow&style=social&logoWidth=0)](https://twitter.com/intent/follow?screen_name=ApacheDubbo)
 [![Gitter](https://badges.gitter.im/alibaba/dubbo.svg)](https://gitter.im/alibaba/dubbo?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)
 
-Apache Dubbo is a high-performance, Java-based open-source RPC framework. Please visit the [official site](http://dubbo.apache.org) for the quick start guide and documentation, as well as the [wiki](https://github.com/apache/dubbo/wiki) for news, FAQ, and release notes.
+Apache Dubbo is an easy-to-use Web and RPC framework that provides multiple
+language implementations(Java, [Go](https://github.com/apache/dubbo-go), [Rust](https://github.com/apache/dubbo-rust), [Node.js](https://github.com/apache/dubbo-js), [Web](https://github.com/apache/dubbo-js)) for communication, service discovery, traffic management,
+observability, security, tools, and best practices for building enterprise-ready microservices.
 
-We are now collecting Dubbo user info to help us to improve Dubbo further. Kindly support us by providing your usage information on [issue#9436: Wanted: who's using dubbo](https://github.com/apache/dubbo/issues/9436), thanks :)
+Visit [the official website](https://dubbo.apache.org/) for more information.
 
 ## Architecture
-
 ![Architecture](https://dubbo.apache.org/imgs/architecture.png)
 
-## Features
-
-* Transparent interface based RPC
-* Intelligent load balancing
-* Automatic service registration and discovery
-* High extensibility
-* Runtime traffic routing
-* Visualized service governance
+* **[RPC protocol](https://cn.dubbo.apache.org/zh-cn/overview/core-features/protocols/):** triple, tcp, rest and more.
+* **[Service Discovery](https://cn.dubbo.apache.org/zh-cn/overview/core-features/service-discovery/):** Nacos, Zookeeper, Kubernetes, etc.
+* **[Microservice solution](https://cn.dubbo.apache.org/zh-cn/overview/core-features/):** traffic routing, configuration, observability, tracing, deploying to Kubernetes, service mesh, etc.
 
 ## Getting started
+Follow the instructions below to learn how to:
 
-The following code snippet comes from [Dubbo Samples](https://github.com/apache/dubbo-samples.git). You may clone the sample project and step into the `dubbo-samples-api` subdirectory before proceeding.
-
-```bash
-git clone https://github.com/apache/dubbo-samples.git
-cd dubbo-samples/1-basic/dubbo-samples-api
-```
-
-There's a [README](https://github.com/apache/dubbo-samples/blob/389cd612f1ea57ee6e575005b32f195c442c35a2/1-basic/dubbo-samples-api/README.md) file under `dubbo-samples-api` directory. We recommend referencing the samples in that directory by following the below-mentioned instructions: 
-
-### Maven dependency
-
-```xml
-<properties>
-    <dubbo.version>3.0.10</dubbo.version>
-</properties>
-
-<dependencies>
-    <dependency>
-        <groupId>org.apache.dubbo</groupId>
-        <artifactId>dubbo</artifactId>
-        <version>${dubbo.version}</version>
-    </dependency>
-    <dependency>
-        <groupId>org.apache.dubbo</groupId>
-        <artifactId>dubbo-dependencies-zookeeper</artifactId>
-        <version>${dubbo.version}</version>
-        <type>pom</type>
-    </dependency>
-</dependencies>
-```
-
-### Define service interfaces
-
-```java
-package org.apache.dubbo.samples.api;
-
-public interface GreetingsService {
-    String sayHi(String name);
-}
-```
-
-*See [api/GreetingsService.java](https://github.com/apache/dubbo-samples/blob/389cd612f1ea57ee6e575005b32f195c442c35a2/1-basic/dubbo-samples-api/src/main/java/org/apache/dubbo/samples/api/GreetingsService.java) on GitHub.*
-
-### Implement service interface for the provider
-
-```java
-package org.apache.dubbo.samples.provider;
-
-import org.apache.dubbo.samples.api.GreetingsService;
-
-public class GreetingsServiceImpl implements GreetingsService {
-    @Override
-    public String sayHi(String name) {
-        return ""hi, "" + name;
-    }
-}
-```
-
-*See [provider/GreetingsServiceImpl.java](https://github.com/apache/dubbo-samples/blob/389cd612f1ea57ee6e575005b32f195c442c35a2/1-basic/dubbo-samples-api/src/main/java/org/apache/dubbo/samples/provider/GreetingsServiceImpl.java) on GitHub.*
-
-### Start service provider
-
-```java
-package org.apache.dubbo.samples.provider;
-
-
-import org.apache.dubbo.config.ApplicationConfig;
-import org.apache.dubbo.config.RegistryConfig;
-import org.apache.dubbo.config.ServiceConfig;
-import org.apache.dubbo.samples.api.GreetingsService;
-
-import java.util.concurrent.CountDownLatch;
-
-public class Application {
-    private static String zookeeperHost = System.getProperty(""zookeeper.address"", ""127.0.0.1"");
-
-    public static void main(String[] args) throws Exception {
-        ServiceConfig<GreetingsService> service = new ServiceConfig<>();
-        service.setApplication(new ApplicationConfig(""first-dubbo-provider""));
-        service.setRegistry(new RegistryConfig(""zookeeper://"" + zookeeperHost + "":2181""));
-        service.setInterface(GreetingsService.class);
-        service.setRef(new GreetingsServiceImpl());
-        service.export();
-
-        System.out.println(""dubbo service started"");
-        new CountDownLatch(1).await();
-    }
-}
-```
-
-*See [provider/Application.java](https://github.com/apache/dubbo-samples/blob/389cd612f1ea57ee6e575005b32f195c442c35a2/1-basic/dubbo-samples-spring-xml/src/main/java/org/apache/dubbo/samples/provider/Application.java) on GitHub.*
-
-### Build and run the provider
+### Programming with lightweight RPC API
+[5 minutes step-by-step guide](https://dubbo.apache.org/zh-cn/overview/quickstart/rpc/java)
 
-```bash
-mvn clean package
-mvn -Djava.net.preferIPv4Stack=true -Dexec.mainClass=org.apache.dubbo.samples.provider.Application exec:java
-```
+Dubbo supports building RPC services with only a few lines of code while depending only on a lightweight SDK (<10MB). The protocol on the wire can be [Triple](https://cn.dubbo.apache.org/zh-cn/overview/reference/protocols/triple/)(fully gRPC compatible and HTTP-friendly), Dubbo2(TCP), REST, or any protocol of your choice.","[{'comment': 'Eng ver by default', 'commenter': 'AlbumenJ'}, {'comment': ""I will remove the cn. domain prefix. Please notice that the content will still be under /zh-cn because we don't have /en version yet."", 'commenter': 'chickenlj'}]"
12910,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java,"@@ -113,6 +122,15 @@ public void afterUnExport() {
         return exporter;
     }
 
+    private void checkJsonCompatibility(Class<?> clazz) throws RpcException {
+        boolean compatibility = JsonCompatibilityUtil.checkClassCompatibility(clazz);
+        if (!compatibility) {
+            List<String> unsupportedMethods = JsonCompatibilityUtil.getUnsupportedMethods(clazz);
+            logger.error(""Interface {} does not support json serialization, the specific methods are {}"", clazz, unsupportedMethods);
+            throw new RpcException(String.format(""Interface %s does not support json serialization"", clazz));","[{'comment': 'Print logs or affect startup, should be decided by the user, it should be a configuration, configuration json check levels can be ignore (no check), log, startup error, respectively can correspond to disabled, warn, strict\r\n', 'commenter': 'CrazyHZM'}, {'comment': 'done!\r\nIn the new version, user can specify the implementation mode by specifying attribute `json-check-level`.  The optional values are `ignore`, `log`, or `startup_error`. \r\nIf no value is specified, the default implementation mode is `startup_error`.', 'commenter': 'Skylark-hjyp'}]"
12910,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java,"@@ -113,6 +122,31 @@ public void afterUnExport() {
         return exporter;
     }
 
+    private void checkJsonCompatibility(Class<?> clazz, String jsonCheckLevel) throws RpcException {
+
+        if (jsonCheckLevel == null || JSON_CHECK_LEVEL_WARN.equals(jsonCheckLevel)) {
+            boolean compatibility = JsonCompatibilityUtil.checkClassCompatibility(clazz);
+            if (!compatibility) {
+                List<String> unsupportedMethods = JsonCompatibilityUtil.getUnsupportedMethods(clazz);
+                assert unsupportedMethods != null;
+                logger.warn("""", """", """", String.format(""Interface %s does not support json serialization, the specific methods are %s."", clazz.getName(), unsupportedMethods));
+            } else {
+                logger.info(""Check json compatibility complete, all methods can be serialized using json."");
+            }
+        } else if (JSON_CHECK_LEVEL_STRICT.equals(jsonCheckLevel)) {
+            boolean compatibility = JsonCompatibilityUtil.checkClassCompatibility(clazz);
+            if (!compatibility) {
+                List<String> unsupportedMethods = JsonCompatibilityUtil.getUnsupportedMethods(clazz);
+                assert unsupportedMethods != null;
+                throw new RpcException(String.format(""Interface %s does not support json serialization, the specific methods are %s."", clazz.getName(), unsupportedMethods));
+            } else {
+                logger.info(""Check json compatibility complete, all methods can be serialized using json."");
+            }
+        } else {
+            logger.info(""Ignore json compatibility check."");","[{'comment': 'No need to print.', 'commenter': 'CrazyHZM'}, {'comment': 'done', 'commenter': 'Skylark-hjyp'}]"
12910,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java,"@@ -113,6 +122,31 @@ public void afterUnExport() {
         return exporter;
     }
 
+    private void checkJsonCompatibility(Class<?> clazz, String jsonCheckLevel) throws RpcException {
+
+        if (jsonCheckLevel == null || JSON_CHECK_LEVEL_WARN.equals(jsonCheckLevel)) {
+            boolean compatibility = JsonCompatibilityUtil.checkClassCompatibility(clazz);
+            if (!compatibility) {
+                List<String> unsupportedMethods = JsonCompatibilityUtil.getUnsupportedMethods(clazz);
+                assert unsupportedMethods != null;
+                logger.warn("""", """", """", String.format(""Interface %s does not support json serialization, the specific methods are %s."", clazz.getName(), unsupportedMethods));
+            } else {
+                logger.info(""Check json compatibility complete, all methods can be serialized using json."");","[{'comment': 'The log level should be adjusted to debug, and the check class should be added to the log message.', 'commenter': 'CrazyHZM'}, {'comment': 'done', 'commenter': 'Skylark-hjyp'}]"
12910,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java,"@@ -113,6 +122,31 @@ public void afterUnExport() {
         return exporter;
     }
 
+    private void checkJsonCompatibility(Class<?> clazz, String jsonCheckLevel) throws RpcException {
+
+        if (jsonCheckLevel == null || JSON_CHECK_LEVEL_WARN.equals(jsonCheckLevel)) {
+            boolean compatibility = JsonCompatibilityUtil.checkClassCompatibility(clazz);
+            if (!compatibility) {
+                List<String> unsupportedMethods = JsonCompatibilityUtil.getUnsupportedMethods(clazz);
+                assert unsupportedMethods != null;
+                logger.warn("""", """", """", String.format(""Interface %s does not support json serialization, the specific methods are %s."", clazz.getName(), unsupportedMethods));
+            } else {
+                logger.info(""Check json compatibility complete, all methods can be serialized using json."");
+            }
+        } else if (JSON_CHECK_LEVEL_STRICT.equals(jsonCheckLevel)) {
+            boolean compatibility = JsonCompatibilityUtil.checkClassCompatibility(clazz);
+            if (!compatibility) {
+                List<String> unsupportedMethods = JsonCompatibilityUtil.getUnsupportedMethods(clazz);
+                assert unsupportedMethods != null;
+                throw new RpcException(String.format(""Interface %s does not support json serialization, the specific methods are %s."", clazz.getName(), unsupportedMethods));
+            } else {
+                logger.info(""Check json compatibility complete, all methods can be serialized using json."");","[{'comment': 'As above.', 'commenter': 'CrazyHZM'}, {'comment': 'done', 'commenter': 'Skylark-hjyp'}]"
12910,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/constans/RestConstant.java,"@@ -57,6 +57,11 @@ public interface RestConstant {
     String IDLE_TIMEOUT_PARAM = ""idle.timeout"";
     String KEEP_ALIVE_TIMEOUT_PARAM = ""keep.alive.timeout"";
 
+    String JSON_CHECK_LEVEL = ""jsonCheckLevel"";
+    String JSON_CHECK_LEVEL_DISABLED = ""disable"";","[{'comment': 'change to `disabled`', 'commenter': 'CrazyHZM'}, {'comment': 'done', 'commenter': 'Skylark-hjyp'}]"
12910,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java,"@@ -113,6 +122,29 @@ public void afterUnExport() {
         return exporter;
     }
 
+    private void checkJsonCompatibility(Class<?> clazz, String jsonCheckLevel) throws RpcException {
+
+        if (jsonCheckLevel == null || JSON_CHECK_LEVEL_WARN.equals(jsonCheckLevel)) {
+            boolean compatibility = JsonCompatibilityUtil.checkClassCompatibility(clazz);
+            if (!compatibility) {
+                List<String> unsupportedMethods = JsonCompatibilityUtil.getUnsupportedMethods(clazz);
+                assert unsupportedMethods != null;
+                logger.warn("""", """", """", String.format(""Interface %s does not support json serialization, the specific methods are %s."", clazz.getName(), unsupportedMethods));
+            } else {
+                logger.debug(""Check json compatibility complete, all methods of {} can be serialized using json."", clazz.getName());
+            }
+        } else if (JSON_CHECK_LEVEL_STRICT.equals(jsonCheckLevel)) {
+            boolean compatibility = JsonCompatibilityUtil.checkClassCompatibility(clazz);
+            if (!compatibility) {
+                List<String> unsupportedMethods = JsonCompatibilityUtil.getUnsupportedMethods(clazz);
+                assert unsupportedMethods != null;
+                throw new RpcException(String.format(""Interface %s does not support json serialization, the specific methods are %s."", clazz.getName(), unsupportedMethods));","[{'comment': 'change `RpcException` to `IllegalStateException`.', 'commenter': 'CrazyHZM'}, {'comment': 'done', 'commenter': 'Skylark-hjyp'}]"
12918,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java,"@@ -239,7 +246,15 @@ AsyncRpcResult invokeUnary(MethodDescriptor methodDescriptor, Invocation invocat
         if (methodDescriptor instanceof StubMethodDescriptor) {
             pureArgument = invocation.getArguments()[0];
         } else {
-            pureArgument = invocation.getArguments();
+            if (methodDescriptor.isGeneric()) {
+                Object[] args = new Object[3];
+                args[0] = RpcUtils.getMethodName(invocation);
+                args[1] = Arrays.stream(RpcUtils.getParameterTypes(invocation)).map(Class::getName).collect(Collectors.toList());","[{'comment': 'Can this part be precomputed', 'commenter': 'EarthChen'}]"
12921,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/rest/PathMatcher.java,"@@ -174,7 +174,7 @@ && httpMethodMatch(that) // http method compare
     }
 
     /**
-     * it is needed to compare http method when one of needCompareHttpMethod is true,and don`t compare when both needCompareHttpMethod are false
+     * needCompareHttpMethod is not compared when one of them is false, and needCompareHttpMethod is compared when both are true","[{'comment': 'Is there any **real** changes?', 'commenter': 'AlbumenJ'}]"
12948,dubbo-common/src/main/java/org/apache/dubbo/common/constants/CommonConstants.java,"@@ -337,6 +337,8 @@ public interface CommonConstants {
 
     String REGISTRY_PROTOCOL_LISTENER_KEY = ""registry.protocol.listener"";
 
+    String REGISTRY_SERVICE_CLASS_NAME = ""org.apache.dubbo.registry.RegistryService"";","[{'comment': 'This change has nothing to do with the rest of changes in this pull request.', 'commenter': 'chickenlj'}, {'comment': 'This constant used to replace direct reference of `RegistryService` in `ConfigValidationUtils`\r\n\r\nOld:\r\n```Java\r\n//ConfigValidationUtils.loadRegistries:214\r\n                    map.put(PATH_KEY, RegistryService.class.getName());\r\n```\r\n\r\nNew:\r\n```Java\r\n//ConfigValidationUtils.loadRegistries:127\r\n                    map.put(PATH_KEY,REGISTRY_SERVICE_CLASS_NAME);\r\n```\r\n', 'commenter': 'namelessssssssssss'}]"
12948,dubbo-common/src/main/java/org/apache/dubbo/config/context/AbstractConfigManager.java,"@@ -613,7 +612,7 @@ protected <T extends AbstractConfig> boolean isNeedValidation(T config) {
 
     private ConfigValidator getConfigValidator() {","[{'comment': 'Use `ConfigValidatorFacade` here', 'commenter': 'AlbumenJ'}]"
12950,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java,"@@ -68,8 +69,10 @@ private void schedule(Runnable removable) {
         if (atomicBoolean.compareAndSet(false, true)) {
             boolean success = false;
             try {
-                executor.execute(this);
-                success = true;
+                if (!executor.isShutdown()) {","[{'comment': 'maybe only needed `instanceof` and `cast`, other code should not change', 'commenter': 'icodening'}, {'comment': 'Okay, for example:\r\n![image](https://github.com/apache/dubbo/assets/18413695/4fd6fbc2-ad10-4f5a-9450-b0cd77f62283)\r\n![image](https://github.com/apache/dubbo/assets/18413695/6bcd21a1-7bbf-4715-aa26-5b521f11534c)\r\n', 'commenter': 'finefuture'}]"
12950,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java,"@@ -42,7 +42,7 @@ public final class SerializingExecutor implements Executor, Runnable {
      */
     private final AtomicBoolean atomicBoolean = new AtomicBoolean();
 
-    private final ExecutorService executor;","[{'comment': ""Why change type from ExecutorService to Executor?\r\nI think there's no need to change it.\r\n"", 'commenter': 'bert82503'}, {'comment': 'Already rolled back.', 'commenter': 'finefuture'}]"
12950,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java,"@@ -41,7 +42,7 @@ public final class SerializingExecutor implements Executor, Runnable {
      */
     private final AtomicBoolean atomicBoolean = new AtomicBoolean();
 
-    private final Executor executor;","[{'comment': 'Is there rollback type?\r\nnice work.\r\n', 'commenter': 'bert82503'}, {'comment': 'Yep, already rolled back.', 'commenter': 'finefuture'}]"
12953,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java,"@@ -224,10 +224,8 @@ public List<Invoker<T>> list(Invocation invocation) throws RpcException {
 
                 logger.warn(CLUSTER_NO_VALID_PROVIDER, ""provider server or registry center crashed"", """",
                     ""No provider available after connectivity filter for the service "" + getConsumerUrl().getServiceKey()
-                        + "" All validInvokers' size: "" + validInvokers.size()
                         + "" All routed invokers' size: "" + routedResult.size()
-                        + "" All invokers' size: "" + invokers.size()
-                        + "" from registry "" + getUrl().getAddress()","[{'comment': ""Origin invokers' size is necessary to find out if there are some providers disconnected."", 'commenter': 'AlbumenJ'}, {'comment': ""![image](https://github.com/apache/dubbo/assets/18413695/713f1626-f8a3-45a9-a1de-e137bb432561)\r\nBecause Directory‘s toString method has invokers' size and other detail info, it can replace"", 'commenter': 'finefuture'}, {'comment': 'Cloud u pls provide a example log to see what would be log when no provider found?', 'commenter': 'AlbumenJ'}, {'comment': '![image](https://github.com/apache/dubbo/assets/18413695/d51255b8-45d2-4301-a76a-dd70d9f98a9a)\r\nFor example', 'commenter': 'finefuture'}]"
12955,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleWritePingHandler.java,"@@ -0,0 +1,79 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.protocol.tri;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelDuplexHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;
+import io.netty.handler.timeout.IdleState;
+import io.netty.handler.timeout.IdleStateEvent;
+
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+
+public class TripleWritePingHandler extends ChannelDuplexHandler {
+
+    private final long writePingIntervalInMs;
+
+    private ScheduledFuture<?> scheduledFuture;
+
+    public TripleWritePingHandler(long writePingIntervalInMs) {
+        this.writePingIntervalInMs = writePingIntervalInMs;
+    }
+
+    @Override
+    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+        super.channelActive(ctx);
+        scheduledFuture = ctx.executor().scheduleWithFixedDelay(new WritePingTask(ctx.channel()), writePingIntervalInMs, writePingIntervalInMs, TimeUnit.MILLISECONDS);","[{'comment': 'Need a better way to write heartbeat.', 'commenter': 'AlbumenJ'}, {'comment': 'ok , i will redesign it', 'commenter': 'icodening'}]"
12955,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyConnectionClient.java,"@@ -122,12 +125,15 @@ protected void initChannel(SocketChannel ch) {
                 }
 
 //                pipeline.addLast(""logging"", new LoggingHandler(LogLevel.INFO)); //for debug
-                // TODO support IDLE
-//                int heartbeatInterval = UrlUtils.getHeartbeat(getUrl());
+
+                int idleTimeout = UrlUtils.getIdleTimeout(getUrl());
+                pipeline.addLast(""client-idle-handler"", new IdleStateHandler(idleTimeout, 0, 0, MILLISECONDS));","[{'comment': 'Need a idle handler and a close handler.', 'commenter': 'AlbumenJ'}]"
12987,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/Server.java,"@@ -115,17 +115,33 @@ protected void initChannel(Channel ch) throws Exception {
                 ));
             }
         });
-        try {
-            if (StringUtils.isBlank(host)) {
-                serverBootstrap.bind(port).sync();
+        Throwable lastError = null;
+        for (int i = 0; i < 10; i++) {","[{'comment': 'I recommend adding a server-failed-retry-count  and  server-failed-retry-interval configuration\r\n', 'commenter': 'CrazyHZM'}, {'comment': 'ok', 'commenter': 'AlbumenJ'}, {'comment': 'done', 'commenter': 'AlbumenJ'}]"
12987,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServer.java,"@@ -138,9 +139,31 @@ protected void initChannel(SocketChannel ch) throws Exception {
             bindIp = ANYHOST_VALUE;
         }
         InetSocketAddress bindAddress = new InetSocketAddress(bindIp, bindPort);
-        ChannelFuture channelFuture = bootstrap.bind(bindAddress);
-        channelFuture.syncUninterruptibly();
-        channel = channelFuture.channel();
+        Throwable lastError = null;
+        int retryTimes = getUrl().getParameter(Constants.BIND_RETRY_TIMES, 10);
+        int retryInterval = getUrl().getParameter(Constants.BIND_RETRY_INTERVAL, 3000);
+        for (int i = 0; i < retryTimes; i++) {","[{'comment': ""Why would we need binding retry, what's the problem with throwing exception directly on binding failure."", 'commenter': 'chickenlj'}, {'comment': 'Such 20880, 22222... are in `ip_local_port_range` and can be used as a tcp client port. If there is someone requesting remoting using 20880 as client port(allocated by kernel), Dubbo will bind failed.', 'commenter': 'AlbumenJ'}]"
12987,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java,"@@ -128,13 +130,12 @@ private void startQosServer(URL url) {
             server.setAcceptForeignIpWhitelist(acceptForeignIpWhitelist);
             server.setAnonymousAccessPermissionLevel(anonymousAccessPermissionLevel);
             server.setAnonymousAllowCommands(anonymousAllowCommands);
-            server.start();
+            server.start(qosCheck);
 
         } catch (Throwable throwable) {
             logger.warn(QOS_FAILED_START_SERVER, """", """", ""Fail to start qos server: "", throwable);
-            boolean qosCheck = url.getParameter(QOS_CHECK, false);
             if (qosCheck) {
-                throw new IllegalStateException(""Fail to start qos server: "" + throwable.getMessage(), throwable);
+                throw new RpcException(throwable);","[{'comment': 'Unnecessary wrap, how about throw it directly.', 'commenter': 'chickenlj'}]"
12990,dubbo-common/src/main/java/org/apache/dubbo/metadata/MetadataPublisherRegister.java,"@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.metadata;
+
+import org.apache.dubbo.common.deploy.ApplicationDeployListener;
+import org.apache.dubbo.common.extension.ExtensionLoader;
+import org.apache.dubbo.rpc.model.ApplicationModel;
+
+public class MetadataPublisherRegister implements ApplicationDeployListener {","[{'comment': 'Just move to `dubbo-metadata-api` and inject by itself. BTW, SPI for `MetadataPublisher` is really necessary?', 'commenter': 'AlbumenJ'}, {'comment': 'Yes, it seems unnecessary to make `MetadataPublisher` a SPI. I will fix it.', 'commenter': 'namelessssssssssss'}]"
12990,dubbo-registry/dubbo-registry-api/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.common.deploy.ApplicationDeployListener,,"[{'comment': 'Moving the ApplicationContext to common', 'commenter': 'namelessssssssssss'}, {'comment': 'Move the lifecycle related API to common', 'commenter': 'namelessssssssssss'}, {'comment': 'Move this two simple metadata API common', 'commenter': 'namelessssssssssss'}, {'comment': 'After metrics-api replaced by metrics-event, this class can move to metrics-default', 'commenter': 'namelessssssssssss'}, {'comment': 'Some validator moved to other packages', 'commenter': 'namelessssssssssss'}, {'comment': 'This test need move to IT', 'commenter': 'namelessssssssssss'}, {'comment': 'This test need move to IT', 'commenter': 'namelessssssssssss'}, {'comment': 'This test need move to IT', 'commenter': 'namelessssssssssss'}]"
13001,dubbo-remoting/dubbo-remoting-api/src/test/java/org/apache/dubbo/remoting/exchange/support/DefaultFutureTest.java,"@@ -86,6 +86,44 @@ public void timeoutNotSend() throws Exception {
         }
     }
 
+    /**
+     * for example, it will print like this:
+     * before a future is created, time is : 2023-09-03 18:20:14.535
+     * after a future is timeout, time is : 2023-09-03 18:20:14.669
+     * <p>
+     * The exception info print like:
+     * Sending request timeout in client-side by scan timer.
+     * start time: 2023-09-03 18:20:14.544, end time: 2023-09-03 18:20:14.598...
+     */
+    @Test
+    @Disabled","[{'comment': 'Why dieable it?', 'commenter': 'AlbumenJ'}, {'comment': 'copied other test case.', 'commenter': 'tianshuang'}, {'comment': 'see: https://github.com/apache/dubbo/pull/4574', 'commenter': 'tianshuang'}, {'comment': 'Try enable it to see if it works in Github Actions~', 'commenter': 'AlbumenJ'}, {'comment': 'OK', 'commenter': 'tianshuang'}]"
13015,dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java,"@@ -158,7 +158,7 @@ private static Wrapper makeWrapper(Class<?> c) {
             pts.put(fn, ft);
         }
 
-        final ClassPool classPool = new ClassPool(ClassPool.getDefault());
+        final ClassPool classPool = new ClassPool(true);","[{'comment': 'Looks like what `org.apache.dubbo.common.bytecode.ClassGenerator#POOL_MAP` does?', 'commenter': 'AlbumenJ'}, {'comment': '确实是一样的。\r\n我目前的改法是出于最小修改原则\r\n如果要复用ClassGenerator的逻辑\r\n那么就是删除161 162 163这三行\r\n并替换为：final ClassPool classPool = ClassGenerator.getClassPool(cl);\r\n\r\n同时还发现ClassGenerator.getClassPool这个方法没有做线程安全，也需要修改\r\n```\r\npublic static ClassPool getClassPool(ClassLoader loader) {\r\n        if (loader == null) {\r\n            return ClassPool.getDefault();\r\n        }\r\n\r\n        ClassPool pool = POOL_MAP.get(loader);\r\n        if (pool == null) {\r\n            pool = new ClassPool(true);\r\n            pool.insertClassPath(new LoaderClassPath(loader));\r\n            pool.insertClassPath(new DubboLoaderClassPath());\r\n            POOL_MAP.put(loader, pool);\r\n        }\r\n        return pool;\r\n    }\r\n```\r\n\r\n于是我再次提交了代码\r\n', 'commenter': 'wien13'}]"
13015,dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java,"@@ -89,13 +89,19 @@ public static ClassPool getClassPool(ClassLoader loader) {
         if (loader == null) {
             return ClassPool.getDefault();
         }
-
-        ClassPool pool = POOL_MAP.get(loader);
+        //https://sonarcloud.io/organizations/apache/rules?open=java%3AS2445&rule_key=java%3AS2445&tab=why","[{'comment': '这个改成原来的吧，我直接忽略检查就行', 'commenter': 'AlbumenJ'}, {'comment': '好的 ，我处理下', 'commenter': 'wien13'}]"
13015,dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/Wrapper.java,"@@ -158,9 +156,7 @@ private static Wrapper makeWrapper(Class<?> c) {
             pts.put(fn, ft);
         }
 
-        final ClassPool classPool = new ClassPool(ClassPool.getDefault());
-        classPool.insertClassPath(new LoaderClassPath(cl));
-        classPool.insertClassPath(new DubboLoaderClassPath());
+        final ClassPool classPool = ClassGenerator.getClassPool(cl);","[{'comment': '如果这个池子共享了，是不是单独抽一个 util 类出来管理会好一些', 'commenter': 'AlbumenJ'}, {'comment': 'ClassPool池是ClassGenerator的一部分，而且我看ClassGenerator整个是管理字节码增强的，而且getClassPool还是一个public方法，ClassPool池也属于字节码增强的一部分，都放在ClassGenerator里管理是不是也不错\r\n\r\n我搜了下，算上ClassGenerator自己，之前就有2个类JValidatorNew、JValidator在使用这个getClassPool\r\n![image](https://github.com/apache/dubbo/assets/5327221/f5ac23f1-7014-4aff-828a-d52f0a8e3d4a)\r\n算上本次我改完加入的Wrapper，一共就是4个类使用这个getClassPool池', 'commenter': 'wien13'}]"
13015,dubbo-common/src/main/java/org/apache/dubbo/common/bytecode/ClassGenerator.java,"@@ -92,10 +92,15 @@ public static ClassPool getClassPool(ClassLoader loader) {
 
         ClassPool pool = POOL_MAP.get(loader);
         if (pool == null) {
-            pool = new ClassPool(true);
-            pool.insertClassPath(new LoaderClassPath(loader));
-            pool.insertClassPath(new DubboLoaderClassPath());
-            POOL_MAP.put(loader, pool);
+            synchronized (loader) {","[{'comment': '这里是不是直接使用当前 class 作为同步对象去弄，直接使用 loader 如果用户侧也是用了 loader 作为 metux 会出现死锁的', 'commenter': 'AlbumenJ'}, {'comment': '你说的这个方式我知道，使用当前class、POOL_MAP、或者单独搞一个独立static final对象做为锁，效果都可到达你说的，既所有的线程来到这里get为null无论来自哪个classloader都会排队。但这与现在的写法逻辑完全不同了，现在是每个classloader都是独立的锁。\r\n\r\n当然是有概率发生你说的事情的，调用这个方法的外部方法先锁住classloader，这里就会发生死锁。\r\n那么现在就有2个选择：\r\n1、使用classloader独立锁，多个Classloader调用的时候不发生锁冲突\r\n2、为了避免问题1，共用同一个锁，避免发生classloader死锁问题\r\n\r\n仔细分析了下，这个地方锁住等待的开销非常非常低，所以使用一个公共锁避免发生classloader死锁是对的，但是我觉得别锁当前class了，锁POOL_MAP更好\r\n', 'commenter': 'wien13'}]"
13028,dubbo-native/pom.xml,"@@ -35,6 +35,10 @@
             <artifactId>dubbo-common</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-transport</artifactId>
+        </dependency>","[{'comment': 'Native modules cannot depend on modules from any other three parties.\r\n', 'commenter': 'CrazyHZM'}]"
13028,dubbo-native/src/main/java/org/apache/dubbo/aot/generate/AotProcessor.java,"@@ -51,6 +51,7 @@ public static void main(String[] args) {
             .registerAdaptiveType(new ArrayList<>(ClassSourceScanner.INSTANCE.adaptiveClasses().values()))
             .registerBeanType(ClassSourceScanner.INSTANCE.scopeModelInitializer())
             .registerConfigType(ClassSourceScanner.INSTANCE.configClasses())
+            .registerBeanType(ClassSourceScanner.INSTANCE.getNetty4ChannelHandlerSubclasses()) // actually queryAllPublicMethods is enough","[{'comment': ""It's not supposed to handle Netty content here, and it is a good way to borrow ReflectionTypeDescriberRegistrar to implement this logic.\r\n\r\n"", 'commenter': 'CrazyHZM'}, {'comment': 'I need the jar scanner,if move to the ReflectionTypeDescriberRegistrar can scanner expose to it？', 'commenter': 'FoghostCn'}]"
13029,dubbo-filter/dubbo-filter-validation/src/main/java/org/apache/dubbo/validation/filter/ValidationFilter.java,"@@ -82,8 +83,7 @@ public void setValidation(Validation validation) {
      */
     @Override
     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
-        if (validation != null && !invocation.getMethodName().startsWith(""$"")
-            && ConfigUtils.isNotEmpty(invoker.getUrl().getMethodParameter(invocation.getMethodName(), VALIDATION_KEY))) {
+        if (validation != null && needValidate(invoker.getUrl(), invocation.getMethodName())) {","[{'comment': '`validation != null` should be part of `needVlidate` method.', 'commenter': 'CrazyHZM'}, {'comment': 'Updated', 'commenter': 'refeccd'}]"
13033,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/event/RequestEvent.java,"@@ -58,10 +59,18 @@ public static RequestEvent toRequestEvent(ApplicationModel applicationModel, Str
                                               MetricsDispatcher metricsDispatcher, DefaultMetricsCollector collector,
                                               Invocation invocation, String side) {
         MethodMetric methodMetric = new MethodMetric(applicationModel, invocation);
+        RequestEvent requestEvent = getRequestEvent(applicationModel, appName, metricsDispatcher, collector, invocation,
+            side, methodMetric, MetricsSupport.getInterfaceName(invocation));
+        return requestEvent;
+    }
+
+
+
+    private static RequestEvent getRequestEvent(ApplicationModel applicationModel, String appName, MetricsDispatcher metricsDispatcher, DefaultMetricsCollector collector, Invocation invocation, String side, ServiceKeyMetric methodMetric, String serviceKey) {","[{'comment': 'This method of extraction seems unnecessary, there are too many parameters, and it is only used once.', 'commenter': 'wxbty'}]"
13033,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MethodMetric.java,"@@ -38,10 +41,23 @@ public class MethodMetric extends ServiceKeyMetric {
 
     public MethodMetric(ApplicationModel applicationModel, Invocation invocation) {
         super(applicationModel, MetricsSupport.getInterfaceName(invocation));
-        this.methodName = RpcUtils.getMethodName(invocation);
         this.side = MetricsSupport.getSide(invocation);
         this.group = MetricsSupport.getGroup(invocation);
         this.version = MetricsSupport.getVersion(invocation);
+        if (isServiceLevel(applicationModel)) {
+            this.methodName = """";
+            return;
+        }
+        this.methodName = RpcUtils.getMethodName(invocation);","[{'comment': 'Why does methodName need to be assigned an empty string，service-level does not display this label， Will this be more concise?\r\nif (!isServiceLevel(applicationModel)) {\r\n        this.methodName = RpcUtils.getMethodName(invocation);      \r\n }', 'commenter': 'wxbty'}]"
13033,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MethodMetric.java,"@@ -38,10 +41,17 @@ public class MethodMetric extends ServiceKeyMetric {
 
     public MethodMetric(ApplicationModel applicationModel, Invocation invocation) {
         super(applicationModel, MetricsSupport.getInterfaceName(invocation));
-        this.methodName = RpcUtils.getMethodName(invocation);
         this.side = MetricsSupport.getSide(invocation);
         this.group = MetricsSupport.getGroup(invocation);
         this.version = MetricsSupport.getVersion(invocation);
+        this.methodName = isServiceLevel(applicationModel) ? null : RpcUtils.getMethodName(invocation);","[{'comment': 'Should pre-check for `isServiceLevel`. Prevent cal it for each invocation.', 'commenter': 'AlbumenJ'}, {'comment': ' this is a good suggestion', 'commenter': 'songxiaosheng'}]"
13033,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java,"@@ -97,6 +98,7 @@ public AggregateMetricsCollector(ApplicationModel applicationModel) {
                 this.enableRequest = Optional.ofNullable(aggregation.getEnableRequest()).orElse(true);
             }
         }
+        this.serviceLevel = MethodMetric.isServiceLevel(applicationModel);","[{'comment': 'Move into `if (isCollectEnabled()` and `if (optional.isPresent())`', 'commenter': 'AlbumenJ'}]"
13033,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/HistogramMetricsCollector.java,"@@ -69,6 +71,7 @@ public HistogramMetricsCollector(ApplicationModel applicationModel) {
 
             metricRegister = new HistogramMetricRegister(MetricsGlobalRegistry.getCompositeRegistry(applicationModel), histogram);
         }
+        this.serviceLevel = MethodMetric.isServiceLevel(applicationModel);","[{'comment': 'Move into `if (config == null || config.getHistogram() == null || config.getHistogram().getEnabled() == null || Boolean.TRUE.equals(config.getHistogram().getEnabled()))`', 'commenter': 'AlbumenJ'}]"
13034,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MetricsSupport.java,"@@ -59,25 +59,30 @@
 public class MetricsSupport {
 
     private static final String version = Version.getVersion();
+
     private static final String commitId = Version.getLastCommitId();
 
+
     public static Map<String, String> applicationTags(ApplicationModel applicationModel) {
         return applicationTags(applicationModel, null);
     }
 
     public static Map<String, String> applicationTags(ApplicationModel applicationModel, @Nullable Map<String, String> extraInfo) {
         Map<String, String> tags = new HashMap<>();
-        tags.put(TAG_IP, getLocalHost());
-        tags.put(TAG_HOSTNAME, getLocalHostName());
         tags.put(TAG_APPLICATION_NAME, applicationModel.getApplicationName());
         tags.put(TAG_APPLICATION_MODULE, applicationModel.getInternalId());
         tags.put(TAG_APPLICATION_VERSION_KEY, version);
-        tags.put(MetricsKey.METADATA_GIT_COMMITID_METRIC.getName(), commitId);
         if (CollectionUtils.isNotEmptyMap(extraInfo)) {
             tags.putAll(extraInfo);
         }
         return tags;
     }
+    public static Map<String, String> applicationPrivateTags(ApplicationModel applicationModel, Map<String, String> tags) {","[{'comment': '```suggestion\r\n    public static Map<String, String> hostInfoTags(ApplicationModel applicationModel, Map<String, String> tags) {\r\n```', 'commenter': 'AlbumenJ'}]"
13034,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MetricsSupport.java,"@@ -59,25 +59,33 @@
 public class MetricsSupport {
 
     private static final String version = Version.getVersion();
+
     private static final String commitId = Version.getLastCommitId();
 
+
     public static Map<String, String> applicationTags(ApplicationModel applicationModel) {
         return applicationTags(applicationModel, null);
     }
 
     public static Map<String, String> applicationTags(ApplicationModel applicationModel, @Nullable Map<String, String> extraInfo) {
         Map<String, String> tags = new HashMap<>();
-        tags.put(TAG_IP, getLocalHost());
-        tags.put(TAG_HOSTNAME, getLocalHostName());
         tags.put(TAG_APPLICATION_NAME, applicationModel.getApplicationName());
         tags.put(TAG_APPLICATION_MODULE, applicationModel.getInternalId());
         tags.put(TAG_APPLICATION_VERSION_KEY, version);","[{'comment': '`Version` key can be moved into `gitTags`', 'commenter': 'AlbumenJ'}]"
13034,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/model/MetricsSupport.java,"@@ -59,25 +59,33 @@
 public class MetricsSupport {
 
     private static final String version = Version.getVersion();
+
     private static final String commitId = Version.getLastCommitId();
 
+
     public static Map<String, String> applicationTags(ApplicationModel applicationModel) {
         return applicationTags(applicationModel, null);
     }
 
     public static Map<String, String> applicationTags(ApplicationModel applicationModel, @Nullable Map<String, String> extraInfo) {
         Map<String, String> tags = new HashMap<>();
-        tags.put(TAG_IP, getLocalHost());
-        tags.put(TAG_HOSTNAME, getLocalHostName());
         tags.put(TAG_APPLICATION_NAME, applicationModel.getApplicationName());
         tags.put(TAG_APPLICATION_MODULE, applicationModel.getInternalId());
-        tags.put(TAG_APPLICATION_VERSION_KEY, version);
-        tags.put(MetricsKey.METADATA_GIT_COMMITID_METRIC.getName(), commitId);
         if (CollectionUtils.isNotEmptyMap(extraInfo)) {
             tags.putAll(extraInfo);
         }
         return tags;
     }
+    public static Map<String, String> gitTags(Map<String, String> tags) {
+        tags.put(MetricsKey.METADATA_GIT_COMMITID_METRIC.getName(), commitId);
+        tags.put(TAG_APPLICATION_VERSION_KEY, version);
+        return tags;
+    }
+    public static Map<String, String> hostTags( Map<String, String> tags) {
+        tags.put(TAG_IP, getLocalHost());","[{'comment': '服务方法的指标数据，ip标签为何移走了？是怎么考量的？\r\n某个方法耗时长，怎么反推定位到是某个ip实例触发的？通过traceId定位么\r\n', 'commenter': 'bert82503'}, {'comment': 'ip可以直接查指标来源的', 'commenter': 'songxiaosheng'}, {'comment': '明白了，感谢！👍🏻\r\n', 'commenter': 'bert82503'}]"
13045,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/registry/ZoneAwareCluster.java,"@@ -23,8 +23,6 @@
 
 public class ZoneAwareCluster extends AbstractCluster {
 
-    public final static String NAME = ""zone-aware"";","[{'comment': 'The NAME moved to Constants', 'commenter': 'namelessssssssssss'}]"
13045,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Cluster.java,"@@ -24,18 +24,18 @@
 import org.apache.dubbo.rpc.model.ScopeModel;
 import org.apache.dubbo.rpc.model.ScopeModelUtil;
 
+import static org.apache.dubbo.rpc.cluster.Constants.DEFAULT_CLUSTER;
+
 /**
  * Cluster. (SPI, Singleton, ThreadSafe)
  * <p>
  * <a href=""http://en.wikipedia.org/wiki/Computer_cluster"">Cluster</a>
  * <a href=""http://en.wikipedia.org/wiki/Fault-tolerant_system"">Fault-Tolerant</a>
  *
  */
-@SPI(Cluster.DEFAULT)
+@SPI(DEFAULT_CLUSTER)
 public interface Cluster {
 
-    String DEFAULT = ""failover"";","[{'comment': 'This constant moved to Constants', 'commenter': 'namelessssssssssss'}]"
13045,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java,"@@ -291,7 +292,7 @@ private void createInjvmInvoker(Exporter<?> exporter) {
                     Invoker<?> invoker = protocolSPI.refer(getInterface(), consumerUrl);
                     List<Invoker<?>> invokers = new ArrayList<>();
                     invokers.add(invoker);
-                    injvmInvoker = Cluster.getCluster(url.getScopeModel(), Cluster.DEFAULT, false).join(new StaticDirectory(url, invokers), true);
+                    injvmInvoker = Cluster.getCluster(url.getScopeModel(), DEFAULT_CLUSTER, false).join(new StaticDirectory(url, invokers), true);","[{'comment': 'Using DEFAULT_CLUSTER to avoid the reference of Cluster', 'commenter': 'namelessssssssssss'}]"
13045,dubbo-common/src/main/java/org/apache/dubbo/metadata/ServiceNameMapping.java,"@@ -59,46 +52,6 @@ static ServiceNameMapping getDefaultExtension(ScopeModel scopeModel) {
         return ScopeModelUtil.getApplicationModel(scopeModel).getDefaultExtension(ServiceNameMapping.class);
     }
 
-    static String buildMappingKey(URL url) {","[{'comment': 'This methods are moved to a simple util', 'commenter': 'namelessssssssssss'}]"
13045,dubbo-config/dubbo-config-api/pom.xml,"@@ -198,25 +192,25 @@
             <scope>test</scope>
         </dependency>
 
-        <dependency>","[{'comment': 'Depedency of configcenter will cause cyclic reference, and related tests needs to move.', 'commenter': 'namelessssssssssss'}]"
13045,dubbo-config/dubbo-config-api/pom.xml,"@@ -30,59 +30,53 @@
         <skip_maven_deploy>false</skip_maven_deploy>
     </properties>
     <dependencies>
-        <dependency>
-            <groupId>org.apache.dubbo</groupId>
-            <artifactId>dubbo-registry-api</artifactId>
-            <version>${project.parent.version}</version>
-        </dependency>
+<!--        <dependency>-->
+<!--            <groupId>org.apache.dubbo</groupId>-->
+<!--            <artifactId>dubbo-registry-api</artifactId>-->
+<!--            <version>${project.parent.version}</version>-->
+<!--        </dependency>-->
+<!--        <dependency>-->
+<!--            <groupId>org.apache.dubbo</groupId>-->
+<!--            <artifactId>dubbo-metadata-api</artifactId>-->
+<!--            <version>${project.parent.version}</version>-->
+<!--        </dependency>-->
+<!--        <dependency>-->
+<!--            <groupId>org.apache.dubbo</groupId>-->
+<!--            <artifactId>dubbo-metrics-default</artifactId>-->
+<!--            <version>${project.parent.version}</version>-->
+<!--        </dependency>-->
+<!--        <dependency>-->
+<!--            <groupId>org.apache.dubbo</groupId>-->
+<!--            <artifactId>dubbo-metrics-registry</artifactId>-->
+<!--            <version>${project.parent.version}</version>-->
+<!--        </dependency>-->
+<!--        <dependency>-->
+<!--            <groupId>org.apache.dubbo</groupId>-->
+<!--            <artifactId>dubbo-metrics-metadata</artifactId>-->
+<!--            <version>${project.parent.version}</version>-->
+<!--        </dependency>-->
+<!--        <dependency>-->
+<!--            <groupId>org.apache.dubbo</groupId>-->
+<!--            <artifactId>dubbo-metrics-config-center</artifactId>-->
+<!--            <version>${project.parent.version}</version>-->
+<!--        </dependency>-->
+<!--        <dependency>-->
+<!--            <groupId>org.apache.dubbo</groupId>-->
+<!--            <artifactId>dubbo-tracing</artifactId>-->
+<!--            <version>${project.parent.version}</version>-->
+<!--        </dependency>-->
 
         <dependency>
             <groupId>org.apache.dubbo</groupId>
-            <artifactId>dubbo-metadata-api</artifactId>
+            <artifactId>dubbo-monitor-api</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
-
         <dependency>
             <groupId>org.apache.dubbo</groupId>
+            <!--TODO: swap to metrics-event-->","[{'comment': 'After metrics refactor, this package can be replaced by metrics-event', 'commenter': 'namelessssssssssss'}]"
13045,dubbo-config/dubbo-config-api/pom.xml,"@@ -178,46 +132,13 @@
             <scope>test</scope>
         </dependency>
 
-        <dependency>","[{'comment': 'Depedency of metadata-api will cause cyclic reference, and related tests needs to move.', 'commenter': 'namelessssssssssss'}]"
13045,dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/ConfigValidatorExistTest.java,"@@ -48,19 +46,15 @@ void testConfigValidatorExist(){
 
         validateFacade = new ConfigValidateFacade(applicationModel);
         Assertions.assertNotNull(validateFacade);
-        Assertions.assertTrue(validateFacade.getValidators().size() >= 7);
+        Assertions.assertTrue(validateFacade.getValidators().size() >= 4);","[{'comment': 'Some validators are moved to other packages', 'commenter': 'namelessssssssssss'}]"
13045,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/ClusterInvokerFactory.java,"@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc;
+
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.rpc.model.ScopeModel;
+
+import java.util.List;
+
+public interface ClusterInvokerFactory {
+
+    /**
+     * Build a new cluster invoker with static directory.
+     *
+     * @param wrap whether to use a Cluster wrapper to create ClusterInvoker
+     * @param url the url of service registry, used to create a StaticDirectory
+     * @param buildFilterChain whether add a filter chain to new ClusterInvoker
+     */
+    Invoker<?> buildWithStaticDirectory(ScopeModel scopeModel, String name, boolean wrap, URL url, List<Invoker<?>> invokers, boolean buildFilterChain);","[{'comment': 'A little wired with this method :)', 'commenter': 'AlbumenJ'}]"
13050,dubbo-remoting/dubbo-remoting-http12/pom.xml,"@@ -59,7 +59,11 @@
             <groupId>io.netty</groupId>
             <artifactId>netty-codec-http2</artifactId>
         </dependency>
-
+        <dependency>
+            <groupId>org.apache.dubbo</groupId>
+            <artifactId>dubbo-native</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>","[{'comment': 'Test scope is enough?', 'commenter': 'AlbumenJ'}, {'comment': 'aot config interface class `ReflectionTypeDescriberRegistrar` placed at dubbo-native module,it should be compile scope', 'commenter': 'FoghostCn'}, {'comment': ""Maybe it can be an optional dependency, but for now, I think it's better to keep consistent with the other modules.\r\n\r\n\r\n\r\n\r\n\r\n"", 'commenter': 'FoghostCn'}]"
13102,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java,"@@ -449,23 +449,25 @@ public void onHeader(Http2Headers headers, boolean endStream) {
 
         @Override
         public void onData(ByteBuf data, boolean endStream) {
-            executor.execute(() -> {
-                if (transportError != null) {
-                    transportError.appendDescription(
-                        ""Data:"" + data.toString(StandardCharsets.UTF_8));
-                    ReferenceCountUtil.release(data);
-                    if (transportError.description.length() > 512 || endStream) {
-                        handleH2TransportError(transportError);
-                    }
-                    return;
-                }
-                if (!headerReceived) {
-                    handleH2TransportError(TriRpcStatus.INTERNAL.withDescription(
-                        ""headers not received before payload""));
-                    return;
+            executor.execute(() -> doOnData(data, endStream), () -> ReferenceCountUtil.release(data));","[{'comment': 'But is there anything better here?', 'commenter': 'EarthChen'}, {'comment': 'Still using Executor', 'commenter': 'EarthChen'}, {'comment': 'It is SerializingExecutor, not a real Executor, should replace method name?', 'commenter': 'finefuture'}, {'comment': 'What I mean is that the failed operation can not destroy the serialExecutor interface?', 'commenter': 'EarthChen'}, {'comment': 'Maybe i can make CloseableRunnable, if execute failed, clear resource', 'commenter': 'finefuture'}, {'comment': 'maybe，go ahead', 'commenter': 'EarthChen'}, {'comment': 'Resubmitted, please review.', 'commenter': 'finefuture'}, {'comment': ""Is it possible to reuse jdk's closeable?"", 'commenter': 'EarthChen'}, {'comment': ""![image](https://github.com/apache/dubbo/assets/18413695/735a29f4-15db-4298-9cdd-d2d855766c9d)\r\nIt would throw a IOException, and SerializingExecutor need handle it, but SerializingExecutor shouldn't do the job"", 'commenter': 'finefuture'}, {'comment': 'Ok.fine', 'commenter': 'EarthChen'}]"
13102,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/CloseableRunnable.java,"@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.common.threadpool.serial;
+
+/**
+ * Runnable with clean function
+ */
+public interface CloseableRunnable extends Runnable {","[{'comment': '`java.io.Closeable` might be better', 'commenter': 'icodening'}]"
13102,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/serial/SerializingExecutor.java,"@@ -86,6 +86,9 @@ private void schedule(Runnable removable) {
                         // to execute don't succeed and accidentally run a previous runnable.
                         runQueue.remove(removable);
                     }
+                    if (removable instanceof CloseableRunnable) {","[{'comment': 'It will not be executed when `atomicBoolean.compareAndSet(false, true) == false (line 68)`', 'commenter': 'icodening'}]"
13104,dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/data/BaseStatComposite.java,"@@ -133,4 +133,14 @@ public ApplicationStatComposite getApplicationStatComposite() {
     public RtStatComposite getRtStatComposite() {
         return rtStatComposite;
     }
+
+    @Override
+    public boolean calSamplesChanged() {
+        // Should ensure that all the composite's samplesChanged have been compareAndSet, and cannot flip the `or` logic
+        boolean changed = applicationStatComposite.calSamplesChanged();
+        changed = rtStatComposite.calSamplesChanged() || changed;
+        changed = serviceStatComposite.calSamplesChanged() || changed;
+        changed = methodStatComposite.calSamplesChanged() || changed;
+        return changed;
+    }","[{'comment': 'changed = changed || rtStatComposite.calSamplesChanged() ; \r\nThis would be better，Similar in other places.', 'commenter': 'wxbty'}, {'comment': '`calSamplesChanged` before check `changed` can ensure that all the samples has been updated at once.\r\nFor examle, if a composite contains A and B samples and these two samples are changed. If `calSamplesChanged` before check `changed` can update all the flags both in A and B. Thus, one time `refresh` can refresh all.', 'commenter': 'AlbumenJ'}, {'comment': 'Understood', 'commenter': 'wxbty'}]"
13110,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericFilter.java,"@@ -191,6 +192,26 @@ public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
                                 args.length + "" and type is"" +
                                 args[0].getClass().getName());
                     }
+                }  else if (ProtocolUtils.isNativeStreamGenericSerialization(generic)) {
+                    for (int i = 0; i < args.length; i++) {
+                        if (byte[].class == args[i].getClass()) {
+                            try (UnsafeByteArrayInputStream is = new UnsafeByteArrayInputStream((byte[]) args[i])) {
+                                args[i] = applicationModel.getExtensionLoader(Serialization.class)
+                                    .getExtension(invoker.getUrl().getParameter(Constants.SERIALIZATION_KEY))
+                                    .deserialize(null, is).readObject(method.getParameterTypes()[i]);
+                            } catch (Exception e) {
+                                throw new RpcException(""Deserialize argument ["" + (i + 1) + ""] failed."", e);
+                            }
+                        } else {
+                            throw new RpcException(
+                                ""Generic serialization ["" +
+                                    invoker.getUrl().getParameter(Constants.SERIALIZATION_KEY) +
+                                    ""] only support message type "" +
+                                    byte[].class +
+                                    "" and your message type is "" +
+                                    args[i].getClass());
+                        }
+                    }","[{'comment': 'It seems like using byte array as a serialization input. In my opinion, it would be better to being customized in a custom `Filter` not in Dubbo framework.', 'commenter': 'AlbumenJ'}, {'comment': 'ensure data types in runtime by an external filter is more compatible', 'commenter': 'kimmking'}, {'comment': '@AlbumenJ @kimmking Thanks to both of you for your opinions, we will try it. I will close this PR first.', 'commenter': 'mr3'}]"
13145,dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/plugin/DubboProtocPluginWrapperFactory.java,"@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.maven.plugin.protoc.plugin;","[{'comment': 'Remove a package path, and  `org.apache.dubbo.maven.plugin.protoc` is better.', 'commenter': 'CrazyHZM'}, {'comment': 'Already refactored', 'commenter': 'sadfera'}]"
13145,dubbo-compiler/README.md,"@@ -0,0 +1,138 @@
+## dubbo-complier
+
+> dubbo-complier supports generating code based on .proto files
+
+### How to use 
+
+#### 1.Define Proto file
+
+greeter.proto
+```protobuf
+syntax = ""proto3"";
+
+option java_multiple_files = true;
+option java_package = ""org.apache.dubbo.demo"";
+option java_outer_classname = ""DemoServiceProto"";
+option objc_class_prefix = ""DEMOSRV"";
+
+package demoservice;
+
+// The demo service definition.
+service DemoService {
+  rpc SayHello (HelloRequest) returns (HelloReply) {}
+}
+
+// The request message containing the user's name.
+message HelloRequest {
+  string name = 1;
+}
+
+// The response message containing the greetings
+message HelloReply {
+  string message = 1;
+}
+
+```
+
+#### 2.Use dubbo-maven-plugin,rather than ```protobuf-maven-plugin```
+
+    now dubbo support his own protoc plugin base on dubbo-maven-plugin
+
+```xml
+  <plugin>
+    <groupId>org.apache.dubbo</groupId>
+    <artifactId>dubbo-maven-plugin</artifactId>
+    <version>3.2.7-SNAPSHOT</version>","[{'comment': '```suggestion\r\n    <version>3.3.0</version>\r\n```', 'commenter': 'AlbumenJ'}]"
13145,dubbo-compiler/src/main/java/org/apache/dubbo/gen/utils/ProtoTypeMap.java,"@@ -0,0 +1,139 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */","[{'comment': 'Remove this header and add this file into exclustion in license checker', 'commenter': 'AlbumenJ'}, {'comment': 'ok', 'commenter': 'sadfera'}]"
13145,dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/DubboProtocPluginWrapperFactory.java,"@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.maven.plugin.protoc;
+
+
+import org.codehaus.plexus.util.Os;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class DubboProtocPluginWrapperFactory {","[{'comment': 'No place to use this class?', 'commenter': 'CrazyHZM'}, {'comment': 'org.apache.dubbo.maven.plugin.protoc.DubboProtocCompilerMojo use it , and It will help me find the  pluginWrapper class based on the operating system', 'commenter': 'sadfera'}]"
13145,.licenserc.yaml,"@@ -104,6 +104,8 @@ header:
     - 'dubbo-annotation-processor/src/main/java/org/apache/dubbo/annotation/permit/**'
     - 'dubbo-common/src/main/java/org/apache/dubbo/common/logger/helpers/FormattingTuple.java'
     - 'dubbo-common/src/main/java/org/apache/dubbo/common/logger/helpers/MessageFormatter.java'
+    - 'dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/DubboProtocCompilerMojo.java'
+    - 'dubbo-compiler/src/main/java/org/apache/dubbo/gen/utils/ProtoTypeMap.java'","[{'comment': 'Please add the notification into `NOTICE` file to declare the copyright.', 'commenter': 'AlbumenJ'}, {'comment': 'ok,my pleasure', 'commenter': 'sadfera'}]"
13145,NOTICE,"@@ -16,3 +16,37 @@ Copyright 2014 The Netty Project
 This product contains code form the t-digest Project:
 The code for the t-digest was originally authored by Ted Dunning
 Adrien Grand contributed the heart of the AVLTreeDigest (https://github.com/jpountz)
+
+This product contains the following code copied from Maven Protocol Buffers Plugin:
+dubbo-maven-plugin/src/main/java/org/apache/dubbo/maven/plugin/protoc/DubboProtocCompilerMojo.java
+
+Maven Protocol Buffers Plugin
+=============================
+Copyright (c) 2016 Maven Protocol Buffers Plugin Authors. All rights reserved.
+Maven Protocol Buffers Plugin includes a binary distribution of WinRun4J,
+which is used to execute protoc plugins written in Java
+under 32-bit and 64-bit Windows operating systems.
+
+WinRun4J is licensed under the Common Public License (CPL).
+http://www.eclipse.org/legal/cpl-v10.html
+
+Additional information about WinRun4J is available on
+the project's home page:
+http://winrun4j.sourceforge.net/
+
+For information about the bundled versions of the binaries
+please read src/main/resources/winrun4j/README.txt
+inside this git repository.","[{'comment': 'These lines can be removed', 'commenter': 'AlbumenJ'}, {'comment': 'ok,fixed', 'commenter': 'sadfera'}]"
13155,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java,"@@ -24,13 +24,9 @@
 import org.apache.dubbo.config.Constants;
 import org.apache.dubbo.remoting.utils.UrlUtils;
 import org.apache.dubbo.remoting.transport.CodecSupport;
-import org.apache.dubbo.rpc.model.MethodDescriptor;
-import org.apache.dubbo.rpc.model.Pack;
-import org.apache.dubbo.rpc.model.PackableMethod;
+import org.apache.dubbo.rpc.model.*;","[{'comment': 'Pls remove wildcard import', 'commenter': 'AlbumenJ'}, {'comment': 'ok', 'commenter': 'SpringStudent'}]"
13155,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ReflectionServiceDescriptor.java,"@@ -74,6 +76,10 @@ private void initMethods() {
         }
 
         methods.forEach((methodName, methodList) -> {
+            //pb method not allow override
+            if(methodList.size() > 1 && methodList.stream().filter(methodDescriptor -> Arrays.stream(methodDescriptor.getParameterClasses()).anyMatch(pclss -> isProtobufClass(pclss))).count() > 0L){","[{'comment': 'Please do not add complex judgments to if statements', 'commenter': 'EarthChen'}, {'comment': 'do you mean \r\n`methodList.size() > 1 && methodList.stream()`\r\nneed to be split into 2 if judgement like\r\n\r\n```\r\nif(methodList.size() > 1 ){\r\n   if(methodList.stream()...)\r\n}\r\n```\r\n', 'commenter': 'SpringStudent'}, {'comment': 'Yes.It is better for the stream statement to return a bool value and the if statement to look clearer.', 'commenter': 'EarthChen'}, {'comment': 'ok,i fixed it', 'commenter': 'SpringStudent'}]"
13155,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ReflectionServiceDescriptor.java,"@@ -74,6 +76,13 @@ private void initMethods() {
         }
 
         methods.forEach((methodName, methodList) -> {
+            //pb method not allow override
+            if(methodList.size() > 1){
+                long pbMethodCount = methodList.stream().filter(methodDescriptor -> Arrays.stream(methodDescriptor.getParameterClasses()).anyMatch(pclss -> isProtobufClass(pclss))).count();
+                if(pbMethodCount > 0L){
+                    throw new IllegalStateException(""Protobuf method not allow override,""+""method("" + methodName + "")."");","[{'comment': 'also print interface name', 'commenter': 'AlbumenJ'}, {'comment': 'i will modify the exception msg', 'commenter': 'SpringStudent'}]"
13155,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ReflectionServiceDescriptor.java,"@@ -89,6 +98,21 @@ private void initMethods() {
                     +"" stream method signatures. method("" + methodName + "")"");
         });
     }
+    
+    public static boolean isProtobufClass(Class<?> clazz) {
+        while (clazz != Object.class && clazz != null) {
+            Class<?>[] interfaces = clazz.getInterfaces();
+            if (interfaces.length > 0) {
+                for (Class<?> clazzInterface : interfaces) {
+                    if (PROTOBUF_MESSAGE_CLASS_NAME.equalsIgnoreCase(clazzInterface.getName())) {","[{'comment': '`equals` is enough?', 'commenter': 'AlbumenJ'}, {'comment': 'I think the authors of this method wanted to do this without introducing protobuf dependencies,otherwise we can use isAssignableFrom to judge pb class', 'commenter': 'SpringStudent'}]"
13155,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ReflectionServiceDescriptor.java,"@@ -89,6 +98,21 @@ private void initMethods() {
                     +"" stream method signatures. method("" + methodName + "")"");
         });
     }
+    
+    public static boolean isProtobufClass(Class<?> clazz) {
+        while (clazz != Object.class && clazz != null) {
+            Class<?>[] interfaces = clazz.getInterfaces();
+            if (interfaces.length > 0) {
+                for (Class<?> clazzInterface : interfaces) {
+                    if (PROTOBUF_MESSAGE_CLASS_NAME.equalsIgnoreCase(clazzInterface.getName())) {
+                        return true;
+                    }
+                }
+            }
+            clazz = clazz.getSuperclass();","[{'comment': 'Is it really in need to check super class?', 'commenter': 'AlbumenJ'}, {'comment': 'this method just be moved from ReflectionPackableMethod.java,Is there a better way to judge pb class?', 'commenter': 'SpringStudent'}, {'comment': ""I'm worried about whether judging every time will affect performance when init."", 'commenter': 'AlbumenJ'}, {'comment': 'I understand your concern, if I keep the code logic I submitted unchanged, I can think some solutions:\r\n1. Modify the isProtobufClass method, Judge pb class by isAssignableFrom. This method requires that the Dubco-common project add the dependency of protobuf.\r\n2. Add cache for isProtobufClass method implementation , Cache the pb class while judging the pb class, It can reduce the judgment of the same pb class. In addition, I found that the method also be called in the rpc process, By caching pb Class,performance of rpc call can be improved by caching pb class also.\r\n3. Adding caching in mode 1 has the same benefits as in mode 2', 'commenter': 'SpringStudent'}, {'comment': 'I think this only happens when the service is started and registered, not when rpc is called. The performance impact can be ignored.', 'commenter': 'EarthChen'}, {'comment': '> I think this only happens when the service is started and registered, not when rpc is called. The performance impact can be ignored.\r\n\r\nThe usage time during startup is also important. When the service scale is large, startup can take tens of minutes or even hours.', 'commenter': 'AlbumenJ'}, {'comment': '> > I think this only happens when the service is started and registered, not when rpc is called. The performance impact can be ignored.\r\n> \r\n> The usage time during startup is also important. When the service scale is large, startup can take tens of minutes or even hours.\r\n\r\nWhat can i do to fix it.', 'commenter': 'SpringStudent'}, {'comment': 'I\'ve written some other implementations of the isProtobufClass method. And attach some test results\r\n`public class Test {\r\n\r\n    public static void main(String[] args) throws NoSuchMethodException {\r\n        System.out.println(""####class is pb class start"");\r\n        long start = System.currentTimeMillis();\r\n        for (int i = 0; i < 100000; i++) {\r\n            isProtobufClass(HelloRequest.class);\r\n        }\r\n        System.out.println(""isProtobufClass cost="" + (System.currentTimeMillis() - start));\r\n        start = System.currentTimeMillis();\r\n        for (int i = 0; i < 100000; i++) {\r\n            isProtobufClass2(HelloRequest.class);\r\n        }\r\n        System.out.println(""isProtobufClass2 cost="" + (System.currentTimeMillis() - start));\r\n        start = System.currentTimeMillis();\r\n        for (int i = 0; i < 100000; i++) {\r\n            isProtobufClass3(HelloRequest.class);\r\n        }\r\n        System.out.println(""isProtobufClass3 cost="" + (System.currentTimeMillis() - start));\r\n        start = System.currentTimeMillis();\r\n        for (int i = 0; i < 100000; i++) {\r\n            isProtobufClass4(HelloRequest.class);\r\n        }\r\n        System.out.println(""isProtobufClass4 cost="" + (System.currentTimeMillis() - start));\r\n        System.out.println(""####class is pb class end"");\r\n\r\n        System.out.println(""####class is not pb class start"");\r\n        start = System.currentTimeMillis();\r\n        for (int i = 0; i < 100000; i++) {\r\n            isProtobufClass(TripleClientCall.class);\r\n        }\r\n        System.out.println(""isProtobufClass cost="" + (System.currentTimeMillis() - start));\r\n        start = System.currentTimeMillis();\r\n        for (int i = 0; i < 100000; i++) {\r\n            isProtobufClass2(TripleClientCall.class);\r\n        }\r\n        System.out.println(""isProtobufClass2 cost="" + (System.currentTimeMillis() - start));\r\n        start = System.currentTimeMillis();\r\n        for (int i = 0; i < 100000; i++) {\r\n            isProtobufClass3(TripleClientCall.class);\r\n        }\r\n        System.out.println(""isProtobufClass3 cost="" + (System.currentTimeMillis() - start));\r\n        start = System.currentTimeMillis();\r\n        for (int i = 0; i < 100000; i++) {\r\n            isProtobufClass4(TripleClientCall.class);\r\n        }\r\n        System.out.println(""isProtobufClass4 cost="" + (System.currentTimeMillis() - start));\r\n        System.out.println(""####class is not pb class end"");\r\n    }\r\n\r\n\r\n    public static boolean isProtobufClass(Class<?> clazz) {\r\n        while (clazz != Object.class && clazz != null) {\r\n            Class<?>[] interfaces = clazz.getInterfaces();\r\n            if (interfaces.length > 0) {\r\n                for (Class<?> clazzInterface : interfaces) {\r\n                    if (PROTOBUF_MESSAGE_CLASS_NAME.equalsIgnoreCase(clazzInterface.getName())) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            clazz = clazz.getSuperclass();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public static boolean isProtobufClass2(Class<?> clazz) {\r\n        try {\r\n            //pb class must deserilizable by parseFrom(byte[]) method\r\n            HelloRequest.class.getDeclaredMethod(""parseFrom"", byte[].class);\r\n        } catch (Exception e) {\r\n            return false;\r\n        }\r\n        while (clazz != Object.class && clazz != null) {\r\n            Class<?>[] interfaces = clazz.getInterfaces();\r\n            if (interfaces.length > 0) {\r\n                for (Class<?> clazzInterface : interfaces) {\r\n                    if (PROTOBUF_MESSAGE_CLASS_NAME.equalsIgnoreCase(clazzInterface.getName())) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            clazz = clazz.getSuperclass();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public static boolean isProtobufClass3(Class<?> pojoClazz) {\r\n        try {\r\n            Class<?> protobufBaseClass = Class.forName(PROTOBUF_MESSAGE_CLASS_NAME);\r\n            return protobufBaseClass.isAssignableFrom(pojoClazz);\r\n        } catch (ClassNotFoundException | NoClassDefFoundError e) {\r\n            // If sink does not have protobuf in classpath then it cannot be protobuf\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static boolean isProtobufClass4(Class<?> pojoClazz) {\r\n        return Message.class.isAssignableFrom(pojoClazz);\r\n    }\r\n}\r\n`\r\ntest result\r\n`####class is pb class start\r\nisProtobufClass cost=35\r\nisProtobufClass2 cost=74\r\nisProtobufClass3 cost=55\r\nisProtobufClass4 cost=4\r\n####class is pb class end\r\n####class is not pb class start\r\nisProtobufClass cost=11\r\nisProtobufClass2 cost=46\r\nisProtobufClass3 cost=55\r\nisProtobufClass4 cost=4\r\n####class is not pb class end`\r\n\r\nYou can see that even if the isProtobuf method is called 10W times, the implementation time of all methods is not more than 100ms, and the performance is isProtobufClass4>isProtobufClass>isProtobufClass2>isProtobufClass3; I personally think that the current implementation isProtobufClass has little effect on the startup speed', 'commenter': 'SpringStudent'}, {'comment': 'There is a better implementation:\r\n1. Use Dubbo’s Classloader in Dubbo’s tool class in advance to try to load the class name of Protobuf Message to obtain whether protobuf exists and the corresponding `Class` object\r\n2. When judgment is needed, judge in advance whether protobuf exists. If it exists, use `Class` to directly judge `isAssignableFrom`.', 'commenter': 'AlbumenJ'}, {'comment': ""I think I understand what you say, and just to make sure, if can't load Protobuf Message class, the isProtobuf method can directly return false. After all, if you can't get Protobuf Message, you're not relying on protobuf at all. No protobuf Class exists."", 'commenter': 'SpringStudent'}, {'comment': ""> if can't load Protobuf Message class, the isProtobuf method can directly return false.\r\n\r\nYes"", 'commenter': 'AlbumenJ'}]"
13155,dubbo-rpc/dubbo-rpc-triple/src/test/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocolTest.java,"@@ -45,6 +43,19 @@
 
 class TripleProtocolTest {
 
+    @Test
+    void testPbMethodOverride()throws Exception{","[{'comment': 'The test should not be here, I think the test constructor ReflectionServiceDescriptor is better', 'commenter': 'EarthChen'}, {'comment': ""> The test should not be here, I think the test constructor ReflectionServiceDescriptor is better\r\n\r\nIn beginning i want to write test case in dubbo-common/ReflectionServiceDescriptorTest.java,but the project which contains ReflectionServiceDescriptor.java code did't have protobuf dependencies,So I cannot add pb class for this unit test.Whether it is necessary add protobuf denpendices to dubbo-common pom.xml."", 'commenter': 'SpringStudent'}, {'comment': '`scope=test` can solve this problem', 'commenter': 'EarthChen'}, {'comment': 'i fix it', 'commenter': 'SpringStudent'}]"
13155,dubbo-common/src/main/java/org/apache/dubbo/common/utils/ProtobufUtils.java,"@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.utils;
+
+import static org.apache.dubbo.common.constants.CommonConstants.PROTOBUF_MESSAGE_CLASS_NAME;
+
+public class ProtobufUtils {
+
+    private static Class<?> protobufClss;
+
+    private ProtobufUtils() {
+    }
+
+    static {
+        try {
+            protobufClss = ClassUtils.forNameWithThreadContextClassLoader(PROTOBUF_MESSAGE_CLASS_NAME);","[{'comment': ""With Dubbo's classloader(`ProtobufUtils.class.getClassLoader()`), not TCCL.\r\n\r\nClass load from Triple protocol will use the classloader which also load Triple protocol itself. "", 'commenter': 'AlbumenJ'}]"
13155,dubbo-common/src/main/java/org/apache/dubbo/common/utils/ProtobufUtils.java,"@@ -0,0 +1,42 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.common.utils;
+
+import static org.apache.dubbo.common.constants.CommonConstants.PROTOBUF_MESSAGE_CLASS_NAME;
+
+public class ProtobufUtils {
+
+    private static Class<?> protobufClss;
+
+    private ProtobufUtils() {
+    }
+
+    static {
+        try {
+            protobufClss = ClassUtils.forName(PROTOBUF_MESSAGE_CLASS_NAME, ProtobufUtils.class.getClassLoader());
+        } catch (Throwable t) {
+            //do nothing","[{'comment': ""Use info log to log out that protobuf's dependency is absent."", 'commenter': 'AlbumenJ'}, {'comment': 'Others LGTM', 'commenter': 'AlbumenJ'}, {'comment': 'i fix it', 'commenter': 'SpringStudent'}]"
13171,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java,"@@ -102,15 +102,7 @@
 import static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;
 import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_CLASS_NOT_FOUND;
 import static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_PARAMETER_FORMAT_ERROR;
-import static org.apache.dubbo.common.constants.RegistryConstants.DEFAULT_REGISTER_MODE_ALL;
-import static org.apache.dubbo.common.constants.RegistryConstants.DEFAULT_REGISTER_MODE_INSTANCE;
-import static org.apache.dubbo.common.constants.RegistryConstants.DEFAULT_REGISTER_MODE_INTERFACE;
-import static org.apache.dubbo.common.constants.RegistryConstants.DUBBO_REGISTER_MODE_DEFAULT_KEY;
-import static org.apache.dubbo.common.constants.RegistryConstants.REGISTER_MODE_KEY;
-import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_KEY;
-import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_PROTOCOL;
-import static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_TYPE_KEY;
-import static org.apache.dubbo.common.constants.RegistryConstants.SERVICE_REGISTRY_PROTOCOL;
+import static org.apache.dubbo.common.constants.RegistryConstants.*;","[{'comment': 'Prevent use wildcard import', 'commenter': 'AlbumenJ'}]"
13172,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistryDirectory.java,"@@ -339,9 +339,7 @@ private void refreshInvoker(List<URL> invokerUrls) {
             ""Registry type: instance. "" +
             ""Service Key: "" + getConsumerUrl().getServiceKey() + "". "" +
             ""Urls Size : "" + invokerUrls.size() + "". "" +
-            ""Invokers Size : "" + getInvokers().size() + "". "" +
-            ""Available Size: "" + getValidInvokers().size() + "". "" +
-            ""Available Invokers : "" + joinValidInvokerAddresses());","[{'comment': 'Why remove these lines?', 'commenter': 'AlbumenJ'}, {'comment': 'I will fix it.', 'commenter': 'finefuture'}, {'comment': 'Recovered, For example:\r\n![image](https://github.com/apache/dubbo/assets/18413695/d17caaf8-152d-4448-a5d8-55329e9a6dd5)\r\n', 'commenter': 'finefuture'}]"
13175,dubbo-plugin/dubbo-reactive/src/test/java/org/apache/dubbo/reactive/CreatObserverAdapter.java,"@@ -0,0 +1,51 @@
+package org.apache.dubbo.reactive;","[{'comment': 'Please add ASF license header', 'commenter': 'AlbumenJ'}, {'comment': 'You can copy it from other files.', 'commenter': 'AlbumenJ'}]"
13175,dubbo-plugin/dubbo-reactive/src/test/java/org/apache/dubbo/reactive/CreatObserverAdapter.java,"@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.dubbo.reactive;
+
+import org.apache.dubbo.rpc.protocol.tri.observer.ServerCallToObserverAdapter;
+
+import org.mockito.Mockito;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.doAnswer;
+
+public class CreatObserverAdapter {","[{'comment': 'Is `Creat` correct? Maybe `Create`?', 'commenter': 'AlbumenJ'}]"
13214,dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/RpcUtilsTest.java,"@@ -50,6 +50,14 @@ class RpcUtilsTest {
      * regular scenario: async invocation in URL
      * verify: 1. whether invocationId is set correctly, 2. idempotent or not
      */
+    Invoker CreateMockInvoker(URL url){","[{'comment': '```suggestion\r\n    Invoker createMockInvoker(URL url){\r\n```', 'commenter': 'AlbumenJ'}]"
13214,dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/support/RpcUtilsTest.java,"@@ -50,6 +50,14 @@ class RpcUtilsTest {
      * regular scenario: async invocation in URL
      * verify: 1. whether invocationId is set correctly, 2. idempotent or not
      */
+    Invoker createMockInvoker(URL url){
+        Invoker invoker = CreateMockInvoker();
+        given(invoker.getUrl()).willReturn(url);
+        return  invoker;
+    }
+    Invoker CreateMockInvoker(){","[{'comment': '```suggestion\r\n    Invoker createMockInvoker(){\r\n```', 'commenter': 'AlbumenJ'}, {'comment': '\r\nI have replaced all `CreateMockInvoker` with `createMockInvoker`', 'commenter': 'gzhao9'}]"
13227,dubbo-config/pom.xml,"@@ -49,4 +48,16 @@
             <scope>test</scope>
         </dependency>
     </dependencies>
+
+    <profiles>
+        <profile>
+            <id>jdk-version-ge-17</id>
+            <activation>","[{'comment': 'Add release profile to ensure that `dubbo-config-spring6` is compiled when releasing', 'commenter': 'AlbumenJ'}, {'comment': 'Done.', 'commenter': 'oxsean'}]"
13230,dubbo-dependencies/dubbo-dependencies-zookeeper/pom.xml,"@@ -48,6 +48,32 @@
             <groupId>org.apache.zookeeper</groupId>
             <artifactId>zookeeper</artifactId>
             <version>${zookeeper_version}</version>
+            <exclusions>
+                <exclusion>
+                    <artifactId>slf4j-log4j12</artifactId>
+                    <groupId>org.slf4j</groupId>
+                </exclusion>
+                <exclusion>
+                    <artifactId>log4j</artifactId>
+                    <groupId>log4j</groupId>
+                </exclusion>
+                <exclusion>
+                    <artifactId>spotbugs-annotations</artifactId>
+                    <groupId>com.github.spotbugs</groupId>
+                </exclusion>
+                <exclusion>
+                    <artifactId>audience-annotations</artifactId>
+                    <groupId>org.apache.yetus</groupId>
+                </exclusion>
+                <exclusion>
+                    <artifactId>jline</artifactId>
+                    <groupId>jline</groupId>
+                </exclusion>
+                <exclusion>
+                    <artifactId>*</artifactId>
+                    <groupId>io.netty</groupId>
+                </exclusion>
+            </exclusions>","[{'comment': 'I think you need to fix `dubbo-samples` first.', 'commenter': 'AlbumenJ'}, {'comment': 'Done, but need merge https://github.com/apache/dubbo-samples/pull/1010 first to take effect.', 'commenter': 'oxsean'}]"
13238,dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java,"@@ -207,4 +207,8 @@ private String getMetadataStandalone(BaseMetadataIdentifier metadataIdentifier)
         }
     }
 
+    @Override
+    public boolean registerServiceAppMapping(String serviceInterface, String defaultMappingGroup, String newConfigContent, Object ticket) {
+        throw new UnsupportedOperationException(""Redis metadataReport implementation does not support registerServiceAppMapping() method."");","[{'comment': 'To fix https://github.com/apache/dubbo/issues/12627, you should use jedis to set content here.', 'commenter': 'AlbumenJ'}, {'comment': 'PTAL', 'commenter': 'Nortyr'}]"
13238,dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java,"@@ -61,12 +77,34 @@ public class RedisMetadataReport extends AbstractMetadataReport {
     private Set<HostAndPort> jedisClusterNodes;
     private int timeout;
     private String password;
+    private final String root;
+    private MD5Utils md5Utils = new MD5Utils();
+    protected ConcurrentMap<String, MappingDataListener> listenerMap = new ConcurrentHashMap<>();
+    private String luaScript=""local key = KEYS[1];\n"" +
+        ""local field = ARGV[1];\n"" +
+        ""local oldValue = ARGV[2];\n"" +
+        ""local newValue = ARGV[3];\n"" +
+        ""local channel = ARGV[4];\n"" +
+        ""local valueExists = redis.call(\""HEXISTS\"", key, field);\n"" +
+        ""if valueExists == 0 then\n"" +
+        ""    redis.call(\""HSET\"", key, field, newValue);\n"" +","[{'comment': 'Starting from version 2.2, redis provides `WATCH` to help implement [cas behavior](https://redis.io/docs/interact/transactions/#cas) in case race conditions may occur.', 'commenter': 'Linchen-Xu'}, {'comment': '请问下JedisCluster中无法使用watch有什么好的建议呢？\r\n如果不建议使用lua脚本的话，要不然使用setnx实现一个简易的锁？', 'commenter': 'Nortyr'}, {'comment': '之前有人[讨论](https://groups.google.com/g/jedis_redis/c/Z4-0065UFkg)过在JedisCluster上如何做transaction，基本思路是从sluter里拿到对应key所在的Jedis，然后在上面开transaction，只不过这样做的话会稍微麻烦点。\r\n我觉得用什么方式都无所谓，只要能实现目标就行。\r\n\r\n从我的角度上看的话，毕竟官方提供了watch作为保险措施，能加最好还是加一下，免得为以后挖坑。', 'commenter': 'Linchen-Xu'}, {'comment': '不错的建议，PTAL', 'commenter': 'Nortyr'}, {'comment': '麻烦再改一下watch那里的逻辑，其他部分我觉得ok。', 'commenter': 'Linchen-Xu'}, {'comment': '已改，之前完全没有注意过UNWATCH，十分感谢', 'commenter': 'Nortyr'}]"
13238,dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java,"@@ -207,4 +245,242 @@ private String getMetadataStandalone(BaseMetadataIdentifier metadataIdentifier)
         }
     }
 
+    @Override
+    public boolean registerServiceAppMapping(String serviceInterface, String defaultMappingGroup, String newConfigContent, Object ticket) {
+        try {
+            if (null!= ticket && !(ticket instanceof String)) {
+                throw new IllegalArgumentException(""zookeeper publishConfigCas requires stat type ticket"");
+            }
+            String pathKey = buildMappingKey(defaultMappingGroup);
+
+            return storeMapping(pathKey, serviceInterface, newConfigContent,(String)ticket);
+        } catch (Exception e) {
+            logger.warn(REGISTRY_ZOOKEEPER_EXCEPTION, """", """", ""redis publishConfigCas failed."", e);
+            return false;
+        }
+    }
+
+
+    private boolean storeMapping(String key, String field, String value,String ticket) {
+        if (pool != null) {
+            return storeMappingStandalone(key, field, value, ticket);
+        } else {
+            return storeMappingInCluster(key, field, value, ticket);
+        }
+    }
+
+    private boolean storeMappingInCluster(String key, String field, String value,String ticket) {
+        try (JedisCluster jedisCluster = new JedisCluster(jedisClusterNodes, timeout, timeout, 2, password, new GenericObjectPoolConfig<>())) {
+            Object result =jedisCluster.eval(luaScript, 1, key, field, ticket==null?"""":ticket, value,buildPubSubKey(field));
+            return null==result;
+        } catch (Throwable e) {
+            String msg = ""Failed to put "" + key + "":"" + field + "" to redis "" + value + "", cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+    }
+
+    private boolean storeMappingStandalone(String key, String field, String value,String ticket) {
+        try (Jedis jedis = pool.getResource()) {
+            Object result = jedis.eval(luaScript, 1, key, field, ticket==null?"""":ticket, value,buildPubSubKey(field));
+            return null==result;
+        } catch (Throwable e) {
+            String msg = ""Failed to put "" + key + "":"" + field + "" to redis "" + value + "", cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+    }
+
+    private String buildMappingKey(String defaultMappingGroup) {
+        return this.root + GROUP_CHAR_SEPARATOR + defaultMappingGroup;
+    }
+
+    private String buildPubSubKey(String serviceKey) {
+        return buildMappingKey(DEFAULT_MAPPING_GROUP) + GROUP_CHAR_SEPARATOR + serviceKey;
+    }
+
+    @Override
+    public ConfigItem getConfigItem(String serviceKey, String group) {
+        String key = buildMappingKey(group);
+        String content = getMappingData(key, serviceKey);
+
+        return new ConfigItem(content, content);
+    }
+
+    private String getMappingData(String key, String field) {
+        if (pool != null) {
+            return getMappingDataStandalone(key, field);
+        } else {
+            return getMappingDataInCluster(key, field);
+        }
+    }
+
+    private String getMappingDataInCluster(String key, String field) {
+        try (JedisCluster jedisCluster = new JedisCluster(jedisClusterNodes, timeout, timeout, 2, password, new GenericObjectPoolConfig<>())) {
+            return jedisCluster.hget(key, field);
+        } catch (Throwable e) {
+            String msg = ""Failed to get "" + key + "":"" + field + "" from redis cluster , cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+    }
+
+    private String getMappingDataStandalone(String key, String field) {
+        try (Jedis jedis = pool.getResource()) {
+            return jedis.hget(key, field);
+        } catch (Throwable e) {
+            String msg = ""Failed to get "" + key + "":"" + field + "" from redis , cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+    }
+
+    @Override
+    public void removeServiceAppMappingListener(String serviceKey, MappingListener listener) {
+        if (null != listenerMap.get(serviceKey)) {
+            MappingDataListener mappingDataListener=listenerMap.get(serviceKey);
+            NotifySub notifySub=mappingDataListener.getNotifySub();
+            notifySub.removeListener(listener);
+            if(notifySub.isEmpty()){
+                mappingDataListener.shutdown();
+                listenerMap.remove(serviceKey,mappingDataListener);
+            }
+        }
+    }
+
+    @Override
+    public Set<String> getServiceAppMapping(String serviceKey, MappingListener listener, URL url) {
+        if (null == listenerMap.get(serviceKey)) {
+            NotifySub notifySub = new NotifySub(serviceKey);
+            notifySub.addListener(listener);
+            MappingDataListener dataListener = new MappingDataListener(buildPubSubKey(serviceKey), notifySub);
+            ConcurrentHashMapUtils.computeIfAbsent(listenerMap, serviceKey
+                , k -> dataListener);
+            dataListener.start();
+        }else{
+            listenerMap.get(serviceKey).getNotifySub().addListener(listener);
+        }
+        return this.getServiceAppMapping(serviceKey, url);
+    }
+
+    @Override
+    public Set<String> getServiceAppMapping(String serviceKey, URL url) {
+        String key = buildMappingKey(DEFAULT_MAPPING_GROUP);
+        return getAppNames(getMappingData(key, serviceKey));
+
+    }
+
+    @Override
+    public MetadataInfo getAppMetadata(SubscriberMetadataIdentifier identifier, Map<String, String> instanceMetadata) {
+        String content = this.getMetadata(identifier);
+        return JsonUtils.toJavaObject(content, MetadataInfo.class);
+    }
+
+    @Override
+    public void publishAppMetadata(SubscriberMetadataIdentifier identifier, MetadataInfo metadataInfo) {
+        this.storeMetadata(identifier, metadataInfo.getContent());
+    }
+
+    @Override
+    public void unPublishAppMetadata(SubscriberMetadataIdentifier identifier, MetadataInfo metadataInfo) {
+        this.deleteMetadata(identifier);
+    }
+
+    private static class NotifySub extends JedisPubSub {
+
+        private String serviceKey;
+        private Set<MappingListener> listeners = new HashSet<>();
+
+        public NotifySub(String serviceKey) {
+            this.serviceKey = serviceKey;
+        }
+
+        public void addListener(MappingListener listener) {
+            this.listeners.add(listener);
+        }
+
+        public void removeListener(MappingListener listener) {
+            this.listeners.remove(listener);
+        }
+
+        public Boolean isEmpty(){
+            return this.listeners.isEmpty();
+        }
+
+        @Override
+        public void onMessage(String key, String msg) {
+            logger.info(""sub from redis "" + key + "" message:"" + msg);
+            MappingChangedEvent mappingChangedEvent = new MappingChangedEvent(serviceKey, getAppNames(msg));
+            if(!listeners.isEmpty()){
+                listeners.forEach(listener -> listener.onEvent(mappingChangedEvent));
+            }
+
+        }
+
+        @Override
+        public void onPMessage(String pattern, String key, String msg) {
+            onMessage(key, msg);
+        }
+
+        @Override
+        public void onPSubscribe(String pattern, int subscribedChannels) {
+            super.onPSubscribe(pattern, subscribedChannels);
+        }
+    }
+
+    private class MappingDataListener extends Thread {
+
+        private String path;
+
+        private volatile Jedis currentClient;","[{'comment': 'This variable is assigned but never accessed.', 'commenter': 'Linchen-Xu'}]"
13238,dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java,"@@ -61,12 +77,34 @@ public class RedisMetadataReport extends AbstractMetadataReport {
     private Set<HostAndPort> jedisClusterNodes;
     private int timeout;
     private String password;
+    private final String root;
+    private MD5Utils md5Utils = new MD5Utils();","[{'comment': 'This is never used.', 'commenter': 'Linchen-Xu'}]"
13238,dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java,"@@ -207,4 +226,258 @@ private String getMetadataStandalone(BaseMetadataIdentifier metadataIdentifier)
         }
     }
 
+    @Override
+    public boolean registerServiceAppMapping(String serviceInterface, String defaultMappingGroup, String newConfigContent, Object ticket) {
+        try {
+            if (null!= ticket && !(ticket instanceof String)) {
+                throw new IllegalArgumentException(""zookeeper publishConfigCas requires stat type ticket"");
+            }
+            String pathKey = buildMappingKey(defaultMappingGroup);
+
+            return storeMapping(pathKey, serviceInterface, newConfigContent,(String)ticket);
+        } catch (Exception e) {
+            logger.warn(REGISTRY_ZOOKEEPER_EXCEPTION, """", """", ""redis publishConfigCas failed."", e);
+            return false;
+        }
+    }
+
+
+    private boolean storeMapping(String key, String field, String value,String ticket) {
+        if (pool != null) {
+            return storeMappingStandalone(key, field, value, ticket);
+        } else {
+            return storeMappingInCluster(key, field, value, ticket);
+        }
+    }
+
+    private boolean storeMappingInCluster(String key, String field, String value,String ticket) {
+        try (JedisCluster jedisCluster = new JedisCluster(jedisClusterNodes, timeout, timeout, 2, password, new GenericObjectPoolConfig<>())) {
+            Jedis jedis=jedisCluster.getConnectionFromSlot(JedisClusterCRC16.getSlot(key));
+            jedis.watch(key);
+            String oldValue = jedis.get(key);
+            if (null==oldValue||null==ticket||oldValue.equals(ticket)) {
+                Transaction transaction = jedis.multi();
+                transaction.hset(key,field,value);
+                List<Object> result=transaction.exec();
+                if(null!=result){
+                    jedisCluster.publish(buildPubSubKey(field),value);
+                    return true;
+                }
+            }
+        } catch (Throwable e) {
+            String msg = ""Failed to put "" + key + "":"" + field + "" to redis "" + value + "", cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+        return false;
+    }
+
+    private boolean storeMappingStandalone(String key, String field, String value,String ticket) {
+        try (Jedis jedis = pool.getResource()) {
+            jedis.watch(key);","[{'comment': 'watch之后需要手动执行[unwatch](https://redis.io/commands/unwatch/)（除非执行过discard或exec）。\r\n建议在try的最后加一行：\r\n```suggestion\r\n            jedis.watch(key);\r\n            ...\r\n                List<Object> result=transaction.exec();\r\n                return null!=result;\r\n            }\r\n            jedis.unwatch();\r\n```', 'commenter': 'Linchen-Xu'}, {'comment': '> watch之后需要手动执行[unwatch](https://redis.io/commands/unwatch/)（除非执行过discard或exec）。 建议在try的最后加一行：\r\n\r\n@Nortyr 麻烦再改下，想了下watch移到里面就没有意义了，还是应该写成watch+判断并执行+unwatch的形式', 'commenter': 'Linchen-Xu'}, {'comment': 'emmm,done\r\n', 'commenter': 'Nortyr'}]"
13238,dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java,"@@ -207,4 +226,261 @@ private String getMetadataStandalone(BaseMetadataIdentifier metadataIdentifier)
         }
     }
 
+    @Override
+    public boolean registerServiceAppMapping(String serviceInterface, String defaultMappingGroup, String newConfigContent, Object ticket) {
+        try {
+            if (null!= ticket && !(ticket instanceof String)) {
+                throw new IllegalArgumentException(""zookeeper publishConfigCas requires stat type ticket"");","[{'comment': 'Should be redis here', 'commenter': 'AlbumenJ'}, {'comment': 'Okay, I will fix it in this link: https://github.com/apache/dubbo/pull/13303. Should I close this PR or that one?', 'commenter': 'Nortyr'}, {'comment': 'Close this one and track in #13303 in the future', 'commenter': 'AlbumenJ'}]"
13246,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/aot/NacosReflectionTypeDescriberRegistrar.java,"@@ -0,0 +1,86 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.registry.nacos.aot;
+
+import org.apache.dubbo.aot.api.MemberCategory;
+import org.apache.dubbo.aot.api.ReflectionTypeDescriberRegistrar;
+import org.apache.dubbo.aot.api.TypeDescriber;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+
+public class NacosReflectionTypeDescriberRegistrar implements ReflectionTypeDescriberRegistrar {
+
+    @Override
+    public List<TypeDescriber> getTypeDescribers() {
+        List<TypeDescriber> typeDescribers = new ArrayList<>();
+        String[] classesWithDeclared = {""com.alibaba.nacos.api.ability.ClientAbilities"", ""com.alibaba.nacos.api.config.ability.ClientConfigAbility"", ""com.alibaba.nacos.api.config.remote.request.AbstractConfigRequest"", ""com.alibaba.nacos.api.config.remote.request.ConfigBatchListenRequest"", ""com.alibaba.nacos.api.config.remote.request.ConfigBatchListenRequest$ConfigListenContext"", ""com.alibaba.nacos.api.config.remote.request.ConfigPublishRequest"", ""com.alibaba.nacos.api.config.remote.request.ConfigQueryRequest"", ""com.alibaba.nacos.api.config.remote.response.ConfigChangeBatchListenResponse"", ""com.alibaba.nacos.api.config.remote.response.ConfigChangeBatchListenResponse$ConfigContext"", ""com.alibaba.nacos.api.config.remote.response.ConfigPublishResponse"", ""com.alibaba.nacos.api.config.remote.response.ConfigQueryResponse"", ""com.alibaba.nacos.api.naming.ability.ClientNamingAbility"", ""com.alibaba.nacos.api.naming.pojo.Instance"", ""com.alibaba.nacos.api.naming.pojo.ServiceInfo"", ""com.alibaba.nacos.api.naming.remote.request.AbstractNamingRequest"", ""com.alibaba.nacos.api.naming.remote.request.InstanceRequest"", ""com.alibaba.nacos.api.naming.remote.request.NotifySubscriberRequest"", ""com.alibaba.nacos.api.naming.remote.request.ServiceQueryRequest"", ""com.alibaba.nacos.api.naming.remote.request.SubscribeServiceRequest"", ""com.alibaba.nacos.api.naming.remote.response.InstanceResponse"", ""com.alibaba.nacos.api.naming.remote.response.NotifySubscriberResponse"", ""com.alibaba.nacos.api.naming.remote.response.QueryServiceResponse"", ""com.alibaba.nacos.api.naming.remote.response.SubscribeServiceResponse"", ""com.alibaba.nacos.api.remote.ability.ClientRemoteAbility"", ""com.alibaba.nacos.api.remote.request.ConnectionSetupRequest"", ""com.alibaba.nacos.api.remote.request.HealthCheckRequest"", ""com.alibaba.nacos.api.remote.request.InternalRequest"", ""com.alibaba.nacos.api.remote.request.Request"", ""com.alibaba.nacos.api.remote.request.ServerCheckRequest"", ""com.alibaba.nacos.api.remote.request.ServerRequest"", ""com.alibaba.nacos.api.remote.response.HealthCheckResponse"", ""com.alibaba.nacos.api.remote.response.Response"", ""com.alibaba.nacos.api.remote.response.ServerCheckResponse"", ""com.alibaba.nacos.common.remote.TlsConfig"", ""com.alibaba.nacos.common.remote.client.RpcClientTlsConfig""};","[{'comment': 'We need to introduce class dependencies directly in order to prevent incompatibilities from going undetected once nacos is upgraded.', 'commenter': 'CrazyHZM'}, {'comment': 'Fixed in the latest commit.', 'commenter': 'chaicho'}]"
13250,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/filter/DubboContainerResponseContextImpl.java,"@@ -124,9 +124,8 @@ public Type getEntityType() {
 
     @Override
     public void setEntity(Object entity) {
-        //if (entity != null) logger.info(""*** setEntity(Object) "" + entity.toString());
         if (entity != null && jaxrsResponse.getEntity() != null) {
-            logger.info(""Dubbo container response context filter set entity ,before entity is: "" + jaxrsResponse.getEntity() + ""and after entity is: "" + entity);
+            logger.debug(""Dubbo container response context filter set entity ,before entity is: "" + jaxrsResponse.getEntity() + ""and after entity is: "" + entity);","[{'comment': 'Check if debug level is enabled first', 'commenter': 'AlbumenJ'}]"
13267,dubbo-spring-boot/dubbo-spring-boot-compatible/autoconfigure/src/test/java/org/apache/dubbo/spring/boot/context/event/AwaitingNonWebApplicationListenerTest.java,"@@ -20,10 +20,12 @@
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 
 /**
  * {@link AwaitingNonWebApplicationListener} Test
  */
+@Ignore","[{'comment': 'Why ignore this?', 'commenter': 'AlbumenJ'}, {'comment': '这个类里的测试方法全都被注释掉了，跑TestSuite的时候会报错No runnable methods，加Ignore是为了不影响TestSuite正常运行', 'commenter': 'Linchen-Xu'}]"
13273,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java,"@@ -68,7 +68,10 @@ public synchronized void notify(Object rawAddresses) {
 
         // more than 10 calls && next execute time is in the future
         boolean delay = shouldDelay.get() && delta < 0;
-        if (delay) {
+        // when the scheduler is shutdown, no notification is sent
+        if (scheduler.isShutdown()) {
+            return;","[{'comment': 'Seems we shoud log something here.', 'commenter': 'AlbumenJ'}, {'comment': 'get', 'commenter': 'stone-98'}]"
13273,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java,"@@ -68,7 +69,13 @@ public synchronized void notify(Object rawAddresses) {
 
         // more than 10 calls && next execute time is in the future
         boolean delay = shouldDelay.get() && delta < 0;
-        if (delay) {
+        // when the scheduler is shutdown, no notification is sent
+        if (scheduler.isShutdown()) {
+            if (logger.isWarnEnabled()) {
+                logger.warn(COMMON_FAILED_NOTIFY_EVENT, """", """", ""Notification scheduler is off, no notifications are sent."");","[{'comment': 'Also log the registry url', 'commenter': 'AlbumenJ'}, {'comment': 'get.', 'commenter': 'stone-98'}]"
13303,dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java,"@@ -209,4 +228,266 @@ private String getMetadataStandalone(BaseMetadataIdentifier metadataIdentifier)
             throw new RpcException(msg, e);
         }
     }
+
+    @Override
+    public boolean registerServiceAppMapping(","[{'comment': 'Store class and application names using Redis hashes\r\nkey: dubbo:mapping\r\nfield: class\r\nvalue: application_names', 'commenter': 'Nortyr'}]"
13303,dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java,"@@ -209,4 +228,266 @@ private String getMetadataStandalone(BaseMetadataIdentifier metadataIdentifier)
             throw new RpcException(msg, e);
         }
     }
+
+    @Override
+    public boolean registerServiceAppMapping(
+            String serviceInterface, String defaultMappingGroup, String newConfigContent, Object ticket) {
+        try {
+            if (null != ticket && !(ticket instanceof String)) {
+                throw new IllegalArgumentException(""redis publishConfigCas requires stat type ticket"");
+            }
+            String pathKey = buildMappingKey(defaultMappingGroup);
+
+            return storeMapping(pathKey, serviceInterface, newConfigContent, (String) ticket);
+        } catch (Exception e) {
+            logger.warn(TRANSPORT_FAILED_RESPONSE, """", """", ""redis publishConfigCas failed."", e);
+            return false;
+        }
+    }
+
+    private boolean storeMapping(String key, String field, String value, String ticket) {
+        if (pool != null) {
+            return storeMappingStandalone(key, field, value, ticket);
+        } else {
+            return storeMappingInCluster(key, field, value, ticket);
+        }
+    }
+
+    private boolean storeMappingInCluster(String key, String field, String value, String ticket) {
+        try (JedisCluster jedisCluster =
+                new JedisCluster(jedisClusterNodes, timeout, timeout, 2, password, new GenericObjectPoolConfig<>())) {
+            Jedis jedis = jedisCluster.getConnectionFromSlot(JedisClusterCRC16.getSlot(key));
+            jedis.watch(key);
+            String oldValue = jedis.hget(key, field);
+            if (null == oldValue || null == ticket || oldValue.equals(ticket)) {
+                Transaction transaction = jedis.multi();
+                transaction.hset(key, field, value);
+                List<Object> result = transaction.exec();
+                if (null != result) {
+                    jedisCluster.publish(buildPubSubKey(), field);
+                    return true;
+                }
+            } else {
+                jedis.unwatch();
+            }
+        } catch (Throwable e) {
+            String msg = ""Failed to put "" + key + "":"" + field + "" to redis "" + value + "", cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+        return false;
+    }
+
+    private boolean storeMappingStandalone(String key, String field, String value, String ticket) {","[{'comment': ""use 'watch' to implement cas"", 'commenter': 'Nortyr'}]"
13303,dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java,"@@ -209,4 +228,266 @@ private String getMetadataStandalone(BaseMetadataIdentifier metadataIdentifier)
             throw new RpcException(msg, e);
         }
     }
+
+    @Override
+    public boolean registerServiceAppMapping(
+            String serviceInterface, String defaultMappingGroup, String newConfigContent, Object ticket) {
+        try {
+            if (null != ticket && !(ticket instanceof String)) {
+                throw new IllegalArgumentException(""redis publishConfigCas requires stat type ticket"");
+            }
+            String pathKey = buildMappingKey(defaultMappingGroup);
+
+            return storeMapping(pathKey, serviceInterface, newConfigContent, (String) ticket);
+        } catch (Exception e) {
+            logger.warn(TRANSPORT_FAILED_RESPONSE, """", """", ""redis publishConfigCas failed."", e);
+            return false;
+        }
+    }
+
+    private boolean storeMapping(String key, String field, String value, String ticket) {
+        if (pool != null) {
+            return storeMappingStandalone(key, field, value, ticket);
+        } else {
+            return storeMappingInCluster(key, field, value, ticket);
+        }
+    }
+
+    private boolean storeMappingInCluster(String key, String field, String value, String ticket) {","[{'comment': 'Inspired by the link: https://groups.google.com/g/jedis_redis/c/Z4-0065UFkg\r\n', 'commenter': 'Nortyr'}]"
13303,dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java,"@@ -209,4 +228,266 @@ private String getMetadataStandalone(BaseMetadataIdentifier metadataIdentifier)
             throw new RpcException(msg, e);
         }
     }
+
+    @Override
+    public boolean registerServiceAppMapping(
+            String serviceInterface, String defaultMappingGroup, String newConfigContent, Object ticket) {
+        try {
+            if (null != ticket && !(ticket instanceof String)) {
+                throw new IllegalArgumentException(""redis publishConfigCas requires stat type ticket"");
+            }
+            String pathKey = buildMappingKey(defaultMappingGroup);
+
+            return storeMapping(pathKey, serviceInterface, newConfigContent, (String) ticket);
+        } catch (Exception e) {
+            logger.warn(TRANSPORT_FAILED_RESPONSE, """", """", ""redis publishConfigCas failed."", e);
+            return false;
+        }
+    }
+
+    private boolean storeMapping(String key, String field, String value, String ticket) {
+        if (pool != null) {
+            return storeMappingStandalone(key, field, value, ticket);
+        } else {
+            return storeMappingInCluster(key, field, value, ticket);
+        }
+    }
+
+    private boolean storeMappingInCluster(String key, String field, String value, String ticket) {
+        try (JedisCluster jedisCluster =
+                new JedisCluster(jedisClusterNodes, timeout, timeout, 2, password, new GenericObjectPoolConfig<>())) {
+            Jedis jedis = jedisCluster.getConnectionFromSlot(JedisClusterCRC16.getSlot(key));
+            jedis.watch(key);
+            String oldValue = jedis.hget(key, field);
+            if (null == oldValue || null == ticket || oldValue.equals(ticket)) {
+                Transaction transaction = jedis.multi();
+                transaction.hset(key, field, value);
+                List<Object> result = transaction.exec();
+                if (null != result) {
+                    jedisCluster.publish(buildPubSubKey(), field);
+                    return true;
+                }
+            } else {
+                jedis.unwatch();
+            }
+        } catch (Throwable e) {
+            String msg = ""Failed to put "" + key + "":"" + field + "" to redis "" + value + "", cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+        return false;
+    }
+
+    private boolean storeMappingStandalone(String key, String field, String value, String ticket) {
+        try (Jedis jedis = pool.getResource()) {
+            jedis.watch(key);
+            String oldValue = jedis.hget(key, field);
+            if (null == oldValue || null == ticket || oldValue.equals(ticket)) {
+                Transaction transaction = jedis.multi();
+                transaction.hset(key, field, value);
+                transaction.publish(buildPubSubKey(), field);
+                List<Object> result = transaction.exec();
+                return null != result;
+            }
+            jedis.unwatch();
+        } catch (Throwable e) {
+            String msg = ""Failed to put "" + key + "":"" + field + "" to redis "" + value + "", cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+        return false;
+    }
+
+    private String buildMappingKey(String defaultMappingGroup) {
+        return this.root + GROUP_CHAR_SEPARATOR + defaultMappingGroup;
+    }
+
+    private String buildPubSubKey() {
+        return buildMappingKey(DEFAULT_MAPPING_GROUP) + GROUP_CHAR_SEPARATOR + QUEUES_KEY;
+    }
+
+    @Override
+    public ConfigItem getConfigItem(String serviceKey, String group) {
+        String key = buildMappingKey(group);
+        String content = getMappingData(key, serviceKey);
+
+        return new ConfigItem(content, content);
+    }
+
+    private String getMappingData(String key, String field) {
+        if (pool != null) {
+            return getMappingDataStandalone(key, field);
+        } else {
+            return getMappingDataInCluster(key, field);
+        }
+    }
+
+    private String getMappingDataInCluster(String key, String field) {
+        try (JedisCluster jedisCluster =
+                new JedisCluster(jedisClusterNodes, timeout, timeout, 2, password, new GenericObjectPoolConfig<>())) {
+            return jedisCluster.hget(key, field);
+        } catch (Throwable e) {
+            String msg = ""Failed to get "" + key + "":"" + field + "" from redis cluster , cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+    }
+
+    private String getMappingDataStandalone(String key, String field) {
+        try (Jedis jedis = pool.getResource()) {
+            return jedis.hget(key, field);
+        } catch (Throwable e) {
+            String msg = ""Failed to get "" + key + "":"" + field + "" from redis , cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+    }
+
+    @Override
+    public void removeServiceAppMappingListener(String serviceKey, MappingListener listener) {
+        MappingDataListener mappingDataListener = mappingDataListenerMap.get(buildPubSubKey());
+        if (null != mappingDataListener) {
+            NotifySub notifySub = mappingDataListener.getNotifySub();
+            notifySub.removeListener(serviceKey, listener);
+            if (notifySub.isEmpty()) {
+                mappingDataListener.shutdown();
+            }
+        }
+    }
+
+    @Override
+    public Set<String> getServiceAppMapping(String serviceKey, MappingListener listener, URL url) {
+        MappingDataListener mappingDataListener =","[{'comment': 'start one thread to subscribe dubbo:mapping:queues Whenever any server changes occur, it will publish serviceKey,then RedisMetadataReport.NotifySub#onMessage will retrieve the application names again.', 'commenter': 'Nortyr'}]"
13303,dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java,"@@ -209,4 +228,266 @@ private String getMetadataStandalone(BaseMetadataIdentifier metadataIdentifier)
             throw new RpcException(msg, e);
         }
     }
+
+    @Override
+    public boolean registerServiceAppMapping(
+            String serviceInterface, String defaultMappingGroup, String newConfigContent, Object ticket) {
+        try {
+            if (null != ticket && !(ticket instanceof String)) {
+                throw new IllegalArgumentException(""redis publishConfigCas requires stat type ticket"");
+            }
+            String pathKey = buildMappingKey(defaultMappingGroup);
+
+            return storeMapping(pathKey, serviceInterface, newConfigContent, (String) ticket);
+        } catch (Exception e) {
+            logger.warn(TRANSPORT_FAILED_RESPONSE, """", """", ""redis publishConfigCas failed."", e);
+            return false;
+        }
+    }
+
+    private boolean storeMapping(String key, String field, String value, String ticket) {
+        if (pool != null) {
+            return storeMappingStandalone(key, field, value, ticket);
+        } else {
+            return storeMappingInCluster(key, field, value, ticket);
+        }
+    }
+
+    private boolean storeMappingInCluster(String key, String field, String value, String ticket) {
+        try (JedisCluster jedisCluster =
+                new JedisCluster(jedisClusterNodes, timeout, timeout, 2, password, new GenericObjectPoolConfig<>())) {
+            Jedis jedis = jedisCluster.getConnectionFromSlot(JedisClusterCRC16.getSlot(key));
+            jedis.watch(key);
+            String oldValue = jedis.hget(key, field);
+            if (null == oldValue || null == ticket || oldValue.equals(ticket)) {
+                Transaction transaction = jedis.multi();
+                transaction.hset(key, field, value);
+                List<Object> result = transaction.exec();
+                if (null != result) {
+                    jedisCluster.publish(buildPubSubKey(), field);
+                    return true;
+                }
+            } else {
+                jedis.unwatch();
+            }
+        } catch (Throwable e) {
+            String msg = ""Failed to put "" + key + "":"" + field + "" to redis "" + value + "", cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+        return false;
+    }
+
+    private boolean storeMappingStandalone(String key, String field, String value, String ticket) {
+        try (Jedis jedis = pool.getResource()) {
+            jedis.watch(key);
+            String oldValue = jedis.hget(key, field);
+            if (null == oldValue || null == ticket || oldValue.equals(ticket)) {
+                Transaction transaction = jedis.multi();
+                transaction.hset(key, field, value);
+                transaction.publish(buildPubSubKey(), field);
+                List<Object> result = transaction.exec();
+                return null != result;
+            }
+            jedis.unwatch();
+        } catch (Throwable e) {
+            String msg = ""Failed to put "" + key + "":"" + field + "" to redis "" + value + "", cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+        return false;
+    }
+
+    private String buildMappingKey(String defaultMappingGroup) {
+        return this.root + GROUP_CHAR_SEPARATOR + defaultMappingGroup;
+    }
+
+    private String buildPubSubKey() {
+        return buildMappingKey(DEFAULT_MAPPING_GROUP) + GROUP_CHAR_SEPARATOR + QUEUES_KEY;
+    }
+
+    @Override
+    public ConfigItem getConfigItem(String serviceKey, String group) {
+        String key = buildMappingKey(group);
+        String content = getMappingData(key, serviceKey);
+
+        return new ConfigItem(content, content);
+    }
+
+    private String getMappingData(String key, String field) {
+        if (pool != null) {
+            return getMappingDataStandalone(key, field);
+        } else {
+            return getMappingDataInCluster(key, field);
+        }
+    }
+
+    private String getMappingDataInCluster(String key, String field) {
+        try (JedisCluster jedisCluster =
+                new JedisCluster(jedisClusterNodes, timeout, timeout, 2, password, new GenericObjectPoolConfig<>())) {
+            return jedisCluster.hget(key, field);
+        } catch (Throwable e) {
+            String msg = ""Failed to get "" + key + "":"" + field + "" from redis cluster , cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+    }
+
+    private String getMappingDataStandalone(String key, String field) {
+        try (Jedis jedis = pool.getResource()) {
+            return jedis.hget(key, field);
+        } catch (Throwable e) {
+            String msg = ""Failed to get "" + key + "":"" + field + "" from redis , cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+    }
+
+    @Override
+    public void removeServiceAppMappingListener(String serviceKey, MappingListener listener) {
+        MappingDataListener mappingDataListener = mappingDataListenerMap.get(buildPubSubKey());
+        if (null != mappingDataListener) {
+            NotifySub notifySub = mappingDataListener.getNotifySub();
+            notifySub.removeListener(serviceKey, listener);
+            if (notifySub.isEmpty()) {
+                mappingDataListener.shutdown();
+            }
+        }
+    }
+
+    @Override
+    public Set<String> getServiceAppMapping(String serviceKey, MappingListener listener, URL url) {
+        MappingDataListener mappingDataListener =
+                ConcurrentHashMapUtils.computeIfAbsent(mappingDataListenerMap, buildPubSubKey(), k -> {
+                    MappingDataListener dataListener = new MappingDataListener(buildPubSubKey());
+                    dataListener.start();
+                    return dataListener;
+                });
+        mappingDataListener.getNotifySub().addListener(serviceKey, listener);
+        return this.getServiceAppMapping(serviceKey, url);
+    }
+
+    @Override
+    public Set<String> getServiceAppMapping(String serviceKey, URL url) {
+        String key = buildMappingKey(DEFAULT_MAPPING_GROUP);
+        return getAppNames(getMappingData(key, serviceKey));
+    }
+
+    @Override
+    public MetadataInfo getAppMetadata(SubscriberMetadataIdentifier identifier, Map<String, String> instanceMetadata) {
+        String content = this.getMetadata(identifier);
+        return JsonUtils.toJavaObject(content, MetadataInfo.class);
+    }
+
+    @Override
+    public void publishAppMetadata(SubscriberMetadataIdentifier identifier, MetadataInfo metadataInfo) {
+        this.storeMetadata(identifier, metadataInfo.getContent());
+    }
+
+    @Override
+    public void unPublishAppMetadata(SubscriberMetadataIdentifier identifier, MetadataInfo metadataInfo) {
+        this.deleteMetadata(identifier);
+    }
+
+    // for test
+    public MappingDataListener getMappingDataListener() {
+        return mappingDataListenerMap.get(buildPubSubKey());
+    }
+
+    class NotifySub extends JedisPubSub {
+
+        private final Map<String, Set<MappingListener>> listeners = new ConcurrentHashMap<>();
+
+        public void addListener(String key, MappingListener listener) {
+            Set<MappingListener> listenerSet = listeners.computeIfAbsent(key, k -> new ConcurrentHashSet<>());
+            listenerSet.add(listener);
+        }
+
+        public void removeListener(String serviceKey, MappingListener listener) {
+            Set<MappingListener> listenerSet = this.listeners.get(serviceKey);
+            if (listenerSet != null) {
+                listenerSet.remove(listener);
+                if (listenerSet.isEmpty()) {
+                    this.listeners.remove(serviceKey);
+                }
+            }
+        }
+
+        public Boolean isEmpty() {
+            return this.listeners.isEmpty();
+        }
+
+        @Override
+        public void onMessage(String key, String msg) {
+            logger.info(""sub from redis:"" + key + "" message:"" + msg);
+            String applicationNames = getMappingData(buildMappingKey(DEFAULT_MAPPING_GROUP), msg);
+            MappingChangedEvent mappingChangedEvent = new MappingChangedEvent(msg, getAppNames(applicationNames));
+            if (!listeners.get(msg).isEmpty()) {
+                for (MappingListener mappingListener : listeners.get(msg)) {
+                    mappingListener.onEvent(mappingChangedEvent);
+                }
+            }
+        }
+
+        @Override
+        public void onPMessage(String pattern, String key, String msg) {
+            onMessage(key, msg);
+        }
+
+        @Override
+        public void onPSubscribe(String pattern, int subscribedChannels) {
+            super.onPSubscribe(pattern, subscribedChannels);
+        }
+    }
+
+    class MappingDataListener extends Thread {","[{'comment': 'subscribe application names change message\r\n', 'commenter': 'Nortyr'}]"
13303,dubbo-metadata/dubbo-metadata-report-redis/src/main/java/org/apache/dubbo/metadata/store/redis/RedisMetadataReport.java,"@@ -209,4 +228,266 @@ private String getMetadataStandalone(BaseMetadataIdentifier metadataIdentifier)
             throw new RpcException(msg, e);
         }
     }
+
+    @Override
+    public boolean registerServiceAppMapping(
+            String serviceInterface, String defaultMappingGroup, String newConfigContent, Object ticket) {
+        try {
+            if (null != ticket && !(ticket instanceof String)) {
+                throw new IllegalArgumentException(""redis publishConfigCas requires stat type ticket"");
+            }
+            String pathKey = buildMappingKey(defaultMappingGroup);
+
+            return storeMapping(pathKey, serviceInterface, newConfigContent, (String) ticket);
+        } catch (Exception e) {
+            logger.warn(TRANSPORT_FAILED_RESPONSE, """", """", ""redis publishConfigCas failed."", e);
+            return false;
+        }
+    }
+
+    private boolean storeMapping(String key, String field, String value, String ticket) {
+        if (pool != null) {
+            return storeMappingStandalone(key, field, value, ticket);
+        } else {
+            return storeMappingInCluster(key, field, value, ticket);
+        }
+    }
+
+    private boolean storeMappingInCluster(String key, String field, String value, String ticket) {
+        try (JedisCluster jedisCluster =
+                new JedisCluster(jedisClusterNodes, timeout, timeout, 2, password, new GenericObjectPoolConfig<>())) {
+            Jedis jedis = jedisCluster.getConnectionFromSlot(JedisClusterCRC16.getSlot(key));
+            jedis.watch(key);
+            String oldValue = jedis.hget(key, field);
+            if (null == oldValue || null == ticket || oldValue.equals(ticket)) {
+                Transaction transaction = jedis.multi();
+                transaction.hset(key, field, value);
+                List<Object> result = transaction.exec();
+                if (null != result) {
+                    jedisCluster.publish(buildPubSubKey(), field);
+                    return true;
+                }
+            } else {
+                jedis.unwatch();
+            }
+        } catch (Throwable e) {
+            String msg = ""Failed to put "" + key + "":"" + field + "" to redis "" + value + "", cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+        return false;
+    }
+
+    private boolean storeMappingStandalone(String key, String field, String value, String ticket) {
+        try (Jedis jedis = pool.getResource()) {
+            jedis.watch(key);
+            String oldValue = jedis.hget(key, field);
+            if (null == oldValue || null == ticket || oldValue.equals(ticket)) {
+                Transaction transaction = jedis.multi();
+                transaction.hset(key, field, value);
+                transaction.publish(buildPubSubKey(), field);
+                List<Object> result = transaction.exec();
+                return null != result;
+            }
+            jedis.unwatch();
+        } catch (Throwable e) {
+            String msg = ""Failed to put "" + key + "":"" + field + "" to redis "" + value + "", cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+        return false;
+    }
+
+    private String buildMappingKey(String defaultMappingGroup) {
+        return this.root + GROUP_CHAR_SEPARATOR + defaultMappingGroup;
+    }
+
+    private String buildPubSubKey() {
+        return buildMappingKey(DEFAULT_MAPPING_GROUP) + GROUP_CHAR_SEPARATOR + QUEUES_KEY;
+    }
+
+    @Override
+    public ConfigItem getConfigItem(String serviceKey, String group) {
+        String key = buildMappingKey(group);
+        String content = getMappingData(key, serviceKey);
+
+        return new ConfigItem(content, content);
+    }
+
+    private String getMappingData(String key, String field) {
+        if (pool != null) {
+            return getMappingDataStandalone(key, field);
+        } else {
+            return getMappingDataInCluster(key, field);
+        }
+    }
+
+    private String getMappingDataInCluster(String key, String field) {
+        try (JedisCluster jedisCluster =
+                new JedisCluster(jedisClusterNodes, timeout, timeout, 2, password, new GenericObjectPoolConfig<>())) {
+            return jedisCluster.hget(key, field);
+        } catch (Throwable e) {
+            String msg = ""Failed to get "" + key + "":"" + field + "" from redis cluster , cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+    }
+
+    private String getMappingDataStandalone(String key, String field) {
+        try (Jedis jedis = pool.getResource()) {
+            return jedis.hget(key, field);
+        } catch (Throwable e) {
+            String msg = ""Failed to get "" + key + "":"" + field + "" from redis , cause: "" + e.getMessage();
+            logger.error(TRANSPORT_FAILED_RESPONSE, """", """", msg, e);
+            throw new RpcException(msg, e);
+        }
+    }
+
+    @Override
+    public void removeServiceAppMappingListener(String serviceKey, MappingListener listener) {
+        MappingDataListener mappingDataListener = mappingDataListenerMap.get(buildPubSubKey());
+        if (null != mappingDataListener) {
+            NotifySub notifySub = mappingDataListener.getNotifySub();
+            notifySub.removeListener(serviceKey, listener);
+            if (notifySub.isEmpty()) {
+                mappingDataListener.shutdown();
+            }
+        }
+    }
+
+    @Override
+    public Set<String> getServiceAppMapping(String serviceKey, MappingListener listener, URL url) {
+        MappingDataListener mappingDataListener =
+                ConcurrentHashMapUtils.computeIfAbsent(mappingDataListenerMap, buildPubSubKey(), k -> {
+                    MappingDataListener dataListener = new MappingDataListener(buildPubSubKey());
+                    dataListener.start();
+                    return dataListener;
+                });
+        mappingDataListener.getNotifySub().addListener(serviceKey, listener);
+        return this.getServiceAppMapping(serviceKey, url);
+    }
+
+    @Override
+    public Set<String> getServiceAppMapping(String serviceKey, URL url) {
+        String key = buildMappingKey(DEFAULT_MAPPING_GROUP);
+        return getAppNames(getMappingData(key, serviceKey));
+    }
+
+    @Override
+    public MetadataInfo getAppMetadata(SubscriberMetadataIdentifier identifier, Map<String, String> instanceMetadata) {
+        String content = this.getMetadata(identifier);
+        return JsonUtils.toJavaObject(content, MetadataInfo.class);
+    }
+
+    @Override
+    public void publishAppMetadata(SubscriberMetadataIdentifier identifier, MetadataInfo metadataInfo) {
+        this.storeMetadata(identifier, metadataInfo.getContent());
+    }
+
+    @Override
+    public void unPublishAppMetadata(SubscriberMetadataIdentifier identifier, MetadataInfo metadataInfo) {
+        this.deleteMetadata(identifier);
+    }
+
+    // for test
+    public MappingDataListener getMappingDataListener() {
+        return mappingDataListenerMap.get(buildPubSubKey());
+    }
+
+    class NotifySub extends JedisPubSub {","[{'comment': 'listen application names change message and notify listener', 'commenter': 'Nortyr'}]"
13334,dubbo-common/src/main/java/org/apache/dubbo/common/utils/JVMUtil.java,"@@ -33,75 +33,84 @@ public class JVMUtil {
     public static void jstack(OutputStream stream) throws Exception {
         ThreadMXBean threadMxBean = ManagementFactory.getThreadMXBean();
         for (ThreadInfo threadInfo : threadMxBean.dumpAllThreads(true, true)) {
-            stream.write(getThreadDumpString(threadInfo).getBytes());
+            getThreadDumpString(stream, threadInfo);
         }
     }
 
-    private static String getThreadDumpString(ThreadInfo threadInfo) {
-        StringBuilder sb = new StringBuilder(""\"""" + threadInfo.getThreadName() + ""\"""" + "" Id=""
-                + threadInfo.getThreadId() + "" "" + threadInfo.getThreadState());
+    private static void getThreadDumpString(final OutputStream stream, ThreadInfo threadInfo) throws Exception {
+        // print basic info
+        stream.write(String.format(
+                        ""\""%s\"" Id=%d %s"",
+                        threadInfo.getThreadName(), threadInfo.getThreadId(), threadInfo.getThreadState())
+                .getBytes());
         if (threadInfo.getLockName() != null) {
-            sb.append("" on "" + threadInfo.getLockName());
+            stream.write(String.format("" on %s"", threadInfo.getLockName()).getBytes());
         }
         if (threadInfo.getLockOwnerName() != null) {
-            sb.append("" owned by \"""" + threadInfo.getLockOwnerName() + ""\"" Id="" + threadInfo.getLockOwnerId());
+            stream.write(
+                    String.format("" owned by \""%s\"" Id=%d"", threadInfo.getLockOwnerName(), threadInfo.getLockOwnerId())
+                            .getBytes());
         }
         if (threadInfo.isSuspended()) {
-            sb.append("" (suspended)"");
+            stream.write("" (suspended)"".getBytes());
         }
         if (threadInfo.isInNative()) {
-            sb.append("" (in native)"");
+            stream.write("" (in native)"".getBytes());
         }
-        sb.append('\n');
-        int i = 0;
+        stream.write(""\n"".getBytes());
+
+        // calculate stack print depth
+        StackTraceElement[] stackTrace = threadInfo.getStackTrace();
         // default is 32, means only print up to 32 lines
-        int jstackMaxLine = 32;
+        int printStackDepth = Math.min(32, stackTrace.length);
         String jstackMaxLineStr = System.getProperty(CommonConstants.DUBBO_JSTACK_MAXLINE);
         if (StringUtils.isNotEmpty(jstackMaxLineStr)) {
             try {
-                jstackMaxLine = Integer.parseInt(jstackMaxLineStr);
+                printStackDepth = Integer.parseInt(jstackMaxLineStr);","[{'comment': 'Seems should be `Math.min(stackTrace.length, Integer.parseInt(jstackMaxLineStr))`', 'commenter': 'AlbumenJ'}]"
13334,dubbo-common/src/test/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReportTest.java,"@@ -45,8 +46,9 @@ void jStackDumpTest() {
 
         AbortPolicyWithReport abortPolicyWithReport = new AbortPolicyWithReport(""Test"", url) {
             @Override
-            protected void jstack(FileOutputStream jStackStream) {
+            protected void jstack(FileOutputStream jStackStream) throws Exception {
                 fileOutputStream.set(jStackStream);
+                JVMUtil.jstack(jStackStream);","[{'comment': 'Please add some test cases to verify the result', 'commenter': 'AlbumenJ'}]"
13347,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,"@@ -779,6 +780,13 @@ public void prepareApplicationInstance(ModuleModel moduleModel) {
         // export MetricsService
         exportMetricsService();
 
+        if (moduleModel.getDeployer().hasRegistryInteraction()) {
+             ApplicationConfig applicationConfig = configManager.getApplicationOrElseThrow();
+             if (DEFAULT_APP_NAME.equals(applicationConfig.getName())) {
+                throw new IllegalStateException(""Application name must be set when registry is enabled."");
+             }","[{'comment': 'I think it would be better to allow register interface mode if users have not specified the application name. It works in interface mode.', 'commenter': 'AlbumenJ'}]"
