Pull,Path,Diff_hunk,Comment
9,src/main/java/org/apache/commons/codec/net/PercentCodec.java,"@@ -0,0 +1,114 @@
+package org.apache.commons.codec.net;
+
+import java.io.ByteArrayOutputStream;
+import java.nio.charset.Charset;
+import java.nio.charset.CharsetEncoder;
+import java.util.BitSet;
+import org.apache.commons.codec.BinaryDecoder;
+import org.apache.commons.codec.BinaryEncoder;
+import org.apache.commons.codec.DecoderException;
+import org.apache.commons.codec.EncoderException;
+
+/**
+ * Implements the Percent-Encoding scheme, as described in HTTP 1.1 specification.
+ *
+ * @see <a href=""https://tools.ietf.org/html/rfc3986#section-2.1"">Percent-Encoding</a>
+ */
+public class PercentCodec implements BinaryEncoder, BinaryDecoder {
+
+    private final byte ESCAPE_CHAR = '%';
+
+    private BitSet alwaysEncodeChars = new BitSet();","[{'comment': 'Why not make this final?', 'commenter': 'garydgregory'}]"
9,src/main/java/org/apache/commons/codec/net/PercentCodec.java,"@@ -0,0 +1,114 @@
+package org.apache.commons.codec.net;
+
+import java.io.ByteArrayOutputStream;
+import java.nio.charset.Charset;
+import java.nio.charset.CharsetEncoder;
+import java.util.BitSet;
+import org.apache.commons.codec.BinaryDecoder;
+import org.apache.commons.codec.BinaryEncoder;
+import org.apache.commons.codec.DecoderException;
+import org.apache.commons.codec.EncoderException;
+
+/**
+ * Implements the Percent-Encoding scheme, as described in HTTP 1.1 specification.
+ *
+ * @see <a href=""https://tools.ietf.org/html/rfc3986#section-2.1"">Percent-Encoding</a>
+ */
+public class PercentCodec implements BinaryEncoder, BinaryDecoder {
+
+    private final byte ESCAPE_CHAR = '%';
+
+    private BitSet alwaysEncodeChars = new BitSet();
+
+    public PercentCodec() {
+        alwaysEncodeChars.set(ESCAPE_CHAR);
+    }
+
+    public PercentCodec(char[] alwaysEncodeCharArray) {
+        super();
+        fillBitSet(alwaysEncodeCharArray);
+    }
+
+    private void fillBitSet(char[] alwaysEncodeCharArray) {
+        if (alwaysEncodeCharArray == null)
+            return;","[{'comment': 'Missing { and }.', 'commenter': 'garydgregory'}]"
9,src/test/java/org/apache/commons/codec/net/PercentCodecTest.java,"@@ -0,0 +1,70 @@
+package org.apache.commons.codec.net;
+
+import java.nio.charset.Charset;
+import org.apache.commons.codec.DecoderException;
+import org.apache.commons.codec.EncoderException;
+import static org.junit.Assert.assertEquals;
+import org.junit.Test;
+
+/**
+ * Percent-Encoding cÎ¿dec test cases
+ */
+public class PercentCodecTest {
+
+    @Test
+    public void testBasicEncodeDecode() throws Exception {
+        PercentCodec percentCodec = new PercentCodec();
+        final String input = ""Hello world!"";
+        byte[] encoded = percentCodec.encode(input.getBytes(Charset.forName(""UTF-8"")));
+        final String encodedS = new String(encoded, ""UTF-8"");
+        byte[] decoded = percentCodec.decode(encoded);
+        final String decodedS = new String(decoded, ""UTF-8"");
+        assertEquals(""Basic Percent-Encoding test"", ""Hello world!"", encodedS);
+        assertEquals(""Basic URL decoding test"", input, decodedS);
+    }
+
+    @Test
+    public void testSafeCharEncodeDecodeObject() throws Exception {
+        PercentCodec percentCodec = new PercentCodec();
+        final String input = ""abc123_-.*"";
+        Object encoded = percentCodec.encode((Object) input.getBytes(Charset.forName(""UTF-8"")));
+        final String encodedS = new String((byte[]) encoded, ""UTF-8"");
+        Object decoded = percentCodec.decode(encoded);
+        final String decodedS = new String((byte[]) decoded, ""UTF-8"");
+        assertEquals(""Basic Percent-Encoding test"", input, encodedS);
+        assertEquals(""Basic URL decoding test"", input, decodedS);
+    }
+
+    @Test
+    public void testUnsafeCharEncodeDecode() throws Exception {
+        PercentCodec percentCodec = new PercentCodec();
+        final String input = ""\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6% "";
+        byte[] encoded = percentCodec.encode(input.getBytes(Charset.forName(""UTF-8"")));
+        final String encodedS = new String(encoded, ""UTF-8"");
+        byte[] decoded = percentCodec.decode(encoded);
+        final String decodedS = new String(decoded, ""UTF-8"");
+        assertEquals(""Basic Percent-Encoding test"", ""%CE%B1%CE%B2%CE%B3%CE%B4%CE%B5%CE%B6%25 "", encodedS);
+        assertEquals(""Basic URL decoding test"", input, decodedS);
+    }
+
+    @Test
+    public void testConfigurablePercentEncoder() throws Exception {
+        final String input = ""abc123_-.* "";
+        PercentCodec percentCodec = new PercentCodec(input.toCharArray());
+        byte[] encoded = percentCodec.encode(input.getBytes(Charset.forName(""UTF-8"")));
+        final String encodedS = new String(encoded, ""UTF-8"");
+        assertEquals(""Basic Percent-Encoding test"", ""%61%62%63%31%32%33%5F%2D%2E%2A%20"", encodedS);
+    }
+
+    @Test(expected = EncoderException.class)
+    public void testEncodeUnsupportedObject() throws Exception {
+        PercentCodec percentCodec = new PercentCodec();
+        percentCodec.encode(""test"");
+    }
+
+    @Test(expected = DecoderException.class)
+    public void testDecodeUnsupportedObject() throws Exception {
+        PercentCodec percentCodec = new PercentCodec();
+        percentCodec.decode(""test"");
+    }
+}","[{'comment': 'It would be nice to add a code coverage report to the component; not required for this patch but a nice-to-have.', 'commenter': 'garydgregory'}, {'comment': 'According to coveralls, code coverage _decreased_ with this patch. You might want to make sure you get full code coverage for this new code if possible. Thank you!', 'commenter': 'garydgregory'}]"
22,src/main/java/org/apache/commons/codec/digest/MurmurHash2.java,"@@ -0,0 +1,215 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.digest;
+
+/**
+ * MurmurHash2 yields a 32-bit or 64-bit value.
+ * 
+ * MurmurHash is a non-cryptographic hash function suitable for general
+ * hash-based lookup. The name comes from two basic operations, multiply (MU)
+ * and rotate (R), used in its inner loop. Unlike cryptographic hash functions,
+ * it is not specifically designed to be difficult to reverse by an adversary,
+ * making it unsuitable for cryptographic purposes.
+ * 
+ * This is a re-implementation of the original C code plus some additional
+ * features.
+ * 
+ * Public domain.
+ * 
+ * @author Viliam Holub","[{'comment': '@melloware \r\nThank you for your PR.\r\nWe recommend _against_ using author tags, please remove them.', 'commenter': 'garydgregory'}, {'comment': 'Removed.', 'commenter': 'melloware'}]"
22,src/main/java/org/apache/commons/codec/digest/MurmurHash2.java,"@@ -0,0 +1,215 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.digest;
+
+/**
+ * MurmurHash2 yields a 32-bit or 64-bit value.
+ * 
+ * MurmurHash is a non-cryptographic hash function suitable for general
+ * hash-based lookup. The name comes from two basic operations, multiply (MU)
+ * and rotate (R), used in its inner loop. Unlike cryptographic hash functions,
+ * it is not specifically designed to be difficult to reverse by an adversary,
+ * making it unsuitable for cryptographic purposes.
+ * 
+ * This is a re-implementation of the original C code plus some additional
+ * features.
+ * 
+ * Public domain.
+ * 
+ * @author Viliam Holub
+ * @see <a href=""https://en.wikipedia.org/wiki/MurmurHash"">MurmurHash</a>
+ * @since 1.13
+ */
+public final class MurmurHash2 {
+
+	// all methods static; private constructor.","[{'comment': ""NOT all methods should be static: You should implement Codec's `BinaryEncoder` and `BinaryDecoder` interfaces and/or `StringEncoder` and `StringDecoder` depending on the use cases of this code."", 'commenter': 'garydgregory'}, {'comment': 'Good idea let me study those interfaces and see if I can modify.', 'commenter': 'melloware'}, {'comment': ""Actually looking at those the intent was something was encoded.  This is more like the XXHash32 class in Commons Codec.  This hashes a value to a long or int.  I don't see any interface for Hash algorithms?"", 'commenter': 'melloware'}]"
22,src/main/java/org/apache/commons/codec/digest/MurmurHash3.java,"@@ -0,0 +1,551 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.digest;
+
+/**
+ * MurmurHash3 yields a 32-bit or 128-bit value.
+ * 
+ * MurmurHash is a non-cryptographic hash function suitable for general
+ * hash-based lookup. The name comes from two basic operations, multiply (MU)
+ * and rotate (R), used in its inner loop. Unlike cryptographic hash functions,
+ * it is not specifically designed to be difficult to reverse by an adversary,
+ * making it unsuitable for cryptographic purposes.
+ * 
+ * 32-bit Java port of
+ * https://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp#94
+ * 128-bit Java port of
+ * https://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp#255
+ *
+ * This is a public domain code with no copyrights. From homepage of MurmurHash
+ * (https://code.google.com/p/smhasher/), ""All MurmurHash versions are public
+ * domain software, and the author disclaims all copyright to their code.""
+ * 
+ * Copied from Apache Hive:
+ * https://github.com/apache/hive/blob/master/storage-api/src/java/org/apache/hive/common/util/Murmur3.java
+ * 
+ * @see <a href=""https://en.wikipedia.org/wiki/MurmurHash"">MurmurHash</a>
+ * @since 1.13
+ */
+public final class MurmurHash3 {","[{'comment': ""NOT all methods should be static: You should implement Codec's `BinaryEncoder` and `BinaryDecoder` interfaces and/or `StringEncoder` and `StringDecoder` depending on the use cases of this code."", 'commenter': 'garydgregory'}]"
23,src/test/java/org/apache/commons/codec/binary/HexTest.java,"@@ -227,18 +227,19 @@ public void testDecodeByteArrayOddCharacters() {
 
     @Test
     public void testDecodeByteBufferEmpty() throws DecoderException {
-        assertTrue(Arrays.equals(new byte[0], new Hex().decode(ByteBuffer.allocate(0))));","[{'comment': 'I would prefer to add tests instead of updating each call to `allocate` with a call to `allocateDirect`. This is something that could be done either with subclasses (one for allocate, one for allocateDirect) or with parameterizing the test with lambdas.', 'commenter': 'garydgregory'}, {'comment': ""I'm sorry but have no time for that"", 'commenter': 'Megaprog'}]"
27,src/main/java/org/apache/commons/codec/digest/MurmurHash3.java,"@@ -72,6 +75,7 @@
 	private static final int M = 5;
 	private static final int N1 = 0x52dce729;
 	private static final int N2 = 0x38495ab5;
+	private static final long UINT_MASK = 0x00000000FFFFFFFFL;","[{'comment': 'Use lower case F for consistency. No need for all the leading zeros either.', 'commenter': 'aherbert'}]"
27,src/main/java/org/apache/commons/codec/digest/MurmurHash3.java,"@@ -207,20 +211,24 @@ public static int hash32(final byte[] data, final int offset, final int length,
 		// tail
 		final int idx = nblocks << 2;
 		int k1 = 0;
+		/*
+         * The original algorithm uses unsigned bytes.
+         * We have to mask to match the behavior of the unsigned bytes and prevent sign extension.
+         */
 		switch (length - idx) {
-		case 3:
-			k1 ^= data[offset + idx + 2] << 16;
-		case 2:
-			k1 ^= data[offset + idx + 1] << 8;
-		case 1:
-			k1 ^= data[offset + idx];
-
-			// mix functions
-			k1 *= C1_32;
-			k1 = Integer.rotateLeft(k1, R1_32);
-			k1 *= C2_32;
-			hash ^= k1;
-		}
+    	case 3:
+            k1 = (data[offset + idx + 2] & UBYTE_MASK) << 16;
+            // fallthrough
+        case 2:
+            k1 |= (data[offset + idx + 1] & UBYTE_MASK) << 8;
+            // fallthrough
+        case 1:
+            k1 |= (data[offset + idx] & UBYTE_MASK);
+            k1 *= C1_32;
+            k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);","[{'comment': 'I would leave the use of Integer.rotateLeft() and the `// mix functions` comment.\r\n\r\nThe whitespace formatting of this block is incorrect so the git diff seems larger than the actual changes. The final mix functions should not have to be changed, only the unsigned masking applied to k1.', 'commenter': 'aherbert'}]"
27,src/main/java/org/apache/commons/codec/digest/MurmurHash3.java,"@@ -393,7 +401,7 @@ public static long hash64(final byte[] data, final int offset, final int length,
 	 * @return - 128 bit hash (2 longs)
 	 */
 	public static long[] hash128(final String data) {
-		final byte[] origin = data.getBytes();
+		final byte[] origin = data.getBytes(StandardCharsets.UTF_8);","[{'comment': 'Why the charset conversion? Changing away from using the default charset is not related to the other changes in this PR.', 'commenter': 'aherbert'}, {'comment': 'It showed up in a bug report -- reverting.', 'commenter': 'Claudenw'}]"
27,src/main/java/org/apache/commons/codec/digest/MurmurHash3.java,"@@ -602,15 +613,19 @@ public final void add(final byte[] data, int offset, final int length) {
 			System.arraycopy(data, offset + consumed, tail, 0, tailLen);
 		}
 
+		/*
+		 * The original algorithm uses unsigned bytes.
+         * We have to mask to match the behavior of the unsigned bytes and prevent sign extension.
+         */
 		public final int end() {
 			int k1 = 0;
 			switch (tailLen) {
 			case 3:
-				k1 ^= tail[2] << 16;
+				k1 ^= (tail[2] & UBYTE_MASK) << 16;","[{'comment': ""In the change to `hash32` you switched to using `|=` operators from `^=` but not here.\r\n\r\nIn both cases it makes no difference as k1 is zero and `^=` will produce the equivalent. I suggest changing the `|=` operator back to `^=`. This will minimise the changes in the PR.\r\n\r\nA performance test against an updated algorithm that exclusively uses `|=` would justify a change. Otherwise just leave it as is. I'd expect no difference anyway given this is in the `end()` method and will be a minority of the runtime for the overall hash method."", 'commenter': 'aherbert'}, {'comment': 'reverted to ^=', 'commenter': 'Claudenw'}]"
27,src/test/java/org/apache/commons/codec/digest/MurmurHash3Test.java,"@@ -224,4 +224,68 @@ public void testSingleLongRandom() {
 		}
 	}
 
+	/**
+	 * Execute the Murmur3_x64_128 tests from Yonic Seeley's implementation tests.
+	 * Part of CODEC-264 testing
+	 * @see https://github.com/yonik/java_util/blob/master/test/util/hash/TestMurmurHash3.java
+	 * @throws Exception
+	 */
+	@Test
+	public void testHash128SignExtension() throws Exception {
+        long[] answers128 = new long[] {0x6e54d3ad2be8e9a2L,0xd99e452d1cfc7decL,0x609c35d060cf37c1L,0x4ba03e78929b6807L,0xf4865522a8838216L,0xef8dc0ad3f5a0581L,0x8513b05a329d04ecL,0x2295dbef5a603ebcL,0xd0259c75fa8711b2L,0x311f78657cb7ecb9L,0x771d03baa6accef1L,0x596d9c3bde77e873L,0xdc177610450452dbL,0x5b85d931e890ef5eL,0x261f88eedccbbd36L,0xcba71c1101271139L,0xa3a125d270c03cL,0xc41e9d6ae4ef9d56L,0xf9b21d4d660517c0L,0x409d87f99aeb3ea9L,0x92d8e70ae59a864L,0xf4e12d297744d05aL,0xd894caa03d461dbeL,0x99d6ff317880f305L,0x145d42da3710d23aL,0x2812adb381c1d64aL,0xd90254532b45e323L,0xacbb43b768a7b276L,0x74573f58c60c3ddfL,0xc72b9b42a7cbbd69L,0xd1129837bea190a7L,0xa7b20418ce5d46f9L,0xa6d094d2a166f659L,0x10f66ed93811576eL,0x28d3553af07b8cfaL,0xdd3b57dcd4d98ec2L,0xcd57b4faccaf9764L,0x1e4001ee8b46813aL,0xc79f57499389029eL,0xf4f84142db2d7673L,0xfafc9890edaf9086L,0xc54472528c0fcd98L,0xd3ff4eff416c02b7L,0x47c8414e9fa28367L,0x78f0171da51288e6L,0x7f5046c28cd1b43aL,0xc38dacef191ad1f0L,0x6210c0aba8230563L,0x15e3cd836648fe66L,0x56a1797408568c1eL,0x9162e9b79d4f6689L,0x6fc7ba8e6135592dL,0x569e7feab218d54aL,0x93d21aac30f6029fL,0x4e7a938ca19a5fe5L,0x3c7dd68323efe355L,0x651993620ca49e3fL,0x9f0cc9127f8eca7L,0x3963f278753c4f44L,0x3f2ab0d0e62bb19fL,0x4d72a64283465629L,0xd9d958282564a987L,0xde019492e4164d94L,0xc319fb27d1d42455L,0xe788f28b58a0c025L,0xabb3f2ca571338b4L,0xaac4a40f227db268L,0x8f86a5605449d75aL,0xcc3999bd3c872160L,0x3010e16e331a57e2L,0xd43cfd0741d4ed2L,0x7954298caa472790L,0xfe5b6444abb41ceL,0xaff3b10d222afeafL,0xa5438bad24a5629eL,0xc474fa5e2ff33329L,0xbda083bc5d7b382bL,0xef31a1cda016673eL,0xda9b98b58bb7eff5L,0xe001283d41a1576L,0x6ee0f9ab35eb17ebL,0x5de93fcf7e7e0169L,0x3cd1756a735b7caL,0x582ded067b6714e9L,0x56194735c4168e94L,0xeeaf5a39dcf76088L,0xf9d9a9c7d1520670L,0xb98d7d405a177795L,0x3281c2365b5bc415L,0x85e4cfb23980f8b4L,0x484aee59fa5880bdL,0xe000f2daa2078018L,0xebff3a4bff725d23L,0x803e3c3dd2716703L,0x413e18195eb5b4bfL,0xce1ea41794fec551L,0xcbf65e356e2d69bdL,0x654a616738582ba7L,0x62e46d535f11c417L,0xbd11185034218fa2L,0x7c715d440eaa5fb1L,0xe68ad0d758ade8dL,0x3242a4d88ac3ba92L,0x10f1e6939ee06b78L,0x965d9c4109ab6eb4L,0x6bc256008b6083d5L,0xa8fb3b9666e0eb4dL,0x2d8a83366565a273L,0xa5eddde29cc59fc4L,0xfd1f7dc9866ceb19L,0x86c13e98272a7eb9L,0x11149397f635b42cL,0xcbf82258e2b85bf5L,0x37215737b1ab86fbL,0x44e5126c5c5f4ae5L,0x99fe7cce58649b93L,0xc455e6ddc7be80f0L,0xf93bec96644e8723L,0x130dc4e99fb989e8L,0xb01734fafdc5308dL,0x8fde545bd48cb2feL,0x1102c89b77b4b405L,0x2cd24ed5816eca6eL,0xebd56473a502b63fL,0x357fb8e6b489be97L,0xe163a9495e6d67daL,0x87411ac34bd7399aL,0xf8bc18d84f4237bfL,0x43702207d2269e74L,0x37a3eec07a419e21L,0x7fe4605c33d4ac0cL,0x6df566b6925a898dL,0x89526c269d9225b0L,0xfc24aac3b731d33eL,0x2518f6ea6300c3caL,0xe4e20fdb203d79f5L};
+
+        byte[] bytes = ""Now is the time for all good men to come to the aid of their country"".getBytes(""UTF-8"");
+	      int hash=0;
+	      for (int i=0; i<bytes.length; i++) {
+	        hash = hash*31+(bytes[i]&0xff);
+	        bytes[i] = (byte)hash;
+	      }
+
+	      // test different offsets.
+	      for (int offset = 0; offset<20; offset++) {
+	        // put the original bytes at the offset so the same hash will be generated
+	        byte[] arr = new byte[bytes.length + offset];
+	        System.arraycopy(bytes, 0, arr, offset, bytes.length);
+	        int seed = 1;
+	        long[] result;
+	        for (int len=0; len<bytes.length; len++) {
+	          seed *= 0x9e3779b1;
+	          result = MurmurHash3.hash128(arr, offset, len, seed);
+	          assertEquals(answers128[len * 2], result[0]);
+	          assertEquals(answers128[len*2+1], result[1]);
+	        }
+	      }
+	    }
+
+    /**
+     * Execute the Murmur3_x86_32 tests from Yonic Seeley's implementation tests.
+     * Part of CODEC-264 testing
+     * @see https://github.com/yonik/java_util/blob/master/test/util/hash/TestMurmurHash3.java
+     * @throws Exception
+     */
+	@Test
+    public void testHash32SignExtension() throws Exception {
+        int[] answers32 = new int[] {0x11fd02eb,0x8dd65a73,0x29b074ba,0xcbcd43ce,0xb6463881,0xf6228557,0x3d55c634,0xa1bb9072,0x448402c6,0xb12bf3d4,0x18a71ccb,0x6ae5f185,0x9a482256,0xc686d7f2,0x8e8984d8,0x68a2491d,0xcc29b0e6,0x3e9130bd,0xc90defb3,0xf81c5978,0x15ff7f63,0x4ec16a7a,0xa08aa899,0x7317ffee,0x93752d34,0x400f8781,0x2358838c,0x6ecb8998,0x45a5c102,0x46ed68fd,0xfecb51c0,0x7a68c7db,0x9e334eab,0x21ea13b6,0xf184e92c,0xc016220d,0x7f6c9713,0x1e909123,0xb51a21b7,0x94c58881,0xe4e91bf0,0xde80a366,0xfd84005a,0x3361d373,0xe7d528cc,0x487275a7,0xf2290ee5,0x869992a8,0x63cdd341,0x8e94b334,0x1fc7bf11,0x5228b0,0xb4292b62,0x36ed3770,0xfe914519,0x7d9d1830,0xe1acfb60,0xc8b4d4b7,0xf1ec49ba,0xedbb8cc1,0xdc5b3ab1,0x7c7778ae,0x52bf68d,0xe0bb4148,0xfea36521,0xa0696ca5,0xf28df752,0xd82dccb6};
+
+        byte[] bytes = ""Now is the time for all good men to come to the aid of their country"".getBytes(""UTF-8"");
+          int hash=0;
+          for (int i=0; i<bytes.length; i++) {
+            hash = hash*31+(bytes[i]&0xff);
+            bytes[i] = (byte)hash;
+          }
+
+          // test different offsets.
+          for (int offset = 0; offset<20; offset++) {
+            // put the original bytes at the offset so the same hash will be generated
+            byte[] arr = new byte[bytes.length + offset];
+            System.arraycopy(bytes, 0, arr, offset, bytes.length);
+            int seed = 1;
+            for (int len=0; len<bytes.length; len++) {
+              seed *= 0x9e3779b1;
+              int h = MurmurHash3.hash32(arr, offset, len, seed);
+              assertEquals(answers32[len], h);
+            }
+          }
+        }
+","[{'comment': 'The formatting of these blocks is off. The original code uses tabs. Can you stick to the tab style or use 4 character space indents instead.\r\n\r\nMurmurHash2/3 and their tests are the only files in the repo that use tabs. All others use 4 character indentation. This can be fixed at another time.', 'commenter': 'aherbert'}, {'comment': 'attempted to fix ', 'commenter': 'Claudenw'}, {'comment': 'In general, we are a no tabs project, see ""Spaces No Tabs"" here https://commons.apache.org/patches.html. \r\n\r\nIt was my mistake to bring in the original PR with tabs in the first place, dang. We can fix tabs separately indeed, whatever makes the process best for review...\r\n', 'commenter': 'garydgregory'}, {'comment': 'That was my fault I should have scrubbed the tabs when I brought this file over.  ', 'commenter': 'melloware'}]"
27,src/main/java/org/apache/commons/codec/digest/MurmurHash3.java,"@@ -407,22 +415,25 @@ public static long hash64(final byte[] data, final int offset, final int length,
 	 * @return - 128 bit hash (2 longs)
 	 */
 	public static long[] hash128(final byte[] data, final int offset, final int length, final int seed) {
-		long h1 = seed;
-		long h2 = seed;
+	    // The original algorithm does have a 32 bit unsigned seed.
+	    // We have to mask to match the behavior of the unsigned types and prevent sign extension.
+	    long h1 = seed & UINT_MASK;","[{'comment': 'Indentation issues.', 'commenter': 'aherbert'}]"
27,src/test/java/org/apache/commons/codec/digest/MurmurHash3Test.java,"@@ -224,4 +225,238 @@ public void testSingleLongRandom() {
 		}
 	}
 
+	@Test
+    public void test32_x86_String() {
+        // Arrange
+        final String origin = TEST;
+
+        // Act
+        final int result = MurmurHash3.hash32_x86(origin);
+
+        // Assert
+        assertEquals(-436507231, result);
+    }
+
+    @Test
+    public void test128_x64_Short() {
+        // Arrange
+        final ByteBuffer BUFFER = ByteBuffer.allocate(MurmurHash3.SHORT_BYTES);
+        BUFFER.putShort(0, (short) 2);
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(BUFFER.array());
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(8673501042631707204L, result[0]);
+        assertEquals(491907755572407714L, result[1]);
+    }
+
+    @Test
+    public void test128_x64_Int() {
+        // Arrange
+        final ByteBuffer BUFFER = ByteBuffer.allocate(MurmurHash3.INTEGER_BYTES);
+        BUFFER.putInt(0, 3);
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(BUFFER.array());
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(2448828847287705405L, result[0]);
+        assertEquals(-4568642211270719983L, result[1]);
+    }
+
+    @Test
+    public void test128_x64_Long() {
+        // Arrange
+        final ByteBuffer BUFFER = ByteBuffer.allocate(MurmurHash3.LONG_BYTES);
+        BUFFER.putLong(0, 8675309L);
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(BUFFER.array());
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(2339756411022791995L, result[0]);
+        assertEquals(8242951144762217305L, result[1]);
+    }
+
+    @Test
+    public void test128_x64_Double() {
+        // Arrange
+        final ByteBuffer BUFFER = ByteBuffer.allocate(Double.SIZE / Byte.SIZE);
+        BUFFER.putDouble(0, 456.987);
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(BUFFER.array());
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(6877430437712399133L, result[0]);
+        assertEquals(-8576421050167250536L, result[1]);
+    }
+
+    @Test
+    public void test128_x64_String() {
+        // Arrange
+        final String origin = TEST;
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(origin);
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(6409160382500807310L, result[0]);
+        assertEquals(-7835827609130513921L, result[1]);
+    }
+
+
+
+    @Test
+    public void testTwoLongOrdered_32x86() {
+        final ByteBuffer buffer = ByteBuffer.allocate(MurmurHash3.LONG_BYTES * 2);
+        for (long i = 0; i < 1000; i++) {
+            for (long j = 0; j < 1000; j++) {
+                buffer.putLong(0, i);
+                buffer.putLong(MurmurHash3.LONG_BYTES, j);
+                assertEquals(MurmurHash3.hash32_x86(buffer.array()), MurmurHash3.hash32_x86(i, j));
+            }
+        }
+    }
+
+    @Test
+    public void testTwoLongRandom_32x86() {
+        final ByteBuffer buffer = ByteBuffer.allocate(MurmurHash3.LONG_BYTES * 2);
+        final Random random = new Random();
+        for (long i = 0; i < 1000; i++) {
+            for (long j = 0; j < 1000; j++) {
+                final long x = random.nextLong();
+                final long y = random.nextLong();
+                buffer.putLong(0, x);
+                buffer.putLong(MurmurHash3.LONG_BYTES, y);
+                assertEquals(MurmurHash3.hash32_x86(buffer.array()), MurmurHash3.hash32_x86(x, y));
+            }
+        }
+    }
+
+    @Test
+    public void testSingleLongOrdered_32x86() {
+        final ByteBuffer buffer = ByteBuffer.allocate(MurmurHash3.LONG_BYTES);
+        for (long i = 0; i < 1000; i++) {
+            buffer.putLong(0, i);
+            assertEquals(MurmurHash3.hash32_x86(buffer.array()), MurmurHash3.hash32_x86(i));
+        }
+    }
+
+    @Test
+    public void testSingleLongRandom_32x86() {
+        final ByteBuffer buffer = ByteBuffer.allocate(MurmurHash3.LONG_BYTES);
+        final Random random = new Random();
+        for (long i = 0; i < 1000; i++) {
+            final long x = random.nextLong();
+            buffer.putLong(0, x);
+            assertEquals(MurmurHash3.hash32_x86(buffer.array()), MurmurHash3.hash32_x86(x));
+        }
+    }
+    
+    @Test
+    public void testCorrectValues() throws Exception {
+        byte[] bytes = ""Now is the time for all good men to come to the aid of their country"".getBytes(""UTF-8"");
+        int hash=0;
+        for (int i=0; i<bytes.length; i++) {
+          hash = hash*31+(bytes[i]&0xff);
+          bytes[i] = (byte)hash;
+        }
+
+        // test different offsets.
+        for (int offset = 0; offset<20; offset++) {
+          // put the original bytes at the offset so the same hash will be generated
+          byte[] arr = new byte[bytes.length + offset];
+          System.arraycopy(bytes, 0, arr, offset, bytes.length);
+          int seed = 1;
+          long[] result;
+          for (int len=0; len<bytes.length; len++) {
+            seed *= 0x9e3779b1;
+            int h = MurmurHash3.hash32_x86(arr, offset, len, seed);
+            assertEquals(answers32[len], h);
+            result = MurmurHash3.hash128_x64(arr, offset, len, seed);
+            assertEquals(answers128[len * 2], result[0]);
+            assertEquals(answers128[len*2+1], result[1]);
+          }
+        }
+      }
+
+      static int[] answers32 = new int[] {0x11fd02eb,0x8dd65a73,0x29b074ba,0xcbcd43ce,0xb6463881,0xf6228557,0x3d55c634,0xa1bb9072,0x448402c6,0xb12bf3d4,0x18a71ccb,0x6ae5f185,0x9a482256,0xc686d7f2,0x8e8984d8,0x68a2491d,0xcc29b0e6,0x3e9130bd,0xc90defb3,0xf81c5978,0x15ff7f63,0x4ec16a7a,0xa08aa899,0x7317ffee,0x93752d34,0x400f8781,0x2358838c,0x6ecb8998,0x45a5c102,0x46ed68fd,0xfecb51c0,0x7a68c7db,0x9e334eab,0x21ea13b6,0xf184e92c,0xc016220d,0x7f6c9713,0x1e909123,0xb51a21b7,0x94c58881,0xe4e91bf0,0xde80a366,0xfd84005a,0x3361d373,0xe7d528cc,0x487275a7,0xf2290ee5,0x869992a8,0x63cdd341,0x8e94b334,0x1fc7bf11,0x5228b0,0xb4292b62,0x36ed3770,0xfe914519,0x7d9d1830,0xe1acfb60,0xc8b4d4b7,0xf1ec49ba,0xedbb8cc1,0xdc5b3ab1,0x7c7778ae,0x52bf68d,0xe0bb4148,0xfea36521,0xa0696ca5,0xf28df752,0xd82dccb6};
+      static long[] answers128 = new long[] {0x6e54d3ad2be8e9a2L,0xd99e452d1cfc7decL,0x609c35d060cf37c1L,0x4ba03e78929b6807L,0xf4865522a8838216L,0xef8dc0ad3f5a0581L,0x8513b05a329d04ecL,0x2295dbef5a603ebcL,0xd0259c75fa8711b2L,0x311f78657cb7ecb9L,0x771d03baa6accef1L,0x596d9c3bde77e873L,0xdc177610450452dbL,0x5b85d931e890ef5eL,0x261f88eedccbbd36L,0xcba71c1101271139L,0xa3a125d270c03cL,0xc41e9d6ae4ef9d56L,0xf9b21d4d660517c0L,0x409d87f99aeb3ea9L,0x92d8e70ae59a864L,0xf4e12d297744d05aL,0xd894caa03d461dbeL,0x99d6ff317880f305L,0x145d42da3710d23aL,0x2812adb381c1d64aL,0xd90254532b45e323L,0xacbb43b768a7b276L,0x74573f58c60c3ddfL,0xc72b9b42a7cbbd69L,0xd1129837bea190a7L,0xa7b20418ce5d46f9L,0xa6d094d2a166f659L,0x10f66ed93811576eL,0x28d3553af07b8cfaL,0xdd3b57dcd4d98ec2L,0xcd57b4faccaf9764L,0x1e4001ee8b46813aL,0xc79f57499389029eL,0xf4f84142db2d7673L,0xfafc9890edaf9086L,0xc54472528c0fcd98L,0xd3ff4eff416c02b7L,0x47c8414e9fa28367L,0x78f0171da51288e6L,0x7f5046c28cd1b43aL,0xc38dacef191ad1f0L,0x6210c0aba8230563L,0x15e3cd836648fe66L,0x56a1797408568c1eL,0x9162e9b79d4f6689L,0x6fc7ba8e6135592dL,0x569e7feab218d54aL,0x93d21aac30f6029fL,0x4e7a938ca19a5fe5L,0x3c7dd68323efe355L,0x651993620ca49e3fL,0x9f0cc9127f8eca7L,0x3963f278753c4f44L,0x3f2ab0d0e62bb19fL,0x4d72a64283465629L,0xd9d958282564a987L,0xde019492e4164d94L,0xc319fb27d1d42455L,0xe788f28b58a0c025L,0xabb3f2ca571338b4L,0xaac4a40f227db268L,0x8f86a5605449d75aL,0xcc3999bd3c872160L,0x3010e16e331a57e2L,0xd43cfd0741d4ed2L,0x7954298caa472790L,0xfe5b6444abb41ceL,0xaff3b10d222afeafL,0xa5438bad24a5629eL,0xc474fa5e2ff33329L,0xbda083bc5d7b382bL,0xef31a1cda016673eL,0xda9b98b58bb7eff5L,0xe001283d41a1576L,0x6ee0f9ab35eb17ebL,0x5de93fcf7e7e0169L,0x3cd1756a735b7caL,0x582ded067b6714e9L,0x56194735c4168e94L,0xeeaf5a39dcf76088L,0xf9d9a9c7d1520670L,0xb98d7d405a177795L,0x3281c2365b5bc415L,0x85e4cfb23980f8b4L,0x484aee59fa5880bdL,0xe000f2daa2078018L,0xebff3a4bff725d23L,0x803e3c3dd2716703L,0x413e18195eb5b4bfL,0xce1ea41794fec551L,0xcbf65e356e2d69bdL,0x654a616738582ba7L,0x62e46d535f11c417L,0xbd11185034218fa2L,0x7c715d440eaa5fb1L,0xe68ad0d758ade8dL,0x3242a4d88ac3ba92L,0x10f1e6939ee06b78L,0x965d9c4109ab6eb4L,0x6bc256008b6083d5L,0xa8fb3b9666e0eb4dL,0x2d8a83366565a273L,0xa5eddde29cc59fc4L,0xfd1f7dc9866ceb19L,0x86c13e98272a7eb9L,0x11149397f635b42cL,0xcbf82258e2b85bf5L,0x37215737b1ab86fbL,0x44e5126c5c5f4ae5L,0x99fe7cce58649b93L,0xc455e6ddc7be80f0L,0xf93bec96644e8723L,0x130dc4e99fb989e8L,0xb01734fafdc5308dL,0x8fde545bd48cb2feL,0x1102c89b77b4b405L,0x2cd24ed5816eca6eL,0xebd56473a502b63fL,0x357fb8e6b489be97L,0xe163a9495e6d67daL,0x87411ac34bd7399aL,0xf8bc18d84f4237bfL,0x43702207d2269e74L,0x37a3eec07a419e21L,0x7fe4605c33d4ac0cL,0x6df566b6925a898dL,0x89526c269d9225b0L,0xfc24aac3b731d33eL,0x2518f6ea6300c3caL,0xe4e20fdb203d79f5L};
+
+      
+      private void doString(String s) {
+        doString(s, 0, 0);
+      }
+
+      private void doString(String s, int pre, int post) {
+        byte[] utf8 = s.getBytes(StandardCharsets.UTF_8);
+        int hash1 = MurmurHash3.hash32_x86(utf8, pre, utf8.length-pre-post, 123456789);
+        int hash2 = MurmurHash3.hash32_x86(s, pre, s.length()-pre-post, 123456789);
+        if (hash1 != hash2) {
+          System.out.println(s);
+          // second time for debugging...
+          hash2 = MurmurHash3.hash32_x86(s, pre, s.length()-pre-post, 123456789);
+        }
+        assertEquals(hash1, hash2);
+      }
+
+      public void testStringHash() {","[{'comment': 'Is this missing a `@Test`', 'commenter': 'aherbert'}, {'comment': 'Also should the method be more explicit: `testStringHashUsesUTF8`', 'commenter': 'aherbert'}]"
27,src/test/java/org/apache/commons/codec/digest/MurmurHash3Test.java,"@@ -224,4 +225,238 @@ public void testSingleLongRandom() {
 		}
 	}
 
+	@Test
+    public void test32_x86_String() {
+        // Arrange
+        final String origin = TEST;
+
+        // Act
+        final int result = MurmurHash3.hash32_x86(origin);
+
+        // Assert
+        assertEquals(-436507231, result);
+    }
+
+    @Test
+    public void test128_x64_Short() {
+        // Arrange
+        final ByteBuffer BUFFER = ByteBuffer.allocate(MurmurHash3.SHORT_BYTES);
+        BUFFER.putShort(0, (short) 2);
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(BUFFER.array());
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(8673501042631707204L, result[0]);
+        assertEquals(491907755572407714L, result[1]);
+    }
+
+    @Test
+    public void test128_x64_Int() {
+        // Arrange
+        final ByteBuffer BUFFER = ByteBuffer.allocate(MurmurHash3.INTEGER_BYTES);
+        BUFFER.putInt(0, 3);
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(BUFFER.array());
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(2448828847287705405L, result[0]);
+        assertEquals(-4568642211270719983L, result[1]);
+    }
+
+    @Test
+    public void test128_x64_Long() {
+        // Arrange
+        final ByteBuffer BUFFER = ByteBuffer.allocate(MurmurHash3.LONG_BYTES);
+        BUFFER.putLong(0, 8675309L);
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(BUFFER.array());
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(2339756411022791995L, result[0]);
+        assertEquals(8242951144762217305L, result[1]);
+    }
+
+    @Test
+    public void test128_x64_Double() {
+        // Arrange
+        final ByteBuffer BUFFER = ByteBuffer.allocate(Double.SIZE / Byte.SIZE);
+        BUFFER.putDouble(0, 456.987);
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(BUFFER.array());
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(6877430437712399133L, result[0]);
+        assertEquals(-8576421050167250536L, result[1]);
+    }
+
+    @Test
+    public void test128_x64_String() {
+        // Arrange
+        final String origin = TEST;
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(origin);
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(6409160382500807310L, result[0]);
+        assertEquals(-7835827609130513921L, result[1]);
+    }
+
+
+
+    @Test
+    public void testTwoLongOrdered_32x86() {
+        final ByteBuffer buffer = ByteBuffer.allocate(MurmurHash3.LONG_BYTES * 2);
+        for (long i = 0; i < 1000; i++) {
+            for (long j = 0; j < 1000; j++) {
+                buffer.putLong(0, i);
+                buffer.putLong(MurmurHash3.LONG_BYTES, j);
+                assertEquals(MurmurHash3.hash32_x86(buffer.array()), MurmurHash3.hash32_x86(i, j));
+            }
+        }
+    }
+
+    @Test
+    public void testTwoLongRandom_32x86() {
+        final ByteBuffer buffer = ByteBuffer.allocate(MurmurHash3.LONG_BYTES * 2);
+        final Random random = new Random();
+        for (long i = 0; i < 1000; i++) {
+            for (long j = 0; j < 1000; j++) {
+                final long x = random.nextLong();
+                final long y = random.nextLong();
+                buffer.putLong(0, x);
+                buffer.putLong(MurmurHash3.LONG_BYTES, y);
+                assertEquals(MurmurHash3.hash32_x86(buffer.array()), MurmurHash3.hash32_x86(x, y));
+            }
+        }
+    }
+
+    @Test
+    public void testSingleLongOrdered_32x86() {
+        final ByteBuffer buffer = ByteBuffer.allocate(MurmurHash3.LONG_BYTES);
+        for (long i = 0; i < 1000; i++) {
+            buffer.putLong(0, i);
+            assertEquals(MurmurHash3.hash32_x86(buffer.array()), MurmurHash3.hash32_x86(i));
+        }
+    }
+
+    @Test
+    public void testSingleLongRandom_32x86() {
+        final ByteBuffer buffer = ByteBuffer.allocate(MurmurHash3.LONG_BYTES);
+        final Random random = new Random();
+        for (long i = 0; i < 1000; i++) {
+            final long x = random.nextLong();
+            buffer.putLong(0, x);
+            assertEquals(MurmurHash3.hash32_x86(buffer.array()), MurmurHash3.hash32_x86(x));
+        }
+    }
+    
+    @Test
+    public void testCorrectValues() throws Exception {
+        byte[] bytes = ""Now is the time for all good men to come to the aid of their country"".getBytes(""UTF-8"");
+        int hash=0;
+        for (int i=0; i<bytes.length; i++) {
+          hash = hash*31+(bytes[i]&0xff);
+          bytes[i] = (byte)hash;
+        }
+
+        // test different offsets.
+        for (int offset = 0; offset<20; offset++) {
+          // put the original bytes at the offset so the same hash will be generated
+          byte[] arr = new byte[bytes.length + offset];
+          System.arraycopy(bytes, 0, arr, offset, bytes.length);
+          int seed = 1;
+          long[] result;
+          for (int len=0; len<bytes.length; len++) {
+            seed *= 0x9e3779b1;
+            int h = MurmurHash3.hash32_x86(arr, offset, len, seed);
+            assertEquals(answers32[len], h);
+            result = MurmurHash3.hash128_x64(arr, offset, len, seed);
+            assertEquals(answers128[len * 2], result[0]);
+            assertEquals(answers128[len*2+1], result[1]);
+          }
+        }
+      }
+
+      static int[] answers32 = new int[] {0x11fd02eb,0x8dd65a73,0x29b074ba,0xcbcd43ce,0xb6463881,0xf6228557,0x3d55c634,0xa1bb9072,0x448402c6,0xb12bf3d4,0x18a71ccb,0x6ae5f185,0x9a482256,0xc686d7f2,0x8e8984d8,0x68a2491d,0xcc29b0e6,0x3e9130bd,0xc90defb3,0xf81c5978,0x15ff7f63,0x4ec16a7a,0xa08aa899,0x7317ffee,0x93752d34,0x400f8781,0x2358838c,0x6ecb8998,0x45a5c102,0x46ed68fd,0xfecb51c0,0x7a68c7db,0x9e334eab,0x21ea13b6,0xf184e92c,0xc016220d,0x7f6c9713,0x1e909123,0xb51a21b7,0x94c58881,0xe4e91bf0,0xde80a366,0xfd84005a,0x3361d373,0xe7d528cc,0x487275a7,0xf2290ee5,0x869992a8,0x63cdd341,0x8e94b334,0x1fc7bf11,0x5228b0,0xb4292b62,0x36ed3770,0xfe914519,0x7d9d1830,0xe1acfb60,0xc8b4d4b7,0xf1ec49ba,0xedbb8cc1,0xdc5b3ab1,0x7c7778ae,0x52bf68d,0xe0bb4148,0xfea36521,0xa0696ca5,0xf28df752,0xd82dccb6};
+      static long[] answers128 = new long[] {0x6e54d3ad2be8e9a2L,0xd99e452d1cfc7decL,0x609c35d060cf37c1L,0x4ba03e78929b6807L,0xf4865522a8838216L,0xef8dc0ad3f5a0581L,0x8513b05a329d04ecL,0x2295dbef5a603ebcL,0xd0259c75fa8711b2L,0x311f78657cb7ecb9L,0x771d03baa6accef1L,0x596d9c3bde77e873L,0xdc177610450452dbL,0x5b85d931e890ef5eL,0x261f88eedccbbd36L,0xcba71c1101271139L,0xa3a125d270c03cL,0xc41e9d6ae4ef9d56L,0xf9b21d4d660517c0L,0x409d87f99aeb3ea9L,0x92d8e70ae59a864L,0xf4e12d297744d05aL,0xd894caa03d461dbeL,0x99d6ff317880f305L,0x145d42da3710d23aL,0x2812adb381c1d64aL,0xd90254532b45e323L,0xacbb43b768a7b276L,0x74573f58c60c3ddfL,0xc72b9b42a7cbbd69L,0xd1129837bea190a7L,0xa7b20418ce5d46f9L,0xa6d094d2a166f659L,0x10f66ed93811576eL,0x28d3553af07b8cfaL,0xdd3b57dcd4d98ec2L,0xcd57b4faccaf9764L,0x1e4001ee8b46813aL,0xc79f57499389029eL,0xf4f84142db2d7673L,0xfafc9890edaf9086L,0xc54472528c0fcd98L,0xd3ff4eff416c02b7L,0x47c8414e9fa28367L,0x78f0171da51288e6L,0x7f5046c28cd1b43aL,0xc38dacef191ad1f0L,0x6210c0aba8230563L,0x15e3cd836648fe66L,0x56a1797408568c1eL,0x9162e9b79d4f6689L,0x6fc7ba8e6135592dL,0x569e7feab218d54aL,0x93d21aac30f6029fL,0x4e7a938ca19a5fe5L,0x3c7dd68323efe355L,0x651993620ca49e3fL,0x9f0cc9127f8eca7L,0x3963f278753c4f44L,0x3f2ab0d0e62bb19fL,0x4d72a64283465629L,0xd9d958282564a987L,0xde019492e4164d94L,0xc319fb27d1d42455L,0xe788f28b58a0c025L,0xabb3f2ca571338b4L,0xaac4a40f227db268L,0x8f86a5605449d75aL,0xcc3999bd3c872160L,0x3010e16e331a57e2L,0xd43cfd0741d4ed2L,0x7954298caa472790L,0xfe5b6444abb41ceL,0xaff3b10d222afeafL,0xa5438bad24a5629eL,0xc474fa5e2ff33329L,0xbda083bc5d7b382bL,0xef31a1cda016673eL,0xda9b98b58bb7eff5L,0xe001283d41a1576L,0x6ee0f9ab35eb17ebL,0x5de93fcf7e7e0169L,0x3cd1756a735b7caL,0x582ded067b6714e9L,0x56194735c4168e94L,0xeeaf5a39dcf76088L,0xf9d9a9c7d1520670L,0xb98d7d405a177795L,0x3281c2365b5bc415L,0x85e4cfb23980f8b4L,0x484aee59fa5880bdL,0xe000f2daa2078018L,0xebff3a4bff725d23L,0x803e3c3dd2716703L,0x413e18195eb5b4bfL,0xce1ea41794fec551L,0xcbf65e356e2d69bdL,0x654a616738582ba7L,0x62e46d535f11c417L,0xbd11185034218fa2L,0x7c715d440eaa5fb1L,0xe68ad0d758ade8dL,0x3242a4d88ac3ba92L,0x10f1e6939ee06b78L,0x965d9c4109ab6eb4L,0x6bc256008b6083d5L,0xa8fb3b9666e0eb4dL,0x2d8a83366565a273L,0xa5eddde29cc59fc4L,0xfd1f7dc9866ceb19L,0x86c13e98272a7eb9L,0x11149397f635b42cL,0xcbf82258e2b85bf5L,0x37215737b1ab86fbL,0x44e5126c5c5f4ae5L,0x99fe7cce58649b93L,0xc455e6ddc7be80f0L,0xf93bec96644e8723L,0x130dc4e99fb989e8L,0xb01734fafdc5308dL,0x8fde545bd48cb2feL,0x1102c89b77b4b405L,0x2cd24ed5816eca6eL,0xebd56473a502b63fL,0x357fb8e6b489be97L,0xe163a9495e6d67daL,0x87411ac34bd7399aL,0xf8bc18d84f4237bfL,0x43702207d2269e74L,0x37a3eec07a419e21L,0x7fe4605c33d4ac0cL,0x6df566b6925a898dL,0x89526c269d9225b0L,0xfc24aac3b731d33eL,0x2518f6ea6300c3caL,0xe4e20fdb203d79f5L};
+
+      
+      private void doString(String s) {
+        doString(s, 0, 0);
+      }
+
+      private void doString(String s, int pre, int post) {
+        byte[] utf8 = s.getBytes(StandardCharsets.UTF_8);
+        int hash1 = MurmurHash3.hash32_x86(utf8, pre, utf8.length-pre-post, 123456789);
+        int hash2 = MurmurHash3.hash32_x86(s, pre, s.length()-pre-post, 123456789);
+        if (hash1 != hash2) {
+          System.out.println(s);
+          // second time for debugging...
+          hash2 = MurmurHash3.hash32_x86(s, pre, s.length()-pre-post, 123456789);
+        }","[{'comment': 'The repeat of the test should be removed.\r\n\r\nIt is currently not executed due to a missing `@Test` annotation is the method that uses it.', 'commenter': 'aherbert'}]"
27,src/test/java/org/apache/commons/codec/digest/MurmurHash3Test.java,"@@ -224,4 +225,238 @@ public void testSingleLongRandom() {
 		}
 	}
 
+	@Test
+    public void test32_x86_String() {
+        // Arrange
+        final String origin = TEST;
+
+        // Act
+        final int result = MurmurHash3.hash32_x86(origin);
+
+        // Assert
+        assertEquals(-436507231, result);
+    }
+
+    @Test
+    public void test128_x64_Short() {
+        // Arrange
+        final ByteBuffer BUFFER = ByteBuffer.allocate(MurmurHash3.SHORT_BYTES);
+        BUFFER.putShort(0, (short) 2);
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(BUFFER.array());
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(8673501042631707204L, result[0]);
+        assertEquals(491907755572407714L, result[1]);
+    }
+
+    @Test
+    public void test128_x64_Int() {
+        // Arrange
+        final ByteBuffer BUFFER = ByteBuffer.allocate(MurmurHash3.INTEGER_BYTES);
+        BUFFER.putInt(0, 3);
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(BUFFER.array());
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(2448828847287705405L, result[0]);
+        assertEquals(-4568642211270719983L, result[1]);
+    }
+
+    @Test
+    public void test128_x64_Long() {
+        // Arrange
+        final ByteBuffer BUFFER = ByteBuffer.allocate(MurmurHash3.LONG_BYTES);
+        BUFFER.putLong(0, 8675309L);
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(BUFFER.array());
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(2339756411022791995L, result[0]);
+        assertEquals(8242951144762217305L, result[1]);
+    }
+
+    @Test
+    public void test128_x64_Double() {
+        // Arrange
+        final ByteBuffer BUFFER = ByteBuffer.allocate(Double.SIZE / Byte.SIZE);
+        BUFFER.putDouble(0, 456.987);
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(BUFFER.array());
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(6877430437712399133L, result[0]);
+        assertEquals(-8576421050167250536L, result[1]);
+    }
+
+    @Test
+    public void test128_x64_String() {
+        // Arrange
+        final String origin = TEST;
+
+        // Act
+        final long[] result = MurmurHash3.hash128_x64(origin);
+
+        // Assert
+        assertEquals(result.length, 2);
+        assertEquals(6409160382500807310L, result[0]);
+        assertEquals(-7835827609130513921L, result[1]);
+    }
+
+
+
+    @Test
+    public void testTwoLongOrdered_32x86() {
+        final ByteBuffer buffer = ByteBuffer.allocate(MurmurHash3.LONG_BYTES * 2);
+        for (long i = 0; i < 1000; i++) {
+            for (long j = 0; j < 1000; j++) {
+                buffer.putLong(0, i);
+                buffer.putLong(MurmurHash3.LONG_BYTES, j);
+                assertEquals(MurmurHash3.hash32_x86(buffer.array()), MurmurHash3.hash32_x86(i, j));
+            }
+        }
+    }
+
+    @Test
+    public void testTwoLongRandom_32x86() {
+        final ByteBuffer buffer = ByteBuffer.allocate(MurmurHash3.LONG_BYTES * 2);
+        final Random random = new Random();
+        for (long i = 0; i < 1000; i++) {
+            for (long j = 0; j < 1000; j++) {
+                final long x = random.nextLong();
+                final long y = random.nextLong();
+                buffer.putLong(0, x);
+                buffer.putLong(MurmurHash3.LONG_BYTES, y);
+                assertEquals(MurmurHash3.hash32_x86(buffer.array()), MurmurHash3.hash32_x86(x, y));
+            }
+        }
+    }
+
+    @Test
+    public void testSingleLongOrdered_32x86() {
+        final ByteBuffer buffer = ByteBuffer.allocate(MurmurHash3.LONG_BYTES);
+        for (long i = 0; i < 1000; i++) {
+            buffer.putLong(0, i);
+            assertEquals(MurmurHash3.hash32_x86(buffer.array()), MurmurHash3.hash32_x86(i));
+        }
+    }
+
+    @Test
+    public void testSingleLongRandom_32x86() {
+        final ByteBuffer buffer = ByteBuffer.allocate(MurmurHash3.LONG_BYTES);
+        final Random random = new Random();
+        for (long i = 0; i < 1000; i++) {
+            final long x = random.nextLong();
+            buffer.putLong(0, x);
+            assertEquals(MurmurHash3.hash32_x86(buffer.array()), MurmurHash3.hash32_x86(x));
+        }
+    }
+    
+    @Test","[{'comment': 'All code from this point down has different whitespace indentation.', 'commenter': 'aherbert'}, {'comment': 'I have created a pull request to change all the tabs to spaces.\r\nhttps://github.com/apache/commons-codec/pull/28\r\n\r\nPlz review', 'commenter': 'Claudenw'}]"
29,src/main/java/org/apache/commons/codec/binary/Base32.java,"@@ -548,19 +561,23 @@ public boolean isInAlphabet(final byte octet) {
     }
 
     /**
-     * <p>
-     * Validates whether the character is possible in the context of the set of possible base 32 values.
-     * </p>
+     * Validates whether decoding the final trailing character is possible in the context
+     * of the set of possible base 32 values.
+     *
+     * <p>The character is valid if the lower bits within the provided mask are zero. This
+     * is used to test the final trailing base-32 digit is zero in the bits that will be discarded.
      *
-     * @param numBits number of least significant bits to check
+     * @param emptyBitsMask The mask of the lower bits that should be empty
      * @param context the context to be used
      *
      * @throws IllegalArgumentException if the bits being checked contain any non-zero value
      */
-    private void validateCharacter(final int numBits, final Context context) {
-        if ((context.lbitWorkArea & numBits) != 0) {
-            throw new IllegalArgumentException(
-                ""Last encoded character (before the paddings if any) is a valid base 32 alphabet but not a possible value"");
+    private static void validateCharacter(final long emptyBitsMask, final Context context) {
+        // Use the long bit work area
+        if ((context.lbitWorkArea & emptyBitsMask) != 0) {
+        throw new IllegalArgumentException(","[{'comment': 'Indentation is not quite right for the guts of this `if` block.', 'commenter': 'garydgregory'}, {'comment': ""Sorry. I seem to have dropped 4 space indentation somehow. I'll fix that now."", 'commenter': 'aherbert'}]"
31,src/test/java/org/apache/commons/codec/digest/MessageDigestAlgorithmsTest.java,"@@ -146,6 +151,22 @@ public void testDigestFile() throws IOException {
         Assert.assertArrayEquals(digestTestData(), DigestUtils.digest(DigestUtils.getDigest(messageDigestAlgorithm),getTestFile()));
     }
 
+    @Test
+    public void testNonBlockingDigestRandomAccessFile() throws IOException {
+        Assume.assumeTrue(DigestUtils.isAvailable(messageDigestAlgorithm));
+        Assert.assertArrayEquals(digestTestData(),
+                DigestUtils.nonblockingDigest(DigestUtils.getDigest(messageDigestAlgorithm), getTestRandomAccessFile()));
+        Assert.assertArrayEquals(digestTestData(), DigestUtils.digest(DigestUtils.getDigest(messageDigestAlgorithm),getTestFile()));","[{'comment': 'This should call `nonblockingDigest` with `getTestRandomAccessFile()`', 'commenter': 'aherbert'}]"
31,src/test/java/org/apache/commons/codec/digest/MessageDigestAlgorithmsTest.java,"@@ -146,6 +151,22 @@ public void testDigestFile() throws IOException {
         Assert.assertArrayEquals(digestTestData(), DigestUtils.digest(DigestUtils.getDigest(messageDigestAlgorithm),getTestFile()));
     }
 
+    @Test
+    public void testNonBlockingDigestRandomAccessFile() throws IOException {
+        Assume.assumeTrue(DigestUtils.isAvailable(messageDigestAlgorithm));
+        Assert.assertArrayEquals(digestTestData(),
+                DigestUtils.nonblockingDigest(DigestUtils.getDigest(messageDigestAlgorithm), getTestRandomAccessFile()));
+        Assert.assertArrayEquals(digestTestData(), DigestUtils.digest(DigestUtils.getDigest(messageDigestAlgorithm),getTestFile()));
+    }
+
+    @Test
+    public void testNonBlockingDigestFile() throws IOException {
+        Assume.assumeTrue(DigestUtils.isAvailable(messageDigestAlgorithm));
+        Assert.assertArrayEquals(digestTestData(),
+                DigestUtils.nonblockingDigest(DigestUtils.getDigest(messageDigestAlgorithm), getTestFile()));
+        Assert.assertArrayEquals(digestTestData(), DigestUtils.digest(DigestUtils.getDigest(messageDigestAlgorithm),getTestFile()));","[{'comment': 'This should call `nonblockingDigest`.', 'commenter': 'aherbert'}]"
31,src/main/java/org/apache/commons/codec/digest/DigestUtils.java,"@@ -99,6 +101,33 @@
         return updateDigest(messageDigest, data).digest();
     }
 
+    /**
+     * Reads through a File using non-blocking-io (NIO) and returns the digest for the data
+     *
+     * @param messageDigest The MessageDigest to use (e.g. MD5)
+     * @param data          Data to digest
+     * @return the digest
+     * @throws IOException On error reading from the stream
+     * @since 1.14
+     */
+    public static byte[] nonblockingDigest(final MessageDigest messageDigest, final File data) throws IOException {","[{'comment': 'Don\'t use implementation details in method names, so -1 to the ""nonblocking"" prefix.', 'commenter': 'garydgregory'}, {'comment': 'If I remove the prefix from:\r\n\r\n```java\r\nnonblockingDigest(final MessageDigest messageDigest, final File data)\r\n```\r\n\r\nwill clash with an existing method name.', 'commenter': 'behrangsa'}]"
31,src/main/java/org/apache/commons/codec/digest/DigestUtils.java,"@@ -1207,6 +1236,43 @@ public static MessageDigest updateDigest(final MessageDigest digest, final File
         }
     }
 
+    /**
+     * Reads through a RandomAccessFile and updates the digest for the data
+     * using non-blocking-io (NIO)
+     *
+     * @param digest The MessageDigest to use (e.g. MD5)
+     * @param data   Data to digest
+     * @return the digest
+     * @throws IOException On error reading from the stream
+     * @since 1.14
+     */
+    public static MessageDigest updateDigestNio(final MessageDigest digest, final RandomAccessFile data) throws IOException {","[{'comment': 'Don\'t use implementation details in method names, so -1 to the ""Nio"" postfix.', 'commenter': 'garydgregory'}, {'comment': ""I've added the prefix here for consistency with the other overload that takes a `File`."", 'commenter': 'behrangsa'}]"
31,src/main/java/org/apache/commons/codec/digest/DigestUtils.java,"@@ -99,6 +101,20 @@
         return updateDigest(messageDigest, data).digest();
     }
 
+    /**
+     * Reads through a RandomAccessFile using non-blocking-io (NIO) and returns the digest for the data","[{'comment': 'First line of javadoc should end with a period.', 'commenter': 'aherbert'}, {'comment': 'Fixed.', 'commenter': 'behrangsa'}]"
31,src/main/java/org/apache/commons/codec/digest/DigestUtils.java,"@@ -1207,6 +1223,29 @@ public static MessageDigest updateDigest(final MessageDigest digest, final File
         }
     }
 
+    /**
+     * Reads through a RandomAccessFile and updates the digest for the data
+     * using non-blocking-io (NIO)","[{'comment': 'First line of javadoc should end with a period.', 'commenter': 'aherbert'}]"
31,src/test/java/org/apache/commons/codec/digest/DigestUtilsTest.java,"@@ -63,23 +67,37 @@ File getTestFile() {
         return testFile;
     }
 
+    RandomAccessFile getTestRandomAccessFile() {
+        return testRandomAccessFileWrapper;
+    }
+
     @Before
     public void setUp() throws Exception {
         new Random().nextBytes(testData);
         testFile = File.createTempFile(DigestUtilsTest.class.getName(), "".dat"");
         try (final FileOutputStream fos = new FileOutputStream(testFile)) {
             fos.write(testData);
         }
+
+        testRandomAccessFile = File.createTempFile(DigestUtilsTest.class.getName(), "".dat"");
+        try (final FileOutputStream fos = new FileOutputStream(testRandomAccessFile)) {
+            fos.write(testData);
+        }
+        testRandomAccessFileWrapper = new RandomAccessFile(testRandomAccessFile, ""rw"");
     }
 
     @After
     public void tearDown() {
         if (!testFile.delete()) {
             testFile.deleteOnExit();
         }
+
+        if (!testRandomAccessFile.delete()) {
+            testRandomAccessFile.deleteOnExit();
+        }
     }
 
-    @Test(expected=IllegalArgumentException.class)
+    @Test(expected = IllegalArgumentException.class)","[{'comment': 'You have reformatted whitespace for the rest of this class.\r\n\r\nIt makes it hard to see that you have not actually changed anything below this line other than whitespace. Can you unformat please.\r\n', 'commenter': 'aherbert'}, {'comment': 'It is possible to ignore white-space changes in GitHub reviews: https://github.blog/2018-05-01-ignore-white-space-in-code-review/', 'commenter': 'behrangsa'}, {'comment': 'Fixed.', 'commenter': 'behrangsa'}]"
31,src/test/java/org/apache/commons/codec/digest/MessageDigestAlgorithmsTest.java,"@@ -151,6 +156,25 @@ public void testDigestFile() throws IOException {
         Assert.assertArrayEquals(digestTestData(), DigestUtils.digest(DigestUtils.getDigest(messageDigestAlgorithm),getTestFile()));
     }
 
+    @Test
+    public void testNonBlockingDigestRandomAccessFile() throws IOException {
+        Assume.assumeTrue(DigestUtils.isAvailable(messageDigestAlgorithm));
+
+        final byte[] expected = digestTestData();
+
+        Assert.assertArrayEquals(expected,","[{'comment': 'In keeping with the rest of the class can you reformat the assertions to a single line. The 5 lines per assertion are very explicit.', 'commenter': 'aherbert'}, {'comment': 'Fixed.', 'commenter': 'behrangsa'}]"
35,src/test/java/org/apache/commons/codec/net/BCodecTest.java,"@@ -157,6 +158,7 @@ public void testDecodeObjects() throws Exception {
     }
 
     @Test
+    @Ignore(""CODEC-280: Disabled strict decoding by default. The BCodec uses the default so this test does not fail the impossible cases."")","[{'comment': ""@aherbert \r\nI think this test should be rewritten to match the new behavior, not `@Ignore`'d."", 'commenter': 'garydgregory'}, {'comment': 'The new behaviour is lenient. So that would be a behaviour change for BCodec and make this test redundant.\r\n\r\nI think that the new strict decoding property can be added here too so users have an option.', 'commenter': 'aherbert'}, {'comment': 'Hi @garydgregory \r\n\r\nI received an email from github with another comment from you but cannot find it through the web interface so I\'ll repeat for clarity the comment was ""I\'m all for making Base32 and Base64 carry the same option.""\r\n\r\nThis PR already has the public setStrictDecoding(boolean) for Base32 and Base64. The unresolved is whether the property should be added to BCodec as well. At the moment this test is ignored because BCodec cannot be made strict. So either:\r\n\r\n1. Drop the test and BCodec is always lenient\r\n2. Make BCodec always strict (this test will pass)\r\n3. Make BCodec have configurable strict/lenient decoding\r\n\r\nMy option would be number 3.', 'commenter': 'aherbert'}]"
35,src/main/java/org/apache/commons/codec/binary/BaseNCodec.java,"@@ -223,6 +230,47 @@ protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize,
         this.pad = pad;
     }
 
+    /**
+     * Sets the decoding behaviour when the input bytes contain leftover trailing bits that
+     * cannot be created by a valid encoding. These can be bits that are unused from the final
+     * character or entire characters. The default mode is lenient decoding. Set this to
+     * {@code true} to enable strict decoding.
+     * <ul>
+     * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible.
+     *     The remainder are discarded.
+     * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits
+     *     are not part of a valid encoding. Any unused bits from the final character must
+     *     be zero. Impossible counts of entire final characters are not allowed.
+     * </ul>
+     *
+     * <p>When strict decoding is enabled it is expected that the decoded bytes will be re-encoded
+     * to a byte array that matches the original, i.e. no changes occur on the final
+     * character. This requires that the input bytes use the same padding and alphabet
+     * as the encoder.
+     *
+     * @param strictDecoding Set to true to enable strict decoding; otherwise use lenient decoding.
+     * @see #encode(byte[])
+     * @since 1.15
+     */
+    public void setStrictDecoding(boolean strictDecoding) {","[{'comment': ""@aherbert looking at the [BaseNCodec](https://commons.apache.org/proper/commons-codec/archives/1.15/apidocs/org/apache/commons/codec/binary/BaseNCodec.html) Javadoc I can't find the **setStrictDecoding()** method, however **isStrictDecoding()** is available. Can you please double check?\r\n\r\nAnd following [your example](https://issues.apache.org/jira/browse/CODEC-280) for `codec.setStrictDecoding(true)` I'm getting a compilation error when using [commons-codec 1.15](https://search.maven.org/artifact/commons-codec/commons-codec/1.15/jar):\r\n```\r\nsymbol:   method setStrictDecoding(boolean)\r\nlocation: variable codec of type org.apache.commons.codec.binary.Base32\r\n```"", 'commenter': 'boris-github'}, {'comment': ""Oh, I see why. Browsing the history of the file, I found that it was modified in [Reimplement the new-in-1.15 BaseNCodec's and friends' strict vs. lenient](https://github.com/apache/commons-codec/commit/9f1b740a17f0d54366edfb45df0636b8e302666a#r46803902). Sadly the [release notes](https://commons.apache.org/proper/commons-codec/changes-report.html#a1.15) haven't been updated to reflect that.\r\n(cost me 2 hours)"", 'commenter': 'boris-github'}]"
46,src/main/java/org/apache/commons/codec/binary/Base16.java,"@@ -0,0 +1,251 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.binary;
+
+import org.apache.commons.codec.CodecPolicy;
+
+/**
+ * Provides Base16 encoding and decoding.
+ *
+ * <p>
+ * This class is thread-safe.
+ * </p>
+ *
+ * @see <a href=""https://tools.ietf.org/html/rfc4648#section-8"">RFC 4648 - 8. Base 16 Encoding</a>
+ *
+ * @since 1.15
+ */
+public class Base16 extends BaseNCodec {
+
+    /**
+     * BASE16 characters are 4 bits in length.
+     * They are formed by taking an 8-bit group,
+     * which is converted into two BASE16 characters.
+     */
+    private static final int BITS_PER_ENCODED_BYTE = 4;
+    private static final int BYTES_PER_ENCODED_BLOCK = 2;
+    private static final int BYTES_PER_UNENCODED_BLOCK = 1;
+
+    /**
+     * This array is a lookup table that translates Unicode characters drawn from the ""Base16 Alphabet"" (as specified
+     * in Table 5 of RFC 4648) into their 4-bit positive integer equivalents. Characters that are not in the Base16
+     * alphabet but fall within the bounds of the array are translated to -1.
+     */
+    private static final byte[] UPPER_CASE_DECODE_TABLE = {
+            //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f
+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 0-9
+            -1, 10, 11, 12, 13, 14, 15                                      // 40-46 A-F
+    };
+
+    /**
+     * This array is a lookup table that translates 4-bit positive integer index values into their ""Base16 Alphabet""
+     * equivalents as specified in Table 5 of RFC 4648.
+     */
+    private static final byte[] UPPER_CASE_ENCODE_TABLE = {
+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+            'A', 'B', 'C', 'D', 'E', 'F'
+    };
+
+    /**
+     * This array is a lookup table that translates Unicode characters drawn from the a lower-case ""Base16 Alphabet""
+     * into their 4-bit positive integer equivalents. Characters that are not in the Base16
+     * alphabet but fall within the bounds of the array are translated to -1.
+     */
+    private static final byte[] LOWER_CASE_DECODE_TABLE = {
+            //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f
+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 0-9
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 40-4f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 50-5f
+            -1, 10, 11, 12, 13, 14, 15                                      // 60-66 a-f
+    };
+
+    /**
+     * This array is a lookup table that translates 4-bit positive integer index values into their ""Base16 Alphabet""
+     * lower-case equivalents.
+     */
+    private static final byte[] LOWER_CASE_ENCODE_TABLE = {
+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+            'a', 'b', 'c', 'd', 'e', 'f'
+    };
+
+    /** Mask used to extract 4 bits, used when decoding character. */
+    private static final int MASK_4BITS = 0x0f;
+
+    /**
+     * Decode table to use.
+     */
+    private final byte[] decodeTable;
+
+    /**
+     * Encode table to use.
+     */
+    private final byte[] encodeTable;
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     */
+    public Base16() {
+        this(false);
+    }
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     *
+     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.
+     */
+    public Base16(final boolean lowerCase) {
+        this(lowerCase, DECODING_POLICY_DEFAULT);
+    }
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     *
+     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.
+     * @param decodingPolicy Decoding policy.
+     */
+    public Base16(final boolean lowerCase, final CodecPolicy decodingPolicy) {
+        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, 0, 0,
+                PAD_DEFAULT, decodingPolicy);
+        if (lowerCase) {
+            this.encodeTable = LOWER_CASE_ENCODE_TABLE;
+            this.decodeTable = LOWER_CASE_DECODE_TABLE;
+        } else {
+            this.encodeTable = UPPER_CASE_ENCODE_TABLE;
+            this.decodeTable = UPPER_CASE_DECODE_TABLE;
+        }
+    }
+
+    @Override
+    void decode(final byte[] data, int offset, final int length, final Context context) {
+        if (context.eof || length < 0) {
+            context.eof = true;
+            if (context.ibitWorkArea > 0) {","[{'comment': '`ibitWorkArea != 0`', 'commenter': 'aherbert'}, {'comment': 'Okay.', 'commenter': 'adamretter'}]"
46,src/main/java/org/apache/commons/codec/binary/Base16.java,"@@ -0,0 +1,251 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.binary;
+
+import org.apache.commons.codec.CodecPolicy;
+
+/**
+ * Provides Base16 encoding and decoding.
+ *
+ * <p>
+ * This class is thread-safe.
+ * </p>
+ *
+ * @see <a href=""https://tools.ietf.org/html/rfc4648#section-8"">RFC 4648 - 8. Base 16 Encoding</a>
+ *
+ * @since 1.15
+ */
+public class Base16 extends BaseNCodec {
+
+    /**
+     * BASE16 characters are 4 bits in length.
+     * They are formed by taking an 8-bit group,
+     * which is converted into two BASE16 characters.
+     */
+    private static final int BITS_PER_ENCODED_BYTE = 4;
+    private static final int BYTES_PER_ENCODED_BLOCK = 2;
+    private static final int BYTES_PER_UNENCODED_BLOCK = 1;
+
+    /**
+     * This array is a lookup table that translates Unicode characters drawn from the ""Base16 Alphabet"" (as specified
+     * in Table 5 of RFC 4648) into their 4-bit positive integer equivalents. Characters that are not in the Base16
+     * alphabet but fall within the bounds of the array are translated to -1.
+     */
+    private static final byte[] UPPER_CASE_DECODE_TABLE = {
+            //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f
+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 0-9
+            -1, 10, 11, 12, 13, 14, 15                                      // 40-46 A-F
+    };
+
+    /**
+     * This array is a lookup table that translates 4-bit positive integer index values into their ""Base16 Alphabet""
+     * equivalents as specified in Table 5 of RFC 4648.
+     */
+    private static final byte[] UPPER_CASE_ENCODE_TABLE = {
+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+            'A', 'B', 'C', 'D', 'E', 'F'
+    };
+
+    /**
+     * This array is a lookup table that translates Unicode characters drawn from the a lower-case ""Base16 Alphabet""
+     * into their 4-bit positive integer equivalents. Characters that are not in the Base16
+     * alphabet but fall within the bounds of the array are translated to -1.
+     */
+    private static final byte[] LOWER_CASE_DECODE_TABLE = {
+            //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f
+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 0-9
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 40-4f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 50-5f
+            -1, 10, 11, 12, 13, 14, 15                                      // 60-66 a-f
+    };
+
+    /**
+     * This array is a lookup table that translates 4-bit positive integer index values into their ""Base16 Alphabet""
+     * lower-case equivalents.
+     */
+    private static final byte[] LOWER_CASE_ENCODE_TABLE = {
+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+            'a', 'b', 'c', 'd', 'e', 'f'
+    };
+
+    /** Mask used to extract 4 bits, used when decoding character. */
+    private static final int MASK_4BITS = 0x0f;
+
+    /**
+     * Decode table to use.
+     */
+    private final byte[] decodeTable;
+
+    /**
+     * Encode table to use.
+     */
+    private final byte[] encodeTable;
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     */
+    public Base16() {
+        this(false);
+    }
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     *
+     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.
+     */
+    public Base16(final boolean lowerCase) {
+        this(lowerCase, DECODING_POLICY_DEFAULT);
+    }
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     *
+     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.
+     * @param decodingPolicy Decoding policy.
+     */
+    public Base16(final boolean lowerCase, final CodecPolicy decodingPolicy) {
+        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, 0, 0,
+                PAD_DEFAULT, decodingPolicy);
+        if (lowerCase) {
+            this.encodeTable = LOWER_CASE_ENCODE_TABLE;
+            this.decodeTable = LOWER_CASE_DECODE_TABLE;
+        } else {
+            this.encodeTable = UPPER_CASE_ENCODE_TABLE;
+            this.decodeTable = UPPER_CASE_DECODE_TABLE;
+        }
+    }
+
+    @Override
+    void decode(final byte[] data, int offset, final int length, final Context context) {
+        if (context.eof || length < 0) {
+            context.eof = true;
+            if (context.ibitWorkArea > 0) {
+                validateTrailingCharacter();
+            }
+            return;
+        }
+
+        final int dataLen = Math.min(data.length - offset, length);
+        final int availableChars = (context.ibitWorkArea > 0 ? 1 : 0) + dataLen;
+
+        // small optimisation to short-cut the rest of this method when it is fed byte-by-byte
+        if (availableChars == 1 && availableChars == dataLen) {
+            context.ibitWorkArea = decodeOctet(data[offset]) + 1;   // store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0
+            return;
+        }
+
+        // we must have an even number of chars to decode
+        final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1;
+
+        final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context);
+
+        int result;
+        int i = 0;
+        if (dataLen < availableChars) {
+            // we have 1/2 byte from previous invocation to decode
+            result = (context.ibitWorkArea - 1) << BITS_PER_ENCODED_BYTE;
+            result |= decodeOctet(data[offset++]);
+            i = 2;
+
+            buffer[context.pos++] = (byte)result;
+
+            // reset to empty-value for next invocation!
+            context.ibitWorkArea = 0;
+        }
+
+        while (i < charsToProcess) {
+            result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE;
+            result |= decodeOctet(data[offset++]);
+            i += 2;
+            buffer[context.pos++] = (byte)result;
+        }
+
+        // we have one char of a hex-pair left over
+        if (i < dataLen) {
+            context.ibitWorkArea = decodeOctet(data[i]) + 1;   // store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0
+        }
+    }
+
+    private int decodeOctet(final byte octet) {
+        int decoded = -1;
+        if (octet >= 0 && octet < decodeTable.length) {
+            decoded = decodeTable[octet];
+        }
+
+        if (decoded == -1) {
+            throw new IllegalArgumentException(""Invalid octet in encoded value: "" + (int)octet);
+        }
+
+        return decoded;
+    }
+
+    @Override
+    void encode(final byte[] data, final int offset, final int length, final Context context) {
+        if (context.eof) {
+            return;
+        }
+
+        if (length < 0) {
+            context.eof = true;
+            return;
+        }
+
+        final byte[] buffer = ensureBufferSize(length * BYTES_PER_ENCODED_BLOCK, context);
+
+        final int end = offset + length;
+        for (int i = offset; i < end; i++) {
+            final int value = data[i];
+            final int high = (value >> BITS_PER_ENCODED_BYTE) & MASK_4BITS;
+            final int low = value & MASK_4BITS;
+            buffer[context.pos++] = encodeTable[high];
+            buffer[context.pos++] = encodeTable[low];
+        }
+    }
+
+    /**
+     * Returns whether or not the {@code octet} is in the Base16 alphabet.
+     *
+     * @param octet The value to test.
+     *
+     * @return {@code true} if the value is defined in the the Base16 alphabet {@code false} otherwise.
+     */
+    @Override
+    public boolean isInAlphabet(final byte octet) {
+        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;","[{'comment': 'To avoid checking if the octet is not negative you could convert as unsigned:\r\n\r\n`(octet & 0xff) < decodeTable.length && decodeTable[octet] != -1`\r\n\r\n', 'commenter': 'aherbert'}, {'comment': ""That's slightly nicer, thanks"", 'commenter': 'adamretter'}]"
46,src/main/java/org/apache/commons/codec/binary/Base16.java,"@@ -0,0 +1,251 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.binary;
+
+import org.apache.commons.codec.CodecPolicy;
+
+/**
+ * Provides Base16 encoding and decoding.
+ *
+ * <p>
+ * This class is thread-safe.
+ * </p>
+ *
+ * @see <a href=""https://tools.ietf.org/html/rfc4648#section-8"">RFC 4648 - 8. Base 16 Encoding</a>
+ *
+ * @since 1.15
+ */
+public class Base16 extends BaseNCodec {
+
+    /**
+     * BASE16 characters are 4 bits in length.
+     * They are formed by taking an 8-bit group,
+     * which is converted into two BASE16 characters.
+     */
+    private static final int BITS_PER_ENCODED_BYTE = 4;
+    private static final int BYTES_PER_ENCODED_BLOCK = 2;
+    private static final int BYTES_PER_UNENCODED_BLOCK = 1;
+
+    /**
+     * This array is a lookup table that translates Unicode characters drawn from the ""Base16 Alphabet"" (as specified
+     * in Table 5 of RFC 4648) into their 4-bit positive integer equivalents. Characters that are not in the Base16
+     * alphabet but fall within the bounds of the array are translated to -1.
+     */
+    private static final byte[] UPPER_CASE_DECODE_TABLE = {
+            //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f
+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 0-9
+            -1, 10, 11, 12, 13, 14, 15                                      // 40-46 A-F
+    };
+
+    /**
+     * This array is a lookup table that translates 4-bit positive integer index values into their ""Base16 Alphabet""
+     * equivalents as specified in Table 5 of RFC 4648.
+     */
+    private static final byte[] UPPER_CASE_ENCODE_TABLE = {
+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+            'A', 'B', 'C', 'D', 'E', 'F'
+    };
+
+    /**
+     * This array is a lookup table that translates Unicode characters drawn from the a lower-case ""Base16 Alphabet""
+     * into their 4-bit positive integer equivalents. Characters that are not in the Base16
+     * alphabet but fall within the bounds of the array are translated to -1.
+     */
+    private static final byte[] LOWER_CASE_DECODE_TABLE = {
+            //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f
+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 0-9
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 40-4f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 50-5f
+            -1, 10, 11, 12, 13, 14, 15                                      // 60-66 a-f
+    };
+
+    /**
+     * This array is a lookup table that translates 4-bit positive integer index values into their ""Base16 Alphabet""
+     * lower-case equivalents.
+     */
+    private static final byte[] LOWER_CASE_ENCODE_TABLE = {
+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+            'a', 'b', 'c', 'd', 'e', 'f'
+    };
+
+    /** Mask used to extract 4 bits, used when decoding character. */
+    private static final int MASK_4BITS = 0x0f;
+
+    /**
+     * Decode table to use.
+     */
+    private final byte[] decodeTable;
+
+    /**
+     * Encode table to use.
+     */
+    private final byte[] encodeTable;
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     */
+    public Base16() {
+        this(false);
+    }
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     *
+     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.
+     */
+    public Base16(final boolean lowerCase) {
+        this(lowerCase, DECODING_POLICY_DEFAULT);
+    }
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     *
+     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.
+     * @param decodingPolicy Decoding policy.
+     */
+    public Base16(final boolean lowerCase, final CodecPolicy decodingPolicy) {
+        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, 0, 0,
+                PAD_DEFAULT, decodingPolicy);
+        if (lowerCase) {
+            this.encodeTable = LOWER_CASE_ENCODE_TABLE;
+            this.decodeTable = LOWER_CASE_DECODE_TABLE;
+        } else {
+            this.encodeTable = UPPER_CASE_ENCODE_TABLE;
+            this.decodeTable = UPPER_CASE_DECODE_TABLE;
+        }
+    }
+
+    @Override
+    void decode(final byte[] data, int offset, final int length, final Context context) {
+        if (context.eof || length < 0) {
+            context.eof = true;
+            if (context.ibitWorkArea > 0) {
+                validateTrailingCharacter();
+            }
+            return;
+        }
+
+        final int dataLen = Math.min(data.length - offset, length);
+        final int availableChars = (context.ibitWorkArea > 0 ? 1 : 0) + dataLen;
+
+        // small optimisation to short-cut the rest of this method when it is fed byte-by-byte
+        if (availableChars == 1 && availableChars == dataLen) {
+            context.ibitWorkArea = decodeOctet(data[offset]) + 1;   // store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0
+            return;
+        }
+
+        // we must have an even number of chars to decode
+        final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1;
+
+        final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context);
+
+        int result;
+        int i = 0;
+        if (dataLen < availableChars) {
+            // we have 1/2 byte from previous invocation to decode
+            result = (context.ibitWorkArea - 1) << BITS_PER_ENCODED_BYTE;
+            result |= decodeOctet(data[offset++]);
+            i = 2;
+
+            buffer[context.pos++] = (byte)result;
+
+            // reset to empty-value for next invocation!
+            context.ibitWorkArea = 0;
+        }
+
+        while (i < charsToProcess) {
+            result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE;
+            result |= decodeOctet(data[offset++]);
+            i += 2;
+            buffer[context.pos++] = (byte)result;
+        }
+
+        // we have one char of a hex-pair left over
+        if (i < dataLen) {
+            context.ibitWorkArea = decodeOctet(data[i]) + 1;   // store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0
+        }
+    }
+
+    private int decodeOctet(final byte octet) {
+        int decoded = -1;
+        if (octet >= 0 && octet < decodeTable.length) {
+            decoded = decodeTable[octet];
+        }
+
+        if (decoded == -1) {
+            throw new IllegalArgumentException(""Invalid octet in encoded value: "" + (int)octet);
+        }
+
+        return decoded;
+    }
+
+    @Override
+    void encode(final byte[] data, final int offset, final int length, final Context context) {
+        if (context.eof) {
+            return;
+        }
+
+        if (length < 0) {
+            context.eof = true;
+            return;
+        }
+
+        final byte[] buffer = ensureBufferSize(length * BYTES_PER_ENCODED_BLOCK, context);
+
+        final int end = offset + length;
+        for (int i = offset; i < end; i++) {
+            final int value = data[i];
+            final int high = (value >> BITS_PER_ENCODED_BYTE) & MASK_4BITS;
+            final int low = value & MASK_4BITS;
+            buffer[context.pos++] = encodeTable[high];
+            buffer[context.pos++] = encodeTable[low];
+        }
+    }
+
+    /**
+     * Returns whether or not the {@code octet} is in the Base16 alphabet.
+     *
+     * @param octet The value to test.
+     *
+     * @return {@code true} if the value is defined in the the Base16 alphabet {@code false} otherwise.
+     */
+    @Override
+    public boolean isInAlphabet(final byte octet) {","[{'comment': 'I am not convinced by the two decode tables. Is there any reason that you would not want to support case-insensitive decoding? Currently if I want to decode some hex encoded data I have to know before decoding if the hex uses upper or lower case and create the correct decoder.\r\n\r\nBase32 supports case insensitive decoding when used in Hex mode.\r\n\r\nBase64 supports decoding of both URL-safe and standard encoding by default.\r\n\r\nThe Hex class which delegates to `Character.digit(ch, 16)` will handle mixed case input hex.\r\n\r\nThe upside of forcing a case is that data encoded using both upper and lower case characters will be reported as invalid. Is this something in RFC 4648?\r\n\r\n', 'commenter': 'aherbert'}, {'comment': ""Yes exactly! I want this to be spec compliant, not something that might produce unexpected behaviour. If you don't know if the hex you are decoding is upper or lower case, I think you have bigger problems... i.e. are you sure it is even valid hex?"", 'commenter': 'adamretter'}, {'comment': ""I think there are two issues here:\r\n\r\n- Not knowing if the hex is upper or lower case, but it must use exclusively one or the other\r\n- Not allowing mixed case hex\r\n\r\nIdeally the most flexible decoder would have a 3rd mode for case insensitive decoding. This would apply to decoding only. It would work using a 3rd decoding table that combines the upper and lower case tables.\r\n\r\nHowever allowing mixed case in the same input is not really valid. So the decoder would have to detect the first A-F character and ensure the same case is used for the rest. An exception can be raised if not. This can even be covered by the strict/lenient decoding policy. Tracking the first A-F character is a lot of extra code so I don't like this idea.\r\n\r\nWhat do you think to using the decoding policy to cover this? The constructor accepts the upper/lower case flag for encoding and the strict/lenient decoding flag. If using strict decoding the case must match. If lenient mode then decoding is case insensitive. After all, if we are allowing a trailing character to be discarded, then allowing upper or lower case hex seems no worse a violation of a true encoding.\r\n"", 'commenter': 'aherbert'}, {'comment': 'I think it is not a bad suggestion, but I also think this is perhaps feature/scope creep. My goal was to implement the decoder according to the RFC. What you have suggested sounds like an additional feature which could be added later without issue. I would rather get this PR merged as it is. Is that okay with you?', 'commenter': 'adamretter'}, {'comment': 'OK.\r\n\r\nThe idea of using the lenient decoding to cover both case insensitive decoding and allowing trailing characters is a mash up. A case insensitive decoding table can be added as an option later. After all, you may wish to support case insensitive decoding but enforce no trailing characters.', 'commenter': 'aherbert'}]"
46,src/main/java/org/apache/commons/codec/binary/Base16.java,"@@ -0,0 +1,251 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.binary;
+
+import org.apache.commons.codec.CodecPolicy;
+
+/**
+ * Provides Base16 encoding and decoding.
+ *
+ * <p>
+ * This class is thread-safe.
+ * </p>
+ *
+ * @see <a href=""https://tools.ietf.org/html/rfc4648#section-8"">RFC 4648 - 8. Base 16 Encoding</a>
+ *
+ * @since 1.15
+ */
+public class Base16 extends BaseNCodec {
+
+    /**
+     * BASE16 characters are 4 bits in length.
+     * They are formed by taking an 8-bit group,
+     * which is converted into two BASE16 characters.
+     */
+    private static final int BITS_PER_ENCODED_BYTE = 4;
+    private static final int BYTES_PER_ENCODED_BLOCK = 2;
+    private static final int BYTES_PER_UNENCODED_BLOCK = 1;
+
+    /**
+     * This array is a lookup table that translates Unicode characters drawn from the ""Base16 Alphabet"" (as specified
+     * in Table 5 of RFC 4648) into their 4-bit positive integer equivalents. Characters that are not in the Base16
+     * alphabet but fall within the bounds of the array are translated to -1.
+     */
+    private static final byte[] UPPER_CASE_DECODE_TABLE = {
+            //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f
+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 0-9
+            -1, 10, 11, 12, 13, 14, 15                                      // 40-46 A-F
+    };
+
+    /**
+     * This array is a lookup table that translates 4-bit positive integer index values into their ""Base16 Alphabet""
+     * equivalents as specified in Table 5 of RFC 4648.
+     */
+    private static final byte[] UPPER_CASE_ENCODE_TABLE = {
+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+            'A', 'B', 'C', 'D', 'E', 'F'
+    };
+
+    /**
+     * This array is a lookup table that translates Unicode characters drawn from the a lower-case ""Base16 Alphabet""
+     * into their 4-bit positive integer equivalents. Characters that are not in the Base16
+     * alphabet but fall within the bounds of the array are translated to -1.
+     */
+    private static final byte[] LOWER_CASE_DECODE_TABLE = {
+            //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f
+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 0-9
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 40-4f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 50-5f
+            -1, 10, 11, 12, 13, 14, 15                                      // 60-66 a-f
+    };
+
+    /**
+     * This array is a lookup table that translates 4-bit positive integer index values into their ""Base16 Alphabet""
+     * lower-case equivalents.
+     */
+    private static final byte[] LOWER_CASE_ENCODE_TABLE = {
+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+            'a', 'b', 'c', 'd', 'e', 'f'
+    };
+
+    /** Mask used to extract 4 bits, used when decoding character. */
+    private static final int MASK_4BITS = 0x0f;
+
+    /**
+     * Decode table to use.
+     */
+    private final byte[] decodeTable;
+
+    /**
+     * Encode table to use.
+     */
+    private final byte[] encodeTable;
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     */
+    public Base16() {
+        this(false);
+    }
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     *
+     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.
+     */
+    public Base16(final boolean lowerCase) {
+        this(lowerCase, DECODING_POLICY_DEFAULT);
+    }
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     *
+     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.
+     * @param decodingPolicy Decoding policy.
+     */
+    public Base16(final boolean lowerCase, final CodecPolicy decodingPolicy) {
+        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, 0, 0,
+                PAD_DEFAULT, decodingPolicy);
+        if (lowerCase) {
+            this.encodeTable = LOWER_CASE_ENCODE_TABLE;
+            this.decodeTable = LOWER_CASE_DECODE_TABLE;
+        } else {
+            this.encodeTable = UPPER_CASE_ENCODE_TABLE;
+            this.decodeTable = UPPER_CASE_DECODE_TABLE;
+        }
+    }
+
+    @Override
+    void decode(final byte[] data, int offset, final int length, final Context context) {
+        if (context.eof || length < 0) {
+            context.eof = true;
+            if (context.ibitWorkArea > 0) {
+                validateTrailingCharacter();
+            }
+            return;
+        }
+
+        final int dataLen = Math.min(data.length - offset, length);
+        final int availableChars = (context.ibitWorkArea > 0 ? 1 : 0) + dataLen;
+
+        // small optimisation to short-cut the rest of this method when it is fed byte-by-byte
+        if (availableChars == 1 && availableChars == dataLen) {
+            context.ibitWorkArea = decodeOctet(data[offset]) + 1;   // store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0
+            return;
+        }
+
+        // we must have an even number of chars to decode
+        final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1;
+
+        final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context);
+
+        int result;
+        int i = 0;
+        if (dataLen < availableChars) {
+            // we have 1/2 byte from previous invocation to decode
+            result = (context.ibitWorkArea - 1) << BITS_PER_ENCODED_BYTE;
+            result |= decodeOctet(data[offset++]);
+            i = 2;
+
+            buffer[context.pos++] = (byte)result;
+
+            // reset to empty-value for next invocation!
+            context.ibitWorkArea = 0;
+        }
+
+        while (i < charsToProcess) {
+            result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE;
+            result |= decodeOctet(data[offset++]);
+            i += 2;
+            buffer[context.pos++] = (byte)result;
+        }
+
+        // we have one char of a hex-pair left over
+        if (i < dataLen) {
+            context.ibitWorkArea = decodeOctet(data[i]) + 1;   // store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0
+        }
+    }
+
+    private int decodeOctet(final byte octet) {
+        int decoded = -1;
+        if (octet >= 0 && octet < decodeTable.length) {","[{'comment': 'Avoid the `>= 0` using `(octet & 0xff) < decodeTable.length`', 'commenter': 'aherbert'}]"
46,src/main/java/org/apache/commons/codec/binary/BaseNCodec.java,"@@ -567,7 +567,7 @@ public String encodeToString(final byte[] pArray) {
      */
     protected byte[] ensureBufferSize(final int size, final Context context){
         if (context.buffer == null) {
-            context.buffer = new byte[getDefaultBufferSize()];
+            context.buffer = new byte[Math.max(size, getDefaultBufferSize())];","[{'comment': 'Nice spot. Previously it was not relevant as the buffer is expanded continuously inside the decoding loop. Base32 and Base64 can (should) be similarly optimised. Something for another improvement.', 'commenter': 'aherbert'}]"
46,src/main/java/org/apache/commons/codec/binary/Hex.java,"@@ -54,13 +54,13 @@
     /**
      * Used to build output as Hex
      */
-    private static final char[] DIGITS_LOWER = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd',
+    static final char[] DIGITS_LOWER = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd',","[{'comment': 'All the changes to Hex are no longer required since Base16 no longer delegates encoding/decoding to the Hex class.\r\n\r\nThe changes are to either package-private or protected scope and so will not be usable API. There is one public method to decode part of an array:\r\n```java\r\npublic static int decodeHex(final char[] data, final byte[] out, final int outOffset)\r\n```\r\n\r\nThis perhaps should have been protected/package private utility method anyway.\r\n\r\nI think all changes in this class can be removed.\r\n', 'commenter': 'aherbert'}]"
46,src/test/java/org/apache/commons/codec/binary/Base16TestData.java,"@@ -0,0 +1,111 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.binary;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Random;
+
+/**
+ * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between
+ * Commons-Codec and OpenSSL.
+ *
+ * @since 1.15
+ */
+public class Base16TestData {
+
+    final static String ENCODED_UTF8_LOWERCASE
+            = ""f483cd2b052f74b888029e9cb73d764a2426386b2d5b262f48f79ebee7c386bcdac2ceb9be8ca42a36c88f7dd85936bdc40edcfc51f2a56725ad9850ee89df737244f77049e5f4f847dcc011d8db8f2d61bf8658367113e1625e5cc2c9ff9a7ea81a53b0fa5ea56f03355632d5cd36ff5c320be92003a0af45477d712aff96df3c00476c4d5e063029f5f84c2e02261d8afc6ece7f9c2ccf2ada37b0aa5239dad3fd27b0acf2fa86ef5b3af960042cabe6fd4a2fbf268e8be39d3147e343424b88b907bbaa7d3b0520bd0aa20cacc4bff02e828d1d4cf67360613208fe4656b95edd041d81c8881e7a5d7785544cf19151b5de29b87ef94ddf6c922783fb105ccdc8601c8c67bc6df47592d4b51c45d43b3ebc27fc89505b138c7aaf8a6494a802f896b5db1ead7c876c811afff866af8a7f8fcd24d20f6adf986ad5ac8633df7ce002d349a67c59ec856d9c750b10bf428a9ff76507ff2941467489367e2c4b4a1adee51b36f3a7a640780fd57b52df5ab629c226bc3ec2225c325fbd929db9d48531046038714c61d1e6b19373835a7c08f79124b6658e2b00923f4c635b020cc438f2830006e51f1f93d1fd6d58b5b6131abe6e270dce2f68da1213546764d6306e25159553ccf44725bc959359dea2816780d0cc47000f2238ce559e6aa9fd618ced40eae7dac121d3500a879325a02412d02e2cbe73a2039ae5ef8ccd58ef0793184253a569a4ed42b440a576b967855f11a9eef542b67e2d53f2324f142d8f99779bc69d1b9cef955be6e0c8474822421009a66ad4c2960b72ae88e4bd049d6deced00d892892afa04e1436e9735764c6082f8a0279a346a401a979499a08c7400a0735928e99afee2103acbdf0e7aa271874399fc8262e57cf478c0d47f2d88327ce557ecac51dd71b3c0a0d0a98bae5ac094877dd3ced4d0ce34e2bef92ed8d155d4828618ac157863b61b0bcc20fe7a9c8a6af7966ded472a7e42c80acdd4446df3519341793cbc8b7ec50495ea63b3541d5777c45752c9b62cb0037b9b54d40947185b6316bf0bf5f2daac699babef74bf76977ab571c7afdf921c68e892c7b226fbf1b157695529d68ebd85460c3d730517ba6360b041bf69d3cf25dfff77a86479e7ddcd0a2b8f3d672c0d6c144a13351325b414d5f517c6e7cc79d88a3a3213f8dfe2cfe5f5b05def225d456442ca287659cca902238812406c1fe7424e06a5bbcb110e8321e1920105d8077e8654c9c2ea45e4052d96784a5e334a6cede6f43140584429bf7e7dfff8adbd4a028eb089f7a783155f22c6b66f99635f302a5ecec990fbe60ba7daed7e19667751a246b1625bb7720f0e57eb86ffa6001d98a5a3c6add0ea6490d74d16e870b8696406aad928d523fe04a2618734ea017faffcfa896023a572515b5aaadc22d95dd64567f56ba977958ed380bb60"";
+
+    final static String ENCODED_UTF8_UPPERCASE
+            = ""F483CD2B052F74B888029E9CB73D764A2426386B2D5B262F48F79EBEE7C386BCDAC2CEB9BE8CA42A36C88F7DD85936BDC40EDCFC51F2A56725AD9850EE89DF737244F77049E5F4F847DCC011D8DB8F2D61BF8658367113E1625E5CC2C9FF9A7EA81A53B0FA5EA56F03355632D5CD36FF5C320BE92003A0AF45477D712AFF96DF3C00476C4D5E063029F5F84C2E02261D8AFC6ECE7F9C2CCF2ADA37B0AA5239DAD3FD27B0ACF2FA86EF5B3AF960042CABE6FD4A2FBF268E8BE39D3147E343424B88B907BBAA7D3B0520BD0AA20CACC4BFF02E828D1D4CF67360613208FE4656B95EDD041D81C8881E7A5D7785544CF19151B5DE29B87EF94DDF6C922783FB105CCDC8601C8C67BC6DF47592D4B51C45D43B3EBC27FC89505B138C7AAF8A6494A802F896B5DB1EAD7C876C811AFFF866AF8A7F8FCD24D20F6ADF986AD5AC8633DF7CE002D349A67C59EC856D9C750B10BF428A9FF76507FF2941467489367E2C4B4A1ADEE51B36F3A7A640780FD57B52DF5AB629C226BC3EC2225C325FBD929DB9D48531046038714C61D1E6B19373835A7C08F79124B6658E2B00923F4C635B020CC438F2830006E51F1F93D1FD6D58B5B6131ABE6E270DCE2F68DA1213546764D6306E25159553CCF44725BC959359DEA2816780D0CC47000F2238CE559E6AA9FD618CED40EAE7DAC121D3500A879325A02412D02E2CBE73A2039AE5EF8CCD58EF0793184253A569A4ED42B440A576B967855F11A9EEF542B67E2D53F2324F142D8F99779BC69D1B9CEF955BE6E0C8474822421009A66AD4C2960B72AE88E4BD049D6DECED00D892892AFA04E1436E9735764C6082F8A0279A346A401A979499A08C7400A0735928E99AFEE2103ACBDF0E7AA271874399FC8262E57CF478C0D47F2D88327CE557ECAC51DD71B3C0A0D0A98BAE5AC094877DD3CED4D0CE34E2BEF92ED8D155D4828618AC157863B61B0BCC20FE7A9C8A6AF7966DED472A7E42C80ACDD4446DF3519341793CBC8B7EC50495EA63B3541D5777C45752C9B62CB0037B9B54D40947185B6316BF0BF5F2DAAC699BABEF74BF76977AB571C7AFDF921C68E892C7B226FBF1B157695529D68EBD85460C3D730517BA6360B041BF69D3CF25DFFF77A86479E7DDCD0A2B8F3D672C0D6C144A13351325B414D5F517C6E7CC79D88A3A3213F8DFE2CFE5F5B05DEF225D456442CA287659CCA902238812406C1FE7424E06A5BBCB110E8321E1920105D8077E8654C9C2EA45E4052D96784A5E334A6CEDE6F43140584429BF7E7DFFF8ADBD4A028EB089F7A783155F22C6B66F99635F302A5ECEC990FBE60BA7DAED7E19667751A246B1625BB7720F0E57EB86FFA6001D98A5A3C6ADD0EA6490D74D16E870B8696406AAD928D523FE04A2618734EA017FAFFCFA896023A572515B5AAADC22D95DD64567F56BA977958ED380BB60"";
+
+    final static byte[] DECODED
+            = {-12, -125, -51, 43, 5, 47, 116, -72, -120, 2, -98, -100, -73, 61, 118, 74, 36, 38, 56, 107, 45, 91, 38,
+            47, 72, -9, -98, -66, -25, -61, -122, -68, -38, -62, -50, -71, -66, -116, -92, 42, 54, -56, -113, 125,
+            -40, 89, 54, -67, -60, 14, -36, -4, 81, -14, -91, 103, 37, -83, -104, 80, -18, -119, -33, 115, 114, 68,
+            -9, 112, 73, -27, -12, -8, 71, -36, -64, 17, -40, -37, -113, 45, 97, -65, -122, 88, 54, 113, 19, -31, 98,
+            94, 92, -62, -55, -1, -102, 126, -88, 26, 83, -80, -6, 94, -91, 111, 3, 53, 86, 50, -43, -51, 54, -1, 92,
+            50, 11, -23, 32, 3, -96, -81, 69, 71, 125, 113, 42, -1, -106, -33, 60, 0, 71, 108, 77, 94, 6, 48, 41, -11,
+            -8, 76, 46, 2, 38, 29, -118, -4, 110, -50, 127, -100, 44, -49, 42, -38, 55, -80, -86, 82, 57, -38, -45,
+            -3, 39, -80, -84, -14, -6, -122, -17, 91, 58, -7, 96, 4, 44, -85, -26, -3, 74, 47, -65, 38, -114, -117,
+            -29, -99, 49, 71, -29, 67, 66, 75, -120, -71, 7, -69, -86, 125, 59, 5, 32, -67, 10, -94, 12, -84, -60, -65,
+            -16, 46, -126, -115, 29, 76, -10, 115, 96, 97, 50, 8, -2, 70, 86, -71, 94, -35, 4, 29, -127, -56, -120,
+            30, 122, 93, 119, -123, 84, 76, -15, -111, 81, -75, -34, 41, -72, 126, -7, 77, -33, 108, -110, 39, -125,
+            -5, 16, 92, -51, -56, 96, 28, -116, 103, -68, 109, -12, 117, -110, -44, -75, 28, 69, -44, 59, 62, -68,
+            39, -4, -119, 80, 91, 19, -116, 122, -81, -118, 100, -108, -88, 2, -8, -106, -75, -37, 30, -83, 124, -121,
+            108, -127, 26, -1, -8, 102, -81, -118, 127, -113, -51, 36, -46, 15, 106, -33, -104, 106, -43, -84, -122,
+            51, -33, 124, -32, 2, -45, 73, -90, 124, 89, -20, -123, 109, -100, 117, 11, 16, -65, 66, -118, -97, -9,
+            101, 7, -1, 41, 65, 70, 116, -119, 54, 126, 44, 75, 74, 26, -34, -27, 27, 54, -13, -89, -90, 64, 120, 15,
+            -43, 123, 82, -33, 90, -74, 41, -62, 38, -68, 62, -62, 34, 92, 50, 95, -67, -110, -99, -71, -44, -123,
+            49, 4, 96, 56, 113, 76, 97, -47, -26, -79, -109, 115, -125, 90, 124, 8, -9, -111, 36, -74, 101, -114, 43,
+            0, -110, 63, 76, 99, 91, 2, 12, -60, 56, -14, -125, 0, 6, -27, 31, 31, -109, -47, -3, 109, 88, -75, -74,
+            19, 26, -66, 110, 39, 13, -50, 47, 104, -38, 18, 19, 84, 103, 100, -42, 48, 110, 37, 21, -107, 83, -52,
+            -12, 71, 37, -68, -107, -109, 89, -34, -94, -127, 103, -128, -48, -52, 71, 0, 15, 34, 56, -50, 85, -98,
+            106, -87, -3, 97, -116, -19, 64, -22, -25, -38, -63, 33, -45, 80, 10, -121, -109, 37, -96, 36, 18, -48,
+            46, 44, -66, 115, -94, 3, -102, -27, -17, -116, -51, 88, -17, 7, -109, 24, 66, 83, -91, 105, -92, -19,
+            66, -76, 64, -91, 118, -71, 103, -123, 95, 17, -87, -18, -11, 66, -74, 126, 45, 83, -14, 50, 79, 20, 45,
+            -113, -103, 119, -101, -58, -99, 27, -100, -17, -107, 91, -26, -32, -56, 71, 72, 34, 66, 16, 9, -90, 106,
+            -44, -62, -106, 11, 114, -82, -120, -28, -67, 4, -99, 109, -20, -19, 0, -40, -110, -119, 42, -6, 4, -31,
+            67, 110, -105, 53, 118, 76, 96, -126, -8, -96, 39, -102, 52, 106, 64, 26, -105, -108, -103, -96, -116,
+            116, 0, -96, 115, 89, 40, -23, -102, -2, -30, 16, 58, -53, -33, 14, 122, -94, 113, -121, 67, -103, -4,
+            -126, 98, -27, 124, -12, 120, -64, -44, 127, 45, -120, 50, 124, -27, 87, -20, -84, 81, -35, 113, -77,
+            -64, -96, -48, -87, -117, -82, 90, -64, -108, -121, 125, -45, -50, -44, -48, -50, 52, -30, -66, -7, 46,
+            -40, -47, 85, -44, -126, -122, 24, -84, 21, 120, 99, -74, 27, 11, -52, 32, -2, 122, -100, -118, 106, -9,
+            -106, 109, -19, 71, 42, 126, 66, -56, 10, -51, -44, 68, 109, -13, 81, -109, 65, 121, 60, -68, -117, 126,
+            -59, 4, -107, -22, 99, -77, 84, 29, 87, 119, -60, 87, 82, -55, -74, 44, -80, 3, 123, -101, 84, -44, 9, 71,
+            24, 91, 99, 22, -65, 11, -11, -14, -38, -84, 105, -101, -85, -17, 116, -65, 118, -105, 122, -75, 113,
+            -57, -81, -33, -110, 28, 104, -24, -110, -57, -78, 38, -5, -15, -79, 87, 105, 85, 41, -42, -114, -67,
+            -123, 70, 12, 61, 115, 5, 23, -70, 99, 96, -80, 65, -65, 105, -45, -49, 37, -33, -1, 119, -88, 100, 121,
+            -25, -35, -51, 10, 43, -113, 61, 103, 44, 13, 108, 20, 74, 19, 53, 19, 37, -76, 20, -43, -11, 23, -58, -25,
+            -52, 121, -40, -118, 58, 50, 19, -8, -33, -30, -49, -27, -11, -80, 93, -17, 34, 93, 69, 100, 66, -54, 40,
+            118, 89, -52, -87, 2, 35, -120, 18, 64, 108, 31, -25, 66, 78, 6, -91, -69, -53, 17, 14, -125, 33, -31, -110,
+            1, 5, -40, 7, 126, -122, 84, -55, -62, -22, 69, -28, 5, 45, -106, 120, 74, 94, 51, 74, 108, -19, -26, -12,
+            49, 64, 88, 68, 41, -65, 126, 125, -1, -8, -83, -67, 74, 2, -114, -80, -119, -9, -89, -125, 21, 95, 34,
+            -58, -74, 111, -103, 99, 95, 48, 42, 94, -50, -55, -112, -5, -26, 11, -89, -38, -19, 126, 25, 102, 119,
+            81, -94, 70, -79, 98, 91, -73, 114, 15, 14, 87, -21, -122, -1, -90, 0, 29, -104, -91, -93, -58, -83, -48,
+            -22, 100, -112, -41, 77, 22, -24, 112, -72, 105, 100, 6, -86, -39, 40, -43, 35, -2, 4, -94, 97, -121, 52,
+            -22, 1, 127, -81, -4, -6, -119, 96, 35, -91, 114, 81, 91, 90, -86, -36, 34, -39, 93, -42, 69, 103, -11,
+            107, -87, 119, -107, -114, -45, -128, -69, 96};
+
+    static byte[] streamToBytes(final InputStream is) throws IOException {
+        final ByteArrayOutputStream os = new ByteArrayOutputStream();
+        final byte[] buf = new byte[4096];
+        int read;
+        while ((read = is.read(buf)) > -1) {
+            os.write(buf, 0, read);
+        }
+        return os.toByteArray();
+    }
+
+    /**
+     * Returns an encoded and decoded copy of the same random data.
+     *
+     * @param size amount of random data to generate and encode
+     * @return two byte[] arrays:  [0] = decoded, [1] = encoded
+     */
+    static byte[][] randomData(final int size) {
+        final Random r = new Random();
+        final byte[] decoded = new byte[size];
+        r.nextBytes(decoded);","[{'comment': 'Although only test data any use of Random should be discouraged. ThreadLocalRandom or SplittableRandom are far more robust statistically and also faster (due to lack of synchronisation).\r\n\r\n```\r\nThreadLocalRandom.current().nextBytes(decoded);\r\n```\r\n', 'commenter': 'aherbert'}]"
46,src/test/java/org/apache/commons/codec/binary/HexTest.java,"@@ -340,6 +341,18 @@ public void testDecodeHexCharArrayOddCharacters5() {
         checkDecodeHexCharArrayOddCharacters(new char[] { 'A', 'B', 'C', 'D', 'E' });
     }
 
+    @Test(expected = DecoderException.class)","[{'comment': 'IIUC these tests target coverage in new methods added to Hex. If the changes are dropped then these tests can be dropped too.', 'commenter': 'aherbert'}]"
46,src/test/java/org/apache/commons/codec/binary/Base16Test.java,"@@ -0,0 +1,625 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.binary;
+
+import org.apache.commons.codec.CodecPolicy;
+import org.apache.commons.codec.DecoderException;
+import org.apache.commons.codec.EncoderException;
+import org.apache.commons.lang3.ArrayUtils;
+import org.junit.Assume;
+import org.junit.Test;
+
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+import java.util.Random;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Test cases for Base16 class.
+ *
+ * @since 1.15
+ */
+public class Base16Test {
+
+    private static final Charset CHARSET_UTF8 = StandardCharsets.UTF_8;
+
+    private final Random random = new Random();
+
+    /**
+     * @return Returns the random.
+     */
+    public Random getRandom() {
+        return this.random;
+    }
+
+    /**
+     * Test the Base16 implementation
+     */
+    @Test
+    public void testBase16() {
+        final String content = ""Hello World"";
+        final byte[] encodedBytes = new Base16().encode(StringUtils.getBytesUtf8(content));
+        final String encodedContent = StringUtils.newStringUtf8(encodedBytes);
+        assertEquals(""encoding hello world"", ""48656C6C6F20576F726C64"", encodedContent);
+
+        final byte[] decodedBytes = new Base16().decode(encodedBytes);
+        final String decodedContent = StringUtils.newStringUtf8(decodedBytes);
+        assertEquals(""decoding hello world"", content, decodedContent);
+    }
+
+    @Test
+    public void testBase16AtBufferStart() {
+        testBase16InBuffer(0, 100);
+    }
+
+    @Test
+    public void testBase16AtBufferEnd() {
+        testBase16InBuffer(100, 0);
+    }
+
+    @Test
+    public void testBase16AtBufferMiddle() {
+        testBase16InBuffer(100, 100);
+    }
+
+    private void testBase16InBuffer(final int startPasSize, final int endPadSize) {
+        final String content = ""Hello World"";
+        String encodedContent;
+        final byte[] bytesUtf8 = StringUtils.getBytesUtf8(content);
+        byte[] buffer = ArrayUtils.addAll(bytesUtf8, new byte[endPadSize]);
+        buffer = ArrayUtils.addAll(new byte[startPasSize], buffer);
+        final byte[] encodedBytes = new Base16().encode(buffer, startPasSize, bytesUtf8.length);
+        encodedContent = StringUtils.newStringUtf8(encodedBytes);
+        assertEquals(""encoding hello world"", ""48656C6C6F20576F726C64"", encodedContent);
+    }
+
+    /**
+     * isBase16 throws RuntimeException on some
+     * non-Base16 bytes
+     */
+    @Test(expected=RuntimeException.class)
+    public void testCodec68() {
+        final byte[] x = new byte[] { 'n', 'H', '=', '=', (byte) 0x9c };
+        final Base16 b16 = new Base16();
+        b16.decode(x);
+    }
+
+    @Test
+    public void testConstructors() {
+        new Base16();
+        new Base16(false);
+        new Base16(true);
+        new Base16(false, CodecPolicy.LENIENT);
+        new Base16(false, CodecPolicy.STRICT);
+    }
+
+    @Test
+    public void testConstructor_LowerCase() {
+        final Base16 Base16 = new Base16(true);","[{'comment': 'Replace `Base16 Base16` with `Base16 base16`', 'commenter': 'aherbert'}]"
46,src/test/java/org/apache/commons/codec/binary/Base16Test.java,"@@ -0,0 +1,625 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.binary;
+
+import org.apache.commons.codec.CodecPolicy;
+import org.apache.commons.codec.DecoderException;
+import org.apache.commons.codec.EncoderException;
+import org.apache.commons.lang3.ArrayUtils;
+import org.junit.Assume;
+import org.junit.Test;
+
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+import java.util.Random;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Test cases for Base16 class.
+ *
+ * @since 1.15
+ */
+public class Base16Test {
+
+    private static final Charset CHARSET_UTF8 = StandardCharsets.UTF_8;
+
+    private final Random random = new Random();
+
+    /**
+     * @return Returns the random.
+     */
+    public Random getRandom() {
+        return this.random;
+    }
+
+    /**
+     * Test the Base16 implementation
+     */
+    @Test
+    public void testBase16() {
+        final String content = ""Hello World"";
+        final byte[] encodedBytes = new Base16().encode(StringUtils.getBytesUtf8(content));
+        final String encodedContent = StringUtils.newStringUtf8(encodedBytes);
+        assertEquals(""encoding hello world"", ""48656C6C6F20576F726C64"", encodedContent);
+
+        final byte[] decodedBytes = new Base16().decode(encodedBytes);
+        final String decodedContent = StringUtils.newStringUtf8(decodedBytes);
+        assertEquals(""decoding hello world"", content, decodedContent);
+    }
+
+    @Test
+    public void testBase16AtBufferStart() {
+        testBase16InBuffer(0, 100);
+    }
+
+    @Test
+    public void testBase16AtBufferEnd() {
+        testBase16InBuffer(100, 0);
+    }
+
+    @Test
+    public void testBase16AtBufferMiddle() {
+        testBase16InBuffer(100, 100);
+    }
+
+    private void testBase16InBuffer(final int startPasSize, final int endPadSize) {
+        final String content = ""Hello World"";
+        String encodedContent;
+        final byte[] bytesUtf8 = StringUtils.getBytesUtf8(content);
+        byte[] buffer = ArrayUtils.addAll(bytesUtf8, new byte[endPadSize]);
+        buffer = ArrayUtils.addAll(new byte[startPasSize], buffer);
+        final byte[] encodedBytes = new Base16().encode(buffer, startPasSize, bytesUtf8.length);
+        encodedContent = StringUtils.newStringUtf8(encodedBytes);
+        assertEquals(""encoding hello world"", ""48656C6C6F20576F726C64"", encodedContent);
+    }
+
+    /**
+     * isBase16 throws RuntimeException on some
+     * non-Base16 bytes
+     */
+    @Test(expected=RuntimeException.class)
+    public void testCodec68() {
+        final byte[] x = new byte[] { 'n', 'H', '=', '=', (byte) 0x9c };
+        final Base16 b16 = new Base16();
+        b16.decode(x);
+    }
+
+    @Test
+    public void testConstructors() {
+        new Base16();
+        new Base16(false);
+        new Base16(true);
+        new Base16(false, CodecPolicy.LENIENT);
+        new Base16(false, CodecPolicy.STRICT);
+    }
+
+    @Test
+    public void testConstructor_LowerCase() {
+        final Base16 Base16 = new Base16(true);
+        final byte[] encoded = Base16.encode(Base16TestData.DECODED);
+        final String expectedResult = Base16TestData.ENCODED_UTF8_LOWERCASE;
+        final String result = StringUtils.newStringUtf8(encoded);
+        assertEquals(""new Base16(true)"", expectedResult, result);
+    }
+
+    @Test
+    public void testConstructor_LowerCase_DecodingPolicy() {
+        final Base16 Base16 = new Base16(false, CodecPolicy.STRICT);
+        final byte[] encoded = Base16.encode(Base16TestData.DECODED);
+        final String expectedResult = Base16TestData.ENCODED_UTF8_UPPERCASE;
+        final String result = StringUtils.newStringUtf8(encoded);
+        assertEquals(""new Base16(false, CodecPolicy.STRICT)"", result, expectedResult);
+    }
+
+    /**
+     * Test encode and decode of empty byte array.
+     */
+    @Test
+    public void testEmptyBase16() {
+        byte[] empty = new byte[0];
+        byte[] result = new Base16().encode(empty);
+        assertEquals(""empty Base16 encode"", 0, result.length);
+        assertEquals(""empty Base16 encode"", null, new Base16().encode(null));
+
+        empty = new byte[0];
+        result = new Base16().decode(empty);
+        assertEquals(""empty Base16 decode"", 0, result.length);
+        assertEquals(""empty Base16 encode"", null, new Base16().decode((byte[]) null));
+    }
+
+    // encode/decode a large random array
+    @Test
+    public void testEncodeDecodeRandom() {
+        for (int i = 1; i < 5; i++) {
+            final int len = this.getRandom().nextInt(10000) + 1;
+            final byte[] data = new byte[len];
+            this.getRandom().nextBytes(data);
+            final byte[] enc = new Base16().encode(data);
+            final byte[] data2 = new Base16().decode(enc);
+            assertArrayEquals(data, data2);
+        }
+    }
+
+    // encode/decode random arrays from size 0 to size 11
+    @Test
+    public void testEncodeDecodeSmall() {
+        for (int i = 0; i < 12; i++) {
+            final byte[] data = new byte[i];
+            this.getRandom().nextBytes(data);
+            final byte[] enc = new Base16().encode(data);
+            final byte[] data2 = new Base16().decode(enc);
+            assertArrayEquals(toString(data) + "" equals "" + toString(data2), data, data2);
+        }
+    }
+
+    @Test
+    public void testKnownDecodings() {
+        assertEquals(""The quick brown fox jumped over the lazy dogs."", new String(new Base16(true).decode(
+                ""54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e"".getBytes(CHARSET_UTF8))));
+        assertEquals(""It was the best of times, it was the worst of times."", new String(new Base16(true).decode(
+                ""497420776173207468652062657374206f662074696d65732c206974207761732074686520776f727374206f662074696d65732e"".getBytes(CHARSET_UTF8))));
+        assertEquals(""http://jakarta.apache.org/commmons"", new String(
+                new Base16(true).decode(""687474703a2f2f6a616b617274612e6170616368652e6f72672f636f6d6d6d6f6e73"".getBytes(CHARSET_UTF8))));
+        assertEquals(""AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"", new String(new Base16(true).decode(
+                ""4161426243634464456546664767486849694a6a4b6b4c6c4d6d4e6e4f6f50705171527253735474557556765777587859795a7a"".getBytes(CHARSET_UTF8))));
+        assertEquals(""{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }"",
+                new String(new Base16(true).decode(""7b20302c20312c20322c20332c20342c20352c20362c20372c20382c2039207d"".getBytes(CHARSET_UTF8))));
+        assertEquals(""xyzzy!"", new String(new Base16(true).decode(""78797a7a7921"".getBytes(CHARSET_UTF8))));
+    }
+
+    @Test
+    public void testKnownEncodings() {
+        assertEquals(""54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e"", new String(
+                new Base16(true).encode(""The quick brown fox jumped over the lazy dogs."".getBytes(CHARSET_UTF8))));
+        assertEquals(""497420776173207468652062657374206f662074696d65732c206974207761732074686520776f727374206f662074696d65732e"", new String(
+                new Base16(true).encode(""It was the best of times, it was the worst of times."".getBytes(CHARSET_UTF8))));
+        assertEquals(""687474703a2f2f6a616b617274612e6170616368652e6f72672f636f6d6d6d6f6e73"",
+                new String(new Base16(true).encode(""http://jakarta.apache.org/commmons"".getBytes(CHARSET_UTF8))));
+        assertEquals(""4161426243634464456546664767486849694a6a4b6b4c6c4d6d4e6e4f6f50705171527253735474557556765777587859795a7a"", new String(
+                new Base16(true).encode(""AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"".getBytes(CHARSET_UTF8))));
+        assertEquals(""7b20302c20312c20322c20332c20342c20352c20362c20372c20382c2039207d"",
+                new String(new Base16(true).encode(""{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }"".getBytes(CHARSET_UTF8))));
+        assertEquals(""78797a7a7921"", new String(new Base16(true).encode(""xyzzy!"".getBytes(CHARSET_UTF8))));
+    }
+
+    @Test
+    public void testNonBase16Test() {
+        final byte[] invalidEncodedChars = { '/', ':', '@', 'G', '%', '`', 'g' };
+
+        final byte[] encoded = new byte[1];
+        for (final byte invalidEncodedChar : invalidEncodedChars) {
+            try {
+                encoded[0] = invalidEncodedChar;
+                new Base16().decode(encoded);
+                fail(""IllegalArgumentException should have been thrown when trying to decode invalid Base16 char: "" + (char)invalidEncodedChar);
+            } catch (final Exception e) {
+                assertTrue(e instanceof IllegalArgumentException);
+            }
+        }
+    }
+
+    @Test
+    public void testObjectDecodeWithInvalidParameter() {
+        final Base16 b16 = new Base16();
+
+        try {
+            b16.decode(Integer.valueOf(5));
+            fail(""decode(Object) didn't throw an exception when passed an Integer object"");
+        } catch (final DecoderException e) {
+            // ignored
+        }
+
+    }
+
+    @Test
+    public void testObjectDecodeWithValidParameter() throws Exception {
+        final String original = ""Hello World!"";
+        final Object o = new Base16().encode(original.getBytes(CHARSET_UTF8));
+
+        final Base16 b16 = new Base16();
+        final Object oDecoded = b16.decode(o);
+        final byte[] baDecoded = (byte[]) oDecoded;
+        final String dest = new String(baDecoded);
+
+        assertEquals(""dest string does not equal original"", original, dest);
+    }
+
+    @Test
+    public void testObjectEncodeWithInvalidParameter() {
+        final Base16 b16 = new Base16();
+        try {
+            b16.encode(""Yadayadayada"");
+            fail(""encode(Object) didn't throw an exception when passed a String object"");
+        } catch (final EncoderException e) {
+            // Expected
+        }
+    }
+
+    @Test
+    public void testObjectEncodeWithValidParameter() throws Exception {
+        final String original = ""Hello World!"";
+        final Object origObj = original.getBytes(CHARSET_UTF8);
+
+        final Object oEncoded = new Base16().encode(origObj);
+        final byte[] bArray = new Base16().decode((byte[]) oEncoded);
+        final String dest = new String(bArray);
+
+        assertEquals(""dest string does not equal original"", original, dest);
+    }
+
+    @Test
+    public void testObjectEncode() {
+        final Base16 b16 = new Base16();
+        assertEquals(""48656C6C6F20576F726C64"", new String(b16.encode(""Hello World"".getBytes(CHARSET_UTF8))));
+    }
+
+    @Test
+    public void testPairs() {
+        assertEquals(""0000"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0 })));
+        assertEquals(""0001"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 1 })));
+        assertEquals(""0002"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 2 })));
+        assertEquals(""0003"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 3 })));
+        assertEquals(""0004"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 4 })));
+        assertEquals(""0005"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 5 })));
+        assertEquals(""0006"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 6 })));
+        assertEquals(""0007"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 7 })));
+        assertEquals(""0008"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 8 })));
+        assertEquals(""0009"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 9 })));
+        assertEquals(""000A"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 10 })));
+        assertEquals(""000B"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 11 })));
+        assertEquals(""000C"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 12 })));
+        assertEquals(""000D"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 13 })));
+        assertEquals(""000E"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 14 })));
+        assertEquals(""000F"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 15 })));
+        assertEquals(""0010"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 16 })));
+        assertEquals(""0011"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 17 })));
+        for (int i = -128; i <= 127; i++) {
+            final byte test[] = { (byte) i, (byte) i };
+            assertArrayEquals(test, new Base16().decode(new Base16().encode(test)));
+        }
+    }
+
+    @Test
+    public void testSingletons() {
+        assertEquals(""00"", new String(new Base16().encode(new byte[] { (byte) 0 })));
+        assertEquals(""01"", new String(new Base16().encode(new byte[] { (byte) 1 })));
+        assertEquals(""02"", new String(new Base16().encode(new byte[] { (byte) 2 })));
+        assertEquals(""03"", new String(new Base16().encode(new byte[] { (byte) 3 })));
+        assertEquals(""04"", new String(new Base16().encode(new byte[] { (byte) 4 })));
+        assertEquals(""05"", new String(new Base16().encode(new byte[] { (byte) 5 })));
+        assertEquals(""06"", new String(new Base16().encode(new byte[] { (byte) 6 })));
+        assertEquals(""07"", new String(new Base16().encode(new byte[] { (byte) 7 })));
+        assertEquals(""08"", new String(new Base16().encode(new byte[] { (byte) 8 })));
+        assertEquals(""09"", new String(new Base16().encode(new byte[] { (byte) 9 })));
+        assertEquals(""0A"", new String(new Base16().encode(new byte[] { (byte) 10 })));
+        assertEquals(""0B"", new String(new Base16().encode(new byte[] { (byte) 11 })));
+        assertEquals(""0C"", new String(new Base16().encode(new byte[] { (byte) 12 })));
+        assertEquals(""0D"", new String(new Base16().encode(new byte[] { (byte) 13 })));
+        assertEquals(""0E"", new String(new Base16().encode(new byte[] { (byte) 14 })));
+        assertEquals(""0F"", new String(new Base16().encode(new byte[] { (byte) 15 })));
+        assertEquals(""10"", new String(new Base16().encode(new byte[] { (byte) 16 })));
+        assertEquals(""11"", new String(new Base16().encode(new byte[] { (byte) 17 })));
+        assertEquals(""12"", new String(new Base16().encode(new byte[] { (byte) 18 })));
+        assertEquals(""13"", new String(new Base16().encode(new byte[] { (byte) 19 })));
+        assertEquals(""14"", new String(new Base16().encode(new byte[] { (byte) 20 })));
+        assertEquals(""15"", new String(new Base16().encode(new byte[] { (byte) 21 })));
+        assertEquals(""16"", new String(new Base16().encode(new byte[] { (byte) 22 })));
+        assertEquals(""17"", new String(new Base16().encode(new byte[] { (byte) 23 })));
+        assertEquals(""18"", new String(new Base16().encode(new byte[] { (byte) 24 })));
+        assertEquals(""19"", new String(new Base16().encode(new byte[] { (byte) 25 })));
+        assertEquals(""1A"", new String(new Base16().encode(new byte[] { (byte) 26 })));
+        assertEquals(""1B"", new String(new Base16().encode(new byte[] { (byte) 27 })));
+        assertEquals(""1C"", new String(new Base16().encode(new byte[] { (byte) 28 })));
+        assertEquals(""1D"", new String(new Base16().encode(new byte[] { (byte) 29 })));
+        assertEquals(""1E"", new String(new Base16().encode(new byte[] { (byte) 30 })));
+        assertEquals(""1F"", new String(new Base16().encode(new byte[] { (byte) 31 })));
+        assertEquals(""20"", new String(new Base16().encode(new byte[] { (byte) 32 })));
+        assertEquals(""21"", new String(new Base16().encode(new byte[] { (byte) 33 })));
+        assertEquals(""22"", new String(new Base16().encode(new byte[] { (byte) 34 })));
+        assertEquals(""23"", new String(new Base16().encode(new byte[] { (byte) 35 })));
+        assertEquals(""24"", new String(new Base16().encode(new byte[] { (byte) 36 })));
+        assertEquals(""25"", new String(new Base16().encode(new byte[] { (byte) 37 })));
+        assertEquals(""26"", new String(new Base16().encode(new byte[] { (byte) 38 })));
+        assertEquals(""27"", new String(new Base16().encode(new byte[] { (byte) 39 })));
+        assertEquals(""28"", new String(new Base16().encode(new byte[] { (byte) 40 })));
+        assertEquals(""29"", new String(new Base16().encode(new byte[] { (byte) 41 })));
+        assertEquals(""2A"", new String(new Base16().encode(new byte[] { (byte) 42 })));
+        assertEquals(""2B"", new String(new Base16().encode(new byte[] { (byte) 43 })));
+        assertEquals(""2C"", new String(new Base16().encode(new byte[] { (byte) 44 })));
+        assertEquals(""2D"", new String(new Base16().encode(new byte[] { (byte) 45 })));
+        assertEquals(""2E"", new String(new Base16().encode(new byte[] { (byte) 46 })));
+        assertEquals(""2F"", new String(new Base16().encode(new byte[] { (byte) 47 })));
+        assertEquals(""30"", new String(new Base16().encode(new byte[] { (byte) 48 })));
+        assertEquals(""31"", new String(new Base16().encode(new byte[] { (byte) 49 })));
+        assertEquals(""32"", new String(new Base16().encode(new byte[] { (byte) 50 })));
+        assertEquals(""33"", new String(new Base16().encode(new byte[] { (byte) 51 })));
+        assertEquals(""34"", new String(new Base16().encode(new byte[] { (byte) 52 })));
+        assertEquals(""35"", new String(new Base16().encode(new byte[] { (byte) 53 })));
+        assertEquals(""36"", new String(new Base16().encode(new byte[] { (byte) 54 })));
+        assertEquals(""37"", new String(new Base16().encode(new byte[] { (byte) 55 })));
+        assertEquals(""38"", new String(new Base16().encode(new byte[] { (byte) 56 })));
+        assertEquals(""39"", new String(new Base16().encode(new byte[] { (byte) 57 })));
+        assertEquals(""3A"", new String(new Base16().encode(new byte[] { (byte) 58 })));
+        assertEquals(""3B"", new String(new Base16().encode(new byte[] { (byte) 59 })));
+        assertEquals(""3C"", new String(new Base16().encode(new byte[] { (byte) 60 })));
+        assertEquals(""3D"", new String(new Base16().encode(new byte[] { (byte) 61 })));
+        assertEquals(""3E"", new String(new Base16().encode(new byte[] { (byte) 62 })));
+        assertEquals(""3F"", new String(new Base16().encode(new byte[] { (byte) 63 })));
+        assertEquals(""40"", new String(new Base16().encode(new byte[] { (byte) 64 })));
+        assertEquals(""41"", new String(new Base16().encode(new byte[] { (byte) 65 })));
+        assertEquals(""42"", new String(new Base16().encode(new byte[] { (byte) 66 })));
+        assertEquals(""43"", new String(new Base16().encode(new byte[] { (byte) 67 })));
+        assertEquals(""44"", new String(new Base16().encode(new byte[] { (byte) 68 })));
+        assertEquals(""45"", new String(new Base16().encode(new byte[] { (byte) 69 })));
+        assertEquals(""46"", new String(new Base16().encode(new byte[] { (byte) 70 })));
+        assertEquals(""47"", new String(new Base16().encode(new byte[] { (byte) 71 })));
+        assertEquals(""48"", new String(new Base16().encode(new byte[] { (byte) 72 })));
+        assertEquals(""49"", new String(new Base16().encode(new byte[] { (byte) 73 })));
+        assertEquals(""4A"", new String(new Base16().encode(new byte[] { (byte) 74 })));
+        assertEquals(""4B"", new String(new Base16().encode(new byte[] { (byte) 75 })));
+        assertEquals(""4C"", new String(new Base16().encode(new byte[] { (byte) 76 })));
+        assertEquals(""4D"", new String(new Base16().encode(new byte[] { (byte) 77 })));
+        assertEquals(""4E"", new String(new Base16().encode(new byte[] { (byte) 78 })));
+        assertEquals(""4F"", new String(new Base16().encode(new byte[] { (byte) 79 })));
+        assertEquals(""50"", new String(new Base16().encode(new byte[] { (byte) 80 })));
+        assertEquals(""51"", new String(new Base16().encode(new byte[] { (byte) 81 })));
+        assertEquals(""52"", new String(new Base16().encode(new byte[] { (byte) 82 })));
+        assertEquals(""53"", new String(new Base16().encode(new byte[] { (byte) 83 })));
+        assertEquals(""54"", new String(new Base16().encode(new byte[] { (byte) 84 })));
+        assertEquals(""55"", new String(new Base16().encode(new byte[] { (byte) 85 })));
+        assertEquals(""56"", new String(new Base16().encode(new byte[] { (byte) 86 })));
+        assertEquals(""57"", new String(new Base16().encode(new byte[] { (byte) 87 })));
+        assertEquals(""58"", new String(new Base16().encode(new byte[] { (byte) 88 })));
+        assertEquals(""59"", new String(new Base16().encode(new byte[] { (byte) 89 })));
+        assertEquals(""5A"", new String(new Base16().encode(new byte[] { (byte) 90 })));
+        assertEquals(""5B"", new String(new Base16().encode(new byte[] { (byte) 91 })));
+        assertEquals(""5C"", new String(new Base16().encode(new byte[] { (byte) 92 })));
+        assertEquals(""5D"", new String(new Base16().encode(new byte[] { (byte) 93 })));
+        assertEquals(""5E"", new String(new Base16().encode(new byte[] { (byte) 94 })));
+        assertEquals(""5F"", new String(new Base16().encode(new byte[] { (byte) 95 })));
+        assertEquals(""60"", new String(new Base16().encode(new byte[] { (byte) 96 })));
+        assertEquals(""61"", new String(new Base16().encode(new byte[] { (byte) 97 })));
+        assertEquals(""62"", new String(new Base16().encode(new byte[] { (byte) 98 })));
+        assertEquals(""63"", new String(new Base16().encode(new byte[] { (byte) 99 })));
+        assertEquals(""64"", new String(new Base16().encode(new byte[] { (byte) 100 })));
+        assertEquals(""65"", new String(new Base16().encode(new byte[] { (byte) 101 })));
+        assertEquals(""66"", new String(new Base16().encode(new byte[] { (byte) 102 })));
+        assertEquals(""67"", new String(new Base16().encode(new byte[] { (byte) 103 })));
+        assertEquals(""68"", new String(new Base16().encode(new byte[] { (byte) 104 })));
+        for (int i = -128; i <= 127; i++) {
+            final byte test[] = { (byte) i };
+            assertTrue(Arrays.equals(test, new Base16().decode(new Base16().encode(test))));
+        }
+    }
+
+    @Test
+    public void testTriplets() {
+        assertEquals(""000000"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 0 })));
+        assertEquals(""000001"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 1 })));
+        assertEquals(""000002"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 2 })));
+        assertEquals(""000003"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 3 })));
+        assertEquals(""000004"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 4 })));
+        assertEquals(""000005"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 5 })));
+        assertEquals(""000006"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 6 })));
+        assertEquals(""000007"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 7 })));
+        assertEquals(""000008"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 8 })));
+        assertEquals(""000009"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 9 })));
+        assertEquals(""00000A"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 10 })));
+        assertEquals(""00000B"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 11 })));
+        assertEquals(""00000C"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 12 })));
+        assertEquals(""00000D"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 13 })));
+        assertEquals(""00000E"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 14 })));
+        assertEquals(""00000F"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 15 })));
+    }
+
+    @Test
+    public void testByteToStringVariations() throws DecoderException {
+        final Base16 Base16 = new Base16();
+        final byte[] b1 = StringUtils.getBytesUtf8(""Hello World"");
+        final byte[] b2 = new byte[0];
+        final byte[] b3 = null;
+
+        assertEquals(""byteToString Hello World"", ""48656C6C6F20576F726C64"", Base16.encodeToString(b1));
+        assertEquals(""byteToString static Hello World"", ""48656C6C6F20576F726C64"", StringUtils.newStringUtf8(new Base16().encode(b1)));
+        assertEquals(""byteToString \""\"""", """", Base16.encodeToString(b2));
+        assertEquals(""byteToString static \""\"""", """", StringUtils.newStringUtf8(new Base16().encode(b2)));
+        assertEquals(""byteToString null"", null, Base16.encodeToString(b3));
+        assertEquals(""byteToString static null"", null, StringUtils.newStringUtf8(new Base16().encode(b3)));
+    }
+
+    @Test
+    public void testStringToByteVariations() throws DecoderException {
+        final Base16 Base16 = new Base16();
+        final String s1 = ""48656C6C6F20576F726C64"";
+        final String s2 = """";
+        final String s3 = null;
+
+        assertEquals(""StringToByte Hello World"", ""Hello World"", StringUtils.newStringUtf8(Base16.decode(s1)));
+        assertEquals(""StringToByte Hello World"", ""Hello World"",
+                StringUtils.newStringUtf8((byte[]) new Base16().decode((Object) s1)));
+        assertEquals(""StringToByte static Hello World"", ""Hello World"",
+                StringUtils.newStringUtf8(new Base16().decode(s1)));
+        assertEquals(""StringToByte \""\"""", """", StringUtils.newStringUtf8(new Base16().decode(s2)));
+        assertEquals(""StringToByte static \""\"""", """", StringUtils.newStringUtf8(new Base16().decode(s2)));
+        assertEquals(""StringToByte null"", null, StringUtils.newStringUtf8(new Base16().decode(s3)));
+        assertEquals(""StringToByte static null"", null, StringUtils.newStringUtf8(new Base16().decode(s3)));
+    }
+
+    private String toString(final byte[] data) {
+        final StringBuilder buf = new StringBuilder();
+        for (int i = 0; i < data.length; i++) {
+            buf.append(data[i]);
+            if (i != data.length - 1) {
+                buf.append("","");
+            }
+        }
+        return buf.toString();
+    }
+
+    /**
+     * Test for CODEC-265: Encode a ~1GiB file.
+     *
+     * @see <a href=""https://issues.apache.org/jira/projects/CODEC/issues/CODEC-265"">CODEC-265</a>
+     */
+    public void testCodec265_over() {
+        // almost 1GiB file to encode: 2^29 bytes
+        final int size1GiB = 1 << 29;
+
+        // Expecting a size of 2 output bytes per 1 input byte
+        final int blocks = size1GiB;
+        final int expectedLength = 2 * blocks;
+
+        // This test is memory hungry. Check we can run it.
+        final long presumableFreeMemory = BaseNCodecTest.getPresumableFreeMemory();
+
+        // Estimate the maximum memory required:
+        // 1GiB + 1GiB + ~2GiB + ~1.33GiB + 32 KiB  = ~5.33GiB
+        //
+        // 1GiB: Input buffer to encode
+        // 1GiB: Existing working buffer (due to doubling of default buffer size of 8192)
+        // ~2GiB: New working buffer to allocate (due to doubling)
+        // ~1.33GiB: Expected output size (since the working buffer is copied at the end)
+        // 32KiB: Some head room
+        final long estimatedMemory = (long) size1GiB * 4 + expectedLength + 32 * 1024;
+        Assume.assumeTrue(""Not enough free memory for the test"", presumableFreeMemory > estimatedMemory);
+
+        final byte[] bytes = new byte[size1GiB];
+        final byte[] encoded = new Base16().encode(bytes);
+        assertEquals(expectedLength, encoded.length);
+    }
+
+    @Test
+    public void testIsInAlphabet() {
+        // invalid bounds
+        Base16 b16 = new Base16(true);
+        assertFalse(b16.isInAlphabet((byte)0));
+        assertFalse(b16.isInAlphabet((byte)1));
+        assertFalse(b16.isInAlphabet((byte)-1));
+        assertFalse(b16.isInAlphabet((byte)-15));
+        assertFalse(b16.isInAlphabet((byte)-16));
+        assertFalse(b16.isInAlphabet((byte)128));
+        assertFalse(b16.isInAlphabet((byte)255));
+
+        // lower-case
+        b16 = new Base16(true);
+        for (char c = '0'; c <= '9'; c++) {
+            assertTrue(b16.isInAlphabet((byte) c));
+        }
+        for (char c = 'a'; c <= 'f'; c++) {
+            assertTrue(b16.isInAlphabet((byte) c));
+        }
+        for (char c = 'A'; c <= 'F'; c++) {
+            assertFalse(b16.isInAlphabet((byte) c));
+        }
+        assertFalse(b16.isInAlphabet((byte) ('0' - 1)));
+        assertFalse(b16.isInAlphabet((byte) ('9' + 1)));
+        assertFalse(b16.isInAlphabet((byte) ('a' - 1)));
+        assertFalse(b16.isInAlphabet((byte) ('z' + 1)));
+
+        // upper-case
+        b16 = new Base16(false);
+        for (char c = '0'; c <= '9'; c++) {
+            assertTrue(b16.isInAlphabet((byte) c));
+        }
+        for (char c = 'a'; c <= 'f'; c++) {
+            assertFalse(b16.isInAlphabet((byte) c));
+        }
+        for (char c = 'A'; c <= 'F'; c++) {
+            assertTrue(b16.isInAlphabet((byte) c));
+        }
+        assertFalse(b16.isInAlphabet((byte) ('0' - 1)));
+        assertFalse(b16.isInAlphabet((byte) ('9' + 1)));
+        assertFalse(b16.isInAlphabet((byte) ('A' - 1)));
+        assertFalse(b16.isInAlphabet((byte) ('F' + 1)));
+    }
+
+    @Test
+    public void testDecodeSingleBytes() {
+        final String encoded = ""556E74696C206E6578742074696D6521"";
+
+        final BaseNCodec.Context context = new BaseNCodec.Context();
+        final Base16 b16 = new Base16();
+
+        final byte[] encocdedBytes = StringUtils.getBytesUtf8(encoded);
+
+        // decode byte-by-byte
+        b16.decode(encocdedBytes, 0, 1, context);
+        b16.decode(encocdedBytes, 1, 1, context);    // yields ""U""
+        b16.decode(encocdedBytes, 2, 1, context);
+        b16.decode(encocdedBytes, 3, 1, context);    // yields ""n""
+
+        // decode split hex-pairs
+        b16.decode(encocdedBytes, 4, 3, context);    // yields ""t""
+        b16.decode(encocdedBytes, 7, 3, context);    // yields ""il""
+        b16.decode(encocdedBytes, 10, 3, context);   // yields "" ""
+
+        // decode remaining
+        b16.decode(encocdedBytes, 13, 19, context);  // yields ""next time!""
+
+        final byte[] decodedBytes = new byte[context.pos];
+        System.arraycopy(context.buffer, context.readPos, decodedBytes, 0, decodedBytes.length);
+        final String decoded = StringUtils.newStringUtf8(decodedBytes);
+
+        assertEquals(""Until next time!"", decoded);
+    }
+
+    @Test
+    public void testDecodeSingleBytesOptimisation() {
+        final BaseNCodec.Context context = new BaseNCodec.Context();
+        context.ibitWorkArea = 0;","[{'comment': ""The codec relies on the fact that a new Context created in `BaseNCodec.decode(byte[])` has a zero work area. So perhaps this should be checked. I'd also change the -17 to the hex byte representation for clarity.\r\n```java\r\nfinal BaseNCodec.Context context = new BaseNCodec.Context();\r\nassertEquals(0, context.ibitWorkArea);\r\n\r\nfinal byte[] data = new byte[1];\r\nfinal Base16 b16 = new Base16();\r\n\r\ndata[0] = (byte) 'E';\r\nb16.decode(data, 0, 1, context);\r\nassertEquals(15, context.ibitWorkArea);\r\n\r\ndata[0] = (byte) 'F';\r\nb16.decode(data, 0, 1, context);\r\nassertEquals(0, context.ibitWorkArea);\r\n\r\nassertEquals((byte) 0xEF, context.buffer[0]);\r\n```"", 'commenter': 'aherbert'}]"
46,src/main/java/org/apache/commons/codec/binary/Base16.java,"@@ -0,0 +1,251 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.binary;
+
+import org.apache.commons.codec.CodecPolicy;
+
+/**
+ * Provides Base16 encoding and decoding.
+ *
+ * <p>
+ * This class is thread-safe.
+ * </p>
+ *
+ * @see <a href=""https://tools.ietf.org/html/rfc4648#section-8"">RFC 4648 - 8. Base 16 Encoding</a>
+ *
+ * @since 1.15
+ */
+public class Base16 extends BaseNCodec {
+
+    /**
+     * BASE16 characters are 4 bits in length.
+     * They are formed by taking an 8-bit group,
+     * which is converted into two BASE16 characters.
+     */
+    private static final int BITS_PER_ENCODED_BYTE = 4;
+    private static final int BYTES_PER_ENCODED_BLOCK = 2;
+    private static final int BYTES_PER_UNENCODED_BLOCK = 1;
+
+    /**
+     * This array is a lookup table that translates Unicode characters drawn from the ""Base16 Alphabet"" (as specified
+     * in Table 5 of RFC 4648) into their 4-bit positive integer equivalents. Characters that are not in the Base16
+     * alphabet but fall within the bounds of the array are translated to -1.
+     */
+    private static final byte[] UPPER_CASE_DECODE_TABLE = {
+            //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f
+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 0-9
+            -1, 10, 11, 12, 13, 14, 15                                      // 40-46 A-F
+    };
+
+    /**
+     * This array is a lookup table that translates 4-bit positive integer index values into their ""Base16 Alphabet""
+     * equivalents as specified in Table 5 of RFC 4648.
+     */
+    private static final byte[] UPPER_CASE_ENCODE_TABLE = {
+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+            'A', 'B', 'C', 'D', 'E', 'F'
+    };
+
+    /**
+     * This array is a lookup table that translates Unicode characters drawn from the a lower-case ""Base16 Alphabet""
+     * into their 4-bit positive integer equivalents. Characters that are not in the Base16
+     * alphabet but fall within the bounds of the array are translated to -1.
+     */
+    private static final byte[] LOWER_CASE_DECODE_TABLE = {
+            //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f
+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 0-9
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 40-4f
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 50-5f
+            -1, 10, 11, 12, 13, 14, 15                                      // 60-66 a-f
+    };
+
+    /**
+     * This array is a lookup table that translates 4-bit positive integer index values into their ""Base16 Alphabet""
+     * lower-case equivalents.
+     */
+    private static final byte[] LOWER_CASE_ENCODE_TABLE = {
+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+            'a', 'b', 'c', 'd', 'e', 'f'
+    };
+
+    /** Mask used to extract 4 bits, used when decoding character. */
+    private static final int MASK_4BITS = 0x0f;
+
+    /**
+     * Decode table to use.
+     */
+    private final byte[] decodeTable;
+
+    /**
+     * Encode table to use.
+     */
+    private final byte[] encodeTable;
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     */
+    public Base16() {
+        this(false);
+    }
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     *
+     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.
+     */
+    public Base16(final boolean lowerCase) {
+        this(lowerCase, DECODING_POLICY_DEFAULT);
+    }
+
+    /**
+     * Creates a Base16 codec used for decoding and encoding.
+     *
+     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.
+     * @param decodingPolicy Decoding policy.
+     */
+    public Base16(final boolean lowerCase, final CodecPolicy decodingPolicy) {
+        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, 0, 0,
+                PAD_DEFAULT, decodingPolicy);
+        if (lowerCase) {
+            this.encodeTable = LOWER_CASE_ENCODE_TABLE;
+            this.decodeTable = LOWER_CASE_DECODE_TABLE;
+        } else {
+            this.encodeTable = UPPER_CASE_ENCODE_TABLE;
+            this.decodeTable = UPPER_CASE_DECODE_TABLE;
+        }
+    }
+
+    @Override
+    void decode(final byte[] data, int offset, final int length, final Context context) {
+        if (context.eof || length < 0) {
+            context.eof = true;
+            if (context.ibitWorkArea > 0) {
+                validateTrailingCharacter();
+            }
+            return;
+        }
+
+        final int dataLen = Math.min(data.length - offset, length);
+        final int availableChars = (context.ibitWorkArea > 0 ? 1 : 0) + dataLen;","[{'comment': 'Could change to `ibitWorkArea != 0`', 'commenter': 'aherbert'}]"
46,src/test/java/org/apache/commons/codec/binary/Base16Test.java,"@@ -0,0 +1,625 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.binary;
+
+import org.apache.commons.codec.CodecPolicy;
+import org.apache.commons.codec.DecoderException;
+import org.apache.commons.codec.EncoderException;
+import org.apache.commons.lang3.ArrayUtils;
+import org.junit.Assume;
+import org.junit.Test;
+
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+import java.util.Random;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Test cases for Base16 class.
+ *
+ * @since 1.15
+ */
+public class Base16Test {
+
+    private static final Charset CHARSET_UTF8 = StandardCharsets.UTF_8;
+
+    private final Random random = new Random();
+
+    /**
+     * @return Returns the random.
+     */
+    public Random getRandom() {
+        return this.random;
+    }
+
+    /**
+     * Test the Base16 implementation
+     */
+    @Test
+    public void testBase16() {
+        final String content = ""Hello World"";
+        final byte[] encodedBytes = new Base16().encode(StringUtils.getBytesUtf8(content));
+        final String encodedContent = StringUtils.newStringUtf8(encodedBytes);
+        assertEquals(""encoding hello world"", ""48656C6C6F20576F726C64"", encodedContent);
+
+        final byte[] decodedBytes = new Base16().decode(encodedBytes);
+        final String decodedContent = StringUtils.newStringUtf8(decodedBytes);
+        assertEquals(""decoding hello world"", content, decodedContent);
+    }
+
+    @Test
+    public void testBase16AtBufferStart() {
+        testBase16InBuffer(0, 100);
+    }
+
+    @Test
+    public void testBase16AtBufferEnd() {
+        testBase16InBuffer(100, 0);
+    }
+
+    @Test
+    public void testBase16AtBufferMiddle() {
+        testBase16InBuffer(100, 100);
+    }
+
+    private void testBase16InBuffer(final int startPasSize, final int endPadSize) {
+        final String content = ""Hello World"";
+        String encodedContent;
+        final byte[] bytesUtf8 = StringUtils.getBytesUtf8(content);
+        byte[] buffer = ArrayUtils.addAll(bytesUtf8, new byte[endPadSize]);
+        buffer = ArrayUtils.addAll(new byte[startPasSize], buffer);
+        final byte[] encodedBytes = new Base16().encode(buffer, startPasSize, bytesUtf8.length);
+        encodedContent = StringUtils.newStringUtf8(encodedBytes);
+        assertEquals(""encoding hello world"", ""48656C6C6F20576F726C64"", encodedContent);
+    }
+
+    /**
+     * isBase16 throws RuntimeException on some
+     * non-Base16 bytes
+     */
+    @Test(expected=RuntimeException.class)
+    public void testCodec68() {
+        final byte[] x = new byte[] { 'n', 'H', '=', '=', (byte) 0x9c };
+        final Base16 b16 = new Base16();
+        b16.decode(x);
+    }
+
+    @Test
+    public void testConstructors() {
+        new Base16();
+        new Base16(false);
+        new Base16(true);
+        new Base16(false, CodecPolicy.LENIENT);
+        new Base16(false, CodecPolicy.STRICT);
+    }
+
+    @Test
+    public void testConstructor_LowerCase() {
+        final Base16 Base16 = new Base16(true);
+        final byte[] encoded = Base16.encode(Base16TestData.DECODED);
+        final String expectedResult = Base16TestData.ENCODED_UTF8_LOWERCASE;
+        final String result = StringUtils.newStringUtf8(encoded);
+        assertEquals(""new Base16(true)"", expectedResult, result);
+    }
+
+    @Test
+    public void testConstructor_LowerCase_DecodingPolicy() {
+        final Base16 Base16 = new Base16(false, CodecPolicy.STRICT);
+        final byte[] encoded = Base16.encode(Base16TestData.DECODED);
+        final String expectedResult = Base16TestData.ENCODED_UTF8_UPPERCASE;
+        final String result = StringUtils.newStringUtf8(encoded);
+        assertEquals(""new Base16(false, CodecPolicy.STRICT)"", result, expectedResult);
+    }
+
+    /**
+     * Test encode and decode of empty byte array.
+     */
+    @Test
+    public void testEmptyBase16() {
+        byte[] empty = new byte[0];
+        byte[] result = new Base16().encode(empty);
+        assertEquals(""empty Base16 encode"", 0, result.length);
+        assertEquals(""empty Base16 encode"", null, new Base16().encode(null));
+
+        empty = new byte[0];
+        result = new Base16().decode(empty);
+        assertEquals(""empty Base16 decode"", 0, result.length);
+        assertEquals(""empty Base16 encode"", null, new Base16().decode((byte[]) null));
+    }
+
+    // encode/decode a large random array
+    @Test
+    public void testEncodeDecodeRandom() {
+        for (int i = 1; i < 5; i++) {
+            final int len = this.getRandom().nextInt(10000) + 1;
+            final byte[] data = new byte[len];
+            this.getRandom().nextBytes(data);
+            final byte[] enc = new Base16().encode(data);
+            final byte[] data2 = new Base16().decode(enc);
+            assertArrayEquals(data, data2);
+        }
+    }
+
+    // encode/decode random arrays from size 0 to size 11
+    @Test
+    public void testEncodeDecodeSmall() {
+        for (int i = 0; i < 12; i++) {
+            final byte[] data = new byte[i];
+            this.getRandom().nextBytes(data);
+            final byte[] enc = new Base16().encode(data);
+            final byte[] data2 = new Base16().decode(enc);
+            assertArrayEquals(toString(data) + "" equals "" + toString(data2), data, data2);
+        }
+    }
+
+    @Test
+    public void testKnownDecodings() {
+        assertEquals(""The quick brown fox jumped over the lazy dogs."", new String(new Base16(true).decode(
+                ""54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e"".getBytes(CHARSET_UTF8))));
+        assertEquals(""It was the best of times, it was the worst of times."", new String(new Base16(true).decode(
+                ""497420776173207468652062657374206f662074696d65732c206974207761732074686520776f727374206f662074696d65732e"".getBytes(CHARSET_UTF8))));
+        assertEquals(""http://jakarta.apache.org/commmons"", new String(
+                new Base16(true).decode(""687474703a2f2f6a616b617274612e6170616368652e6f72672f636f6d6d6d6f6e73"".getBytes(CHARSET_UTF8))));
+        assertEquals(""AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"", new String(new Base16(true).decode(
+                ""4161426243634464456546664767486849694a6a4b6b4c6c4d6d4e6e4f6f50705171527253735474557556765777587859795a7a"".getBytes(CHARSET_UTF8))));
+        assertEquals(""{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }"",
+                new String(new Base16(true).decode(""7b20302c20312c20322c20332c20342c20352c20362c20372c20382c2039207d"".getBytes(CHARSET_UTF8))));
+        assertEquals(""xyzzy!"", new String(new Base16(true).decode(""78797a7a7921"".getBytes(CHARSET_UTF8))));
+    }
+
+    @Test
+    public void testKnownEncodings() {
+        assertEquals(""54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e"", new String(
+                new Base16(true).encode(""The quick brown fox jumped over the lazy dogs."".getBytes(CHARSET_UTF8))));
+        assertEquals(""497420776173207468652062657374206f662074696d65732c206974207761732074686520776f727374206f662074696d65732e"", new String(
+                new Base16(true).encode(""It was the best of times, it was the worst of times."".getBytes(CHARSET_UTF8))));
+        assertEquals(""687474703a2f2f6a616b617274612e6170616368652e6f72672f636f6d6d6d6f6e73"",
+                new String(new Base16(true).encode(""http://jakarta.apache.org/commmons"".getBytes(CHARSET_UTF8))));
+        assertEquals(""4161426243634464456546664767486849694a6a4b6b4c6c4d6d4e6e4f6f50705171527253735474557556765777587859795a7a"", new String(
+                new Base16(true).encode(""AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"".getBytes(CHARSET_UTF8))));
+        assertEquals(""7b20302c20312c20322c20332c20342c20352c20362c20372c20382c2039207d"",
+                new String(new Base16(true).encode(""{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }"".getBytes(CHARSET_UTF8))));
+        assertEquals(""78797a7a7921"", new String(new Base16(true).encode(""xyzzy!"".getBytes(CHARSET_UTF8))));
+    }
+
+    @Test
+    public void testNonBase16Test() {
+        final byte[] invalidEncodedChars = { '/', ':', '@', 'G', '%', '`', 'g' };
+
+        final byte[] encoded = new byte[1];
+        for (final byte invalidEncodedChar : invalidEncodedChars) {
+            try {
+                encoded[0] = invalidEncodedChar;
+                new Base16().decode(encoded);
+                fail(""IllegalArgumentException should have been thrown when trying to decode invalid Base16 char: "" + (char)invalidEncodedChar);
+            } catch (final Exception e) {
+                assertTrue(e instanceof IllegalArgumentException);
+            }
+        }
+    }
+
+    @Test
+    public void testObjectDecodeWithInvalidParameter() {
+        final Base16 b16 = new Base16();
+
+        try {
+            b16.decode(Integer.valueOf(5));
+            fail(""decode(Object) didn't throw an exception when passed an Integer object"");
+        } catch (final DecoderException e) {
+            // ignored
+        }
+
+    }
+
+    @Test
+    public void testObjectDecodeWithValidParameter() throws Exception {
+        final String original = ""Hello World!"";
+        final Object o = new Base16().encode(original.getBytes(CHARSET_UTF8));
+
+        final Base16 b16 = new Base16();
+        final Object oDecoded = b16.decode(o);
+        final byte[] baDecoded = (byte[]) oDecoded;
+        final String dest = new String(baDecoded);
+
+        assertEquals(""dest string does not equal original"", original, dest);
+    }
+
+    @Test
+    public void testObjectEncodeWithInvalidParameter() {
+        final Base16 b16 = new Base16();
+        try {
+            b16.encode(""Yadayadayada"");
+            fail(""encode(Object) didn't throw an exception when passed a String object"");
+        } catch (final EncoderException e) {
+            // Expected
+        }
+    }
+
+    @Test
+    public void testObjectEncodeWithValidParameter() throws Exception {
+        final String original = ""Hello World!"";
+        final Object origObj = original.getBytes(CHARSET_UTF8);
+
+        final Object oEncoded = new Base16().encode(origObj);
+        final byte[] bArray = new Base16().decode((byte[]) oEncoded);
+        final String dest = new String(bArray);
+
+        assertEquals(""dest string does not equal original"", original, dest);
+    }
+
+    @Test
+    public void testObjectEncode() {
+        final Base16 b16 = new Base16();
+        assertEquals(""48656C6C6F20576F726C64"", new String(b16.encode(""Hello World"".getBytes(CHARSET_UTF8))));
+    }
+
+    @Test
+    public void testPairs() {
+        assertEquals(""0000"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0 })));
+        assertEquals(""0001"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 1 })));
+        assertEquals(""0002"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 2 })));
+        assertEquals(""0003"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 3 })));
+        assertEquals(""0004"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 4 })));
+        assertEquals(""0005"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 5 })));
+        assertEquals(""0006"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 6 })));
+        assertEquals(""0007"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 7 })));
+        assertEquals(""0008"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 8 })));
+        assertEquals(""0009"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 9 })));
+        assertEquals(""000A"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 10 })));
+        assertEquals(""000B"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 11 })));
+        assertEquals(""000C"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 12 })));
+        assertEquals(""000D"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 13 })));
+        assertEquals(""000E"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 14 })));
+        assertEquals(""000F"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 15 })));
+        assertEquals(""0010"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 16 })));
+        assertEquals(""0011"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 17 })));
+        for (int i = -128; i <= 127; i++) {
+            final byte test[] = { (byte) i, (byte) i };
+            assertArrayEquals(test, new Base16().decode(new Base16().encode(test)));
+        }
+    }
+
+    @Test
+    public void testSingletons() {
+        assertEquals(""00"", new String(new Base16().encode(new byte[] { (byte) 0 })));
+        assertEquals(""01"", new String(new Base16().encode(new byte[] { (byte) 1 })));
+        assertEquals(""02"", new String(new Base16().encode(new byte[] { (byte) 2 })));
+        assertEquals(""03"", new String(new Base16().encode(new byte[] { (byte) 3 })));
+        assertEquals(""04"", new String(new Base16().encode(new byte[] { (byte) 4 })));
+        assertEquals(""05"", new String(new Base16().encode(new byte[] { (byte) 5 })));
+        assertEquals(""06"", new String(new Base16().encode(new byte[] { (byte) 6 })));
+        assertEquals(""07"", new String(new Base16().encode(new byte[] { (byte) 7 })));
+        assertEquals(""08"", new String(new Base16().encode(new byte[] { (byte) 8 })));
+        assertEquals(""09"", new String(new Base16().encode(new byte[] { (byte) 9 })));
+        assertEquals(""0A"", new String(new Base16().encode(new byte[] { (byte) 10 })));
+        assertEquals(""0B"", new String(new Base16().encode(new byte[] { (byte) 11 })));
+        assertEquals(""0C"", new String(new Base16().encode(new byte[] { (byte) 12 })));
+        assertEquals(""0D"", new String(new Base16().encode(new byte[] { (byte) 13 })));
+        assertEquals(""0E"", new String(new Base16().encode(new byte[] { (byte) 14 })));
+        assertEquals(""0F"", new String(new Base16().encode(new byte[] { (byte) 15 })));
+        assertEquals(""10"", new String(new Base16().encode(new byte[] { (byte) 16 })));
+        assertEquals(""11"", new String(new Base16().encode(new byte[] { (byte) 17 })));
+        assertEquals(""12"", new String(new Base16().encode(new byte[] { (byte) 18 })));
+        assertEquals(""13"", new String(new Base16().encode(new byte[] { (byte) 19 })));
+        assertEquals(""14"", new String(new Base16().encode(new byte[] { (byte) 20 })));
+        assertEquals(""15"", new String(new Base16().encode(new byte[] { (byte) 21 })));
+        assertEquals(""16"", new String(new Base16().encode(new byte[] { (byte) 22 })));
+        assertEquals(""17"", new String(new Base16().encode(new byte[] { (byte) 23 })));
+        assertEquals(""18"", new String(new Base16().encode(new byte[] { (byte) 24 })));
+        assertEquals(""19"", new String(new Base16().encode(new byte[] { (byte) 25 })));
+        assertEquals(""1A"", new String(new Base16().encode(new byte[] { (byte) 26 })));
+        assertEquals(""1B"", new String(new Base16().encode(new byte[] { (byte) 27 })));
+        assertEquals(""1C"", new String(new Base16().encode(new byte[] { (byte) 28 })));
+        assertEquals(""1D"", new String(new Base16().encode(new byte[] { (byte) 29 })));
+        assertEquals(""1E"", new String(new Base16().encode(new byte[] { (byte) 30 })));
+        assertEquals(""1F"", new String(new Base16().encode(new byte[] { (byte) 31 })));
+        assertEquals(""20"", new String(new Base16().encode(new byte[] { (byte) 32 })));
+        assertEquals(""21"", new String(new Base16().encode(new byte[] { (byte) 33 })));
+        assertEquals(""22"", new String(new Base16().encode(new byte[] { (byte) 34 })));
+        assertEquals(""23"", new String(new Base16().encode(new byte[] { (byte) 35 })));
+        assertEquals(""24"", new String(new Base16().encode(new byte[] { (byte) 36 })));
+        assertEquals(""25"", new String(new Base16().encode(new byte[] { (byte) 37 })));
+        assertEquals(""26"", new String(new Base16().encode(new byte[] { (byte) 38 })));
+        assertEquals(""27"", new String(new Base16().encode(new byte[] { (byte) 39 })));
+        assertEquals(""28"", new String(new Base16().encode(new byte[] { (byte) 40 })));
+        assertEquals(""29"", new String(new Base16().encode(new byte[] { (byte) 41 })));
+        assertEquals(""2A"", new String(new Base16().encode(new byte[] { (byte) 42 })));
+        assertEquals(""2B"", new String(new Base16().encode(new byte[] { (byte) 43 })));
+        assertEquals(""2C"", new String(new Base16().encode(new byte[] { (byte) 44 })));
+        assertEquals(""2D"", new String(new Base16().encode(new byte[] { (byte) 45 })));
+        assertEquals(""2E"", new String(new Base16().encode(new byte[] { (byte) 46 })));
+        assertEquals(""2F"", new String(new Base16().encode(new byte[] { (byte) 47 })));
+        assertEquals(""30"", new String(new Base16().encode(new byte[] { (byte) 48 })));
+        assertEquals(""31"", new String(new Base16().encode(new byte[] { (byte) 49 })));
+        assertEquals(""32"", new String(new Base16().encode(new byte[] { (byte) 50 })));
+        assertEquals(""33"", new String(new Base16().encode(new byte[] { (byte) 51 })));
+        assertEquals(""34"", new String(new Base16().encode(new byte[] { (byte) 52 })));
+        assertEquals(""35"", new String(new Base16().encode(new byte[] { (byte) 53 })));
+        assertEquals(""36"", new String(new Base16().encode(new byte[] { (byte) 54 })));
+        assertEquals(""37"", new String(new Base16().encode(new byte[] { (byte) 55 })));
+        assertEquals(""38"", new String(new Base16().encode(new byte[] { (byte) 56 })));
+        assertEquals(""39"", new String(new Base16().encode(new byte[] { (byte) 57 })));
+        assertEquals(""3A"", new String(new Base16().encode(new byte[] { (byte) 58 })));
+        assertEquals(""3B"", new String(new Base16().encode(new byte[] { (byte) 59 })));
+        assertEquals(""3C"", new String(new Base16().encode(new byte[] { (byte) 60 })));
+        assertEquals(""3D"", new String(new Base16().encode(new byte[] { (byte) 61 })));
+        assertEquals(""3E"", new String(new Base16().encode(new byte[] { (byte) 62 })));
+        assertEquals(""3F"", new String(new Base16().encode(new byte[] { (byte) 63 })));
+        assertEquals(""40"", new String(new Base16().encode(new byte[] { (byte) 64 })));
+        assertEquals(""41"", new String(new Base16().encode(new byte[] { (byte) 65 })));
+        assertEquals(""42"", new String(new Base16().encode(new byte[] { (byte) 66 })));
+        assertEquals(""43"", new String(new Base16().encode(new byte[] { (byte) 67 })));
+        assertEquals(""44"", new String(new Base16().encode(new byte[] { (byte) 68 })));
+        assertEquals(""45"", new String(new Base16().encode(new byte[] { (byte) 69 })));
+        assertEquals(""46"", new String(new Base16().encode(new byte[] { (byte) 70 })));
+        assertEquals(""47"", new String(new Base16().encode(new byte[] { (byte) 71 })));
+        assertEquals(""48"", new String(new Base16().encode(new byte[] { (byte) 72 })));
+        assertEquals(""49"", new String(new Base16().encode(new byte[] { (byte) 73 })));
+        assertEquals(""4A"", new String(new Base16().encode(new byte[] { (byte) 74 })));
+        assertEquals(""4B"", new String(new Base16().encode(new byte[] { (byte) 75 })));
+        assertEquals(""4C"", new String(new Base16().encode(new byte[] { (byte) 76 })));
+        assertEquals(""4D"", new String(new Base16().encode(new byte[] { (byte) 77 })));
+        assertEquals(""4E"", new String(new Base16().encode(new byte[] { (byte) 78 })));
+        assertEquals(""4F"", new String(new Base16().encode(new byte[] { (byte) 79 })));
+        assertEquals(""50"", new String(new Base16().encode(new byte[] { (byte) 80 })));
+        assertEquals(""51"", new String(new Base16().encode(new byte[] { (byte) 81 })));
+        assertEquals(""52"", new String(new Base16().encode(new byte[] { (byte) 82 })));
+        assertEquals(""53"", new String(new Base16().encode(new byte[] { (byte) 83 })));
+        assertEquals(""54"", new String(new Base16().encode(new byte[] { (byte) 84 })));
+        assertEquals(""55"", new String(new Base16().encode(new byte[] { (byte) 85 })));
+        assertEquals(""56"", new String(new Base16().encode(new byte[] { (byte) 86 })));
+        assertEquals(""57"", new String(new Base16().encode(new byte[] { (byte) 87 })));
+        assertEquals(""58"", new String(new Base16().encode(new byte[] { (byte) 88 })));
+        assertEquals(""59"", new String(new Base16().encode(new byte[] { (byte) 89 })));
+        assertEquals(""5A"", new String(new Base16().encode(new byte[] { (byte) 90 })));
+        assertEquals(""5B"", new String(new Base16().encode(new byte[] { (byte) 91 })));
+        assertEquals(""5C"", new String(new Base16().encode(new byte[] { (byte) 92 })));
+        assertEquals(""5D"", new String(new Base16().encode(new byte[] { (byte) 93 })));
+        assertEquals(""5E"", new String(new Base16().encode(new byte[] { (byte) 94 })));
+        assertEquals(""5F"", new String(new Base16().encode(new byte[] { (byte) 95 })));
+        assertEquals(""60"", new String(new Base16().encode(new byte[] { (byte) 96 })));
+        assertEquals(""61"", new String(new Base16().encode(new byte[] { (byte) 97 })));
+        assertEquals(""62"", new String(new Base16().encode(new byte[] { (byte) 98 })));
+        assertEquals(""63"", new String(new Base16().encode(new byte[] { (byte) 99 })));
+        assertEquals(""64"", new String(new Base16().encode(new byte[] { (byte) 100 })));
+        assertEquals(""65"", new String(new Base16().encode(new byte[] { (byte) 101 })));
+        assertEquals(""66"", new String(new Base16().encode(new byte[] { (byte) 102 })));
+        assertEquals(""67"", new String(new Base16().encode(new byte[] { (byte) 103 })));
+        assertEquals(""68"", new String(new Base16().encode(new byte[] { (byte) 104 })));
+        for (int i = -128; i <= 127; i++) {
+            final byte test[] = { (byte) i };
+            assertTrue(Arrays.equals(test, new Base16().decode(new Base16().encode(test))));
+        }
+    }
+
+    @Test
+    public void testTriplets() {
+        assertEquals(""000000"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 0 })));
+        assertEquals(""000001"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 1 })));
+        assertEquals(""000002"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 2 })));
+        assertEquals(""000003"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 3 })));
+        assertEquals(""000004"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 4 })));
+        assertEquals(""000005"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 5 })));
+        assertEquals(""000006"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 6 })));
+        assertEquals(""000007"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 7 })));
+        assertEquals(""000008"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 8 })));
+        assertEquals(""000009"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 9 })));
+        assertEquals(""00000A"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 10 })));
+        assertEquals(""00000B"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 11 })));
+        assertEquals(""00000C"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 12 })));
+        assertEquals(""00000D"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 13 })));
+        assertEquals(""00000E"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 14 })));
+        assertEquals(""00000F"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 15 })));
+    }
+
+    @Test
+    public void testByteToStringVariations() throws DecoderException {
+        final Base16 Base16 = new Base16();
+        final byte[] b1 = StringUtils.getBytesUtf8(""Hello World"");
+        final byte[] b2 = new byte[0];
+        final byte[] b3 = null;
+
+        assertEquals(""byteToString Hello World"", ""48656C6C6F20576F726C64"", Base16.encodeToString(b1));
+        assertEquals(""byteToString static Hello World"", ""48656C6C6F20576F726C64"", StringUtils.newStringUtf8(new Base16().encode(b1)));
+        assertEquals(""byteToString \""\"""", """", Base16.encodeToString(b2));
+        assertEquals(""byteToString static \""\"""", """", StringUtils.newStringUtf8(new Base16().encode(b2)));
+        assertEquals(""byteToString null"", null, Base16.encodeToString(b3));
+        assertEquals(""byteToString static null"", null, StringUtils.newStringUtf8(new Base16().encode(b3)));
+    }
+
+    @Test
+    public void testStringToByteVariations() throws DecoderException {
+        final Base16 Base16 = new Base16();
+        final String s1 = ""48656C6C6F20576F726C64"";
+        final String s2 = """";
+        final String s3 = null;
+
+        assertEquals(""StringToByte Hello World"", ""Hello World"", StringUtils.newStringUtf8(Base16.decode(s1)));
+        assertEquals(""StringToByte Hello World"", ""Hello World"",
+                StringUtils.newStringUtf8((byte[]) new Base16().decode((Object) s1)));
+        assertEquals(""StringToByte static Hello World"", ""Hello World"",
+                StringUtils.newStringUtf8(new Base16().decode(s1)));
+        assertEquals(""StringToByte \""\"""", """", StringUtils.newStringUtf8(new Base16().decode(s2)));
+        assertEquals(""StringToByte static \""\"""", """", StringUtils.newStringUtf8(new Base16().decode(s2)));
+        assertEquals(""StringToByte null"", null, StringUtils.newStringUtf8(new Base16().decode(s3)));
+        assertEquals(""StringToByte static null"", null, StringUtils.newStringUtf8(new Base16().decode(s3)));
+    }
+
+    private String toString(final byte[] data) {
+        final StringBuilder buf = new StringBuilder();
+        for (int i = 0; i < data.length; i++) {
+            buf.append(data[i]);
+            if (i != data.length - 1) {
+                buf.append("","");
+            }
+        }
+        return buf.toString();
+    }
+
+    /**
+     * Test for CODEC-265: Encode a ~1GiB file.
+     *
+     * @see <a href=""https://issues.apache.org/jira/projects/CODEC/issues/CODEC-265"">CODEC-265</a>
+     */
+    public void testCodec265_over() {
+        // almost 1GiB file to encode: 2^29 bytes
+        final int size1GiB = 1 << 29;
+
+        // Expecting a size of 2 output bytes per 1 input byte
+        final int blocks = size1GiB;
+        final int expectedLength = 2 * blocks;
+
+        // This test is memory hungry. Check we can run it.
+        final long presumableFreeMemory = BaseNCodecTest.getPresumableFreeMemory();
+
+        // Estimate the maximum memory required:","[{'comment': 'This has been copied from the Base64Test, changed (to encode a 500MiB file) and then disabled (no `@Test` annotation).\r\n\r\nCodec 265 concerns encoding a 1GiB file. Using base 64 you get 4 characters per 3 bytes so the output is ~1.33GiB. With Base16 you get 2 characters per byte and it is not possible to create a 2 GiB char array.\r\n\r\nNote: It will never run on Travis CI due to memory restrictions. When I run this locally it passes with a 500MiB input (1 << 29) but fails with 1GiB (1 << 30). However this is not due to an out-of-memory error (as expected) but an index out of bounds exception. This is due to the allocation of the buffer using:\r\n```java\r\ncontext.buffer = new byte[Math.max(size, getDefaultBufferSize())];\r\n```\r\nAs noted in my review comment for `ensureBufferSize` this has been changed to allow a single allocation of the entire array. Unfortunately when size is negative this creates a buffer of the default size.\r\n\r\nGiven that `BaseNCodec.ensureBufferSize` is intended to be called with a positive-only size one suggestion is `Base16.encode` could be updated to change this line:\r\n```java\r\nfinal byte[] buffer = ensureBufferSize(length * BYTES_PER_ENCODED_BLOCK, context)\r\n```\r\nto\r\n```java\r\nfinal int size = length * BYTES_PER_ENCODED_BLOCK;\r\nif (size < 0) {\r\n    throw new IllegalArgumentException(""Input byte[] length exceeds maximum size for encoded data: "" + length);\r\n}\r\n\r\nfinal byte[] buffer = ensureBufferSize(size, context)\r\n```\r\n\r\nA different approach with a less meaningful exception (a negative array size exception) would be to change ensureBufferSize:\r\n```java\r\ncontext.buffer = new byte[\r\n    compareUnsigned(size, getDefaultBufferSize()) > 0\r\n       ? size\r\n       : getDefaultBufferSize()];\r\n```\r\n\r\nEither way a test should be added to hit this exception.\r\n\r\n', 'commenter': 'aherbert'}, {'comment': 'I see that the change to `Base16.encode` to handle overflow has been done but this test still exists. It should be replaced by an attempt to encode a `byte[]` that is length 2^30. This will require 1Gb of memory and should be OK on Travis CI. Something like:\r\n```java\r\n@Test(expected = IllegalArgumentException.class)\r\npublic void testMaximumEncodedSizeExceeded() {\r\n  final int size1GiB = 1 << 30;\r\n  final byte[] bytes = new byte[size1GiB];\r\n  new Base16().encode(bytes);\r\n}\r\n```\r\n', 'commenter': 'aherbert'}, {'comment': '@aherbert I already added such a test as you requested. See the test function directly below your comment named `checkEncodeLengthBounds`', 'commenter': 'adamretter'}, {'comment': 'OK. It uses a different method call where the length is a separate argument but given the simplicity of the encode method there is no point in testing `encode(new byte[1 << 30])` as well.  So just remove `testCodec265_over()` as the test makes no sense for Base16.', 'commenter': 'aherbert'}]"
46,src/test/java/org/apache/commons/codec/binary/Base16Test.java,"@@ -0,0 +1,634 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.binary;
+
+import org.apache.commons.codec.CodecPolicy;
+import org.apache.commons.codec.DecoderException;
+import org.apache.commons.codec.EncoderException;
+import org.apache.commons.lang3.ArrayUtils;
+import org.junit.Assume;
+import org.junit.Test;
+
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+import java.util.Random;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Test cases for Base16 class.
+ *
+ * @since 1.15
+ */
+public class Base16Test {
+
+    private static final Charset CHARSET_UTF8 = StandardCharsets.UTF_8;
+
+    private final Random random = new Random();
+
+    /**
+     * @return Returns the random.
+     */
+    public Random getRandom() {
+        return this.random;
+    }
+
+    /**
+     * Test the Base16 implementation
+     */
+    @Test
+    public void testBase16() {
+        final String content = ""Hello World"";
+        final byte[] encodedBytes = new Base16().encode(StringUtils.getBytesUtf8(content));
+        final String encodedContent = StringUtils.newStringUtf8(encodedBytes);
+        assertEquals(""encoding hello world"", ""48656C6C6F20576F726C64"", encodedContent);
+
+        final byte[] decodedBytes = new Base16().decode(encodedBytes);
+        final String decodedContent = StringUtils.newStringUtf8(decodedBytes);
+        assertEquals(""decoding hello world"", content, decodedContent);
+    }
+
+    @Test
+    public void testBase16AtBufferStart() {
+        testBase16InBuffer(0, 100);
+    }
+
+    @Test
+    public void testBase16AtBufferEnd() {
+        testBase16InBuffer(100, 0);
+    }
+
+    @Test
+    public void testBase16AtBufferMiddle() {
+        testBase16InBuffer(100, 100);
+    }
+
+    private void testBase16InBuffer(final int startPasSize, final int endPadSize) {
+        final String content = ""Hello World"";
+        String encodedContent;
+        final byte[] bytesUtf8 = StringUtils.getBytesUtf8(content);
+        byte[] buffer = ArrayUtils.addAll(bytesUtf8, new byte[endPadSize]);
+        buffer = ArrayUtils.addAll(new byte[startPasSize], buffer);
+        final byte[] encodedBytes = new Base16().encode(buffer, startPasSize, bytesUtf8.length);
+        encodedContent = StringUtils.newStringUtf8(encodedBytes);
+        assertEquals(""encoding hello world"", ""48656C6C6F20576F726C64"", encodedContent);
+    }
+
+    /**
+     * isBase16 throws RuntimeException on some
+     * non-Base16 bytes
+     */
+    @Test(expected=RuntimeException.class)
+    public void testCodec68() {
+        final byte[] x = new byte[] { 'n', 'H', '=', '=', (byte) 0x9c };
+        final Base16 b16 = new Base16();
+        b16.decode(x);
+    }
+
+    @Test
+    public void testConstructors() {
+        new Base16();
+        new Base16(false);
+        new Base16(true);
+        new Base16(false, CodecPolicy.LENIENT);
+        new Base16(false, CodecPolicy.STRICT);
+    }
+
+    @Test
+    public void testConstructor_LowerCase() {
+        final Base16 base16 = new Base16(true);
+        final byte[] encoded = base16.encode(BaseNTestData.DECODED);
+        final String expectedResult = Base16TestData.ENCODED_UTF8_LOWERCASE;
+        final String result = StringUtils.newStringUtf8(encoded);
+        assertEquals(""new Base16(true)"", expectedResult, result);
+    }
+
+    @Test
+    public void testConstructor_LowerCase_DecodingPolicy() {
+        final Base16 base16 = new Base16(false, CodecPolicy.STRICT);
+        final byte[] encoded = base16.encode(BaseNTestData.DECODED);
+        final String expectedResult = Base16TestData.ENCODED_UTF8_UPPERCASE;
+        final String result = StringUtils.newStringUtf8(encoded);
+        assertEquals(""new base16(false, CodecPolicy.STRICT)"", result, expectedResult);
+    }
+
+    /**
+     * Test encode and decode of empty byte array.
+     */
+    @Test
+    public void testEmptyBase16() {
+        byte[] empty = new byte[0];
+        byte[] result = new Base16().encode(empty);
+        assertEquals(""empty Base16 encode"", 0, result.length);
+        assertEquals(""empty Base16 encode"", null, new Base16().encode(null));
+
+        empty = new byte[0];
+        result = new Base16().decode(empty);
+        assertEquals(""empty Base16 decode"", 0, result.length);
+        assertEquals(""empty Base16 encode"", null, new Base16().decode((byte[]) null));
+    }
+
+    // encode/decode a large random array
+    @Test
+    public void testEncodeDecodeRandom() {
+        for (int i = 1; i < 5; i++) {
+            final int len = this.getRandom().nextInt(10000) + 1;
+            final byte[] data = new byte[len];
+            this.getRandom().nextBytes(data);
+            final byte[] enc = new Base16().encode(data);
+            final byte[] data2 = new Base16().decode(enc);
+            assertArrayEquals(data, data2);
+        }
+    }
+
+    // encode/decode random arrays from size 0 to size 11
+    @Test
+    public void testEncodeDecodeSmall() {
+        for (int i = 0; i < 12; i++) {
+            final byte[] data = new byte[i];
+            this.getRandom().nextBytes(data);
+            final byte[] enc = new Base16().encode(data);
+            final byte[] data2 = new Base16().decode(enc);
+            assertArrayEquals(toString(data) + "" equals "" + toString(data2), data, data2);
+        }
+    }
+
+    @Test
+    public void testKnownDecodings() {
+        assertEquals(""The quick brown fox jumped over the lazy dogs."", new String(new Base16(true).decode(
+                ""54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e"".getBytes(CHARSET_UTF8))));
+        assertEquals(""It was the best of times, it was the worst of times."", new String(new Base16(true).decode(
+                ""497420776173207468652062657374206f662074696d65732c206974207761732074686520776f727374206f662074696d65732e"".getBytes(CHARSET_UTF8))));
+        assertEquals(""http://jakarta.apache.org/commmons"", new String(
+                new Base16(true).decode(""687474703a2f2f6a616b617274612e6170616368652e6f72672f636f6d6d6d6f6e73"".getBytes(CHARSET_UTF8))));
+        assertEquals(""AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"", new String(new Base16(true).decode(
+                ""4161426243634464456546664767486849694a6a4b6b4c6c4d6d4e6e4f6f50705171527253735474557556765777587859795a7a"".getBytes(CHARSET_UTF8))));
+        assertEquals(""{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }"",
+                new String(new Base16(true).decode(""7b20302c20312c20322c20332c20342c20352c20362c20372c20382c2039207d"".getBytes(CHARSET_UTF8))));
+        assertEquals(""xyzzy!"", new String(new Base16(true).decode(""78797a7a7921"".getBytes(CHARSET_UTF8))));
+    }
+
+    @Test
+    public void testKnownEncodings() {
+        assertEquals(""54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e"", new String(
+                new Base16(true).encode(""The quick brown fox jumped over the lazy dogs."".getBytes(CHARSET_UTF8))));
+        assertEquals(""497420776173207468652062657374206f662074696d65732c206974207761732074686520776f727374206f662074696d65732e"", new String(
+                new Base16(true).encode(""It was the best of times, it was the worst of times."".getBytes(CHARSET_UTF8))));
+        assertEquals(""687474703a2f2f6a616b617274612e6170616368652e6f72672f636f6d6d6d6f6e73"",
+                new String(new Base16(true).encode(""http://jakarta.apache.org/commmons"".getBytes(CHARSET_UTF8))));
+        assertEquals(""4161426243634464456546664767486849694a6a4b6b4c6c4d6d4e6e4f6f50705171527253735474557556765777587859795a7a"", new String(
+                new Base16(true).encode(""AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"".getBytes(CHARSET_UTF8))));
+        assertEquals(""7b20302c20312c20322c20332c20342c20352c20362c20372c20382c2039207d"",
+                new String(new Base16(true).encode(""{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }"".getBytes(CHARSET_UTF8))));
+        assertEquals(""78797a7a7921"", new String(new Base16(true).encode(""xyzzy!"".getBytes(CHARSET_UTF8))));
+    }
+
+    @Test
+    public void testNonBase16Test() {
+        final byte[] invalidEncodedChars = { '/', ':', '@', 'G', '%', '`', 'g' };
+
+        final byte[] encoded = new byte[1];
+        for (final byte invalidEncodedChar : invalidEncodedChars) {
+            try {
+                encoded[0] = invalidEncodedChar;
+                new Base16().decode(encoded);
+                fail(""IllegalArgumentException should have been thrown when trying to decode invalid Base16 char: "" + (char)invalidEncodedChar);
+            } catch (final Exception e) {
+                assertTrue(e instanceof IllegalArgumentException);
+            }
+        }
+    }
+
+    @Test
+    public void testObjectDecodeWithInvalidParameter() {
+        final Base16 b16 = new Base16();
+
+        try {
+            b16.decode(Integer.valueOf(5));
+            fail(""decode(Object) didn't throw an exception when passed an Integer object"");
+        } catch (final DecoderException e) {
+            // ignored
+        }
+
+    }
+
+    @Test
+    public void testObjectDecodeWithValidParameter() throws Exception {
+        final String original = ""Hello World!"";
+        final Object o = new Base16().encode(original.getBytes(CHARSET_UTF8));
+
+        final Base16 b16 = new Base16();
+        final Object oDecoded = b16.decode(o);
+        final byte[] baDecoded = (byte[]) oDecoded;
+        final String dest = new String(baDecoded);
+
+        assertEquals(""dest string does not equal original"", original, dest);
+    }
+
+    @Test
+    public void testObjectEncodeWithInvalidParameter() {
+        final Base16 b16 = new Base16();
+        try {
+            b16.encode(""Yadayadayada"");
+            fail(""encode(Object) didn't throw an exception when passed a String object"");
+        } catch (final EncoderException e) {
+            // Expected
+        }
+    }
+
+    @Test
+    public void testObjectEncodeWithValidParameter() throws Exception {
+        final String original = ""Hello World!"";
+        final Object origObj = original.getBytes(CHARSET_UTF8);
+
+        final Object oEncoded = new Base16().encode(origObj);
+        final byte[] bArray = new Base16().decode((byte[]) oEncoded);
+        final String dest = new String(bArray);
+
+        assertEquals(""dest string does not equal original"", original, dest);
+    }
+
+    @Test
+    public void testObjectEncode() {
+        final Base16 b16 = new Base16();
+        assertEquals(""48656C6C6F20576F726C64"", new String(b16.encode(""Hello World"".getBytes(CHARSET_UTF8))));
+    }
+
+    @Test
+    public void testPairs() {
+        assertEquals(""0000"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0 })));
+        assertEquals(""0001"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 1 })));
+        assertEquals(""0002"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 2 })));
+        assertEquals(""0003"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 3 })));
+        assertEquals(""0004"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 4 })));
+        assertEquals(""0005"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 5 })));
+        assertEquals(""0006"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 6 })));
+        assertEquals(""0007"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 7 })));
+        assertEquals(""0008"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 8 })));
+        assertEquals(""0009"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 9 })));
+        assertEquals(""000A"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 10 })));
+        assertEquals(""000B"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 11 })));
+        assertEquals(""000C"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 12 })));
+        assertEquals(""000D"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 13 })));
+        assertEquals(""000E"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 14 })));
+        assertEquals(""000F"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 15 })));
+        assertEquals(""0010"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 16 })));
+        assertEquals(""0011"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 17 })));
+        for (int i = -128; i <= 127; i++) {
+            final byte test[] = { (byte) i, (byte) i };
+            assertArrayEquals(test, new Base16().decode(new Base16().encode(test)));
+        }
+    }
+
+    @Test
+    public void testSingletons() {
+        assertEquals(""00"", new String(new Base16().encode(new byte[] { (byte) 0 })));
+        assertEquals(""01"", new String(new Base16().encode(new byte[] { (byte) 1 })));
+        assertEquals(""02"", new String(new Base16().encode(new byte[] { (byte) 2 })));
+        assertEquals(""03"", new String(new Base16().encode(new byte[] { (byte) 3 })));
+        assertEquals(""04"", new String(new Base16().encode(new byte[] { (byte) 4 })));
+        assertEquals(""05"", new String(new Base16().encode(new byte[] { (byte) 5 })));
+        assertEquals(""06"", new String(new Base16().encode(new byte[] { (byte) 6 })));
+        assertEquals(""07"", new String(new Base16().encode(new byte[] { (byte) 7 })));
+        assertEquals(""08"", new String(new Base16().encode(new byte[] { (byte) 8 })));
+        assertEquals(""09"", new String(new Base16().encode(new byte[] { (byte) 9 })));
+        assertEquals(""0A"", new String(new Base16().encode(new byte[] { (byte) 10 })));
+        assertEquals(""0B"", new String(new Base16().encode(new byte[] { (byte) 11 })));
+        assertEquals(""0C"", new String(new Base16().encode(new byte[] { (byte) 12 })));
+        assertEquals(""0D"", new String(new Base16().encode(new byte[] { (byte) 13 })));
+        assertEquals(""0E"", new String(new Base16().encode(new byte[] { (byte) 14 })));
+        assertEquals(""0F"", new String(new Base16().encode(new byte[] { (byte) 15 })));
+        assertEquals(""10"", new String(new Base16().encode(new byte[] { (byte) 16 })));
+        assertEquals(""11"", new String(new Base16().encode(new byte[] { (byte) 17 })));
+        assertEquals(""12"", new String(new Base16().encode(new byte[] { (byte) 18 })));
+        assertEquals(""13"", new String(new Base16().encode(new byte[] { (byte) 19 })));
+        assertEquals(""14"", new String(new Base16().encode(new byte[] { (byte) 20 })));
+        assertEquals(""15"", new String(new Base16().encode(new byte[] { (byte) 21 })));
+        assertEquals(""16"", new String(new Base16().encode(new byte[] { (byte) 22 })));
+        assertEquals(""17"", new String(new Base16().encode(new byte[] { (byte) 23 })));
+        assertEquals(""18"", new String(new Base16().encode(new byte[] { (byte) 24 })));
+        assertEquals(""19"", new String(new Base16().encode(new byte[] { (byte) 25 })));
+        assertEquals(""1A"", new String(new Base16().encode(new byte[] { (byte) 26 })));
+        assertEquals(""1B"", new String(new Base16().encode(new byte[] { (byte) 27 })));
+        assertEquals(""1C"", new String(new Base16().encode(new byte[] { (byte) 28 })));
+        assertEquals(""1D"", new String(new Base16().encode(new byte[] { (byte) 29 })));
+        assertEquals(""1E"", new String(new Base16().encode(new byte[] { (byte) 30 })));
+        assertEquals(""1F"", new String(new Base16().encode(new byte[] { (byte) 31 })));
+        assertEquals(""20"", new String(new Base16().encode(new byte[] { (byte) 32 })));
+        assertEquals(""21"", new String(new Base16().encode(new byte[] { (byte) 33 })));
+        assertEquals(""22"", new String(new Base16().encode(new byte[] { (byte) 34 })));
+        assertEquals(""23"", new String(new Base16().encode(new byte[] { (byte) 35 })));
+        assertEquals(""24"", new String(new Base16().encode(new byte[] { (byte) 36 })));
+        assertEquals(""25"", new String(new Base16().encode(new byte[] { (byte) 37 })));
+        assertEquals(""26"", new String(new Base16().encode(new byte[] { (byte) 38 })));
+        assertEquals(""27"", new String(new Base16().encode(new byte[] { (byte) 39 })));
+        assertEquals(""28"", new String(new Base16().encode(new byte[] { (byte) 40 })));
+        assertEquals(""29"", new String(new Base16().encode(new byte[] { (byte) 41 })));
+        assertEquals(""2A"", new String(new Base16().encode(new byte[] { (byte) 42 })));
+        assertEquals(""2B"", new String(new Base16().encode(new byte[] { (byte) 43 })));
+        assertEquals(""2C"", new String(new Base16().encode(new byte[] { (byte) 44 })));
+        assertEquals(""2D"", new String(new Base16().encode(new byte[] { (byte) 45 })));
+        assertEquals(""2E"", new String(new Base16().encode(new byte[] { (byte) 46 })));
+        assertEquals(""2F"", new String(new Base16().encode(new byte[] { (byte) 47 })));
+        assertEquals(""30"", new String(new Base16().encode(new byte[] { (byte) 48 })));
+        assertEquals(""31"", new String(new Base16().encode(new byte[] { (byte) 49 })));
+        assertEquals(""32"", new String(new Base16().encode(new byte[] { (byte) 50 })));
+        assertEquals(""33"", new String(new Base16().encode(new byte[] { (byte) 51 })));
+        assertEquals(""34"", new String(new Base16().encode(new byte[] { (byte) 52 })));
+        assertEquals(""35"", new String(new Base16().encode(new byte[] { (byte) 53 })));
+        assertEquals(""36"", new String(new Base16().encode(new byte[] { (byte) 54 })));
+        assertEquals(""37"", new String(new Base16().encode(new byte[] { (byte) 55 })));
+        assertEquals(""38"", new String(new Base16().encode(new byte[] { (byte) 56 })));
+        assertEquals(""39"", new String(new Base16().encode(new byte[] { (byte) 57 })));
+        assertEquals(""3A"", new String(new Base16().encode(new byte[] { (byte) 58 })));
+        assertEquals(""3B"", new String(new Base16().encode(new byte[] { (byte) 59 })));
+        assertEquals(""3C"", new String(new Base16().encode(new byte[] { (byte) 60 })));
+        assertEquals(""3D"", new String(new Base16().encode(new byte[] { (byte) 61 })));
+        assertEquals(""3E"", new String(new Base16().encode(new byte[] { (byte) 62 })));
+        assertEquals(""3F"", new String(new Base16().encode(new byte[] { (byte) 63 })));
+        assertEquals(""40"", new String(new Base16().encode(new byte[] { (byte) 64 })));
+        assertEquals(""41"", new String(new Base16().encode(new byte[] { (byte) 65 })));
+        assertEquals(""42"", new String(new Base16().encode(new byte[] { (byte) 66 })));
+        assertEquals(""43"", new String(new Base16().encode(new byte[] { (byte) 67 })));
+        assertEquals(""44"", new String(new Base16().encode(new byte[] { (byte) 68 })));
+        assertEquals(""45"", new String(new Base16().encode(new byte[] { (byte) 69 })));
+        assertEquals(""46"", new String(new Base16().encode(new byte[] { (byte) 70 })));
+        assertEquals(""47"", new String(new Base16().encode(new byte[] { (byte) 71 })));
+        assertEquals(""48"", new String(new Base16().encode(new byte[] { (byte) 72 })));
+        assertEquals(""49"", new String(new Base16().encode(new byte[] { (byte) 73 })));
+        assertEquals(""4A"", new String(new Base16().encode(new byte[] { (byte) 74 })));
+        assertEquals(""4B"", new String(new Base16().encode(new byte[] { (byte) 75 })));
+        assertEquals(""4C"", new String(new Base16().encode(new byte[] { (byte) 76 })));
+        assertEquals(""4D"", new String(new Base16().encode(new byte[] { (byte) 77 })));
+        assertEquals(""4E"", new String(new Base16().encode(new byte[] { (byte) 78 })));
+        assertEquals(""4F"", new String(new Base16().encode(new byte[] { (byte) 79 })));
+        assertEquals(""50"", new String(new Base16().encode(new byte[] { (byte) 80 })));
+        assertEquals(""51"", new String(new Base16().encode(new byte[] { (byte) 81 })));
+        assertEquals(""52"", new String(new Base16().encode(new byte[] { (byte) 82 })));
+        assertEquals(""53"", new String(new Base16().encode(new byte[] { (byte) 83 })));
+        assertEquals(""54"", new String(new Base16().encode(new byte[] { (byte) 84 })));
+        assertEquals(""55"", new String(new Base16().encode(new byte[] { (byte) 85 })));
+        assertEquals(""56"", new String(new Base16().encode(new byte[] { (byte) 86 })));
+        assertEquals(""57"", new String(new Base16().encode(new byte[] { (byte) 87 })));
+        assertEquals(""58"", new String(new Base16().encode(new byte[] { (byte) 88 })));
+        assertEquals(""59"", new String(new Base16().encode(new byte[] { (byte) 89 })));
+        assertEquals(""5A"", new String(new Base16().encode(new byte[] { (byte) 90 })));
+        assertEquals(""5B"", new String(new Base16().encode(new byte[] { (byte) 91 })));
+        assertEquals(""5C"", new String(new Base16().encode(new byte[] { (byte) 92 })));
+        assertEquals(""5D"", new String(new Base16().encode(new byte[] { (byte) 93 })));
+        assertEquals(""5E"", new String(new Base16().encode(new byte[] { (byte) 94 })));
+        assertEquals(""5F"", new String(new Base16().encode(new byte[] { (byte) 95 })));
+        assertEquals(""60"", new String(new Base16().encode(new byte[] { (byte) 96 })));
+        assertEquals(""61"", new String(new Base16().encode(new byte[] { (byte) 97 })));
+        assertEquals(""62"", new String(new Base16().encode(new byte[] { (byte) 98 })));
+        assertEquals(""63"", new String(new Base16().encode(new byte[] { (byte) 99 })));
+        assertEquals(""64"", new String(new Base16().encode(new byte[] { (byte) 100 })));
+        assertEquals(""65"", new String(new Base16().encode(new byte[] { (byte) 101 })));
+        assertEquals(""66"", new String(new Base16().encode(new byte[] { (byte) 102 })));
+        assertEquals(""67"", new String(new Base16().encode(new byte[] { (byte) 103 })));
+        assertEquals(""68"", new String(new Base16().encode(new byte[] { (byte) 104 })));
+        for (int i = -128; i <= 127; i++) {
+            final byte test[] = { (byte) i };
+            assertTrue(Arrays.equals(test, new Base16().decode(new Base16().encode(test))));
+        }
+    }
+
+    @Test
+    public void testTriplets() {
+        assertEquals(""000000"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 0 })));
+        assertEquals(""000001"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 1 })));
+        assertEquals(""000002"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 2 })));
+        assertEquals(""000003"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 3 })));
+        assertEquals(""000004"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 4 })));
+        assertEquals(""000005"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 5 })));
+        assertEquals(""000006"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 6 })));
+        assertEquals(""000007"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 7 })));
+        assertEquals(""000008"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 8 })));
+        assertEquals(""000009"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 9 })));
+        assertEquals(""00000A"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 10 })));
+        assertEquals(""00000B"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 11 })));
+        assertEquals(""00000C"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 12 })));
+        assertEquals(""00000D"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 13 })));
+        assertEquals(""00000E"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 14 })));
+        assertEquals(""00000F"", new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 15 })));
+    }
+
+    @Test
+    public void testByteToStringVariations() throws DecoderException {
+        final Base16 base16 = new Base16();
+        final byte[] b1 = StringUtils.getBytesUtf8(""Hello World"");
+        final byte[] b2 = new byte[0];
+        final byte[] b3 = null;
+
+        assertEquals(""byteToString Hello World"", ""48656C6C6F20576F726C64"", base16.encodeToString(b1));
+        assertEquals(""byteToString static Hello World"", ""48656C6C6F20576F726C64"", StringUtils.newStringUtf8(new Base16().encode(b1)));
+        assertEquals(""byteToString \""\"""", """", base16.encodeToString(b2));
+        assertEquals(""byteToString static \""\"""", """", StringUtils.newStringUtf8(new Base16().encode(b2)));
+        assertEquals(""byteToString null"", null, base16.encodeToString(b3));
+        assertEquals(""byteToString static null"", null, StringUtils.newStringUtf8(new Base16().encode(b3)));
+    }
+
+    @Test
+    public void testStringToByteVariations() throws DecoderException {
+        final Base16 base16 = new Base16();
+        final String s1 = ""48656C6C6F20576F726C64"";
+        final String s2 = """";
+        final String s3 = null;
+
+        assertEquals(""StringToByte Hello World"", ""Hello World"", StringUtils.newStringUtf8(base16.decode(s1)));
+        assertEquals(""StringToByte Hello World"", ""Hello World"",
+                StringUtils.newStringUtf8((byte[]) new Base16().decode((Object) s1)));
+        assertEquals(""StringToByte static Hello World"", ""Hello World"",
+                StringUtils.newStringUtf8(new Base16().decode(s1)));
+        assertEquals(""StringToByte \""\"""", """", StringUtils.newStringUtf8(new Base16().decode(s2)));
+        assertEquals(""StringToByte static \""\"""", """", StringUtils.newStringUtf8(new Base16().decode(s2)));
+        assertEquals(""StringToByte null"", null, StringUtils.newStringUtf8(new Base16().decode(s3)));
+        assertEquals(""StringToByte static null"", null, StringUtils.newStringUtf8(new Base16().decode(s3)));
+    }
+
+    private String toString(final byte[] data) {
+        final StringBuilder buf = new StringBuilder();
+        for (int i = 0; i < data.length; i++) {
+            buf.append(data[i]);
+            if (i != data.length - 1) {
+                buf.append("","");
+            }
+        }
+        return buf.toString();
+    }
+
+    /**
+     * Test for CODEC-265: Encode a ~1GiB file.
+     *
+     * @see <a href=""https://issues.apache.org/jira/projects/CODEC/issues/CODEC-265"">CODEC-265</a>
+     */
+    @Test
+    public void testCodec265_over() {
+        // almost 1GiB file to encode: 2^29 bytes
+        final int size1GiB = 1 << 29;
+
+        // Expecting a size of 2 output bytes per 1 input byte
+        final int blocks = size1GiB;
+        final int expectedLength = 2 * blocks;
+
+        // This test is memory hungry. Check we can run it.
+        final long presumableFreeMemory = BaseNCodecTest.getPresumableFreeMemory();
+
+        // Estimate the maximum memory required:
+        // 1GiB + 1GiB + ~2GiB + ~1.33GiB + 32 KiB  = ~5.33GiB
+        //
+        // 1GiB: Input buffer to encode
+        // 1GiB: Existing working buffer (due to doubling of default buffer size of 8192)
+        // ~2GiB: New working buffer to allocate (due to doubling)
+        // ~1.33GiB: Expected output size (since the working buffer is copied at the end)
+        // 32KiB: Some head room
+        final long estimatedMemory = (long) size1GiB * 4 + expectedLength + 32 * 1024;
+        Assume.assumeTrue(""Not enough free memory for the test"", presumableFreeMemory > estimatedMemory);
+
+        final byte[] bytes = new byte[size1GiB];
+        final byte[] encoded = new Base16().encode(bytes);
+        assertEquals(expectedLength, encoded.length);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void checkEncodeLengthBounds() {
+        final Base16 base16 = new Base16();
+        base16.encode(new byte[10], 0, 1 << 30);
+    }
+
+    @Test
+    public void testIsInAlphabet() {
+        // invalid bounds
+        Base16 b16 = new Base16(true);
+        assertFalse(b16.isInAlphabet((byte)0));
+        assertFalse(b16.isInAlphabet((byte)1));
+        assertFalse(b16.isInAlphabet((byte)-1));
+        assertFalse(b16.isInAlphabet((byte)-15));
+        assertFalse(b16.isInAlphabet((byte)-16));
+        assertFalse(b16.isInAlphabet((byte)128));
+        assertFalse(b16.isInAlphabet((byte)255));
+
+        // lower-case
+        b16 = new Base16(true);
+        for (char c = '0'; c <= '9'; c++) {
+            assertTrue(b16.isInAlphabet((byte) c));
+        }
+        for (char c = 'a'; c <= 'f'; c++) {
+            assertTrue(b16.isInAlphabet((byte) c));
+        }
+        for (char c = 'A'; c <= 'F'; c++) {
+            assertFalse(b16.isInAlphabet((byte) c));
+        }
+        assertFalse(b16.isInAlphabet((byte) ('0' - 1)));
+        assertFalse(b16.isInAlphabet((byte) ('9' + 1)));
+        assertFalse(b16.isInAlphabet((byte) ('a' - 1)));
+        assertFalse(b16.isInAlphabet((byte) ('z' + 1)));","[{'comment': ""Just spotted this one. It should be `'f' + 1`"", 'commenter': 'aherbert'}, {'comment': ""My intention was for `'z' + 1`... I will add f+1 too"", 'commenter': 'adamretter'}]"
49,src/main/java/org/apache/commons/codec/binary/Hex.java,"@@ -148,12 +169,62 @@
     protected static char[] encodeHex(final byte[] data, final char[] toDigits) {
         final int l = data.length;
         final char[] out = new char[l << 1];
+        encodeHex(data, 0, data.length, toDigits, out, 0);
+        return out;
+    }
+
+    /**
+     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.
+     *
+     * @param data a byte[] to convert to Hex characters
+     * @param dataOffset the position in {@code data} to start encoding from
+     * @param dataLen the number of bytes from {@code dataOffset} to encode
+     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase
+     * @return A char[] containing the appropriate characters from the alphabet For best results, this should be either
+     *         upper- or lower-case hex.
+     * @since 1.15
+     */
+    protected static char[] encodeHex(final byte[] data, final int dataOffset, final int dataLen,
+            final boolean toLowerCase) {
+        final char[] out = new char[dataLen << 1];
+        encodeHex(data, dataOffset, dataLen, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER, out, 0);
+        return out;
+    }
+
+    /**
+     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.
+     *
+     * @param data a byte[] to convert to Hex characters
+     * @param dataOffset the position in {@code data} to start encoding from
+     * @param dataLen the number of bytes from {@code dataOffset} to encode
+     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase
+     * @param out a char[] which will hold the resultant appropriate characters from the alphabet.
+     * @param outOffset the position within {@code out} at which to start writing the encoded characters.
+     * @since 1.15
+     */
+    protected static void encodeHex(final byte[] data, final int dataOffset, final int dataLen,","[{'comment': 'Should be public', 'commenter': 'aherbert'}]"
49,src/main/java/org/apache/commons/codec/binary/Hex.java,"@@ -148,12 +169,62 @@
     protected static char[] encodeHex(final byte[] data, final char[] toDigits) {
         final int l = data.length;
         final char[] out = new char[l << 1];
+        encodeHex(data, 0, data.length, toDigits, out, 0);
+        return out;
+    }
+
+    /**
+     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.
+     *
+     * @param data a byte[] to convert to Hex characters
+     * @param dataOffset the position in {@code data} to start encoding from
+     * @param dataLen the number of bytes from {@code dataOffset} to encode
+     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase
+     * @return A char[] containing the appropriate characters from the alphabet For best results, this should be either
+     *         upper- or lower-case hex.
+     * @since 1.15
+     */
+    protected static char[] encodeHex(final byte[] data, final int dataOffset, final int dataLen,","[{'comment': 'Should be public', 'commenter': 'aherbert'}]"
67,src/main/java/org/apache/commons/codec/binary/Hex.java,"@@ -168,7 +168,7 @@ public static int decodeHex(final char[] data, final byte[] out, final int outOf
     protected static char[] encodeHex(final byte[] data, final char[] toDigits) {
         final int l = data.length;
         final char[] out = new char[l << 1];
-        encodeHex(data, 0, data.length, toDigits, out, 0);
+        encodeHex(data, 0, l, toDigits, out, 0);","[{'comment': 'No mystery names please, especially ""l"" which can look just like a ""1"" depending on your font!', 'commenter': 'garydgregory'}, {'comment': 'agree. fixit', 'commenter': 'arturobernalg'}]"
67,src/main/java/org/apache/commons/codec/cli/Digest.java,"@@ -61,16 +61,17 @@ private Digest(final String[] args) {
         if (args == null) {
             throw new IllegalArgumentException(""args"");
         }
-        if (args.length == 0) {
+        final int argsLength = args.length;
+        if (argsLength == 0) {
             throw new IllegalArgumentException(
                     String.format(""Usage: java %s [algorithm] [FILE|DIRECTORY|string] ..."", Digest.class.getName()));
         }
         this.args = args;
         algorithm = args[0];
-        if (args.length <= 1) {
+        if (argsLength <= 1) {
             inputs = null;
         } else {
-            inputs = new String[args.length -1];
+            inputs = new String[argsLength -1];","[{'comment': 'Formatting.', 'commenter': 'garydgregory'}, {'comment': 'agree. fixit', 'commenter': 'arturobernalg'}]"
67,src/main/java/org/apache/commons/codec/language/bm/Rule.java,"@@ -488,11 +496,12 @@ private static RPattern pattern(final String regex) {
         final boolean endsWith = regex.endsWith(""$"");
         final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());
         final boolean boxes = content.contains(""["");
+        final int contentLength = content.length();
 
         if (!boxes) {
             if (startsWith && endsWith) {
                 // exact match
-                if (content.length() == 0) {
+                if (contentLength == 0) {","[{'comment': 'Just use `String#isEmpty()` for 0-length checks on Strings.\r\n', 'commenter': 'garydgregory'}, {'comment': 'agree. fixit', 'commenter': 'arturobernalg'}]"
67,src/main/java/org/apache/commons/codec/language/bm/Rule.java,"@@ -507,7 +516,7 @@ public boolean isMatch(final CharSequence input) {
                         return input.equals(content);
                     }
                 };
-            } else if ((startsWith || endsWith) && content.length() == 0) {
+            } else if ((startsWith || endsWith) && contentLength == 0) {","[{'comment': 'See above.', 'commenter': 'garydgregory'}]"
67,src/test/java/org/apache/commons/codec/cli/DigestTest.java,"@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.cli;
+
+import org.junit.Test;
+
+import java.io.IOException;
+
+
+/**
+ * Tests {@link Digest}.
+ *
+ * @since 1.17
+ */
+public class DigestTest{
+
+    /**
+     * Tests if empty arguments are handled correctly.
+     *
+     * @throws IllegalArgumentException for some failure scenarios.
+     */
+    @Test(expected = IllegalArgumentException.class)","[{'comment': 'Do we need a local var?', 'commenter': 'garydgregory'}, {'comment': 'agree. fixit', 'commenter': 'arturobernalg'}]"
67,src/test/java/org/apache/commons/codec/cli/DigestTest.java,"@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.cli;
+
+import org.junit.Test;
+
+import java.io.IOException;
+
+
+/**
+ * Tests {@link Digest}.
+ *
+ * @since 1.17
+ */
+public class DigestTest{","[{'comment': 'Fix formatting.\r\n', 'commenter': 'garydgregory'}, {'comment': 'Fix it ', 'commenter': 'arturobernalg'}]"
78,src/main/java/org/apache/commons/codec/binary/BinaryCodec.java,"@@ -136,8 +136,10 @@
      * @param array
      *            the source array
      * @return {@code true} if the given array is {@code null} or empty (size 0.)
+     *
+     * @since 1.16 change visibility to public
      */
-    private static boolean isEmpty(final byte[] array) {
+    public static boolean isEmpty(final byte[] array) {","[{'comment': 'Hello @arturobernalg \r\nPlease make this package private instead of public, this helps minimize the API footprint we will need to maintain for BC, especially since this is just for internal use.', 'commenter': 'garydgregory'}]"
78,src/main/java/org/apache/commons/codec/binary/StringUtils.java,"@@ -269,6 +269,25 @@ public static ByteBuffer getByteBufferUtf8(final String string) {
         return getBytes(string, StandardCharsets.UTF_8);
     }
 
+    /**
+     * <p>Checks if a CharSequence is empty ("""") or null.</p>
+     *
+     * <pre>
+     * StringUtils.isEmpty(null)      = true
+     * StringUtils.isEmpty("""")        = true
+     * StringUtils.isEmpty("" "")       = false
+     * StringUtils.isEmpty(""bob"")     = false
+     * StringUtils.isEmpty(""  bob  "") = false
+     * </pre>
+     *
+     * @param cs  the CharSequence to check, may be null
+     * @return {@code true} if the CharSequence is empty or null
+     * @since 1.16
+     */
+    public static boolean isEmpty(final CharSequence cs) {","[{'comment': 'Make this package-private and move it somewhere in the language package since it is the only place where it seems to be called, which will help as noted in my other comment.', 'commenter': 'garydgregory'}, {'comment': 'Hi @arturobernalg ping?', 'commenter': 'garydgregory'}, {'comment': 'changed ', 'commenter': 'arturobernalg'}]"
78,src/test/java/org/apache/commons/codec/binary/StringUtilsTest.java,"@@ -121,6 +121,7 @@ public void testGetBytesUncheckedNullInput() {
         Assert.assertNull(StringUtils.getBytesUnchecked(null, ""UNKNOWN""));
     }
 
+","[{'comment': 'I do not think we need this extra blank line.', 'commenter': 'garydgregory'}, {'comment': 'removed.', 'commenter': 'arturobernalg'}]"
79,src/main/java/org/apache/commons/codec/digest/Blake3.java,"@@ -0,0 +1,455 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.codec.digest;
+
+import java.util.Arrays;
+import java.util.Objects;
+
+/**
+ * Implements the Blake3 algorithm providing a {@linkplain #initHash() hash function} with extensible output (XOF), a
+ * {@linkplain #initKeyedHash(byte[]) keyed hash function} (MAC, PRF), and a
+ * {@linkplain #initKeyDerivationFunction(byte[]) key derivation function} (KDF). Blake3 has a 128-bit security level
+ * and a default output length of 256 bits (32 bytes) which can extended up to 2<sup>64</sup> bytes.
+ * <p>
+ * Adapted from the ISC-licensed O(1) Cryptography library by Matt Sicker and ported from the reference public domain
+ * implementation by Jack O'Connor.
+ * </p>
+ *
+ * @see <a href=""https://github.com/BLAKE3-team/BLAKE3"">BLAKE3 hash function</a>
+ * @since 1.16
+ */
+public final class Blake3 {
+    // TODO: migrate to Integer.BYTES after upgrading to Java 8
+    private static final int INT_BYTES = Integer.SIZE / Byte.SIZE;
+
+    private static final int BLOCK_LEN = 64;
+    private static final int KEY_LEN = 32;
+    private static final int OUT_LEN = 32;
+    private static final int CHUNK_LEN = 1024;
+
+    private static final int[] IV =
+            { 0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19 };
+
+    // domain flags
+    private static final int CHUNK_START = 1;
+    private static final int CHUNK_END = 1 << 1;
+    private static final int PARENT = 1 << 2;
+    private static final int ROOT = 1 << 3;
+    private static final int KEYED_HASH = 1 << 4;
+    private static final int DERIVE_KEY_CONTEXT = 1 << 5;
+    private static final int DERIVE_KEY_MATERIAL = 1 << 6;
+
+    private final EngineState engineState;
+
+    private Blake3(final int[] key, final int flags) {
+        engineState = new EngineState(key, flags);
+    }
+
+    /**
+     * Resets this instance back to its initial state when it was first constructed.
+     */
+    public void reset() {
+        engineState.reset();
+    }
+
+    /**
+     * Absorbs the provided bytes into this instance's state.
+     *
+     * @param in source array to absorb data from
+     */
+    public void absorb(final byte[] in) {
+        Objects.requireNonNull(in);
+        absorb(in, 0, in.length);
+    }
+
+    /**
+     * Absorbs the provided bytes at an offset into this instance's state.
+     *
+     * @param in     source array to absorb data from
+     * @param offset where in the array to begin absorbing bytes
+     * @param length number of bytes to absorb in
+     */
+    public void absorb(final byte[] in, final int offset, final int length) {
+        Objects.requireNonNull(in);
+        engineState.inputData(in, offset, length);
+    }
+
+    /**
+     * Squeezes hash output data that depends on the sequence of absorbed bytes preceding this invocation and any previously
+     * squeezed bytes.
+     *
+     * @param out destination array to squeeze bytes into
+     */
+    public void squeeze(final byte[] out) {","[{'comment': 'I do not think a lot of these methods need to be public. I think most uses cases would be ""hash this"" without concern about the details. The less public APIs footprint we present, the more freedom with have to change the class.', 'commenter': 'garydgregory'}, {'comment': 'The original name for this method is `finalize` which doesn\'t mesh too well with Java (similar to why the crypto APIs use `doFinal()` instead of `final()`). Perhaps I could use `doFinalize()`? This method is used for calculating the hash and can be done incrementally (e.g., knowing the hash of a part of a file as it\'s streaming) and being an extensible output function, this can ""squeeze"" as many bytes as requested to create an arbitrarily long hash (up to 2^64 bytes I think).\r\n\r\nThe squeeze/absorb naming is something I borrowed from internals of SHA-3, so I\'m certainly up for renaming them to something else. Absorb is equivalent to `update` in `MessageDigest` and `Mac`.', 'commenter': 'jvz'}]"
79,src/test/java/org/apache/commons/codec/digest/Blake3TestVectorsTest.java,"@@ -0,0 +1,314 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.codec.digest;
+
+import org.apache.commons.codec.DecoderException;
+import org.apache.commons.codec.binary.Hex;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+
+import static org.junit.Assert.assertArrayEquals;
+
+// Each test is an input length and three outputs, one for each of the hash, keyed_hash, and derive_key modes.","[{'comment': 'Make this a Javadoc.\r\n', 'commenter': 'garydgregory'}]"
79,src/test/java/org/apache/commons/codec/digest/Blake3TestVectorsTest.java,"@@ -0,0 +1,314 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.codec.digest;
+
+import org.apache.commons.codec.DecoderException;
+import org.apache.commons.codec.binary.Hex;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+
+import static org.junit.Assert.assertArrayEquals;
+
+// Each test is an input length and three outputs, one for each of the hash, keyed_hash, and derive_key modes.
+// The input in each case is filled with a repeating sequence of 251 bytes: 0, 1, 2, ..., 249, 250, 0, 1, ..., and so on.
+// The key used with keyed_hash is the 32-byte ASCII string ""whats the Elvish word for friend"", also given in the `key` field
+// below. The context string used with derive_key is the ASCII string ""BLAKE3 2019-12-27 16:29:52 test vectors context"", also
+// given in the `context_string` field below. Outputs are encoded as hexadecimal. Each case is an extended output, and
+// implementations should also check that the first 32 bytes match their default-length output.
+@RunWith(Parameterized.class)
+public class Blake3TestVectorsTest {
+    private static final byte[] KEY = ""whats the Elvish word for friend"".getBytes(StandardCharsets.UTF_8);
+    private static final byte[] CTX =
+            ""BLAKE3 2019-12-27 16:29:52 test vectors context"".getBytes(StandardCharsets.UTF_8);
+
+    @Parameterized.Parameters
+    public static Object[][] testCases() {
+        return new Object[][] {
+                {
+                        0,
+                        ""af1349b9f5f9a1a6a0404dea36dcc9499bcb25c9adc112b7cc9a93cae41f3262e00f03e7b69af26b7faaf09fcd333050338ddfe085b8cc869ca98b206c08243a26f5487789e8f660afe6c99ef9e0c52b92e7393024a80459cf91f476f9ffdbda7001c22e159b402631f277ca96f2defdf1078282314e763699a31c5363165421cce14d"",
+                        ""92b2b75604ed3c761f9d6f62392c8a9227ad0ea3f09573e783f1498a4ed60d26b18171a2f22a4b94822c701f107153dba24918c4bae4d2945c20ece13387627d3b73cbf97b797d5e59948c7ef788f54372df45e45e4293c7dc18c1d41144a9758be58960856be1eabbe22c2653190de560ca3b2ac4aa692a9210694254c371e851bc8f"",
+                        ""2cc39783c223154fea8dfb7c1b1660f2ac2dcbd1c1de8277b0b0dd39b7e50d7d905630c8be290dfcf3e6842f13bddd573c098c3f17361f1f206b8cad9d088aa4a3f746752c6b0ce6a83b0da81d59649257cdf8eb3e9f7d4998e41021fac119deefb896224ac99f860011f73609e6e0e4540f93b273e56547dfd3aa1a035ba6689d89a0""
+                },
+                {
+                        1,
+                        ""2d3adedff11b61f14c886e35afa036736dcd87a74d27b5c1510225d0f592e213c3a6cb8bf623e20cdb535f8d1a5ffb86342d9c0b64aca3bce1d31f60adfa137b358ad4d79f97b47c3d5e79f179df87a3b9776ef8325f8329886ba42f07fb138bb502f4081cbcec3195c5871e6c23e2cc97d3c69a613eba131e5f1351f3f1da786545e5"",
+                        ""6d7878dfff2f485635d39013278ae14f1454b8c0a3a2d34bc1ab38228a80c95b6568c0490609413006fbd428eb3fd14e7756d90f73a4725fad147f7bf70fd61c4e0cf7074885e92b0e3f125978b4154986d4fb202a3f331a3fb6cf349a3a70e49990f98fe4289761c8602c4e6ab1138d31d3b62218078b2f3ba9a88e1d08d0dd4cea11"",
+                        ""b3e2e340a117a499c6cf2398a19ee0d29cca2bb7404c73063382693bf66cb06c5827b91bf889b6b97c5477f535361caefca0b5d8c4746441c57617111933158950670f9aa8a05d791daae10ac683cbef8faf897c84e6114a59d2173c3f417023a35d6983f2c7dfa57e7fc559ad751dbfb9ffab39c2ef8c4aafebc9ae973a64f0c76551""
+                },
+                {
+                        2,
+                        ""7b7015bb92cf0b318037702a6cdd81dee41224f734684c2c122cd6359cb1ee63d8386b22e2ddc05836b7c1bb693d92af006deb5ffbc4c70fb44d0195d0c6f252faac61659ef86523aa16517f87cb5f1340e723756ab65efb2f91964e14391de2a432263a6faf1d146937b35a33621c12d00be8223a7f1919cec0acd12097ff3ab00ab1"",
+                        ""5392ddae0e0a69d5f40160462cbd9bd889375082ff224ac9c758802b7a6fd20a9ffbf7efd13e989a6c246f96d3a96b9d279f2c4e63fb0bdff633957acf50ee1a5f658be144bab0f6f16500dee4aa5967fc2c586d85a04caddec90fffb7633f46a60786024353b9e5cebe277fcd9514217fee2267dcda8f7b31697b7c54fab6a939bf8f"",
+                        ""1f166565a7df0098ee65922d7fea425fb18b9943f19d6161e2d17939356168e6daa59cae19892b2d54f6fc9f475d26031fd1c22ae0a3e8ef7bdb23f452a15e0027629d2e867b1bb1e6ab21c71297377750826c404dfccc2406bd57a83775f89e0b075e59a7732326715ef912078e213944f490ad68037557518b79c0086de6d6f6cdd2""
+                },
+                {
+                        3,
+                        ""e1be4d7a8ab5560aa4199eea339849ba8e293d55ca0a81006726d184519e647f5b49b82f805a538c68915c1ae8035c900fd1d4b13902920fd05e1450822f36de9454b7e9996de4900c8e723512883f93f4345f8a58bfe64ee38d3ad71ab027765d25cdd0e448328a8e7a683b9a6af8b0af94fa09010d9186890b096a08471e4230a134"",
+                        ""39e67b76b5a007d4921969779fe666da67b5213b096084ab674742f0d5ec62b9b9142d0fab08e1b161efdbb28d18afc64d8f72160c958e53a950cdecf91c1a1bbab1a9c0f01def762a77e2e8545d4dec241e98a89b6db2e9a5b070fc110caae2622690bd7b76c02ab60750a3ea75426a6bb8803c370ffe465f07fb57def95df772c39f"",
+                        ""440aba35cb006b61fc17c0529255de438efc06a8c9ebf3f2ddac3b5a86705797f27e2e914574f4d87ec04c379e12789eccbfbc15892626042707802dbe4e97c3ff59dca80c1e54246b6d055154f7348a39b7d098b2b4824ebe90e104e763b2a447512132cede16243484a55a4e40a85790038bb0dcf762e8c053cabae41bbe22a5bff7""
+                },
+                {
+                        4,
+                        ""f30f5ab28fe047904037f77b6da4fea1e27241c5d132638d8bedce9d40494f328f603ba4564453e06cdcee6cbe728a4519bbe6f0d41e8a14b5b225174a566dbfa61b56afb1e452dc08c804f8c3143c9e2cc4a31bb738bf8c1917b55830c6e65797211701dc0b98daa1faeaa6ee9e56ab606ce03a1a881e8f14e87a4acf4646272cfd12"",
+                        ""7671dde590c95d5ac9616651ff5aa0a27bee5913a348e053b8aa9108917fe070116c0acff3f0d1fa97ab38d813fd46506089118147d83393019b068a55d646251ecf81105f798d76a10ae413f3d925787d6216a7eb444e510fd56916f1d753a5544ecf0072134a146b2615b42f50c179f56b8fae0788008e3e27c67482349e249cb86a"",
+                        ""f46085c8190d69022369ce1a18880e9b369c135eb93f3c63550d3e7630e91060fbd7d8f4258bec9da4e05044f88b91944f7cab317a2f0c18279629a3867fad0662c9ad4d42c6f27e5b124da17c8c4f3a94a025ba5d1b623686c6099d202a7317a82e3d95dae46a87de0555d727a5df55de44dab799a20dffe239594d6e99ed17950910""
+                },
+                {
+                        5,
+                        ""b40b44dfd97e7a84a996a91af8b85188c66c126940ba7aad2e7ae6b385402aa2ebcfdac6c5d32c31209e1f81a454751280db64942ce395104e1e4eaca62607de1c2ca748251754ea5bbe8c20150e7f47efd57012c63b3c6a6632dc1c7cd15f3e1c999904037d60fac2eb9397f2adbe458d7f264e64f1e73aa927b30988e2aed2f03620"",
+                        ""73ac69eecf286894d8102018a6fc729f4b1f4247d3703f69bdc6a5fe3e0c84616ab199d1f2f3e53bffb17f0a2209fe8b4f7d4c7bae59c2bc7d01f1ff94c67588cc6b38fa6024886f2c078bfe09b5d9e6584cd6c521c3bb52f4de7687b37117a2dbbec0d59e92fa9a8cc3240d4432f91757aabcae03e87431dac003e7d73574bfdd8218"",
+                        ""1f24eda69dbcb752847ec3ebb5dd42836d86e58500c7c98d906ecd82ed9ae47f6f48a3f67e4e43329c9a89b1ca526b9b35cbf7d25c1e353baffb590fd79be58ddb6c711f1a6b60e98620b851c688670412fcb0435657ba6b638d21f0f2a04f2f6b0bd8834837b10e438d5f4c7c2c71299cf7586ea9144ed09253d51f8f54dd6bff719d""
+                },
+                {
+                        6,
+                        ""06c4e8ffb6872fad96f9aaca5eee1553eb62aed0ad7198cef42e87f6a616c844611a30c4e4f37fe2fe23c0883cde5cf7059d88b657c7ed2087e3d210925ede716435d6d5d82597a1e52b9553919e804f5656278bd739880692c94bff2824d8e0b48cac1d24682699e4883389dc4f2faa2eb3b4db6e39debd5061ff3609916f3e07529a"",
+                        ""82d3199d0013035682cc7f2a399d4c212544376a839aa863a0f4c91220ca7a6dc2ffb3aa05f2631f0fa9ac19b6e97eb7e6669e5ec254799350c8b8d189e8807800842a5383c4d907c932f34490aaf00064de8cdb157357bde37c1504d2960034930887603abc5ccb9f5247f79224baff6120a3c622a46d7b1bcaee02c5025460941256"",
+                        ""be96b30b37919fe4379dfbe752ae77b4f7e2ab92f7ff27435f76f2f065f6a5f435ae01a1d14bd5a6b3b69d8cbd35f0b01ef2173ff6f9b640ca0bd4748efa398bf9a9c0acd6a66d9332fdc9b47ffe28ba7ab6090c26747b85f4fab22f936b71eb3f64613d8bd9dfabe9bb68da19de78321b481e5297df9e40ec8a3d662f3e1479c65de0""
+                },
+                {
+                        7,
+                        ""3f8770f387faad08faa9d8414e9f449ac68e6ff0417f673f602a646a891419fe66036ef6e6d1a8f54baa9fed1fc11c77cfb9cff65bae915045027046ebe0c01bf5a941f3bb0f73791d3fc0b84370f9f30af0cd5b0fc334dd61f70feb60dad785f070fef1f343ed933b49a5ca0d16a503f599a365a4296739248b28d1a20b0e2cc8975c"",
+                        ""af0a7ec382aedc0cfd626e49e7628bc7a353a4cb108855541a5651bf64fbb28a7c5035ba0f48a9c73dabb2be0533d02e8fd5d0d5639a18b2803ba6bf527e1d145d5fd6406c437b79bcaad6c7bdf1cf4bd56a893c3eb9510335a7a798548c6753f74617bede88bef924ba4b334f8852476d90b26c5dc4c3668a2519266a562c6c8034a6"",
+                        ""dc3b6485f9d94935329442916b0d059685ba815a1fa2a14107217453a7fc9f0e66266db2ea7c96843f9d8208e600a73f7f45b2f55b9e6d6a7ccf05daae63a3fdd10b25ac0bd2e224ce8291f88c05976d575df998477db86fb2cfbbf91725d62cb57acfeb3c2d973b89b503c2b60dde85a7802b69dc1ac2007d5623cbea8cbfb6b181f5""
+                },
+                {
+                        8,
+                        ""2351207d04fc16ade43ccab08600939c7c1fa70a5c0aaca76063d04c3228eaeb725d6d46ceed8f785ab9f2f9b06acfe398c6699c6129da084cb531177445a682894f9685eaf836999221d17c9a64a3a057000524cd2823986db378b074290a1a9b93a22e135ed2c14c7e20c6d045cd00b903400374126676ea78874d79f2dd7883cf5c"",
+                        ""be2f5495c61cba1bb348a34948c004045e3bd4dae8f0fe82bf44d0da245a060048eb5e68ce6dea1eb0229e144f578b3aa7e9f4f85febd135df8525e6fe40c6f0340d13dd09b255ccd5112a94238f2be3c0b5b7ecde06580426a93e0708555a265305abf86d874e34b4995b788e37a823491f25127a502fe0704baa6bfdf04e76c13276"",
+                        ""2b166978cef14d9d438046c720519d8b1cad707e199746f1562d0c87fbd32940f0e2545a96693a66654225ebbaac76d093bfa9cd8f525a53acb92a861a98c42e7d1c4ae82e68ab691d510012edd2a728f98cd4794ef757e94d6546961b4f280a51aac339cc95b64a92b83cc3f26d8af8dfb4c091c240acdb4d47728d23e7148720ef04""
+                },
+                {
+                        63,
+                        ""e9bc37a594daad83be9470df7f7b3798297c3d834ce80ba85d6e207627b7db7b1197012b1e7d9af4d7cb7bdd1f3bb49a90a9b5dec3ea2bbc6eaebce77f4e470cbf4687093b5352f04e4a4570fba233164e6acc36900e35d185886a827f7ea9bdc1e5c3ce88b095a200e62c10c043b3e9bc6cb9b6ac4dfa51794b02ace9f98779040755"",
+                        ""bb1eb5d4afa793c1ebdd9fb08def6c36d10096986ae0cfe148cd101170ce37aea05a63d74a840aecd514f654f080e51ac50fd617d22610d91780fe6b07a26b0847abb38291058c97474ef6ddd190d30fc318185c09ca1589d2024f0a6f16d45f11678377483fa5c005b2a107cb9943e5da634e7046855eaa888663de55d6471371d55d"",
+                        ""b6451e30b953c206e34644c6803724e9d2725e0893039cfc49584f991f451af3b89e8ff572d3da4f4022199b9563b9d70ebb616efff0763e9abec71b550f1371e233319c4c4e74da936ba8e5bbb29a598e007a0bbfa929c99738ca2cc098d59134d11ff300c39f82e2fce9f7f0fa266459503f64ab9913befc65fddc474f6dc1c67669""
+                },
+                {
+                        64,
+                        ""4eed7141ea4a5cd4b788606bd23f46e212af9cacebacdc7d1f4c6dc7f2511b98fc9cc56cb831ffe33ea8e7e1d1df09b26efd2767670066aa82d023b1dfe8ab1b2b7fbb5b97592d46ffe3e05a6a9b592e2949c74160e4674301bc3f97e04903f8c6cf95b863174c33228924cdef7ae47559b10b294acd660666c4538833582b43f82d74"",
+                        ""ba8ced36f327700d213f120b1a207a3b8c04330528586f414d09f2f7d9ccb7e68244c26010afc3f762615bbac552a1ca909e67c83e2fd5478cf46b9e811efccc93f77a21b17a152ebaca1695733fdb086e23cd0eb48c41c034d52523fc21236e5d8c9255306e48d52ba40b4dac24256460d56573d1312319afcf3ed39d72d0bfc69acb"",
+                        ""a5c4a7053fa86b64746d4bb688d06ad1f02a18fce9afd3e818fefaa7126bf73e9b9493a9befebe0bf0c9509fb3105cfa0e262cde141aa8e3f2c2f77890bb64a4cca96922a21ead111f6338ad5244f2c15c44cb595443ac2ac294231e31be4a4307d0a91e874d36fc9852aeb1265c09b6e0cda7c37ef686fbbcab97e8ff66718be048bb""
+                },
+                {
+                        65,
+                        ""de1e5fa0be70df6d2be8fffd0e99ceaa8eb6e8c93a63f2d8d1c30ecb6b263dee0e16e0a4749d6811dd1d6d1265c29729b1b75a9ac346cf93f0e1d7296dfcfd4313b3a227faaaaf7757cc95b4e87a49be3b8a270a12020233509b1c3632b3485eef309d0abc4a4a696c9decc6e90454b53b000f456a3f10079072baaf7a981653221f2c"",
+                        ""c0a4edefa2d2accb9277c371ac12fcdbb52988a86edc54f0716e1591b4326e72d5e795f46a596b02d3d4bfb43abad1e5d19211152722ec1f20fef2cd413e3c22f2fc5da3d73041275be6ede3517b3b9f0fc67ade5956a672b8b75d96cb43294b9041497de92637ed3f2439225e683910cb3ae923374449ca788fb0f9bea92731bc26ad"",
+                        ""51fd05c3c1cfbc8ed67d139ad76f5cf8236cd2acd26627a30c104dfd9d3ff8a82b02e8bd36d8498a75ad8c8e9b15eb386970283d6dd42c8ae7911cc592887fdbe26a0a5f0bf821cd92986c60b2502c9be3f98a9c133a7e8045ea867e0828c7252e739321f7c2d65daee4468eb4429efae469a42763f1f94977435d10dccae3e3dce88d""
+                },
+                {
+                        127,
+                        ""d81293fda863f008c09e92fc382a81f5a0b4a1251cba1634016a0f86a6bd640de3137d477156d1fde56b0cf36f8ef18b44b2d79897bece12227539ac9ae0a5119da47644d934d26e74dc316145dcb8bb69ac3f2e05c242dd6ee06484fcb0e956dc44355b452c5e2bbb5e2b66e99f5dd443d0cbcaaafd4beebaed24ae2f8bb672bcef78"",
+                        ""c64200ae7dfaf35577ac5a9521c47863fb71514a3bcad18819218b818de85818ee7a317aaccc1458f78d6f65f3427ec97d9c0adb0d6dacd4471374b621b7b5f35cd54663c64dbe0b9e2d95632f84c611313ea5bd90b71ce97b3cf645776f3adc11e27d135cbadb9875c2bf8d3ae6b02f8a0206aba0c35bfe42574011931c9a255ce6dc"",
+                        ""c91c090ceee3a3ac81902da31838012625bbcd73fcb92e7d7e56f78deba4f0c3feeb3974306966ccb3e3c69c337ef8a45660ad02526306fd685c88542ad00f759af6dd1adc2e50c2b8aac9f0c5221ff481565cf6455b772515a69463223202e5c371743e35210bbbbabd89651684107fd9fe493c937be16e39cfa7084a36207c99bea3""
+                },
+                {
+                        128,
+                        ""f17e570564b26578c33bb7f44643f539624b05df1a76c81f30acd548c44b45efa69faba091427f9c5c4caa873aa07828651f19c55bad85c47d1368b11c6fd99e47ecba5820a0325984d74fe3e4058494ca12e3f1d3293d0010a9722f7dee64f71246f75e9361f44cc8e214a100650db1313ff76a9f93ec6e84edb7add1cb4a95019b0c"",
+                        ""b04fe15577457267ff3b6f3c947d93be581e7e3a4b018679125eaf86f6a628ecd86bbe0001f10bda47e6077b735016fca8119da11348d93ca302bbd125bde0db2b50edbe728a620bb9d3e6f706286aedea973425c0b9eedf8a38873544cf91badf49ad92a635a93f71ddfcee1eae536c25d1b270956be16588ef1cfef2f1d15f650bd5"",
+                        ""81720f34452f58a0120a58b6b4608384b5c51d11f39ce97161a0c0e442ca022550e7cd651e312f0b4c6afb3c348ae5dd17d2b29fab3b894d9a0034c7b04fd9190cbd90043ff65d1657bbc05bfdecf2897dd894c7a1b54656d59a50b51190a9da44db426266ad6ce7c173a8c0bbe091b75e734b4dadb59b2861cd2518b4e7591e4b83c9""
+                },
+                {
+                        129,
+                        ""683aaae9f3c5ba37eaaf072aed0f9e30bac0865137bae68b1fde4ca2aebdcb12f96ffa7b36dd78ba321be7e842d364a62a42e3746681c8bace18a4a8a79649285c7127bf8febf125be9de39586d251f0d41da20980b70d35e3dac0eee59e468a894fa7e6a07129aaad09855f6ad4801512a116ba2b7841e6cfc99ad77594a8f2d181a7"",
+                        ""d4a64dae6cdccbac1e5287f54f17c5f985105457c1a2ec1878ebd4b57e20d38f1c9db018541eec241b748f87725665b7b1ace3e0065b29c3bcb232c90e37897fa5aaee7e1e8a2ecfcd9b51463e42238cfdd7fee1aecb3267fa7f2128079176132a412cd8aaf0791276f6b98ff67359bd8652ef3a203976d5ff1cd41885573487bcd683"",
+                        ""938d2d4435be30eafdbb2b7031f7857c98b04881227391dc40db3c7b21f41fc18d72d0f9c1de5760e1941aebf3100b51d64644cb459eb5d20258e233892805eb98b07570ef2a1787cd48e117c8d6a63a68fd8fc8e59e79dbe63129e88352865721c8d5f0cf183f85e0609860472b0d6087cefdd186d984b21542c1c780684ed6832d8d""
+                },
+                {
+                        1023,
+                        ""10108970eeda3eb932baac1428c7a2163b0e924c9a9e25b35bba72b28f70bd11a182d27a591b05592b15607500e1e8dd56bc6c7fc063715b7a1d737df5bad3339c56778957d870eb9717b57ea3d9fb68d1b55127bba6a906a4a24bbd5acb2d123a37b28f9e9a81bbaae360d58f85e5fc9d75f7c370a0cc09b6522d9c8d822f2f28f485"",
+                        ""c951ecdf03288d0fcc96ee3413563d8a6d3589547f2c2fb36d9786470f1b9d6e890316d2e6d8b8c25b0a5b2180f94fb1a158ef508c3cde45e2966bd796a696d3e13efd86259d756387d9becf5c8bf1ce2192b87025152907b6d8cc33d17826d8b7b9bc97e38c3c85108ef09f013e01c229c20a83d9e8efac5b37470da28575fd755a10"",
+                        ""74a16c1c3d44368a86e1ca6df64be6a2f64cce8f09220787450722d85725dea59c413264404661e9e4d955409dfe4ad3aa487871bcd454ed12abfe2c2b1eb7757588cf6cb18d2eccad49e018c0d0fec323bec82bf1644c6325717d13ea712e6840d3e6e730d35553f59eff5377a9c350bcc1556694b924b858f329c44ee64b884ef00d""
+                },
+                {
+                        1024,
+                        ""42214739f095a406f3fc83deb889744ac00df831c10daa55189b5d121c855af71cf8107265ecdaf8505b95d8fcec83a98a6a96ea5109d2c179c47a387ffbb404756f6eeae7883b446b70ebb144527c2075ab8ab204c0086bb22b7c93d465efc57f8d917f0b385c6df265e77003b85102967486ed57db5c5ca170ba441427ed9afa684e"",
+                        ""75c46f6f3d9eb4f55ecaaee480db732e6c2105546f1e675003687c31719c7ba4a78bc838c72852d4f49c864acb7adafe2478e824afe51c8919d06168414c265f298a8094b1ad813a9b8614acabac321f24ce61c5a5346eb519520d38ecc43e89b5000236df0597243e4d2493fd626730e2ba17ac4d8824d09d1a4a8f57b8227778e2de"",
+                        ""7356cd7720d5b66b6d0697eb3177d9f8d73a4a5c5e968896eb6a6896843027066c23b601d3ddfb391e90d5c8eccdef4ae2a264bce9e612ba15e2bc9d654af1481b2e75dbabe615974f1070bba84d56853265a34330b4766f8e75edd1f4a1650476c10802f22b64bd3919d246ba20a17558bc51c199efdec67e80a227251808d8ce5bad""
+                },
+                {
+                        1025,
+                        ""d00278ae47eb27b34faecf67b4fe263f82d5412916c1ffd97c8cb7fb814b8444f4c4a22b4b399155358a994e52bf255de60035742ec71bd08ac275a1b51cc6bfe332b0ef84b409108cda080e6269ed4b3e2c3f7d722aa4cdc98d16deb554e5627be8f955c98e1d5f9565a9194cad0c4285f93700062d9595adb992ae68ff12800ab67a"",
+                        ""357dc55de0c7e382c900fd6e320acc04146be01db6a8ce7210b7189bd664ea69362396b77fdc0d2634a552970843722066c3c15902ae5097e00ff53f1e116f1cd5352720113a837ab2452cafbde4d54085d9cf5d21ca613071551b25d52e69d6c81123872b6f19cd3bc1333edf0c52b94de23ba772cf82636cff4542540a7738d5b930"",
+                        ""effaa245f065fbf82ac186839a249707c3bddf6d3fdda22d1b95a3c970379bcb5d31013a167509e9066273ab6e2123bc835b408b067d88f96addb550d96b6852dad38e320b9d940f86db74d398c770f462118b35d2724efa13da97194491d96dd37c3c09cbef665953f2ee85ec83d88b88d11547a6f911c8217cca46defa2751e7f3ad""
+                },
+                {
+                        2048,
+                        ""e776b6028c7cd22a4d0ba182a8bf62205d2ef576467e838ed6f2529b85fba24a9a60bf80001410ec9eea6698cd537939fad4749edd484cb541aced55cd9bf54764d063f23f6f1e32e12958ba5cfeb1bf618ad094266d4fc3c968c2088f677454c288c67ba0dba337b9d91c7e1ba586dc9a5bc2d5e90c14f53a8863ac75655461cea8f9"",
+                        ""879cf1fa2ea0e79126cb1063617a05b6ad9d0b696d0d757cf053439f60a99dd10173b961cd574288194b23ece278c330fbb8585485e74967f31352a8183aa782b2b22f26cdcadb61eed1a5bc144b8198fbb0c13abbf8e3192c145d0a5c21633b0ef86054f42809df823389ee40811a5910dcbd1018af31c3b43aa55201ed4edaac74fe"",
+                        ""7b2945cb4fef70885cc5d78a87bf6f6207dd901ff239201351ffac04e1088a23e2c11a1ebffcea4d80447867b61badb1383d842d4e79645d48dd82ccba290769caa7af8eaa1bd78a2a5e6e94fbdab78d9c7b74e894879f6a515257ccf6f95056f4e25390f24f6b35ffbb74b766202569b1d797f2d4bd9d17524c720107f985f4ddc583""
+                },
+                {
+                        2049,
+                        ""5f4d72f40d7a5f82b15ca2b2e44b1de3c2ef86c426c95c1af0b687952256303096de31d71d74103403822a2e0bc1eb193e7aecc9643a76b7bbc0c9f9c52e8783aae98764ca468962b5c2ec92f0c74eb5448d519713e09413719431c802f948dd5d90425a4ecdadece9eb178d80f26efccae630734dff63340285adec2aed3b51073ad3"",
+                        ""9f29700902f7c86e514ddc4df1e3049f258b2472b6dd5267f61bf13983b78dd5f9a88abfefdfa1e00b418971f2b39c64ca621e8eb37fceac57fd0c8fc8e117d43b81447be22d5d8186f8f5919ba6bcc6846bd7d50726c06d245672c2ad4f61702c646499ee1173daa061ffe15bf45a631e2946d616a4c345822f1151284712f76b2b0e"",
+                        ""2ea477c5515cc3dd606512ee72bb3e0e758cfae7232826f35fb98ca1bcbdf27316d8e9e79081a80b046b60f6a263616f33ca464bd78d79fa18200d06c7fc9bffd808cc4755277a7d5e09da0f29ed150f6537ea9bed946227ff184cc66a72a5f8c1e4bd8b04e81cf40fe6dc4427ad5678311a61f4ffc39d195589bdbc670f63ae70f4b6""
+                },
+                {
+                        3072,
+                        ""b98cb0ff3623be03326b373de6b9095218513e64f1ee2edd2525c7ad1e5cffd29a3f6b0b978d6608335c09dc94ccf682f9951cdfc501bfe47b9c9189a6fc7b404d120258506341a6d802857322fbd20d3e5dae05b95c88793fa83db1cb08e7d8008d1599b6209d78336e24839724c191b2a52a80448306e0daa84a3fdb566661a37e11"",
+                        ""044a0e7b172a312dc02a4c9a818c036ffa2776368d7f528268d2e6b5df19177022f302d0529e4174cc507c463671217975e81dab02b8fdeb0d7ccc7568dd22574c783a76be215441b32e91b9a904be8ea81f7a0afd14bad8ee7c8efc305ace5d3dd61b996febe8da4f56ca0919359a7533216e2999fc87ff7d8f176fbecb3d6f34278b"",
+                        ""050df97f8c2ead654d9bb3ab8c9178edcd902a32f8495949feadcc1e0480c46b3604131bbd6e3ba573b6dd682fa0a63e5b165d39fc43a625d00207607a2bfeb65ff1d29292152e26b298868e3b87be95d6458f6f2ce6118437b632415abe6ad522874bcd79e4030a5e7bad2efa90a7a7c67e93f0a18fb28369d0a9329ab5c24134ccb0""
+                },
+                {
+                        3073,
+                        ""7124b49501012f81cc7f11ca069ec9226cecb8a2c850cfe644e327d22d3e1cd39a27ae3b79d68d89da9bf25bc27139ae65a324918a5f9b7828181e52cf373c84f35b639b7fccbb985b6f2fa56aea0c18f531203497b8bbd3a07ceb5926f1cab74d14bd66486d9a91eba99059a98bd1cd25876b2af5a76c3e9eed554ed72ea952b603bf"",
+                        ""68dede9bef00ba89e43f31a6825f4cf433389fedae75c04ee9f0cf16a427c95a96d6da3fe985054d3478865be9a092250839a697bbda74e279e8a9e69f0025e4cfddd6cfb434b1cd9543aaf97c635d1b451a4386041e4bb100f5e45407cbbc24fa53ea2de3536ccb329e4eb9466ec37093a42cf62b82903c696a93a50b702c80f3c3c5"",
+                        ""72613c9ec9ff7e40f8f5c173784c532ad852e827dba2bf85b2ab4b76f7079081576288e552647a9d86481c2cae75c2dd4e7c5195fb9ada1ef50e9c5098c249d743929191441301c69e1f48505a4305ec1778450ee48b8e69dc23a25960fe33070ea549119599760a8a2d28aeca06b8c5e9ba58bc19e11fe57b6ee98aa44b2a8e6b14a5""
+                },
+                {
+                        4096,
+                        ""015094013f57a5277b59d8475c0501042c0b642e531b0a1c8f58d2163229e9690289e9409ddb1b99768eafe1623da896faf7e1114bebeadc1be30829b6f8af707d85c298f4f0ff4d9438aef948335612ae921e76d411c3a9111df62d27eaf871959ae0062b5492a0feb98ef3ed4af277f5395172dbe5c311918ea0074ce0036454f620"",
+                        ""befc660aea2f1718884cd8deb9902811d332f4fc4a38cf7c7300d597a081bfc0bbb64a36edb564e01e4b4aaf3b060092a6b838bea44afebd2deb8298fa562b7b597c757b9df4c911c3ca462e2ac89e9a787357aaf74c3b56d5c07bc93ce899568a3eb17d9250c20f6c5f6c1e792ec9a2dcb715398d5a6ec6d5c54f586a00403a1af1de"",
+                        ""1e0d7f3db8c414c97c6307cbda6cd27ac3b030949da8e23be1a1a924ad2f25b9d78038f7b198596c6cc4a9ccf93223c08722d684f240ff6569075ed81591fd93f9fff1110b3a75bc67e426012e5588959cc5a4c192173a03c00731cf84544f65a2fb9378989f72e9694a6a394a8a30997c2e67f95a504e631cd2c5f55246024761b245""
+                },
+                {
+                        4097,
+                        ""9b4052b38f1c5fc8b1f9ff7ac7b27cd242487b3d890d15c96a1c25b8aa0fb99505f91b0b5600a11251652eacfa9497b31cd3c409ce2e45cfe6c0a016967316c426bd26f619eab5d70af9a418b845c608840390f361630bd497b1ab44019316357c61dbe091ce72fc16dc340ac3d6e009e050b3adac4b5b2c92e722cffdc46501531956"",
+                        ""00df940cd36bb9fa7cbbc3556744e0dbc8191401afe70520ba292ee3ca80abbc606db4976cfdd266ae0abf667d9481831ff12e0caa268e7d3e57260c0824115a54ce595ccc897786d9dcbf495599cfd90157186a46ec800a6763f1c59e36197e9939e900809f7077c102f888caaf864b253bc41eea812656d46742e4ea42769f89b83f"",
+                        ""aca51029626b55fda7117b42a7c211f8c6e9ba4fe5b7a8ca922f34299500ead8a897f66a400fed9198fd61dd2d58d382458e64e100128075fc54b860934e8de2e84170734b06e1d212a117100820dbc48292d148afa50567b8b84b1ec336ae10d40c8c975a624996e12de31abbe135d9d159375739c333798a80c64ae895e51e22f3ad""
+                },
+                {
+                        5120,
+                        ""9cadc15fed8b5d854562b26a9536d9707cadeda9b143978f319ab34230535833acc61c8fdc114a2010ce8038c853e121e1544985133fccdd0a2d507e8e615e611e9a0ba4f47915f49e53d721816a9198e8b30f12d20ec3689989175f1bf7a300eee0d9321fad8da232ece6efb8e9fd81b42ad161f6b9550a069e66b11b40487a5f5059"",
+                        ""2c493e48e9b9bf31e0553a22b23503c0a3388f035cece68eb438d22fa1943e209b4dc9209cd80ce7c1f7c9a744658e7e288465717ae6e56d5463d4f80cdb2ef56495f6a4f5487f69749af0c34c2cdfa857f3056bf8d807336a14d7b89bf62bef2fb54f9af6a546f818dc1e98b9e07f8a5834da50fa28fb5874af91bf06020d1bf0120e"",
+                        ""7a7acac8a02adcf3038d74cdd1d34527de8a0fcc0ee3399d1262397ce5817f6055d0cefd84d9d57fe792d65a278fd20384ac6c30fdb340092f1a74a92ace99c482b28f0fc0ef3b923e56ade20c6dba47e49227166251337d80a037e987ad3a7f728b5ab6dfafd6e2ab1bd583a95d9c895ba9c2422c24ea0f62961f0dca45cad47bfa0d""
+                },
+                {
+                        5121,
+                        ""628bd2cb2004694adaab7bbd778a25df25c47b9d4155a55f8fbd79f2fe154cff96adaab0613a6146cdaabe498c3a94e529d3fc1da2bd08edf54ed64d40dcd6777647eac51d8277d70219a9694334a68bc8f0f23e20b0ff70ada6f844542dfa32cd4204ca1846ef76d811cdb296f65e260227f477aa7aa008bac878f72257484f2b6c95"",
+                        ""6ccf1c34753e7a044db80798ecd0782a8f76f33563accaddbfbb2e0ea4b2d0240d07e63f13667a8d1490e5e04f13eb617aea16a8c8a5aaed1ef6fbde1b0515e3c81050b361af6ead126032998290b563e3caddeaebfab592e155f2e161fb7cba939092133f23f9e65245e58ec23457b78a2e8a125588aad6e07d7f11a85b88d375b72d"",
+                        ""b07f01e518e702f7ccb44a267e9e112d403a7b3f4883a47ffbed4b48339b3c341a0add0ac032ab5aaea1e4e5b004707ec5681ae0fcbe3796974c0b1cf31a194740c14519273eedaabec832e8a784b6e7cfc2c5952677e6c3f2c3914454082d7eb1ce1766ac7d75a4d3001fc89544dd46b5147382240d689bbbaefc359fb6ae30263165""
+                },
+                {
+                        6144,
+                        ""3e2e5b74e048f3add6d21faab3f83aa44d3b2278afb83b80b3c35164ebeca2054d742022da6fdda444ebc384b04a54c3ac5839b49da7d39f6d8a9db03deab32aade156c1c0311e9b3435cde0ddba0dce7b26a376cad121294b689193508dd63151603c6ddb866ad16c2ee41585d1633a2cea093bea714f4c5d6b903522045b20395c83"",
+                        ""3d6b6d21281d0ade5b2b016ae4034c5dec10ca7e475f90f76eac7138e9bc8f1dc35754060091dc5caf3efabe0603c60f45e415bb3407db67e6beb3d11cf8e4f7907561f05dace0c15807f4b5f389c841eb114d81a82c02a00b57206b1d11fa6e803486b048a5ce87105a686dee041207e095323dfe172df73deb8c9532066d88f9da7e"",
+                        ""2a95beae63ddce523762355cf4b9c1d8f131465780a391286a5d01abb5683a1597099e3c6488aab6c48f3c15dbe1942d21dbcdc12115d19a8b8465fb54e9053323a9178e4275647f1a9927f6439e52b7031a0b465c861a3fc531527f7758b2b888cf2f20582e9e2c593709c0a44f9c6e0f8b963994882ea4168827823eef1f64169fef""
+                },
+                {
+                        6145,
+                        ""f1323a8631446cc50536a9f705ee5cb619424d46887f3c376c695b70e0f0507f18a2cfdd73c6e39dd75ce7c1c6e3ef238fd54465f053b25d21044ccb2093beb015015532b108313b5829c3621ce324b8e14229091b7c93f32db2e4e63126a377d2a63a3597997d4f1cba59309cb4af240ba70cebff9a23d5e3ff0cdae2cfd54e070022"",
+                        ""9ac301e9e39e45e3250a7e3b3df701aa0fb6889fbd80eeecf28dbc6300fbc539f3c184ca2f59780e27a576c1d1fb9772e99fd17881d02ac7dfd39675aca918453283ed8c3169085ef4a466b91c1649cc341dfdee60e32231fc34c9c4e0b9a2ba87ca8f372589c744c15fd6f985eec15e98136f25beeb4b13c4e43dc84abcc79cd4646c"",
+                        ""379bcc61d0051dd489f686c13de00d5b14c505245103dc040d9e4dd1facab8e5114493d029bdbd295aaa744a59e31f35c7f52dba9c3642f773dd0b4262a9980a2aef811697e1305d37ba9d8b6d850ef07fe41108993180cf779aeece363704c76483458603bbeeb693cffbbe5588d1f3535dcad888893e53d977424bb707201569a8d2""
+                },
+                {
+                        7168,
+                        ""61da957ec2499a95d6b8023e2b0e604ec7f6b50e80a9678b89d2628e99ada77a5707c321c83361793b9af62a40f43b523df1c8633cecb4cd14d00bdc79c78fca5165b863893f6d38b02ff7236c5a9a8ad2dba87d24c547cab046c29fc5bc1ed142e1de4763613bb162a5a538e6ef05ed05199d751f9eb58d332791b8d73fb74e4fce95"",
+                        ""b42835e40e9d4a7f42ad8cc04f85a963a76e18198377ed84adddeaecacc6f3fca2f01d5277d69bb681c70fa8d36094f73ec06e452c80d2ff2257ed82e7ba348400989a65ee8daa7094ae0933e3d2210ac6395c4af24f91c2b590ef87d7788d7066ea3eaebca4c08a4f14b9a27644f99084c3543711b64a070b94f2c9d1d8a90d035d52"",
+                        ""11c37a112765370c94a51415d0d651190c288566e295d505defdad895dae223730d5a5175a38841693020669c7638f40b9bc1f9f39cf98bda7a5b54ae24218a800a2116b34665aa95d846d97ea988bfcb53dd9c055d588fa21ba78996776ea6c40bc428b53c62b5f3ccf200f647a5aae8067f0ea1976391fcc72af1945100e2a6dcb88""
+                },
+                {
+                        7169,
+                        ""a003fc7a51754a9b3c7fae0367ab3d782dccf28855a03d435f8cfe74605e781798a8b20534be1ca9eb2ae2df3fae2ea60e48c6fb0b850b1385b5de0fe460dbe9d9f9b0d8db4435da75c601156df9d047f4ede008732eb17adc05d96180f8a73548522840779e6062d643b79478a6e8dbce68927f36ebf676ffa7d72d5f68f050b119c8"",
+                        ""ed9b1a922c046fdb3d423ae34e143b05ca1bf28b710432857bf738bcedbfa5113c9e28d72fcbfc020814ce3f5d4fc867f01c8f5b6caf305b3ea8a8ba2da3ab69fabcb438f19ff11f5378ad4484d75c478de425fb8e6ee809b54eec9bdb184315dc856617c09f5340451bf42fd3270a7b0b6566169f242e533777604c118a6358250f54"",
+                        ""554b0a5efea9ef183f2f9b931b7497995d9eb26f5c5c6dad2b97d62fc5ac31d99b20652c016d88ba2a611bbd761668d5eda3e568e940faae24b0d9991c3bd25a65f770b89fdcadabcb3d1a9c1cb63e69721cacf1ae69fefdcef1e3ef41bc5312ccc17222199e47a26552c6adc460cf47a72319cb5039369d0060eaea59d6c65130f1dd""
+                },
+                {
+                        8192,
+                        ""aae792484c8efe4f19e2ca7d371d8c467ffb10748d8a5a1ae579948f718a2a635fe51a27db045a567c1ad51be5aa34c01c6651c4d9b5b5ac5d0fd58cf18dd61a47778566b797a8c67df7b1d60b97b19288d2d877bb2df417ace009dcb0241ca1257d62712b6a4043b4ff33f690d849da91ea3bf711ed583cb7b7a7da2839ba71309bbf"",
+                        ""dc9637c8845a770b4cbf76b8daec0eebf7dc2eac11498517f08d44c8fc00d58a4834464159dcbc12a0ba0c6d6eb41bac0ed6585cabfe0aca36a375e6c5480c22afdc40785c170f5a6b8a1107dbee282318d00d915ac9ed1143ad40765ec120042ee121cd2baa36250c618adaf9e27260fda2f94dea8fb6f08c04f8f10c78292aa46102"",
+                        ""ad01d7ae4ad059b0d33baa3c01319dcf8088094d0359e5fd45d6aeaa8b2d0c3d4c9e58958553513b67f84f8eac653aeeb02ae1d5672dcecf91cd9985a0e67f4501910ecba25555395427ccc7241d70dc21c190e2aadee875e5aae6bf1912837e53411dabf7a56cbf8e4fb780432b0d7fe6cec45024a0788cf5874616407757e9e6bef7""
+                },
+                {
+                        8193,
+                        ""bab6c09cb8ce8cf459261398d2e7aef35700bf488116ceb94a36d0f5f1b7bc3bb2282aa69be089359ea1154b9a9286c4a56af4de975a9aa4a5c497654914d279bea60bb6d2cf7225a2fa0ff5ef56bbe4b149f3ed15860f78b4e2ad04e158e375c1e0c0b551cd7dfc82f1b155c11b6b3ed51ec9edb30d133653bb5709d1dbd55f4e1ff6"",
+                        ""954a2a75420c8d6547e3ba5b98d963e6fa6491addc8c023189cc519821b4a1f5f03228648fd983aef045c2fa8290934b0866b615f585149587dda2299039965328835a2b18f1d63b7e300fc76ff260b571839fe44876a4eae66cbac8c67694411ed7e09df51068a22c6e67d6d3dd2cca8ff12e3275384006c80f4db68023f24eebba57"",
+                        ""af1e0346e389b17c23200270a64aa4e1ead98c61695d917de7d5b00491c9b0f12f20a01d6d622edf3de026a4db4e4526225debb93c1237934d71c7340bb5916158cbdafe9ac3225476b6ab57a12357db3abbad7a26c6e66290e44034fb08a20a8d0ec264f309994d2810c49cfba6989d7abb095897459f5425adb48aba07c5fb3c83c0""
+                },
+                {
+                        16384,
+                        ""f875d6646de28985646f34ee13be9a576fd515f76b5b0a26bb324735041ddde49d764c270176e53e97bdffa58d549073f2c660be0e81293767ed4e4929f9ad34bbb39a529334c57c4a381ffd2a6d4bfdbf1482651b172aa883cc13408fa67758a3e47503f93f87720a3177325f7823251b85275f64636a8f1d599c2e49722f42e93893"",
+                        ""9e9fc4eb7cf081ea7c47d1807790ed211bfec56aa25bb7037784c13c4b707b0df9e601b101e4cf63a404dfe50f2e1865bb12edc8fca166579ce0c70dba5a5c0fc960ad6f3772183416a00bd29d4c6e651ea7620bb100c9449858bf14e1ddc9ecd35725581ca5b9160de04060045993d972571c3e8f71e9d0496bfa744656861b169d65"",
+                        ""160e18b5878cd0df1c3af85eb25a0db5344d43a6fbd7a8ef4ed98d0714c3f7e160dc0b1f09caa35f2f417b9ef309dfe5ebd67f4c9507995a531374d099cf8ae317542e885ec6f589378864d3ea98716b3bbb65ef4ab5e0ab5bb298a501f19a41ec19af84a5e6b428ecd813b1a47ed91c9657c3fba11c406bc316768b58f6802c9e9b57""
+                },
+                {
+                        31744,
+                        ""62b6960e1a44bcc1eb1a611a8d6235b6b4b78f32e7abc4fb4c6cdcce94895c47860cc51f2b0c28a7b77304bd55fe73af663c02d3f52ea053ba43431ca5bab7bfea2f5e9d7121770d88f70ae9649ea713087d1914f7f312147e247f87eb2d4ffef0ac978bf7b6579d57d533355aa20b8b77b13fd09748728a5cc327a8ec470f4013226f"",
+                        ""efa53b389ab67c593dba624d898d0f7353ab99e4ac9d42302ee64cbf9939a4193a7258db2d9cd32a7a3ecfce46144114b15c2fcb68a618a976bd74515d47be08b628be420b5e830fade7c080e351a076fbc38641ad80c736c8a18fe3c66ce12f95c61c2462a9770d60d0f77115bbcd3782b593016a4e728d4c06cee4505cb0c08a42ec"",
+                        ""39772aef80e0ebe60596361e45b061e8f417429d529171b6764468c22928e28e9759adeb797a3fbf771b1bcea30150a020e317982bf0d6e7d14dd9f064bc11025c25f31e81bd78a921db0174f03dd481d30e93fd8e90f8b2fee209f849f2d2a52f31719a490fb0ba7aea1e09814ee912eba111a9fde9d5c274185f7bae8ba85d300a2b""
+                },
+                {
+                        102400,
+                        ""bc3e3d41a1146b069abffad3c0d44860cf664390afce4d9661f7902e7943e085e01c59dab908c04c3342b816941a26d69c2605ebee5ec5291cc55e15b76146e6745f0601156c3596cb75065a9c57f35585a52e1ac70f69131c23d611ce11ee4ab1ec2c009012d236648e77be9295dd0426f29b764d65de58eb7d01dd42248204f45f8e"",
+                        ""1c35d1a5811083fd7119f5d5d1ba027b4d01c0c6c49fb6ff2cf75393ea5db4a7f9dbdd3e1d81dcbca3ba241bb18760f207710b751846faaeb9dff8262710999a59b2aa1aca298a032d94eacfadf1aa192418eb54808db23b56e34213266aa08499a16b354f018fc4967d05f8b9d2ad87a7278337be9693fc638a3bfdbe314574ee6fc4"",
+                        ""4652cff7a3f385a6103b5c260fc1593e13c778dbe608efb092fe7ee69df6e9c6d83a3e041bc3a48df2879f4a0a3ed40e7c961c73eff740f3117a0504c2dff4786d44fb17f1549eb0ba585e40ec29bf7732f0b7e286ff8acddc4cb1e23b87ff5d824a986458dcc6a04ac83969b80637562953df51ed1a7e90a7926924d2763778be8560""
+                }
+        };
+    }
+
+    private final Blake3 hasher = Blake3.initHash();
+    private final Blake3 keyedHasher = Blake3.initKeyedHash(KEY);
+    private final Blake3 kdfHasher = Blake3.initKeyDerivationFunction(CTX);
+
+    private final byte[] input;
+    private final byte[] hash;
+    private final byte[] keyedHash;
+    private final byte[] deriveKey;
+
+    public Blake3TestVectorsTest(int inputLength, String hash, String keyedHash, String deriveKey)","[{'comment': 'It would be nice to add a simple Javadoc and some input validation.\r\n', 'commenter': 'garydgregory'}]"
79,src/main/java/org/apache/commons/codec/digest/Blake3.java,"@@ -0,0 +1,455 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.codec.digest;
+
+import java.util.Arrays;
+import java.util.Objects;
+
+/**
+ * Implements the Blake3 algorithm providing a {@linkplain #initHash() hash function} with extensible output (XOF), a
+ * {@linkplain #initKeyedHash(byte[]) keyed hash function} (MAC, PRF), and a
+ * {@linkplain #initKeyDerivationFunction(byte[]) key derivation function} (KDF). Blake3 has a 128-bit security level
+ * and a default output length of 256 bits (32 bytes) which can extended up to 2<sup>64</sup> bytes.
+ * <p>
+ * Adapted from the ISC-licensed O(1) Cryptography library by Matt Sicker and ported from the reference public domain
+ * implementation by Jack O'Connor.
+ * </p>
+ *
+ * @see <a href=""https://github.com/BLAKE3-team/BLAKE3"">BLAKE3 hash function</a>
+ * @since 1.16
+ */
+public final class Blake3 {
+    // TODO: migrate to Integer.BYTES after upgrading to Java 8
+    private static final int INT_BYTES = Integer.SIZE / Byte.SIZE;
+
+    private static final int BLOCK_LEN = 64;
+    private static final int KEY_LEN = 32;
+    private static final int OUT_LEN = 32;
+    private static final int CHUNK_LEN = 1024;
+
+    private static final int[] IV =
+            { 0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19 };
+
+    // domain flags
+    private static final int CHUNK_START = 1;
+    private static final int CHUNK_END = 1 << 1;
+    private static final int PARENT = 1 << 2;
+    private static final int ROOT = 1 << 3;
+    private static final int KEYED_HASH = 1 << 4;
+    private static final int DERIVE_KEY_CONTEXT = 1 << 5;
+    private static final int DERIVE_KEY_MATERIAL = 1 << 6;
+
+    private final EngineState engineState;
+
+    private Blake3(final int[] key, final int flags) {
+        engineState = new EngineState(key, flags);
+    }
+
+    /**
+     * Resets this instance back to its initial state when it was first constructed.
+     */
+    public void reset() {
+        engineState.reset();
+    }
+
+    /**
+     * Absorbs the provided bytes into this instance's state.
+     *
+     * @param in source array to absorb data from
+     */
+    public void absorb(final byte[] in) {
+        Objects.requireNonNull(in);
+        absorb(in, 0, in.length);
+    }
+
+    /**
+     * Absorbs the provided bytes at an offset into this instance's state.
+     *
+     * @param in     source array to absorb data from
+     * @param offset where in the array to begin absorbing bytes
+     * @param length number of bytes to absorb in
+     */
+    public void absorb(final byte[] in, final int offset, final int length) {
+        Objects.requireNonNull(in);
+        engineState.inputData(in, offset, length);
+    }
+
+    /**
+     * Squeezes hash output data that depends on the sequence of absorbed bytes preceding this invocation and any previously
+     * squeezed bytes.
+     *
+     * @param out destination array to squeeze bytes into
+     */
+    public void squeeze(final byte[] out) {
+        squeeze(out, 0, out.length);
+    }
+
+    /**
+     * Squeezes an arbitrary number of bytes into the provided output array that depends on the sequence of previously
+     * absorbed and squeezed bytes.
+     *
+     * @param out    destination array to squeeze bytes into
+     * @param offset where in the array to begin writing bytes to
+     * @param length number of bytes to squeeze out
+     */
+    public void squeeze(final byte[] out, final int offset, final int length) {
+        Objects.requireNonNull(out);
+        engineState.outputHash(out, offset, length);
+    }
+
+    /**
+     * Squeezes and returns an arbitrary number of bytes dependent on the sequence of previously absorbed and squeezed bytes.
+     *
+     * @param nrBytes number of bytes to squeeze
+     * @return requested number of squeezed bytes
+     */
+    public byte[] squeeze(final int nrBytes) {
+        final byte[] hash = new byte[nrBytes];
+        squeeze(hash);
+        return hash;
+    }
+
+    /**
+     * Constructs a fresh Blake3 hash function. The instance returned functions as an arbitrary length message digest.
+     *
+     * @return fresh Blake3 instance in hashed mode
+     */
+    public static Blake3 initHash() {
+        return new Blake3(IV, 0);
+    }
+
+    /**
+     * Constructs a fresh Blake3 keyed hash function. The instance returned functions as a pseudorandom function (PRF) or as a
+     * message authentication code (MAC).
+     *
+     * @param key 32-byte secret key
+     * @return fresh Blake3 instance in keyed mode using the provided key
+     */
+    public static Blake3 initKeyedHash(final byte[] key) {
+        Objects.requireNonNull(key);
+        if (key.length != KEY_LEN) {
+            throw new IllegalArgumentException(""Blake3 keys must be 32 bytes"");
+        }
+        return new Blake3(unpackInts(key, 8), KEYED_HASH);
+    }
+
+    /**
+     * Constructs a fresh Blake3 key derivation function using the provided key derivation context byte string.
+     * The instance returned functions as a key-derivation function which can further absorb additional context data
+     * before squeezing derived key data.
+     *
+     * @param kdfContext a globally unique key-derivation context byte string to separate key derivation contexts from each other
+     * @return fresh Blake3 instance in key derivation mode
+     */
+    public static Blake3 initKeyDerivationFunction(final byte[] kdfContext) {
+        Objects.requireNonNull(kdfContext);
+        final EngineState kdf = new EngineState(IV, DERIVE_KEY_CONTEXT);
+        kdf.inputData(kdfContext, 0, kdfContext.length);
+        final byte[] key = new byte[KEY_LEN];
+        kdf.outputHash(key, 0, key.length);
+        return new Blake3(unpackInts(key, 8), DERIVE_KEY_MATERIAL);
+    }
+
+    /**
+     * Calculates the Blake3 hash of the provided data.
+     *
+     * @param data source array to absorb data from
+     * @return 32-byte hash squeezed from the provided data
+     */
+    public static byte[] hash(final byte[] data) {
+        final Blake3 blake3 = Blake3.initHash();
+        blake3.absorb(data);
+        return blake3.squeeze(OUT_LEN);
+    }
+
+    /**
+     * Calculates the Blake3 keyed hash (MAC) of the provided data.
+     *
+     * @param key  32-byte secret key
+     * @param data source array to absorb data from
+     * @return 32-byte mac squeezed from the provided data
+     */
+    public static byte[] keyedHash(final byte[] key, final byte[] data) {
+        final Blake3 blake3 = Blake3.initKeyedHash(key);
+        blake3.absorb(data);
+        return blake3.squeeze(OUT_LEN);
+    }
+
+    private static void packInt(final int value, final byte[] dst, final int off, final int len) {
+        for (int i = 0; i < len; i++) {
+            dst[off + i] = (byte) (value >>> i * Byte.SIZE);
+        }
+    }
+
+    private static int unpackInt(final byte[] buf, final int off) {
+        return buf[off] & 0xFF | (buf[off + 1] & 0xFF) << 8 | (buf[off + 2] & 0xFF) << 16 | (buf[off + 3] & 0xFF) << 24;
+    }
+
+    private static int[] unpackInts(final byte[] buf, final int nrInts) {
+        final int[] values = new int[nrInts];
+        for (int i = 0, off = 0; i < nrInts; i++, off += INT_BYTES) {
+            values[i] = unpackInt(buf, off);
+        }
+        return values;
+    }
+
+    // The mixing function, G, which mixes either a column or a diagonal.
+    private static void g(
+            final int[] state, final int a, final int b, final int c, final int d, final int mx, final int my) {
+        state[a] += state[b] + mx;
+        state[d] = Integer.rotateRight(state[d] ^ state[a], 16);
+        state[c] += state[d];
+        state[b] = Integer.rotateRight(state[b] ^ state[c], 12);
+        state[a] += state[b] + my;
+        state[d] = Integer.rotateRight(state[d] ^ state[a], 8);
+        state[c] += state[d];
+        state[b] = Integer.rotateRight(state[b] ^ state[c], 7);
+    }
+
+    private static void round(final int[] state, final int[] msg, final byte[] schedule) {
+        // Mix the columns.
+        g(state, 0, 4, 8, 12, msg[schedule[0]], msg[schedule[1]]);
+        g(state, 1, 5, 9, 13, msg[schedule[2]], msg[schedule[3]]);
+        g(state, 2, 6, 10, 14, msg[schedule[4]], msg[schedule[5]]);
+        g(state, 3, 7, 11, 15, msg[schedule[6]], msg[schedule[7]]);
+
+        // Mix the diagonals.
+        g(state, 0, 5, 10, 15, msg[schedule[8]], msg[schedule[9]]);
+        g(state, 1, 6, 11, 12, msg[schedule[10]], msg[schedule[11]]);
+        g(state, 2, 7, 8, 13, msg[schedule[12]], msg[schedule[13]]);
+        g(state, 3, 4, 9, 14, msg[schedule[14]], msg[schedule[15]]);
+    }
+
+    // pre-permuted for all 7 rounds; the second row (2,6,3,...) indicates the base permutation
+    private static final byte[][] MSG_SCHEDULE = {
+            { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
+            { 2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8 },
+            { 3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1 },
+            { 10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6 },
+            { 12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4 },
+            { 9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7 },
+            { 11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13 }
+    };
+
+    private static int[] compress(
+            final int[] chainingValue, final int[] blockWords, final int blockLength, final long counter,
+            final int flags) {
+        final int[] state = Arrays.copyOf(chainingValue, 16);
+        System.arraycopy(IV, 0, state, 8, 4);
+        state[12] = (int) counter;
+        state[13] = (int) (counter >> Integer.SIZE);
+        state[14] = blockLength;
+        state[15] = flags;
+        for (int i = 0; i < 7; i++) {
+            final byte[] schedule = MSG_SCHEDULE[i];
+            round(state, blockWords, schedule);
+        }
+        for (int i = 0; i < 8; i++) {
+            state[i] ^= state[i + 8];
+            state[i + 8] ^= chainingValue[i];
+        }
+        return state;
+    }
+
+    private static Output parentOutput(
+            final int[] leftChildCV, final int[] rightChildCV, final int[] key, final int flags) {
+        final int[] blockWords = Arrays.copyOf(leftChildCV, 16);
+        System.arraycopy(rightChildCV, 0, blockWords, 8, 8);
+        return new Output(key.clone(), blockWords, 0, BLOCK_LEN, flags | PARENT);
+    }
+
+    private static int[] parentChainingValue(
+            final int[] leftChildCV, final int[] rightChildCV, final int[] key, final int flags) {
+        return parentOutput(leftChildCV, rightChildCV, key, flags).chainingValue();
+    }
+
+    /**
+     * Represents the state just prior to either producing an eight word chaining value or any number of output bytes when the
+     * ROOT flag is set.
+     */
+    private static class Output {
+        private final int[] inputChainingValue;
+        private final int[] blockWords;
+        private final long counter;
+        private final int blockLength;
+        private final int flags;
+
+        Output(
+                final int[] inputChainingValue, final int[] blockWords, final long counter, final int blockLength,
+                final int flags) {
+            this.inputChainingValue = inputChainingValue;
+            this.blockWords = blockWords;
+            this.counter = counter;
+            this.blockLength = blockLength;
+            this.flags = flags;
+        }
+
+        int[] chainingValue() {
+            return Arrays.copyOf(compress(inputChainingValue, blockWords, blockLength, counter, flags), 8);
+        }
+
+        void rootOutputBytes(final byte[] out, int offset, int length) {
+            int outputBlockCounter = 0;
+            while (length > 0) {
+                int chunkLength = Math.min(OUT_LEN * 2, length);
+                length -= chunkLength;
+                final int[] words =
+                        compress(inputChainingValue, blockWords, blockLength, outputBlockCounter++, flags | ROOT);
+                int wordCounter = 0;
+                while (chunkLength > 0) {
+                    final int wordLength = Math.min(INT_BYTES, chunkLength);
+                    packInt(words[wordCounter++], out, offset, wordLength);
+                    offset += wordLength;
+                    chunkLength -= wordLength;
+                }
+            }
+        }
+    }
+
+    private static class ChunkState {
+        private int[] chainingValue;
+        private final long chunkCounter;
+        private final int flags;
+
+        private final byte[] block = new byte[BLOCK_LEN];
+        private int blockLength;
+        private int blocksCompressed;
+
+        ChunkState(final int[] key, final long chunkCounter, final int flags) {
+            chainingValue = key;
+            this.chunkCounter = chunkCounter;
+            this.flags = flags;
+        }
+
+        int length() {
+            return BLOCK_LEN * blocksCompressed + blockLength;
+        }
+
+        int startFlag() {
+            return blocksCompressed == 0 ? CHUNK_START : 0;
+        }
+
+        void update(final byte[] input, int offset, int length) {
+            while (length > 0) {
+                if (blockLength == BLOCK_LEN) {
+                    // If the block buffer is full, compress it and clear it. More
+                    // input is coming, so this compression is not CHUNK_END.
+                    final int[] blockWords = unpackInts(block, 16);
+                    chainingValue = Arrays.copyOf(
+                            compress(chainingValue, blockWords, BLOCK_LEN, chunkCounter, flags | startFlag()), 8);
+                    blocksCompressed++;
+                    blockLength = 0;
+                    Arrays.fill(block, (byte) 0);
+                }
+
+                final int want = BLOCK_LEN - blockLength;
+                final int take = Math.min(want, length);
+                System.arraycopy(input, offset, block, blockLength, take);
+                blockLength += take;
+                offset += take;
+                length -= take;
+            }
+        }
+
+        Output output() {
+            final int[] blockWords = unpackInts(block, 16);
+            final int outputFlags = flags | startFlag() | CHUNK_END;
+            return new Output(chainingValue, blockWords, chunkCounter, blockLength, outputFlags);
+        }
+    }
+
+    private static class EngineState {
+        private final int[] key;
+        private final int flags;
+        // Space for 54 subtree chaining values: 2^54 * CHUNK_LEN = 2^64
+        private final int[][] cvStack = new int[54][];","[{'comment': ""`54` looks magical, add a Javadoc'd constant IMO."", 'commenter': 'garydgregory'}, {'comment': 'Yes, some better javadocs about the space limitations. As hinted by the vague comment left here (and explained in more detail in the linked PDF for blake3), a stack of 54 int arrays (each being 8 ints) is the maximum amount of hashing state that can accumulate when hashing the largest amount of data allowed by the algorithm. When used in applications with a smaller processing limit (e.g., some embedded device only processing kB-order messages), the stack space can be reduced. This could, of course, use something like ArrayDeque here, though I opted to avoid generating garbage or other wrappers where possible while porting the rust code.', 'commenter': 'jvz'}]"
79,src/main/java/org/apache/commons/codec/digest/Blake3.java,"@@ -0,0 +1,455 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.codec.digest;
+
+import java.util.Arrays;
+import java.util.Objects;
+
+/**
+ * Implements the Blake3 algorithm providing a {@linkplain #initHash() hash function} with extensible output (XOF), a
+ * {@linkplain #initKeyedHash(byte[]) keyed hash function} (MAC, PRF), and a
+ * {@linkplain #initKeyDerivationFunction(byte[]) key derivation function} (KDF). Blake3 has a 128-bit security level
+ * and a default output length of 256 bits (32 bytes) which can extended up to 2<sup>64</sup> bytes.
+ * <p>
+ * Adapted from the ISC-licensed O(1) Cryptography library by Matt Sicker and ported from the reference public domain
+ * implementation by Jack O'Connor.
+ * </p>
+ *
+ * @see <a href=""https://github.com/BLAKE3-team/BLAKE3"">BLAKE3 hash function</a>
+ * @since 1.16
+ */
+public final class Blake3 {
+    // TODO: migrate to Integer.BYTES after upgrading to Java 8
+    private static final int INT_BYTES = Integer.SIZE / Byte.SIZE;
+
+    private static final int BLOCK_LEN = 64;
+    private static final int KEY_LEN = 32;
+    private static final int OUT_LEN = 32;
+    private static final int CHUNK_LEN = 1024;
+
+    private static final int[] IV =
+            { 0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19 };
+
+    // domain flags
+    private static final int CHUNK_START = 1;
+    private static final int CHUNK_END = 1 << 1;
+    private static final int PARENT = 1 << 2;
+    private static final int ROOT = 1 << 3;
+    private static final int KEYED_HASH = 1 << 4;
+    private static final int DERIVE_KEY_CONTEXT = 1 << 5;
+    private static final int DERIVE_KEY_MATERIAL = 1 << 6;
+
+    private final EngineState engineState;
+
+    private Blake3(final int[] key, final int flags) {
+        engineState = new EngineState(key, flags);
+    }
+
+    /**
+     * Resets this instance back to its initial state when it was first constructed.
+     */
+    public void reset() {
+        engineState.reset();
+    }
+
+    /**
+     * Absorbs the provided bytes into this instance's state.
+     *
+     * @param in source array to absorb data from
+     */
+    public void absorb(final byte[] in) {
+        Objects.requireNonNull(in);
+        absorb(in, 0, in.length);
+    }
+
+    /**
+     * Absorbs the provided bytes at an offset into this instance's state.
+     *
+     * @param in     source array to absorb data from
+     * @param offset where in the array to begin absorbing bytes
+     * @param length number of bytes to absorb in
+     */
+    public void absorb(final byte[] in, final int offset, final int length) {
+        Objects.requireNonNull(in);
+        engineState.inputData(in, offset, length);
+    }
+
+    /**
+     * Squeezes hash output data that depends on the sequence of absorbed bytes preceding this invocation and any previously
+     * squeezed bytes.
+     *
+     * @param out destination array to squeeze bytes into
+     */
+    public void squeeze(final byte[] out) {
+        squeeze(out, 0, out.length);
+    }
+
+    /**
+     * Squeezes an arbitrary number of bytes into the provided output array that depends on the sequence of previously
+     * absorbed and squeezed bytes.
+     *
+     * @param out    destination array to squeeze bytes into
+     * @param offset where in the array to begin writing bytes to
+     * @param length number of bytes to squeeze out
+     */
+    public void squeeze(final byte[] out, final int offset, final int length) {
+        Objects.requireNonNull(out);
+        engineState.outputHash(out, offset, length);
+    }
+
+    /**
+     * Squeezes and returns an arbitrary number of bytes dependent on the sequence of previously absorbed and squeezed bytes.
+     *
+     * @param nrBytes number of bytes to squeeze
+     * @return requested number of squeezed bytes
+     */
+    public byte[] squeeze(final int nrBytes) {
+        final byte[] hash = new byte[nrBytes];
+        squeeze(hash);
+        return hash;
+    }
+
+    /**
+     * Constructs a fresh Blake3 hash function. The instance returned functions as an arbitrary length message digest.
+     *
+     * @return fresh Blake3 instance in hashed mode
+     */
+    public static Blake3 initHash() {
+        return new Blake3(IV, 0);
+    }
+
+    /**
+     * Constructs a fresh Blake3 keyed hash function. The instance returned functions as a pseudorandom function (PRF) or as a
+     * message authentication code (MAC).
+     *
+     * @param key 32-byte secret key
+     * @return fresh Blake3 instance in keyed mode using the provided key
+     */
+    public static Blake3 initKeyedHash(final byte[] key) {
+        Objects.requireNonNull(key);
+        if (key.length != KEY_LEN) {
+            throw new IllegalArgumentException(""Blake3 keys must be 32 bytes"");
+        }
+        return new Blake3(unpackInts(key, 8), KEYED_HASH);
+    }
+
+    /**
+     * Constructs a fresh Blake3 key derivation function using the provided key derivation context byte string.
+     * The instance returned functions as a key-derivation function which can further absorb additional context data
+     * before squeezing derived key data.
+     *
+     * @param kdfContext a globally unique key-derivation context byte string to separate key derivation contexts from each other
+     * @return fresh Blake3 instance in key derivation mode
+     */
+    public static Blake3 initKeyDerivationFunction(final byte[] kdfContext) {
+        Objects.requireNonNull(kdfContext);
+        final EngineState kdf = new EngineState(IV, DERIVE_KEY_CONTEXT);
+        kdf.inputData(kdfContext, 0, kdfContext.length);
+        final byte[] key = new byte[KEY_LEN];
+        kdf.outputHash(key, 0, key.length);
+        return new Blake3(unpackInts(key, 8), DERIVE_KEY_MATERIAL);
+    }
+
+    /**
+     * Calculates the Blake3 hash of the provided data.
+     *
+     * @param data source array to absorb data from
+     * @return 32-byte hash squeezed from the provided data
+     */
+    public static byte[] hash(final byte[] data) {
+        final Blake3 blake3 = Blake3.initHash();
+        blake3.absorb(data);
+        return blake3.squeeze(OUT_LEN);
+    }
+
+    /**
+     * Calculates the Blake3 keyed hash (MAC) of the provided data.
+     *
+     * @param key  32-byte secret key
+     * @param data source array to absorb data from
+     * @return 32-byte mac squeezed from the provided data
+     */
+    public static byte[] keyedHash(final byte[] key, final byte[] data) {
+        final Blake3 blake3 = Blake3.initKeyedHash(key);
+        blake3.absorb(data);
+        return blake3.squeeze(OUT_LEN);
+    }
+
+    private static void packInt(final int value, final byte[] dst, final int off, final int len) {
+        for (int i = 0; i < len; i++) {
+            dst[off + i] = (byte) (value >>> i * Byte.SIZE);
+        }
+    }
+
+    private static int unpackInt(final byte[] buf, final int off) {
+        return buf[off] & 0xFF | (buf[off + 1] & 0xFF) << 8 | (buf[off + 2] & 0xFF) << 16 | (buf[off + 3] & 0xFF) << 24;
+    }
+
+    private static int[] unpackInts(final byte[] buf, final int nrInts) {
+        final int[] values = new int[nrInts];
+        for (int i = 0, off = 0; i < nrInts; i++, off += INT_BYTES) {
+            values[i] = unpackInt(buf, off);
+        }
+        return values;
+    }
+
+    // The mixing function, G, which mixes either a column or a diagonal.
+    private static void g(
+            final int[] state, final int a, final int b, final int c, final int d, final int mx, final int my) {
+        state[a] += state[b] + mx;
+        state[d] = Integer.rotateRight(state[d] ^ state[a], 16);
+        state[c] += state[d];
+        state[b] = Integer.rotateRight(state[b] ^ state[c], 12);
+        state[a] += state[b] + my;
+        state[d] = Integer.rotateRight(state[d] ^ state[a], 8);
+        state[c] += state[d];
+        state[b] = Integer.rotateRight(state[b] ^ state[c], 7);
+    }
+
+    private static void round(final int[] state, final int[] msg, final byte[] schedule) {
+        // Mix the columns.
+        g(state, 0, 4, 8, 12, msg[schedule[0]], msg[schedule[1]]);
+        g(state, 1, 5, 9, 13, msg[schedule[2]], msg[schedule[3]]);
+        g(state, 2, 6, 10, 14, msg[schedule[4]], msg[schedule[5]]);
+        g(state, 3, 7, 11, 15, msg[schedule[6]], msg[schedule[7]]);
+
+        // Mix the diagonals.
+        g(state, 0, 5, 10, 15, msg[schedule[8]], msg[schedule[9]]);
+        g(state, 1, 6, 11, 12, msg[schedule[10]], msg[schedule[11]]);
+        g(state, 2, 7, 8, 13, msg[schedule[12]], msg[schedule[13]]);
+        g(state, 3, 4, 9, 14, msg[schedule[14]], msg[schedule[15]]);
+    }
+
+    // pre-permuted for all 7 rounds; the second row (2,6,3,...) indicates the base permutation
+    private static final byte[][] MSG_SCHEDULE = {
+            { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
+            { 2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8 },
+            { 3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1 },
+            { 10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6 },
+            { 12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4 },
+            { 9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7 },
+            { 11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13 }
+    };
+
+    private static int[] compress(
+            final int[] chainingValue, final int[] blockWords, final int blockLength, final long counter,
+            final int flags) {
+        final int[] state = Arrays.copyOf(chainingValue, 16);
+        System.arraycopy(IV, 0, state, 8, 4);
+        state[12] = (int) counter;
+        state[13] = (int) (counter >> Integer.SIZE);
+        state[14] = blockLength;
+        state[15] = flags;
+        for (int i = 0; i < 7; i++) {
+            final byte[] schedule = MSG_SCHEDULE[i];
+            round(state, blockWords, schedule);
+        }
+        for (int i = 0; i < 8; i++) {
+            state[i] ^= state[i + 8];
+            state[i + 8] ^= chainingValue[i];
+        }
+        return state;
+    }
+
+    private static Output parentOutput(
+            final int[] leftChildCV, final int[] rightChildCV, final int[] key, final int flags) {
+        final int[] blockWords = Arrays.copyOf(leftChildCV, 16);
+        System.arraycopy(rightChildCV, 0, blockWords, 8, 8);
+        return new Output(key.clone(), blockWords, 0, BLOCK_LEN, flags | PARENT);
+    }
+
+    private static int[] parentChainingValue(
+            final int[] leftChildCV, final int[] rightChildCV, final int[] key, final int flags) {
+        return parentOutput(leftChildCV, rightChildCV, key, flags).chainingValue();
+    }
+
+    /**
+     * Represents the state just prior to either producing an eight word chaining value or any number of output bytes when the
+     * ROOT flag is set.
+     */
+    private static class Output {
+        private final int[] inputChainingValue;
+        private final int[] blockWords;
+        private final long counter;
+        private final int blockLength;
+        private final int flags;
+
+        Output(
+                final int[] inputChainingValue, final int[] blockWords, final long counter, final int blockLength,
+                final int flags) {
+            this.inputChainingValue = inputChainingValue;
+            this.blockWords = blockWords;
+            this.counter = counter;
+            this.blockLength = blockLength;
+            this.flags = flags;
+        }
+
+        int[] chainingValue() {
+            return Arrays.copyOf(compress(inputChainingValue, blockWords, blockLength, counter, flags), 8);
+        }
+
+        void rootOutputBytes(final byte[] out, int offset, int length) {
+            int outputBlockCounter = 0;
+            while (length > 0) {
+                int chunkLength = Math.min(OUT_LEN * 2, length);
+                length -= chunkLength;
+                final int[] words =
+                        compress(inputChainingValue, blockWords, blockLength, outputBlockCounter++, flags | ROOT);
+                int wordCounter = 0;
+                while (chunkLength > 0) {
+                    final int wordLength = Math.min(INT_BYTES, chunkLength);
+                    packInt(words[wordCounter++], out, offset, wordLength);
+                    offset += wordLength;
+                    chunkLength -= wordLength;
+                }
+            }
+        }
+    }
+
+    private static class ChunkState {
+        private int[] chainingValue;
+        private final long chunkCounter;
+        private final int flags;
+
+        private final byte[] block = new byte[BLOCK_LEN];
+        private int blockLength;
+        private int blocksCompressed;
+
+        ChunkState(final int[] key, final long chunkCounter, final int flags) {
+            chainingValue = key;
+            this.chunkCounter = chunkCounter;
+            this.flags = flags;
+        }
+
+        int length() {
+            return BLOCK_LEN * blocksCompressed + blockLength;
+        }
+
+        int startFlag() {
+            return blocksCompressed == 0 ? CHUNK_START : 0;
+        }
+
+        void update(final byte[] input, int offset, int length) {
+            while (length > 0) {
+                if (blockLength == BLOCK_LEN) {
+                    // If the block buffer is full, compress it and clear it. More
+                    // input is coming, so this compression is not CHUNK_END.
+                    final int[] blockWords = unpackInts(block, 16);
+                    chainingValue = Arrays.copyOf(
+                            compress(chainingValue, blockWords, BLOCK_LEN, chunkCounter, flags | startFlag()), 8);
+                    blocksCompressed++;
+                    blockLength = 0;
+                    Arrays.fill(block, (byte) 0);
+                }
+
+                final int want = BLOCK_LEN - blockLength;
+                final int take = Math.min(want, length);
+                System.arraycopy(input, offset, block, blockLength, take);
+                blockLength += take;
+                offset += take;
+                length -= take;
+            }
+        }
+
+        Output output() {
+            final int[] blockWords = unpackInts(block, 16);","[{'comment': ""`16` looks magical, add a Javadoc'd constant IMO. Does it have to match the `16` above in `update(final byte[] input, int offset, int length)`? Using a constant would avoid the question ;-)"", 'commenter': 'garydgregory'}]"
79,src/main/java/org/apache/commons/codec/digest/Blake3.java,"@@ -0,0 +1,455 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.codec.digest;
+
+import java.util.Arrays;
+import java.util.Objects;
+
+/**
+ * Implements the Blake3 algorithm providing a {@linkplain #initHash() hash function} with extensible output (XOF), a
+ * {@linkplain #initKeyedHash(byte[]) keyed hash function} (MAC, PRF), and a
+ * {@linkplain #initKeyDerivationFunction(byte[]) key derivation function} (KDF). Blake3 has a 128-bit security level
+ * and a default output length of 256 bits (32 bytes) which can extended up to 2<sup>64</sup> bytes.
+ * <p>
+ * Adapted from the ISC-licensed O(1) Cryptography library by Matt Sicker and ported from the reference public domain
+ * implementation by Jack O'Connor.
+ * </p>
+ *
+ * @see <a href=""https://github.com/BLAKE3-team/BLAKE3"">BLAKE3 hash function</a>
+ * @since 1.16
+ */
+public final class Blake3 {
+    // TODO: migrate to Integer.BYTES after upgrading to Java 8
+    private static final int INT_BYTES = Integer.SIZE / Byte.SIZE;
+
+    private static final int BLOCK_LEN = 64;
+    private static final int KEY_LEN = 32;
+    private static final int OUT_LEN = 32;
+    private static final int CHUNK_LEN = 1024;
+
+    private static final int[] IV =","[{'comment': 'Needs Javadoc, too magical ;-)', 'commenter': 'garydgregory'}]"
79,src/main/java/org/apache/commons/codec/digest/Blake3.java,"@@ -0,0 +1,455 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.codec.digest;
+
+import java.util.Arrays;
+import java.util.Objects;
+
+/**
+ * Implements the Blake3 algorithm providing a {@linkplain #initHash() hash function} with extensible output (XOF), a
+ * {@linkplain #initKeyedHash(byte[]) keyed hash function} (MAC, PRF), and a
+ * {@linkplain #initKeyDerivationFunction(byte[]) key derivation function} (KDF). Blake3 has a 128-bit security level
+ * and a default output length of 256 bits (32 bytes) which can extended up to 2<sup>64</sup> bytes.
+ * <p>
+ * Adapted from the ISC-licensed O(1) Cryptography library by Matt Sicker and ported from the reference public domain
+ * implementation by Jack O'Connor.
+ * </p>
+ *
+ * @see <a href=""https://github.com/BLAKE3-team/BLAKE3"">BLAKE3 hash function</a>
+ * @since 1.16
+ */
+public final class Blake3 {","[{'comment': 'A hash ""Hello World!"" code example in the Javadoc would be nice.\r\n', 'commenter': 'garydgregory'}]"
79,src/main/java/org/apache/commons/codec/digest/Blake3.java,"@@ -0,0 +1,505 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.codec.digest;
+
+import java.util.Arrays;
+import java.util.Objects;
+
+/**
+ * Implements the Blake3 algorithm providing a {@linkplain #initHash() hash function} with extensible output (XOF), a
+ * {@linkplain #initKeyedHash(byte[]) keyed hash function} (MAC, PRF), and a
+ * {@linkplain #initKeyDerivationFunction(byte[]) key derivation function} (KDF). Blake3 has a 128-bit security level
+ * and a default output length of 256 bits (32 bytes) which can extended up to 2<sup>64</sup> bytes.
+ * <h2>Hashing</h2>
+ * <p>Hash mode calculates the same output hash given the same input bytes and can be used as both a message digest and
+ * and extensible output function.</p>
+ * <pre>{@code
+ *      Blake3 hasher = Blake3.initHash();
+ *      hasher.update(""Hello, world!"".getBytes(StandardCharsets.UTF_8));
+ *      byte[] hash = new byte[32];
+ *      hasher.doFinalize(hash);
+ * }</pre>
+ * <h2>Keyed Hashing</h2>
+ * <p>Keyed hashes take a 32-byte secret key and calculates a message authentication code on some input bytes. These
+ * also work as pseduo-random functions (PRFs) with extensible output similar to the extensible hash output. Note that
+ * Blake3 keyed hashes have the same performance as plain hashes; the key is used in initialization in place of a
+ * standard initialization vector used for plain hashing.</p>
+ * <pre>{@code
+ *      SecureRandom random = new SecureRandom(); // or SecureRandom.getInstanceStrong() in Java 8+
+ *      byte[] key = new byte[32];
+ *      random.nextBytes(key);
+ *      Blake3 hasher = Blake3.initKeyedHash(key);
+ *      hasher.update(""Hello, Alice!"".getBytes(StandardCharsets.UTF_8));
+ *      byte[] mac = new byte[32];
+ *      hasher.doFinalize(mac);
+ * }</pre>
+ * <h2>Key Derivation</h2>
+ * <p>A specific hash mode for deriving session keys and other derived keys in a unique key derivation context
+ * identified by some sequence of bytes. These context strings should be unique but do not need to be kept secret.
+ * Additional input data is hashed for key material which can be finalized to derive subkeys.</p>
+ * <pre>{@code
+ *      String context = ""org.apache.commons.codec.digest.Blake3Example"";
+ *      byte[] sharedSecret = ...;
+ *      byte[] senderId = ...;
+ *      byte[] recipientId = ...;
+ *      Blake3 kdf = Blake3.initKeyDerivationFunction(context.getBytes(StandardCharsets.UTF_8));
+ *      kdf.update(sharedSecret);
+ *      kdf.update(senderId);
+ *      kdf.update(recipientId);
+ *      byte[] txKey = new byte[32];
+ *      byte[] rxKey = new byte[32];
+ *      kdf.doFinalize(txKey);
+ *      kdf.doFinalize(rxKey);
+ * }</pre>
+ * <p>
+ * Adapted from the ISC-licensed O(1) Cryptography library by Matt Sicker and ported from the reference public domain
+ * implementation by Jack O'Connor.
+ * </p>
+ *
+ * @see <a href=""https://github.com/BLAKE3-team/BLAKE3"">BLAKE3 hash function</a>
+ * @since 1.16
+ */
+public final class Blake3 {
+    // TODO: migrate to Integer.BYTES after upgrading to Java 8
+    private static final int INT_BYTES = Integer.SIZE / Byte.SIZE;
+
+    private static final int BLOCK_LEN = 64;
+    private static final int BLOCK_INTS = BLOCK_LEN / INT_BYTES;
+    private static final int KEY_LEN = 32;
+    private static final int KEY_INTS = KEY_LEN / INT_BYTES;
+    private static final int OUT_LEN = 32;
+    private static final int CHUNK_LEN = 1024;
+    private static final int CHAINING_VALUE_INTS = 8;
+
+    // standard hash key used for plain hashes; same initialization vector as Blake2s
+    private static final int[] IV =
+            { 0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19 };
+
+    // domain flags
+    private static final int CHUNK_START = 1;
+    private static final int CHUNK_END = 1 << 1;
+    private static final int PARENT = 1 << 2;
+    private static final int ROOT = 1 << 3;
+    private static final int KEYED_HASH = 1 << 4;
+    private static final int DERIVE_KEY_CONTEXT = 1 << 5;
+    private static final int DERIVE_KEY_MATERIAL = 1 << 6;
+
+    private final EngineState engineState;
+
+    private Blake3(final int[] key, final int flags) {
+        engineState = new EngineState(key, flags);
+    }
+
+    /**
+     * Resets this instance back to its initial state when it was first constructed.
+     */
+    public void reset() {
+        engineState.reset();
+    }
+
+    /**
+     * Updates this hash state using the provided bytes.
+     *
+     * @param in source array to update data from
+     */
+    public void update(final byte[] in) {
+        Objects.requireNonNull(in);
+        update(in, 0, in.length);
+    }
+
+    /**
+     * Updates this hash state using the provided bytes at an offset.
+     *
+     * @param in     source array to update data from
+     * @param offset where in the array to begin reading bytes
+     * @param length number of bytes to update
+     */
+    public void update(final byte[] in, final int offset, final int length) {
+        Objects.requireNonNull(in);
+        engineState.inputData(in, offset, length);
+    }
+
+    /**
+     * Finalizes hash output data that depends on the sequence of updated bytes preceding this invocation and any
+     * previously finalized bytes. Note that this can finalize up to 2<sup>64</sup> bytes per instance.
+     *
+     * @param out destination array to finalize bytes into
+     */
+    public void doFinalize(final byte[] out) {
+        doFinalize(out, 0, out.length);
+    }
+
+    /**
+     * Finalizes an arbitrary number of bytes into the provided output array that depends on the sequence of previously
+     * updated and finalized bytes. Note that this can finalize up to 2<sup>64</sup> bytes per instance.
+     *
+     * @param out    destination array to finalize bytes into
+     * @param offset where in the array to begin writing bytes to
+     * @param length number of bytes to finalize
+     */
+    public void doFinalize(final byte[] out, final int offset, final int length) {
+        Objects.requireNonNull(out);
+        engineState.outputHash(out, offset, length);
+    }
+
+    /**
+     * Squeezes and returns an arbitrary number of bytes dependent on the sequence of previously absorbed and squeezed bytes.
+     *
+     * @param nrBytes number of bytes to finalize
+     * @return requested number of finalized bytes
+     */
+    public byte[] doFinalize(final int nrBytes) {
+        final byte[] hash = new byte[nrBytes];
+        doFinalize(hash);
+        return hash;
+    }
+
+    /**
+     * Constructs a fresh Blake3 hash function. The instance returned functions as an arbitrary length message digest.
+     *
+     * @return fresh Blake3 instance in hashed mode
+     */
+    public static Blake3 initHash() {
+        return new Blake3(IV, 0);
+    }
+
+    /**
+     * Constructs a fresh Blake3 keyed hash function. The instance returned functions as a pseudorandom function (PRF) or as a
+     * message authentication code (MAC).
+     *
+     * @param key 32-byte secret key
+     * @return fresh Blake3 instance in keyed mode using the provided key
+     */
+    public static Blake3 initKeyedHash(final byte[] key) {
+        Objects.requireNonNull(key);
+        if (key.length != KEY_LEN) {
+            throw new IllegalArgumentException(""Blake3 keys must be 32 bytes"");
+        }
+        return new Blake3(unpackInts(key, KEY_INTS), KEYED_HASH);
+    }
+
+    /**
+     * Constructs a fresh Blake3 key derivation function using the provided key derivation context byte string.
+     * The instance returned functions as a key-derivation function which can further absorb additional context data
+     * before squeezing derived key data.
+     *
+     * @param kdfContext a globally unique key-derivation context byte string to separate key derivation contexts from each other
+     * @return fresh Blake3 instance in key derivation mode
+     */
+    public static Blake3 initKeyDerivationFunction(final byte[] kdfContext) {
+        Objects.requireNonNull(kdfContext);
+        final EngineState kdf = new EngineState(IV, DERIVE_KEY_CONTEXT);
+        kdf.inputData(kdfContext, 0, kdfContext.length);
+        final byte[] key = new byte[KEY_LEN];
+        kdf.outputHash(key, 0, key.length);
+        return new Blake3(unpackInts(key, KEY_INTS), DERIVE_KEY_MATERIAL);
+    }
+
+    /**
+     * Calculates the Blake3 hash of the provided data.
+     *
+     * @param data source array to absorb data from
+     * @return 32-byte hash squeezed from the provided data
+     */
+    public static byte[] hash(final byte[] data) {
+        final Blake3 blake3 = Blake3.initHash();
+        blake3.update(data);
+        return blake3.doFinalize(OUT_LEN);
+    }
+
+    /**
+     * Calculates the Blake3 keyed hash (MAC) of the provided data.
+     *
+     * @param key  32-byte secret key
+     * @param data source array to absorb data from
+     * @return 32-byte mac squeezed from the provided data
+     */
+    public static byte[] keyedHash(final byte[] key, final byte[] data) {
+        final Blake3 blake3 = Blake3.initKeyedHash(key);
+        blake3.update(data);
+        return blake3.doFinalize(OUT_LEN);
+    }
+
+    private static void packInt(final int value, final byte[] dst, final int off, final int len) {
+        for (int i = 0; i < len; i++) {
+            dst[off + i] = (byte) (value >>> i * Byte.SIZE);
+        }
+    }
+
+    private static int unpackInt(final byte[] buf, final int off) {
+        return buf[off] & 0xFF | (buf[off + 1] & 0xFF) << 8 | (buf[off + 2] & 0xFF) << 16 | (buf[off + 3] & 0xFF) << 24;
+    }
+
+    private static int[] unpackInts(final byte[] buf, final int nrInts) {
+        final int[] values = new int[nrInts];
+        for (int i = 0, off = 0; i < nrInts; i++, off += INT_BYTES) {
+            values[i] = unpackInt(buf, off);
+        }
+        return values;
+    }
+
+    // The mixing function, G, which mixes either a column or a diagonal.
+    private static void g(
+            final int[] state, final int a, final int b, final int c, final int d, final int mx, final int my) {
+        state[a] += state[b] + mx;
+        state[d] = Integer.rotateRight(state[d] ^ state[a], 16);
+        state[c] += state[d];
+        state[b] = Integer.rotateRight(state[b] ^ state[c], 12);
+        state[a] += state[b] + my;
+        state[d] = Integer.rotateRight(state[d] ^ state[a], 8);
+        state[c] += state[d];
+        state[b] = Integer.rotateRight(state[b] ^ state[c], 7);
+    }
+
+    private static void round(final int[] state, final int[] msg, final byte[] schedule) {
+        // Mix the columns.
+        g(state, 0, 4, 8, 12, msg[schedule[0]], msg[schedule[1]]);
+        g(state, 1, 5, 9, 13, msg[schedule[2]], msg[schedule[3]]);
+        g(state, 2, 6, 10, 14, msg[schedule[4]], msg[schedule[5]]);
+        g(state, 3, 7, 11, 15, msg[schedule[6]], msg[schedule[7]]);
+
+        // Mix the diagonals.
+        g(state, 0, 5, 10, 15, msg[schedule[8]], msg[schedule[9]]);
+        g(state, 1, 6, 11, 12, msg[schedule[10]], msg[schedule[11]]);
+        g(state, 2, 7, 8, 13, msg[schedule[12]], msg[schedule[13]]);
+        g(state, 3, 4, 9, 14, msg[schedule[14]], msg[schedule[15]]);
+    }
+
+    // pre-permuted for all 7 rounds; the second row (2,6,3,...) indicates the base permutation
+    private static final byte[][] MSG_SCHEDULE = {
+            { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
+            { 2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8 },
+            { 3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1 },
+            { 10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6 },
+            { 12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4 },
+            { 9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7 },
+            { 11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13 }
+    };
+
+    private static int[] compress(
+            final int[] chainingValue, final int[] blockWords, final int blockLength, final long counter,
+            final int flags) {
+        final int[] state = Arrays.copyOf(chainingValue, BLOCK_INTS);
+        System.arraycopy(IV, 0, state, 8, 4);
+        state[12] = (int) counter;
+        state[13] = (int) (counter >> Integer.SIZE);
+        state[14] = blockLength;
+        state[15] = flags;
+        for (int i = 0; i < 7; i++) {
+            final byte[] schedule = MSG_SCHEDULE[i];
+            round(state, blockWords, schedule);
+        }
+        for (int i = 0; i < state.length / 2; i++) {
+            state[i] ^= state[i + 8];
+            state[i + 8] ^= chainingValue[i];
+        }
+        return state;
+    }
+
+    private static Output parentOutput(
+            final int[] leftChildCV, final int[] rightChildCV, final int[] key, final int flags) {
+        final int[] blockWords = Arrays.copyOf(leftChildCV, BLOCK_INTS);","[{'comment': ""Not sure if it's worth commenting in the code, but there are various parts of the code like this line where I intentionally copy the array larger than the original to zero-extend a new array to fill in afterwards. Some byte array idioms :)"", 'commenter': 'jvz'}]"
85,src/main/java/org/apache/commons/codec/binary/BaseNCodec.java,"@@ -569,7 +570,11 @@ public String encodeToString(final byte[] pArray) {
      */
     protected byte[] ensureBufferSize(final int size, final Context context){
         if (context.buffer == null) {
-            context.buffer = new byte[Math.max(size, getDefaultBufferSize())];
+            int bufferSize = Math.max(size, getDefaultBufferSize());
+            if (context.bufferCache == null || context.bufferCache.length != bufferSize) {","[{'comment': 'I think it is only possible to call `ensureBufferSize` with a recycled `Context` when using the same BaseNCodecInputStream instance. These only encode or decode bytes in chunks of 4096 or 8192 respectively. Thus when `bufferCache` is not null then it should always be required to be initialised to the same `bufferSize`. Thus you may be able to change this to:\r\n```java\r\nif (context.bufferCache == null) {\r\n```\r\n\r\nIdeally this requires a new test that reuses a BaseNCodecInputStream instance to encode or decode a series of `byte[]` inputs to show coverage of execution paths. The Travis CI job should report coverage via Coveralls so that will indicate if the existing tests execute all these new code paths.\r\n', 'commenter': 'aherbert'}, {'comment': ""Base16 seems to have variable sizes. I don't understand the inner workings well enough currently. Will have to dig deeper. Wouldn't mind if you took over, though. :)"", 'commenter': 'apinske'}, {'comment': ""Ideally we wouldn't even need the cache, but the buffer is set to null to signal the calling code. I don't feel competent enough to refactor that though."", 'commenter': 'apinske'}, {'comment': 'I see now that encode and decode are called in BaseNCodecInputStream.read with the number of bytes read into the buffer. This can be used to optimise allocation as is done in Base16 codec. But given that the number of bytes will not be more than 8196 then this may suffice to better recycle the buffer:\r\n```java\r\nif (context.bufferCache == null || context.bufferCache.length < bufferSize) {\r\n```\r\nThis will work as the buffer size is not required to be exactly the size requested, only that it must be equal to or larger than the size requested.\r\n\r\nUse of the buffer as null for a signal predates my involvement with these classes. The use of buffer compared to null or not null is only done in a few places; all those places also use the `readPos` marker in the same method or directly after as they are all inquiring about whether there is anything to read. The same functionality may be achieved using `pos > readPos` as the signal. I updated BaseNCodec using (I left the old code commented out for reference):\r\n```java\r\n    int available(final Context context) {  // package protected for access from I/O streams\r\n        return hasData(context) ? context.pos - context.readPos : 0;\r\n        //return context.buffer != null ? context.pos - context.readPos : 0;\r\n    }\r\n\r\n    boolean hasData(final Context context) {  // package protected for access from I/O streams\r\n        return context.pos > context.readPos;\r\n        //return context.buffer != null;\r\n    }\r\n\r\n    int readResults(final byte[] b, final int bPos, final int bAvail, final Context context) {\r\n        if (hasData(context)) {\r\n        //if (context.buffer != null) {\r\n            final int len = Math.min(available(context), bAvail);\r\n            System.arraycopy(context.buffer, context.readPos, b, bPos, len);\r\n            context.readPos += len;\r\n            if (context.readPos >= context.pos) {\r\n                // All data read.\r\n                // Reset markers so hasData() will return false, and this method can return -1,\r\n                // but do not set buffer to null to allow reuse.\r\n                context.pos = context.readPos = 0;\r\n            //    context.buffer = null; // so hasData() will return false, and this method can return -1\r\n            }\r\n            return len;\r\n        }\r\n        return context.eof ? EOF : 0;\r\n    }\r\n```\r\n\r\nThis passes all the unit tests and does not require the buffer be set to null.\r\n\r\nYou could update the PR to use this method and then remove the bufferCache. The buffer itself will then be recycled.\r\n\r\n', 'commenter': 'aherbert'}, {'comment': ""Thanks! I'll rework the PR."", 'commenter': 'apinske'}]"
85,src/main/java/org/apache/commons/codec/binary/BaseNCodec.java,"@@ -75,6 +75,7 @@
          * Buffer for streaming.
          */
         byte[] buffer;
+        byte[] bufferCache;","[{'comment': ""This should have a comment such as:\r\n```\r\nA reuseable buffer that is allocated and assigned to 'buffer' when initialising 'buffer'\r\nfor processing. Note that when processing finishes the 'buffer' is assigned to null to\r\nindicate the end of input. The allocated memory is still available in 'bufferCache' for\r\nreuse on subsequent input. The cache is only used when the Context is recycled as\r\nin the case of using a BaseNCodecInputStream to read bytes.\r\n```"", 'commenter': 'aherbert'}]"
85,src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java,"@@ -39,12 +39,15 @@
 
     private final byte[] singleByte = new byte[1];
 
+    private final byte[] buf;","[{'comment': ""Add a comment about a reusable buffer to avoid repeat allocations in the read method's while loop."", 'commenter': 'aherbert'}]"
85,src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java,"@@ -171,7 +174,7 @@ public int read(final byte array[], final int offset, final int len) throws IOEx
         */
         while (readLen == 0) {","[{'comment': 'You commented that the read only attempts to read at most the size of the input buffer (`buf`), effectively ignoring the user requested length to read (`len`). This prevents a user reading with a very large `array` in a single method call.\r\n\r\nHow about this:\r\n```java\r\n// Attempt to read the request length\r\nwhile (readLen < len) {\r\n    if (!baseNCodec.hasData(context)) {\r\n        // Obtain more data.\r\n        // *** TBC: remove buffer allocation here ***\r\n        final byte[] buf = new byte[doEncode ? 4096 : 8192];\r\n        final int c = in.read(buf);\r\n        if (doEncode) {\r\n            baseNCodec.encode(buf, 0, c, context);\r\n        } else {\r\n            baseNCodec.decode(buf, 0, c, context);\r\n        }\r\n    }\r\n    final int read = baseNCodec.readResults(array, offset + readLen, len - readLen, context);\r\n    if (read < 0) {\r\n        // Return the amount read or EOF\r\n        return readLen != 0 ? readLen : -1;\r\n    }\r\n    readLen += read;\r\n}\r\n```\r\n\r\nThe above change passes the test suite using the old code. Can you try it with your changes to recycle the buffer.\r\n\r\nIIUC recycling the buffer will not cause memory expansion here. With the new changes the call to `readResults` should either: read all the data if the user has provided a very large destination `array` and the Context is reset to zero; or read some of the data up to the `len` requested by the user. The Context will then return true for the next call into this method in the `hasData(context)` statement and the Context will be emptied next time.\r\n', 'commenter': 'aherbert'}, {'comment': 'Looks good. Tests pass. I adjusted the new Base64-Test to provided bigger buffers.', 'commenter': 'apinske'}]"
85,src/main/java/org/apache/commons/codec/binary/BaseNCodec.java,"@@ -711,12 +711,15 @@ public boolean isStrictDecoding() {
      * @return The number of bytes successfully extracted into the provided byte[] array.
      */
     int readResults(final byte[] b, final int bPos, final int bAvail, final Context context) {
-        if (context.buffer != null) {
+        if (hasData(context)) {
             final int len = Math.min(available(context), bAvail);
             System.arraycopy(context.buffer, context.readPos, b, bPos, len);
             context.readPos += len;
             if (context.readPos >= context.pos) {","[{'comment': 'Perhaps this would be clearer as:\r\n```java\r\nif (!hasData(context))\r\n```\r\nReusing the hasData method makes it the single point of entry to the logic with the pos and readPos markers.\r\nThe comment can then be changed to:\r\n```java\r\n// All data read.\r\n// Reset position markers but do not set buffer to null to allow its reuse.\r\n// hasData(context) will still return false, and this method will return 0 until\r\n// more data is available, or -1 if EOF.\r\n```', 'commenter': 'aherbert'}]"
135,src/main/java/org/apache/commons/codec/binary/Base16.java,"@@ -177,26 +177,24 @@ void decode(final byte[] data, int offset, final int length, final Context conte
         if (dataLen < availableChars) {
             // we have 1/2 byte from previous invocation to decode
             result = (context.ibitWorkArea - 1) << BITS_PER_ENCODED_BYTE;
-            result |= decodeOctet(data[offset++]);","[{'comment': 'Can this avoid use of `offset + i++`:\r\n```Java\r\nresult |= decodeOctet(data[offset++]);\r\ni = 1;\r\n```', 'commenter': 'aherbert'}]"
135,src/main/java/org/apache/commons/codec/binary/Base16.java,"@@ -177,26 +177,24 @@ void decode(final byte[] data, int offset, final int length, final Context conte
         if (dataLen < availableChars) {
             // we have 1/2 byte from previous invocation to decode
             result = (context.ibitWorkArea - 1) << BITS_PER_ENCODED_BYTE;
-            result |= decodeOctet(data[offset++]);
-            i = 2;
+            result |= decodeOctet(data[offset + i++]);
 
             buffer[context.pos++] = (byte)result;
 
             // reset to empty-value for next invocation!
             context.ibitWorkArea = 0;
         }
 
-        while (i < charsToProcess) {
-            result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE;
-            result |= decodeOctet(data[offset++]);
-            i += 2;
+        while (i + 1 < charsToProcess) {","[{'comment': 'I would prefer to not use `i + 1 < charsToProcess` on the loop condition.\r\n\r\nIt seems the logic setting `charsToProcess` is incorrect when there is a previous half-byte. The value should not be final and can be decremented by 1 if `i` is set to 1:\r\n```\r\nresult |= decodeOctet(data[offset++]);\r\ni = 1;\r\ncharsToProcess--;\r\n\r\n// ...\r\n\r\nwhile (i < charsToProcess) {\r\n```\r\n\r\nThis corrected logic still requires that offset is added to i: `data[offset + i++]`. Previously offset was incremented.\r\n\r\nThis may be better served by computing the end point for offset:\r\n```Java\r\n// Set earlier before offset is changed\r\nfinal int end = offset + dataLen;\r\n\r\n// ...\r\n\r\n// Allow looping over (offset + 1 < end)\r\nfinal int loopEnd = end - 1;\r\nwhile (offset < loopEnd) {\r\n            result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE;\r\n            result |= decodeOctet(data[offset++]);\r\n}\r\n\r\n// Consume final trailing byte\r\nif (offset < end) {\r\n\r\n```\r\n\r\nThis logic would eliminate the requirement for `i` and `charsToProcess`. The logic to handle the ensureBufferSize can just use `availableChars`. Note: The code is untested.\r\n', 'commenter': 'aherbert'}]"
219,src/test/java/org/apache/commons/codec/language/RefinedSoundexTest.java,"@@ -93,4 +94,13 @@ public void testNewInstance2() {
     public void testNewInstance3() {
         assertEquals(""D6043"", new RefinedSoundex(RefinedSoundex.US_ENGLISH_MAPPING_STRING).soundex(""dogs""));
     }
+
+    @Test
+    public void testInvalidSoundexCharacter() {
+        char[] invalid = new char[256];
+        for (int i = 0; i < 256; i++) {","[{'comment': ""Hello @arthurscchan \r\nYou'll want to remove use of the magic number here and say `invalid.length`.\r\nTY!"", 'commenter': 'garydgregory'}, {'comment': 'Have changed. Thanks.', 'commenter': 'arthurscchan'}]"
220,src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java,"@@ -126,10 +126,20 @@ public final String encode(String name) {
         // Preprocessing
         name = cleanName(name);
 
+        // Bulletproof if name becomes empty after cleanName(name)
+        if (EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 0) {","[{'comment': 'Use `isEmpty()`.', 'commenter': 'garydgregory'}, {'comment': ""- You're checking that the name is empty... twice?\r\n- Why use equalsIgnoreCase() for SPACE?"", 'commenter': 'garydgregory'}]"
220,src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java,"@@ -126,10 +126,20 @@ public final String encode(String name) {
         // Preprocessing
         name = cleanName(name);
 
+        // Bulletproof if name becomes empty after cleanName(name)
+        if (EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 0) {
+            return EMPTY;
+        }
+
         // BEGIN: Actual encoding part of the algorithm...
         // 1. Delete all vowels unless the vowel begins the word
         name = removeVowels(name);
 
+        // Bulletproof if name becomes empty after removeVowels(name)
+        if (EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 0) {","[{'comment': 'Use `isEmpty()`.', 'commenter': 'garydgregory'}, {'comment': ""- You're checking that the name is empty... twice?\r\n- Why use equalsIgnoreCase() for SPACE?"", 'commenter': 'garydgregory'}]"
220,src/test/java/org/apache/commons/codec/language/MatchRatingApproachEncoderTest.java,"@@ -519,4 +520,22 @@ public final void testRemoveVowel_ALESSANDRA_Returns_ALSSNDR() {
 
     // ***** END REGION - TEST GET MRA COMPARISONS
 
+    // ***** BEGIN REGION - TEST INVALID STRING *****
+
+    @Test
+    public final void testPunctuationOnly() {
+      assertDoesNotThrow(() -> this.getStringEncoder().encode("".,-""));","[{'comment': 'See comment in other PR.', 'commenter': 'garydgregory'}]"
220,src/test/java/org/apache/commons/codec/language/MatchRatingApproachEncoderTest.java,"@@ -519,4 +520,34 @@ public final void testRemoveVowel_ALESSANDRA_Returns_ALSSNDR() {
 
     // ***** END REGION - TEST GET MRA COMPARISONS
 
+    // ***** BEGIN REGION - TEST INVALID STRING *****
+
+    @Test
+    public final void testPunctuationOnly() {
+        assertDoesNotThrow(() -> {
+            String expected = """";
+            String result = this.getStringEncoder().encode("".,-"");
+            assertEquals(result, expected);
+        });
+    }
+
+    @Test
+    public final void testVowelOnly() {
+        assertDoesNotThrow(() -> {
+            String expected = ""A"";
+            String result = this.getStringEncoder().encode(""aeiouAEIOU"");
+            assertEquals(result, expected);
+        });
+    }
+
+    @Test
+    public final void testVowelAndPunctuationOnly() {
+        assertDoesNotThrow(() -> {
+            String expected = ""U"";
+            String result = this.getStringEncoder().encode(""uoiea.,-AEIOU"");
+            assertEquals(result, expected);
+        });
+    }
+
+    // ***** END REGION - TEST INVALID STRING *****","[{'comment': 'Noise comment, remove it please.', 'commenter': 'garydgregory'}, {'comment': 'Removed.', 'commenter': 'arthurscchan'}]"
220,src/test/java/org/apache/commons/codec/language/MatchRatingApproachEncoderTest.java,"@@ -519,4 +520,34 @@ public final void testRemoveVowel_ALESSANDRA_Returns_ALSSNDR() {
 
     // ***** END REGION - TEST GET MRA COMPARISONS
 
+    // ***** BEGIN REGION - TEST INVALID STRING *****","[{'comment': 'Noise comment, remove it please.', 'commenter': 'garydgregory'}, {'comment': 'removed. ', 'commenter': 'arthurscchan'}]"
220,src/test/java/org/apache/commons/codec/language/MatchRatingApproachEncoderTest.java,"@@ -519,4 +520,34 @@ public final void testRemoveVowel_ALESSANDRA_Returns_ALSSNDR() {
 
     // ***** END REGION - TEST GET MRA COMPARISONS
 
+    // ***** BEGIN REGION - TEST INVALID STRING *****
+
+    @Test
+    public final void testPunctuationOnly() {
+        assertDoesNotThrow(() -> {
+            String expected = """";","[{'comment': ""No need for local vars, block, or does not throw api in single assert method. I've already commented on this in a separate PR."", 'commenter': 'garydgregory'}, {'comment': 'Resolved.', 'commenter': 'arthurscchan'}]"
221,src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java,"@@ -208,6 +208,11 @@ public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[]
         final int bytesLength = bytes.length;
 
         if (strict) {
+            // Ensure bytes have at least 3 bytes
+            if (bytesLength < 3) {","[{'comment': 'Hello @arthurscchan \r\nIf the number `3` is special, please refactor it into a constant and document it.', 'commenter': 'garydgregory'}]"
223,src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineTest.java,"@@ -70,4 +80,13 @@ public void testEncode(final String name, final String phoneticExpected, final N
             }
         }
     }
+
+    @ParameterizedTest
+    @MethodSource(""invalidData"")
+    public void testInvalidEncode(final String input, final NameType nameType, final RuleType ruleType,
+                                  final boolean concat, final int maxPhonemes) {
+        final PhoneticEngine engine = new PhoneticEngine(nameType, ruleType, concat, maxPhonemes);
+
+        assertDoesNotThrow(() -> engine.encode(input));","[{'comment': 'Why is `assertDoesNotThrow` used here? The test method does nothing else after the call to encode so there is nothing else to run. Or, am I missing something?\r\n\r\nNote: I am not going to copy-paste the above comment in all PRs.', 'commenter': 'garydgregory'}, {'comment': 'Originally I just want to test if the invalid input still throw any unexpected exceptions. But yes, I do agree the result also needed to be checked. I have changed the test case a little bit, as well as for other PRs. Thanks for your suggestions.', 'commenter': 'arthurscchan'}]"
223,src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java,"@@ -431,7 +431,7 @@ public String encode(String input, final Languages.LanguageSet languageSet) {
         } else if (words2.size() == 1) {
             // not a multi-word name
             input = words.iterator().next();
-        } else {
+        } else if (words2.size() > 0) {","[{'comment': 'Use `isEmpty()`.', 'commenter': 'garydgregory'}, {'comment': 'Changed. Thanks for your suggestion.', 'commenter': 'arthurscchan'}]"
