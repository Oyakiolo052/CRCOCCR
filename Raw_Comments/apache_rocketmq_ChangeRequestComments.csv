Pull,Path,Diff_hunk,Comment
91,client/src/main/java/org/apache/rocketmq/client/consumer/listener/ConsumeReturnType.java,"@@ -33,7 +33,7 @@
     /**
      * consume return null
      */
-    RETURNNULL,
+    RETURN_NULL,","[{'comment': 'This is in an enum in client, we should be cautions for this since the user may has been using it.\r\n\r\nMaybe we can comment in the java doc and explain that we will rename it in latter version?', 'commenter': 'Jaskey'}]"
91,client/src/main/java/org/apache/rocketmq/client/producer/LocalTransactionState.java,"@@ -19,5 +19,5 @@
 public enum LocalTransactionState {
     COMMIT_MESSAGE,
     ROLLBACK_MESSAGE,
-    UNKNOW,
+    UNKNOWN,","[{'comment': 'The same above', 'commenter': 'Jaskey'}]"
91,client/src/main/java/org/apache/rocketmq/client/producer/LocalTransactionExecutor.java,"@@ -18,6 +18,6 @@
 
 import org.apache.rocketmq.common.message.Message;
 
-public interface LocalTransactionExecuter {
-    public LocalTransactionState executeLocalTransactionBranch(final Message msg, final Object arg);
+public interface LocalTransactionExecutor {","[{'comment': ""We can't just rename a public interface, since the user who updates will find it not able to compile."", 'commenter': 'Jaskey'}, {'comment': ""1) This project is still at incubation stage, if we do not correct things now, we may never ever get the chance to fix them afterwards.\r\n2) Transaction related feature is not currently implemented, IMO, we may fix this interface before it's widely used.\r\n"", 'commenter': 'lizhanhui'}, {'comment': 'So in the next version, we must announce that they may face the compatible problem when they use XXXX in the older version.\r\n\r\nBefore they update, they must know about this and know how to fix them , and then upgrade.', 'commenter': 'Jaskey'}, {'comment': 'This is why I make these changes through PR process instead of regarding them trivial and merging directly.\r\n\r\nWe can discuss to figure out an acceptable way.\r\n\r\nYou may also notice that I do not change configuration name spelling issues yet and I am expecting opinions too.', 'commenter': 'lizhanhui'}, {'comment': 'For cinfiguration issue, we can fix them by pointing them to the same right spelling config.\r\n\r\n    private int rightConfig;\r\n       @Deprecated    \r\n    public int getTypoConfig(){\r\n         return rightConfig;\r\n    }\r\n\r\n    @Deprecated\r\n    public void setTypoConfig(int val) {\r\n        this.rightConfig = val;\r\n    }\r\n\r\n    getter/setter for right config...\r\n\r\n\r\nBut since client config and server config are working in totally different ways that server config uses reflection to load configurations so this should only work for client configuration typo issue. \r\n\r\nI suggest we post another two typo issues for client configuration and server configuration.', 'commenter': 'Jaskey'}]"
91,CONTRIBUTING.md,"@@ -11,7 +11,7 @@ To submit a change for inclusion, please do the following:
 
 #### If the change is non-trivial please include some unit tests that cover the new functionality.
 #### If you are introducing a completely new feature or API it is a good idea to start a wiki and get consensus on the basic design first.
-#### It is our job to follow up on patches in a timely fashion. Nag us if we aren't doing our job (sometimes we drop things).
+#### It is our job to follow up on patches in a timely fashion. Nag us if we arn't doing our job timely enough (sometimes we may miss things).","[{'comment': ""arn't -> aren't ?"", 'commenter': 'vesense'}, {'comment': ""Yes, aren't is right. "", 'commenter': 'lizhanhui'}]"
91,common/src/main/java/org/apache/rocketmq/common/protocol/header/GetEarliestMsgStoreTimeRequestHeader.java,"@@ -16,15 +16,15 @@
  */
 
 /**
- * $Id: GetEarliestMsgStoretimeRequestHeader.java 1835 2013-05-16 02:00:50Z vintagewang@apache.org $
+ * $Id: GetEarliestMsgStoreTimeRequestHeader.java 1835 2013-05-16 02:00:50Z vintagewang@apache.org $","[{'comment': 'Why do we need this line?', 'commenter': 'shroman'}]"
91,common/src/main/java/org/apache/rocketmq/common/protocol/header/GetEarliestMsgStoreTimeResponseHeader.java,"@@ -16,15 +16,15 @@
  */
 
 /**
- * $Id: GetEarliestMsgStoretimeResponseHeader.java 1835 2013-05-16 02:00:50Z vintagewang@apache.org $
+ * $Id: GetEarliestMsgStoreTimeResponseHeader.java 1835 2013-05-16 02:00:50Z vintagewang@apache.org $","[{'comment': 'Why do we need this line?', 'commenter': 'shroman'}, {'comment': 'It should not be here.', 'commenter': 'lizhanhui'}, {'comment': ""There are many files with such lines. If you don't mind, let's have them removed with this commit ;)"", 'commenter': 'shroman'}]"
91,client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java,"@@ -907,10 +907,10 @@ public void queryMessage(
         final QueryMessageRequestHeader requestHeader,
         final long timeoutMillis,
         final InvokeCallback invokeCallback,
-        final Boolean isUnqiueKey
+        final Boolean isUnqueKey","[{'comment': 'is it isUniqueKey ?', 'commenter': 'vsair'}, {'comment': 'Thanks for point it out, unique key.', 'commenter': 'lizhanhui'}]"
91,common/src/main/java/org/apache/rocketmq/common/protocol/route/TopicRouteData.java,"@@ -27,23 +27,23 @@
 
 public class TopicRouteData extends RemotingSerializable {
     private String orderTopicConf;
-    private List<QueueData> queueDatas;
-    private List<BrokerData> brokerDatas;
+    private List<QueueData> queueDataList;
+    private List<BrokerData> brokerDataList;","[{'comment': ""It is modification of protocol, IMO, it's improper for upgrade of server or client."", 'commenter': 'vsair'}, {'comment': 'Right. looks we have to keep it intact.', 'commenter': 'lizhanhui'}]"
91,common/src/main/java/org/apache/rocketmq/common/protocol/header/QueryMessageResponseHeader.java,"@@ -28,7 +28,7 @@
     @CFNotNull
     private Long indexLastUpdateTimestamp;
     @CFNotNull
-    private Long indexLastUpdatePhyoffset;
+    private Long indexLastUpdatePhyOffset;","[{'comment': 'Protocol modification.', 'commenter': 'vsair'}]"
134,store/src/main/java/org/apache/rocketmq/store/DefaultMessageStore.java,"@@ -745,17 +751,7 @@ public long getMessageStoreTimeStamp(String topic, int queueId, long consumeQueu
         ConsumeQueue logicQueue = this.findConsumeQueue(topic, queueId);
         if (logicQueue != null) {
             SelectMappedBufferResult result = logicQueue.getIndexBuffer(consumeQueueOffset);
-            if (result != null) {
-                try {
-                    final long phyOffset = result.getByteBuffer().getLong();
-                    final int size = result.getByteBuffer().getInt();
-                    long storeTime = this.getCommitLog().pickupStoreTimestamp(phyOffset, size);
-                    return storeTime;
-                } catch (Exception ignored) {
-                } finally {
-                    result.release();
-                }
-            }
+            long storeTime = getStoreTime(result);","[{'comment': 'Convert Long to long ? may lead to NPE?', 'commenter': 'vsair'}, {'comment': 'We appreciate your contribution for rocketmq commuity, could you use unit test to verify your refactoring', 'commenter': 'vongosling'}]"
134,store/src/main/java/org/apache/rocketmq/store/DefaultMessageStore.java,"@@ -717,22 +717,28 @@ public long getEarliestMessageTime(String topic, int queueId) {
             long minLogicOffset = logicQueue.getMinLogicOffset();
 
             SelectMappedBufferResult result = logicQueue.getIndexBuffer(minLogicOffset / ConsumeQueue.CQ_STORE_UNIT_SIZE);
-            if (result != null) {
-                try {
-                    final long phyOffset = result.getByteBuffer().getLong();
-                    final int size = result.getByteBuffer().getInt();
-                    long storeTime = this.getCommitLog().pickupStoreTimestamp(phyOffset, size);
-                    return storeTime;
-                } catch (Exception e) {
-                } finally {
-                    result.release();
-                }
-            }
+            Long storeTime = getStoreTime(result);
+            if (storeTime != null) return storeTime;
         }
 
         return -1;
     }
 
+    private Long getStoreTime(SelectMappedBufferResult result) {","[{'comment': 'IMO, just return long and default value is -1.', 'commenter': 'vsair'}]"
134,client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java,"@@ -1215,9 +1199,14 @@ public TopicRouteData getTopicRouteInfoFromNameServer(final String topic, final
         assert response != null;
         switch (response.getCode()) {
             case ResponseCode.TOPIC_NOT_EXIST: {
-                if (!topic.equals(MixAll.DEFAULT_TOPIC))
-                    log.warn(""get Topic [{}] RouteInfoFromNameServer is not exist value"", topic);
-                break;
+                if(allowTopicNotExist) {","[{'comment': ""Could you polish the 'double if'?"", 'commenter': 'vsair'}]"
134,store/src/main/java/org/apache/rocketmq/store/DefaultMessageStore.java,"@@ -16,29 +16,7 @@
  */
 package org.apache.rocketmq.store;
 
-import java.io.File;
-import java.io.IOException;
-import java.net.SocketAddress;
-import java.nio.ByteBuffer;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicLong;
-import org.apache.rocketmq.common.BrokerConfig;
-import org.apache.rocketmq.common.MixAll;
-import org.apache.rocketmq.common.ServiceThread;
-import org.apache.rocketmq.common.SystemClock;
-import org.apache.rocketmq.common.ThreadFactoryImpl;
-import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.*;","[{'comment': ""I believe you won't have this * if you format promerly.\r\nPlease check http://rocketmq.apache.org/docs/code-guidelines/"", 'commenter': 'shroman'}, {'comment': '@shroman Done. Thanks for pointing towards the code guidelines. ', 'commenter': 'that-data-scientist'}]"
134,client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java,"@@ -1215,9 +1210,13 @@ public TopicRouteData getTopicRouteInfoFromNameServer(final String topic, final
         assert response != null;
         switch (response.getCode()) {
             case ResponseCode.TOPIC_NOT_EXIST: {
-                if (!topic.equals(MixAll.DEFAULT_TOPIC))
+                if (allowTopicNotExist && !topic.equals(MixAll.DEFAULT_TOPIC)) {
                     log.warn(""get Topic [{}] RouteInfoFromNameServer is not exist value"", topic);
-                break;
+                    break;","[{'comment': 'why do you need 2 breaks?', 'commenter': 'shroman'}, {'comment': ""@shroman We don't have two breaks. The part you are have referred to shows the diff where the break from 1220 has been removed and the break on 1215 has been added. "", 'commenter': 'that-data-scientist'}, {'comment': ""well, I mean you can have one for `case ResponseCode.TOPIC_NOT_EXIST`, can't you?"", 'commenter': 'shroman'}, {'comment': '@shroman Ahh. I get you now. Making the change and pushing. Thanks\r\n', 'commenter': 'that-data-scientist'}]"
134,client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java,"@@ -1215,9 +1210,13 @@ public TopicRouteData getTopicRouteInfoFromNameServer(final String topic, final
         assert response != null;
         switch (response.getCode()) {
             case ResponseCode.TOPIC_NOT_EXIST: {
-                if (!topic.equals(MixAll.DEFAULT_TOPIC))
+                if (allowTopicNotExist && !topic.equals(MixAll.DEFAULT_TOPIC)) {
                     log.warn(""get Topic [{}] RouteInfoFromNameServer is not exist value"", topic);
-                break;
+                    break;
+                } else {
+                    // TODO LOG","[{'comment': ""Please don't leave TODO if possible."", 'commenter': 'shroman'}, {'comment': '@shroman The TODO was already there. Not sure what to do about it right now. ', 'commenter': 'that-data-scientist'}, {'comment': 'ok then', 'commenter': 'shroman'}]"
134,store/src/main/java/org/apache/rocketmq/store/DefaultMessageStore.java,"@@ -717,22 +718,28 @@ public long getEarliestMessageTime(String topic, int queueId) {
             long minLogicOffset = logicQueue.getMinLogicOffset();
 
             SelectMappedBufferResult result = logicQueue.getIndexBuffer(minLogicOffset / ConsumeQueue.CQ_STORE_UNIT_SIZE);
-            if (result != null) {
-                try {
-                    final long phyOffset = result.getByteBuffer().getLong();
-                    final int size = result.getByteBuffer().getInt();
-                    long storeTime = this.getCommitLog().pickupStoreTimestamp(phyOffset, size);
-                    return storeTime;
-                } catch (Exception e) {
-                } finally {
-                    result.release();
-                }
-            }
+            Long storeTime = getStoreTime(result);
+            return storeTime;","[{'comment': '`return getStoreTime(result);` will suffice.', 'commenter': 'shroman'}, {'comment': 'Yup. Made the change. ', 'commenter': 'that-data-scientist'}]"
218,client/src/main/java/org/apache/rocketmq/client/log/ClientLogger.java,"@@ -90,13 +87,7 @@ private static Logger createLogger(final String loggerName) {
                     }
 
                 } else if (classType.getName().equals(""org.apache.logging.slf4j.Log4jLoggerFactory"")) {
-                    Class<?> joranConfigurator = Class.forName(""org.apache.logging.log4j.core.config.Configurator"");
-                    Method initialize = joranConfigurator.getDeclaredMethod(""initialize"", String.class, String.class);
-                    if (null == logConfigFilePath) {
-                        initialize.invoke(joranConfigurator, ""log4j2"", log4J2ResourceFile);
-                    } else {
-                        initialize.invoke(joranConfigurator, ""log4j2"", logConfigFilePath);
-                    }
+                    Log4j2Helper.addClientLogger(clientLogRoot,clientLogLevel,clientLogMaxIndex,true);","[{'comment': 'Hi, please leave a space behind `,`:\r\n`Log4j2Helper.addClientLogger(clientLogRoot, clientLogLevel, clientLogMaxIndex, true);`\r\n', 'commenter': 'zhouxinyu'}]"
218,client/src/main/java/org/apache/rocketmq/client/log/Log4j2Helper.java,"@@ -0,0 +1,159 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.client.log;
+
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.core.Layout;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.appender.AbstractAppender;
+import org.apache.logging.log4j.core.appender.AsyncAppender;
+import org.apache.logging.log4j.core.appender.RollingFileAppender;
+import org.apache.logging.log4j.core.appender.rolling.CompositeTriggeringPolicy;
+import org.apache.logging.log4j.core.appender.rolling.DefaultRolloverStrategy;
+import org.apache.logging.log4j.core.appender.rolling.SizeBasedTriggeringPolicy;
+import org.apache.logging.log4j.core.appender.rolling.TimeBasedTriggeringPolicy;
+import org.apache.logging.log4j.core.config.AppenderRef;
+import org.apache.logging.log4j.core.config.Configuration;
+import org.apache.logging.log4j.core.config.LoggerConfig;
+import org.apache.logging.log4j.core.layout.PatternLayout;
+
+import java.lang.reflect.Method;
+
+public class Log4j2Helper {
+
+    private static final int ASYNC_APPENDER_QUEUE_SIZE = 1024;
+
+    private static final String APPENDER_FILE_SIZE = ""100MB"";
+
+    private static final int ASYNC_APPENDER_SHUTDOWN_TIMEOUT = 3;
+
+    private static final String LOG_LAYOUT_PATTERN = ""%d{yyy-MM-dd HH:mm:ss,GMT+8} %p %t - %m%n"";
+
+    private static Method getMethodWithOnlyName(Class clazz, String name) {
+        Method[] declaredMethods = clazz.getDeclaredMethods();
+        for (Method declaredMethod : declaredMethods) {
+            if (declaredMethod.getName().equals(name)) {
+                return declaredMethod;
+            }
+        }
+        return null;
+    }
+
+    private static DefaultRolloverStrategy createRolloverStrategy(String max, final Configuration config) {
+        Method createMethod = getMethodWithOnlyName(DefaultRolloverStrategy.class, ""createStrategy"");
+        if (createMethod != null) {
+            createMethod.setAccessible(true);
+            Class<?>[] parameterTypes = createMethod.getParameterTypes();
+            try {
+                if (parameterTypes.length == 5) {
+                    return (DefaultRolloverStrategy) createMethod.invoke(null, max, ""1"", null, ""1"", config);
+                } else {
+                    return (DefaultRolloverStrategy) createMethod.invoke(null, max, ""1"", null, ""1"", null, true, config);
+                }
+            } catch (Exception e) {
+                System.err.println(e);
+            }
+        }
+        return null;
+    }
+
+    private static AbstractAppender createAsyncAppender(AbstractAppender appender, boolean blocking, int queueSize, Configuration config) {
+        String refAppenderName = appender.getName();
+        AppenderRef ref = AppenderRef.createAppenderRef(refAppenderName, null, null);
+        AppenderRef[] refs1 = new AppenderRef[]{ref};
+        String asyncAppenderName = ""Async"" + refAppenderName;
+
+        Method createMethod = getMethodWithOnlyName(AsyncAppender.class, ""createAppender"");
+
+        if (createMethod == null) {
+            return appender;
+        }
+        AsyncAppender asyncAppender = null;
+        try {
+            if (createMethod.getParameterTypes().length == 9) {","[{'comment': 'Do we have another approach to distinguish these two methods, instead of using magic number 9?', 'commenter': 'zhouxinyu'}]"
393,distribution/bin/to_bytes.gawk,"@@ -0,0 +1,26 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Use gawk because gnu awk can't extract regexp groups; gawk has `match`","[{'comment': ""@huanwei Is there any script to test whether `gawk` exists and install it if missed?\r\nMy concern is that our users may use this script on their OS instead of Docker container, so we may need to solve the dependencies of `gawk`. So I'm wondering whether we can calculate values of available memory without `gawk` by using bash built-in functions and commands.\r\n\r\nAnd there is another issue, the Apache RocketMQ has `cmd` script for Windows users, I think we should make scripts of Unix/Linux and Windows working in same logic."", 'commenter': 'xiaozongyang'}, {'comment': 'ping @huanwei @vongosling ', 'commenter': 'xiaozongyang'}, {'comment': '@XiaoZYang Thanks for your suggestion. For Unix/Linux I have changed the scripts to use `awk`.', 'commenter': 'huanwei'}, {'comment': ""I'm trying to find a Windows environment. If anyone has the Windows environment, please go ahead.."", 'commenter': 'huanwei'}, {'comment': '@huanwei cool, would you mind change your pr merge target to develop branch. It has a little difference with external projects.', 'commenter': 'vongosling'}, {'comment': ""@huanwei Oh, I'd like to have a try on Windows tomorrow 👍 "", 'commenter': 'xiaozongyang'}, {'comment': '@huanwei @vongosling I get some problems with the windows script and the result will be posted on this Saturday, i.e. Aut.11.', 'commenter': 'xiaozongyang'}]"
393,distribution/bin/runserver.sh,"@@ -37,7 +37,16 @@ export CLASSPATH=.:${BASE_DIR}/conf:${CLASSPATH}
 # JVM Configuration
 #===========================================================================================
 # Get the max heap used by a jvm, which used all the ram available to the container.
-MAX_POSSIBLE_HEAP=$(java -XX:+UnlockExperimentalVMOptions -XX:MaxRAMFraction=1 -XshowSettings:vm -version |& awk '/Max\. Heap Size \(Estimated\): [0-9KMG]+/{ print $5}' | gawk -f to_bytes.gawk)
+MAX_POSSIBLE_HEAP_STR=$(java -XX:+UnlockExperimentalVMOptions -XX:MaxRAMFraction=1 -XshowSettings:vm -version |& awk '/Max\. Heap Size \(Estimated\): [0-9KMG]+/{ print $5}')","[{'comment': '@huanwei  Is it a typo here? It should be `|` instead of `|&`.\r\nAnd after I replace `|&` with `|`, When I run the script by `bash mqnamesrv -n localhost:9876` I got an error with message: `Invalid maximum heap size: -Xmx0`. By the way, the code is cloned from your github.\r\nWould you mind re-checking your awk script here? \r\nMy development environment is:\r\n- OS: MacOS Elcaption 10.11\r\n- java version: 1.8.0_172\r\n- bash version: 3.2.57', 'commenter': 'xiaozongyang'}, {'comment': ""@XiaoZYang `|&` is shorthand for `2>&1 |`. I did the tests on my Ubuntu and CentOS, it works well.  Seems MacOS bash does not  recognize `|&` . \r\n\r\nNow it should be compatible with MacOS, I did the test on my Mac:\r\n```\r\nhuandeMacBook-Pro:huanwei huan$ java -XX:+UnlockExperimentalVMOptions -XX:MaxRAMFraction=1 -XshowSettings:vm -version 2>&1 | awk '/Max\\. Heap Size \\(Estimated\\): [0-9KMG]+/{ print $5}'\r\n7.11G\r\n```\r\nThanks for your finding. 👍 "", 'commenter': 'huanwei'}]"
635,remoting/src/test/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstractTest.java,"@@ -90,4 +93,18 @@ public void operationComplete(final ResponseFuture responseFuture) {
         semaphore.acquire(1);
         assertThat(semaphore.availablePermits()).isEqualTo(0);
     }
+
+    @Test","[{'comment': 'It would be better add share handler test in here, not judge null case but also the same object judgment.', 'commenter': 'vongosling'}]"
646,broker/src/main/java/org/apache/rocketmq/broker/client/net/Broker2Client.java,"@@ -119,10 +119,8 @@ public RemotingCommand resetOffset(String topic, String group, long timeStamp, b
         Map<MessageQueue, Long> offsetTable = new HashMap<MessageQueue, Long>();
 
         for (int i = 0; i < topicConfig.getWriteQueueNums(); i++) {
-            MessageQueue mq = new MessageQueue();
-            mq.setBrokerName(this.brokerController.getBrokerConfig().getBrokerName());
-            mq.setTopic(topic);
-            mq.setQueueId(i);
+            String brokerName = this.brokerController.getBrokerConfig().getBrokerName();","[{'comment': 'This line could be outside the loop?', 'commenter': 'liuruiyiyang'}]"
875,common/src/test/java/org/apache/rocketmq/common/consistenthash/ConsistentHashRouterTest.java,"@@ -0,0 +1,109 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.common.consistenthash;
+
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ *  Created by guoyao on 2019/2/22.
+ */","[{'comment': 'Plz remove the author info.', 'commenter': 'RongtongJin'}]"
1593,client/src/test/java/org/apache/rocketmq/client/latency/MQFaultStrategyTest.java,"@@ -0,0 +1,252 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.client.latency;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.rocketmq.client.common.ThreadLocalIndex;
+import org.apache.rocketmq.client.impl.producer.TopicPublishInfo;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.Spy;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.junit.MockitoJUnitRunner;
+import org.mockito.stubbing.Answer;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.doReturn;
+
+@RunWith(MockitoJUnitRunner.class)
+public class MQFaultStrategyTest {
+    private MQFaultStrategy mqFaultStrategy;
+    @Spy
+    private final TopicPublishInfo tpInfo = createTopicPublicshInfo();
+    @Spy
+    private final LatencyFaultToleranceImpl latencyFaultTolerance =  new LatencyFaultToleranceImpl();
+    @Mock
+    private ThreadLocalIndex sendWhichQueue;
+    private static String brokerNameA = ""BrokerA"";
+    private static String brokerNameB = ""BrokerB"";
+    private static String brokerNameC = ""BrokerC"";
+    private static String topic = ""TEST_TOPIC"";","[{'comment': ""maybe declared as 'final'?\r\n\r\n"", 'commenter': 'jamesxuhaozhe'}]"
1593,client/src/main/java/org/apache/rocketmq/client/latency/MQFaultStrategy.java,"@@ -65,7 +65,7 @@ public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final S
                         pos = 0;
                     MessageQueue mq = tpInfo.getMessageQueueList().get(pos);
                     if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) {
-                        if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))
+                        if (!mq.getBrokerName().equals(lastBrokerName))","[{'comment': 'please see #1607 ', 'commenter': 'ifplusor'}]"
1903,store/src/main/java/org/apache/rocketmq/store/CommitLog.java,"@@ -761,15 +767,20 @@ public long getBeginTimeInLock() {
         storeStatsService.getSinglePutMessageTopicTimesTotal(messageExtBatch.getTopic()).addAndGet(result.getMsgNum());
         storeStatsService.getSinglePutMessageTopicSizeTotal(messageExtBatch.getTopic()).addAndGet(result.getWroteBytes());
 
-        CompletableFuture<PutMessageStatus> flushOKFuture = submitFlushRequest(result, putMessageResult, messageExtBatch);
-        CompletableFuture<PutMessageStatus> replicaOKFuture = submitReplicaRequest(result, putMessageResult, messageExtBatch);
+        CompletableFuture<PutMessageStatus> flushOKFuture = submitFlushRequest(result, messageExtBatch);
+        CompletableFuture<PutMessageStatus> replicaOKFuture = submitReplicaRequest(result, messageExtBatch);
         return flushOKFuture.thenCombine(replicaOKFuture, (flushStatus, replicaStatus) -> {
             if (flushStatus != PutMessageStatus.PUT_OK) {
-                putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);
+                putMessageResult.setPutMessageStatus(flushStatus);
+                log.error(""do groupcommit, wait for flush failed, topic: {} tags: {} client address: {}"",","[{'comment': 'If the disk flashing has failed, and continue to log here, it will increase the system load and increase disk IO.\r\nIMO, as the status will be sent to the client, it is better to remove the error log here. ', 'commenter': 'ShannonDing'}, {'comment': 'Indeed so.\r\nI still have a question about [#1894 pr]\r\n````java\r\nreq.wakeupCustomer(flushOK ? PutMessageStatus.PUT_OK : PutMessageStatus.FLUSH_DISK_TIMEOUT);\r\n````\r\nflushOK is false means FLUSH_DISK_TIMEOUT? ', 'commenter': 'rushsky518'}]"
1981,common/src/main/java/org/apache/rocketmq/common/message/MessageExt.java,"@@ -118,18 +118,25 @@ public void setBornHost(SocketAddress bornHost) {
     }
 
     public String getBornHostString() {
-        if (this.bornHost != null) {
-            InetSocketAddress inetSocketAddress = (InetSocketAddress) this.bornHost;
-            return inetSocketAddress.getAddress().getHostAddress();
+        try {
+            if (this.bornHost != null) {
+                InetSocketAddress inetSocketAddress = (InetSocketAddress) this.bornHost;
+                return inetSocketAddress.getAddress().getHostAddress();
+            }
+        } catch (Exception e) {
         }
 
         return null;
     }
 
     public String getBornHostNameString() {
-        if (this.bornHost != null) {
-            InetSocketAddress inetSocketAddress = (InetSocketAddress) this.bornHost;
-            return inetSocketAddress.getAddress().getHostName();
+        try {
+            if (this.bornHost != null) {
+                InetSocketAddress inetSocketAddress = (InetSocketAddress) this.bornHost;
+                return inetSocketAddress.getAddress().getHostName();
+            }
+        } catch (Exception e) {","[{'comment': 'It is recommended to check for NPE in advance instead of catching exceptions', 'commenter': 'RongtongJin'}, {'comment': 'It would be better to write as this instead of catching exceptions\r\n```java\r\npublic String getBornHostNameString() {\r\n        if (this.bornHost != null) {\r\n            InetAddress inetAddress = ((InetSocketAddress) this.bornHost).getAddress();\r\n            return inetAddress != null ? inetAddress.getHostName() : null;\r\n        }\r\n        return null;\r\n    }\r\n```', 'commenter': 'RongtongJin'}]"
1985,broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java,"@@ -285,7 +273,19 @@ private synchronized RemotingCommand updateAndCreateTopic(ChannelHandlerContext
 
         this.brokerController.registerIncrementBrokerData(topicConfig, this.brokerController.getTopicConfigManager().getDataVersion());
 
-        return null;
+        response.setCode(ResponseCode.SUCCESS);
+        return response;
+    }
+
+    private boolean isSystemTopic(RemotingCommand response, String topic) {
+        if (this.brokerController.getTopicConfigManager().isSystemTopic(topic)) {
+            String errorMsg = ""the topic["" + topic + ""] is conflict with system reserved words."";
+            log.warn(errorMsg);","[{'comment': 'You can combine two code into one and use placeholder like `log.warn(""xxxxxxx { } xxxx"", topic)`', 'commenter': 'RongtongJin'}, {'comment': ""errorMsg used in log and response's remark, so it is better to use a local var to store it"", 'commenter': 'coder-zzzz'}, {'comment': ""> errorMsg used in log and response's remark, so it is better to use a local var to store it\r\n\r\nYou are right"", 'commenter': 'RongtongJin'}]"
1985,broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java,"@@ -252,29 +253,16 @@ private synchronized RemotingCommand updateAndCreateTopic(ChannelHandlerContext
             (CreateTopicRequestHeader) request.decodeCommandCustomHeader(CreateTopicRequestHeader.class);
         log.info(""updateAndCreateTopic called by {}"", RemotingHelper.parseChannelRemoteAddr(ctx.channel()));
 
-        if (requestHeader.getTopic().equals(this.brokerController.getBrokerConfig().getBrokerClusterName())) {
-            String errorMsg = ""the topic["" + requestHeader.getTopic() + ""] is conflict with system reserved words."";","[{'comment': 'the -> The', 'commenter': 'duhenglucky'}, {'comment': 'ok', 'commenter': 'coder-zzzz'}]"
1985,broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java,"@@ -285,7 +273,19 @@ private synchronized RemotingCommand updateAndCreateTopic(ChannelHandlerContext
 
         this.brokerController.registerIncrementBrokerData(topicConfig, this.brokerController.getTopicConfigManager().getDataVersion());
 
-        return null;
+        response.setCode(ResponseCode.SUCCESS);
+        return response;
+    }
+
+    private boolean isSystemTopic(RemotingCommand response, String topic) {
+        if (this.brokerController.getTopicConfigManager().isSystemTopic(topic)) {","[{'comment': 'It would be better to integrate these two methods: org.apache.rocketmq.common.MixAll#isSystemTopic ', 'commenter': 'duhenglucky'}, {'comment': ""The MixAll#isSystemTopic is used in NamespaceUtil, but NamespaceUtil is use in both broker and client. Some topic can be mixed like AUTO_CREATE_TOPIC_KEY_TOPIC, but some can't, such as the topic of broker' clusterName.\r\nI try to use a new method in nameserver which offer the ability to judge if the topic will be created is system topic before this pr.But I found there always will be mistake when some broker register itself to nameserver after the judge request. \r\nSo I just promise broker itself will not create topics which it thought is system topic.\r\n\r\nDo u have any ideas to fix it?"", 'commenter': 'coder-zzzz'}]"
1985,broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java,"@@ -285,7 +273,19 @@ private synchronized RemotingCommand updateAndCreateTopic(ChannelHandlerContext
 
         this.brokerController.registerIncrementBrokerData(topicConfig, this.brokerController.getTopicConfigManager().getDataVersion());
 
-        return null;
+        response.setCode(ResponseCode.SUCCESS);
+        return response;
+    }
+
+    private boolean isSystemTopic(RemotingCommand response, String topic) {
+        if (this.brokerController.getTopicConfigManager().isSystemTopic(topic)) {
+            String errorMsg = ""The topic["" + topic + ""] is conflict with system reserved words."";","[{'comment': 'String errorMsg = ""The topic["" + topic + ""] is conflict with system reserved words."";\r\n\r\nThe reminder info(reserved words should update system topic )is not uniform with your modification. ', 'commenter': 'vongosling'}, {'comment': 'ok', 'commenter': 'coder-zzzz'}]"
1985,broker/src/main/java/org/apache/rocketmq/broker/topic/TopicConfigManager.java,"@@ -124,6 +124,14 @@ public TopicConfigManager(BrokerController brokerController) {
             topicConfig.setWriteQueueNums(1);
             this.topicConfigTable.put(topicConfig.getTopicName(), topicConfig);
         }
+        {
+            String topic = MixAll.SCHEDULE_TOPIC;
+            TopicConfig topicConfig = new TopicConfig(topic);","[{'comment': 'SCHEDULE_TOPIC is a special system topic? IMO, we should refactor this naming logic here.', 'commenter': 'vongosling'}, {'comment': 'Yeah, it is a special system topic used in delay msg. When producer send a delay  msg, the msg will be send to SCHEDULE_TOPIC, then send to the real topic when the delay time comes.\r\nDo u meaning  add prefix to system topic , or remove system topics to a independent class?', 'commenter': 'coder-zzzz'}, {'comment': 'system topic should be a List. Also, we could judge it from the naming, a prefix is a good way.', 'commenter': 'vongosling'}]"
1985,broker/src/main/java/org/apache/rocketmq/broker/topic/TopicConfigManager.java,"@@ -124,6 +124,14 @@ public TopicConfigManager(BrokerController brokerController) {
             topicConfig.setWriteQueueNums(1);
             this.topicConfigTable.put(topicConfig.getTopicName(), topicConfig);
         }
+        {
+            String topic = MixAll.SCHEDULE_TOPIC;
+            TopicConfig topicConfig = new TopicConfig(topic);
+            this.systemTopicList.add(topic);
+            topicConfig.setReadQueueNums(18);
+            topicConfig.setWriteQueueNums(18);","[{'comment': 'Should use static number while not a special number 18', 'commenter': 'vongosling'}, {'comment': 'I will do it.', 'commenter': 'coder-zzzz'}]"
1985,common/src/main/java/org/apache/rocketmq/common/MixAll.java,"@@ -56,6 +56,7 @@
     //http://jmenv.tbsite.net:8080/rocketmq/nsaddr
     //public static final String WS_ADDR = ""http://"" + WS_DOMAIN_NAME + "":8080/rocketmq/"" + WS_DOMAIN_SUBGROUP;
     public static final String AUTO_CREATE_TOPIC_KEY_TOPIC = ""TBW102""; // Will be created at broker when isAutoCreateTopicEnable
+    public static final String SCHEDULE_TOPIC = ""SCHEDULE_TOPIC_XXXX"";","[{'comment': 'MixAll class should not inflate continue. could you help to move the system topic related logic to a new class, such as TopicValidator or TopicChecker?', 'commenter': 'vongosling'}, {'comment': ""It's a good way to make code cleaner.I'will try my best to do it"", 'commenter': 'coder-zzzz'}]"
1985,store/src/main/java/org/apache/rocketmq/store/dledger/DLedgerCommitLog.java,"@@ -383,7 +384,7 @@ public PutMessageResult putMessage(final MessageExtBrokerInner msg) {
                     msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());
                 }
 
-                topic = ScheduleMessageService.SCHEDULE_TOPIC;
+                topic = MixAll.SCHEDULE_TOPIC;","[{'comment': ""I don't like to see many MixAll scatter in so many places:-)"", 'commenter': 'vongosling'}]"
1985,broker/src/main/java/org/apache/rocketmq/broker/processor/AbstractSendMessageProcessor.java,"@@ -173,6 +173,12 @@ protected RemotingCommand msgCheck(final ChannelHandlerContext ctx,
             return response;
         }
 
+        if (TopicValidator.RMQ_SYS_SCHEDULE_TOPIC.equals(requestHeader.getTopic())) {
+            response.setCode(ResponseCode.NO_PERMISSION);
+            response.setRemark(""sending message to topic["" + requestHeader.getTopic() + ""] is forbidden"");
+            return response;
+        }
+","[{'comment': 'Is this piece of code necessary? The following code will check system topic again.', 'commenter': 'RongtongJin'}]"
1985,common/src/main/java/org/apache/rocketmq/common/topic/TopicValidator.java,"@@ -57,13 +85,24 @@ public static boolean validateTopic(String topic, RemotingCommand response) {
             return false;
         }
 
-        //whether the same with system reserved keyword
-        if (topic.equals(MixAll.AUTO_CREATE_TOPIC_KEY_TOPIC)) {
+        if (isSystemTopic(topic)) {
             response.setCode(ResponseCode.SYSTEM_ERROR);
-            response.setRemark(""The specified topic is conflict with AUTO_CREATE_TOPIC_KEY_TOPIC."");
+            response.setRemark(""The topic["" + topic + ""] is conflict with system topic."");
             return false;
         }","[{'comment': '[Important] There is a serious problem. msgCheck call this method and check all system topics, this will cause the client to fail to send messages to **all system topics**, but it is necessary for the client to send messages to certain system topics, such as BenchmarkTest, OFFSET_MOVED_EVENT.  IMO, We need a blacklist to prohibit sending to certain system topics, but not all system topics.', 'commenter': 'RongtongJin'}, {'comment': 'This is really a deadly problem. Schedule Topic is the only one should prevent send by user,I’ll check the method TopicValidator#validateTopic everywhere invoked.', 'commenter': 'coder-zzzz'}]"
1985,broker/src/main/java/org/apache/rocketmq/broker/processor/AbstractSendMessageProcessor.java,"@@ -173,13 +173,10 @@ protected RemotingCommand msgCheck(final ChannelHandlerContext ctx,
             return response;
         }
 
-        if (TopicValidator.RMQ_SYS_SCHEDULE_TOPIC.equals(requestHeader.getTopic())) {
-            response.setCode(ResponseCode.NO_PERMISSION);
-            response.setRemark(""sending message to topic["" + requestHeader.getTopic() + ""] is forbidden"");
+        if (!TopicValidator.validateTopic(requestHeader.getTopic(), response)) {
             return response;
         }
-
-        if (!TopicValidator.validateTopic(requestHeader.getTopic(), response)) {
+        if (!TopicValidator.validateBlacklistTopic(requestHeader.getTopic(), response)) {","[{'comment': ""what is a blacklist? It's just not allowed to send a message to this topic. It would be better to name it notAllowedSending."", 'commenter': 'vongosling'}, {'comment': ""ok，I'll change it "", 'commenter': 'coder-zzzz'}]"
1985,broker/src/test/java/org/apache/rocketmq/broker/topic/TopicValidatorTest.java,"@@ -70,6 +64,62 @@ public void testAddSystemTopic() {
         assertThat(TopicValidator.getSystemTopicSet()).contains(topic);
     }
 
+    @Test
+    public void testValidateSystemTopic() {
+        RemotingCommand response = RemotingCommand.createResponseCommand(-1, """");
+
+        String topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;
+        Boolean res = TopicValidator.validateSystemTopic(topic, response);
+        assertThat(res).isFalse();
+        assertThat(response.getCode()).isEqualTo(ResponseCode.SYSTEM_ERROR);
+        assertThat(response.getRemark()).isEqualTo(""The topic["" + topic + ""] is conflict with system topic."");
+
+        topic = ""test_topic"";
+        res = TopicValidator.validateSystemTopic(topic, response);
+        assertThat(res).isTrue();
+    }
+
+    @Test
+    public void testValidateBlacklistTopic() {
+        RemotingCommand response = RemotingCommand.createResponseCommand(-1, """");
+
+        String topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;
+        Boolean res = TopicValidator.validateBlacklistTopic(topic, response);","[{'comment': 'it still needs to polish when you change your blacklist method in validator class.', 'commenter': 'vongosling'}]"
1985,broker/src/test/java/org/apache/rocketmq/broker/topic/TopicValidatorTest.java,"@@ -70,6 +64,62 @@ public void testAddSystemTopic() {
         assertThat(TopicValidator.getSystemTopicSet()).contains(topic);
     }
 
+    @Test
+    public void testValidateSystemTopic() {
+        RemotingCommand response = RemotingCommand.createResponseCommand(-1, """");
+
+        String topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;
+        Boolean res = TopicValidator.validateSystemTopic(topic, response);
+        assertThat(res).isFalse();
+        assertThat(response.getCode()).isEqualTo(ResponseCode.SYSTEM_ERROR);
+        assertThat(response.getRemark()).isEqualTo(""The topic["" + topic + ""] is conflict with system topic."");
+
+        topic = ""test_topic"";
+        res = TopicValidator.validateSystemTopic(topic, response);
+        assertThat(res).isTrue();
+    }
+
+    @Test
+    public void testValidateBlacklistTopic() {
+        RemotingCommand response = RemotingCommand.createResponseCommand(-1, """");
+
+        String topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;
+        Boolean res = TopicValidator.validateBlacklistTopic(topic, response);
+        assertThat(res).isFalse();
+        assertThat(response.getCode()).isEqualTo(ResponseCode.NO_PERMISSION);
+        assertThat(response.getRemark()).isEqualTo(""Sending message to topic["" + topic + ""] is forbidden."");
+
+        topic = ""test_topic"";
+        res = TopicValidator.validateBlacklistTopic(topic, response);
+        assertThat(res).isTrue();
+    }
+
+    @Test
+    public void testIsSystemTopic() {
+        String topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;
+        boolean res = TopicValidator.isSystemTopic(topic);
+        assertThat(res).isTrue();
+
+        topic = ""rmq_sys_test"";
+        res = TopicValidator.isSystemTopic(topic);
+        assertThat(res).isTrue();
+
+        topic = ""test_topic"";
+        res = TopicValidator.isSystemTopic(topic);
+        assertThat(res).isFalse();
+    }
+
+    @Test
+    public void testIsBlacklistTopic() {
+        String topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;","[{'comment': 'where is IsBlacklistTopic in here ', 'commenter': 'vongosling'}]"
1985,common/src/main/java/org/apache/rocketmq/common/topic/TopicValidator.java,"@@ -0,0 +1,131 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.common.topic;
+
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.protocol.ResponseCode;
+import org.apache.rocketmq.remoting.protocol.RemotingCommand;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class TopicValidator {
+
+    public static final String AUTO_CREATE_TOPIC_KEY_TOPIC = ""TBW102""; // Will be created at broker when isAutoCreateTopicEnable
+    public static final String RMQ_SYS_SCHEDULE_TOPIC = ""SCHEDULE_TOPIC_XXXX"";
+    public static final String RMQ_SYS_BENCHMARK_TOPIC = ""BenchmarkTest"";
+    public static final String RMQ_SYS_TRANS_HALF_TOPIC = ""RMQ_SYS_TRANS_HALF_TOPIC"";
+    public static final String RMQ_SYS_TRACE_TOPIC = ""RMQ_SYS_TRACE_TOPIC"";
+    public static final String RMQ_SYS_TRANS_OP_HALF_TOPIC = ""RMQ_SYS_TRANS_OP_HALF_TOPIC"";
+    public static final String RMQ_SYS_TRANS_CHECK_MAX_TIME_TOPIC = ""TRANS_CHECK_MAX_TIME_TOPIC"";
+    public static final String RMQ_SYS_SELF_TEST_TOPIC = ""SELF_TEST_TOPIC"";
+    public static final String RMQ_SYS_OFFSET_MOVED_EVENT = ""OFFSET_MOVED_EVENT"";
+
+    public static final String SYSTEM_TOPIC_PREFIX = ""rmq_sys_"";
+
+    private static final String VALID_PATTERN_STR = ""^[%|a-zA-Z0-9_-]+$"";
+    private static final Pattern PATTERN = Pattern.compile(VALID_PATTERN_STR);
+    private static final int TOPIC_MAX_LENGTH = 127;
+
+    private static final Set<String> SYSTEM_TOPIC_SET = new HashSet<String>();
+
+    /**
+     * Topics'set which client can not send msg!
+     */
+    private static final Set<String> CLIENT_BLACKLIST_TOPIC_SET = new HashSet<String>();
+
+    static {
+        SYSTEM_TOPIC_SET.add(AUTO_CREATE_TOPIC_KEY_TOPIC);
+        SYSTEM_TOPIC_SET.add(RMQ_SYS_SCHEDULE_TOPIC);
+        SYSTEM_TOPIC_SET.add(RMQ_SYS_BENCHMARK_TOPIC);
+        SYSTEM_TOPIC_SET.add(RMQ_SYS_TRANS_HALF_TOPIC);
+        SYSTEM_TOPIC_SET.add(RMQ_SYS_TRACE_TOPIC);
+        SYSTEM_TOPIC_SET.add(RMQ_SYS_TRANS_OP_HALF_TOPIC);
+        SYSTEM_TOPIC_SET.add(RMQ_SYS_TRANS_CHECK_MAX_TIME_TOPIC);
+        SYSTEM_TOPIC_SET.add(RMQ_SYS_SELF_TEST_TOPIC);
+        SYSTEM_TOPIC_SET.add(RMQ_SYS_OFFSET_MOVED_EVENT);
+
+        CLIENT_BLACKLIST_TOPIC_SET.add(RMQ_SYS_SCHEDULE_TOPIC);
+    }
+
+    private static boolean regularExpressionMatcher(String origin, Pattern pattern) {
+        if (pattern == null) {
+            return true;
+        }
+        Matcher matcher = pattern.matcher(origin);
+        return matcher.matches();
+    }
+
+    public static boolean validateTopic(String topic, RemotingCommand response) {
+
+        if (UtilAll.isBlank(topic)) {
+            response.setCode(ResponseCode.SYSTEM_ERROR);
+            response.setRemark(""The specified topic is blank."");
+            return false;
+        }
+
+        if (!regularExpressionMatcher(topic, PATTERN)) {
+            response.setCode(ResponseCode.SYSTEM_ERROR);
+            response.setRemark(""The specified topic contains illegal characters, allowing only "" + VALID_PATTERN_STR);
+            return false;
+        }
+
+        if (topic.length() > TOPIC_MAX_LENGTH) {
+            response.setCode(ResponseCode.SYSTEM_ERROR);
+            response.setRemark(""The specified topic is longer than topic max length."");
+            return false;
+        }
+
+        return true;
+    }
+
+    public static boolean validateSystemTopic(String topic, RemotingCommand response) {
+        if (isSystemTopic(topic)) {
+            response.setCode(ResponseCode.SYSTEM_ERROR);
+            response.setRemark(""The topic["" + topic + ""] is conflict with system topic."");
+            return false;
+        }
+        return true;
+    }
+
+    public static boolean isSystemTopic(String topic) {
+        return SYSTEM_TOPIC_SET.contains(topic) || topic.startsWith(SYSTEM_TOPIC_PREFIX);
+    }
+
+    public static boolean isBlacklistTopic(String topic) {
+        return CLIENT_BLACKLIST_TOPIC_SET.contains(topic);
+    }
+
+    public static boolean validateBlacklistTopic(String topic, RemotingCommand response) {
+        if (isBlacklistTopic(topic)) {
+            response.setCode(ResponseCode.NO_PERMISSION);
+            response.setRemark(""Sending message to topic["" + topic + ""] is forbidden."");
+            return false;
+        }
+        return true;","[{'comment': 'It would be better to reconsider the naming of these methods. The difference between `validateSystemTopic` and `isSystemTopic` are quite confusing, same for  `isBlacklistTopic` and `validateBlacklistTopic`. For example, when a topic is system topic, but validateSystemTopic return false.', 'commenter': 'RongtongJin'}]"
2059,client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultLitePullConsumerImpl.java,"@@ -691,7 +691,7 @@ public void run() {
 
                 ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);
 
-                if (processQueue == null && processQueue.isDropped()) {
+                if (processQueue != null && processQueue.isDropped()) {","[{'comment': 'assignedMessageQueue.getProcessQueue(messageQueue) may return null. So it is necessary to check if processQueue is null to prevent NPE', 'commenter': 'RongtongJin'}, {'comment': 'ok,i check both with (processQueue is null) or (processQueue not null and isDropped)', 'commenter': 'lebron374'}]"
2059,client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultLitePullConsumerImpl.java,"@@ -691,7 +691,7 @@ public void run() {
 
                 ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);
 
-                if (processQueue == null && processQueue.isDropped()) {
+                if ((null == processQueue) || (processQueue != null && processQueue.isDropped())) {","[{'comment': 'why not just write as `if (processQueue == null || processQueue.isDropped())` ? This is more concise', 'commenter': 'RongtongJin'}, {'comment': 'ok,i change as you say', 'commenter': 'lebron374'}]"
2059,client/src/test/java/org/apache/rocketmq/client/consumer/DefaultLitePullConsumerTest.java,"@@ -304,6 +304,29 @@ public void testPauseAndResume_Success() throws Exception {
         }
     }
 
+    @Test
+    public void testPullTaskImpl_ProcessQueueDropped() throws Exception {
+        DefaultLitePullConsumer litePullConsumer = createNotStartLitePullConsumer();
+        try {
+            MessageQueue messageQueue = createMessageQueue();
+            litePullConsumer.assign(Collections.singletonList(messageQueue));
+            Field field = DefaultLitePullConsumer.class.getDeclaredField(""defaultLitePullConsumerImpl"");
+            field.setAccessible(true);
+            // set ProcessQueue dropped = true
+            DefaultLitePullConsumerImpl localLitePullConsumerImpl = (DefaultLitePullConsumerImpl) field.get(litePullConsumer);
+            field = DefaultLitePullConsumerImpl.class.getDeclaredField(""assignedMessageQueue"");
+            field.setAccessible(true);","[{'comment': 'powermock provide mock private method. you could use it to test null case and dropped case separately', 'commenter': 'vongosling'}, {'comment': '> powermock provide mock private method. you could use it to test null case and dropped case separately\r\n\r\ni just add testPullTaskImpl_ProcessQueueNull', 'commenter': 'lebron374'}, {'comment': ""Thanks, it's all right here."", 'commenter': 'vongosling'}]"
2213,remoting/src/main/java/org/apache/rocketmq/remoting/protocol/RemotingCommand.java,"@@ -61,10 +61,13 @@
     static {
         final String protocol = System.getProperty(SERIALIZE_TYPE_PROPERTY, System.getenv(SERIALIZE_TYPE_ENV));
         if (!isBlank(protocol)) {
+            byte protocolByte = -1;
             try {
-                serializeTypeConfigInThisServer = SerializeType.valueOf(protocol);
+                protocolByte = (byte) Integer.parseInt(protocol);
+                System.out.println(protocolByte);","[{'comment': 'IMO, we should delete these two codes.', 'commenter': 'RongtongJin'}, {'comment': 'The method SerializeType.valueOf() need a byte type parameter.It will get a wrong result when we put a String type parameter.', 'commenter': 'fantow'}, {'comment': 'You are right , just delete `System.out.println(protocolByte);`.', 'commenter': 'RongtongJin'}]"
2213,remoting/src/main/java/org/apache/rocketmq/remoting/protocol/RemotingCommand.java,"@@ -61,10 +61,13 @@
     static {
         final String protocol = System.getProperty(SERIALIZE_TYPE_PROPERTY, System.getenv(SERIALIZE_TYPE_ENV));
         if (!isBlank(protocol)) {
+            byte protocolByte = -1;
             try {
-                serializeTypeConfigInThisServer = SerializeType.valueOf(protocol);
+                protocolByte = (byte) Integer.parseInt(protocol);
+                System.out.println(protocolByte);
+                serializeTypeConfigInThisServer = SerializeType.valueOf(protocolByte);
             } catch (IllegalArgumentException e) {
-                throw new RuntimeException(""parser specified protocol error. protocol="" + protocol, e);
+                throw new RuntimeException(""parser specified protocol error. protocol="" + serializeTypeConfigInThisServer, e);
             }","[{'comment': 'IMO, No need to catch the runtime exception and rethrow it', 'commenter': 'RongtongJin'}, {'comment': 'Okay,I will fix it.', 'commenter': 'fantow'}]"
2213,remoting/src/test/java/org/apache/rocketmq/remoting/protocol/SerializeTypeTest.java,"@@ -0,0 +1,22 @@
+package org.apache.rocketmq.remoting.protocol;","[{'comment': 'Missing ASF license header', 'commenter': 'RongtongJin'}, {'comment': 'Thx,I have fixed it.', 'commenter': 'fantow'}]"
2213,remoting/src/main/java/org/apache/rocketmq/remoting/protocol/RemotingCommand.java,"@@ -61,10 +63,12 @@
     static {
         final String protocol = System.getProperty(SERIALIZE_TYPE_PROPERTY, System.getenv(SERIALIZE_TYPE_ENV));
         if (!isBlank(protocol)) {
+            byte protocolByte = -1;
             try {
-                serializeTypeConfigInThisServer = SerializeType.valueOf(protocol);
+                protocolByte = (byte) Integer.parseInt(protocol);
+                serializeTypeConfigInThisServer = SerializeType.valueOf(protocolByte);
             } catch (IllegalArgumentException e) {
-                throw new RuntimeException(""parser specified protocol error. protocol="" + protocol, e);
+                e.printStackTrace();
             }","[{'comment': 'IMO, no need to catch Runtime exception.', 'commenter': 'RongtongJin'}]"
2465,docs/en/best_practice.md,"@@ -1,6 +1,68 @@
 #  Best practices
 
 ## 1 Producer
+### 1.1 Attention of send message","[{'comment': 'I really appreciate your attention to help finish the english copies of the user manual. Would you like to make another pr to these parts? Let pr solve only one issue.', 'commenter': 'vongosling'}, {'comment': 'ok， I‘ll create another issue', 'commenter': 'coder-zzzz'}]"
2719,client/src/main/java/org/apache/rocketmq/client/consumer/store/RemoteBrokerOffsetStore.java,"@@ -97,6 +97,11 @@ public long readOffset(final MessageQueue mq, final ReadOffsetType type) {
                     catch (MQBrokerException e) {
                         return -1;
                     }
+                    //remotingException, should retry
+                    catch (RemotingException e) {
+                      log.warn(""fetchConsumeOffsetFromBroker RemotingException, "" + mq, e);
+                      return -3;","[{'comment': ""Define a meaningful constant, instead of the magic number '-3'"", 'commenter': 'caigy'}]"
2719,client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultMQPushConsumerImpl.java,"@@ -271,6 +271,10 @@ public void pullMessage(final PullRequest pullRequest) {
             if (processQueue.isLocked()) {
                 if (!pullRequest.isLockedFirst()) {
                     final long offset = this.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());","[{'comment': 'Please resolve conflicts with master.', 'commenter': 'caigy'}]"
2719,client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultMQPushConsumerImpl.java,"@@ -271,6 +271,10 @@ public void pullMessage(final PullRequest pullRequest) {
             if (processQueue.isLocked()) {
                 if (!pullRequest.isLockedFirst()) {
                     final long offset = this.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());
+                    if (offset == -3) {","[{'comment': ""Also use constant instead of '-3' here."", 'commenter': 'caigy'}]"
2719,client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultMQPushConsumerImpl.java,"@@ -271,6 +271,10 @@ public void pullMessage(final PullRequest pullRequest) {
             if (processQueue.isLocked()) {
                 if (!pullRequest.isLockedFirst()) {
                     final long offset = this.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());
+                    if (offset == -3) {
+                      this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);
+                      log.info(""pull message later because remoting exception with broker, {}"", pullRequest);
+                    }","[{'comment': 'Should the procedure just return here?', 'commenter': 'caigy'}]"
2757,pom.xml,"@@ -571,6 +571,11 @@
                 <artifactId>guava</artifactId>
                 <version>19.0</version>
             </dependency>
+            <dependency>
+                <groupId>com.googlecode.concurrentlinkedhashmap</groupId>","[{'comment': ""Do not introduce this older(2015) dependency, you could check guava's MapMaker or CacheBuilder. Or, use Caffeine."", 'commenter': 'vongosling'}]"
2757,broker/src/main/java/org/apache/rocketmq/broker/loadbalance/AssignmentManager.java,"@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.broker.loadbalance;
+
+import com.google.common.collect.Lists;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+import org.apache.rocketmq.broker.BrokerController;
+import org.apache.rocketmq.broker.out.BrokerOuterAPI;
+import org.apache.rocketmq.client.exception.MQBrokerException;
+import org.apache.rocketmq.client.impl.factory.MQClientInstance;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.common.ThreadFactoryImpl;
+import org.apache.rocketmq.common.constant.LoggerName;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.common.protocol.ResponseCode;
+import org.apache.rocketmq.common.protocol.route.TopicRouteData;
+import org.apache.rocketmq.common.topic.TopicValidator;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.logging.InternalLoggerFactory;
+
+
+public class AssignmentManager {
+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);
+
+    private transient BrokerController brokerController;
+
+    private final static long LOCK_TIMEOUT_MILLIS = 3000;
+
+    private final Lock lockNamesrv = new ReentrantLock();
+
+    private final BrokerOuterAPI mQClientAPIImpl;
+
+    private final ConcurrentHashMap<String, Set<MessageQueue>> topicSubscribeInfoTable = new ConcurrentHashMap<String, Set<MessageQueue>>();
+
+    private ScheduledExecutorService scheduledExecutorService = Executors
+        .newSingleThreadScheduledExecutor(new ThreadFactoryImpl(""LoadBalanceManagerScheduledThread""));
+
+    private static final List<String> IGNORE_ROUTE_TOPICS = Lists.newArrayList(
+        TopicValidator.SYSTEM_TOPIC_PREFIX,
+        MixAll.CID_RMQ_SYS_PREFIX,
+        MixAll.DEFAULT_CONSUMER_GROUP,
+        MixAll.TOOLS_CONSUMER_GROUP,
+        MixAll.FILTERSRV_CONSUMER_GROUP,
+        MixAll.MONITOR_CONSUMER_GROUP,
+        MixAll.ONS_HTTP_PROXY_GROUP,","[{'comment': 'ONS?', 'commenter': 'vongosling'}, {'comment': 'This constant is introduced in this commit 66ca327aa3badadc8edabbcd6440f7633fd53e1d \r\nI just ref this one like other places.', 'commenter': 'ayanamist'}, {'comment': 'I could not find any MixAll.ONS* in your link. Am I missing something?', 'commenter': 'vongosling'}, {'comment': ""Because it's a large commit, and Github collapse them by default.\r\nYou should first find MixAll.java file, then click Load diff link, then you will find what i said.\r\nBTW there are many other ONS stuff constants there and being refered by other codes, i think if you care about them, another separate commit is preferred."", 'commenter': 'ayanamist'}, {'comment': 'emmm, got it, leave it to the next optimization. ', 'commenter': 'vongosling'}]"
2757,broker/src/main/java/org/apache/rocketmq/broker/longpolling/NotifyMessageArrivingListener.java,"@@ -17,21 +17,24 @@
 
 package org.apache.rocketmq.broker.longpolling;
 
-import org.apache.rocketmq.store.MessageArrivingListener;
-
 import java.util.Map;
+import org.apache.rocketmq.broker.processor.PopMessageProcessor;
+import org.apache.rocketmq.store.MessageArrivingListener;
 
 public class NotifyMessageArrivingListener implements MessageArrivingListener {
     private final PullRequestHoldService pullRequestHoldService;
+    private final PopMessageProcessor popMessageProcessor;
 
-    public NotifyMessageArrivingListener(final PullRequestHoldService pullRequestHoldService) {
+    public NotifyMessageArrivingListener(final PullRequestHoldService pullRequestHoldService, final PopMessageProcessor popMessageProcessor) {","[{'comment': 'what is pop semantic? Common Queue Operations do not include pop except the special dequeue. Such a name can be confusing. IMO, We should use some common names in the industry. such as poll/pull, peek, push, and so on.', 'commenter': 'vongosling'}]"
2757,broker/src/main/java/org/apache/rocketmq/broker/processor/PopReviveService.java,"@@ -0,0 +1,470 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.broker.processor;
+
+import com.alibaba.fastjson.JSON;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import org.apache.rocketmq.broker.BrokerController;
+import org.apache.rocketmq.broker.util.MsgUtil;
+import org.apache.rocketmq.client.consumer.PullResult;
+import org.apache.rocketmq.client.consumer.PullStatus;
+import org.apache.rocketmq.common.KeyBuilder;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.common.PopAckConstants;
+import org.apache.rocketmq.common.ServiceThread;
+import org.apache.rocketmq.common.TopicConfig;
+import org.apache.rocketmq.common.TopicFilterType;
+import org.apache.rocketmq.common.constant.LoggerName;
+import org.apache.rocketmq.common.message.MessageAccessor;
+import org.apache.rocketmq.common.message.MessageConst;
+import org.apache.rocketmq.common.message.MessageDecoder;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.utils.DataConverter;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.logging.InternalLoggerFactory;
+import org.apache.rocketmq.store.AppendMessageStatus;
+import org.apache.rocketmq.store.GetMessageResult;
+import org.apache.rocketmq.store.MessageExtBrokerInner;
+import org.apache.rocketmq.store.PutMessageResult;
+import org.apache.rocketmq.store.config.BrokerRole;
+import org.apache.rocketmq.store.pop.AckMsg;
+import org.apache.rocketmq.store.pop.PopCheckPoint;
+
+public class PopReviveService extends ServiceThread {
+    private static final InternalLogger POP_LOGGER = InternalLoggerFactory.getLogger(LoggerName.ROCKETMQ_POP_LOGGER_NAME);
+
+    private int queueId;
+    private BrokerController brokerController;
+    private String reviveTopic;
+    private static volatile boolean isMaster = false;
+
+    public PopReviveService(int queueId, BrokerController brokerController, String reviveTopic) {
+        super();
+        this.queueId = queueId;
+        this.brokerController = brokerController;
+        this.reviveTopic = reviveTopic;
+    }
+
+    @Override
+    public String getServiceName() {
+        return ""PopReviveService_"" + this.queueId;
+    }
+
+    private boolean checkMaster() {
+        return brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;
+    }
+
+    private boolean checkAndSetMaster() {
+        isMaster = checkMaster();
+        return isMaster;
+    }
+
+    private void reviveRetry(PopCheckPoint popCheckPoint, MessageExt messageExt) throws Exception {
+        if (!checkAndSetMaster()) {
+            POP_LOGGER.info(""slave skip retry , revive topic={}, reviveQueueId={}"", reviveTopic, queueId);
+            return;
+        }
+        MessageExtBrokerInner msgInner = new MessageExtBrokerInner();
+        if (!popCheckPoint.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
+            msgInner.setTopic(KeyBuilder.buildPopRetryTopic(popCheckPoint.getTopic(), popCheckPoint.getCId()));
+        } else {
+            msgInner.setTopic(popCheckPoint.getTopic());
+        }
+        msgInner.setBody(messageExt.getBody());
+        msgInner.setQueueId(0);
+        if (messageExt.getTags() != null) {
+            msgInner.setTags(messageExt.getTags());
+        } else {
+            MessageAccessor.setProperties(msgInner, new HashMap<String, String>());
+        }
+        msgInner.setBornTimestamp(messageExt.getBornTimestamp());
+        msgInner.setBornHost(brokerController.getStoreHost());
+        msgInner.setStoreHost(brokerController.getStoreHost());
+        msgInner.setReconsumeTimes(messageExt.getReconsumeTimes() + 1);
+        msgInner.getProperties().putAll(messageExt.getProperties());
+        if (messageExt.getReconsumeTimes() == 0 || msgInner.getProperties().get(MessageConst.PROPERTY_FIRST_POP_TIME) == null) {
+            msgInner.getProperties().put(MessageConst.PROPERTY_FIRST_POP_TIME, String.valueOf(popCheckPoint.getPopTime()));
+        }
+        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));
+        addRetryTopicIfNoExit(msgInner.getTopic(), popCheckPoint.getCId());
+        PutMessageResult putMessageResult = brokerController.getMessageStore().putMessage(msgInner);
+        if (brokerController.getBrokerConfig().isEnablePopLog()) {
+            POP_LOGGER.info(""reviveQueueId={},retry msg , ck={}, msg queueId {}, offset {}, reviveDelay={}, result is {} "",
+                    queueId, popCheckPoint, messageExt.getQueueId(), messageExt.getQueueOffset(),
+                    (System.currentTimeMillis() - popCheckPoint.getReviveTime()) / 1000, putMessageResult);
+        }
+        if (putMessageResult.getAppendMessageResult() == null || putMessageResult.getAppendMessageResult().getStatus() != AppendMessageStatus.PUT_OK) {
+            throw new Exception(""reviveQueueId="" + queueId + "",revive error ,msg is :"" + msgInner);
+        }
+        this.brokerController.getBrokerStatsManager().incBrokerPutNums(1);
+        this.brokerController.getBrokerStatsManager().incTopicPutNums(msgInner.getTopic());
+        this.brokerController.getBrokerStatsManager().incTopicPutSize(msgInner.getTopic(), putMessageResult.getAppendMessageResult().getWroteBytes());
+        if (brokerController.getPopMessageProcessor() != null) {
+            brokerController.getPopMessageProcessor().notifyMessageArriving(
+                    KeyBuilder.parseNormalTopic(popCheckPoint.getTopic(), popCheckPoint.getCId()),
+                    popCheckPoint.getCId(),
+                    -1
+            );
+        }
+    }
+
+    private void initPopRetryOffset(String topic, String consumerGroup) {
+        long offset = this.brokerController.getConsumerOffsetManager().queryOffset(consumerGroup, topic, 0);
+        if (offset < 0) {
+            this.brokerController.getConsumerOffsetManager().commitOffset(""initPopRetryOffset"", consumerGroup, topic,
+                0, 0);
+        }
+    }
+
+    private void addRetryTopicIfNoExit(String topic, String consumerGroup) {
+        TopicConfig topicConfig = brokerController.getTopicConfigManager().selectTopicConfig(topic);
+        if (topicConfig != null) {
+            return;
+        }
+        topicConfig = new TopicConfig(topic);
+        topicConfig.setReadQueueNums(PopAckConstants.retryQueueNum);
+        topicConfig.setWriteQueueNums(PopAckConstants.retryQueueNum);
+        topicConfig.setTopicFilterType(TopicFilterType.SINGLE_TAG);
+        topicConfig.setPerm(6);
+        topicConfig.setTopicSysFlag(0);
+        brokerController.getTopicConfigManager().updateTopicConfig(topicConfig);
+
+        initPopRetryOffset(topic, consumerGroup);
+    }
+
+    private List<MessageExt> getReviveMessage(long offset, int queueId) {
+        PullResult pullResult = getMessage(PopAckConstants.REVIVE_GROUP, reviveTopic, queueId, offset, 32);
+        if (pullResult == null) {
+            return null;
+        }
+        if (reachTail(pullResult, offset)) {
+            POP_LOGGER.info(""reviveQueueId={}, reach tail,offset {}"", queueId, offset);
+        } else if (pullResult.getPullStatus() == PullStatus.OFFSET_ILLEGAL || pullResult.getPullStatus() == PullStatus.NO_MATCHED_MSG) {
+            POP_LOGGER.error(""reviveQueueId={}, OFFSET_ILLEGAL {}, result is {}"", queueId, offset, pullResult);
+            if (!checkAndSetMaster()) {
+                POP_LOGGER.info(""slave skip offset correct topic={}, reviveQueueId={}"", reviveTopic, queueId);
+                return null;
+            }
+            brokerController.getConsumerOffsetManager().commitOffset(PopAckConstants.LOCAL_HOST, PopAckConstants.REVIVE_GROUP, reviveTopic, queueId, pullResult.getNextBeginOffset() - 1);
+        }
+        return pullResult.getMsgFoundList();
+    }
+
+    private boolean reachTail(PullResult pullResult, long offset) {
+        return pullResult.getPullStatus() == PullStatus.NO_NEW_MSG
+                || (pullResult.getPullStatus() == PullStatus.OFFSET_ILLEGAL && offset == pullResult.getMaxOffset());
+    }
+
+    private MessageExt getBizMessage(String topic, long offset, int queueId) {
+        final GetMessageResult getMessageTmpResult = brokerController.getMessageStore().getMessage(PopAckConstants.REVIVE_GROUP, topic, queueId, offset, 1, null);
+        List<MessageExt> list = decodeMsgList(getMessageTmpResult);
+        if (list == null || list.isEmpty()) {
+            POP_LOGGER.warn(""can not get msg , topic {}, offset {}, queueId {}, result is {}"", topic, offset, queueId, getMessageTmpResult);
+            return null;
+        } else {
+            return list.get(0);
+        }
+    }
+
+    public PullResult getMessage(String group, String topic, int queueId, long offset, int nums) {
+        GetMessageResult getMessageResult = brokerController.getMessageStore().getMessage(group, topic, queueId, offset, nums, null);
+
+        if (getMessageResult != null) {
+            PullStatus pullStatus = PullStatus.NO_NEW_MSG;
+            List<MessageExt> foundList = null;
+            switch (getMessageResult.getStatus()) {
+                case FOUND:
+                    pullStatus = PullStatus.FOUND;
+                    foundList = decodeMsgList(getMessageResult);
+                    brokerController.getBrokerStatsManager().incGroupGetNums(group, topic, getMessageResult.getMessageCount());
+                    brokerController.getBrokerStatsManager().incGroupGetSize(group, topic, getMessageResult.getBufferTotalSize());
+                    brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount());
+                    brokerController.getBrokerStatsManager().recordDiskFallBehindTime(group, topic, queueId,
+                            brokerController.getMessageStore().now() - foundList.get(foundList.size() - 1).getStoreTimestamp());
+                    break;
+                case NO_MATCHED_MESSAGE:
+                    pullStatus = PullStatus.NO_MATCHED_MSG;
+                    POP_LOGGER.warn(""no matched message. GetMessageStatus={}, topic={}, groupId={}, requestOffset={}"",
+                            getMessageResult.getStatus(), topic, group, offset);
+                    break;
+                case NO_MESSAGE_IN_QUEUE:
+                    pullStatus = PullStatus.NO_NEW_MSG;
+                    POP_LOGGER.warn(""no new message. GetMessageStatus={}, topic={}, groupId={}, requestOffset={}"",
+                            getMessageResult.getStatus(), topic, group, offset);
+                    break;
+                case MESSAGE_WAS_REMOVING:
+                case NO_MATCHED_LOGIC_QUEUE:
+                case OFFSET_FOUND_NULL:
+                case OFFSET_OVERFLOW_BADLY:
+                case OFFSET_OVERFLOW_ONE:
+                case OFFSET_TOO_SMALL:
+                    pullStatus = PullStatus.OFFSET_ILLEGAL;
+                    POP_LOGGER.warn(""offset illegal. GetMessageStatus={}, topic={}, groupId={}, requestOffset={}"",
+                            getMessageResult.getStatus(), topic, group, offset);
+                    break;
+                default:
+                    assert false;
+                    break;
+            }
+
+            return new PullResult(pullStatus, getMessageResult.getNextBeginOffset(), getMessageResult.getMinOffset(),
+                    getMessageResult.getMaxOffset(), foundList);
+
+        } else {
+            POP_LOGGER.error(""get message from store return null. topic={}, groupId={}, requestOffset={}"", topic, group, offset);
+            return null;
+        }
+    }
+
+    private List<MessageExt> decodeMsgList(GetMessageResult getMessageResult) {
+        List<MessageExt> foundList = new ArrayList<>();
+        try {
+            List<ByteBuffer> messageBufferList = getMessageResult.getMessageBufferList();
+            if (messageBufferList != null) {
+                for (int i = 0; i < messageBufferList.size(); i++) {
+                    ByteBuffer bb = messageBufferList.get(i);
+                    if (bb == null) {
+                        POP_LOGGER.error(""bb is null {}"", getMessageResult);
+                        continue;
+                    }
+                    MessageExt msgExt = MessageDecoder.decode(bb);
+                    if (msgExt == null) {
+                        POP_LOGGER.error(""decode msgExt is null {}"", getMessageResult);
+                        continue;
+                    }
+                    // use CQ offset, not offset in Message
+                    msgExt.setQueueOffset(getMessageResult.getMessageQueueOffset().get(i));
+                    foundList.add(msgExt);
+                }
+            }
+        } finally {
+            getMessageResult.release();
+        }
+
+        return foundList;
+    }
+
+    private void consumeReviveMessage(ConsumeReviveObj consumeReviveObj) {
+        HashMap<String, PopCheckPoint> map = consumeReviveObj.map;
+        long startScanTime = System.currentTimeMillis();
+        long endTime = 0;
+        long oldOffset = brokerController.getConsumerOffsetManager().queryOffset(PopAckConstants.REVIVE_GROUP, reviveTopic, queueId);
+        consumeReviveObj.oldOffset = oldOffset;
+        POP_LOGGER.info(""reviveQueueId={}, old offset is {} "", queueId, oldOffset);
+        long offset = oldOffset + 1;
+        long firstRt = 0;
+        // offset self amend
+        while (true) {
+            if (!checkAndSetMaster()) {
+                POP_LOGGER.info(""slave skip scan , revive topic={}, reviveQueueId={}"", reviveTopic, queueId);
+                break;
+            }
+            List<MessageExt> messageExts = getReviveMessage(offset, queueId);
+            if (messageExts == null || messageExts.isEmpty()) {
+                break;
+            }
+            if (System.currentTimeMillis() - startScanTime > brokerController.getBrokerConfig().getReviveScanTime()) {
+                POP_LOGGER.info(""reviveQueueId={}, scan timeout  "", queueId);
+                break;
+            }
+            for (MessageExt messageExt : messageExts) {
+                if (PopAckConstants.CK_TAG.equals(messageExt.getTags())) {
+                    String raw = new String(messageExt.getBody(), DataConverter.charset);
+                    if (brokerController.getBrokerConfig().isEnablePopLog()) {
+                        POP_LOGGER.info(""reviveQueueId={},find ck, offset:{}, raw : {}"", messageExt.getQueueId(), messageExt.getQueueOffset(), raw);
+                    }
+                    PopCheckPoint point = JSON.parseObject(raw, PopCheckPoint.class);
+                    if (point.getTopic() == null || point.getCId() == null) {
+                        continue;
+                    }
+                    map.put(point.getTopic() + point.getCId() + point.getQueueId() + point.getStartOffset() + point.getPopTime(), point);
+                    point.setReviveOffset(messageExt.getQueueOffset());
+                    if (firstRt == 0) {
+                        firstRt = point.getReviveTime();
+                    }
+                } else if (PopAckConstants.ACK_TAG.equals(messageExt.getTags())) {
+                    String raw = new String(messageExt.getBody(), DataConverter.charset);
+                    if (brokerController.getBrokerConfig().isEnablePopLog()) {
+                        POP_LOGGER.info(""reviveQueueId={},find ack, offset:{}, raw : {}"", messageExt.getQueueId(), messageExt.getQueueOffset(), raw);
+                    }
+                    AckMsg ackMsg = JSON.parseObject(raw, AckMsg.class);
+                    PopCheckPoint point = map.get(ackMsg.getTopic() + ackMsg.getConsumerGroup() + ackMsg.getQueueId() + ackMsg.getStartOffset() + ackMsg.getPopTime());
+                    if (point == null) {
+                        continue;
+                    }
+                    int indexOfAck = point.indexOfAck(ackMsg.getAckOffset());
+                    if (indexOfAck > -1) {
+                        point.setBitMap(DataConverter.setBit(point.getBitMap(), indexOfAck, true));
+                    } else {
+                        POP_LOGGER.error(""invalid ack index, {}, {}"", ackMsg, point);
+                    }
+                }
+                long deliverTime = MsgUtil.getMessageDeliverTime(this.brokerController, messageExt);
+                if (deliverTime > endTime) {
+                    endTime = deliverTime;
+                }
+            }
+            offset = offset + messageExts.size();
+        }
+        consumeReviveObj.endTime = endTime;
+    }
+
+    private void mergeAndRevive(ConsumeReviveObj consumeReviveObj) throws Throwable {
+        ArrayList<PopCheckPoint> sortList = consumeReviveObj.genSortList();
+        POP_LOGGER.info(""reviveQueueId={},ck listSize={}"", queueId, sortList.size());
+        if (sortList.size() != 0) {
+            POP_LOGGER.info(""reviveQueueId={}, 1st ck, startOffset={}, reviveOffset={} ; last ck, startOffset={}, reviveOffset={}"", queueId, sortList.get(0).getStartOffset(),
+                    sortList.get(0).getReviveOffset(), sortList.get(sortList.size() - 1).getStartOffset(), sortList.get(sortList.size() - 1).getReviveOffset());
+        }
+        long newOffset = consumeReviveObj.oldOffset;
+        for (PopCheckPoint popCheckPoint : sortList) {
+            if (!checkAndSetMaster()) {
+                POP_LOGGER.info(""slave skip ck process , revive topic={}, reviveQueueId={}"", reviveTopic, queueId);
+                break;
+            }
+            if (consumeReviveObj.endTime - popCheckPoint.getReviveTime() <= (PopAckConstants.ackTimeInterval + PopAckConstants.SECOND)) {
+                break;
+            }
+
+            // check normal topic, skip ck , if normal topic is not exist
+            String normalTopic = KeyBuilder.parseNormalTopic(popCheckPoint.getTopic(), popCheckPoint.getCId());
+            if (brokerController.getTopicConfigManager().selectTopicConfig(normalTopic) == null) {
+                POP_LOGGER.warn(""reviveQueueId={},can not get normal topic {} , then continue "", queueId, popCheckPoint.getTopic());
+                newOffset = popCheckPoint.getReviveOffset();
+                continue;
+            }
+            if (null == brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(popCheckPoint.getCId())) {
+                POP_LOGGER.warn(""reviveQueueId={},can not get cid {} , then continue "", queueId, popCheckPoint.getCId());
+                newOffset = popCheckPoint.getReviveOffset();
+                continue;
+            }
+
+            reviveMsgFromCk(popCheckPoint);
+
+            newOffset = popCheckPoint.getReviveOffset();
+        }
+        if (newOffset > consumeReviveObj.oldOffset) {
+            if (!checkAndSetMaster()) {
+                POP_LOGGER.info(""slave skip commit, revive topic={}, reviveQueueId={}"", reviveTopic, queueId);
+                return;
+            }
+            brokerController.getConsumerOffsetManager().commitOffset(PopAckConstants.LOCAL_HOST, PopAckConstants.REVIVE_GROUP, reviveTopic, queueId, newOffset);
+        }
+        consumeReviveObj.newOffset = newOffset;
+    }
+
+    private void reviveMsgFromCk(PopCheckPoint popCheckPoint) throws Throwable {
+        for (int j = 0; j < popCheckPoint.getNum(); j++) {","[{'comment': ""I'm reading pop consuming code recently, and confused about **retry message** handle.\r\nhow to handle retry ck message? I could not find ack message of RETRY topic.\r\n@ayanamist can u help to reply? Thanks~"", 'commenter': 'maixiaohai'}, {'comment': '\r\n1、The pop mode consumes messages. For each message pulled by the client, the broker will save the CK message and wait for the ACK\r\n\r\n2、If the ACK message is not received in time due to client exceptions or timeout due to network reasons, popreviveservice will get the CK message from the receive topic and judge whether there is no ack after timeout. If there is no ack after timeout, the message will be put into the retry topic\r\n\r\n![image](https://user-images.githubusercontent.com/14222167/128729678-c5962d21-a0f5-4a5e-b388-70d0f5778b78.png)\r\n\r\n3、When the client pulls a message, it will probability pull a message from the retry topic\r\n![image](https://user-images.githubusercontent.com/14222167/128730163-14362248-0f33-472e-b299-a10e8ea61ad0.png)\r\n\r\n', 'commenter': 'odbozhou'}, {'comment': '@odbozhou Thanks for your quick reply~\r\n\r\nI could not find retry messages at consumer client side.\r\nAnd when popMessage response return, client will call `processPopResponse` method, and it will set the topic of retry message to real topic. \r\n<img width=""955"" alt=""截屏2021-08-10 上午12 32 34"" src=""https://user-images.githubusercontent.com/3734319/128742191-fda8317c-6d0b-4dcf-a819-5f84bec9a8d0.png"">\r\n\r\n<img width=""978"" alt=""截屏2021-08-10 上午12 38 24"" src=""https://user-images.githubusercontent.com/3734319/128742228-29db122e-6845-43de-884b-cd10f78b53a3.png"">\r\n', 'commenter': 'maixiaohai'}, {'comment': 'As mentioned in the second point above, the consumer pop method pulls the message, and probabilistically pulls the retry message from the broker. The consumer basically does not need to perceive whether the message is pulled from the retry queue or the message pulled from the real topic.', 'commenter': 'odbozhou'}, {'comment': 'I\'ve figured it out. When consumer call `ackAsync` method, the topic will be reset back through extraInfo.\r\n<img width=""829"" alt=""截屏2021-08-10 上午11 20 24"" src=""https://user-images.githubusercontent.com/3734319/128803533-b18ff729-5f04-44f2-b43f-94a86ce08ea0.png"">\r\n', 'commenter': 'maixiaohai'}]"
2876,distribution/benchmark/bproducer.sh,"@@ -0,0 +1,18 @@
+#!/bin/sh","[{'comment': 'Do we have any descriptions in one place? if not, I suggest you could rename it to batchproducer.sh', 'commenter': 'vongosling'}, {'comment': 'ok', 'commenter': 'Git-Yang'}]"
2934,namesrv/src/main/java/org/apache/rocketmq/namesrv/routeinfo/RouteInfoManager.java,"@@ -131,13 +127,7 @@ public RegisterBrokerResult registerBroker(
                 Map<Long, String> brokerAddrsMap = brokerData.getBrokerAddrs();
                 //Switch slave to master: first remove <1, IP:PORT> in namesrv, then add <0, IP:PORT>
                 //The same IP:PORT must only have one record in brokerAddrTable
-                Iterator<Entry<Long, String>> it = brokerAddrsMap.entrySet().iterator();
-                while (it.hasNext()) {
-                    Entry<Long, String> item = it.next();
-                    if (null != brokerAddr && brokerAddr.equals(item.getValue()) && brokerId != item.getKey()) {
-                        it.remove();
-                    }
-                }
+                brokerAddrsMap.entrySet().removeIf(item -> null != brokerAddr && brokerAddr.equals(item.getValue()) && brokerId != item.getKey());","[{'comment': 'I tried this way and it dose not remove the entry at all. maybe remove items in entrySet dont reflect to the map', 'commenter': 'yuz10'}, {'comment': 'Sorry, I made a mistake in my test. This way really works.', 'commenter': 'yuz10'}]"
2983,client/src/main/java/org/apache/rocketmq/client/impl/consumer/ConsumeMessageStagedConcurrentlyService.java,"@@ -0,0 +1,872 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.client.impl.consumer;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.collections.MapUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;
+import org.apache.rocketmq.client.consumer.listener.ConsumeReturnType;
+import org.apache.rocketmq.client.consumer.listener.ConsumeStagedConcurrentlyContext;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerStagedConcurrently;
+import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
+import org.apache.rocketmq.client.consumer.store.StageOffsetStore;
+import org.apache.rocketmq.client.hook.ConsumeMessageContext;
+import org.apache.rocketmq.client.log.ClientLogger;
+import org.apache.rocketmq.client.stat.ConsumerStatsManager;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.common.ThreadFactoryImpl;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.concurrent.PriorityConcurrentEngine;
+import org.apache.rocketmq.common.message.Message;
+import org.apache.rocketmq.common.message.MessageAccessor;
+import org.apache.rocketmq.common.message.MessageConst;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.common.protocol.NamespaceUtil;
+import org.apache.rocketmq.common.protocol.body.CMResult;
+import org.apache.rocketmq.common.protocol.body.ConsumeMessageDirectlyResult;
+import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
+import org.apache.rocketmq.common.utils.ThreadUtils;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.remoting.common.RemotingHelper;
+
+public class ConsumeMessageStagedConcurrentlyService implements ConsumeMessageService {
+    private static final String NULL = ""null"";
+    private static final InternalLogger log = ClientLogger.getLog();
+    private final static long MAX_TIME_CONSUME_CONTINUOUSLY =
+        Long.parseLong(System.getProperty(""rocketmq.client.maxTimeConsumeContinuously"", ""60000""));
+    private final DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;
+    private final DefaultMQPushConsumer defaultMQPushConsumer;
+    private final MessageListenerStagedConcurrently messageListener;
+    private final BlockingQueue<Runnable> consumeRequestQueue;
+    private final ThreadPoolExecutor dispatchExecutor;
+    private final ThreadPoolExecutor consumeExecutor;
+    private final PriorityConcurrentEngine engine;
+    private final String consumerGroup;
+    private final MessageQueueLock messageQueueLock = new MessageQueueLock();
+    private final ScheduledExecutorService scheduledExecutorService;
+    private volatile boolean stopped = false;
+    private final Map<String/*strategyId*/, List<Integer>/*StageDefinition*/> summedStageDefinitionMap;
+    private final ConcurrentMap<String/*topic*/, ConcurrentMap<String/*strategyId*/, ConcurrentMap<String/*groupId*/, AtomicInteger/*currentStageOffset*/>>> currentStageOffsetMap = new ConcurrentHashMap<>();
+    private final int pullBatchSize;
+    private final StageOffsetStore stageOffsetStore;
+
+    public ConsumeMessageStagedConcurrentlyService(DefaultMQPushConsumerImpl defaultMQPushConsumerImpl,
+        MessageListenerStagedConcurrently messageListener) {
+        this.defaultMQPushConsumerImpl = defaultMQPushConsumerImpl;
+        this.messageListener = messageListener;
+        this.summedStageDefinitionMap = new ConcurrentHashMap<>();
+        this.refreshStageDefinition();
+
+        this.stageOffsetStore = this.defaultMQPushConsumerImpl.getStageOffsetStore();
+
+        this.defaultMQPushConsumer = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer();
+        this.consumerGroup = this.defaultMQPushConsumer.getConsumerGroup();
+        this.pullBatchSize = this.defaultMQPushConsumer.getPullBatchSize();
+        this.consumeRequestQueue = new LinkedBlockingQueue<Runnable>();
+
+        int consumeThreadMin = this.defaultMQPushConsumer.getConsumeThreadMin();
+        int consumeThreadMax = this.defaultMQPushConsumer.getConsumeThreadMax();
+        this.dispatchExecutor = new ThreadPoolExecutor(
+            (int) Math.ceil(consumeThreadMin * 1.0 / this.pullBatchSize),
+            (int) Math.ceil(consumeThreadMax * 1.0 / this.pullBatchSize),
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            new LinkedBlockingQueue<Runnable>(),
+            new ThreadFactoryImpl(""DispatchMessageThread_""));
+        // when the number of threads is equal to
+        // the topic consumeQueue size multiplied by this.pullBatchSize,
+        // good performance can be obtained
+        this.consumeExecutor = new ThreadPoolExecutor(
+            consumeThreadMin,
+            consumeThreadMax,
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            this.consumeRequestQueue,
+            new ThreadFactoryImpl(""ConsumeMessageThread_""));
+        engine = new PriorityConcurrentEngine(this.consumeExecutor);
+
+        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(""ConsumeMessageScheduledThread_""));
+    }
+
+    private void refreshStageDefinition() {
+        Map<String, List<Integer>> strategies = messageListener.getStageDefinitionStrategies();
+        if (MapUtils.isNotEmpty(strategies)) {
+            for (Map.Entry<String, List<Integer>> entry : strategies.entrySet()) {
+                String strategyId = entry.getKey();
+                List<Integer> definitions = entry.getValue();
+                List<Integer> summedStageDefinitions = new ArrayList<>();
+                if (definitions != null) {
+                    int sum = 0;
+                    for (Integer stageDefinition : definitions) {
+                        summedStageDefinitions.add(sum = sum + stageDefinition);
+                    }
+                }
+                summedStageDefinitionMap.put(strategyId, summedStageDefinitions);
+            }
+        }
+    }
+
+    @Override
+    public void start() {
+        engine.start();
+        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())) {","[{'comment': '`ConsumeMessageStagedConcurrentlyService` is unnecessary.', 'commenter': 'ifplusor'}, {'comment': 'Can you give specific reasons?', 'commenter': 'loongs-zhang'}, {'comment': 'because `start` is member of `ConsumeMessageStagedConcurrentlyService`', 'commenter': 'ifplusor'}]"
2983,common/src/main/java/org/apache/rocketmq/common/concurrent/ConcurrentEngine.java,"@@ -0,0 +1,463 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.common.concurrent;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.collections.MapUtils;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.constant.LoggerName;
+import org.apache.rocketmq.common.utils.ThreadUtils;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.logging.InternalLoggerFactory;
+
+public class ConcurrentEngine {
+
+    protected static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);
+
+    protected final ExecutorService enginePool;
+
+    public ConcurrentEngine() {
+        this.enginePool = ForkJoinPool.commonPool();
+    }
+
+    public ConcurrentEngine(ExecutorService enginePool) {
+        this.enginePool = enginePool;
+    }
+
+    public final void runAsync(Runnable... tasks) {
+        runAsync(UtilAll.newArrayList(tasks));
+    }
+
+    protected static <E> List<E> pollAllTask(Queue<E> tasks) {
+        //avoid list expansion
+        List<E> list = new LinkedList<>();
+        while (tasks != null && !tasks.isEmpty()) {
+            E task = tasks.poll();
+            list.add(task);
+        }
+        return list;
+    }
+
+    protected static <T> void doCallback(CallableSupplier<T> supplier, T response) {
+        Collection<Callback<T>> callbacks = supplier.getCallbacks();
+        if (CollectionUtils.isNotEmpty(callbacks)) {
+            for (Callback<T> callback : callbacks) {
+                callback.call(response);
+            }
+        }
+    }
+
+    public final void runAsync(Queue<? extends Runnable> tasks) {
+        runAsync(pollAllTask(tasks));
+    }
+
+    public final void runAsync(Collection<? extends Runnable> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return;
+        }
+        List<CompletableFuture<Void>> list = new ArrayList<>(tasks.size());
+        for (Runnable task : tasks) {
+            list.add(CompletableFuture.runAsync(task, enginePool));
+        }
+        executeAsync(list);
+    }
+
+    @SafeVarargs
+    public final <T> List<T> supplyAsync(Supplier<T>... tasks) {
+        return supplyAsync(UtilAll.newArrayList(tasks));
+    }
+
+    public final <T> List<T> supplyAsync(Queue<? extends Supplier<T>> tasks) {
+        return supplyAsync(pollAllTask(tasks));
+    }
+
+    public final <T> List<T> supplyAsync(Collection<? extends Supplier<T>> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return new ArrayList<>();
+        }
+        List<CompletableFuture<T>> list = new ArrayList<>(tasks.size());
+        for (Supplier<T> task : tasks) {
+            list.add(CompletableFuture.supplyAsync(task, enginePool));
+        }
+        return executeAsync(list);
+    }
+
+    @SafeVarargs
+    public final <T> List<T> supplyCallableAsync(CallableSupplier<T>... tasks) {
+        return supplyCallableAsync(UtilAll.newArrayList(tasks));
+    }
+
+    public final <T> List<T> supplyCallableAsync(Queue<? extends CallableSupplier<T>> tasks) {
+        return supplyCallableAsync(pollAllTask(tasks));
+    }
+
+    public final <T> List<T> supplyCallableAsync(Collection<? extends CallableSupplier<T>> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return new ArrayList<>();
+        }
+        Map<CallableSupplier<T>, CompletableFuture<T>> map = new HashMap<>(tasks.size());
+        for (CallableSupplier<T> task : tasks) {
+            map.put(task, CompletableFuture.supplyAsync(task, enginePool));
+        }
+        Map<CallableSupplier<T>, T> result = executeKeyedAsync(map);
+        for (Map.Entry<CallableSupplier<T>, T> entry : result.entrySet()) {
+            doCallback(entry.getKey(), entry.getValue());
+        }
+        return UtilAll.newArrayList(result.values());
+    }
+
+    @SafeVarargs
+    public final <K, V> Map<K, V> supplyKeyedCallableAsync(KeyedCallableSupplier<K, V>... tasks) {
+        return supplyKeyedCallableAsync(UtilAll.newArrayList(tasks));
+    }
+
+    public final <K, V> Map<K, V> supplyKeyedCallableAsync(Queue<? extends KeyedCallableSupplier<K, V>> tasks) {
+        return supplyKeyedCallableAsync(pollAllTask(tasks));
+    }
+
+    public final <K, V> Map<K, V> supplyKeyedCallableAsync(Collection<? extends KeyedCallableSupplier<K, V>> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return new HashMap<>();
+        }
+        Map<K, CompletableFuture<V>> map = new HashMap<>(tasks.size());
+        for (KeyedCallableSupplier<K, V> task : tasks) {
+            map.put(task.key(), CompletableFuture.supplyAsync(task, enginePool));
+        }
+        Map<K, V> result = executeKeyedAsync(map);
+        for (KeyedCallableSupplier<K, V> task : tasks) {
+            K key = task.key();
+            V response = result.get(key);
+            doCallback(task, response);
+        }
+        return result;
+    }
+
+    @SafeVarargs
+    public final <T> List<T> executeAsync(CompletableFuture<T>... tasks) {
+        return executeAsync(UtilAll.newArrayList(tasks));
+    }
+
+    public final <T> List<T> executeAsync(Queue<CompletableFuture<T>> tasks) {
+        return executeAsync(pollAllTask(tasks));
+    }
+
+    public final <T> List<T> executeAsync(Collection<CompletableFuture<T>> tasks) {
+        if (CollectionUtils.isEmpty(tasks)) {
+            return new ArrayList<>();
+        }
+        try {
+            CompletableFuture.allOf(tasks.toArray(new CompletableFuture[0])).join();
+        } catch (Exception e) {
+            log.error(""tasks executeAsync failed with exception:{}"", e.getMessage(), e);
+            e.printStackTrace();
+        }
+        return getResultIgnoreException(tasks);
+    }
+
+    public final <T> List<T> getResultIgnoreException(Collection<CompletableFuture<T>> tasks) {
+        List<T> result = new ArrayList<>(tasks.size());
+        for (CompletableFuture<T> completableFuture : tasks) {
+            if (null == completableFuture) {
+                continue;
+            }
+            try {
+                T response = completableFuture.get();
+                if (null != response) {
+                    result.add(response);
+                }
+            } catch (Exception e) {
+                log.error(""task:{} execute failed with exception:{}"", completableFuture, e.getMessage(), e);
+            }
+        }
+        return result;","[{'comment': '`result.size()` and `tasks.size()` may not be equal, is this acceptable?', 'commenter': 'ifplusor'}, {'comment': 'Acceptable, because if the consumption fails, it will be taken again', 'commenter': 'loongs-zhang'}]"
2983,common/src/main/java/org/apache/rocketmq/common/concurrent/ConcurrentEngine.java,"@@ -0,0 +1,463 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.common.concurrent;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.collections.MapUtils;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.constant.LoggerName;
+import org.apache.rocketmq.common.utils.ThreadUtils;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.logging.InternalLoggerFactory;
+
+public class ConcurrentEngine {
+
+    protected static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);
+
+    protected final ExecutorService enginePool;
+
+    public ConcurrentEngine() {
+        this.enginePool = ForkJoinPool.commonPool();
+    }
+
+    public ConcurrentEngine(ExecutorService enginePool) {
+        this.enginePool = enginePool;
+    }
+
+    public final void runAsync(Runnable... tasks) {
+        runAsync(UtilAll.newArrayList(tasks));
+    }
+
+    protected static <E> List<E> pollAllTask(Queue<E> tasks) {
+        //avoid list expansion
+        List<E> list = new LinkedList<>();
+        while (tasks != null && !tasks.isEmpty()) {
+            E task = tasks.poll();
+            list.add(task);
+        }
+        return list;
+    }
+
+    protected static <T> void doCallback(CallableSupplier<T> supplier, T response) {
+        Collection<Callback<T>> callbacks = supplier.getCallbacks();
+        if (CollectionUtils.isNotEmpty(callbacks)) {
+            for (Callback<T> callback : callbacks) {
+                callback.call(response);
+            }
+        }
+    }
+
+    public final void runAsync(Queue<? extends Runnable> tasks) {
+        runAsync(pollAllTask(tasks));
+    }
+
+    public final void runAsync(Collection<? extends Runnable> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return;
+        }
+        List<CompletableFuture<Void>> list = new ArrayList<>(tasks.size());
+        for (Runnable task : tasks) {
+            list.add(CompletableFuture.runAsync(task, enginePool));
+        }
+        executeAsync(list);
+    }
+
+    @SafeVarargs
+    public final <T> List<T> supplyAsync(Supplier<T>... tasks) {
+        return supplyAsync(UtilAll.newArrayList(tasks));
+    }
+
+    public final <T> List<T> supplyAsync(Queue<? extends Supplier<T>> tasks) {
+        return supplyAsync(pollAllTask(tasks));
+    }
+
+    public final <T> List<T> supplyAsync(Collection<? extends Supplier<T>> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return new ArrayList<>();
+        }
+        List<CompletableFuture<T>> list = new ArrayList<>(tasks.size());
+        for (Supplier<T> task : tasks) {
+            list.add(CompletableFuture.supplyAsync(task, enginePool));
+        }
+        return executeAsync(list);
+    }
+
+    @SafeVarargs
+    public final <T> List<T> supplyCallableAsync(CallableSupplier<T>... tasks) {
+        return supplyCallableAsync(UtilAll.newArrayList(tasks));
+    }
+
+    public final <T> List<T> supplyCallableAsync(Queue<? extends CallableSupplier<T>> tasks) {
+        return supplyCallableAsync(pollAllTask(tasks));
+    }
+
+    public final <T> List<T> supplyCallableAsync(Collection<? extends CallableSupplier<T>> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return new ArrayList<>();
+        }
+        Map<CallableSupplier<T>, CompletableFuture<T>> map = new HashMap<>(tasks.size());
+        for (CallableSupplier<T> task : tasks) {
+            map.put(task, CompletableFuture.supplyAsync(task, enginePool));
+        }
+        Map<CallableSupplier<T>, T> result = executeKeyedAsync(map);
+        for (Map.Entry<CallableSupplier<T>, T> entry : result.entrySet()) {
+            doCallback(entry.getKey(), entry.getValue());
+        }
+        return UtilAll.newArrayList(result.values());
+    }
+
+    @SafeVarargs
+    public final <K, V> Map<K, V> supplyKeyedCallableAsync(KeyedCallableSupplier<K, V>... tasks) {
+        return supplyKeyedCallableAsync(UtilAll.newArrayList(tasks));
+    }
+
+    public final <K, V> Map<K, V> supplyKeyedCallableAsync(Queue<? extends KeyedCallableSupplier<K, V>> tasks) {
+        return supplyKeyedCallableAsync(pollAllTask(tasks));
+    }
+
+    public final <K, V> Map<K, V> supplyKeyedCallableAsync(Collection<? extends KeyedCallableSupplier<K, V>> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return new HashMap<>();
+        }
+        Map<K, CompletableFuture<V>> map = new HashMap<>(tasks.size());
+        for (KeyedCallableSupplier<K, V> task : tasks) {
+            map.put(task.key(), CompletableFuture.supplyAsync(task, enginePool));
+        }
+        Map<K, V> result = executeKeyedAsync(map);
+        for (KeyedCallableSupplier<K, V> task : tasks) {
+            K key = task.key();
+            V response = result.get(key);
+            doCallback(task, response);
+        }
+        return result;
+    }
+
+    @SafeVarargs
+    public final <T> List<T> executeAsync(CompletableFuture<T>... tasks) {
+        return executeAsync(UtilAll.newArrayList(tasks));
+    }
+
+    public final <T> List<T> executeAsync(Queue<CompletableFuture<T>> tasks) {
+        return executeAsync(pollAllTask(tasks));
+    }
+
+    public final <T> List<T> executeAsync(Collection<CompletableFuture<T>> tasks) {
+        if (CollectionUtils.isEmpty(tasks)) {
+            return new ArrayList<>();
+        }
+        try {
+            CompletableFuture.allOf(tasks.toArray(new CompletableFuture[0])).join();
+        } catch (Exception e) {
+            log.error(""tasks executeAsync failed with exception:{}"", e.getMessage(), e);
+            e.printStackTrace();
+        }
+        return getResultIgnoreException(tasks);
+    }
+
+    public final <T> List<T> getResultIgnoreException(Collection<CompletableFuture<T>> tasks) {
+        List<T> result = new ArrayList<>(tasks.size());
+        for (CompletableFuture<T> completableFuture : tasks) {
+            if (null == completableFuture) {
+                continue;
+            }
+            try {
+                T response = completableFuture.get();
+                if (null != response) {
+                    result.add(response);
+                }
+            } catch (Exception e) {
+                log.error(""task:{} execute failed with exception:{}"", completableFuture, e.getMessage(), e);
+            }
+        }
+        return result;
+    }
+
+    public final void runAsync(long timeout, TimeUnit unit, Runnable... tasks) {
+        runAsync(timeout, unit, UtilAll.newArrayList(tasks));
+    }
+
+    public final void runAsync(long timeout, TimeUnit unit, Queue<? extends Runnable> tasks) {
+        runAsync(timeout, unit, pollAllTask(tasks));
+    }
+
+    public final void runAsync(long timeout, TimeUnit unit, Collection<? extends Runnable> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return;
+        }
+        List<CompletableFuture<Void>> list = new ArrayList<>(tasks.size());
+        for (Runnable task : tasks) {
+            list.add(CompletableFuture.runAsync(task, enginePool));
+        }
+        executeAsync(timeout, unit, list);
+    }
+
+    @SafeVarargs
+    public final <T> List<T> supplyAsync(long timeout, TimeUnit unit, Supplier<T>... tasks) {
+        return supplyAsync(timeout, unit, UtilAll.newArrayList(tasks));
+    }
+
+    public final <T> List<T> supplyAsync(long timeout, TimeUnit unit, Queue<? extends Supplier<T>> tasks) {
+        return supplyAsync(timeout, unit, pollAllTask(tasks));
+    }
+
+    public final <T> List<T> supplyAsync(long timeout, TimeUnit unit, Collection<? extends Supplier<T>> tasks) {
+        if (null == tasks || tasks.size() == 0 || enginePool.isShutdown()) {
+            return new ArrayList<>();
+        }
+        List<CompletableFuture<T>> list = new ArrayList<>(tasks.size());
+        for (Supplier<T> task : tasks) {
+            list.add(CompletableFuture.supplyAsync(task, enginePool));
+        }
+        return executeAsync(timeout, unit, list);
+    }
+
+    @SafeVarargs
+    public final <T> List<T> supplyCallableAsync(long timeout, TimeUnit unit, CallableSupplier<T>... tasks) {
+        return supplyCallableAsync(timeout, unit, UtilAll.newArrayList(tasks));
+    }
+
+    public final <T> List<T> supplyCallableAsync(long timeout, TimeUnit unit,
+        Queue<? extends CallableSupplier<T>> tasks) {
+        return supplyCallableAsync(timeout, unit, pollAllTask(tasks));
+    }
+
+    public final <T> List<T> supplyCallableAsync(long timeout, TimeUnit unit,
+        Collection<? extends CallableSupplier<T>> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return new ArrayList<>();
+        }
+        Map<CallableSupplier<T>, CompletableFuture<T>> map = new HashMap<>(tasks.size());
+        for (CallableSupplier<T> task : tasks) {
+            map.put(task, CompletableFuture.supplyAsync(task, enginePool));
+        }
+        Map<CallableSupplier<T>, T> result = executeKeyedAsync(map, timeout, unit);
+        for (Map.Entry<CallableSupplier<T>, T> entry : result.entrySet()) {
+            doCallback(entry.getKey(), entry.getValue());
+        }
+        return UtilAll.newArrayList(result.values());
+    }
+
+    @SafeVarargs
+    public final <K, V> Map<K, V> supplyKeyedCallableAsync(long timeout, TimeUnit unit,
+        KeyedCallableSupplier<K, V>... tasks) {
+        return supplyKeyedCallableAsync(timeout, unit, UtilAll.newArrayList(tasks));
+    }
+
+    public final <K, V> Map<K, V> supplyKeyedCallableAsync(long timeout, TimeUnit unit,
+        Queue<? extends KeyedCallableSupplier<K, V>> tasks) {
+        return supplyKeyedCallableAsync(timeout, unit, pollAllTask(tasks));
+    }
+
+    public final <K, V> Map<K, V> supplyKeyedCallableAsync(long timeout, TimeUnit unit,
+        Collection<? extends KeyedCallableSupplier<K, V>> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return new HashMap<>();
+        }
+        Map<K, CompletableFuture<V>> map = new HashMap<>(tasks.size());
+        for (KeyedCallableSupplier<K, V> task : tasks) {
+            map.put(task.key(), CompletableFuture.supplyAsync(task, enginePool));
+        }
+        Map<K, V> result = executeKeyedAsync(map, timeout, unit);
+        for (KeyedCallableSupplier<K, V> task : tasks) {
+            K key = task.key();
+            V response = result.get(key);
+            doCallback(task, response);
+        }
+        return result;
+    }
+
+    @SafeVarargs
+    public final <T> List<T> executeAsync(long timeout, TimeUnit unit, CompletableFuture<T>... tasks) {
+        return executeAsync(timeout, unit, UtilAll.newArrayList(tasks));
+    }
+
+    public final <T> List<T> executeAsync(long timeout, TimeUnit unit, Queue<CompletableFuture<T>> tasks) {
+        return executeAsync(timeout, unit, pollAllTask(tasks));
+    }
+
+    public final <T> List<T> executeAsync(long timeout, TimeUnit unit, Collection<CompletableFuture<T>> tasks) {
+        if (CollectionUtils.isEmpty(tasks)) {
+            return new ArrayList<>();
+        }
+        try {
+            CompletableFuture.allOf(tasks.toArray(new CompletableFuture[0])).join();
+        } catch (Exception e) {
+            log.error(""tasks executeAsync failed with exception:{}"", e.getMessage(), e);
+            e.printStackTrace();
+        }
+        return getResultIgnoreException(tasks, timeout, unit);
+    }
+
+    public static <T> List<T> getResultIgnoreException(Collection<CompletableFuture<T>> tasks, long timeout,
+        TimeUnit unit) {
+        List<T> result = new ArrayList<>(tasks.size());
+        for (CompletableFuture<T> completableFuture : tasks) {
+            if (null == completableFuture) {
+                continue;
+            }
+            try {
+                T response = completableFuture.get(timeout, unit);
+                if (null != response) {
+                    result.add(response);
+                }
+            } catch (Exception e) {
+                log.error(""task:{} execute failed with exception:{}"", completableFuture, e.getMessage(), e);
+            }
+        }
+        return result;
+    }
+
+    @SafeVarargs
+    public final <K, V> Map<K, V> supplyKeyedAsync(KeyedSupplier<K, V>... tasks) {
+        return supplyKeyedAsync(UtilAll.newArrayList(tasks));
+    }
+
+    public final <K, V> Map<K, V> supplyKeyedAsync(Queue<? extends KeyedSupplier<K, V>> tasks) {
+        return supplyKeyedAsync(pollAllTask(tasks));
+    }
+
+    public final <K, V> Map<K, V> supplyKeyedAsync(Collection<? extends KeyedSupplier<K, V>> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return new HashMap<>(0);
+        }
+        Map<K, CompletableFuture<V>> map = new HashMap<>(tasks.size());
+        for (KeyedSupplier<K, V> task : tasks) {
+            map.put(task.key(), CompletableFuture.supplyAsync(task, enginePool));
+        }
+        return executeKeyedAsync(map);
+    }
+
+    public static <K, V> Map<K, V> executeKeyedAsync(Map<K, CompletableFuture<V>> tasks) {
+        if (MapUtils.isEmpty(tasks)) {
+            return new HashMap<>(0);
+        }
+        try {
+            CompletableFuture.allOf(tasks.values().toArray(new CompletableFuture[0])).join();
+        } catch (Exception e) {
+            log.error(""tasks executeAsync failed with exception:{}"", e.getMessage(), e);
+            e.printStackTrace();
+        }
+        return getKeyedResultIgnoreException(tasks);
+    }
+
+    public static <K, V> Map<K, V> getKeyedResultIgnoreException(Map<K, CompletableFuture<V>> tasks) {
+        Map<K, V> result = new HashMap<>(tasks.size());
+        for (Map.Entry<K, CompletableFuture<V>> entry : tasks.entrySet()) {
+            K key = entry.getKey();
+            CompletableFuture<V> value = entry.getValue();
+            if (null == value) {
+                continue;
+            }
+            try {
+                V response = value.get();
+                if (null != response) {
+                    result.put(key, response);
+                }
+            } catch (Exception e) {
+                log.error(""task with key:{} execute failed with exception:{}"", key, e.getMessage(), e);
+            }
+        }
+        return result;","[{'comment': 'ditto', 'commenter': 'ifplusor'}]"
2983,client/src/main/java/org/apache/rocketmq/client/impl/consumer/ConsumeMessageStagedConcurrentlyService.java,"@@ -0,0 +1,872 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.client.impl.consumer;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.collections.MapUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;
+import org.apache.rocketmq.client.consumer.listener.ConsumeReturnType;
+import org.apache.rocketmq.client.consumer.listener.ConsumeStagedConcurrentlyContext;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerStagedConcurrently;
+import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
+import org.apache.rocketmq.client.consumer.store.StageOffsetStore;
+import org.apache.rocketmq.client.hook.ConsumeMessageContext;
+import org.apache.rocketmq.client.log.ClientLogger;
+import org.apache.rocketmq.client.stat.ConsumerStatsManager;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.common.ThreadFactoryImpl;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.concurrent.PriorityConcurrentEngine;
+import org.apache.rocketmq.common.message.Message;
+import org.apache.rocketmq.common.message.MessageAccessor;
+import org.apache.rocketmq.common.message.MessageConst;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.common.protocol.NamespaceUtil;
+import org.apache.rocketmq.common.protocol.body.CMResult;
+import org.apache.rocketmq.common.protocol.body.ConsumeMessageDirectlyResult;
+import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
+import org.apache.rocketmq.common.utils.ThreadUtils;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.remoting.common.RemotingHelper;
+
+public class ConsumeMessageStagedConcurrentlyService implements ConsumeMessageService {
+    private static final String NULL = ""null"";
+    private static final InternalLogger log = ClientLogger.getLog();
+    private final static long MAX_TIME_CONSUME_CONTINUOUSLY =
+        Long.parseLong(System.getProperty(""rocketmq.client.maxTimeConsumeContinuously"", ""60000""));
+    private final DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;
+    private final DefaultMQPushConsumer defaultMQPushConsumer;
+    private final MessageListenerStagedConcurrently messageListener;
+    private final BlockingQueue<Runnable> consumeRequestQueue;
+    private final ThreadPoolExecutor dispatchExecutor;
+    private final ThreadPoolExecutor consumeExecutor;
+    private final PriorityConcurrentEngine engine;
+    private final String consumerGroup;
+    private final MessageQueueLock messageQueueLock = new MessageQueueLock();
+    private final ScheduledExecutorService scheduledExecutorService;
+    private volatile boolean stopped = false;
+    private final Map<String/*strategyId*/, List<Integer>/*StageDefinition*/> summedStageDefinitionMap;
+    private final ConcurrentMap<String/*topic*/, ConcurrentMap<String/*strategyId*/, ConcurrentMap<String/*groupId*/, AtomicInteger/*currentStageOffset*/>>> currentStageOffsetMap = new ConcurrentHashMap<>();
+    private final int pullBatchSize;
+    private final StageOffsetStore stageOffsetStore;
+
+    public ConsumeMessageStagedConcurrentlyService(DefaultMQPushConsumerImpl defaultMQPushConsumerImpl,
+        MessageListenerStagedConcurrently messageListener) {
+        this.defaultMQPushConsumerImpl = defaultMQPushConsumerImpl;
+        this.messageListener = messageListener;
+        this.summedStageDefinitionMap = new ConcurrentHashMap<>();
+        this.refreshStageDefinition();
+
+        this.stageOffsetStore = this.defaultMQPushConsumerImpl.getStageOffsetStore();
+
+        this.defaultMQPushConsumer = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer();
+        this.consumerGroup = this.defaultMQPushConsumer.getConsumerGroup();
+        this.pullBatchSize = this.defaultMQPushConsumer.getPullBatchSize();
+        this.consumeRequestQueue = new LinkedBlockingQueue<Runnable>();
+
+        int consumeThreadMin = this.defaultMQPushConsumer.getConsumeThreadMin();
+        int consumeThreadMax = this.defaultMQPushConsumer.getConsumeThreadMax();
+        this.dispatchExecutor = new ThreadPoolExecutor(
+            (int) Math.ceil(consumeThreadMin * 1.0 / this.pullBatchSize),
+            (int) Math.ceil(consumeThreadMax * 1.0 / this.pullBatchSize),
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            new LinkedBlockingQueue<Runnable>(),
+            new ThreadFactoryImpl(""DispatchMessageThread_""));
+        // when the number of threads is equal to
+        // the topic consumeQueue size multiplied by this.pullBatchSize,
+        // good performance can be obtained
+        this.consumeExecutor = new ThreadPoolExecutor(
+            consumeThreadMin,
+            consumeThreadMax,
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            this.consumeRequestQueue,
+            new ThreadFactoryImpl(""ConsumeMessageThread_""));
+        engine = new PriorityConcurrentEngine(this.consumeExecutor);
+
+        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(""ConsumeMessageScheduledThread_""));
+    }
+
+    private void refreshStageDefinition() {
+        Map<String, List<Integer>> strategies = messageListener.getStageDefinitionStrategies();
+        if (MapUtils.isNotEmpty(strategies)) {
+            for (Map.Entry<String, List<Integer>> entry : strategies.entrySet()) {
+                String strategyId = entry.getKey();
+                List<Integer> definitions = entry.getValue();
+                List<Integer> summedStageDefinitions = new ArrayList<>();
+                if (definitions != null) {
+                    int sum = 0;
+                    for (Integer stageDefinition : definitions) {
+                        summedStageDefinitions.add(sum = sum + stageDefinition);
+                    }
+                }
+                summedStageDefinitionMap.put(strategyId, summedStageDefinitions);
+            }
+        }
+    }
+
+    @Override
+    public void start() {
+        engine.start();
+        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())) {
+            this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
+                @Override
+                public void run() {
+                    ConsumeMessageStagedConcurrentlyService.this.lockMQPeriodically();
+                }
+            }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    @Override
+    public void shutdown(long awaitTerminateMillis) {
+        this.stopped = true;
+        this.scheduledExecutorService.shutdown();
+        ThreadUtils.shutdownGracefully(this.dispatchExecutor, awaitTerminateMillis, TimeUnit.MILLISECONDS);
+        engine.shutdown(awaitTerminateMillis);
+        if (MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {
+            this.unlockAllMQ();
+        }
+    }
+
+    public synchronized void unlockAllMQ() {
+        this.defaultMQPushConsumerImpl.getRebalanceImpl().unlockAll(false);
+    }
+
+    public AtomicInteger getCurrentStageOffset(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId || NULL.equals(strategyId)) {
+            return new AtomicInteger(-1);
+        }
+        groupId = String.valueOf(groupId);
+        ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> groupByStrategy = currentStageOffsetMap.get(topic);
+        if (null == groupByStrategy) {
+            ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> stageOffset = stageOffsetStore == null ?
+                new ConcurrentHashMap<>() : convert(stageOffsetStore.readStageOffset(messageQueue, ReadOffsetType.MEMORY_FIRST_THEN_STORE));
+            currentStageOffsetMap.putIfAbsent(topic, stageOffset);
+            groupByStrategy = currentStageOffsetMap.get(topic);
+        }
+        ConcurrentMap<String, AtomicInteger> groups = groupByStrategy.putIfAbsent(strategyId, new ConcurrentHashMap<>());
+        if (null == groups) {
+            groups = groupByStrategy.get(strategyId);
+        }
+        groups.putIfAbsent(groupId, new AtomicInteger(0));
+        return groups.get(groupId);
+    }
+
+    private ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> convert(
+        Map<String, Map<String, Integer>> original) {
+        if (null == original) {
+            return new ConcurrentHashMap<>();
+        }
+        ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> map = new ConcurrentHashMap<>(original.size());
+        for (Map.Entry<String, Map<String, Integer>> entry : original.entrySet()) {
+            String strategy = entry.getKey();
+            ConcurrentMap<String, AtomicInteger> temp = new ConcurrentHashMap<>();
+            Map<String, Integer> groups = entry.getValue();
+            for (Map.Entry<String, Integer> innerEntry : groups.entrySet()) {
+                String key = innerEntry.getKey();
+                Integer value = innerEntry.getValue();
+                temp.put(key, new AtomicInteger(value));
+            }
+            map.put(strategy, temp);
+        }
+        return map;
+    }
+
+    public int getCurrentLeftoverStage(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId) {
+            return -1;
+        }
+        List<Integer> summedStageDefinition = summedStageDefinitionMap.get(strategyId);
+        if (CollectionUtils.isNotEmpty(summedStageDefinition)) {
+            for (Integer stageDefinition : summedStageDefinition) {
+                int left = stageDefinition - getCurrentStageOffset(messageQueue, topic, strategyId, groupId).get();
+                if (left > 0) {
+                    return left;
+                }
+            }
+        }
+        return -1;
+    }
+
+    public int getCurrentLeftoverStageIndex(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId) {
+            return -1;
+        }
+        List<Integer> summedStageDefinition = summedStageDefinitionMap.get(strategyId);
+        if (CollectionUtils.isNotEmpty(summedStageDefinition)) {
+            for (int i = 0; i < summedStageDefinition.size(); i++) {
+                int left = summedStageDefinition.get(i) - getCurrentStageOffset(messageQueue, topic, strategyId, groupId).get();
+                if (left > 0) {
+                    return i;
+                }
+            }
+        }
+        return -1;
+    }
+
+    public int getCurrentLeftoverStageIndexAndUpdate(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId, int delta) {
+        final AtomicInteger offset = getCurrentStageOffset(messageQueue, topic, strategyId, groupId);
+        synchronized (offset) {
+            try {
+                return getCurrentLeftoverStageIndex(messageQueue, topic, strategyId, groupId);
+            } finally {
+                offset.getAndAdd(delta);
+            }
+        }
+    }
+
+    @Override
+    public void updateCorePoolSize(int corePoolSize) {
+        if (corePoolSize > 0
+            && corePoolSize <= Short.MAX_VALUE
+            && corePoolSize < this.defaultMQPushConsumer.getConsumeThreadMax()) {
+            this.consumeExecutor.setCorePoolSize(corePoolSize);
+        }
+    }
+
+    @Override
+    public void incCorePoolSize() {
+    }
+
+    @Override
+    public void decCorePoolSize() {
+    }
+
+    @Override
+    public int getCorePoolSize() {
+        return this.consumeExecutor.getCorePoolSize();
+    }
+
+    @Override
+    public ConsumeMessageDirectlyResult consumeMessageDirectly(MessageExt msg, String brokerName) {
+        ConsumeMessageDirectlyResult result = new ConsumeMessageDirectlyResult();
+        result.setOrder(true);
+
+        String topic = msg.getTopic();
+        List<MessageExt> msgs = new ArrayList<MessageExt>();
+        msgs.add(msg);
+        MessageQueue mq = new MessageQueue();
+        mq.setBrokerName(brokerName);
+        mq.setTopic(topic);
+        mq.setQueueId(msg.getQueueId());
+
+        ConsumeStagedConcurrentlyContext context = new ConsumeStagedConcurrentlyContext(mq);
+
+        this.defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, this.consumerGroup);
+
+        final long beginTime = System.currentTimeMillis();
+
+        log.info(""consumeMessageDirectly receive new message: {}"", msg);
+
+        Set<MessageQueue> topicSubscribeInfo = this.defaultMQPushConsumerImpl.getRebalanceImpl().getTopicSubscribeInfo(topic);
+        MessageQueue messageQueue = null;
+        if (CollectionUtils.isNotEmpty(topicSubscribeInfo)) {
+            for (MessageQueue queue : topicSubscribeInfo) {
+                if (queue.getQueueId() == msg.getQueueId()) {
+                    messageQueue = queue;
+                    break;
+                }
+            }
+        }
+
+        try {
+            String strategyId = NULL;
+            try {
+                strategyId = String.valueOf(this.messageListener.computeStrategy(msg));
+            } catch (Exception e) {
+                log.error(""computeStrategy failed with exception:"" + e.getMessage() + "" !"");
+            }
+            String groupId = NULL;
+            try {
+                groupId = String.valueOf(this.messageListener.computeGroup(msg));
+            } catch (Exception e) {
+                log.error(""computeGroup failed with exception:"" + e.getMessage() + "" !"");
+            }
+            context.setStrategyId(strategyId);
+            context.setGroupId(groupId);
+            //the test message should not update the stage offset
+            context.setStageIndex(getCurrentLeftoverStageIndex(messageQueue, topic, strategyId, groupId));
+            ConsumeOrderlyStatus status = this.messageListener.consumeMessage(msgs, context);
+            if (status != null) {
+                switch (status) {
+                    case COMMIT:
+                        result.setConsumeResult(CMResult.CR_COMMIT);
+                        break;
+                    case ROLLBACK:
+                        result.setConsumeResult(CMResult.CR_ROLLBACK);
+                        break;
+                    case SUCCESS:
+                        result.setConsumeResult(CMResult.CR_SUCCESS);
+                        break;
+                    case SUSPEND_CURRENT_QUEUE_A_MOMENT:
+                        result.setConsumeResult(CMResult.CR_LATER);
+                        break;
+                    default:
+                        break;
+                }
+            } else {
+                result.setConsumeResult(CMResult.CR_RETURN_NULL);
+            }
+            AtomicInteger currentStageOffset = getCurrentStageOffset(messageQueue, topic, strategyId, groupId);
+            synchronized (currentStageOffset) {
+                int original = currentStageOffset.get();
+                this.messageListener.rollbackCurrentStageOffsetIfNeed(topic, strategyId, groupId, currentStageOffset, msgs);
+                currentStageOffset.set(original);
+            }
+        } catch (Throwable e) {
+            result.setConsumeResult(CMResult.CR_THROW_EXCEPTION);
+            result.setRemark(RemotingHelper.exceptionSimpleDesc(e));
+
+            log.warn(String.format(""consumeMessageDirectly exception: %s Group: %s Msgs: %s MQ: %s"",
+                RemotingHelper.exceptionSimpleDesc(e),
+                ConsumeMessageStagedConcurrentlyService.this.consumerGroup,
+                msgs,
+                mq), e);
+        }
+        result.setAutoCommit(context.isAutoCommit());
+        result.setSpentTimeMills(System.currentTimeMillis() - beginTime);
+
+        log.info(""consumeMessageDirectly Result: {}"", result);
+
+        return result;
+    }
+
+    @Override
+    public void submitConsumeRequest(
+        final List<MessageExt> msgs,
+        final ProcessQueue processQueue,
+        final MessageQueue messageQueue,
+        final boolean dispatchToConsume) {
+        if (dispatchToConsume) {
+            DispatchRequest dispatchRequest = new DispatchRequest(processQueue, messageQueue);
+            this.dispatchExecutor.submit(dispatchRequest);
+        }
+    }
+
+    public synchronized void lockMQPeriodically() {
+        if (!this.stopped) {
+            this.defaultMQPushConsumerImpl.getRebalanceImpl().lockAll();
+        }
+    }
+
+    public void tryLockLaterAndReconsume(final MessageQueue mq, final ProcessQueue processQueue,
+        final long delayMills) {
+        this.scheduledExecutorService.schedule(new Runnable() {
+            @Override
+            public void run() {
+                boolean lockOK = ConsumeMessageStagedConcurrentlyService.this.lockOneMQ(mq);
+                if (lockOK) {
+                    ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequestLater(processQueue, mq, 10);
+                } else {
+                    ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequestLater(processQueue, mq, 3000);
+                }
+            }
+        }, delayMills, TimeUnit.MILLISECONDS);
+    }
+
+    public synchronized boolean lockOneMQ(final MessageQueue mq) {
+        if (!this.stopped) {
+            return this.defaultMQPushConsumerImpl.getRebalanceImpl().lock(mq);
+        }
+
+        return false;
+    }
+
+    private void submitConsumeRequestLater(
+        final ProcessQueue processQueue,
+        final MessageQueue messageQueue,
+        final long suspendTimeMillis
+    ) {
+        long timeMillis = suspendTimeMillis;
+        if (timeMillis == -1) {
+            timeMillis = this.defaultMQPushConsumer.getSuspendCurrentQueueTimeMillis();
+        }
+
+        if (timeMillis < 10) {
+            timeMillis = 10;
+        } else if (timeMillis > 30000) {
+            timeMillis = 30000;
+        }
+
+        this.scheduledExecutorService.schedule(new Runnable() {
+
+            @Override
+            public void run() {
+                ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequest(null, processQueue, messageQueue, true);
+            }
+        }, timeMillis, TimeUnit.MILLISECONDS);
+    }
+
+    public boolean processConsumeResult(
+        final String strategyId,
+        final String groupId,
+        final List<MessageExt> msgs,
+        final ConsumeOrderlyStatus status,
+        final ConsumeStagedConcurrentlyContext context,
+        final ConsumeRequest consumeRequest
+    ) {
+        MessageQueue messageQueue = consumeRequest.getMessageQueue();
+        String topic = messageQueue.getTopic();
+        AtomicInteger currentStageOffset = getCurrentStageOffset(messageQueue, topic, strategyId, groupId);
+        boolean continueConsume = true;
+        long commitOffset = -1L;
+        int commitStageOffset = -1;
+        if (context.isAutoCommit()) {
+            switch (status) {
+                case COMMIT:
+                case ROLLBACK:
+                    log.warn(""the message queue consume result is illegal, we think you want to ack these message {}"",
+                        messageQueue);
+                case SUCCESS:
+                    commitOffset = consumeRequest.getProcessQueue().commitMessages(msgs);
+                    commitStageOffset = currentStageOffset.get();
+                    this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, topic, msgs.size());
+                    break;
+                case SUSPEND_CURRENT_QUEUE_A_MOMENT:
+                    synchronized (currentStageOffset) {
+                        currentStageOffset.set(currentStageOffset.get() - msgs.size());
+                    }
+                    this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, topic, msgs.size());
+                    if (checkReconsumeTimes(msgs)) {
+                        consumeRequest.getProcessQueue().makeMessageToConsumeAgain(msgs);
+                        this.submitConsumeRequestLater(
+                            consumeRequest.getProcessQueue(),
+                            messageQueue,
+                            context.getSuspendCurrentQueueTimeMillis());
+                        continueConsume = false;
+                    } else {
+                        commitOffset = consumeRequest.getProcessQueue().commitMessages(msgs);
+                        commitStageOffset = currentStageOffset.get();
+                    }
+                    break;
+                default:
+                    break;
+            }
+        } else {
+            switch (status) {
+                case SUCCESS:
+                    this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, topic, msgs.size());
+                    break;
+                case COMMIT:
+                    commitOffset = consumeRequest.getProcessQueue().commitMessages(msgs);
+                    commitStageOffset = currentStageOffset.get();
+                    break;
+                case ROLLBACK:
+                    consumeRequest.getProcessQueue().rollback();
+                    this.submitConsumeRequestLater(
+                        consumeRequest.getProcessQueue(),
+                        messageQueue,
+                        context.getSuspendCurrentQueueTimeMillis());
+                    continueConsume = false;
+                    break;
+                case SUSPEND_CURRENT_QUEUE_A_MOMENT:
+                    synchronized (currentStageOffset) {
+                        currentStageOffset.set(currentStageOffset.get() - msgs.size());
+                    }
+                    this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, topic, msgs.size());
+                    if (checkReconsumeTimes(msgs)) {
+                        consumeRequest.getProcessQueue().makeMessageToConsumeAgain(msgs);
+                        this.submitConsumeRequestLater(
+                            consumeRequest.getProcessQueue(),
+                            messageQueue,
+                            context.getSuspendCurrentQueueTimeMillis());
+                        continueConsume = false;
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        if (commitOffset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {
+            this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(messageQueue, commitOffset, false);
+        }
+
+        if (stageOffsetStore != null && commitStageOffset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {
+            synchronized (currentStageOffset) {
+                messageListener.rollbackCurrentStageOffsetIfNeed(topic, strategyId, groupId, currentStageOffset, msgs);
+                //prevent users from resetting the value of currentStageOffset to a value less than 0
+                currentStageOffset.set(Math.max(0, currentStageOffset.get()));
+            }
+            commitStageOffset = currentStageOffset.get();
+            if (!consumeRequest.getProcessQueue().isDropped()) {
+                stageOffsetStore.updateStageOffset(messageQueue, strategyId, groupId, commitStageOffset, false);
+            }
+        }
+
+        return continueConsume;
+    }
+
+    public ConsumerStatsManager getConsumerStatsManager() {
+        return this.defaultMQPushConsumerImpl.getConsumerStatsManager();
+    }
+
+    private int getMaxReconsumeTimes() {
+        // default reconsume times: Integer.MAX_VALUE
+        if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) {
+            return Integer.MAX_VALUE;
+        } else {
+            return this.defaultMQPushConsumer.getMaxReconsumeTimes();
+        }
+    }
+
+    private boolean checkReconsumeTimes(List<MessageExt> msgs) {
+        boolean suspend = false;
+        if (msgs != null && !msgs.isEmpty()) {
+            for (MessageExt msg : msgs) {
+                if (msg.getReconsumeTimes() >= getMaxReconsumeTimes()) {
+                    MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes()));
+                    if (!sendMessageBack(msg)) {
+                        suspend = true;
+                        msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
+                    }
+                } else {
+                    suspend = true;
+                    msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
+                }
+            }
+        }
+        return suspend;
+    }
+
+    public boolean sendMessageBack(final MessageExt msg) {
+        try {
+            // max reconsume times exceeded then send to dead letter queue.
+            Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());
+            String originMsgId = MessageAccessor.getOriginMessageId(msg);
+            MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);
+            newMsg.setFlag(msg.getFlag());
+            MessageAccessor.setProperties(newMsg, msg.getProperties());
+            MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());
+            MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes()));
+            MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));
+            MessageAccessor.clearProperty(newMsg, MessageConst.PROPERTY_TRANSACTION_PREPARED);
+            newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());
+
+            this.defaultMQPushConsumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getDefaultMQProducer().send(newMsg);
+            return true;
+        } catch (Exception e) {
+            log.error(""sendMessageBack exception, group: "" + this.consumerGroup + "" msg: "" + msg.toString(), e);
+        }
+
+        return false;
+    }
+
+    public void resetNamespace(final List<MessageExt> msgs) {
+        for (MessageExt msg : msgs) {
+            if (StringUtils.isNotEmpty(this.defaultMQPushConsumer.getNamespace())) {
+                msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace()));
+            }
+        }
+    }
+
+    class DispatchRequest implements Runnable {
+        private final ProcessQueue processQueue;
+        private final MessageQueue messageQueue;
+
+        public DispatchRequest(ProcessQueue processQueue,
+            MessageQueue messageQueue) {
+            this.processQueue = processQueue;
+            this.messageQueue = messageQueue;
+        }
+
+        @Override
+        public void run() {
+            if (this.processQueue.isDropped()) {
+                log.warn(""run, the message queue not be able to consume, because it's dropped. {}"", this.messageQueue);
+                return;
+            }
+
+            String topic = this.messageQueue.getTopic();
+            final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue);
+            synchronized (objLock) {
+                if (MessageModel.BROADCASTING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())
+                    || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) {
+                    final long beginTime = System.currentTimeMillis();
+                    for (final AtomicBoolean continueConsume = new AtomicBoolean(true); continueConsume.get(); ) {
+                        if (this.processQueue.isDropped()) {
+                            log.warn(""the message queue not be able to consume, because it's dropped. {}"", this.messageQueue);
+                            break;
+                        }
+
+                        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())
+                            && !this.processQueue.isLocked()) {
+                            log.warn(""the message queue not locked, so consume later, {}"", this.messageQueue);
+                            ConsumeMessageStagedConcurrentlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
+                            break;
+                        }
+
+                        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())
+                            && this.processQueue.isLockExpired()) {
+                            log.warn(""the message queue lock expired, so consume later, {}"", this.messageQueue);
+                            ConsumeMessageStagedConcurrentlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
+                            break;
+                        }
+
+                        long interval = System.currentTimeMillis() - beginTime;
+                        if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {
+                            ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10);
+                            break;
+                        }
+
+                        final int consumeBatchSize =
+                            ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();
+                        int takeSize = ConsumeMessageStagedConcurrentlyService.this.pullBatchSize * consumeBatchSize;","[{'comment': '`pullBatchSize * consumeBatchSize` is unreasonable', 'commenter': 'ifplusor'}, {'comment': 'Consider `pullBatchSize` as the number of packets, parallel between packets, serial within packets, and serial packets consume `consumeBatchSize` messages each time', 'commenter': 'loongs-zhang'}, {'comment': 'if `pullBatchSize` is 32 and `consumeBatchSize` is 32 too, `takeSize` will be 1024', 'commenter': 'ifplusor'}, {'comment': 'Take out enough messages for better grouping. The size of `takeSize` is not a problem', 'commenter': 'loongs-zhang'}]"
2983,client/src/main/java/org/apache/rocketmq/client/impl/consumer/ConsumeMessageStagedConcurrentlyService.java,"@@ -0,0 +1,872 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.client.impl.consumer;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.collections.MapUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;
+import org.apache.rocketmq.client.consumer.listener.ConsumeReturnType;
+import org.apache.rocketmq.client.consumer.listener.ConsumeStagedConcurrentlyContext;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerStagedConcurrently;
+import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
+import org.apache.rocketmq.client.consumer.store.StageOffsetStore;
+import org.apache.rocketmq.client.hook.ConsumeMessageContext;
+import org.apache.rocketmq.client.log.ClientLogger;
+import org.apache.rocketmq.client.stat.ConsumerStatsManager;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.common.ThreadFactoryImpl;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.concurrent.PriorityConcurrentEngine;
+import org.apache.rocketmq.common.message.Message;
+import org.apache.rocketmq.common.message.MessageAccessor;
+import org.apache.rocketmq.common.message.MessageConst;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.common.protocol.NamespaceUtil;
+import org.apache.rocketmq.common.protocol.body.CMResult;
+import org.apache.rocketmq.common.protocol.body.ConsumeMessageDirectlyResult;
+import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
+import org.apache.rocketmq.common.utils.ThreadUtils;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.remoting.common.RemotingHelper;
+
+public class ConsumeMessageStagedConcurrentlyService implements ConsumeMessageService {
+    private static final String NULL = ""null"";
+    private static final InternalLogger log = ClientLogger.getLog();
+    private final static long MAX_TIME_CONSUME_CONTINUOUSLY =
+        Long.parseLong(System.getProperty(""rocketmq.client.maxTimeConsumeContinuously"", ""60000""));
+    private final DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;
+    private final DefaultMQPushConsumer defaultMQPushConsumer;
+    private final MessageListenerStagedConcurrently messageListener;
+    private final BlockingQueue<Runnable> consumeRequestQueue;
+    private final ThreadPoolExecutor dispatchExecutor;
+    private final ThreadPoolExecutor consumeExecutor;
+    private final PriorityConcurrentEngine engine;
+    private final String consumerGroup;
+    private final MessageQueueLock messageQueueLock = new MessageQueueLock();
+    private final ScheduledExecutorService scheduledExecutorService;
+    private volatile boolean stopped = false;
+    private final Map<String/*strategyId*/, List<Integer>/*StageDefinition*/> summedStageDefinitionMap;
+    private final ConcurrentMap<String/*topic*/, ConcurrentMap<String/*strategyId*/, ConcurrentMap<String/*groupId*/, AtomicInteger/*currentStageOffset*/>>> currentStageOffsetMap = new ConcurrentHashMap<>();
+    private final int pullBatchSize;
+    private final StageOffsetStore stageOffsetStore;
+
+    public ConsumeMessageStagedConcurrentlyService(DefaultMQPushConsumerImpl defaultMQPushConsumerImpl,
+        MessageListenerStagedConcurrently messageListener) {
+        this.defaultMQPushConsumerImpl = defaultMQPushConsumerImpl;
+        this.messageListener = messageListener;
+        this.summedStageDefinitionMap = new ConcurrentHashMap<>();
+        this.refreshStageDefinition();
+
+        this.stageOffsetStore = this.defaultMQPushConsumerImpl.getStageOffsetStore();
+
+        this.defaultMQPushConsumer = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer();
+        this.consumerGroup = this.defaultMQPushConsumer.getConsumerGroup();
+        this.pullBatchSize = this.defaultMQPushConsumer.getPullBatchSize();
+        this.consumeRequestQueue = new LinkedBlockingQueue<Runnable>();
+
+        int consumeThreadMin = this.defaultMQPushConsumer.getConsumeThreadMin();
+        int consumeThreadMax = this.defaultMQPushConsumer.getConsumeThreadMax();
+        this.dispatchExecutor = new ThreadPoolExecutor(
+            (int) Math.ceil(consumeThreadMin * 1.0 / this.pullBatchSize),
+            (int) Math.ceil(consumeThreadMax * 1.0 / this.pullBatchSize),
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            new LinkedBlockingQueue<Runnable>(),
+            new ThreadFactoryImpl(""DispatchMessageThread_""));
+        // when the number of threads is equal to
+        // the topic consumeQueue size multiplied by this.pullBatchSize,
+        // good performance can be obtained
+        this.consumeExecutor = new ThreadPoolExecutor(
+            consumeThreadMin,
+            consumeThreadMax,
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            this.consumeRequestQueue,
+            new ThreadFactoryImpl(""ConsumeMessageThread_""));
+        engine = new PriorityConcurrentEngine(this.consumeExecutor);
+
+        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(""ConsumeMessageScheduledThread_""));
+    }
+
+    private void refreshStageDefinition() {
+        Map<String, List<Integer>> strategies = messageListener.getStageDefinitionStrategies();
+        if (MapUtils.isNotEmpty(strategies)) {
+            for (Map.Entry<String, List<Integer>> entry : strategies.entrySet()) {
+                String strategyId = entry.getKey();
+                List<Integer> definitions = entry.getValue();
+                List<Integer> summedStageDefinitions = new ArrayList<>();
+                if (definitions != null) {
+                    int sum = 0;
+                    for (Integer stageDefinition : definitions) {
+                        summedStageDefinitions.add(sum = sum + stageDefinition);
+                    }
+                }
+                summedStageDefinitionMap.put(strategyId, summedStageDefinitions);
+            }
+        }
+    }
+
+    @Override
+    public void start() {
+        engine.start();
+        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())) {
+            this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
+                @Override
+                public void run() {
+                    ConsumeMessageStagedConcurrentlyService.this.lockMQPeriodically();
+                }
+            }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    @Override
+    public void shutdown(long awaitTerminateMillis) {
+        this.stopped = true;
+        this.scheduledExecutorService.shutdown();
+        ThreadUtils.shutdownGracefully(this.dispatchExecutor, awaitTerminateMillis, TimeUnit.MILLISECONDS);
+        engine.shutdown(awaitTerminateMillis);
+        if (MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {
+            this.unlockAllMQ();
+        }
+    }
+
+    public synchronized void unlockAllMQ() {
+        this.defaultMQPushConsumerImpl.getRebalanceImpl().unlockAll(false);
+    }
+
+    public AtomicInteger getCurrentStageOffset(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId || NULL.equals(strategyId)) {
+            return new AtomicInteger(-1);
+        }
+        groupId = String.valueOf(groupId);
+        ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> groupByStrategy = currentStageOffsetMap.get(topic);
+        if (null == groupByStrategy) {
+            ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> stageOffset = stageOffsetStore == null ?
+                new ConcurrentHashMap<>() : convert(stageOffsetStore.readStageOffset(messageQueue, ReadOffsetType.MEMORY_FIRST_THEN_STORE));
+            currentStageOffsetMap.putIfAbsent(topic, stageOffset);
+            groupByStrategy = currentStageOffsetMap.get(topic);
+        }
+        ConcurrentMap<String, AtomicInteger> groups = groupByStrategy.putIfAbsent(strategyId, new ConcurrentHashMap<>());
+        if (null == groups) {
+            groups = groupByStrategy.get(strategyId);
+        }
+        groups.putIfAbsent(groupId, new AtomicInteger(0));
+        return groups.get(groupId);
+    }
+
+    private ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> convert(
+        Map<String, Map<String, Integer>> original) {
+        if (null == original) {
+            return new ConcurrentHashMap<>();
+        }
+        ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> map = new ConcurrentHashMap<>(original.size());
+        for (Map.Entry<String, Map<String, Integer>> entry : original.entrySet()) {
+            String strategy = entry.getKey();
+            ConcurrentMap<String, AtomicInteger> temp = new ConcurrentHashMap<>();
+            Map<String, Integer> groups = entry.getValue();
+            for (Map.Entry<String, Integer> innerEntry : groups.entrySet()) {
+                String key = innerEntry.getKey();
+                Integer value = innerEntry.getValue();
+                temp.put(key, new AtomicInteger(value));
+            }
+            map.put(strategy, temp);
+        }
+        return map;
+    }
+
+    public int getCurrentLeftoverStage(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId) {
+            return -1;
+        }
+        List<Integer> summedStageDefinition = summedStageDefinitionMap.get(strategyId);
+        if (CollectionUtils.isNotEmpty(summedStageDefinition)) {
+            for (Integer stageDefinition : summedStageDefinition) {
+                int left = stageDefinition - getCurrentStageOffset(messageQueue, topic, strategyId, groupId).get();
+                if (left > 0) {
+                    return left;
+                }
+            }
+        }
+        return -1;
+    }
+
+    public int getCurrentLeftoverStageIndex(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId) {
+            return -1;
+        }
+        List<Integer> summedStageDefinition = summedStageDefinitionMap.get(strategyId);
+        if (CollectionUtils.isNotEmpty(summedStageDefinition)) {
+            for (int i = 0; i < summedStageDefinition.size(); i++) {
+                int left = summedStageDefinition.get(i) - getCurrentStageOffset(messageQueue, topic, strategyId, groupId).get();
+                if (left > 0) {
+                    return i;
+                }
+            }
+        }
+        return -1;
+    }
+
+    public int getCurrentLeftoverStageIndexAndUpdate(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId, int delta) {
+        final AtomicInteger offset = getCurrentStageOffset(messageQueue, topic, strategyId, groupId);
+        synchronized (offset) {
+            try {
+                return getCurrentLeftoverStageIndex(messageQueue, topic, strategyId, groupId);
+            } finally {
+                offset.getAndAdd(delta);
+            }
+        }
+    }
+
+    @Override
+    public void updateCorePoolSize(int corePoolSize) {
+        if (corePoolSize > 0
+            && corePoolSize <= Short.MAX_VALUE
+            && corePoolSize < this.defaultMQPushConsumer.getConsumeThreadMax()) {
+            this.consumeExecutor.setCorePoolSize(corePoolSize);
+        }
+    }
+
+    @Override
+    public void incCorePoolSize() {
+    }
+
+    @Override
+    public void decCorePoolSize() {
+    }
+
+    @Override
+    public int getCorePoolSize() {
+        return this.consumeExecutor.getCorePoolSize();
+    }
+
+    @Override
+    public ConsumeMessageDirectlyResult consumeMessageDirectly(MessageExt msg, String brokerName) {
+        ConsumeMessageDirectlyResult result = new ConsumeMessageDirectlyResult();
+        result.setOrder(true);
+
+        String topic = msg.getTopic();
+        List<MessageExt> msgs = new ArrayList<MessageExt>();
+        msgs.add(msg);
+        MessageQueue mq = new MessageQueue();
+        mq.setBrokerName(brokerName);
+        mq.setTopic(topic);
+        mq.setQueueId(msg.getQueueId());
+
+        ConsumeStagedConcurrentlyContext context = new ConsumeStagedConcurrentlyContext(mq);
+
+        this.defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, this.consumerGroup);
+
+        final long beginTime = System.currentTimeMillis();
+
+        log.info(""consumeMessageDirectly receive new message: {}"", msg);
+
+        Set<MessageQueue> topicSubscribeInfo = this.defaultMQPushConsumerImpl.getRebalanceImpl().getTopicSubscribeInfo(topic);
+        MessageQueue messageQueue = null;
+        if (CollectionUtils.isNotEmpty(topicSubscribeInfo)) {
+            for (MessageQueue queue : topicSubscribeInfo) {
+                if (queue.getQueueId() == msg.getQueueId()) {
+                    messageQueue = queue;
+                    break;
+                }
+            }
+        }
+
+        try {
+            String strategyId = NULL;
+            try {
+                strategyId = String.valueOf(this.messageListener.computeStrategy(msg));
+            } catch (Exception e) {
+                log.error(""computeStrategy failed with exception:"" + e.getMessage() + "" !"");
+            }
+            String groupId = NULL;
+            try {
+                groupId = String.valueOf(this.messageListener.computeGroup(msg));
+            } catch (Exception e) {
+                log.error(""computeGroup failed with exception:"" + e.getMessage() + "" !"");
+            }
+            context.setStrategyId(strategyId);
+            context.setGroupId(groupId);
+            //the test message should not update the stage offset
+            context.setStageIndex(getCurrentLeftoverStageIndex(messageQueue, topic, strategyId, groupId));
+            ConsumeOrderlyStatus status = this.messageListener.consumeMessage(msgs, context);
+            if (status != null) {
+                switch (status) {
+                    case COMMIT:
+                        result.setConsumeResult(CMResult.CR_COMMIT);
+                        break;
+                    case ROLLBACK:
+                        result.setConsumeResult(CMResult.CR_ROLLBACK);
+                        break;
+                    case SUCCESS:
+                        result.setConsumeResult(CMResult.CR_SUCCESS);
+                        break;
+                    case SUSPEND_CURRENT_QUEUE_A_MOMENT:
+                        result.setConsumeResult(CMResult.CR_LATER);
+                        break;
+                    default:
+                        break;
+                }
+            } else {
+                result.setConsumeResult(CMResult.CR_RETURN_NULL);
+            }
+            AtomicInteger currentStageOffset = getCurrentStageOffset(messageQueue, topic, strategyId, groupId);
+            synchronized (currentStageOffset) {
+                int original = currentStageOffset.get();
+                this.messageListener.rollbackCurrentStageOffsetIfNeed(topic, strategyId, groupId, currentStageOffset, msgs);
+                currentStageOffset.set(original);
+            }
+        } catch (Throwable e) {
+            result.setConsumeResult(CMResult.CR_THROW_EXCEPTION);
+            result.setRemark(RemotingHelper.exceptionSimpleDesc(e));
+
+            log.warn(String.format(""consumeMessageDirectly exception: %s Group: %s Msgs: %s MQ: %s"",
+                RemotingHelper.exceptionSimpleDesc(e),
+                ConsumeMessageStagedConcurrentlyService.this.consumerGroup,
+                msgs,
+                mq), e);
+        }
+        result.setAutoCommit(context.isAutoCommit());
+        result.setSpentTimeMills(System.currentTimeMillis() - beginTime);
+
+        log.info(""consumeMessageDirectly Result: {}"", result);
+
+        return result;
+    }
+
+    @Override
+    public void submitConsumeRequest(
+        final List<MessageExt> msgs,
+        final ProcessQueue processQueue,
+        final MessageQueue messageQueue,
+        final boolean dispatchToConsume) {
+        if (dispatchToConsume) {
+            DispatchRequest dispatchRequest = new DispatchRequest(processQueue, messageQueue);
+            this.dispatchExecutor.submit(dispatchRequest);
+        }
+    }
+
+    public synchronized void lockMQPeriodically() {
+        if (!this.stopped) {
+            this.defaultMQPushConsumerImpl.getRebalanceImpl().lockAll();
+        }
+    }
+
+    public void tryLockLaterAndReconsume(final MessageQueue mq, final ProcessQueue processQueue,
+        final long delayMills) {
+        this.scheduledExecutorService.schedule(new Runnable() {
+            @Override
+            public void run() {
+                boolean lockOK = ConsumeMessageStagedConcurrentlyService.this.lockOneMQ(mq);
+                if (lockOK) {
+                    ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequestLater(processQueue, mq, 10);
+                } else {
+                    ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequestLater(processQueue, mq, 3000);
+                }
+            }
+        }, delayMills, TimeUnit.MILLISECONDS);
+    }
+
+    public synchronized boolean lockOneMQ(final MessageQueue mq) {
+        if (!this.stopped) {
+            return this.defaultMQPushConsumerImpl.getRebalanceImpl().lock(mq);
+        }
+
+        return false;
+    }
+
+    private void submitConsumeRequestLater(
+        final ProcessQueue processQueue,
+        final MessageQueue messageQueue,
+        final long suspendTimeMillis
+    ) {
+        long timeMillis = suspendTimeMillis;
+        if (timeMillis == -1) {
+            timeMillis = this.defaultMQPushConsumer.getSuspendCurrentQueueTimeMillis();
+        }
+
+        if (timeMillis < 10) {
+            timeMillis = 10;
+        } else if (timeMillis > 30000) {
+            timeMillis = 30000;
+        }
+
+        this.scheduledExecutorService.schedule(new Runnable() {
+
+            @Override
+            public void run() {
+                ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequest(null, processQueue, messageQueue, true);
+            }
+        }, timeMillis, TimeUnit.MILLISECONDS);
+    }
+
+    public boolean processConsumeResult(
+        final String strategyId,
+        final String groupId,
+        final List<MessageExt> msgs,
+        final ConsumeOrderlyStatus status,
+        final ConsumeStagedConcurrentlyContext context,
+        final ConsumeRequest consumeRequest
+    ) {
+        MessageQueue messageQueue = consumeRequest.getMessageQueue();
+        String topic = messageQueue.getTopic();
+        AtomicInteger currentStageOffset = getCurrentStageOffset(messageQueue, topic, strategyId, groupId);
+        boolean continueConsume = true;
+        long commitOffset = -1L;
+        int commitStageOffset = -1;
+        if (context.isAutoCommit()) {
+            switch (status) {
+                case COMMIT:
+                case ROLLBACK:
+                    log.warn(""the message queue consume result is illegal, we think you want to ack these message {}"",
+                        messageQueue);
+                case SUCCESS:
+                    commitOffset = consumeRequest.getProcessQueue().commitMessages(msgs);
+                    commitStageOffset = currentStageOffset.get();
+                    this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, topic, msgs.size());
+                    break;
+                case SUSPEND_CURRENT_QUEUE_A_MOMENT:
+                    synchronized (currentStageOffset) {
+                        currentStageOffset.set(currentStageOffset.get() - msgs.size());
+                    }
+                    this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, topic, msgs.size());
+                    if (checkReconsumeTimes(msgs)) {
+                        consumeRequest.getProcessQueue().makeMessageToConsumeAgain(msgs);
+                        this.submitConsumeRequestLater(
+                            consumeRequest.getProcessQueue(),
+                            messageQueue,
+                            context.getSuspendCurrentQueueTimeMillis());
+                        continueConsume = false;
+                    } else {
+                        commitOffset = consumeRequest.getProcessQueue().commitMessages(msgs);
+                        commitStageOffset = currentStageOffset.get();
+                    }
+                    break;
+                default:
+                    break;
+            }
+        } else {
+            switch (status) {
+                case SUCCESS:
+                    this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, topic, msgs.size());
+                    break;
+                case COMMIT:
+                    commitOffset = consumeRequest.getProcessQueue().commitMessages(msgs);
+                    commitStageOffset = currentStageOffset.get();
+                    break;
+                case ROLLBACK:
+                    consumeRequest.getProcessQueue().rollback();
+                    this.submitConsumeRequestLater(
+                        consumeRequest.getProcessQueue(),
+                        messageQueue,
+                        context.getSuspendCurrentQueueTimeMillis());
+                    continueConsume = false;
+                    break;
+                case SUSPEND_CURRENT_QUEUE_A_MOMENT:
+                    synchronized (currentStageOffset) {
+                        currentStageOffset.set(currentStageOffset.get() - msgs.size());
+                    }
+                    this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, topic, msgs.size());
+                    if (checkReconsumeTimes(msgs)) {
+                        consumeRequest.getProcessQueue().makeMessageToConsumeAgain(msgs);
+                        this.submitConsumeRequestLater(
+                            consumeRequest.getProcessQueue(),
+                            messageQueue,
+                            context.getSuspendCurrentQueueTimeMillis());
+                        continueConsume = false;
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        if (commitOffset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {
+            this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(messageQueue, commitOffset, false);
+        }
+
+        if (stageOffsetStore != null && commitStageOffset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {
+            synchronized (currentStageOffset) {
+                messageListener.rollbackCurrentStageOffsetIfNeed(topic, strategyId, groupId, currentStageOffset, msgs);
+                //prevent users from resetting the value of currentStageOffset to a value less than 0
+                currentStageOffset.set(Math.max(0, currentStageOffset.get()));
+            }
+            commitStageOffset = currentStageOffset.get();
+            if (!consumeRequest.getProcessQueue().isDropped()) {
+                stageOffsetStore.updateStageOffset(messageQueue, strategyId, groupId, commitStageOffset, false);
+            }
+        }
+
+        return continueConsume;
+    }
+
+    public ConsumerStatsManager getConsumerStatsManager() {
+        return this.defaultMQPushConsumerImpl.getConsumerStatsManager();
+    }
+
+    private int getMaxReconsumeTimes() {
+        // default reconsume times: Integer.MAX_VALUE
+        if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) {
+            return Integer.MAX_VALUE;
+        } else {
+            return this.defaultMQPushConsumer.getMaxReconsumeTimes();
+        }
+    }
+
+    private boolean checkReconsumeTimes(List<MessageExt> msgs) {
+        boolean suspend = false;
+        if (msgs != null && !msgs.isEmpty()) {
+            for (MessageExt msg : msgs) {
+                if (msg.getReconsumeTimes() >= getMaxReconsumeTimes()) {
+                    MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes()));
+                    if (!sendMessageBack(msg)) {
+                        suspend = true;
+                        msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
+                    }
+                } else {
+                    suspend = true;
+                    msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
+                }
+            }
+        }
+        return suspend;
+    }
+
+    public boolean sendMessageBack(final MessageExt msg) {
+        try {
+            // max reconsume times exceeded then send to dead letter queue.
+            Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());
+            String originMsgId = MessageAccessor.getOriginMessageId(msg);
+            MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);
+            newMsg.setFlag(msg.getFlag());
+            MessageAccessor.setProperties(newMsg, msg.getProperties());
+            MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());
+            MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes()));
+            MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));
+            MessageAccessor.clearProperty(newMsg, MessageConst.PROPERTY_TRANSACTION_PREPARED);
+            newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());
+
+            this.defaultMQPushConsumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getDefaultMQProducer().send(newMsg);
+            return true;
+        } catch (Exception e) {
+            log.error(""sendMessageBack exception, group: "" + this.consumerGroup + "" msg: "" + msg.toString(), e);
+        }
+
+        return false;
+    }
+
+    public void resetNamespace(final List<MessageExt> msgs) {
+        for (MessageExt msg : msgs) {
+            if (StringUtils.isNotEmpty(this.defaultMQPushConsumer.getNamespace())) {
+                msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace()));
+            }
+        }
+    }
+
+    class DispatchRequest implements Runnable {
+        private final ProcessQueue processQueue;
+        private final MessageQueue messageQueue;
+
+        public DispatchRequest(ProcessQueue processQueue,
+            MessageQueue messageQueue) {
+            this.processQueue = processQueue;
+            this.messageQueue = messageQueue;
+        }
+
+        @Override
+        public void run() {
+            if (this.processQueue.isDropped()) {
+                log.warn(""run, the message queue not be able to consume, because it's dropped. {}"", this.messageQueue);
+                return;
+            }
+
+            String topic = this.messageQueue.getTopic();
+            final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue);
+            synchronized (objLock) {
+                if (MessageModel.BROADCASTING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())
+                    || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) {
+                    final long beginTime = System.currentTimeMillis();
+                    for (final AtomicBoolean continueConsume = new AtomicBoolean(true); continueConsume.get(); ) {
+                        if (this.processQueue.isDropped()) {
+                            log.warn(""the message queue not be able to consume, because it's dropped. {}"", this.messageQueue);
+                            break;
+                        }
+
+                        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())
+                            && !this.processQueue.isLocked()) {
+                            log.warn(""the message queue not locked, so consume later, {}"", this.messageQueue);
+                            ConsumeMessageStagedConcurrentlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
+                            break;
+                        }
+
+                        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())
+                            && this.processQueue.isLockExpired()) {
+                            log.warn(""the message queue lock expired, so consume later, {}"", this.messageQueue);
+                            ConsumeMessageStagedConcurrentlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
+                            break;
+                        }
+
+                        long interval = System.currentTimeMillis() - beginTime;
+                        if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {
+                            ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10);
+                            break;
+                        }
+
+                        final int consumeBatchSize =
+                            ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();
+                        int takeSize = ConsumeMessageStagedConcurrentlyService.this.pullBatchSize * consumeBatchSize;
+                        List<MessageExt> msgs = this.processQueue.takeMessages(takeSize);
+                        if (!msgs.isEmpty()) {
+                            //ensure that the stage definitions is up to date
+                            ConsumeMessageStagedConcurrentlyService.this.refreshStageDefinition();
+                            Map<String, Map<String, List<MessageExt>>> messageGroupByStrategyThenGroup = removeAndRePutAllMessagesInTheNextStage(topic, msgs);
+                            for (Map.Entry<String, Map<String, List<MessageExt>>> entry : messageGroupByStrategyThenGroup.entrySet()) {
+                                String strategyId = entry.getKey();
+                                Map<String, List<MessageExt>> messageGroups = entry.getValue();
+                                for (Map.Entry<String, List<MessageExt>> innerEntry : messageGroups.entrySet()) {
+                                    String groupId = innerEntry.getKey();
+                                    List<MessageExt> messagesCanConsume = innerEntry.getValue();
+                                    List<List<MessageExt>> lists = UtilAll.partition(messagesCanConsume, consumeBatchSize);
+                                    for (final List<MessageExt> list : lists) {
+                                        defaultMQPushConsumerImpl.resetRetryAndNamespace(list, defaultMQPushConsumer.getConsumerGroup());
+                                        int currentLeftoverStageIndex =
+                                            ConsumeMessageStagedConcurrentlyService.this.getCurrentLeftoverStageIndexAndUpdate(this.messageQueue, topic, strategyId, groupId, list.size());
+                                        ConsumeRequest consumeRequest = new ConsumeRequest(list, this.processQueue, this.messageQueue, continueConsume, currentLeftoverStageIndex, strategyId, groupId);
+                                        if (currentLeftoverStageIndex >= 0) {
+                                            engine.runPriorityAsync(currentLeftoverStageIndex, consumeRequest);
+                                        } else {
+                                            //If the strategy Id is null, it will go in this case
+                                            engine.runPriorityAsync(consumeRequest);
+                                        }
+                                    }
+                                }
+                            }
+                        } else {
+                            continueConsume.set(false);
+                        }
+                    }
+                } else {
+                    if (this.processQueue.isDropped()) {
+                        log.warn(""the message queue not be able to consume, because it's dropped. {}"", this.messageQueue);
+                        return;
+                    }
+
+                    ConsumeMessageStagedConcurrentlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100);
+                }
+            }
+        }
+
+        private Map<String, Map<String, List<MessageExt>>> removeAndRePutAllMessagesInTheNextStage(String topic,
+            List<MessageExt> msgs) {
+            Map<String, Map<String, List<MessageExt>>> messageGroupByStrategyThenGroup = new LinkedHashMap<>();
+            for (MessageExt message : msgs) {
+                String strategyId = NULL;
+                try {
+                    strategyId = String.valueOf(messageListener.computeStrategy(message));
+                } catch (Exception e) {
+                    log.error(""computeStrategy failed with exception:"" + e.getMessage() + "" !"");
+                }
+                String groupId = NULL;
+                try {
+                    groupId = String.valueOf(messageListener.computeGroup(message));
+                } catch (Exception e) {
+                    log.error(""computeGroup failed with exception:"" + e.getMessage() + "" !"");
+                }
+                //null strategy means direct concurrency
+                Map<String, List<MessageExt>> messageGroupByStrategy = messageGroupByStrategyThenGroup.putIfAbsent(strategyId, new LinkedHashMap<>());","[{'comment': 'Optimistically assuming that the element does not exist, and using `putIfAbsent` is inefficient', 'commenter': 'ifplusor'}]"
2983,client/src/main/java/org/apache/rocketmq/client/impl/consumer/ConsumeMessageStagedConcurrentlyService.java,"@@ -0,0 +1,872 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.client.impl.consumer;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.collections.MapUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;
+import org.apache.rocketmq.client.consumer.listener.ConsumeReturnType;
+import org.apache.rocketmq.client.consumer.listener.ConsumeStagedConcurrentlyContext;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerStagedConcurrently;
+import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
+import org.apache.rocketmq.client.consumer.store.StageOffsetStore;
+import org.apache.rocketmq.client.hook.ConsumeMessageContext;
+import org.apache.rocketmq.client.log.ClientLogger;
+import org.apache.rocketmq.client.stat.ConsumerStatsManager;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.common.ThreadFactoryImpl;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.concurrent.PriorityConcurrentEngine;
+import org.apache.rocketmq.common.message.Message;
+import org.apache.rocketmq.common.message.MessageAccessor;
+import org.apache.rocketmq.common.message.MessageConst;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.common.protocol.NamespaceUtil;
+import org.apache.rocketmq.common.protocol.body.CMResult;
+import org.apache.rocketmq.common.protocol.body.ConsumeMessageDirectlyResult;
+import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
+import org.apache.rocketmq.common.utils.ThreadUtils;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.remoting.common.RemotingHelper;
+
+public class ConsumeMessageStagedConcurrentlyService implements ConsumeMessageService {
+    private static final String NULL = ""null"";
+    private static final InternalLogger log = ClientLogger.getLog();
+    private final static long MAX_TIME_CONSUME_CONTINUOUSLY =
+        Long.parseLong(System.getProperty(""rocketmq.client.maxTimeConsumeContinuously"", ""60000""));
+    private final DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;
+    private final DefaultMQPushConsumer defaultMQPushConsumer;
+    private final MessageListenerStagedConcurrently messageListener;
+    private final BlockingQueue<Runnable> consumeRequestQueue;
+    private final ThreadPoolExecutor dispatchExecutor;
+    private final ThreadPoolExecutor consumeExecutor;
+    private final PriorityConcurrentEngine engine;
+    private final String consumerGroup;
+    private final MessageQueueLock messageQueueLock = new MessageQueueLock();
+    private final ScheduledExecutorService scheduledExecutorService;
+    private volatile boolean stopped = false;
+    private final Map<String/*strategyId*/, List<Integer>/*StageDefinition*/> summedStageDefinitionMap;
+    private final ConcurrentMap<String/*topic*/, ConcurrentMap<String/*strategyId*/, ConcurrentMap<String/*groupId*/, AtomicInteger/*currentStageOffset*/>>> currentStageOffsetMap = new ConcurrentHashMap<>();
+    private final int pullBatchSize;
+    private final StageOffsetStore stageOffsetStore;
+
+    public ConsumeMessageStagedConcurrentlyService(DefaultMQPushConsumerImpl defaultMQPushConsumerImpl,
+        MessageListenerStagedConcurrently messageListener) {
+        this.defaultMQPushConsumerImpl = defaultMQPushConsumerImpl;
+        this.messageListener = messageListener;
+        this.summedStageDefinitionMap = new ConcurrentHashMap<>();
+        this.refreshStageDefinition();
+
+        this.stageOffsetStore = this.defaultMQPushConsumerImpl.getStageOffsetStore();
+
+        this.defaultMQPushConsumer = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer();
+        this.consumerGroup = this.defaultMQPushConsumer.getConsumerGroup();
+        this.pullBatchSize = this.defaultMQPushConsumer.getPullBatchSize();
+        this.consumeRequestQueue = new LinkedBlockingQueue<Runnable>();
+
+        int consumeThreadMin = this.defaultMQPushConsumer.getConsumeThreadMin();
+        int consumeThreadMax = this.defaultMQPushConsumer.getConsumeThreadMax();
+        this.dispatchExecutor = new ThreadPoolExecutor(
+            (int) Math.ceil(consumeThreadMin * 1.0 / this.pullBatchSize),
+            (int) Math.ceil(consumeThreadMax * 1.0 / this.pullBatchSize),
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            new LinkedBlockingQueue<Runnable>(),
+            new ThreadFactoryImpl(""DispatchMessageThread_""));
+        // when the number of threads is equal to
+        // the topic consumeQueue size multiplied by this.pullBatchSize,
+        // good performance can be obtained
+        this.consumeExecutor = new ThreadPoolExecutor(
+            consumeThreadMin,
+            consumeThreadMax,
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            this.consumeRequestQueue,
+            new ThreadFactoryImpl(""ConsumeMessageThread_""));
+        engine = new PriorityConcurrentEngine(this.consumeExecutor);
+
+        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(""ConsumeMessageScheduledThread_""));
+    }
+
+    private void refreshStageDefinition() {
+        Map<String, List<Integer>> strategies = messageListener.getStageDefinitionStrategies();
+        if (MapUtils.isNotEmpty(strategies)) {
+            for (Map.Entry<String, List<Integer>> entry : strategies.entrySet()) {
+                String strategyId = entry.getKey();
+                List<Integer> definitions = entry.getValue();
+                List<Integer> summedStageDefinitions = new ArrayList<>();
+                if (definitions != null) {
+                    int sum = 0;
+                    for (Integer stageDefinition : definitions) {
+                        summedStageDefinitions.add(sum = sum + stageDefinition);
+                    }
+                }
+                summedStageDefinitionMap.put(strategyId, summedStageDefinitions);
+            }
+        }
+    }
+
+    @Override
+    public void start() {
+        engine.start();
+        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())) {
+            this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
+                @Override
+                public void run() {
+                    ConsumeMessageStagedConcurrentlyService.this.lockMQPeriodically();
+                }
+            }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    @Override
+    public void shutdown(long awaitTerminateMillis) {
+        this.stopped = true;
+        this.scheduledExecutorService.shutdown();
+        ThreadUtils.shutdownGracefully(this.dispatchExecutor, awaitTerminateMillis, TimeUnit.MILLISECONDS);
+        engine.shutdown(awaitTerminateMillis);
+        if (MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {
+            this.unlockAllMQ();
+        }
+    }
+
+    public synchronized void unlockAllMQ() {
+        this.defaultMQPushConsumerImpl.getRebalanceImpl().unlockAll(false);
+    }
+
+    public AtomicInteger getCurrentStageOffset(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId || NULL.equals(strategyId)) {
+            return new AtomicInteger(-1);
+        }
+        groupId = String.valueOf(groupId);
+        ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> groupByStrategy = currentStageOffsetMap.get(topic);
+        if (null == groupByStrategy) {
+            ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> stageOffset = stageOffsetStore == null ?
+                new ConcurrentHashMap<>() : convert(stageOffsetStore.readStageOffset(messageQueue, ReadOffsetType.MEMORY_FIRST_THEN_STORE));
+            currentStageOffsetMap.putIfAbsent(topic, stageOffset);
+            groupByStrategy = currentStageOffsetMap.get(topic);
+        }
+        ConcurrentMap<String, AtomicInteger> groups = groupByStrategy.putIfAbsent(strategyId, new ConcurrentHashMap<>());
+        if (null == groups) {
+            groups = groupByStrategy.get(strategyId);
+        }
+        groups.putIfAbsent(groupId, new AtomicInteger(0));
+        return groups.get(groupId);
+    }
+
+    private ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> convert(
+        Map<String, Map<String, Integer>> original) {
+        if (null == original) {
+            return new ConcurrentHashMap<>();
+        }
+        ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> map = new ConcurrentHashMap<>(original.size());
+        for (Map.Entry<String, Map<String, Integer>> entry : original.entrySet()) {
+            String strategy = entry.getKey();
+            ConcurrentMap<String, AtomicInteger> temp = new ConcurrentHashMap<>();
+            Map<String, Integer> groups = entry.getValue();
+            for (Map.Entry<String, Integer> innerEntry : groups.entrySet()) {
+                String key = innerEntry.getKey();
+                Integer value = innerEntry.getValue();
+                temp.put(key, new AtomicInteger(value));
+            }
+            map.put(strategy, temp);
+        }
+        return map;
+    }
+
+    public int getCurrentLeftoverStage(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId) {
+            return -1;
+        }
+        List<Integer> summedStageDefinition = summedStageDefinitionMap.get(strategyId);
+        if (CollectionUtils.isNotEmpty(summedStageDefinition)) {
+            for (Integer stageDefinition : summedStageDefinition) {
+                int left = stageDefinition - getCurrentStageOffset(messageQueue, topic, strategyId, groupId).get();
+                if (left > 0) {
+                    return left;
+                }
+            }
+        }
+        return -1;
+    }
+
+    public int getCurrentLeftoverStageIndex(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId) {
+            return -1;
+        }
+        List<Integer> summedStageDefinition = summedStageDefinitionMap.get(strategyId);
+        if (CollectionUtils.isNotEmpty(summedStageDefinition)) {
+            for (int i = 0; i < summedStageDefinition.size(); i++) {
+                int left = summedStageDefinition.get(i) - getCurrentStageOffset(messageQueue, topic, strategyId, groupId).get();
+                if (left > 0) {
+                    return i;
+                }
+            }
+        }
+        return -1;
+    }
+
+    public int getCurrentLeftoverStageIndexAndUpdate(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId, int delta) {
+        final AtomicInteger offset = getCurrentStageOffset(messageQueue, topic, strategyId, groupId);
+        synchronized (offset) {
+            try {
+                return getCurrentLeftoverStageIndex(messageQueue, topic, strategyId, groupId);
+            } finally {
+                offset.getAndAdd(delta);
+            }
+        }
+    }
+
+    @Override
+    public void updateCorePoolSize(int corePoolSize) {
+        if (corePoolSize > 0
+            && corePoolSize <= Short.MAX_VALUE
+            && corePoolSize < this.defaultMQPushConsumer.getConsumeThreadMax()) {
+            this.consumeExecutor.setCorePoolSize(corePoolSize);
+        }
+    }
+
+    @Override
+    public void incCorePoolSize() {
+    }
+
+    @Override
+    public void decCorePoolSize() {
+    }
+
+    @Override
+    public int getCorePoolSize() {
+        return this.consumeExecutor.getCorePoolSize();
+    }
+
+    @Override
+    public ConsumeMessageDirectlyResult consumeMessageDirectly(MessageExt msg, String brokerName) {
+        ConsumeMessageDirectlyResult result = new ConsumeMessageDirectlyResult();
+        result.setOrder(true);
+
+        String topic = msg.getTopic();
+        List<MessageExt> msgs = new ArrayList<MessageExt>();
+        msgs.add(msg);
+        MessageQueue mq = new MessageQueue();
+        mq.setBrokerName(brokerName);
+        mq.setTopic(topic);
+        mq.setQueueId(msg.getQueueId());
+
+        ConsumeStagedConcurrentlyContext context = new ConsumeStagedConcurrentlyContext(mq);
+
+        this.defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, this.consumerGroup);
+
+        final long beginTime = System.currentTimeMillis();
+
+        log.info(""consumeMessageDirectly receive new message: {}"", msg);
+
+        Set<MessageQueue> topicSubscribeInfo = this.defaultMQPushConsumerImpl.getRebalanceImpl().getTopicSubscribeInfo(topic);
+        MessageQueue messageQueue = null;
+        if (CollectionUtils.isNotEmpty(topicSubscribeInfo)) {
+            for (MessageQueue queue : topicSubscribeInfo) {
+                if (queue.getQueueId() == msg.getQueueId()) {
+                    messageQueue = queue;
+                    break;
+                }
+            }
+        }
+
+        try {
+            String strategyId = NULL;
+            try {
+                strategyId = String.valueOf(this.messageListener.computeStrategy(msg));
+            } catch (Exception e) {
+                log.error(""computeStrategy failed with exception:"" + e.getMessage() + "" !"");
+            }
+            String groupId = NULL;
+            try {
+                groupId = String.valueOf(this.messageListener.computeGroup(msg));
+            } catch (Exception e) {
+                log.error(""computeGroup failed with exception:"" + e.getMessage() + "" !"");
+            }
+            context.setStrategyId(strategyId);
+            context.setGroupId(groupId);
+            //the test message should not update the stage offset
+            context.setStageIndex(getCurrentLeftoverStageIndex(messageQueue, topic, strategyId, groupId));
+            ConsumeOrderlyStatus status = this.messageListener.consumeMessage(msgs, context);
+            if (status != null) {
+                switch (status) {
+                    case COMMIT:
+                        result.setConsumeResult(CMResult.CR_COMMIT);
+                        break;
+                    case ROLLBACK:
+                        result.setConsumeResult(CMResult.CR_ROLLBACK);
+                        break;
+                    case SUCCESS:
+                        result.setConsumeResult(CMResult.CR_SUCCESS);
+                        break;
+                    case SUSPEND_CURRENT_QUEUE_A_MOMENT:
+                        result.setConsumeResult(CMResult.CR_LATER);
+                        break;
+                    default:
+                        break;
+                }
+            } else {
+                result.setConsumeResult(CMResult.CR_RETURN_NULL);
+            }
+            AtomicInteger currentStageOffset = getCurrentStageOffset(messageQueue, topic, strategyId, groupId);
+            synchronized (currentStageOffset) {
+                int original = currentStageOffset.get();
+                this.messageListener.rollbackCurrentStageOffsetIfNeed(topic, strategyId, groupId, currentStageOffset, msgs);
+                currentStageOffset.set(original);
+            }
+        } catch (Throwable e) {
+            result.setConsumeResult(CMResult.CR_THROW_EXCEPTION);
+            result.setRemark(RemotingHelper.exceptionSimpleDesc(e));
+
+            log.warn(String.format(""consumeMessageDirectly exception: %s Group: %s Msgs: %s MQ: %s"",
+                RemotingHelper.exceptionSimpleDesc(e),
+                ConsumeMessageStagedConcurrentlyService.this.consumerGroup,
+                msgs,
+                mq), e);
+        }
+        result.setAutoCommit(context.isAutoCommit());
+        result.setSpentTimeMills(System.currentTimeMillis() - beginTime);
+
+        log.info(""consumeMessageDirectly Result: {}"", result);
+
+        return result;
+    }
+
+    @Override
+    public void submitConsumeRequest(
+        final List<MessageExt> msgs,
+        final ProcessQueue processQueue,
+        final MessageQueue messageQueue,
+        final boolean dispatchToConsume) {
+        if (dispatchToConsume) {
+            DispatchRequest dispatchRequest = new DispatchRequest(processQueue, messageQueue);
+            this.dispatchExecutor.submit(dispatchRequest);
+        }
+    }
+
+    public synchronized void lockMQPeriodically() {
+        if (!this.stopped) {
+            this.defaultMQPushConsumerImpl.getRebalanceImpl().lockAll();
+        }
+    }
+
+    public void tryLockLaterAndReconsume(final MessageQueue mq, final ProcessQueue processQueue,
+        final long delayMills) {
+        this.scheduledExecutorService.schedule(new Runnable() {
+            @Override
+            public void run() {
+                boolean lockOK = ConsumeMessageStagedConcurrentlyService.this.lockOneMQ(mq);
+                if (lockOK) {
+                    ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequestLater(processQueue, mq, 10);
+                } else {
+                    ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequestLater(processQueue, mq, 3000);
+                }
+            }
+        }, delayMills, TimeUnit.MILLISECONDS);
+    }
+
+    public synchronized boolean lockOneMQ(final MessageQueue mq) {
+        if (!this.stopped) {
+            return this.defaultMQPushConsumerImpl.getRebalanceImpl().lock(mq);
+        }
+
+        return false;
+    }
+
+    private void submitConsumeRequestLater(
+        final ProcessQueue processQueue,
+        final MessageQueue messageQueue,
+        final long suspendTimeMillis
+    ) {
+        long timeMillis = suspendTimeMillis;
+        if (timeMillis == -1) {
+            timeMillis = this.defaultMQPushConsumer.getSuspendCurrentQueueTimeMillis();
+        }
+
+        if (timeMillis < 10) {
+            timeMillis = 10;
+        } else if (timeMillis > 30000) {
+            timeMillis = 30000;
+        }
+
+        this.scheduledExecutorService.schedule(new Runnable() {
+
+            @Override
+            public void run() {
+                ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequest(null, processQueue, messageQueue, true);
+            }
+        }, timeMillis, TimeUnit.MILLISECONDS);
+    }
+
+    public boolean processConsumeResult(
+        final String strategyId,
+        final String groupId,
+        final List<MessageExt> msgs,
+        final ConsumeOrderlyStatus status,
+        final ConsumeStagedConcurrentlyContext context,
+        final ConsumeRequest consumeRequest
+    ) {
+        MessageQueue messageQueue = consumeRequest.getMessageQueue();
+        String topic = messageQueue.getTopic();
+        AtomicInteger currentStageOffset = getCurrentStageOffset(messageQueue, topic, strategyId, groupId);
+        boolean continueConsume = true;
+        long commitOffset = -1L;
+        int commitStageOffset = -1;
+        if (context.isAutoCommit()) {
+            switch (status) {
+                case COMMIT:
+                case ROLLBACK:
+                    log.warn(""the message queue consume result is illegal, we think you want to ack these message {}"",
+                        messageQueue);
+                case SUCCESS:
+                    commitOffset = consumeRequest.getProcessQueue().commitMessages(msgs);
+                    commitStageOffset = currentStageOffset.get();
+                    this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, topic, msgs.size());
+                    break;
+                case SUSPEND_CURRENT_QUEUE_A_MOMENT:
+                    synchronized (currentStageOffset) {
+                        currentStageOffset.set(currentStageOffset.get() - msgs.size());
+                    }
+                    this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, topic, msgs.size());
+                    if (checkReconsumeTimes(msgs)) {
+                        consumeRequest.getProcessQueue().makeMessageToConsumeAgain(msgs);
+                        this.submitConsumeRequestLater(
+                            consumeRequest.getProcessQueue(),
+                            messageQueue,
+                            context.getSuspendCurrentQueueTimeMillis());
+                        continueConsume = false;
+                    } else {
+                        commitOffset = consumeRequest.getProcessQueue().commitMessages(msgs);
+                        commitStageOffset = currentStageOffset.get();
+                    }
+                    break;
+                default:
+                    break;
+            }
+        } else {
+            switch (status) {
+                case SUCCESS:
+                    this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, topic, msgs.size());
+                    break;
+                case COMMIT:
+                    commitOffset = consumeRequest.getProcessQueue().commitMessages(msgs);
+                    commitStageOffset = currentStageOffset.get();
+                    break;
+                case ROLLBACK:
+                    consumeRequest.getProcessQueue().rollback();
+                    this.submitConsumeRequestLater(
+                        consumeRequest.getProcessQueue(),
+                        messageQueue,
+                        context.getSuspendCurrentQueueTimeMillis());
+                    continueConsume = false;
+                    break;
+                case SUSPEND_CURRENT_QUEUE_A_MOMENT:
+                    synchronized (currentStageOffset) {
+                        currentStageOffset.set(currentStageOffset.get() - msgs.size());
+                    }
+                    this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, topic, msgs.size());
+                    if (checkReconsumeTimes(msgs)) {
+                        consumeRequest.getProcessQueue().makeMessageToConsumeAgain(msgs);
+                        this.submitConsumeRequestLater(
+                            consumeRequest.getProcessQueue(),
+                            messageQueue,
+                            context.getSuspendCurrentQueueTimeMillis());
+                        continueConsume = false;
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        if (commitOffset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {
+            this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(messageQueue, commitOffset, false);
+        }
+
+        if (stageOffsetStore != null && commitStageOffset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {
+            synchronized (currentStageOffset) {
+                messageListener.rollbackCurrentStageOffsetIfNeed(topic, strategyId, groupId, currentStageOffset, msgs);
+                //prevent users from resetting the value of currentStageOffset to a value less than 0
+                currentStageOffset.set(Math.max(0, currentStageOffset.get()));
+            }
+            commitStageOffset = currentStageOffset.get();
+            if (!consumeRequest.getProcessQueue().isDropped()) {
+                stageOffsetStore.updateStageOffset(messageQueue, strategyId, groupId, commitStageOffset, false);
+            }
+        }
+
+        return continueConsume;
+    }
+
+    public ConsumerStatsManager getConsumerStatsManager() {
+        return this.defaultMQPushConsumerImpl.getConsumerStatsManager();
+    }
+
+    private int getMaxReconsumeTimes() {
+        // default reconsume times: Integer.MAX_VALUE
+        if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) {
+            return Integer.MAX_VALUE;
+        } else {
+            return this.defaultMQPushConsumer.getMaxReconsumeTimes();
+        }
+    }
+
+    private boolean checkReconsumeTimes(List<MessageExt> msgs) {
+        boolean suspend = false;
+        if (msgs != null && !msgs.isEmpty()) {
+            for (MessageExt msg : msgs) {
+                if (msg.getReconsumeTimes() >= getMaxReconsumeTimes()) {
+                    MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes()));
+                    if (!sendMessageBack(msg)) {
+                        suspend = true;
+                        msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
+                    }
+                } else {
+                    suspend = true;
+                    msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
+                }
+            }
+        }
+        return suspend;
+    }
+
+    public boolean sendMessageBack(final MessageExt msg) {
+        try {
+            // max reconsume times exceeded then send to dead letter queue.
+            Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());
+            String originMsgId = MessageAccessor.getOriginMessageId(msg);
+            MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);
+            newMsg.setFlag(msg.getFlag());
+            MessageAccessor.setProperties(newMsg, msg.getProperties());
+            MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());
+            MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes()));
+            MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));
+            MessageAccessor.clearProperty(newMsg, MessageConst.PROPERTY_TRANSACTION_PREPARED);
+            newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());
+
+            this.defaultMQPushConsumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getDefaultMQProducer().send(newMsg);
+            return true;
+        } catch (Exception e) {
+            log.error(""sendMessageBack exception, group: "" + this.consumerGroup + "" msg: "" + msg.toString(), e);
+        }
+
+        return false;
+    }
+
+    public void resetNamespace(final List<MessageExt> msgs) {
+        for (MessageExt msg : msgs) {
+            if (StringUtils.isNotEmpty(this.defaultMQPushConsumer.getNamespace())) {
+                msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace()));
+            }
+        }
+    }
+
+    class DispatchRequest implements Runnable {
+        private final ProcessQueue processQueue;
+        private final MessageQueue messageQueue;
+
+        public DispatchRequest(ProcessQueue processQueue,
+            MessageQueue messageQueue) {
+            this.processQueue = processQueue;
+            this.messageQueue = messageQueue;
+        }
+
+        @Override
+        public void run() {
+            if (this.processQueue.isDropped()) {
+                log.warn(""run, the message queue not be able to consume, because it's dropped. {}"", this.messageQueue);
+                return;
+            }
+
+            String topic = this.messageQueue.getTopic();
+            final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue);
+            synchronized (objLock) {
+                if (MessageModel.BROADCASTING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())
+                    || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) {
+                    final long beginTime = System.currentTimeMillis();
+                    for (final AtomicBoolean continueConsume = new AtomicBoolean(true); continueConsume.get(); ) {
+                        if (this.processQueue.isDropped()) {
+                            log.warn(""the message queue not be able to consume, because it's dropped. {}"", this.messageQueue);
+                            break;
+                        }
+
+                        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())
+                            && !this.processQueue.isLocked()) {
+                            log.warn(""the message queue not locked, so consume later, {}"", this.messageQueue);
+                            ConsumeMessageStagedConcurrentlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
+                            break;
+                        }
+
+                        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())
+                            && this.processQueue.isLockExpired()) {
+                            log.warn(""the message queue lock expired, so consume later, {}"", this.messageQueue);
+                            ConsumeMessageStagedConcurrentlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
+                            break;
+                        }
+
+                        long interval = System.currentTimeMillis() - beginTime;
+                        if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {
+                            ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10);
+                            break;
+                        }
+
+                        final int consumeBatchSize =
+                            ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();
+                        int takeSize = ConsumeMessageStagedConcurrentlyService.this.pullBatchSize * consumeBatchSize;
+                        List<MessageExt> msgs = this.processQueue.takeMessages(takeSize);
+                        if (!msgs.isEmpty()) {
+                            //ensure that the stage definitions is up to date
+                            ConsumeMessageStagedConcurrentlyService.this.refreshStageDefinition();
+                            Map<String, Map<String, List<MessageExt>>> messageGroupByStrategyThenGroup = removeAndRePutAllMessagesInTheNextStage(topic, msgs);
+                            for (Map.Entry<String, Map<String, List<MessageExt>>> entry : messageGroupByStrategyThenGroup.entrySet()) {
+                                String strategyId = entry.getKey();
+                                Map<String, List<MessageExt>> messageGroups = entry.getValue();
+                                for (Map.Entry<String, List<MessageExt>> innerEntry : messageGroups.entrySet()) {
+                                    String groupId = innerEntry.getKey();
+                                    List<MessageExt> messagesCanConsume = innerEntry.getValue();
+                                    List<List<MessageExt>> lists = UtilAll.partition(messagesCanConsume, consumeBatchSize);
+                                    for (final List<MessageExt> list : lists) {
+                                        defaultMQPushConsumerImpl.resetRetryAndNamespace(list, defaultMQPushConsumer.getConsumerGroup());
+                                        int currentLeftoverStageIndex =
+                                            ConsumeMessageStagedConcurrentlyService.this.getCurrentLeftoverStageIndexAndUpdate(this.messageQueue, topic, strategyId, groupId, list.size());
+                                        ConsumeRequest consumeRequest = new ConsumeRequest(list, this.processQueue, this.messageQueue, continueConsume, currentLeftoverStageIndex, strategyId, groupId);
+                                        if (currentLeftoverStageIndex >= 0) {
+                                            engine.runPriorityAsync(currentLeftoverStageIndex, consumeRequest);
+                                        } else {
+                                            //If the strategy Id is null, it will go in this case
+                                            engine.runPriorityAsync(consumeRequest);
+                                        }
+                                    }
+                                }
+                            }
+                        } else {
+                            continueConsume.set(false);
+                        }
+                    }
+                } else {
+                    if (this.processQueue.isDropped()) {
+                        log.warn(""the message queue not be able to consume, because it's dropped. {}"", this.messageQueue);
+                        return;
+                    }
+
+                    ConsumeMessageStagedConcurrentlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100);
+                }
+            }
+        }
+
+        private Map<String, Map<String, List<MessageExt>>> removeAndRePutAllMessagesInTheNextStage(String topic,
+            List<MessageExt> msgs) {
+            Map<String, Map<String, List<MessageExt>>> messageGroupByStrategyThenGroup = new LinkedHashMap<>();
+            for (MessageExt message : msgs) {
+                String strategyId = NULL;
+                try {
+                    strategyId = String.valueOf(messageListener.computeStrategy(message));
+                } catch (Exception e) {
+                    log.error(""computeStrategy failed with exception:"" + e.getMessage() + "" !"");
+                }
+                String groupId = NULL;
+                try {
+                    groupId = String.valueOf(messageListener.computeGroup(message));
+                } catch (Exception e) {
+                    log.error(""computeGroup failed with exception:"" + e.getMessage() + "" !"");
+                }
+                //null strategy means direct concurrency
+                Map<String, List<MessageExt>> messageGroupByStrategy = messageGroupByStrategyThenGroup.putIfAbsent(strategyId, new LinkedHashMap<>());
+                if (null == messageGroupByStrategy) {
+                    messageGroupByStrategy = messageGroupByStrategyThenGroup.get(strategyId);
+                }
+                List<MessageExt> messages = messageGroupByStrategy.putIfAbsent(groupId, new CopyOnWriteArrayList<>());","[{'comment': 'ditto', 'commenter': 'ifplusor'}]"
2983,client/src/main/java/org/apache/rocketmq/client/impl/consumer/ConsumeMessageStagedConcurrentlyService.java,"@@ -0,0 +1,872 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.client.impl.consumer;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.collections.MapUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;
+import org.apache.rocketmq.client.consumer.listener.ConsumeReturnType;
+import org.apache.rocketmq.client.consumer.listener.ConsumeStagedConcurrentlyContext;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerStagedConcurrently;
+import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
+import org.apache.rocketmq.client.consumer.store.StageOffsetStore;
+import org.apache.rocketmq.client.hook.ConsumeMessageContext;
+import org.apache.rocketmq.client.log.ClientLogger;
+import org.apache.rocketmq.client.stat.ConsumerStatsManager;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.common.ThreadFactoryImpl;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.concurrent.PriorityConcurrentEngine;
+import org.apache.rocketmq.common.message.Message;
+import org.apache.rocketmq.common.message.MessageAccessor;
+import org.apache.rocketmq.common.message.MessageConst;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.common.protocol.NamespaceUtil;
+import org.apache.rocketmq.common.protocol.body.CMResult;
+import org.apache.rocketmq.common.protocol.body.ConsumeMessageDirectlyResult;
+import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
+import org.apache.rocketmq.common.utils.ThreadUtils;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.remoting.common.RemotingHelper;
+
+public class ConsumeMessageStagedConcurrentlyService implements ConsumeMessageService {
+    private static final String NULL = ""null"";
+    private static final InternalLogger log = ClientLogger.getLog();
+    private final static long MAX_TIME_CONSUME_CONTINUOUSLY =
+        Long.parseLong(System.getProperty(""rocketmq.client.maxTimeConsumeContinuously"", ""60000""));
+    private final DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;
+    private final DefaultMQPushConsumer defaultMQPushConsumer;
+    private final MessageListenerStagedConcurrently messageListener;
+    private final BlockingQueue<Runnable> consumeRequestQueue;
+    private final ThreadPoolExecutor dispatchExecutor;
+    private final ThreadPoolExecutor consumeExecutor;
+    private final PriorityConcurrentEngine engine;
+    private final String consumerGroup;
+    private final MessageQueueLock messageQueueLock = new MessageQueueLock();
+    private final ScheduledExecutorService scheduledExecutorService;
+    private volatile boolean stopped = false;
+    private final Map<String/*strategyId*/, List<Integer>/*StageDefinition*/> summedStageDefinitionMap;
+    private final ConcurrentMap<String/*topic*/, ConcurrentMap<String/*strategyId*/, ConcurrentMap<String/*groupId*/, AtomicInteger/*currentStageOffset*/>>> currentStageOffsetMap = new ConcurrentHashMap<>();
+    private final int pullBatchSize;
+    private final StageOffsetStore stageOffsetStore;
+
+    public ConsumeMessageStagedConcurrentlyService(DefaultMQPushConsumerImpl defaultMQPushConsumerImpl,
+        MessageListenerStagedConcurrently messageListener) {
+        this.defaultMQPushConsumerImpl = defaultMQPushConsumerImpl;
+        this.messageListener = messageListener;
+        this.summedStageDefinitionMap = new ConcurrentHashMap<>();
+        this.refreshStageDefinition();
+
+        this.stageOffsetStore = this.defaultMQPushConsumerImpl.getStageOffsetStore();
+
+        this.defaultMQPushConsumer = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer();
+        this.consumerGroup = this.defaultMQPushConsumer.getConsumerGroup();
+        this.pullBatchSize = this.defaultMQPushConsumer.getPullBatchSize();
+        this.consumeRequestQueue = new LinkedBlockingQueue<Runnable>();
+
+        int consumeThreadMin = this.defaultMQPushConsumer.getConsumeThreadMin();
+        int consumeThreadMax = this.defaultMQPushConsumer.getConsumeThreadMax();
+        this.dispatchExecutor = new ThreadPoolExecutor(
+            (int) Math.ceil(consumeThreadMin * 1.0 / this.pullBatchSize),
+            (int) Math.ceil(consumeThreadMax * 1.0 / this.pullBatchSize),
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            new LinkedBlockingQueue<Runnable>(),
+            new ThreadFactoryImpl(""DispatchMessageThread_""));
+        // when the number of threads is equal to
+        // the topic consumeQueue size multiplied by this.pullBatchSize,
+        // good performance can be obtained
+        this.consumeExecutor = new ThreadPoolExecutor(
+            consumeThreadMin,
+            consumeThreadMax,
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            this.consumeRequestQueue,
+            new ThreadFactoryImpl(""ConsumeMessageThread_""));
+        engine = new PriorityConcurrentEngine(this.consumeExecutor);
+
+        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(""ConsumeMessageScheduledThread_""));
+    }
+
+    private void refreshStageDefinition() {
+        Map<String, List<Integer>> strategies = messageListener.getStageDefinitionStrategies();
+        if (MapUtils.isNotEmpty(strategies)) {
+            for (Map.Entry<String, List<Integer>> entry : strategies.entrySet()) {
+                String strategyId = entry.getKey();
+                List<Integer> definitions = entry.getValue();
+                List<Integer> summedStageDefinitions = new ArrayList<>();
+                if (definitions != null) {
+                    int sum = 0;
+                    for (Integer stageDefinition : definitions) {
+                        summedStageDefinitions.add(sum = sum + stageDefinition);
+                    }
+                }
+                summedStageDefinitionMap.put(strategyId, summedStageDefinitions);
+            }
+        }
+    }
+
+    @Override
+    public void start() {
+        engine.start();
+        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())) {
+            this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
+                @Override
+                public void run() {
+                    ConsumeMessageStagedConcurrentlyService.this.lockMQPeriodically();
+                }
+            }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    @Override
+    public void shutdown(long awaitTerminateMillis) {
+        this.stopped = true;
+        this.scheduledExecutorService.shutdown();
+        ThreadUtils.shutdownGracefully(this.dispatchExecutor, awaitTerminateMillis, TimeUnit.MILLISECONDS);
+        engine.shutdown(awaitTerminateMillis);
+        if (MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {
+            this.unlockAllMQ();
+        }
+    }
+
+    public synchronized void unlockAllMQ() {
+        this.defaultMQPushConsumerImpl.getRebalanceImpl().unlockAll(false);
+    }
+
+    public AtomicInteger getCurrentStageOffset(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId || NULL.equals(strategyId)) {
+            return new AtomicInteger(-1);
+        }
+        groupId = String.valueOf(groupId);
+        ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> groupByStrategy = currentStageOffsetMap.get(topic);
+        if (null == groupByStrategy) {
+            ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> stageOffset = stageOffsetStore == null ?
+                new ConcurrentHashMap<>() : convert(stageOffsetStore.readStageOffset(messageQueue, ReadOffsetType.MEMORY_FIRST_THEN_STORE));
+            currentStageOffsetMap.putIfAbsent(topic, stageOffset);","[{'comment': 'Why associate stage offset about **mq** with **topic**?', 'commenter': 'ifplusor'}, {'comment': 'To report consumption progress', 'commenter': 'loongs-zhang'}, {'comment': 'How to reflect the difference of offset between different mq?', 'commenter': 'ifplusor'}, {'comment': 'For example, there are 5 order messages. The only difference between them is the status(1,2,3,4,5).`stageOffset` means `status index` such as `0 1 2 3 4`, or you mean different MQ instances?', 'commenter': 'loongs-zhang'}]"
2983,client/src/main/java/org/apache/rocketmq/client/impl/consumer/ConsumeMessageStagedConcurrentlyService.java,"@@ -0,0 +1,872 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.client.impl.consumer;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.collections.MapUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;
+import org.apache.rocketmq.client.consumer.listener.ConsumeReturnType;
+import org.apache.rocketmq.client.consumer.listener.ConsumeStagedConcurrentlyContext;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerStagedConcurrently;
+import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
+import org.apache.rocketmq.client.consumer.store.StageOffsetStore;
+import org.apache.rocketmq.client.hook.ConsumeMessageContext;
+import org.apache.rocketmq.client.log.ClientLogger;
+import org.apache.rocketmq.client.stat.ConsumerStatsManager;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.common.ThreadFactoryImpl;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.concurrent.PriorityConcurrentEngine;
+import org.apache.rocketmq.common.message.Message;
+import org.apache.rocketmq.common.message.MessageAccessor;
+import org.apache.rocketmq.common.message.MessageConst;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.common.protocol.NamespaceUtil;
+import org.apache.rocketmq.common.protocol.body.CMResult;
+import org.apache.rocketmq.common.protocol.body.ConsumeMessageDirectlyResult;
+import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
+import org.apache.rocketmq.common.utils.ThreadUtils;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.remoting.common.RemotingHelper;
+
+public class ConsumeMessageStagedConcurrentlyService implements ConsumeMessageService {
+    private static final String NULL = ""null"";
+    private static final InternalLogger log = ClientLogger.getLog();
+    private final static long MAX_TIME_CONSUME_CONTINUOUSLY =
+        Long.parseLong(System.getProperty(""rocketmq.client.maxTimeConsumeContinuously"", ""60000""));
+    private final DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;
+    private final DefaultMQPushConsumer defaultMQPushConsumer;
+    private final MessageListenerStagedConcurrently messageListener;
+    private final BlockingQueue<Runnable> consumeRequestQueue;
+    private final ThreadPoolExecutor dispatchExecutor;
+    private final ThreadPoolExecutor consumeExecutor;
+    private final PriorityConcurrentEngine engine;
+    private final String consumerGroup;
+    private final MessageQueueLock messageQueueLock = new MessageQueueLock();
+    private final ScheduledExecutorService scheduledExecutorService;
+    private volatile boolean stopped = false;
+    private final Map<String/*strategyId*/, List<Integer>/*StageDefinition*/> summedStageDefinitionMap;
+    private final ConcurrentMap<String/*topic*/, ConcurrentMap<String/*strategyId*/, ConcurrentMap<String/*groupId*/, AtomicInteger/*currentStageOffset*/>>> currentStageOffsetMap = new ConcurrentHashMap<>();
+    private final int pullBatchSize;
+    private final StageOffsetStore stageOffsetStore;
+
+    public ConsumeMessageStagedConcurrentlyService(DefaultMQPushConsumerImpl defaultMQPushConsumerImpl,
+        MessageListenerStagedConcurrently messageListener) {
+        this.defaultMQPushConsumerImpl = defaultMQPushConsumerImpl;
+        this.messageListener = messageListener;
+        this.summedStageDefinitionMap = new ConcurrentHashMap<>();
+        this.refreshStageDefinition();
+
+        this.stageOffsetStore = this.defaultMQPushConsumerImpl.getStageOffsetStore();
+
+        this.defaultMQPushConsumer = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer();
+        this.consumerGroup = this.defaultMQPushConsumer.getConsumerGroup();
+        this.pullBatchSize = this.defaultMQPushConsumer.getPullBatchSize();
+        this.consumeRequestQueue = new LinkedBlockingQueue<Runnable>();
+
+        int consumeThreadMin = this.defaultMQPushConsumer.getConsumeThreadMin();
+        int consumeThreadMax = this.defaultMQPushConsumer.getConsumeThreadMax();
+        this.dispatchExecutor = new ThreadPoolExecutor(
+            (int) Math.ceil(consumeThreadMin * 1.0 / this.pullBatchSize),
+            (int) Math.ceil(consumeThreadMax * 1.0 / this.pullBatchSize),
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            new LinkedBlockingQueue<Runnable>(),
+            new ThreadFactoryImpl(""DispatchMessageThread_""));
+        // when the number of threads is equal to
+        // the topic consumeQueue size multiplied by this.pullBatchSize,
+        // good performance can be obtained
+        this.consumeExecutor = new ThreadPoolExecutor(
+            consumeThreadMin,
+            consumeThreadMax,
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            this.consumeRequestQueue,
+            new ThreadFactoryImpl(""ConsumeMessageThread_""));
+        engine = new PriorityConcurrentEngine(this.consumeExecutor);
+
+        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(""ConsumeMessageScheduledThread_""));
+    }
+
+    private void refreshStageDefinition() {
+        Map<String, List<Integer>> strategies = messageListener.getStageDefinitionStrategies();
+        if (MapUtils.isNotEmpty(strategies)) {
+            for (Map.Entry<String, List<Integer>> entry : strategies.entrySet()) {
+                String strategyId = entry.getKey();
+                List<Integer> definitions = entry.getValue();
+                List<Integer> summedStageDefinitions = new ArrayList<>();
+                if (definitions != null) {
+                    int sum = 0;
+                    for (Integer stageDefinition : definitions) {
+                        summedStageDefinitions.add(sum = sum + stageDefinition);
+                    }
+                }
+                summedStageDefinitionMap.put(strategyId, summedStageDefinitions);
+            }
+        }
+    }
+
+    @Override
+    public void start() {
+        engine.start();
+        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())) {
+            this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
+                @Override
+                public void run() {
+                    ConsumeMessageStagedConcurrentlyService.this.lockMQPeriodically();
+                }
+            }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    @Override
+    public void shutdown(long awaitTerminateMillis) {
+        this.stopped = true;
+        this.scheduledExecutorService.shutdown();
+        ThreadUtils.shutdownGracefully(this.dispatchExecutor, awaitTerminateMillis, TimeUnit.MILLISECONDS);
+        engine.shutdown(awaitTerminateMillis);
+        if (MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {
+            this.unlockAllMQ();
+        }
+    }
+
+    public synchronized void unlockAllMQ() {
+        this.defaultMQPushConsumerImpl.getRebalanceImpl().unlockAll(false);
+    }
+
+    public AtomicInteger getCurrentStageOffset(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId || NULL.equals(strategyId)) {
+            return new AtomicInteger(-1);
+        }
+        groupId = String.valueOf(groupId);
+        ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> groupByStrategy = currentStageOffsetMap.get(topic);
+        if (null == groupByStrategy) {
+            ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> stageOffset = stageOffsetStore == null ?
+                new ConcurrentHashMap<>() : convert(stageOffsetStore.readStageOffset(messageQueue, ReadOffsetType.MEMORY_FIRST_THEN_STORE));
+            currentStageOffsetMap.putIfAbsent(topic, stageOffset);
+            groupByStrategy = currentStageOffsetMap.get(topic);
+        }
+        ConcurrentMap<String, AtomicInteger> groups = groupByStrategy.putIfAbsent(strategyId, new ConcurrentHashMap<>());","[{'comment': 'do not use `putIfAbsent`', 'commenter': 'ifplusor'}]"
2983,client/src/main/java/org/apache/rocketmq/client/impl/consumer/ConsumeMessageStagedConcurrentlyService.java,"@@ -0,0 +1,872 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.client.impl.consumer;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.collections.MapUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;
+import org.apache.rocketmq.client.consumer.listener.ConsumeReturnType;
+import org.apache.rocketmq.client.consumer.listener.ConsumeStagedConcurrentlyContext;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerStagedConcurrently;
+import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
+import org.apache.rocketmq.client.consumer.store.StageOffsetStore;
+import org.apache.rocketmq.client.hook.ConsumeMessageContext;
+import org.apache.rocketmq.client.log.ClientLogger;
+import org.apache.rocketmq.client.stat.ConsumerStatsManager;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.common.ThreadFactoryImpl;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.concurrent.PriorityConcurrentEngine;
+import org.apache.rocketmq.common.message.Message;
+import org.apache.rocketmq.common.message.MessageAccessor;
+import org.apache.rocketmq.common.message.MessageConst;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.common.protocol.NamespaceUtil;
+import org.apache.rocketmq.common.protocol.body.CMResult;
+import org.apache.rocketmq.common.protocol.body.ConsumeMessageDirectlyResult;
+import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
+import org.apache.rocketmq.common.utils.ThreadUtils;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.remoting.common.RemotingHelper;
+
+public class ConsumeMessageStagedConcurrentlyService implements ConsumeMessageService {
+    private static final String NULL = ""null"";
+    private static final InternalLogger log = ClientLogger.getLog();
+    private final static long MAX_TIME_CONSUME_CONTINUOUSLY =
+        Long.parseLong(System.getProperty(""rocketmq.client.maxTimeConsumeContinuously"", ""60000""));
+    private final DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;
+    private final DefaultMQPushConsumer defaultMQPushConsumer;
+    private final MessageListenerStagedConcurrently messageListener;
+    private final BlockingQueue<Runnable> consumeRequestQueue;
+    private final ThreadPoolExecutor dispatchExecutor;
+    private final ThreadPoolExecutor consumeExecutor;
+    private final PriorityConcurrentEngine engine;
+    private final String consumerGroup;
+    private final MessageQueueLock messageQueueLock = new MessageQueueLock();
+    private final ScheduledExecutorService scheduledExecutorService;
+    private volatile boolean stopped = false;
+    private final Map<String/*strategyId*/, List<Integer>/*StageDefinition*/> summedStageDefinitionMap;
+    private final ConcurrentMap<String/*topic*/, ConcurrentMap<String/*strategyId*/, ConcurrentMap<String/*groupId*/, AtomicInteger/*currentStageOffset*/>>> currentStageOffsetMap = new ConcurrentHashMap<>();
+    private final int pullBatchSize;
+    private final StageOffsetStore stageOffsetStore;
+
+    public ConsumeMessageStagedConcurrentlyService(DefaultMQPushConsumerImpl defaultMQPushConsumerImpl,
+        MessageListenerStagedConcurrently messageListener) {
+        this.defaultMQPushConsumerImpl = defaultMQPushConsumerImpl;
+        this.messageListener = messageListener;
+        this.summedStageDefinitionMap = new ConcurrentHashMap<>();
+        this.refreshStageDefinition();
+
+        this.stageOffsetStore = this.defaultMQPushConsumerImpl.getStageOffsetStore();
+
+        this.defaultMQPushConsumer = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer();
+        this.consumerGroup = this.defaultMQPushConsumer.getConsumerGroup();
+        this.pullBatchSize = this.defaultMQPushConsumer.getPullBatchSize();
+        this.consumeRequestQueue = new LinkedBlockingQueue<Runnable>();
+
+        int consumeThreadMin = this.defaultMQPushConsumer.getConsumeThreadMin();
+        int consumeThreadMax = this.defaultMQPushConsumer.getConsumeThreadMax();
+        this.dispatchExecutor = new ThreadPoolExecutor(
+            (int) Math.ceil(consumeThreadMin * 1.0 / this.pullBatchSize),
+            (int) Math.ceil(consumeThreadMax * 1.0 / this.pullBatchSize),
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            new LinkedBlockingQueue<Runnable>(),
+            new ThreadFactoryImpl(""DispatchMessageThread_""));
+        // when the number of threads is equal to
+        // the topic consumeQueue size multiplied by this.pullBatchSize,
+        // good performance can be obtained
+        this.consumeExecutor = new ThreadPoolExecutor(
+            consumeThreadMin,
+            consumeThreadMax,
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            this.consumeRequestQueue,
+            new ThreadFactoryImpl(""ConsumeMessageThread_""));
+        engine = new PriorityConcurrentEngine(this.consumeExecutor);
+
+        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(""ConsumeMessageScheduledThread_""));
+    }
+
+    private void refreshStageDefinition() {
+        Map<String, List<Integer>> strategies = messageListener.getStageDefinitionStrategies();
+        if (MapUtils.isNotEmpty(strategies)) {
+            for (Map.Entry<String, List<Integer>> entry : strategies.entrySet()) {
+                String strategyId = entry.getKey();
+                List<Integer> definitions = entry.getValue();
+                List<Integer> summedStageDefinitions = new ArrayList<>();
+                if (definitions != null) {
+                    int sum = 0;
+                    for (Integer stageDefinition : definitions) {
+                        summedStageDefinitions.add(sum = sum + stageDefinition);
+                    }
+                }
+                summedStageDefinitionMap.put(strategyId, summedStageDefinitions);
+            }
+        }
+    }
+
+    @Override
+    public void start() {
+        engine.start();
+        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())) {
+            this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
+                @Override
+                public void run() {
+                    ConsumeMessageStagedConcurrentlyService.this.lockMQPeriodically();
+                }
+            }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    @Override
+    public void shutdown(long awaitTerminateMillis) {
+        this.stopped = true;
+        this.scheduledExecutorService.shutdown();
+        ThreadUtils.shutdownGracefully(this.dispatchExecutor, awaitTerminateMillis, TimeUnit.MILLISECONDS);
+        engine.shutdown(awaitTerminateMillis);
+        if (MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {
+            this.unlockAllMQ();
+        }
+    }
+
+    public synchronized void unlockAllMQ() {
+        this.defaultMQPushConsumerImpl.getRebalanceImpl().unlockAll(false);
+    }
+
+    public AtomicInteger getCurrentStageOffset(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId || NULL.equals(strategyId)) {
+            return new AtomicInteger(-1);
+        }
+        groupId = String.valueOf(groupId);
+        ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> groupByStrategy = currentStageOffsetMap.get(topic);
+        if (null == groupByStrategy) {
+            ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> stageOffset = stageOffsetStore == null ?
+                new ConcurrentHashMap<>() : convert(stageOffsetStore.readStageOffset(messageQueue, ReadOffsetType.MEMORY_FIRST_THEN_STORE));
+            currentStageOffsetMap.putIfAbsent(topic, stageOffset);
+            groupByStrategy = currentStageOffsetMap.get(topic);
+        }
+        ConcurrentMap<String, AtomicInteger> groups = groupByStrategy.putIfAbsent(strategyId, new ConcurrentHashMap<>());
+        if (null == groups) {
+            groups = groupByStrategy.get(strategyId);
+        }
+        groups.putIfAbsent(groupId, new AtomicInteger(0));","[{'comment': 'ditto', 'commenter': 'ifplusor'}]"
2983,common/src/main/java/org/apache/rocketmq/common/concurrent/PriorityConcurrentEngine.java,"@@ -0,0 +1,164 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.common.concurrent;
+
+import java.util.Collection;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentNavigableMap;
+import java.util.concurrent.ConcurrentSkipListMap;
+import java.util.concurrent.ExecutorService;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.rocketmq.common.UtilAll;
+
+public class PriorityConcurrentEngine extends ConcurrentEngine {
+
+    /**
+     * highest priority
+     */
+    public static final Integer MAX_PRIORITY = Integer.MIN_VALUE;
+
+    /**
+     * lowest priority
+     */
+    public static final Integer MIN_PRIORITY = Integer.MAX_VALUE;
+
+    private final StagedConcurrentConsumeService consumeService = new StagedConcurrentConsumeService(this);
+
+    private final ConcurrentNavigableMap<Integer, Queue<Object>> priorityTasks = new ConcurrentSkipListMap<>();
+
+    public PriorityConcurrentEngine() {
+        super();
+    }
+
+    public PriorityConcurrentEngine(ExecutorService enginePool) {
+        super(enginePool);
+    }
+
+    public final void runPriorityAsync(Runnable... tasks) {
+        runPriorityAsync(MIN_PRIORITY, tasks);
+    }
+
+    public final void runPriorityAsync(Queue<Runnable> tasks) {
+        runPriorityAsync(MIN_PRIORITY, tasks);
+    }
+
+    public final void runPriorityAsync(Collection<Runnable> tasks) {
+        runPriorityAsync(MIN_PRIORITY, tasks);
+    }
+
+    public final void runPriorityAsync(Integer priority, Runnable... tasks) {
+        runPriorityAsync(priority, UtilAll.newArrayList(tasks));
+    }
+
+    public final void runPriorityAsync(Integer priority, Queue<? extends Runnable> tasks) {
+        runPriorityAsync(priority, pollAllTask(tasks));
+    }
+
+    public final void runPriorityAsync(Integer priority, Collection<? extends Runnable> tasks) {
+        if (CollectionUtils.isEmpty(tasks)) {
+            return;
+        }
+        Queue<Object> queue = priorityTasks.putIfAbsent(priority, new ConcurrentLinkedQueue<>());","[{'comment': 'call `get` first, and call `pullIfAbsent` if return `null`', 'commenter': 'ifplusor'}, {'comment': 'got it', 'commenter': 'loongs-zhang'}]"
2983,client/src/main/java/org/apache/rocketmq/client/impl/consumer/ConsumeMessageStagedConcurrentlyService.java,"@@ -0,0 +1,872 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.client.impl.consumer;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.collections.MapUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;
+import org.apache.rocketmq.client.consumer.listener.ConsumeReturnType;
+import org.apache.rocketmq.client.consumer.listener.ConsumeStagedConcurrentlyContext;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerStagedConcurrently;
+import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
+import org.apache.rocketmq.client.consumer.store.StageOffsetStore;
+import org.apache.rocketmq.client.hook.ConsumeMessageContext;
+import org.apache.rocketmq.client.log.ClientLogger;
+import org.apache.rocketmq.client.stat.ConsumerStatsManager;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.common.ThreadFactoryImpl;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.concurrent.PriorityConcurrentEngine;
+import org.apache.rocketmq.common.message.Message;
+import org.apache.rocketmq.common.message.MessageAccessor;
+import org.apache.rocketmq.common.message.MessageConst;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.common.protocol.NamespaceUtil;
+import org.apache.rocketmq.common.protocol.body.CMResult;
+import org.apache.rocketmq.common.protocol.body.ConsumeMessageDirectlyResult;
+import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
+import org.apache.rocketmq.common.utils.ThreadUtils;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.remoting.common.RemotingHelper;
+
+public class ConsumeMessageStagedConcurrentlyService implements ConsumeMessageService {
+    private static final String NULL = ""null"";
+    private static final InternalLogger log = ClientLogger.getLog();
+    private final static long MAX_TIME_CONSUME_CONTINUOUSLY =
+        Long.parseLong(System.getProperty(""rocketmq.client.maxTimeConsumeContinuously"", ""60000""));
+    private final DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;
+    private final DefaultMQPushConsumer defaultMQPushConsumer;
+    private final MessageListenerStagedConcurrently messageListener;
+    private final BlockingQueue<Runnable> consumeRequestQueue;
+    private final ThreadPoolExecutor dispatchExecutor;
+    private final ThreadPoolExecutor consumeExecutor;
+    private final PriorityConcurrentEngine engine;
+    private final String consumerGroup;
+    private final MessageQueueLock messageQueueLock = new MessageQueueLock();
+    private final ScheduledExecutorService scheduledExecutorService;
+    private volatile boolean stopped = false;
+    private final Map<String/*strategyId*/, List<Integer>/*StageDefinition*/> summedStageDefinitionMap;
+    private final ConcurrentMap<String/*topic*/, ConcurrentMap<String/*strategyId*/, ConcurrentMap<String/*groupId*/, AtomicInteger/*currentStageOffset*/>>> currentStageOffsetMap = new ConcurrentHashMap<>();
+    private final int pullBatchSize;
+    private final StageOffsetStore stageOffsetStore;
+
+    public ConsumeMessageStagedConcurrentlyService(DefaultMQPushConsumerImpl defaultMQPushConsumerImpl,
+        MessageListenerStagedConcurrently messageListener) {
+        this.defaultMQPushConsumerImpl = defaultMQPushConsumerImpl;
+        this.messageListener = messageListener;
+        this.summedStageDefinitionMap = new ConcurrentHashMap<>();
+        this.refreshStageDefinition();
+
+        this.stageOffsetStore = this.defaultMQPushConsumerImpl.getStageOffsetStore();
+
+        this.defaultMQPushConsumer = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer();
+        this.consumerGroup = this.defaultMQPushConsumer.getConsumerGroup();
+        this.pullBatchSize = this.defaultMQPushConsumer.getPullBatchSize();
+        this.consumeRequestQueue = new LinkedBlockingQueue<Runnable>();
+
+        int consumeThreadMin = this.defaultMQPushConsumer.getConsumeThreadMin();
+        int consumeThreadMax = this.defaultMQPushConsumer.getConsumeThreadMax();
+        this.dispatchExecutor = new ThreadPoolExecutor(
+            (int) Math.ceil(consumeThreadMin * 1.0 / this.pullBatchSize),
+            (int) Math.ceil(consumeThreadMax * 1.0 / this.pullBatchSize),
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            new LinkedBlockingQueue<Runnable>(),
+            new ThreadFactoryImpl(""DispatchMessageThread_""));
+        // when the number of threads is equal to
+        // the topic consumeQueue size multiplied by this.pullBatchSize,
+        // good performance can be obtained
+        this.consumeExecutor = new ThreadPoolExecutor(
+            consumeThreadMin,
+            consumeThreadMax,
+            1000 * 60,
+            TimeUnit.MILLISECONDS,
+            this.consumeRequestQueue,
+            new ThreadFactoryImpl(""ConsumeMessageThread_""));
+        engine = new PriorityConcurrentEngine(this.consumeExecutor);
+
+        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(""ConsumeMessageScheduledThread_""));
+    }
+
+    private void refreshStageDefinition() {
+        Map<String, List<Integer>> strategies = messageListener.getStageDefinitionStrategies();
+        if (MapUtils.isNotEmpty(strategies)) {
+            for (Map.Entry<String, List<Integer>> entry : strategies.entrySet()) {
+                String strategyId = entry.getKey();
+                List<Integer> definitions = entry.getValue();
+                List<Integer> summedStageDefinitions = new ArrayList<>();
+                if (definitions != null) {
+                    int sum = 0;
+                    for (Integer stageDefinition : definitions) {
+                        summedStageDefinitions.add(sum = sum + stageDefinition);
+                    }
+                }
+                summedStageDefinitionMap.put(strategyId, summedStageDefinitions);
+            }
+        }
+    }
+
+    @Override
+    public void start() {
+        engine.start();
+        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())) {
+            this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
+                @Override
+                public void run() {
+                    ConsumeMessageStagedConcurrentlyService.this.lockMQPeriodically();
+                }
+            }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    @Override
+    public void shutdown(long awaitTerminateMillis) {
+        this.stopped = true;
+        this.scheduledExecutorService.shutdown();
+        ThreadUtils.shutdownGracefully(this.dispatchExecutor, awaitTerminateMillis, TimeUnit.MILLISECONDS);
+        engine.shutdown(awaitTerminateMillis);
+        if (MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {
+            this.unlockAllMQ();
+        }
+    }
+
+    public synchronized void unlockAllMQ() {
+        this.defaultMQPushConsumerImpl.getRebalanceImpl().unlockAll(false);
+    }
+
+    public AtomicInteger getCurrentStageOffset(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId || NULL.equals(strategyId)) {
+            return new AtomicInteger(-1);
+        }
+        groupId = String.valueOf(groupId);
+        ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> groupByStrategy = currentStageOffsetMap.get(topic);
+        if (null == groupByStrategy) {
+            ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> stageOffset = stageOffsetStore == null ?
+                new ConcurrentHashMap<>() : convert(stageOffsetStore.readStageOffset(messageQueue, ReadOffsetType.MEMORY_FIRST_THEN_STORE));
+            currentStageOffsetMap.putIfAbsent(topic, stageOffset);
+            groupByStrategy = currentStageOffsetMap.get(topic);
+        }
+        ConcurrentMap<String, AtomicInteger> groups = groupByStrategy.putIfAbsent(strategyId, new ConcurrentHashMap<>());
+        if (null == groups) {
+            groups = groupByStrategy.get(strategyId);
+        }
+        groups.putIfAbsent(groupId, new AtomicInteger(0));
+        return groups.get(groupId);
+    }
+
+    private ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> convert(
+        Map<String, Map<String, Integer>> original) {
+        if (null == original) {
+            return new ConcurrentHashMap<>();
+        }
+        ConcurrentMap<String, ConcurrentMap<String, AtomicInteger>> map = new ConcurrentHashMap<>(original.size());
+        for (Map.Entry<String, Map<String, Integer>> entry : original.entrySet()) {
+            String strategy = entry.getKey();
+            ConcurrentMap<String, AtomicInteger> temp = new ConcurrentHashMap<>();
+            Map<String, Integer> groups = entry.getValue();
+            for (Map.Entry<String, Integer> innerEntry : groups.entrySet()) {
+                String key = innerEntry.getKey();
+                Integer value = innerEntry.getValue();
+                temp.put(key, new AtomicInteger(value));
+            }
+            map.put(strategy, temp);
+        }
+        return map;
+    }
+
+    public int getCurrentLeftoverStage(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId) {
+            return -1;
+        }
+        List<Integer> summedStageDefinition = summedStageDefinitionMap.get(strategyId);
+        if (CollectionUtils.isNotEmpty(summedStageDefinition)) {
+            for (Integer stageDefinition : summedStageDefinition) {
+                int left = stageDefinition - getCurrentStageOffset(messageQueue, topic, strategyId, groupId).get();
+                if (left > 0) {
+                    return left;
+                }
+            }
+        }
+        return -1;
+    }
+
+    public int getCurrentLeftoverStageIndex(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId) {
+        if (null == strategyId) {
+            return -1;
+        }
+        List<Integer> summedStageDefinition = summedStageDefinitionMap.get(strategyId);
+        if (CollectionUtils.isNotEmpty(summedStageDefinition)) {
+            for (int i = 0; i < summedStageDefinition.size(); i++) {
+                int left = summedStageDefinition.get(i) - getCurrentStageOffset(messageQueue, topic, strategyId, groupId).get();
+                if (left > 0) {
+                    return i;
+                }
+            }
+        }
+        return -1;
+    }
+
+    public int getCurrentLeftoverStageIndexAndUpdate(MessageQueue messageQueue, String topic, String strategyId,
+        String groupId, int delta) {
+        final AtomicInteger offset = getCurrentStageOffset(messageQueue, topic, strategyId, groupId);
+        synchronized (offset) {
+            try {
+                return getCurrentLeftoverStageIndex(messageQueue, topic, strategyId, groupId);
+            } finally {
+                offset.getAndAdd(delta);
+            }
+        }
+    }
+
+    @Override
+    public void updateCorePoolSize(int corePoolSize) {
+        if (corePoolSize > 0
+            && corePoolSize <= Short.MAX_VALUE
+            && corePoolSize < this.defaultMQPushConsumer.getConsumeThreadMax()) {
+            this.consumeExecutor.setCorePoolSize(corePoolSize);
+        }
+    }
+
+    @Override
+    public void incCorePoolSize() {
+    }
+
+    @Override
+    public void decCorePoolSize() {
+    }
+
+    @Override
+    public int getCorePoolSize() {
+        return this.consumeExecutor.getCorePoolSize();
+    }
+
+    @Override
+    public ConsumeMessageDirectlyResult consumeMessageDirectly(MessageExt msg, String brokerName) {
+        ConsumeMessageDirectlyResult result = new ConsumeMessageDirectlyResult();
+        result.setOrder(true);
+
+        String topic = msg.getTopic();
+        List<MessageExt> msgs = new ArrayList<MessageExt>();
+        msgs.add(msg);
+        MessageQueue mq = new MessageQueue();
+        mq.setBrokerName(brokerName);
+        mq.setTopic(topic);
+        mq.setQueueId(msg.getQueueId());
+
+        ConsumeStagedConcurrentlyContext context = new ConsumeStagedConcurrentlyContext(mq);
+
+        this.defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, this.consumerGroup);
+
+        final long beginTime = System.currentTimeMillis();
+
+        log.info(""consumeMessageDirectly receive new message: {}"", msg);
+
+        Set<MessageQueue> topicSubscribeInfo = this.defaultMQPushConsumerImpl.getRebalanceImpl().getTopicSubscribeInfo(topic);
+        MessageQueue messageQueue = null;
+        if (CollectionUtils.isNotEmpty(topicSubscribeInfo)) {
+            for (MessageQueue queue : topicSubscribeInfo) {
+                if (queue.getQueueId() == msg.getQueueId()) {
+                    messageQueue = queue;
+                    break;
+                }
+            }
+        }
+
+        try {
+            String strategyId = NULL;
+            try {
+                strategyId = String.valueOf(this.messageListener.computeStrategy(msg));
+            } catch (Exception e) {
+                log.error(""computeStrategy failed with exception:"" + e.getMessage() + "" !"");
+            }
+            String groupId = NULL;
+            try {
+                groupId = String.valueOf(this.messageListener.computeGroup(msg));
+            } catch (Exception e) {
+                log.error(""computeGroup failed with exception:"" + e.getMessage() + "" !"");
+            }
+            context.setStrategyId(strategyId);
+            context.setGroupId(groupId);
+            //the test message should not update the stage offset
+            context.setStageIndex(getCurrentLeftoverStageIndex(messageQueue, topic, strategyId, groupId));
+            ConsumeOrderlyStatus status = this.messageListener.consumeMessage(msgs, context);
+            if (status != null) {
+                switch (status) {
+                    case COMMIT:
+                        result.setConsumeResult(CMResult.CR_COMMIT);
+                        break;
+                    case ROLLBACK:
+                        result.setConsumeResult(CMResult.CR_ROLLBACK);
+                        break;
+                    case SUCCESS:
+                        result.setConsumeResult(CMResult.CR_SUCCESS);
+                        break;
+                    case SUSPEND_CURRENT_QUEUE_A_MOMENT:
+                        result.setConsumeResult(CMResult.CR_LATER);
+                        break;
+                    default:
+                        break;
+                }
+            } else {
+                result.setConsumeResult(CMResult.CR_RETURN_NULL);
+            }
+            AtomicInteger currentStageOffset = getCurrentStageOffset(messageQueue, topic, strategyId, groupId);
+            synchronized (currentStageOffset) {
+                int original = currentStageOffset.get();
+                this.messageListener.rollbackCurrentStageOffsetIfNeed(topic, strategyId, groupId, currentStageOffset, msgs);
+                currentStageOffset.set(original);
+            }
+        } catch (Throwable e) {
+            result.setConsumeResult(CMResult.CR_THROW_EXCEPTION);
+            result.setRemark(RemotingHelper.exceptionSimpleDesc(e));
+
+            log.warn(String.format(""consumeMessageDirectly exception: %s Group: %s Msgs: %s MQ: %s"",
+                RemotingHelper.exceptionSimpleDesc(e),
+                ConsumeMessageStagedConcurrentlyService.this.consumerGroup,
+                msgs,
+                mq), e);
+        }
+        result.setAutoCommit(context.isAutoCommit());
+        result.setSpentTimeMills(System.currentTimeMillis() - beginTime);
+
+        log.info(""consumeMessageDirectly Result: {}"", result);
+
+        return result;
+    }
+
+    @Override
+    public void submitConsumeRequest(
+        final List<MessageExt> msgs,
+        final ProcessQueue processQueue,
+        final MessageQueue messageQueue,
+        final boolean dispatchToConsume) {
+        if (dispatchToConsume) {
+            DispatchRequest dispatchRequest = new DispatchRequest(processQueue, messageQueue);
+            this.dispatchExecutor.submit(dispatchRequest);
+        }
+    }
+
+    public synchronized void lockMQPeriodically() {
+        if (!this.stopped) {
+            this.defaultMQPushConsumerImpl.getRebalanceImpl().lockAll();
+        }
+    }
+
+    public void tryLockLaterAndReconsume(final MessageQueue mq, final ProcessQueue processQueue,
+        final long delayMills) {
+        this.scheduledExecutorService.schedule(new Runnable() {
+            @Override
+            public void run() {
+                boolean lockOK = ConsumeMessageStagedConcurrentlyService.this.lockOneMQ(mq);
+                if (lockOK) {
+                    ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequestLater(processQueue, mq, 10);
+                } else {
+                    ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequestLater(processQueue, mq, 3000);
+                }
+            }
+        }, delayMills, TimeUnit.MILLISECONDS);
+    }
+
+    public synchronized boolean lockOneMQ(final MessageQueue mq) {
+        if (!this.stopped) {
+            return this.defaultMQPushConsumerImpl.getRebalanceImpl().lock(mq);
+        }
+
+        return false;
+    }
+
+    private void submitConsumeRequestLater(
+        final ProcessQueue processQueue,
+        final MessageQueue messageQueue,
+        final long suspendTimeMillis
+    ) {
+        long timeMillis = suspendTimeMillis;
+        if (timeMillis == -1) {
+            timeMillis = this.defaultMQPushConsumer.getSuspendCurrentQueueTimeMillis();
+        }
+
+        if (timeMillis < 10) {
+            timeMillis = 10;
+        } else if (timeMillis > 30000) {
+            timeMillis = 30000;
+        }
+
+        this.scheduledExecutorService.schedule(new Runnable() {
+
+            @Override
+            public void run() {
+                ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequest(null, processQueue, messageQueue, true);
+            }
+        }, timeMillis, TimeUnit.MILLISECONDS);
+    }
+
+    public boolean processConsumeResult(
+        final String strategyId,
+        final String groupId,
+        final List<MessageExt> msgs,
+        final ConsumeOrderlyStatus status,
+        final ConsumeStagedConcurrentlyContext context,
+        final ConsumeRequest consumeRequest
+    ) {
+        MessageQueue messageQueue = consumeRequest.getMessageQueue();
+        String topic = messageQueue.getTopic();
+        AtomicInteger currentStageOffset = getCurrentStageOffset(messageQueue, topic, strategyId, groupId);
+        boolean continueConsume = true;
+        long commitOffset = -1L;
+        int commitStageOffset = -1;
+        if (context.isAutoCommit()) {
+            switch (status) {
+                case COMMIT:
+                case ROLLBACK:
+                    log.warn(""the message queue consume result is illegal, we think you want to ack these message {}"",
+                        messageQueue);
+                case SUCCESS:
+                    commitOffset = consumeRequest.getProcessQueue().commitMessages(msgs);
+                    commitStageOffset = currentStageOffset.get();
+                    this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, topic, msgs.size());
+                    break;
+                case SUSPEND_CURRENT_QUEUE_A_MOMENT:
+                    synchronized (currentStageOffset) {
+                        currentStageOffset.set(currentStageOffset.get() - msgs.size());
+                    }
+                    this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, topic, msgs.size());
+                    if (checkReconsumeTimes(msgs)) {
+                        consumeRequest.getProcessQueue().makeMessageToConsumeAgain(msgs);
+                        this.submitConsumeRequestLater(
+                            consumeRequest.getProcessQueue(),
+                            messageQueue,
+                            context.getSuspendCurrentQueueTimeMillis());
+                        continueConsume = false;
+                    } else {
+                        commitOffset = consumeRequest.getProcessQueue().commitMessages(msgs);
+                        commitStageOffset = currentStageOffset.get();
+                    }
+                    break;
+                default:
+                    break;
+            }
+        } else {
+            switch (status) {
+                case SUCCESS:
+                    this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, topic, msgs.size());
+                    break;
+                case COMMIT:
+                    commitOffset = consumeRequest.getProcessQueue().commitMessages(msgs);
+                    commitStageOffset = currentStageOffset.get();
+                    break;
+                case ROLLBACK:
+                    consumeRequest.getProcessQueue().rollback();
+                    this.submitConsumeRequestLater(
+                        consumeRequest.getProcessQueue(),
+                        messageQueue,
+                        context.getSuspendCurrentQueueTimeMillis());
+                    continueConsume = false;
+                    break;
+                case SUSPEND_CURRENT_QUEUE_A_MOMENT:
+                    synchronized (currentStageOffset) {
+                        currentStageOffset.set(currentStageOffset.get() - msgs.size());
+                    }
+                    this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, topic, msgs.size());
+                    if (checkReconsumeTimes(msgs)) {
+                        consumeRequest.getProcessQueue().makeMessageToConsumeAgain(msgs);
+                        this.submitConsumeRequestLater(
+                            consumeRequest.getProcessQueue(),
+                            messageQueue,
+                            context.getSuspendCurrentQueueTimeMillis());
+                        continueConsume = false;
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        if (commitOffset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {
+            this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(messageQueue, commitOffset, false);
+        }
+
+        if (stageOffsetStore != null && commitStageOffset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {
+            synchronized (currentStageOffset) {
+                messageListener.rollbackCurrentStageOffsetIfNeed(topic, strategyId, groupId, currentStageOffset, msgs);
+                //prevent users from resetting the value of currentStageOffset to a value less than 0
+                currentStageOffset.set(Math.max(0, currentStageOffset.get()));
+            }
+            commitStageOffset = currentStageOffset.get();
+            if (!consumeRequest.getProcessQueue().isDropped()) {
+                stageOffsetStore.updateStageOffset(messageQueue, strategyId, groupId, commitStageOffset, false);
+            }
+        }
+
+        return continueConsume;
+    }
+
+    public ConsumerStatsManager getConsumerStatsManager() {
+        return this.defaultMQPushConsumerImpl.getConsumerStatsManager();
+    }
+
+    private int getMaxReconsumeTimes() {
+        // default reconsume times: Integer.MAX_VALUE
+        if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) {
+            return Integer.MAX_VALUE;
+        } else {
+            return this.defaultMQPushConsumer.getMaxReconsumeTimes();
+        }
+    }
+
+    private boolean checkReconsumeTimes(List<MessageExt> msgs) {
+        boolean suspend = false;
+        if (msgs != null && !msgs.isEmpty()) {
+            for (MessageExt msg : msgs) {
+                if (msg.getReconsumeTimes() >= getMaxReconsumeTimes()) {
+                    MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes()));
+                    if (!sendMessageBack(msg)) {
+                        suspend = true;
+                        msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
+                    }
+                } else {
+                    suspend = true;
+                    msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
+                }
+            }
+        }
+        return suspend;
+    }
+
+    public boolean sendMessageBack(final MessageExt msg) {
+        try {
+            // max reconsume times exceeded then send to dead letter queue.
+            Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());
+            String originMsgId = MessageAccessor.getOriginMessageId(msg);
+            MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);
+            newMsg.setFlag(msg.getFlag());
+            MessageAccessor.setProperties(newMsg, msg.getProperties());
+            MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());
+            MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes()));
+            MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));
+            MessageAccessor.clearProperty(newMsg, MessageConst.PROPERTY_TRANSACTION_PREPARED);
+            newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());
+
+            this.defaultMQPushConsumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getDefaultMQProducer().send(newMsg);
+            return true;
+        } catch (Exception e) {
+            log.error(""sendMessageBack exception, group: "" + this.consumerGroup + "" msg: "" + msg.toString(), e);
+        }
+
+        return false;
+    }
+
+    public void resetNamespace(final List<MessageExt> msgs) {
+        for (MessageExt msg : msgs) {
+            if (StringUtils.isNotEmpty(this.defaultMQPushConsumer.getNamespace())) {
+                msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace()));
+            }
+        }
+    }
+
+    class DispatchRequest implements Runnable {
+        private final ProcessQueue processQueue;
+        private final MessageQueue messageQueue;
+
+        public DispatchRequest(ProcessQueue processQueue,
+            MessageQueue messageQueue) {
+            this.processQueue = processQueue;
+            this.messageQueue = messageQueue;
+        }
+
+        @Override
+        public void run() {
+            if (this.processQueue.isDropped()) {
+                log.warn(""run, the message queue not be able to consume, because it's dropped. {}"", this.messageQueue);
+                return;
+            }
+
+            String topic = this.messageQueue.getTopic();
+            final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue);
+            synchronized (objLock) {
+                if (MessageModel.BROADCASTING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())
+                    || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) {
+                    final long beginTime = System.currentTimeMillis();
+                    for (final AtomicBoolean continueConsume = new AtomicBoolean(true); continueConsume.get(); ) {
+                        if (this.processQueue.isDropped()) {
+                            log.warn(""the message queue not be able to consume, because it's dropped. {}"", this.messageQueue);
+                            break;
+                        }
+
+                        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())
+                            && !this.processQueue.isLocked()) {
+                            log.warn(""the message queue not locked, so consume later, {}"", this.messageQueue);
+                            ConsumeMessageStagedConcurrentlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
+                            break;
+                        }
+
+                        if (MessageModel.CLUSTERING.equals(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.messageModel())
+                            && this.processQueue.isLockExpired()) {
+                            log.warn(""the message queue lock expired, so consume later, {}"", this.messageQueue);
+                            ConsumeMessageStagedConcurrentlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
+                            break;
+                        }
+
+                        long interval = System.currentTimeMillis() - beginTime;
+                        if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {
+                            ConsumeMessageStagedConcurrentlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10);
+                            break;
+                        }
+
+                        final int consumeBatchSize =
+                            ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();
+                        int takeSize = ConsumeMessageStagedConcurrentlyService.this.pullBatchSize * consumeBatchSize;
+                        List<MessageExt> msgs = this.processQueue.takeMessages(takeSize);
+                        if (!msgs.isEmpty()) {
+                            //ensure that the stage definitions is up to date
+                            ConsumeMessageStagedConcurrentlyService.this.refreshStageDefinition();
+                            Map<String, Map<String, List<MessageExt>>> messageGroupByStrategyThenGroup = removeAndRePutAllMessagesInTheNextStage(topic, msgs);
+                            for (Map.Entry<String, Map<String, List<MessageExt>>> entry : messageGroupByStrategyThenGroup.entrySet()) {
+                                String strategyId = entry.getKey();
+                                Map<String, List<MessageExt>> messageGroups = entry.getValue();
+                                for (Map.Entry<String, List<MessageExt>> innerEntry : messageGroups.entrySet()) {
+                                    String groupId = innerEntry.getKey();
+                                    List<MessageExt> messagesCanConsume = innerEntry.getValue();
+                                    List<List<MessageExt>> lists = UtilAll.partition(messagesCanConsume, consumeBatchSize);
+                                    for (final List<MessageExt> list : lists) {
+                                        defaultMQPushConsumerImpl.resetRetryAndNamespace(list, defaultMQPushConsumer.getConsumerGroup());
+                                        int currentLeftoverStageIndex =
+                                            ConsumeMessageStagedConcurrentlyService.this.getCurrentLeftoverStageIndexAndUpdate(this.messageQueue, topic, strategyId, groupId, list.size());
+                                        ConsumeRequest consumeRequest = new ConsumeRequest(list, this.processQueue, this.messageQueue, continueConsume, currentLeftoverStageIndex, strategyId, groupId);
+                                        if (currentLeftoverStageIndex >= 0) {
+                                            engine.runPriorityAsync(currentLeftoverStageIndex, consumeRequest);
+                                        } else {
+                                            //If the strategy Id is null, it will go in this case
+                                            engine.runPriorityAsync(consumeRequest);
+                                        }
+                                    }
+                                }
+                            }
+                        } else {
+                            continueConsume.set(false);
+                        }
+                    }
+                } else {
+                    if (this.processQueue.isDropped()) {
+                        log.warn(""the message queue not be able to consume, because it's dropped. {}"", this.messageQueue);
+                        return;
+                    }
+
+                    ConsumeMessageStagedConcurrentlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100);
+                }
+            }
+        }
+
+        private Map<String, Map<String, List<MessageExt>>> removeAndRePutAllMessagesInTheNextStage(String topic,
+            List<MessageExt> msgs) {
+            Map<String, Map<String, List<MessageExt>>> messageGroupByStrategyThenGroup = new LinkedHashMap<>();
+            for (MessageExt message : msgs) {
+                String strategyId = NULL;
+                try {
+                    strategyId = String.valueOf(messageListener.computeStrategy(message));
+                } catch (Exception e) {
+                    log.error(""computeStrategy failed with exception:"" + e.getMessage() + "" !"");
+                }
+                String groupId = NULL;
+                try {
+                    groupId = String.valueOf(messageListener.computeGroup(message));
+                } catch (Exception e) {
+                    log.error(""computeGroup failed with exception:"" + e.getMessage() + "" !"");
+                }
+                //null strategy means direct concurrency
+                Map<String, List<MessageExt>> messageGroupByStrategy = messageGroupByStrategyThenGroup.putIfAbsent(strategyId, new LinkedHashMap<>());
+                if (null == messageGroupByStrategy) {
+                    messageGroupByStrategy = messageGroupByStrategyThenGroup.get(strategyId);
+                }
+                List<MessageExt> messages = messageGroupByStrategy.putIfAbsent(groupId, new CopyOnWriteArrayList<>());
+                if (null == messages) {
+                    messages = messageGroupByStrategy.get(groupId);
+                }
+                messages.add(message);
+            }
+            for (Map.Entry<String, Map<String, List<MessageExt>>> entry : messageGroupByStrategyThenGroup.entrySet()) {
+                String strategyId = entry.getKey();
+                Map<String, List<MessageExt>> messageGroupByStrategy = entry.getValue();
+                for (Map.Entry<String, List<MessageExt>> innerEntry : messageGroupByStrategy.entrySet()) {
+                    String groupId = innerEntry.getKey();
+                    List<MessageExt> messages = innerEntry.getValue();
+                    int leftoverStage = ConsumeMessageStagedConcurrentlyService.this.getCurrentLeftoverStage(this.messageQueue, topic, strategyId, groupId);
+                    int size = messages.size();
+                    if (leftoverStage < 0 || size <= leftoverStage) {
+                        continue;
+                    }
+                    List<MessageExt> list = messages.subList(leftoverStage, size);
+                    //the messages must be put back here
+                    this.processQueue.putMessage(list);
+                    messages.removeAll(list);
+                }
+            }
+            return messageGroupByStrategyThenGroup;
+        }
+    }
+
+    class ConsumeRequest implements Runnable {
+        private final List<MessageExt> msgs;
+        private final ProcessQueue processQueue;
+        private final MessageQueue messageQueue;
+        private final AtomicBoolean continueConsume;
+        private final int currentLeftoverStageIndex;
+        private final String strategyId;
+        private final String groupId;
+
+        public ConsumeRequest(List<MessageExt> msgs,
+            ProcessQueue processQueue,
+            MessageQueue messageQueue,
+            AtomicBoolean continueConsume,
+            int currentLeftoverStage,
+            String strategyId,
+            String groupId) {
+            this.msgs = msgs;
+            this.processQueue = processQueue;
+            this.messageQueue = messageQueue;
+            this.continueConsume = continueConsume;
+            this.currentLeftoverStageIndex = currentLeftoverStage;
+            this.strategyId = strategyId;
+            this.groupId = groupId;
+        }
+
+        public ProcessQueue getProcessQueue() {
+            return processQueue;
+        }
+
+        public MessageQueue getMessageQueue() {
+            return messageQueue;
+        }
+
+        @Override
+        public void run() {
+            ConsumeStagedConcurrentlyContext context = new ConsumeStagedConcurrentlyContext(this.messageQueue);
+            context.setStrategyId(strategyId);
+            context.setGroupId(groupId);
+            context.setStageIndex(currentLeftoverStageIndex);
+            ConsumeOrderlyStatus status = null;
+
+            ConsumeMessageContext consumeMessageContext = null;
+            if (ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {
+                consumeMessageContext = new ConsumeMessageContext();
+                consumeMessageContext
+                    .setConsumerGroup(ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumer.getConsumerGroup());
+                consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());
+                consumeMessageContext.setMq(messageQueue);
+                consumeMessageContext.setMsgList(msgs);
+                consumeMessageContext.setSuccess(false);
+                // init the consume context type
+                consumeMessageContext.setProps(new HashMap<String, String>());
+                ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);
+            }
+
+            long beginTimestamp = System.currentTimeMillis();
+            ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;
+            boolean hasException = false;
+            try {
+                this.processQueue.getConsumeLock().lock();
+                if (this.processQueue.isDropped()) {
+                    log.warn(""consumeMessage, the message queue not be able to consume, because it's dropped. {}"",
+                        this.messageQueue);
+                    continueConsume.set(false);
+                    return;
+                }
+                for (MessageExt msg : msgs) {
+                    MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));
+                }
+                status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);
+            } catch (Throwable e) {
+                log.warn(""consumeMessage exception: {} Group: {} Msgs: {} MQ: {}"",
+                    RemotingHelper.exceptionSimpleDesc(e),
+                    ConsumeMessageStagedConcurrentlyService.this.consumerGroup,
+                    msgs,
+                    messageQueue);
+                hasException = true;
+            } finally {
+                this.processQueue.getConsumeLock().unlock();
+            }
+
+            if (null == status
+                || ConsumeOrderlyStatus.ROLLBACK == status
+                || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {
+                log.warn(""consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}"",
+                    ConsumeMessageStagedConcurrentlyService.this.consumerGroup,
+                    msgs,
+                    messageQueue);
+            }
+
+            long consumeRT = System.currentTimeMillis() - beginTimestamp;
+            if (null == status) {
+                if (hasException) {
+                    returnType = ConsumeReturnType.EXCEPTION;
+                } else {
+                    returnType = ConsumeReturnType.RETURNNULL;
+                }
+            } else if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {
+                returnType = ConsumeReturnType.TIME_OUT;
+            } else if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {
+                returnType = ConsumeReturnType.FAILED;
+            } else if (ConsumeOrderlyStatus.SUCCESS == status) {
+                returnType = ConsumeReturnType.SUCCESS;
+            }
+
+            if (ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {
+                consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());
+            }
+
+            if (null == status) {
+                status = ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;
+            }
+
+            if (ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {
+                consumeMessageContext.setStatus(status.toString());
+                consumeMessageContext
+                    .setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status);
+                ConsumeMessageStagedConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);
+            }
+
+            ConsumeMessageStagedConcurrentlyService.this.getConsumerStatsManager()
+                .incConsumeRT(ConsumeMessageStagedConcurrentlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT);
+            continueConsume.set(ConsumeMessageStagedConcurrentlyService.this.processConsumeResult(strategyId, groupId, msgs, status, context, this)","[{'comment': 'I think below code would be better.\n\n```java\nif (!ConsumeMessageStagedConcurrentlyService.this.processConsumeResult(strategyId, groupId, msgs, status, context, this)) {\n        continueConsume.set(false);\n}\n```', 'commenter': 'ifplusor'}, {'comment': 'Good idea, this makes the code easier to understand', 'commenter': 'loongs-zhang'}]"
2983,common/src/main/java/org/apache/rocketmq/common/concurrent/ConcurrentEngine.java,"@@ -0,0 +1,463 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.common.concurrent;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.collections.MapUtils;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.constant.LoggerName;
+import org.apache.rocketmq.common.utils.ThreadUtils;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.logging.InternalLoggerFactory;
+
+public class ConcurrentEngine {
+
+    protected static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);
+
+    protected final ExecutorService enginePool;
+
+    public ConcurrentEngine() {
+        this.enginePool = ForkJoinPool.commonPool();
+    }
+
+    public ConcurrentEngine(ExecutorService enginePool) {
+        this.enginePool = enginePool;
+    }
+
+    public final void runAsync(Runnable... tasks) {
+        runAsync(UtilAll.newArrayList(tasks));
+    }
+
+    protected static <E> List<E> pollAllTask(Queue<E> tasks) {
+        //avoid list expansion
+        List<E> list = new LinkedList<>();
+        while (tasks != null && !tasks.isEmpty()) {
+            E task = tasks.poll();
+            list.add(task);
+        }
+        return list;
+    }
+
+    protected static <T> void doCallback(CallableSupplier<T> supplier, T response) {
+        Collection<Callback<T>> callbacks = supplier.getCallbacks();
+        if (CollectionUtils.isNotEmpty(callbacks)) {
+            for (Callback<T> callback : callbacks) {
+                callback.call(response);
+            }
+        }
+    }
+
+    public final void runAsync(Queue<? extends Runnable> tasks) {
+        runAsync(pollAllTask(tasks));
+    }
+
+    public final void runAsync(Collection<? extends Runnable> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return;
+        }
+        List<CompletableFuture<Void>> list = new ArrayList<>(tasks.size());
+        for (Runnable task : tasks) {
+            list.add(CompletableFuture.runAsync(task, enginePool));
+        }
+        executeAsync(list);
+    }
+
+    @SafeVarargs
+    public final <T> List<T> supplyAsync(Supplier<T>... tasks) {
+        return supplyAsync(UtilAll.newArrayList(tasks));
+    }
+
+    public final <T> List<T> supplyAsync(Queue<? extends Supplier<T>> tasks) {
+        return supplyAsync(pollAllTask(tasks));
+    }
+
+    public final <T> List<T> supplyAsync(Collection<? extends Supplier<T>> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return new ArrayList<>();
+        }
+        List<CompletableFuture<T>> list = new ArrayList<>(tasks.size());
+        for (Supplier<T> task : tasks) {
+            list.add(CompletableFuture.supplyAsync(task, enginePool));
+        }
+        return executeAsync(list);
+    }
+
+    @SafeVarargs
+    public final <T> List<T> supplyCallableAsync(CallableSupplier<T>... tasks) {
+        return supplyCallableAsync(UtilAll.newArrayList(tasks));
+    }
+
+    public final <T> List<T> supplyCallableAsync(Queue<? extends CallableSupplier<T>> tasks) {
+        return supplyCallableAsync(pollAllTask(tasks));
+    }
+
+    public final <T> List<T> supplyCallableAsync(Collection<? extends CallableSupplier<T>> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return new ArrayList<>();
+        }
+        Map<CallableSupplier<T>, CompletableFuture<T>> map = new HashMap<>(tasks.size());
+        for (CallableSupplier<T> task : tasks) {
+            map.put(task, CompletableFuture.supplyAsync(task, enginePool));
+        }
+        Map<CallableSupplier<T>, T> result = executeKeyedAsync(map);
+        for (Map.Entry<CallableSupplier<T>, T> entry : result.entrySet()) {
+            doCallback(entry.getKey(), entry.getValue());
+        }
+        return UtilAll.newArrayList(result.values());
+    }
+
+    @SafeVarargs
+    public final <K, V> Map<K, V> supplyKeyedCallableAsync(KeyedCallableSupplier<K, V>... tasks) {
+        return supplyKeyedCallableAsync(UtilAll.newArrayList(tasks));
+    }
+
+    public final <K, V> Map<K, V> supplyKeyedCallableAsync(Queue<? extends KeyedCallableSupplier<K, V>> tasks) {
+        return supplyKeyedCallableAsync(pollAllTask(tasks));
+    }
+
+    public final <K, V> Map<K, V> supplyKeyedCallableAsync(Collection<? extends KeyedCallableSupplier<K, V>> tasks) {
+        if (CollectionUtils.isEmpty(tasks) || enginePool.isShutdown()) {
+            return new HashMap<>();
+        }
+        Map<K, CompletableFuture<V>> map = new HashMap<>(tasks.size());
+        for (KeyedCallableSupplier<K, V> task : tasks) {
+            map.put(task.key(), CompletableFuture.supplyAsync(task, enginePool));
+        }
+        Map<K, V> result = executeKeyedAsync(map);
+        for (KeyedCallableSupplier<K, V> task : tasks) {
+            K key = task.key();
+            V response = result.get(key);
+            doCallback(task, response);
+        }
+        return result;
+    }
+
+    @SafeVarargs
+    public final <T> List<T> executeAsync(CompletableFuture<T>... tasks) {
+        return executeAsync(UtilAll.newArrayList(tasks));
+    }
+
+    public final <T> List<T> executeAsync(Queue<CompletableFuture<T>> tasks) {
+        return executeAsync(pollAllTask(tasks));
+    }
+
+    public final <T> List<T> executeAsync(Collection<CompletableFuture<T>> tasks) {","[{'comment': 'I think the name execute is inappropriate.', 'commenter': 'ifplusor'}]"
2983,common/src/main/java/org/apache/rocketmq/common/message/MessageClientExt.java,"@@ -36,7 +36,7 @@ public String getMsgId() {
         }
     }
 
-    public void setMsgId(String msgId) {
+    @Override public void setMsgId(String msgId) {","[{'comment': 'Do not in single line.', 'commenter': 'ifplusor'}, {'comment': 'ok', 'commenter': 'loongs-zhang'}]"
2983,common/src/main/java/org/apache/rocketmq/common/protocol/header/UpdateConsumerStageOffsetRequestHeader.java,"@@ -0,0 +1,93 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * $Id: UpdateConsumerOffsetRequestHeader.java 1835 2013-05-16 02:00:50Z vintagewang@apache.org $
+ */
+package org.apache.rocketmq.common.protocol.header;
+
+import org.apache.rocketmq.remoting.CommandCustomHeader;
+import org.apache.rocketmq.remoting.annotation.CFNotNull;
+import org.apache.rocketmq.remoting.annotation.CFNullable;","[{'comment': 'unused import', 'commenter': 'ifplusor'}]"
2983,common/src/main/java/org/apache/rocketmq/common/UtilAll.java,"@@ -29,16 +29,20 @@
 import java.text.NumberFormat;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.Iterator;
+import java.util.LinkedHashMap;","[{'comment': 'unused import', 'commenter': 'ifplusor'}]"
2983,common/src/main/java/org/apache/rocketmq/common/UtilAll.java,"@@ -29,16 +29,20 @@
 import java.text.NumberFormat;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.Iterator;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.zip.CRC32;
 import java.util.zip.DeflaterOutputStream;
 import java.util.zip.InflaterInputStream;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.collections.MapUtils;","[{'comment': 'ditto', 'commenter': 'ifplusor'}]"
2983,client/src/main/java/org/apache/rocketmq/client/consumer/store/StageOffsetSerializeWrapper.java,"@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.client.consumer.store;
+
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;","[{'comment': 'unused import', 'commenter': 'ifplusor'}]"
2983,broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java,"@@ -179,6 +181,7 @@ public BrokerController(
         this.nettyClientConfig = nettyClientConfig;
         this.messageStoreConfig = messageStoreConfig;
         this.consumerOffsetManager = new ConsumerOffsetManager(this);
+        this.consumerStageOffsetManager=new ConsumerStageOffsetManager(this);","[{'comment': 'need spaces arround `=`.', 'commenter': 'ifplusor'}]"
3072,docs/cn/Example_Simple_cn.md,"@@ -0,0 +1,136 @@
+# Basic Sample 
+------
+基本示例中提供了以下两个功能
+* RocketMQ可用于以三种方式发送消息：可靠的同步、可靠的异步和单向传输。前两种消息类型是可靠的，因为无论它们是否成功发送都有响应。
+* RocketMQ可以用来消费消息。
+### 1 添加依赖
+maven:
+``` java
+<dependency>
+  <groupId>org.apache.rocketmq</groupId>
+  <artifactId>rocketmq-client</artifactId>
+  <version>4.3.0</version>
+</dependency>
+```
+gradle: 
+``` java 
+compile 'org.apache.rocketmq:rocketmq-client:4.3.0'
+```
+### 2 发送消息
+##### 2.1 使用Producer发送同步消息
+可靠的同步传输被广泛应用于各种场景，如重要的通知消息、短消息通知等。","[{'comment': ""More appropriate to translate SMS into '短信'"", 'commenter': 'caigy'}]"
3072,docs/cn/Example_Simple_cn.md,"@@ -0,0 +1,136 @@
+# Basic Sample 
+------
+基本示例中提供了以下两个功能
+* RocketMQ可用于以三种方式发送消息：可靠的同步、可靠的异步和单向传输。前两种消息类型是可靠的，因为无论它们是否成功发送都有响应。
+* RocketMQ可以用来消费消息。
+### 1 添加依赖
+maven:
+``` java
+<dependency>
+  <groupId>org.apache.rocketmq</groupId>
+  <artifactId>rocketmq-client</artifactId>
+  <version>4.3.0</version>
+</dependency>
+```
+gradle: 
+``` java 
+compile 'org.apache.rocketmq:rocketmq-client:4.3.0'
+```
+### 2 发送消息
+##### 2.1 使用Producer发送同步消息
+可靠的同步传输被广泛应用于各种场景，如重要的通知消息、短消息通知等。
+``` java
+public class SyncProducer {
+  public static void main(String[] args) throws Exception {
+    // Instantiate with a producer group name
+    DefaultMQProducer producer = new DefaultMQProducer(""please_rename_unique_group_name"");
+    // Specify name server addresses
+    producer.setNamesrvAddr(""localhost:9876"");
+    // Launch the producer instance
+    producer.start();
+    for (int i = 0; i < 100; i++) {
+      // Create a message instance with specifying topic, tag and message body
+      Message msg = new Message(""TopicTest"" /* Topic */,
+        ""TagA"" /* Tag */,
+        (""Hello RocketMQ "" + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */
+        );
+      // Send message to one of brokers
+      SendResult sendResult = producer.send(msg);
+      // Check whether the message has been delivered by the callback of sendResult
+      System.out.printf(""%s%n"", sendResult);
+    }
+    // Shut down once the producer instance is not longer in use
+    producer.shutdown();
+  }
+}
+```
+##### 2.2 发送异步消息
+异步传输通常用于响应时间敏感的业务场景。这意味着发送方无法等待代理的响应太长时间。","[{'comment': 'Not necessary to translate `broker`, eg. ""发送方无法长时间等待 Broker 的响应""', 'commenter': 'caigy'}]"
3072,docs/cn/Example_Simple_cn.md,"@@ -0,0 +1,136 @@
+# Basic Sample 
+------
+基本示例中提供了以下两个功能
+* RocketMQ可用于以三种方式发送消息：可靠的同步、可靠的异步和单向传输。前两种消息类型是可靠的，因为无论它们是否成功发送都有响应。
+* RocketMQ可以用来消费消息。
+### 1 添加依赖
+maven:
+``` java
+<dependency>
+  <groupId>org.apache.rocketmq</groupId>
+  <artifactId>rocketmq-client</artifactId>
+  <version>4.3.0</version>
+</dependency>
+```
+gradle: 
+``` java 
+compile 'org.apache.rocketmq:rocketmq-client:4.3.0'
+```
+### 2 发送消息
+##### 2.1 使用Producer发送同步消息
+可靠的同步传输被广泛应用于各种场景，如重要的通知消息、短消息通知等。
+``` java
+public class SyncProducer {
+  public static void main(String[] args) throws Exception {
+    // Instantiate with a producer group name
+    DefaultMQProducer producer = new DefaultMQProducer(""please_rename_unique_group_name"");
+    // Specify name server addresses
+    producer.setNamesrvAddr(""localhost:9876"");
+    // Launch the producer instance
+    producer.start();
+    for (int i = 0; i < 100; i++) {
+      // Create a message instance with specifying topic, tag and message body
+      Message msg = new Message(""TopicTest"" /* Topic */,
+        ""TagA"" /* Tag */,
+        (""Hello RocketMQ "" + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */
+        );
+      // Send message to one of brokers
+      SendResult sendResult = producer.send(msg);
+      // Check whether the message has been delivered by the callback of sendResult
+      System.out.printf(""%s%n"", sendResult);
+    }
+    // Shut down once the producer instance is not longer in use
+    producer.shutdown();
+  }
+}
+```
+##### 2.2 发送异步消息
+异步传输通常用于响应时间敏感的业务场景。这意味着发送方无法等待代理的响应太长时间。
+``` java
+public class AsyncProducer {
+  public static void main(String[] args) throws Exception {
+    // Instantiate with a producer group name
+    DefaultMQProducer producer = new DefaultMQProducer(""please_rename_unique_group_name"");
+    // Specify name server addresses
+    producer.setNamesrvAddr(""localhost:9876"");
+    // Launch the producer instance
+    producer.start();
+    producer.setRetryTimesWhenSendAsyncFailed(0);
+    for (int i = 0; i < 100; i++) {
+      final int index = i;
+      // Create a message instance with specifying topic, tag and message body
+      Message msg = new Message(""TopicTest"",
+        ""TagA"",
+        ""OrderID188"",
+        ""Hello world"".getBytes(RemotingHelper.DEFAULT_CHARSET));
+      // SendCallback: receive the callback of the asynchronous return result.
+      producer.send(msg, new SendCallback() {
+        @Override
+        public void onSuccess(SendResult sendResult) {
+          System.out.printf(""%-10d OK %s %n"", index,
+            sendResult.getMsgId());
+        }
+        @Override
+        public void onException(Throwable e) {
+          System.out.printf(""%-10d Exception %s %n"", index, e);
+          e.printStackTrace();
+        }
+      });
+    }
+    // Shut down once the producer instance is not longer in use
+    producer.shutdown();
+  }
+}
+```
+##### 2.3 以单向模式发送消息
+单向传输用于需要中等可靠性的情况，如日志收集。","[{'comment': 'Would ""单向传输用于可靠性要求并不高的场景"" be better?', 'commenter': 'caigy'}]"
3149,distribution/bin/export.sh,"@@ -0,0 +1,102 @@
+#!/bin/bash
+
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+checkCmd() {
+  if ! command -v wget > /dev/null 2>&1; then
+    echo -e '[ERROR] This system does not contains wget command, please install it!'
+    exit 1
+  fi
+}
+
+download() {
+  if [[ -e /tmp/rocketmq/ ]]; then
+    rm -rf /tmp/rocketmq/
+  fi
+
+  wget --no-check-certificate -P /tmp/rocketmq/ https://ons-migration.oss-cn-hangzhou.aliyuncs.com/rocketmq-for-export.tar.gz
+  if [[ $? -ne 0 ]]; then
+    echo -e ""[ERROR] Download rocketmq error, please make sure this file exists""
+    exit 1
+  else
+    echo -e ""[INFO] Download rocketmq completed，file path: $(pwd)/rocketmq-for-export.tar.gz""
+  fi
+
+  tar -zxvf /tmp/rocketmq/rocketmq-for-export.tar.gz -C /tmp/rocketmq/ > /dev/null 2>&1
+
+  echo -e ""[INFO] Unzip rocketmq-for-export.tar.gz completed""
+}","[{'comment': 'It is not appropriate to download packages from OSS here', 'commenter': 'RongtongJin'}, {'comment': 'Any update for here?', 'commenter': 'vongosling'}, {'comment': 'has been deleted about oss', 'commenter': 'panzhi33'}]"
3149,tools/src/main/java/org/apache/rocketmq/tools/command/export/ExportConfigsCommand.java,"@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tools.command.export;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+
+import com.alibaba.fastjson.JSON;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.remoting.RPCHook;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
+import org.apache.rocketmq.tools.command.CommandUtil;
+import org.apache.rocketmq.tools.command.SubCommand;
+import org.apache.rocketmq.tools.command.SubCommandException;
+
+public class ExportConfigsCommand implements SubCommand {
+    @Override
+    public String commandName() {
+        return ""exportConfigs"";
+    }
+
+    @Override
+    public String commandDesc() {
+        return ""export configs"";
+    }
+
+    @Override
+    public Options buildCommandlineOptions(Options options) {
+        Option opt = new Option(""c"", ""clusterName"", true, ""choose a cluster to export"");
+        opt.setRequired(true);
+        options.addOption(opt);
+
+        opt = new Option(""f"", ""filePath"", true,
+            ""export configs.json path | default /tmp/rocketmq/export"");
+        opt.setRequired(false);
+        options.addOption(opt);
+        return options;
+    }
+
+    @Override
+    public void execute(CommandLine commandLine, Options options, RPCHook rpcHook)
+        throws SubCommandException {
+        DefaultMQAdminExt defaultMQAdminExt = new DefaultMQAdminExt(rpcHook);
+        defaultMQAdminExt.setInstanceName(Long.toString(System.currentTimeMillis()));
+
+        try {
+            String clusterName = commandLine.getOptionValue('c').trim();
+            String filePath = !commandLine.hasOption('f') ? ""/tmp/rocketmq/export"" : commandLine.getOptionValue('f')","[{'comment': 'Define a constant for `""/tmp/rocketmq/export""`', 'commenter': 'caigy'}]"
3149,tools/src/main/java/org/apache/rocketmq/tools/command/export/ExportMetadataCommand.java,"@@ -0,0 +1,184 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tools.command.export;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+import com.alibaba.fastjson.JSON;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.rocketmq.common.MQVersion;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.common.TopicConfig;
+import org.apache.rocketmq.common.protocol.body.SubscriptionGroupWrapper;
+import org.apache.rocketmq.common.protocol.body.TopicConfigSerializeWrapper;
+import org.apache.rocketmq.common.subscription.SubscriptionGroupConfig;
+import org.apache.rocketmq.remoting.RPCHook;
+import org.apache.rocketmq.srvutil.ServerUtil;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
+import org.apache.rocketmq.tools.command.CommandUtil;
+import org.apache.rocketmq.tools.command.SubCommand;
+import org.apache.rocketmq.tools.command.SubCommandException;
+
+public class ExportMetadataCommand implements SubCommand {
+
+    @Override
+    public String commandName() {
+        return ""exportMetadata"";
+    }
+
+    @Override
+    public String commandDesc() {
+        return ""export metadata"";
+    }
+
+    @Override
+    public Options buildCommandlineOptions(Options options) {
+        Option opt = new Option(""c"", ""clusterName"", true, ""choose a cluster to export"");
+        opt.setRequired(false);
+        options.addOption(opt);
+
+        opt = new Option(""b"", ""brokerAddr"", true, ""choose a broker to export"");
+        opt.setRequired(false);
+        options.addOption(opt);
+
+        opt = new Option(""f"", ""filePath"", true, ""export metadata.json path | default /tmp/rocketmq/export"");
+        opt.setRequired(false);
+        options.addOption(opt);
+
+        opt = new Option(""t"", ""topic"", false, ""only export topic metadata"");
+        opt.setRequired(false);
+        options.addOption(opt);
+
+        opt = new Option(""g"", ""subscriptionGroup"", false, ""only export subscriptionGroup metadata"");
+        opt.setRequired(false);
+        options.addOption(opt);
+
+        opt = new Option(""s"", ""specialTopic"", false, ""need retryTopic and dlqTopic"");
+        opt.setRequired(false);
+        options.addOption(opt);
+        return options;
+    }
+
+    @Override
+    public void execute(CommandLine commandLine, Options options, RPCHook rpcHook)
+        throws SubCommandException {
+        DefaultMQAdminExt defaultMQAdminExt = new DefaultMQAdminExt(rpcHook);
+
+        defaultMQAdminExt.setInstanceName(Long.toString(System.currentTimeMillis()));
+
+        try {
+            defaultMQAdminExt.start();
+
+            String filePath = !commandLine.hasOption('f') ? ""/tmp/rocketmq/export"" : commandLine.getOptionValue('f')
+                .trim();
+
+            boolean specialTopic = commandLine.hasOption('s');
+
+            if (commandLine.hasOption('b')) {
+                final String brokerAddr = commandLine.getOptionValue('b').trim();
+
+                if (commandLine.hasOption('t')) {
+                    filePath = filePath + ""/topic.json"";
+                    TopicConfigSerializeWrapper topicConfigSerializeWrapper = defaultMQAdminExt.getUserTopicConfig(
+                        brokerAddr, specialTopic, 10000L);
+                    MixAll.string2FileNotSafe(JSON.toJSONString(topicConfigSerializeWrapper, true), filePath);
+                    System.out.printf(""export %s success"", filePath);
+                } else if (commandLine.hasOption('g')) {
+                    filePath = filePath + ""/subscriptionGroup.json"";
+                    SubscriptionGroupWrapper subscriptionGroupWrapper = defaultMQAdminExt.getUserSubscriptionGroup(
+                        brokerAddr, 10000L);
+                    MixAll.string2FileNotSafe(JSON.toJSONString(subscriptionGroupWrapper, true), filePath);
+                    System.out.printf(""export %s success"", filePath);
+                }
+            } else if (commandLine.hasOption('c')) {
+                String clusterName = commandLine.getOptionValue('c').trim();
+
+                Set<String> masterSet =
+                    CommandUtil.fetchMasterAddrByClusterName(defaultMQAdminExt, clusterName);
+
+                ConcurrentMap<String, TopicConfig> topicConfigMap = new ConcurrentHashMap<>();
+                ConcurrentMap<String, SubscriptionGroupConfig> subGroupConfigMap = new ConcurrentHashMap<>();","[{'comment': 'Will `topicConfigMap` `subGroupConfigMap` be used by multiple threads? If not, it would be better just use plain HashMap here.', 'commenter': 'caigy'}]"
3149,tools/src/main/java/org/apache/rocketmq/tools/command/export/ExportConfigsCommand.java,"@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tools.command.export;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+
+import com.alibaba.fastjson.JSON;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.remoting.RPCHook;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
+import org.apache.rocketmq.tools.command.CommandUtil;
+import org.apache.rocketmq.tools.command.SubCommand;
+import org.apache.rocketmq.tools.command.SubCommandException;
+
+public class ExportConfigsCommand implements SubCommand {
+    @Override
+    public String commandName() {
+        return ""exportConfigs"";
+    }
+
+    @Override
+    public String commandDesc() {
+        return ""export configs"";
+    }
+
+    @Override
+    public Options buildCommandlineOptions(Options options) {
+        Option opt = new Option(""c"", ""clusterName"", true, ""choose a cluster to export"");
+        opt.setRequired(true);
+        options.addOption(opt);
+
+        opt = new Option(""f"", ""filePath"", true,
+            ""export configs.json path | default /tmp/rocketmq/export"");
+        opt.setRequired(false);
+        options.addOption(opt);
+        return options;
+    }
+
+    @Override
+    public void execute(CommandLine commandLine, Options options, RPCHook rpcHook)
+        throws SubCommandException {
+        DefaultMQAdminExt defaultMQAdminExt = new DefaultMQAdminExt(rpcHook);
+        defaultMQAdminExt.setInstanceName(Long.toString(System.currentTimeMillis()));
+
+        try {
+            String clusterName = commandLine.getOptionValue('c').trim();
+            String filePath = !commandLine.hasOption('f') ? ""/tmp/rocketmq/export"" : commandLine.getOptionValue('f')
+                .trim();
+
+            defaultMQAdminExt.start();
+            Map<String, Object> result = new HashMap<>();
+            // name servers
+            List<String> nameServerAddressList = defaultMQAdminExt.getNameServerAddressList();
+
+            //broker
+            int masterBrokerSize = 0;
+            int slaveBrokerSize = 0;
+            Map<String, Properties> brokerConfigs = new HashMap<>();
+            Map<String, List<String>> masterAndSlaveMap
+                = CommandUtil.fetchMasterAndSlaveDistinguish(defaultMQAdminExt, clusterName);
+            for (String masterAddr : masterAndSlaveMap.keySet()) {
+                Map<String, Properties> map = new HashMap<>();
+                Properties masterProperties = defaultMQAdminExt.getBrokerConfig(masterAddr);
+                map.put(""master"", needBrokerProprties(masterProperties));
+                masterBrokerSize++;
+                slaveBrokerSize += masterAndSlaveMap.get(masterAddr).size();
+
+                brokerConfigs.put(masterProperties.getProperty(""brokerName""), needBrokerProprties(masterProperties));","[{'comment': 'What is the purpose of map defined in this loop?', 'commenter': 'caigy'}]"
3149,tools/src/main/java/org/apache/rocketmq/tools/admin/DefaultMQAdminExtImpl.java,"@@ -955,12 +973,49 @@ public SubscriptionGroupWrapper getAllSubscriptionGroup(final String brokerAddr,
     }
 
     @Override
-    public TopicConfigSerializeWrapper getAllTopicGroup(final String brokerAddr,
+    public SubscriptionGroupWrapper getUserSubscriptionGroup(final String brokerAddr,
+        long timeoutMillis) throws InterruptedException,
+        RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException, MQBrokerException {
+        SubscriptionGroupWrapper subscriptionGroupWrapper = this.mqClientInstance.getMQClientAPIImpl()
+            .getAllSubscriptionGroup(brokerAddr, timeoutMillis);
+
+        Iterator<Entry<String, SubscriptionGroupConfig>> iterator = subscriptionGroupWrapper.getSubscriptionGroupTable()
+            .entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<String, SubscriptionGroupConfig> configEntry = iterator.next();
+            if (MixAll.isSysConsumerGroup(configEntry.getKey()) || SYSTEM_GROUP_SET.contains(configEntry.getKey())) {
+                iterator.remove();
+            }
+        }
+
+        return subscriptionGroupWrapper;
+    }
+
+    @Override
+    public TopicConfigSerializeWrapper getAllTopicConfig(final String brokerAddr,
         long timeoutMillis) throws InterruptedException,
         RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException, MQBrokerException {
         return this.mqClientInstance.getMQClientAPIImpl().getAllTopicConfig(brokerAddr, timeoutMillis);
     }
 
+    @Override
+    public TopicConfigSerializeWrapper getUserTopicConfig(final String brokerAddr, final boolean specialTopic,
+        long timeoutMillis) throws InterruptedException, RemotingException,
+        MQBrokerException, MQClientException {
+        TopicConfigSerializeWrapper topicConfigSerializeWrapper = this.getAllTopicConfig(brokerAddr, timeoutMillis);
+        TopicList topicList = this.mqClientInstance.getMQClientAPIImpl().getSystemTopicListFromBroker(brokerAddr,
+            timeoutMillis);
+        Iterator<Entry<String, TopicConfig>> iterator = topicConfigSerializeWrapper.getTopicConfigTable().entrySet()
+            .iterator();
+        while (iterator.hasNext()) {
+            String topic = iterator.next().getKey();
+            if (topicList.getTopicList().contains(topic) || !specialTopic && (topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX) || topic.startsWith(MixAll.DLQ_GROUP_TOPIC_PREFIX))) {","[{'comment': '!specialTopic && (topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX) || topic.startsWith(MixAll.DLQ_GROUP_TOPIC_PREFIX))\r\n\r\n这段逻辑应该再加个括号', 'commenter': 'dingshuangxi888'}, {'comment': '这里加不加括号，逻辑都是一样的，但是为了方便理解，我还是加上去了', 'commenter': 'panzhi33'}, {'comment': '嗯嗯，逻辑清晰一点，未来加个条件也不会出bug', 'commenter': 'dingshuangxi888'}]"
3176,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -130,6 +130,7 @@ public boolean updateAccessConfig(PlainAccessConfig plainAccessConfig) {
             log.error(""Parameter value plainAccessConfig is null,Please check your parameter"");
             throw new AclException(""Parameter value plainAccessConfig is null, Please check your parameter"");
         }
+        buildPlainAccessResource(plainAccessConfig); // check config","[{'comment': 'It seems that only null checks is necessary here, extracting a check method to accomplish it may be better.', 'commenter': 'caigy'}, {'comment': 'Yes, I agree with above suggestion!', 'commenter': 'zongtanghu'}, {'comment': 'Fixed. Thanks for your advice.', 'commenter': 'yuz10'}]"
3235,common/src/main/java/org/apache/rocketmq/common/constant/SymbolConstants.java,"@@ -0,0 +1,30 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.common.constant;
+
+public class SymbolConstants {
+
+    public static final String GREATER_AND_EQUAL_CONSTANT = "">="";","[{'comment': 'GREATER_**OR**_EQUAL_CONSTANT may be more precise.', 'commenter': 'caigy'}]"
3235,common/src/main/java/org/apache/rocketmq/common/constant/SymbolConstants.java,"@@ -0,0 +1,30 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.common.constant;
+
+public class SymbolConstants {
+
+    public static final String GREATER_AND_EQUAL_CONSTANT = "">="";
+
+    public static final String LESS_THAN_CONSTANT = ""<"";
+
+    public static final String GREATER_CONSTANT = "">"";
+
+    public static final String LESS_THAN_AND_EQUAL_CONSTANT = ""<="";","[{'comment': 'LESS_**OR**_EQUAL_CONSTANT may be more precise.', 'commenter': 'caigy'}]"
3239,store/src/main/java/org/apache/rocketmq/store/index/IndexFile.java,"@@ -71,6 +72,9 @@ public void load() {
         this.indexHeader.load();
     }
 
+    /**
+     * 头部文件刷盘 时间戳 msgId 物理偏移量..","[{'comment': 'Why do you use so many annotations, and it is in Chinese?', 'commenter': 'AbelSara'}, {'comment': ""sory, I don't know why this code was submitted here"", 'commenter': 'gylang'}, {'comment': 'this code just my study comment. i don\'t want to pr ""3eee57d""', 'commenter': 'gylang'}]"
3305,acl/src/main/java/org/apache/rocketmq/acl/common/AclUtils.java,"@@ -206,61 +206,31 @@ public static boolean isIPv6Scope(int num) {
     }
 
     public static String expandIP(String netaddress, int part) {
-        boolean compress = false;
-        int compressIndex = -1;
-        String[] strArray = StringUtils.split(netaddress, "":"");
-        ArrayList<Integer> indexes = new ArrayList<>();
-        for (int i = 0; i < netaddress.length(); i++) {
-            if (netaddress.charAt(i) == ':') {
-                if (indexes.size() > 0 && i - indexes.get(indexes.size() - 1) == 1) {
-                    compressIndex = i;
-                    compress = true;
-                }
-                indexes.add(i);
+        // expand netaddress
+        int separatorCount = StringUtils.countMatches(netaddress, "":"");
+        int padCount = part - separatorCount;
+        if(padCount > 0){","[{'comment': 'make sure the checkstyle pass. run `mvn -Prelease-all -DskipTests install -U` to check build', 'commenter': 'yuz10'}]"
3305,acl/src/test/java/org/apache/rocketmq/acl/common/AclUtilsTest.java,"@@ -31,6 +31,8 @@
 
 public class AclUtilsTest {
 
+    //  strArray[i] = StringUtils.leftPad(strArray[i],4, '0');","[{'comment': 'The comment is meaningless \r\n\r\n', 'commenter': 'yuz10'}]"
3336,docs/cn/RocketMQ_Example.md,"@@ -438,6 +438,7 @@ public class ScheduledMessageConsumer {
    public static void main(String[] args) throws Exception {
       // 实例化消费者
       DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(""ExampleConsumer"");
+      consumer.setNamesrvAddr(""127.0.0.1:9876"");","[{'comment': 'NamesrvAddr is not necessary for the sample code, you can look at the official website sample （ https://rocketmq.apache.org/docs/quick-start/ ）, export NAMESRV_ADDR=localhost:9876', 'commenter': 'odbozhou'}]"
3337,common/src/main/java/org/apache/rocketmq/common/message/MessageConst.java,"@@ -52,6 +52,10 @@
     public static final String PROPERTY_PUSH_REPLY_TIME = ""PUSH_REPLY_TIME"";
     public static final String PROPERTY_CLUSTER = ""CLUSTER"";
     public static final String PROPERTY_MESSAGE_TYPE = ""MSG_TYPE"";
+    public static final String PROPERTY_SPECIFY_DELAY_TIME = ""SPECIFY_DELAY_TIME"";","[{'comment': 'Maybe ""CUSTOM_DELAY_TIME"" is a better name? ', 'commenter': 'Jason918'}, {'comment': 'ok ', 'commenter': 'dragonTalon'}]"
3337,namesrv/src/main/java/org/apache/rocketmq/namesrv/NamesrvStartup.java,"@@ -48,6 +50,7 @@
     private static CommandLine commandLine = null;
 
     public static void main(String[] args) {
+        System.setProperty(MixAll.ROCKETMQ_HOME_PROPERTY, ""/Users/dragonboy/IdeaProjects/rocketmq/distribution"");","[{'comment': 'Test code? ', 'commenter': 'Jason918'}]"
3337,broker/src/main/java/org/apache/rocketmq/broker/BrokerStartup.java,"@@ -64,7 +64,7 @@ public static BrokerController start(BrokerController controller) {
             controller.start();
 
             String tip = ""The broker["" + controller.getBrokerConfig().getBrokerName() + "", ""
-                + controller.getBrokerAddr() + ""] boot success. serializeType="" + RemotingCommand.getSerializeTypeConfigInThisServer();
+                    + controller.getBrokerAddr() + ""] boot success. serializeType="" + RemotingCommand.getSerializeTypeConfigInThisServer();","[{'comment': ""I think it's better not changing the format of old code without logical modification."", 'commenter': 'Jason918'}]"
3337,store/src/main/java/org/apache/rocketmq/store/config/StorePathConfigHelper.java,"@@ -48,6 +48,10 @@ public static String getDelayOffsetStorePath(final String rootDir) {
         return rootDir + File.separator + ""config"" + File.separator + ""delayOffset.json"";
     }
 
+    public static String getSpcifyDelayOffsetStorePath(final String rootDir) {
+        return rootDir + File.separator + ""dragon"" + File.separator + ""delayOffset.json"";","[{'comment': '""dragon"" here is a little confusing.', 'commenter': 'Jason918'}]"
3337,store/src/main/java/org/apache/rocketmq/store/schedule/CustomDelayMessageService.java,"@@ -0,0 +1,496 @@
+package org.apache.rocketmq.store.schedule;
+
+import io.netty.util.concurrent.DefaultThreadFactory;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.common.ConfigManager;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.common.TopicFilterType;
+import org.apache.rocketmq.common.constant.LoggerName;
+import org.apache.rocketmq.common.message.MessageAccessor;
+import org.apache.rocketmq.common.message.MessageConst;
+import org.apache.rocketmq.common.message.MessageDecoder;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.running.RunningStats;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.logging.InternalLoggerFactory;
+import org.apache.rocketmq.store.*;
+import org.apache.rocketmq.store.config.StorePathConfigHelper;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.TimerTask;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * @ClassName CutomDelayMessageService
+ * @Version 1.0
+ * @Author dragonboy
+ * @Date 2021/9/6 14:12
+ * @Description
+ **/
+public class CustomDelayMessageService extends ConfigManager {","[{'comment': 'Please add some unit tests.', 'commenter': 'Jason918'}]"
3337,store/src/main/java/org/apache/rocketmq/store/schedule/CustomDelayMessageService.java,"@@ -0,0 +1,496 @@
+package org.apache.rocketmq.store.schedule;
+
+import io.netty.util.concurrent.DefaultThreadFactory;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.common.ConfigManager;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.common.TopicFilterType;
+import org.apache.rocketmq.common.constant.LoggerName;
+import org.apache.rocketmq.common.message.MessageAccessor;
+import org.apache.rocketmq.common.message.MessageConst;
+import org.apache.rocketmq.common.message.MessageDecoder;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.running.RunningStats;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.logging.InternalLoggerFactory;
+import org.apache.rocketmq.store.*;
+import org.apache.rocketmq.store.config.StorePathConfigHelper;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.TimerTask;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * @ClassName CutomDelayMessageService
+ * @Version 1.0
+ * @Author dragonboy
+ * @Date 2021/9/6 14:12
+ * @Description
+ **/
+public class CustomDelayMessageService extends ConfigManager {
+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);
+
+    public static final String SCHEDULE_TOPIC = ""DRAGON_TOPIC_XXX"";
+
+    private static final Pattern pattern = Pattern.compile(""([0-9]+d)*([0-9]+h)*([0-9]+m)*([0-9]+s)*"");
+
+    private static final HashMap<String, Long> timeUnitTable = new HashMap<String, Long>() {{
+        this.put(""s"", 1000L);
+        this.put(""m"", 1000L * 60);
+        this.put(""h"", 1000L * 60 * 60);
+        this.put(""d"", 1000L * 60 * 60 * 24);
+    }};
+
+    //最大限度的处理层级
+    public static int MAX_LIMIT_LEVEL = 0;","[{'comment': 'This should not be constant and not configurable.', 'commenter': 'Jason918'}, {'comment': 'this code support custom time in 7 day \r\nso,this is record max level.\r\nif level more max level Cause out of bounds', 'commenter': 'dragonTalon'}, {'comment': 'i wang change this code , use System.getProperty(""custom.delaytime"") set delay config', 'commenter': 'dragonTalon'}]"
3337,broker/src/main/java/org/apache/rocketmq/broker/BrokerStartup.java,"@@ -212,10 +212,10 @@ public static BrokerController createBrokerController(String[] args) {
             MixAll.printObjectProperties(log, messageStoreConfig);
 
             final BrokerController controller = new BrokerController(
-                brokerConfig,
-                nettyServerConfig,
-                nettyClientConfig,
-                messageStoreConfig);
+                    brokerConfig,","[{'comment': ""It seems that only the indention is changed in this file. \r\nIMHO, It's better keep as it is, because it will change the log history, and it will be confusing if someone want to check the implementation details through the git log."", 'commenter': 'Jason918'}, {'comment': 'ok ,i reduction this file', 'commenter': 'dragonTalon'}]"
3338,README.md,"@@ -15,7 +15,7 @@ It offers a variety of features:
 * Messaging patterns including publish/subscribe, request/reply and streaming
 * Financial grade transactional message
 * Built-in fault tolerance and high availability configuration options base on [DLedger](https://github.com/openmessaging/openmessaging-storage-dledger)
-* A variety of cross language clients, such as Java, C/C++, Python, Go
+* A variety of cross language clients, such as Java, [C/C++](https://github.com/apache/rocketmq-client-cpp), [Python](https://github.com/apache/rocketmq-client-python), [Go](https://github.com/apache/rocketmq-client-go),[Node.js](https://github.com/apache/rocketmq-client-nodejs)","[{'comment': 'a space before `[Node.js]`', 'commenter': 'ifplusor'}]"
3357,broker/src/main/java/org/apache/rocketmq/broker/processor/SendMessageProcessor.java,"@@ -635,8 +636,16 @@ public SocketAddress getStoreHost() {
     }
 
     private String diskUtil() {
-        String storePathPhysic = this.brokerController.getMessageStoreConfig().getStorePathCommitLog();
-        double physicRatio = UtilAll.getDiskPartitionSpaceUsedPercent(storePathPhysic);
+        double physicRatio = -1;
+        String storePath =this.brokerController.getMessageStoreConfig().getStorePathCommitLog();
+        if (storePath.contains(MessageStoreConfig.MULTI_PATH_SPLITTER)) {
+            String[] paths = storePath.trim().split(MessageStoreConfig.MULTI_PATH_SPLITTER);
+            for (String storePathPhysic : paths) {
+                physicRatio = Math.min(physicRatio, UtilAll.getDiskPartitionSpaceUsedPercent(storePathPhysic));","[{'comment': 'Is `Math.min()` correct here? `physicRatio` is initialized as `-1` and `UtilAll.getDiskPartitionSpaceUsedPercent()` always returns value greater or equal to `-1`.', 'commenter': 'caigy'}, {'comment': '@caigy Yes, you are right. Fixed.', 'commenter': 'Jason918'}]"
3357,store/src/main/java/org/apache/rocketmq/store/DefaultMessageStore.java,"@@ -782,10 +783,20 @@ private String getStorePathPhysic() {
     public HashMap<String, String> getRuntimeInfo() {
         HashMap<String, String> result = this.storeStatsService.getRuntimeInfo();
 
-        {
-            double physicRatio = UtilAll.getDiskPartitionSpaceUsedPercent(getStorePathPhysic());
+        String commitLogStorePath = DefaultMessageStore.this.getMessageStoreConfig().getStorePathCommitLog();
+        if (commitLogStorePath.contains(MessageStoreConfig.MULTI_PATH_SPLITTER)) {
+            double maxValue = Double.MIN_VALUE;","[{'comment': 'Is `maxPhysicsUsedRatio` more appropriate?', 'commenter': 'caigy'}, {'comment': ""@caigy Yes, `maxPhysicsUsedRatio` is better .\r\nBut after some consideration, I think we should use `minPhysicsUsedRatio`. It's more useful for admins, because we use min value of all store path to determine whether disk is full and we should clean disk immediately."", 'commenter': 'Jason918'}, {'comment': '@Jason918 I agree. Using `minPhysicsUsedRatio` is more suitable for this scenario. ', 'commenter': 'caigy'}]"
3357,store/src/main/java/org/apache/rocketmq/store/config/MessageStoreConfig.java,"@@ -17,10 +17,14 @@
 package org.apache.rocketmq.store.config;
 
 import java.io.File;
+
 import org.apache.rocketmq.common.annotation.ImportantField;
 import org.apache.rocketmq.store.ConsumeQueue;
 
 public class MessageStoreConfig {
+
+    public static final String MULTI_PATH_SPLITTER = "":"";","[{'comment': 'IMHO, "":""  can be confusing sometimes, especially on Windows, where the storage path contains C: XXX, eg.', 'commenter': 'duhenglucky'}, {'comment': ""YES, it would be confusing. Thank you for the reminding.\r\nA common reserved character would be a nice fit for this splitter.\r\nAccording to[ Comparison of file Systems](https://en.wikipedia.org/wiki/Comparison_of_file_systems), different files system have different reserved characters. So there is no best character for this splitter,  and I am using ',' as default splitter, user can change it using system property `rocketmq.broker.multiPathSplitter`\r\n"", 'commenter': 'Jason918'}]"
3357,broker/src/main/java/org/apache/rocketmq/broker/processor/SendMessageProcessor.java,"@@ -635,8 +636,16 @@ public SocketAddress getStoreHost() {
     }
 
     private String diskUtil() {
-        String storePathPhysic = this.brokerController.getMessageStoreConfig().getStorePathCommitLog();
-        double physicRatio = UtilAll.getDiskPartitionSpaceUsedPercent(storePathPhysic);
+        double physicRatio = 100;
+        String storePath = this.brokerController.getMessageStoreConfig().getStorePathCommitLog();
+        if (storePath.contains(MessageStoreConfig.MULTI_PATH_SPLITTER)) {
+            String[] paths = storePath.trim().split(MessageStoreConfig.MULTI_PATH_SPLITTER);
+            for (String storePathPhysic : paths) {
+                physicRatio = Math.min(physicRatio, UtilAll.getDiskPartitionSpaceUsedPercent(storePathPhysic));
+            }
+        } else {
+            physicRatio = UtilAll.getDiskPartitionSpaceUsedPercent(storePath);","[{'comment': 'this if branch is not necessary, could use the same code with MULTI_PATH branch', 'commenter': 'yuz10'}, {'comment': 'updated.', 'commenter': 'Jason918'}]"
3357,store/src/main/java/org/apache/rocketmq/store/DefaultMessageStore.java,"@@ -782,16 +783,28 @@ private String getStorePathPhysic() {
     public HashMap<String, String> getRuntimeInfo() {
         HashMap<String, String> result = this.storeStatsService.getRuntimeInfo();
 
-        {
-            double physicRatio = UtilAll.getDiskPartitionSpaceUsedPercent(getStorePathPhysic());
+        String commitLogStorePath = DefaultMessageStore.this.getMessageStoreConfig().getStorePathCommitLog();","[{'comment': 'Dose it support dledger mode? the original code getStorePathPhysic() has different value of  commitLogStorePath in dledger mode', 'commenter': 'yuz10'}, {'comment': 'Thank you for the reminding. \r\nChanged to `getStorePathPhysic()`', 'commenter': 'Jason918'}]"
3357,store/src/main/java/org/apache/rocketmq/store/DefaultMessageStore.java,"@@ -1650,25 +1663,49 @@ private boolean isSpaceToDelete() {
             cleanImmediately = false;
 
             {
-                double physicRatio = UtilAll.getDiskPartitionSpaceUsedPercent(getStorePathPhysic());
-                if (physicRatio > diskSpaceWarningLevelRatio) {
+                String[] storePaths;
+                String commitLogStorePath = DefaultMessageStore.this.getMessageStoreConfig().getStorePathCommitLog();
+                if (commitLogStorePath.contains(MessageStoreConfig.MULTI_PATH_SPLITTER)) {
+                    storePaths = commitLogStorePath.trim().split(MessageStoreConfig.MULTI_PATH_SPLITTER);
+                } else {
+                    storePaths = new String[]{commitLogStorePath};","[{'comment': 'not necessary if branch, could use the same code with MULTI_PATH branch', 'commenter': 'yuz10'}, {'comment': 'updated.', 'commenter': 'Jason918'}]"
3357,store/src/main/java/org/apache/rocketmq/store/MappedFileQueue.java,"@@ -144,35 +145,39 @@ void deleteExpiredFile(List<MappedFile> files) {
         }
     }
 
+
     public boolean load() {
         File dir = new File(this.storePath);
-        File[] files = dir.listFiles();
-        if (files != null) {
-            // ascending order
-            Arrays.sort(files);
-            for (File file : files) {
-
-                if (file.length() != this.mappedFileSize) {
-                    log.warn(file + ""\t"" + file.length()
-                        + "" length not matched message store config value, please check it manually"");
-                    return false;
-                }
+        File[] ls = dir.listFiles();
+        if (ls != null) {
+            return doLoad(Arrays.asList(ls));
+        }
+        return true;
+    }
 
-                try {
-                    MappedFile mappedFile = new MappedFile(file.getPath(), mappedFileSize);
-
-                    mappedFile.setWrotePosition(this.mappedFileSize);
-                    mappedFile.setFlushedPosition(this.mappedFileSize);
-                    mappedFile.setCommittedPosition(this.mappedFileSize);
-                    this.mappedFiles.add(mappedFile);
-                    log.info(""load "" + file.getPath() + "" OK"");
-                } catch (IOException e) {
-                    log.error(""load file "" + file + "" error"", e);
-                    return false;
-                }
+    public boolean doLoad(List<File> files) {
+        // ascending order
+        Collections.sort(files);","[{'comment': 'According to the code :\r\n![image](https://user-images.githubusercontent.com/14816818/134317644-4061cb3f-5470-43bf-bf52-ee974458db10.png)\r\nif paths are a/, b/ then files will be created such as:\r\na/000000   b/000001  a/000002  b/000003\r\nso sort these can cause wrong order.\r\na/000000   a/000002  b/000001  b/000003\r\n\r\nthis is test case:\r\n![image](https://user-images.githubusercontent.com/14816818/134319811-7d986dcf-0ffa-42bb-8aae-796421d86ad4.png)\r\n', 'commenter': 'yuz10'}, {'comment': 'Great point.\r\nChanged `Collections.sort(files)` to `files.sort(Comparator.comparing(File::getName))`,  sort the file using simple filenames, aka, the last part of the path.\r\n\r\nAnd added test in org.apache.rocketmq.store.MultiPathMappedFileQueueTest#testLoadReadOnlyMappedFiles， PTAL.', 'commenter': 'Jason918'}]"
3357,store/src/main/java/org/apache/rocketmq/store/MultiPathMappedFileQueue.java,"@@ -0,0 +1,127 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.store;
+
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.function.Supplier;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.store.config.MessageStoreConfig;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class MultiPathMappedFileQueue extends MappedFileQueue {
+
+    private final MessageStoreConfig config;
+    private final Supplier<Set<String>> fullStorePathsSupplier;
+
+    public MultiPathMappedFileQueue(MessageStoreConfig messageStoreConfig, int mappedFileSize,
+                                    AllocateMappedFileService allocateMappedFileService,
+                                    Supplier<Set<String>> fullStorePathsSupplier) {
+        super(messageStoreConfig.getStorePathCommitLog(), mappedFileSize, allocateMappedFileService);
+        this.config = messageStoreConfig;
+        this.fullStorePathsSupplier = fullStorePathsSupplier;
+    }
+
+    private Set<String> getPaths() {
+        String[] paths = config.getStorePathCommitLog().trim().split(MessageStoreConfig.MULTI_PATH_SPLITTER);
+        return new HashSet<>(Arrays.asList(paths));
+    }
+
+    private Set<String> getReadonlyPaths() {
+        String pathStr = config.getReadOnlyCommitLogStorePaths();
+        if (StringUtils.isBlank(pathStr)) {
+            return Collections.emptySet();
+        }
+        String[] paths = pathStr.trim().split(MessageStoreConfig.MULTI_PATH_SPLITTER);
+        return new HashSet<>(Arrays.asList(paths));
+    }
+
+    @Override
+    public boolean load() {
+        Set<String> storePathSet = getPaths();
+        storePathSet.addAll(getReadonlyPaths());
+
+        List<File> files = new ArrayList<>();
+        for (String path : storePathSet) {
+            File dir = new File(path);
+            File[] ls = dir.listFiles();
+            if (ls != null) {
+                Collections.addAll(files, ls);
+            }
+        }
+
+        return doLoad(files);
+    }
+
+    @Override
+    protected MappedFile tryCreateMappedFile(long createOffset) {
+        long fileIdx = createOffset / this.mappedFileSize;
+        Set<String> storePath = getPaths();
+        Set<String> readonlyPathSet = getReadonlyPaths();
+        Set<String> fullStorePaths =
+                fullStorePathsSupplier == null ? Collections.emptySet() : fullStorePathsSupplier.get();
+
+
+        HashSet<String> availableStorePath = new HashSet<>(storePath);
+        //do not create file in readonly store path.
+        availableStorePath.removeAll(readonlyPathSet);
+
+        //do not create file is space is nearly full.
+        availableStorePath.removeAll(fullStorePaths);
+
+        //if no store path left, fall back to wriable store path.","[{'comment': 'wriable --> writable', 'commenter': 'lollipopjin'}, {'comment': 'fixed.', 'commenter': 'Jason918'}]"
3386,remoting/src/main/java/org/apache/rocketmq/remoting/protocol/RemotingSerializable.java,"@@ -17,11 +17,17 @@
 package org.apache.rocketmq.remoting.protocol;
 
 import com.alibaba.fastjson.JSON;
+import com.alibaba.fastjson.serializer.SerializerFeature;
+
 import java.nio.charset.Charset;
 
 public abstract class RemotingSerializable {
     private final static Charset CHARSET_UTF8 = Charset.forName(""UTF-8"");
 
+    static {","[{'comment': 'Changing default behavior may bring about far-reaching impacts. It would be best to use the overloading method ```JSON.toJSONString(Object object, SerializerFeature... features)```, modifying behavior of RocketMQ-scope.', 'commenter': 'lizhanhui'}, {'comment': 'fastjson默认生成的key会产生不规范情况，如果只是重载方法，那样子就需要修改很多可能不规范的地方的调用，然后，改动量很大！现在只需要加这一个序列化属性，让rocketmq的所有remote调用结果全部是合法的json@我认为这是一个错误，而不算是一个优化了！', 'commenter': 'liuxuzxx'}, {'comment': '这个我已经测试过了，这个remote模块会被admin和client都包含，所以这样子也能做到服务端和客户端的序列化属性的一致性，要不然可能会产生客户端和服务端的序列化属性不一致的情况！', 'commenter': 'liuxuzxx'}, {'comment': '总体来说，我认为这是一个bug，而不是一个优化点，因为这个json数据，go无法解析，在线测试json格式也是错误的，然后jackson也无法解析，只能是fastjson自己产生，以及解析！这是不是就有点违背json原本跨语言的原则了！', 'commenter': 'liuxuzxx'}, {'comment': 'I agree it can be safely regarded as **A BUG** for not generating standard-conforming **JSON**. But it would be necessary not to modify global behavior without notice. Consider this scenario, an application developer uses RocketMQ client and FastJSON at the same time. If our client quietly changes the default behavior, we may break his/her application or mess his data up totally in case he/she depends on the default behavior.\r\n\r\nFurther, IMO, RocketMQ-scope changes can be achieved through modifying RemotingSerializable.java#decode/encode only. ', 'commenter': 'lizhanhui'}, {'comment': 'Before modifying the behavior, we have to:\r\n1, Make sure code can correctly deserialize JSON strings previously serialized without Compatible Feature configured;\r\n2, Make sure clients without feature configured may compatibly parse standard JSON;\r\n3, Verify JSON generated with feature configured can serialize and deserialize complex objects, say a map with non-string key.\r\n\r\nOnce these three compatible concerns are resolved, I am glad to +1 for this pull request.', 'commenter': 'lizhanhui'}, {'comment': 'ok，我感觉这个最大的隐患可能是broker和namesrv是否需要同时设置SerializerFeature.WriteNonStringKeyAsString的问题，我在低版本的fastjson1.2.58好像，是必须同时设置的！如果最新版本的fastjson也需要同时设置，那就真得两边同时修改了！', 'commenter': 'liuxuzxx'}, {'comment': 'I suggest we adopt a test-driven development strategy for this issue.  Create 3 or more unit tests, which help us guarantee changes are always compatible with the community and discuss potential solutions where issues show up.', 'commenter': 'lizhanhui'}, {'comment': '测试了下fastjson的最新版本(1.2.76)是可以适配两种json格式的处理的，但是考虑到客户端的fastjson的版本是否也能够兼容和适配，存在风险性。\r\n由于存在服务模块，namesrv，broker三者之间通过rpc的方式进行交流，所以，为了兼容，我想了如下方案来处理：\r\n```\r\norg.apache.rocketmq.remoting.protocol.RemotingCommand 这个类所有的请求命令类，在这个类里面有个属性：version，这个属性记录了当前请求的RocketMQ的版本号，那么就可以根据这个版本号来判断，toJSON()调用的时候是否需要设置：\r\nSerializerFeature.WriteNonStringKeyAsString 属性，具体的伪代码如下：\r\n\r\nif(version>= 设置了WriteNonStringKeyAsString版本号){\r\n    return JSON.toJSON(obj,SerializerFeature.WriteNonStringKeyAsString);\r\n}else{\r\n    return JSON.toJSON(obj);\r\n}\r\n```\r\n目前我只能想到这个兼容方案了，因为，可能存在客户端，namesrv和broker以及不同的broker版本号都可能不一致的情况，所以，你之前提到的三个问题，如果是通过我这种一棍子打死的方式来处理，确实很粗暴。那么正好就利用这个version属性来做这个版本的分割线判断！', 'commenter': 'liuxuzxx'}]"
3427,client/src/main/java/org/apache/rocketmq/client/ClientConfig.java,"@@ -274,20 +275,28 @@ public void setLanguage(LanguageCode language) {
     }
 
     public String getNamespace() {
+        if (namespaceInitialized) {
+            return namespace;
+        }
+
         if (StringUtils.isNotEmpty(namespace)) {
             return namespace;
         }
 
         if (StringUtils.isNotEmpty(this.namesrvAddr)) {
             if (NameServerAddressUtils.validateInstanceEndpoint(namesrvAddr)) {
-                return NameServerAddressUtils.parseInstanceIdFromEndpoint(namesrvAddr);
+                namespace = NameServerAddressUtils.parseInstanceIdFromEndpoint(namesrvAddr);","[{'comment': ""The `namesrvAddr` is not final and can be updated after creation.\r\nThis will break the compatibility.\r\nIt's better that we can update namespace in `setNamesrvAddr`."", 'commenter': 'Jason918'}, {'comment': 'please fixup it.', 'commenter': 'colin-lee'}]"
3506,tools/src/main/java/org/apache/rocketmq/tools/command/consumer/SetConsumeModeSubCommand.java,"@@ -64,7 +64,7 @@ public Options buildCommandlineOptions(Options options) {
         opt.setRequired(true);
         options.addOption(opt);
 
-        opt = new Option(""n"", ""popShareQueueNum"", true, ""num fo queue which share in pop mode"");
+        opt = new Option(""q"", ""popShareQueueNum"", true, ""num of queue which share in pop mode"");","[{'comment': 'Why do we need change this? It seems would cause some compatibility issue.\r\n', 'commenter': 'Jason918'}, {'comment': 'This option is already used by namesrv', 'commenter': 'Git-Yang'}]"
3595,test/src/main/java/org/apache/rocketmq/test/util/MQAdmin.java,"@@ -123,10 +124,10 @@ public static boolean isBrokerExist(String ns, String ip) {
             return false;
         } else {
             HashMap<String, BrokerData> brokers = clusterInfo.getBrokerAddrTable();
-            for (String brokerName : brokers.keySet()) {
-                HashMap<Long, String> brokerIps = brokers.get(brokerName).getBrokerAddrs();
-                for (long brokerId : brokerIps.keySet()) {
-                    if (brokerIps.get(brokerId).contains(ip))
+            for (Entry<String, BrokerData> brokerNameEntry : brokers.entrySet()) {","[{'comment': 'brokerNameEntry could be renamed to brokerEntry', 'commenter': 'yuz10'}, {'comment': 'already edited', 'commenter': 'zhaohai666'}]"
3595,tools/src/main/java/org/apache/rocketmq/tools/command/CommandUtil.java,"@@ -63,12 +64,12 @@
             String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);
             masterAndSlaveMap.put(masterAddr, new ArrayList<String>());
 
-            for (Long id : brokerData.getBrokerAddrs().keySet()) {
-                if (brokerData.getBrokerAddrs().get(id) == null || id == MixAll.MASTER_ID) {
+            for (Entry<Long, String> idEntry : brokerData.getBrokerAddrs().entrySet()) {
+                if (idEntry.getValue() == null || idEntry.getKey() == MixAll.MASTER_ID) {","[{'comment': 'idEntry could be renamed to brokerAddrEntry', 'commenter': 'yuz10'}]"
3595,tools/src/main/java/org/apache/rocketmq/tools/command/broker/GetBrokerConfigCommand.java,"@@ -83,19 +86,19 @@ public void execute(final CommandLine commandLine, final Options options,
                 Map<String, List<String>> masterAndSlaveMap
                     = CommandUtil.fetchMasterAndSlaveDistinguish(defaultMQAdminExt, clusterName);
 
-                for (String masterAddr : masterAndSlaveMap.keySet()) {
+                for (Entry<String, List<String>> masterAddrEntry : masterAndSlaveMap.entrySet()) {","[{'comment': 'masterAddrEntry could be renamed to masterAndSlaveEntry', 'commenter': 'yuz10'}, {'comment': 'already edited', 'commenter': 'zhaohai666'}]"
3595,tools/src/main/java/org/apache/rocketmq/tools/command/broker/GetBrokerConfigCommand.java,"@@ -121,8 +124,8 @@ protected void getAndPrint(final MQAdminExt defaultMQAdminExt, final String prin
             return;
         }
 
-        for (Object key : properties.keySet()) {
-            System.out.printf(""%-50s=  %s\n"", key, properties.get(key));
+        for (Entry<Object, Object> keyEntry : properties.entrySet()) {
+            System.out.printf(""%-50s=  %s\n"", keyEntry.getKey(), keyEntry.getValue());","[{'comment': 'keyEntry could be renamed to entry, and so is the obove', 'commenter': 'yuz10'}, {'comment': 'already edited', 'commenter': 'zhaohai666'}]"
3595,tools/src/main/java/org/apache/rocketmq/tools/command/consumer/GetConsumerConfigSubCommand.java,"@@ -63,14 +65,14 @@ public void execute(CommandLine commandLine, Options options,
             List<ConsumerConfigInfo> consumerConfigInfoList = new ArrayList<>();
             ClusterInfo clusterInfo = adminExt.examineBrokerClusterInfo();
             Map<String, Set<String>> clusterAddrTable = clusterInfo.getClusterAddrTable();
-            for (String brokerName : clusterInfo.getBrokerAddrTable().keySet()) {
-                String clusterName = this.getClusterName(brokerName, clusterAddrTable);
-                String brokerAddress = clusterInfo.getBrokerAddrTable().get(brokerName).selectBrokerAddr();
+            for (Entry<String, BrokerData> brokerNameEntry : clusterInfo.getBrokerAddrTable().entrySet()) {","[{'comment': 'brokerNameEntry could be rename to brokerEntry', 'commenter': 'yuz10'}, {'comment': 'already edited', 'commenter': 'zhaohai666'}]"
3595,tools/src/main/java/org/apache/rocketmq/tools/command/export/ExportConfigsCommand.java,"@@ -79,10 +81,10 @@ public void execute(CommandLine commandLine, Options options, RPCHook rpcHook)
             Map<String, Properties> brokerConfigs = new HashMap<>();
             Map<String, List<String>> masterAndSlaveMap
                 = CommandUtil.fetchMasterAndSlaveDistinguish(defaultMQAdminExt, clusterName);
-            for (String masterAddr : masterAndSlaveMap.keySet()) {
-                Properties masterProperties = defaultMQAdminExt.getBrokerConfig(masterAddr);
+            for (Entry<String, List<String>> masterAddrEntry : masterAndSlaveMap.entrySet()) {","[{'comment': 'masterAddrEntry could be renamed to masterAndSlaveEntry', 'commenter': 'yuz10'}, {'comment': 'already edited', 'commenter': 'zhaohai666'}]"
3595,tools/src/main/java/org/apache/rocketmq/tools/command/namesrv/GetNamesrvConfigCommand.java,"@@ -66,11 +69,11 @@ public void execute(final CommandLine commandLine, final Options options,
 
             Map<String, Properties> nameServerConfigs = defaultMQAdminExt.getNameServerConfig(serverList);
 
-            for (String server : nameServerConfigs.keySet()) {
+            for (Entry<String, Properties> serverEntry : nameServerConfigs.entrySet()) {","[{'comment': 'serverEntry could be renamed to nameServerConfigEntry', 'commenter': 'yuz10'}, {'comment': 'already edited', 'commenter': 'zhaohai666'}]"
3639,client/src/main/java/org/apache/rocketmq/client/producer/RequestFutureHolder.java,"@@ -74,14 +69,39 @@ public void scanExpiredRequest() {
         }
     }
 
-    private RequestFutureHolder() {
+    public synchronized void startScheduledTask() {
+        if (this.producerNum.incrementAndGet() == 1) {
+            this.getScheduledExecutorService().scheduleAtFixedRate(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        RequestFutureHolder.getInstance().scanExpiredRequest();
+                    } catch (Throwable e) {
+                        log.error(""scan RequestFutureTable exception"", e);
+                    }
+                }
+            }, 1000 * 3, 1000, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    public synchronized void shutdown() {
+        if (this.producerNum.decrementAndGet() == 0) {
+            this.getScheduledExecutorService().shutdown();","[{'comment': 'set the scheduledExecutorService to null?', 'commenter': 'areyouok'}, {'comment': 'ok', 'commenter': 'panzhi33'}, {'comment': '1. shutdown \r\n2. set to null', 'commenter': 'areyouok'}, {'comment': 'ok', 'commenter': 'panzhi33'}]"
3639,client/src/main/java/org/apache/rocketmq/client/producer/RequestFutureHolder.java,"@@ -37,19 +38,13 @@
     private static final RequestFutureHolder INSTANCE = new RequestFutureHolder();
     private ConcurrentHashMap<String, RequestResponseFuture> requestFutureTable = new ConcurrentHashMap<String, RequestResponseFuture>();
     private final AtomicInteger producerNum = new AtomicInteger(0);","[{'comment': 'there is no need use AtomicInteger.\r\n\r\nI suggest change to HashSet《DefaultMQProducerImpl》 and startScheduledTask/shutdown support re-entry. \r\n\r\neg: called DefaultMQProducerImpl.shutdown got exception, and the user may call shutdown again.', 'commenter': 'areyouok'}, {'comment': 'like this?\r\nif(set.size > 0 && state != running) {\r\n   startScheduledTask\r\n}\r\n\r\nif(set.size<=0 && state != shutdown){\r\n  shutdown \r\n}', 'commenter': 'panzhi33'}]"
3639,client/src/main/java/org/apache/rocketmq/client/producer/RequestFutureHolder.java,"@@ -74,14 +69,40 @@ public void scanExpiredRequest() {
         }
     }
 
-    private RequestFutureHolder() {
+    public synchronized void startScheduledTask() {
+        if (this.producerNum.incrementAndGet() == 1) {
+            this.getScheduledExecutorService().scheduleAtFixedRate(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        RequestFutureHolder.getInstance().scanExpiredRequest();
+                    } catch (Throwable e) {
+                        log.error(""scan RequestFutureTable exception"", e);
+                    }
+                }
+            }, 1000 * 3, 1000, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    public synchronized void shutdown() {
+        if (this.producerNum.decrementAndGet() == 0) {
+            this.scheduledExecutorService.shutdown();
+            this.scheduledExecutorService = null;
+        }
     }
 
-    public AtomicInteger getProducerNum() {
-        return producerNum;
+    private RequestFutureHolder() {
     }
 
-    public ScheduledExecutorService getScheduledExecutorService() {
+    private ScheduledExecutorService getScheduledExecutorService() {
+        if (null == scheduledExecutorService || scheduledExecutorService.isShutdown()) {","[{'comment': 'no need to check isShutdown', 'commenter': 'areyouok'}]"
3639,client/src/main/java/org/apache/rocketmq/client/producer/RequestFutureHolder.java,"@@ -74,14 +69,40 @@ public void scanExpiredRequest() {
         }
     }
 
-    private RequestFutureHolder() {
+    public synchronized void startScheduledTask() {
+        if (this.producerNum.incrementAndGet() == 1) {
+            this.getScheduledExecutorService().scheduleAtFixedRate(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        RequestFutureHolder.getInstance().scanExpiredRequest();
+                    } catch (Throwable e) {
+                        log.error(""scan RequestFutureTable exception"", e);
+                    }
+                }
+            }, 1000 * 3, 1000, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    public synchronized void shutdown() {
+        if (this.producerNum.decrementAndGet() == 0) {
+            this.scheduledExecutorService.shutdown();","[{'comment': 'check null', 'commenter': 'areyouok'}, {'comment': 'may thutdown() throws exception? \r\n\r\nthe below code maybe better?\r\n```\r\nScheduledExecutorService ses = this.scheduledExecutorService;\r\nthis.scheduledExecutorService = null;\r\nses.shutdown();\r\n```\r\n', 'commenter': 'areyouok'}, {'comment': 'yes，it would be better', 'commenter': 'panzhi33'}]"
3639,client/src/main/java/org/apache/rocketmq/client/producer/RequestFutureHolder.java,"@@ -74,14 +73,47 @@ public void scanExpiredRequest() {
         }
     }
 
-    private RequestFutureHolder() {
+    public synchronized void startScheduledTask(DefaultMQProducerImpl producer) {
+        this.producerSet.add(producer);
+        if (this.producerSet.size() >= 1 && this.serviceState != ServiceState.RUNNING) {
+            this.serviceState = ServiceState.START_FAILED;
+
+            this.getScheduledExecutorService().scheduleAtFixedRate(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        RequestFutureHolder.getInstance().scanExpiredRequest();
+                    } catch (Throwable e) {
+                        log.error(""scan RequestFutureTable exception"", e);
+                    }
+                }
+            }, 1000 * 3, 1000, TimeUnit.MILLISECONDS);
+
+            this.serviceState = ServiceState.RUNNING;
+        }
     }
 
-    public AtomicInteger getProducerNum() {
-        return producerNum;
+    public synchronized void shutdown(DefaultMQProducerImpl producer) {
+        this.producerSet.remove(producer);
+        if (this.producerSet.size() <= 0 && null != this.scheduledExecutorService && this.serviceState != ServiceState.SHUTDOWN_ALREADY) {
+            this.scheduledExecutorService.shutdown();
+            this.scheduledExecutorService = null;
+            this.serviceState = ServiceState.SHUTDOWN_ALREADY;
+        }
     }
 
-    public ScheduledExecutorService getScheduledExecutorService() {
+    private RequestFutureHolder() {
+    }
+
+    private ScheduledExecutorService getScheduledExecutorService() {
+        if (null == scheduledExecutorService) {
+            scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {","[{'comment': 'Maybe better to replace ThreadFactory with ThreadFactoryImpl.', 'commenter': 'Git-Yang'}]"
3639,client/src/main/java/org/apache/rocketmq/client/producer/RequestFutureHolder.java,"@@ -74,14 +73,42 @@ public void scanExpiredRequest() {
         }
     }
 
-    private RequestFutureHolder() {
+    public synchronized void startScheduledTask(DefaultMQProducerImpl producer) {
+        this.producerSet.add(producer);
+        if (this.producerSet.size() >= 1 && this.serviceState != ServiceState.RUNNING) {
+            this.serviceState = ServiceState.START_FAILED;
+
+            this.getScheduledExecutorService().scheduleAtFixedRate(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        RequestFutureHolder.getInstance().scanExpiredRequest();
+                    } catch (Throwable e) {
+                        log.error(""scan RequestFutureTable exception"", e);
+                    }
+                }
+            }, 1000 * 3, 1000, TimeUnit.MILLISECONDS);
+
+            this.serviceState = ServiceState.RUNNING;
+        }
     }
 
-    public AtomicInteger getProducerNum() {
-        return producerNum;
+    public synchronized void shutdown(DefaultMQProducerImpl producer) {
+        this.producerSet.remove(producer);
+        if (this.producerSet.size() <= 0 && null != this.scheduledExecutorService && this.serviceState != ServiceState.SHUTDOWN_ALREADY) {
+            this.scheduledExecutorService.shutdown();
+            this.scheduledExecutorService = null;
+            this.serviceState = ServiceState.SHUTDOWN_ALREADY;
+        }
     }
 
-    public ScheduledExecutorService getScheduledExecutorService() {
+    private RequestFutureHolder() {
+    }
+
+    private ScheduledExecutorService getScheduledExecutorService() {","[{'comment': 'this method should inline', 'commenter': 'areyouok'}]"
3639,client/src/main/java/org/apache/rocketmq/client/producer/RequestFutureHolder.java,"@@ -74,14 +73,42 @@ public void scanExpiredRequest() {
         }
     }
 
-    private RequestFutureHolder() {
+    public synchronized void startScheduledTask(DefaultMQProducerImpl producer) {
+        this.producerSet.add(producer);
+        if (this.producerSet.size() >= 1 && this.serviceState != ServiceState.RUNNING) {","[{'comment': 'no need check producerSet.size()', 'commenter': 'areyouok'}]"
3639,client/src/main/java/org/apache/rocketmq/client/producer/RequestFutureHolder.java,"@@ -17,39 +17,38 @@
 
 package org.apache.rocketmq.client.producer;
 
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.TimeUnit;
 
 import org.apache.rocketmq.client.common.ClientErrorCode;
 import org.apache.rocketmq.client.exception.RequestTimeoutException;
+import org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl;
 import org.apache.rocketmq.client.log.ClientLogger;
+import org.apache.rocketmq.common.ServiceState;
+import org.apache.rocketmq.common.ThreadFactoryImpl;
 import org.apache.rocketmq.logging.InternalLogger;
 
 public class RequestFutureHolder {
     private static InternalLogger log = ClientLogger.getLog();
     private static final RequestFutureHolder INSTANCE = new RequestFutureHolder();
     private ConcurrentHashMap<String, RequestResponseFuture> requestFutureTable = new ConcurrentHashMap<String, RequestResponseFuture>();
-    private final AtomicInteger producerNum = new AtomicInteger(0);
-    private final ScheduledExecutorService scheduledExecutorService = Executors
-        .newSingleThreadScheduledExecutor(new ThreadFactory() {
-            @Override
-            public Thread newThread(Runnable r) {
-                return new Thread(r, ""RequestHouseKeepingService"");
-            }
-        });
+    private final Set<DefaultMQProducerImpl> producerSet = new HashSet<>();
+    private ScheduledExecutorService scheduledExecutorService = null;
+    private ServiceState serviceState = ServiceState.CREATE_JUST;","[{'comment': 'this serviceState is duplicate. we can use scheduledExecutorService==null to check', 'commenter': 'areyouok'}]"
3655,.travis.yml,"@@ -45,9 +45,9 @@ before_script:
 script:
   - mvn verify -DskipTests
   - travis_retry mvn -B clean apache-rat:check
-  - travis_retry mvn -B package jacoco:report coveralls:report
+  - travis_retry mvn -B install jacoco:report coveralls:report","[{'comment': 'ITTest is designed to execute after we run successfully. We have two tasks when building, after success is a heavy operation. If we remove it, we must opt for the core ITTest case. Meanwhile, The queuing problem is very serious and will be exacerbated if you mix long-running tasks in a light task. Our CI/CD system design has been carefully considered. When optimizing the CI/CD system, we should consider all aspects.', 'commenter': 'vongosling'}]"
3678,.travis.yml,"@@ -4,8 +4,10 @@ notifications:
   email:
     recipients:
       - dev@rocketmq.apache.org
+    if: branch = develop OR branch = master","[{'comment': 'Why changing this file?', 'commenter': 'caigy'}, {'comment': 'en,not my changed ,i check out this feature from master, this changed is in master', 'commenter': 'RookieRoll'}, {'comment': 'Do you need me to pull a branch from develop and resubmit it without this change?\r\n\r\n', 'commenter': 'RookieRoll'}]"
3746,tools/src/main/java/org/apache/rocketmq/tools/command/broker/GetMasterSlaveDiffCommand.java,"@@ -0,0 +1,151 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tools.command.broker;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.common.MixAll;
+import org.apache.rocketmq.common.protocol.body.ClusterInfo;
+import org.apache.rocketmq.common.protocol.route.BrokerData;
+import org.apache.rocketmq.remoting.RPCHook;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
+import org.apache.rocketmq.tools.command.SubCommand;
+import org.apache.rocketmq.tools.command.SubCommandException;
+
+import java.util.HashMap;
+import java.util.Set;
+
+public class GetMasterSlaveDiffCommand implements SubCommand {
+    @Override
+    public String commandName() {
+        return ""getMasterSlaveDiff"";
+    }
+
+    @Override
+    public String commandDesc() {
+        return ""Get number of bytes that slave falls behind master."";
+    }
+
+    @Override
+    public Options buildCommandlineOptions(final Options options) {
+        Option opt = new Option(""b"", ""brokerName"", true, ""Broker Name"");
+        opt.setRequired(false);
+        options.addOption(opt);
+
+        opt = new Option(""c"", ""clusterName"", true, ""Cluster Name"");
+        opt.setRequired(false);
+        options.addOption(opt);
+
+        return options;
+    }
+
+    @Override
+    public void execute(final CommandLine commandLine, final Options options,
+        final RPCHook rpcHook) throws SubCommandException {
+        DefaultMQAdminExt defaultMQAdminExt = new DefaultMQAdminExt(rpcHook);
+        defaultMQAdminExt.setInstanceName(Long.toString(System.currentTimeMillis()));
+        try {
+            if (commandLine.hasOption('b')) {
+                String brokerAddr = commandLine.getOptionValue('b').trim();
+                defaultMQAdminExt.start();
+                printDiffForBroker(defaultMQAdminExt, brokerAddr);
+            } else if (commandLine.hasOption('c')) {
+                String clusterName = commandLine.getOptionValue('c').trim();
+                defaultMQAdminExt.start();
+                printDiffForCluster(defaultMQAdminExt, clusterName);
+            }
+        } catch (Exception e) {
+            throw new SubCommandException(this.getClass().getSimpleName() + "" command failed"", e);
+        } finally {
+            defaultMQAdminExt.shutdown();
+        }
+    }
+
+    private void printDiffForCluster(final DefaultMQAdminExt defaultMQAdminExt, String clusterName) throws SubCommandException {
+        ClusterInfo clusterInfo = null;
+        try {
+            clusterInfo = defaultMQAdminExt.examineBrokerClusterInfo();
+        } catch (Exception e) {
+            throw new SubCommandException(this.getClass().getSimpleName() + "" command failed"", e);
+        }
+
+        HashMap<String, Set<String>> clusterMap = clusterInfo.getClusterAddrTable();
+        Set<String> brokerNameSet = clusterMap.get(clusterName);
+        if (brokerNameSet == null || brokerNameSet.isEmpty()) {
+            System.out.printf(""Can not find brokers for the cluster named %s!%n"", clusterName);
+            return;
+        } else {
+            System.out.printf(""%-24s %-24s %-24s %-14s%n"",
+                    ""#Cluster Name"",
+                    ""#Broker Name"",
+                    ""#Broker Address(Master)"",
+                    ""#Diff(Bytes)""
+            );
+            for (String brokerName : brokerNameSet) {
+                HashMap<String/* brokerName */, BrokerData> brokerAddrTable = clusterInfo.getBrokerAddrTable();
+                BrokerData brokerData;
+                if ((brokerData = brokerAddrTable.get(brokerName)) == null) {
+                    continue;
+                } else {
+                    String masterBrokerAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);
+                    if (StringUtils.isBlank(masterBrokerAddr))
+                        continue;
+                    try {","[{'comment': 'suggest all code in loop moving into try catch block. ', 'commenter': 'ni-ze'}, {'comment': ""Thanks for reminding me. I've already optimized it."", 'commenter': 'XiaoyiPeng'}]"
3746,store/src/test/java/org/apache/rocketmq/store/ha/WaitNotifyObjectTest.java,"@@ -40,4 +40,57 @@ public void run() {
         Assert.assertEquals(0, waitNotifyObject.waitingThreadTable.size());
     }
 
+    @Test
+    public void allWaitForRunning() throws Exception {
+
+        final int threadNum = 5;
+        final long waitIntervalMs = 100L;
+        final CountDownLatch latch = new CountDownLatch(threadNum);
+        final WaitNotifyObject waitNotifyObject = new WaitNotifyObject() {
+            @Override
+            protected void onWaitEnd() {
+                latch.countDown();
+            }
+        };
+        long start = System.nanoTime();
+        for (int i = 0; i < threadNum; i++) {
+            Thread t = new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    waitNotifyObject.allWaitForRunning(waitIntervalMs);
+                }
+            });
+            t.start();
+            t.join();
+        }
+
+        latch.await();
+        long elapsed = (System.nanoTime() - start) / 1000000;
+        Assert.assertEquals(threadNum, waitNotifyObject.waitingThreadTable.size());
+        Assert.assertTrue(elapsed >= threadNum * waitIntervalMs);
+    }
+
+    @Test
+    public void wakeup() throws Exception {
+        final long waitIntervalMs = 3000L;
+        final long sleepMs = 500L;
+        final WaitNotifyObject waitNotifyObject = new WaitNotifyObject();
+        long start = System.nanoTime();
+        Thread t = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    Thread.currentThread().sleep(sleepMs);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+                waitNotifyObject.wakeup();
+            }
+        });
+        t.start();
+        waitNotifyObject.waitForRunning(waitIntervalMs);
+        long elapsed = (System.nanoTime() - start) / 1000000;
+        Assert.assertTrue(elapsed >= sleepMs && elapsed < waitIntervalMs);
+    }
+","[{'comment': 'This unit test has nothing to do with this pr, you can mention a pr again', 'commenter': 'panzhi33'}, {'comment': 'In fact, you are right.\r\nThe reason I add unit test for class `WaitNotifyObject` is because  **coverage check** is always failed, and the **coverage check** indicates the coverage  decreased due to this class `WaitNotifyObject`.', 'commenter': 'XiaoyiPeng'}]"
3746,tools/src/test/java/org/apache/rocketmq/tools/command/broker/GetMasterSlaveDiffCommandTest.java,"@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tools.command.broker;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Options;
+import org.apache.commons.cli.PosixParser;
+import org.apache.rocketmq.client.exception.MQBrokerException;
+import org.apache.rocketmq.client.exception.MQClientException;
+import org.apache.rocketmq.common.protocol.body.ClusterInfo;
+import org.apache.rocketmq.common.protocol.route.BrokerData;
+import org.apache.rocketmq.remoting.exception.RemotingException;
+import org.apache.rocketmq.srvutil.ServerUtil;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
+import org.apache.rocketmq.tools.command.SubCommandException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.internal.util.collections.Sets;
+
+import java.lang.reflect.Field;
+import java.util.HashMap;
+import java.util.Set;
+
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.spy;
+
+public class GetMasterSlaveDiffCommandTest {
+
+    private GetMasterSlaveDiffCommand cmd;
+
+    private static DefaultMQAdminExt defaultMQAdminExt;
+
+    private static final String CLUSTER_NAME = ""DefaultCluster"";
+
+    private static final String BROKER_NAME = ""broker-a"";
+
+    @Before
+    public void before() throws NoSuchFieldException, IllegalAccessException, RemotingException, MQBrokerException,
+            InterruptedException, MQClientException {
+
+        ClusterInfo clusterInfo = new ClusterInfo();
+        HashMap<String, Set<String>> clusterMap = new HashMap<>(4);
+        clusterMap.put(CLUSTER_NAME, Sets.newSet(BROKER_NAME));
+        clusterInfo.setClusterAddrTable(clusterMap);
+
+        HashMap<Long, String> brokerMap = new HashMap<>(4);
+        brokerMap.put(0L, ""127.0.0.1:10911"");
+        BrokerData brokerData = new BrokerData(CLUSTER_NAME, BROKER_NAME, brokerMap);
+        HashMap<String, BrokerData> brokerAddrTable = new HashMap<>();
+        brokerAddrTable.put(BROKER_NAME, brokerData);
+        clusterInfo.setBrokerAddrTable(brokerAddrTable);
+
+        defaultMQAdminExt = new DefaultMQAdminExt();
+        defaultMQAdminExt = spy(defaultMQAdminExt);
+
+        cmd = new GetMasterSlaveDiffCommand();
+        Field field = cmd.getClass().getDeclaredField(""defaultMQAdminExt"");
+        field.setAccessible(true);
+        field.set(cmd, defaultMQAdminExt);
+
+        doReturn(clusterInfo).when(defaultMQAdminExt).examineBrokerClusterInfo();
+        doReturn(1024L).when(defaultMQAdminExt).getMasterSlaveDiff(anyString());
+    }
+
+    @After
+    public void after() {}
+
+    @Test
+    public void testExecute() throws SubCommandException, RemotingException, MQBrokerException, InterruptedException, MQClientException {
+        Options options = ServerUtil.buildCommandlineOptions(new Options());
+        String[] subargs = new String[] {""-b "" + BROKER_NAME , ""-c "" + CLUSTER_NAME};
+        final CommandLine commandLine =
+            ServerUtil.parseCmdLine(""mqadmin "" + cmd.commandName(), subargs, cmd.buildCommandlineOptions(options), new PosixParser());
+        cmd.execute(commandLine, options, null);","[{'comment': 'Any assert for cmd execute?', 'commenter': 'vongosling'}, {'comment': ""Hi, @vongosling \r\nThanks for your review, in package `org.apache.rocketmq.tools.command.broker`, none of the classes has assert for cmd execute.\r\nFor consistency of code style, I didn't add assert before\r\n\r\nBut just now, I've added the assert for cmd execute, please review again. Thank you very much.\r\n"", 'commenter': 'XiaoyiPeng'}]"
3761,acl/src/main/java/org/apache/rocketmq/acl/AccessValidator.java,"@@ -60,16 +63,18 @@
      *
      * @return
      */
-    String getAclConfigVersion();
+    Map<String, DataVersion> getAclConfigVersion();","[{'comment': ""It makes the interface incompatible to older versions, you'd better add a new method and deprecate the original ones. "", 'commenter': 'caigy'}, {'comment': 'done', 'commenter': 'sunxi92'}]"
3761,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -30,51 +41,74 @@
 import org.apache.rocketmq.common.constant.LoggerName;
 import org.apache.rocketmq.logging.InternalLogger;
 import org.apache.rocketmq.logging.InternalLoggerFactory;
-import org.apache.rocketmq.srvutil.FileWatchService;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
+import org.apache.rocketmq.srvutil.AclFileWatchService;
 
 public class PlainPermissionManager {
 
     private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);
 
-    private static final String DEFAULT_PLAIN_ACL_FILE = ""/conf/plain_acl.yml"";
-
     private String fileHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY,
         System.getenv(MixAll.ROCKETMQ_HOME_ENV));
 
-    private String fileName = System.getProperty(""rocketmq.acl.plain.file"", DEFAULT_PLAIN_ACL_FILE);","[{'comment': ""Users using `DEFAULT_PLAIN_ACL_FILE` can't load ACL config file after this change, it requires more compatible considerations."", 'commenter': 'caigy'}, {'comment': '+1.\r\nThis pr need to supply a detailed design.', 'commenter': 'dongeforever'}, {'comment': 'done', 'commenter': 'sunxi92'}]"
3761,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -30,51 +41,74 @@
 import org.apache.rocketmq.common.constant.LoggerName;
 import org.apache.rocketmq.logging.InternalLogger;
 import org.apache.rocketmq.logging.InternalLoggerFactory;
-import org.apache.rocketmq.srvutil.FileWatchService;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
+import org.apache.rocketmq.srvutil.AclFileWatchService;
 
 public class PlainPermissionManager {
 
     private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);
 
-    private static final String DEFAULT_PLAIN_ACL_FILE = ""/conf/plain_acl.yml"";
-
     private String fileHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY,
         System.getenv(MixAll.ROCKETMQ_HOME_ENV));
 
-    private String fileName = System.getProperty(""rocketmq.acl.plain.file"", DEFAULT_PLAIN_ACL_FILE);
+    private String defaultAclDir = fileHome + File.separator
+        + System.getProperty(""rocketmq.acl.dir"", ""/conf/acl"");
+
+    private String defaultAclFile = fileHome + File.separator
+        + System.getProperty(""rocketmq.acl.dir"", ""/conf/acl"") + File.separator + ""plain_acl.yml"";
 
-    private Map<String/** AccessKey **/, PlainAccessResource> plainAccessResourceMap = new HashMap<>();
+    private Map<String/** aclFileName **/, Map<String/** AccessKey **/, PlainAccessResource>> aclPlainAccessResourceMap = new HashMap<>();
+
+    private Map<String/** AccessKey **/, String/** aclFileName **/> accessKeyTable = new HashMap<>();
 
     private List<RemoteAddressStrategy> globalWhiteRemoteAddressStrategy = new ArrayList<>();
 
     private RemoteAddressStrategyFactory remoteAddressStrategyFactory = new RemoteAddressStrategyFactory();
 
     private boolean isWatchStart;
 
-    private final DataVersion dataVersion = new DataVersion();
+    private Map<String/** aclFileName **/, DataVersion> dataVersionMap = new HashMap<>();
 
     public PlainPermissionManager() {
         load();
         watch();
     }
 
     public void load() {
+        if (fileHome == null || fileHome.isEmpty()) {
+            throw new AclException(String.format(""%s file is empty"", fileHome));
+        }","[{'comment': 'Is it more appropriate to just returning than throwing exception?', 'commenter': 'caigy'}, {'comment': 'done', 'commenter': 'sunxi92'}]"
3761,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -30,51 +41,74 @@
 import org.apache.rocketmq.common.constant.LoggerName;
 import org.apache.rocketmq.logging.InternalLogger;
 import org.apache.rocketmq.logging.InternalLoggerFactory;
-import org.apache.rocketmq.srvutil.FileWatchService;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
+import org.apache.rocketmq.srvutil.AclFileWatchService;
 
 public class PlainPermissionManager {
 
     private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);
 
-    private static final String DEFAULT_PLAIN_ACL_FILE = ""/conf/plain_acl.yml"";
-
     private String fileHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY,
         System.getenv(MixAll.ROCKETMQ_HOME_ENV));
 
-    private String fileName = System.getProperty(""rocketmq.acl.plain.file"", DEFAULT_PLAIN_ACL_FILE);
+    private String defaultAclDir = fileHome + File.separator
+        + System.getProperty(""rocketmq.acl.dir"", ""/conf/acl"");
+
+    private String defaultAclFile = fileHome + File.separator
+        + System.getProperty(""rocketmq.acl.dir"", ""/conf/acl"") + File.separator + ""plain_acl.yml"";
 
-    private Map<String/** AccessKey **/, PlainAccessResource> plainAccessResourceMap = new HashMap<>();
+    private Map<String/** aclFileName **/, Map<String/** AccessKey **/, PlainAccessResource>> aclPlainAccessResourceMap = new HashMap<>();
+
+    private Map<String/** AccessKey **/, String/** aclFileName **/> accessKeyTable = new HashMap<>();
 
     private List<RemoteAddressStrategy> globalWhiteRemoteAddressStrategy = new ArrayList<>();
 
     private RemoteAddressStrategyFactory remoteAddressStrategyFactory = new RemoteAddressStrategyFactory();
 
     private boolean isWatchStart;
 
-    private final DataVersion dataVersion = new DataVersion();
+    private Map<String/** aclFileName **/, DataVersion> dataVersionMap = new HashMap<>();
 
     public PlainPermissionManager() {
         load();
         watch();
     }
 
     public void load() {
+        if (fileHome == null || fileHome.isEmpty()) {
+            throw new AclException(String.format(""%s file is empty"", fileHome));
+        }
+        File aclDir = new File(defaultAclDir);
+        File[] aclFiles = aclDir.listFiles();","[{'comment': 'Array of `File` objects is created here but only path string is used(`org.apache.rocketmq.acl.common.AclUtils#getYamlDataObject` uses file name to read this file again), it will use less resource if using `java.nio.file.Files#list`, or add overloaded method for `org.apache.rocketmq.acl.common.AclUtils#getYamlDataObject` accepting file object. ', 'commenter': 'caigy'}]"
3761,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -30,51 +41,74 @@
 import org.apache.rocketmq.common.constant.LoggerName;
 import org.apache.rocketmq.logging.InternalLogger;
 import org.apache.rocketmq.logging.InternalLoggerFactory;
-import org.apache.rocketmq.srvutil.FileWatchService;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
+import org.apache.rocketmq.srvutil.AclFileWatchService;
 
 public class PlainPermissionManager {
 
     private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);
 
-    private static final String DEFAULT_PLAIN_ACL_FILE = ""/conf/plain_acl.yml"";
-
     private String fileHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY,
         System.getenv(MixAll.ROCKETMQ_HOME_ENV));
 
-    private String fileName = System.getProperty(""rocketmq.acl.plain.file"", DEFAULT_PLAIN_ACL_FILE);
+    private String defaultAclDir = fileHome + File.separator
+        + System.getProperty(""rocketmq.acl.dir"", ""/conf/acl"");
+
+    private String defaultAclFile = fileHome + File.separator
+        + System.getProperty(""rocketmq.acl.dir"", ""/conf/acl"") + File.separator + ""plain_acl.yml"";
 
-    private Map<String/** AccessKey **/, PlainAccessResource> plainAccessResourceMap = new HashMap<>();
+    private Map<String/** aclFileName **/, Map<String/** AccessKey **/, PlainAccessResource>> aclPlainAccessResourceMap = new HashMap<>();
+
+    private Map<String/** AccessKey **/, String/** aclFileName **/> accessKeyTable = new HashMap<>();
 
     private List<RemoteAddressStrategy> globalWhiteRemoteAddressStrategy = new ArrayList<>();
 
     private RemoteAddressStrategyFactory remoteAddressStrategyFactory = new RemoteAddressStrategyFactory();
 
     private boolean isWatchStart;
 
-    private final DataVersion dataVersion = new DataVersion();
+    private Map<String/** aclFileName **/, DataVersion> dataVersionMap = new HashMap<>();
 
     public PlainPermissionManager() {
         load();
         watch();
     }
 
     public void load() {
+        if (fileHome == null || fileHome.isEmpty()) {
+            throw new AclException(String.format(""%s file is empty"", fileHome));
+        }
+        File aclDir = new File(defaultAclDir);
+        File[] aclFiles = aclDir.listFiles();
+        if (aclFiles == null || aclFiles.length == 0)
+            return;
+        if (aclPlainAccessResourceMap.size() != 0 && accessKeyTable.size() != 0) {
+            aclPlainAccessResourceMap.clear();
+            accessKeyTable.clear();
+        }
+        List<String> fileList = new ArrayList<>();
+        for (File aclFile : aclFiles) {
+            String aclFileAbsolutePath = aclFile.getAbsolutePath();
+            load(aclFileAbsolutePath);","[{'comment': 'Should we surround `load` by try-catch?', 'commenter': 'caigy'}]"
3761,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -30,51 +41,74 @@
 import org.apache.rocketmq.common.constant.LoggerName;
 import org.apache.rocketmq.logging.InternalLogger;
 import org.apache.rocketmq.logging.InternalLoggerFactory;
-import org.apache.rocketmq.srvutil.FileWatchService;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
+import org.apache.rocketmq.srvutil.AclFileWatchService;
 
 public class PlainPermissionManager {
 
     private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);
 
-    private static final String DEFAULT_PLAIN_ACL_FILE = ""/conf/plain_acl.yml"";
-
     private String fileHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY,
         System.getenv(MixAll.ROCKETMQ_HOME_ENV));
 
-    private String fileName = System.getProperty(""rocketmq.acl.plain.file"", DEFAULT_PLAIN_ACL_FILE);
+    private String defaultAclDir = fileHome + File.separator
+        + System.getProperty(""rocketmq.acl.dir"", ""/conf/acl"");
+
+    private String defaultAclFile = fileHome + File.separator
+        + System.getProperty(""rocketmq.acl.dir"", ""/conf/acl"") + File.separator + ""plain_acl.yml"";
 
-    private Map<String/** AccessKey **/, PlainAccessResource> plainAccessResourceMap = new HashMap<>();
+    private Map<String/** aclFileName **/, Map<String/** AccessKey **/, PlainAccessResource>> aclPlainAccessResourceMap = new HashMap<>();
+
+    private Map<String/** AccessKey **/, String/** aclFileName **/> accessKeyTable = new HashMap<>();
 
     private List<RemoteAddressStrategy> globalWhiteRemoteAddressStrategy = new ArrayList<>();
 
     private RemoteAddressStrategyFactory remoteAddressStrategyFactory = new RemoteAddressStrategyFactory();
 
     private boolean isWatchStart;
 
-    private final DataVersion dataVersion = new DataVersion();
+    private Map<String/** aclFileName **/, DataVersion> dataVersionMap = new HashMap<>();
 
     public PlainPermissionManager() {
         load();
         watch();
     }
 
     public void load() {
+        if (fileHome == null || fileHome.isEmpty()) {
+            throw new AclException(String.format(""%s file is empty"", fileHome));
+        }
+        File aclDir = new File(defaultAclDir);
+        File[] aclFiles = aclDir.listFiles();
+        if (aclFiles == null || aclFiles.length == 0)
+            return;
+        if (aclPlainAccessResourceMap.size() != 0 && accessKeyTable.size() != 0) {
+            aclPlainAccessResourceMap.clear();
+            accessKeyTable.clear();
+        }
+        List<String> fileList = new ArrayList<>();","[{'comment': 'Specifying expected size for ArrayList avoiding expansion.', 'commenter': 'caigy'}, {'comment': 'done', 'commenter': 'sunxi92'}]"
3761,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -91,37 +125,51 @@ public void load() {
             for (PlainAccessConfig plainAccessConfig : plainAccessConfigList) {
                 PlainAccessResource plainAccessResource = buildPlainAccessResource(plainAccessConfig);
                 plainAccessResourceMap.put(plainAccessResource.getAccessKey(), plainAccessResource);
+                this.accessKeyTable.put(plainAccessResource.getAccessKey(), aclFilePath);","[{'comment': 'Can one access key be defined in multiple files? If not so, instructions should be added in documents and checks should be added.', 'commenter': 'caigy'}]"
3761,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -91,37 +125,51 @@ public void load() {
             for (PlainAccessConfig plainAccessConfig : plainAccessConfigList) {
                 PlainAccessResource plainAccessResource = buildPlainAccessResource(plainAccessConfig);
                 plainAccessResourceMap.put(plainAccessResource.getAccessKey(), plainAccessResource);
+                this.accessKeyTable.put(plainAccessResource.getAccessKey(), aclFilePath);
             }
         }
 
         // For loading dataversion part just
         JSONArray tempDataVersion = plainAclConfData.getJSONArray(AclConstants.CONFIG_DATA_VERSION);
+        DataVersion dataVersion = new DataVersion();
         if (tempDataVersion != null && !tempDataVersion.isEmpty()) {
-            List<DataVersion> dataVersion = tempDataVersion.toJavaList(DataVersion.class);
-            DataVersion firstElement = dataVersion.get(0);
-            this.dataVersion.assignNewOne(firstElement);
+            List<DataVersion> dataVersions = tempDataVersion.toJavaList(DataVersion.class);
+            DataVersion firstElement = dataVersions.get(0);
+            dataVersion.assignNewOne(firstElement);
         }
 
         this.globalWhiteRemoteAddressStrategy = globalWhiteRemoteAddressStrategy;
-        this.plainAccessResourceMap = plainAccessResourceMap;
+        this.aclPlainAccessResourceMap.put(aclFilePath, plainAccessResourceMap);
+        this.dataVersionMap.put(aclFilePath, dataVersion);
     }
 
-    public String getAclConfigDataVersion() {","[{'comment': 'Keep `public String getAclConfigDataVersion()` and mark it deprecated for compatibility where only one config file is used.', 'commenter': 'caigy'}, {'comment': 'done', 'commenter': 'sunxi92'}]"
3761,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -91,37 +125,51 @@ public void load() {
             for (PlainAccessConfig plainAccessConfig : plainAccessConfigList) {
                 PlainAccessResource plainAccessResource = buildPlainAccessResource(plainAccessConfig);
                 plainAccessResourceMap.put(plainAccessResource.getAccessKey(), plainAccessResource);
+                this.accessKeyTable.put(plainAccessResource.getAccessKey(), aclFilePath);
             }
         }
 
         // For loading dataversion part just
         JSONArray tempDataVersion = plainAclConfData.getJSONArray(AclConstants.CONFIG_DATA_VERSION);
+        DataVersion dataVersion = new DataVersion();
         if (tempDataVersion != null && !tempDataVersion.isEmpty()) {
-            List<DataVersion> dataVersion = tempDataVersion.toJavaList(DataVersion.class);
-            DataVersion firstElement = dataVersion.get(0);
-            this.dataVersion.assignNewOne(firstElement);
+            List<DataVersion> dataVersions = tempDataVersion.toJavaList(DataVersion.class);
+            DataVersion firstElement = dataVersions.get(0);
+            dataVersion.assignNewOne(firstElement);
         }
 
         this.globalWhiteRemoteAddressStrategy = globalWhiteRemoteAddressStrategy;
-        this.plainAccessResourceMap = plainAccessResourceMap;
+        this.aclPlainAccessResourceMap.put(aclFilePath, plainAccessResourceMap);
+        this.dataVersionMap.put(aclFilePath, dataVersion);
     }
 
-    public String getAclConfigDataVersion() {
-        return this.dataVersion.toJson();
+    public Map<String, DataVersion> getAclConfigDataVersion() {
+        return this.dataVersionMap;
     }
 
-    private Map<String, Object> updateAclConfigFileVersion(Map<String, Object> updateAclConfigMap) {
+    public Map<String, Object> updateAclConfigFileVersion(Map<String, Object> updateAclConfigMap) {
 
+        Object dataVersions = updateAclConfigMap.get(AclConstants.CONFIG_DATA_VERSION);
+        DataVersion dataVersion = new DataVersion();
+        List<Map<String, Object>> dataVersionList = new ArrayList<Map<String, Object>>();","[{'comment': 'It seems unnecessary to create a new ArrayList.', 'commenter': 'caigy'}, {'comment': 'done', 'commenter': 'sunxi92'}]"
3761,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -91,37 +125,51 @@ public void load() {
             for (PlainAccessConfig plainAccessConfig : plainAccessConfigList) {
                 PlainAccessResource plainAccessResource = buildPlainAccessResource(plainAccessConfig);
                 plainAccessResourceMap.put(plainAccessResource.getAccessKey(), plainAccessResource);
+                this.accessKeyTable.put(plainAccessResource.getAccessKey(), aclFilePath);
             }
         }
 
         // For loading dataversion part just
         JSONArray tempDataVersion = plainAclConfData.getJSONArray(AclConstants.CONFIG_DATA_VERSION);
+        DataVersion dataVersion = new DataVersion();
         if (tempDataVersion != null && !tempDataVersion.isEmpty()) {
-            List<DataVersion> dataVersion = tempDataVersion.toJavaList(DataVersion.class);
-            DataVersion firstElement = dataVersion.get(0);
-            this.dataVersion.assignNewOne(firstElement);
+            List<DataVersion> dataVersions = tempDataVersion.toJavaList(DataVersion.class);
+            DataVersion firstElement = dataVersions.get(0);
+            dataVersion.assignNewOne(firstElement);
         }
 
         this.globalWhiteRemoteAddressStrategy = globalWhiteRemoteAddressStrategy;
-        this.plainAccessResourceMap = plainAccessResourceMap;
+        this.aclPlainAccessResourceMap.put(aclFilePath, plainAccessResourceMap);
+        this.dataVersionMap.put(aclFilePath, dataVersion);
     }
 
-    public String getAclConfigDataVersion() {
-        return this.dataVersion.toJson();
+    public Map<String, DataVersion> getAclConfigDataVersion() {
+        return this.dataVersionMap;
     }
 
-    private Map<String, Object> updateAclConfigFileVersion(Map<String, Object> updateAclConfigMap) {
+    public Map<String, Object> updateAclConfigFileVersion(Map<String, Object> updateAclConfigMap) {
 
+        Object dataVersions = updateAclConfigMap.get(AclConstants.CONFIG_DATA_VERSION);
+        DataVersion dataVersion = new DataVersion();
+        List<Map<String, Object>> dataVersionList = new ArrayList<Map<String, Object>>();
+        if (dataVersions != null) {
+            dataVersionList = (List<Map<String, Object>>) dataVersions;
+            dataVersion.setTimestamp((long) dataVersionList.get(0).get(""timestamp""));","[{'comment': 'It would be more robust to check if dataVersionList is empty', 'commenter': 'caigy'}, {'comment': 'done', 'commenter': 'sunxi92'}]"
3761,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -136,42 +184,46 @@ public boolean updateAccessConfig(PlainAccessConfig plainAccessConfig) {
         Permission.checkResourcePerms(plainAccessConfig.getTopicPerms());
         Permission.checkResourcePerms(plainAccessConfig.getGroupPerms());
 
-        Map<String, Object> aclAccessConfigMap = AclUtils.getYamlDataObject(fileHome + File.separator + fileName,
-            Map.class);
-        if (aclAccessConfigMap == null || aclAccessConfigMap.isEmpty()) {
-            throw new AclException(String.format(""the %s file is not found or empty"", fileHome + File.separator + fileName));
-        }
-        List<Map<String, Object>> accounts = (List<Map<String, Object>>) aclAccessConfigMap.get(AclConstants.CONFIG_ACCOUNTS);
-        Map<String, Object> updateAccountMap = null;
-        if (accounts != null) {","[{'comment': 'Just keep the null check', 'commenter': 'caigy'}, {'comment': 'done', 'commenter': 'sunxi92'}]"
3761,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -267,54 +318,61 @@ public boolean updateGlobalWhiteAddrsConfig(List<String> globalWhiteAddrsList) {
             }
             // Update globalWhiteRemoteAddr element in memory map firstly
             aclAccessConfigMap.put(AclConstants.CONFIG_GLOBAL_WHITE_ADDRS, globalWhiteRemoteAddrList);
-            if (AclUtils.writeDataObject(fileHome + File.separator + fileName, updateAclConfigFileVersion(aclAccessConfigMap))) {
-                return true;
-            }
-            return false;
+            return AclUtils.writeDataObject(defaultAclFile, updateAclConfigFileVersion(aclAccessConfigMap));
         }
 
-        log.error(""Users must ensure that the acl yaml config file has globalWhiteRemoteAddresses flag firstly"");
+        log.error(""Users must ensure that the acl yaml config file has globalWhiteRemoteAddresses flag in the %s firstly"", defaultAclFile);","[{'comment': 'It seem that the placeholder is `{}`.', 'commenter': 'caigy'}, {'comment': 'done', 'commenter': 'sunxi92'}]"
3761,common/src/main/java/org/apache/rocketmq/common/protocol/header/GetBrokerAclConfigResponseHeader.java,"@@ -16,14 +16,17 @@
  */
 package org.apache.rocketmq.common.protocol.header;
 
+import org.apache.rocketmq.common.DataVersion;
 import org.apache.rocketmq.remoting.CommandCustomHeader;
 import org.apache.rocketmq.remoting.annotation.CFNotNull;
 import org.apache.rocketmq.remoting.exception.RemotingCommandException;
 
+import java.util.Map;
+
 public class GetBrokerAclConfigResponseHeader implements CommandCustomHeader {
 
     @CFNotNull
-    private String version;
+    private Map<String, DataVersion> version;","[{'comment': 'It changes the protocol, some users may already use it as String.', 'commenter': 'caigy'}, {'comment': 'done', 'commenter': 'sunxi92'}]"
3761,common/src/main/java/org/apache/rocketmq/common/protocol/body/ClusterAclVersionInfo.java,"@@ -19,13 +19,15 @@
 import org.apache.rocketmq.common.DataVersion;
 import org.apache.rocketmq.remoting.protocol.RemotingSerializable;
 
+import java.util.Map;
+
 public class ClusterAclVersionInfo extends RemotingSerializable {
 
     private String brokerName;
 
     private String brokerAddr;
 
-    private DataVersion aclConfigDataVersion;","[{'comment': 'Add a new field other than changing it for compatibility.', 'commenter': 'caigy'}, {'comment': 'done', 'commenter': 'sunxi92'}]"
3761,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -30,51 +41,74 @@
 import org.apache.rocketmq.common.constant.LoggerName;
 import org.apache.rocketmq.logging.InternalLogger;
 import org.apache.rocketmq.logging.InternalLoggerFactory;
-import org.apache.rocketmq.srvutil.FileWatchService;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
+import org.apache.rocketmq.srvutil.AclFileWatchService;
 
 public class PlainPermissionManager {
 
     private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);
 
-    private static final String DEFAULT_PLAIN_ACL_FILE = ""/conf/plain_acl.yml"";
-","[{'comment': 'remove old acl file directory incompatible with old version. Can old acl file and new acl dir coexist?', 'commenter': 'lizhiboo'}]"
3761,srvutil/src/main/java/org/apache/rocketmq/srvutil/AclFileWatchService.java,"@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.srvutil;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.common.ServiceThread;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.constant.LoggerName;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.logging.InternalLoggerFactory;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.security.MessageDigest;
+import java.util.HashMap;
+import java.util.Map;
+
+public class AclFileWatchService extends ServiceThread {
+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);
+
+    private final String aclPath;
+    private int aclFilesNum;
+    private final Map<String, String> fileCurrentHash;
+    private final AclFileWatchService.Listener listener;
+    private static final int WATCH_INTERVAL = 500;
+    private MessageDigest md = MessageDigest.getInstance(""MD5"");
+
+    public AclFileWatchService(String path, final AclFileWatchService.Listener listener) throws Exception {
+        this.aclPath = path;
+        this.fileCurrentHash = new HashMap<>();
+        this.listener = listener;
+
+        File aclDir = new File(path);
+        String[] aclFileNames = aclDir.list();
+        this.aclFilesNum = aclFileNames.length;
+        for (int i = 0; i < aclFilesNum; i++) {
+            String aclFilePath = this.aclPath + aclFileNames[i];
+            if (StringUtils.isNotEmpty(aclFileNames[i]) && new File(aclFilePath).exists()) {
+                this.fileCurrentHash.put(aclFilePath, hash(aclFilePath));
+            }
+        }
+
+    }
+
+    @Override
+    public String getServiceName() {
+        return ""AclFileWatchService"";
+    }
+
+    @Override
+    public void run() {
+        log.info(this.getServiceName() + "" service started"");
+
+        while (!this.isStopped()) {
+            try {
+                this.waitForRunning(WATCH_INTERVAL);
+
+                File aclDir = new File(aclPath);
+                File[] aclFiles = aclDir.listFiles();
+                int realAclFilesNum = aclFiles.length;
+
+                if (aclFilesNum != realAclFilesNum) {
+                    log.info(""aclFilesNum: "" + aclFilesNum + ""  realAclFilesNum: "" + realAclFilesNum);
+                    aclFilesNum = realAclFilesNum;
+                    log.info(""aclFilesNum: "" + aclFilesNum + ""  realAclFilesNum: "" + realAclFilesNum);
+                    listener.onFileNumChanged(aclPath);
+                } else {
+                    for (int i = 0; i < aclFilesNum; i++) {
+                        String fileName = aclFiles[i].getAbsolutePath();
+                        String newHash = hash(fileName);","[{'comment': 'Calculating hash of a file consumes a lot of system resources, can file modified time and file size be used  instead?', 'commenter': 'caigy'}]"
3761,srvutil/src/main/java/org/apache/rocketmq/srvutil/AclFileWatchService.java,"@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.srvutil;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.common.ServiceThread;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.constant.LoggerName;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.logging.InternalLoggerFactory;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.security.MessageDigest;
+import java.util.HashMap;
+import java.util.Map;
+
+public class AclFileWatchService extends ServiceThread {
+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);
+
+    private final String aclPath;
+    private int aclFilesNum;
+    private final Map<String, String> fileCurrentHash;
+    private final AclFileWatchService.Listener listener;
+    private static final int WATCH_INTERVAL = 500;
+    private MessageDigest md = MessageDigest.getInstance(""MD5"");
+
+    public AclFileWatchService(String path, final AclFileWatchService.Listener listener) throws Exception {
+        this.aclPath = path;
+        this.fileCurrentHash = new HashMap<>();
+        this.listener = listener;
+
+        File aclDir = new File(path);
+        String[] aclFileNames = aclDir.list();
+        this.aclFilesNum = aclFileNames.length;
+        for (int i = 0; i < aclFilesNum; i++) {
+            String aclFilePath = this.aclPath + aclFileNames[i];
+            if (StringUtils.isNotEmpty(aclFileNames[i]) && new File(aclFilePath).exists()) {
+                this.fileCurrentHash.put(aclFilePath, hash(aclFilePath));
+            }
+        }
+
+    }
+
+    @Override
+    public String getServiceName() {
+        return ""AclFileWatchService"";
+    }
+
+    @Override
+    public void run() {
+        log.info(this.getServiceName() + "" service started"");
+
+        while (!this.isStopped()) {
+            try {
+                this.waitForRunning(WATCH_INTERVAL);
+
+                File aclDir = new File(aclPath);
+                File[] aclFiles = aclDir.listFiles();
+                int realAclFilesNum = aclFiles.length;
+
+                if (aclFilesNum != realAclFilesNum) {
+                    log.info(""aclFilesNum: "" + aclFilesNum + ""  realAclFilesNum: "" + realAclFilesNum);
+                    aclFilesNum = realAclFilesNum;
+                    log.info(""aclFilesNum: "" + aclFilesNum + ""  realAclFilesNum: "" + realAclFilesNum);
+                    listener.onFileNumChanged(aclPath);
+                } else {
+                    for (int i = 0; i < aclFilesNum; i++) {
+                        String fileName = aclFiles[i].getAbsolutePath();
+                        String newHash = hash(fileName);
+                        if (!newHash.equals(fileCurrentHash.get(i))) {","[{'comment': 'Should it be `fileCurrentHash.get(fileName)`?', 'commenter': 'caigy'}]"
3761,srvutil/src/main/java/org/apache/rocketmq/srvutil/AclFileWatchService.java,"@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.srvutil;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.common.ServiceThread;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.common.constant.LoggerName;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.logging.InternalLoggerFactory;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.security.MessageDigest;
+import java.util.HashMap;
+import java.util.Map;
+
+public class AclFileWatchService extends ServiceThread {
+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);
+
+    private final String aclPath;
+    private int aclFilesNum;
+    private final Map<String, String> fileCurrentHash;
+    private final AclFileWatchService.Listener listener;
+    private static final int WATCH_INTERVAL = 500;","[{'comment': 'Is it too often?', 'commenter': 'caigy'}]"
3780,client/src/main/java/org/apache/rocketmq/client/impl/consumer/ConsumeMessagePopConcurrentlyService.java,"@@ -457,6 +457,12 @@ public void run() {
                 consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());
             }
 
+            if (ConsumeMessagePopConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {","[{'comment': 'The condition is the same to previous branch, it would be better to combine them.', 'commenter': 'caigy'}, {'comment': '@caigy  OK, I will combine them.', 'commenter': 'cserwen'}]"
3833,store/src/main/java/org/apache/rocketmq/store/CommitLog.java,"@@ -16,30 +16,10 @@
  */
 package org.apache.rocketmq.store;
 
-import java.net.Inet4Address;
-import java.net.Inet6Address;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-import java.nio.ByteBuffer;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.function.Supplier;
-
 import org.apache.rocketmq.common.ServiceThread;
 import org.apache.rocketmq.common.UtilAll;
 import org.apache.rocketmq.common.constant.LoggerName;
-import org.apache.rocketmq.common.message.MessageAccessor;
-import org.apache.rocketmq.common.message.MessageConst;
-import org.apache.rocketmq.common.message.MessageDecoder;
-import org.apache.rocketmq.common.message.MessageExt;
-import org.apache.rocketmq.common.message.MessageExtBatch;
+import org.apache.rocketmq.common.message.*;","[{'comment': 'It is not recommended to import all classes with wildcard.', 'commenter': 'XiaoyiPeng'}, {'comment': '+1', 'commenter': 'caigy'}]"
3833,store/src/main/java/org/apache/rocketmq/store/CommitLog.java,"@@ -50,6 +30,13 @@
 import org.apache.rocketmq.store.ha.HAService;
 import org.apache.rocketmq.store.schedule.ScheduleMessageService;
 
+import java.net.*;","[{'comment': 'It is not recommended to import all classes with wildcard.', 'commenter': 'XiaoyiPeng'}, {'comment': '+1', 'commenter': 'caigy'}]"
3838,client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultLitePullConsumerImpl.java,"@@ -645,21 +645,39 @@ private void removePullTask(final String topic) {
     }
 
     public synchronized void commitAll() {
-        try {
-            for (MessageQueue messageQueue : assignedMessageQueue.messageQueues()) {
-                long consumerOffset = assignedMessageQueue.getConsumerOffset(messageQueue);
-                if (consumerOffset != -1) {
-                    ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);
-                    if (processQueue != null && !processQueue.isDropped()) {
-                        updateConsumeOffset(messageQueue, consumerOffset);
-                    }
-                }
+        for (MessageQueue messageQueue : assignedMessageQueue.messageQueues()) {
+            try {
+                commit(messageQueue);
+            } catch (MQClientException e) {
+                log.error(""commit messageQueue ["" + messageQueue+ ""] consume offset error."", e);
             }
-            if (defaultLitePullConsumer.getMessageModel() == MessageModel.BROADCASTING) {
-                offsetStore.persistAll(assignedMessageQueue.messageQueues());
+        }
+    }
+
+    public synchronized void commit(final HashSet<MessageQueue> messageQueues, boolean persist) throws MQClientException {
+        if (messageQueues == null || messageQueues.size() == 0) {
+            return;
+        }
+
+        for (MessageQueue messageQueue : messageQueues) {
+            commit(messageQueue);
+        }
+
+        if (persist) {
+            this.offsetStore.persistAll(messageQueues);
+        }
+    }
+
+    private synchronized void commit(MessageQueue messageQueue) throws MQClientException {
+        long consumerOffset = assignedMessageQueue.getConsumerOffset(messageQueue);
+
+        if (consumerOffset != -1) {
+            ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);
+            if (processQueue != null && !processQueue.isDropped()) {
+                updateConsumeOffset(messageQueue, consumerOffset);
             }
-        } catch (Exception e) {
-            log.error(""An error occurred when update consume offset Automatically."");
+        } else {
+            throw new MQClientException(""messageQueue [""+ messageQueue +""] does not exist in assignedMessageQueue, please assign it first."", null);","[{'comment': 'if consumerOffset equals -1, commit will throw execption. IMO, consumerOffset equlas -1 means this consumequeue is empty, commit offset can be ignored.', 'commenter': 'lizhiboo'}]"
3838,client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultLitePullConsumerImpl.java,"@@ -645,21 +645,39 @@ private void removePullTask(final String topic) {
     }
 
     public synchronized void commitAll() {
-        try {
-            for (MessageQueue messageQueue : assignedMessageQueue.messageQueues()) {
-                long consumerOffset = assignedMessageQueue.getConsumerOffset(messageQueue);
-                if (consumerOffset != -1) {
-                    ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);
-                    if (processQueue != null && !processQueue.isDropped()) {
-                        updateConsumeOffset(messageQueue, consumerOffset);
-                    }
-                }
+        for (MessageQueue messageQueue : assignedMessageQueue.messageQueues()) {","[{'comment': 'the following code is missing in new commitAll:\r\n```\r\nif (defaultLitePullConsumer.getMessageModel() == MessageModel.BROADCASTING) {\r\n                offsetStore.persistAll(assignedMessageQueue.messageQueues());\r\n}\r\n```', 'commenter': 'yuz10'}, {'comment': 'I do not think this is necessary,  we do not need persist offset for BROADCASTING separately, timed task can do that.', 'commenter': 'ni-ze'}, {'comment': 'It is OK for me to remove, someone may find a reason to add this that BROADCASTING use local file, it takes less to persist and can make sure consume offset dont lose when consumer shut down unexpetedly.', 'commenter': 'yuz10'}]"
3838,client/src/test/java/org/apache/rocketmq/client/consumer/DefaultLitePullConsumerTest.java,"@@ -585,23 +615,23 @@ private void initDefaultLitePullConsumer(DefaultLitePullConsumer litePullConsume
         field.set(litePullConsumerImpl, offsetStore);
 
         when(mQClientFactory.getMQClientAPIImpl().pullMessage(anyString(), any(PullMessageRequestHeader.class),
-            anyLong(), any(CommunicationMode.class), nullable(PullCallback.class)))
-            .thenAnswer(new Answer<PullResult>() {
-                @Override
-                public PullResult answer(InvocationOnMock mock) throws Throwable {
-                    PullMessageRequestHeader requestHeader = mock.getArgument(1);
-                    MessageClientExt messageClientExt = new MessageClientExt();
-                    messageClientExt.setTopic(topic);
-                    messageClientExt.setQueueId(0);
-                    messageClientExt.setMsgId(""123"");
-                    messageClientExt.setBody(new byte[] {'a'});
-                    messageClientExt.setOffsetMsgId(""234"");
-                    messageClientExt.setBornHost(new InetSocketAddress(8080));
-                    messageClientExt.setStoreHost(new InetSocketAddress(8080));
-                    PullResult pullResult = createPullResult(requestHeader, PullStatus.FOUND, Collections.<MessageExt>singletonList(messageClientExt));
-                    return pullResult;
-                }
-            });
+                anyLong(), any(CommunicationMode.class), nullable(PullCallback.class)))","[{'comment': 'The indent might be wrong, see https://rocketmq.apache.org/docs/code-guidelines/', 'commenter': 'HScarb'}, {'comment': 'fixed, thx.', 'commenter': 'ni-ze'}]"
3928,tools/src/main/java/org/apache/rocketmq/tools/admin/DefaultMQAdminExtImpl.java,"@@ -913,7 +913,7 @@ public boolean consumed(final MessageExt msg,
         final String group) throws RemotingException, MQClientException, InterruptedException,
         MQBrokerException {
 
-        ConsumeStats cstats = this.examineConsumeStats(group);
+        ConsumeStats cstats = this.examineConsumeStats(group,msg.getTopic());
 
         ClusterInfo ci = this.examineBrokerClusterInfo();
 ","[{'comment': 'The following codes are used to check topic . Maybe you can simplify it.\r\n\r\nhttps://github.com/apache/rocketmq/blob/e7ee1186b5f1b9a46da67e3d71cc7e01c27600bd/tools/src/main/java/org/apache/rocketmq/tools/admin/DefaultMQAdminExtImpl.java#L921\r\n\r\n', 'commenter': 'cserwen'}, {'comment': ""got it, but i still confuse. because examineConsumeStats method send group&topic to broker, the broker can filter the topic's message.  why admin client retrieve all topic of the group and filter the topic's message?"", 'commenter': 'wo3002807'}]"
3997,acl/src/main/java/org/apache/rocketmq/acl/common/AclClientRPCHook.java,"@@ -69,7 +72,11 @@ public void doAfterResponse(String remoteAddr, RemotingCommand request, Remoting
             if (null != header) {
                 Field[] fields = fieldCache.get(header.getClass());
                 if (null == fields) {
-                    fields = header.getClass().getDeclaredFields();
+                    Set<Field> fieldList = new HashSet<Field>();","[{'comment': '`parseRequestContent` is used for signature checks, so the order of fields matters. I think a sorted set should be adopted here.', 'commenter': 'caigy'}, {'comment': ""at the end of the function, the value of the header will be put into a SortedMap. so it doesn't matter to use HashSet here."", 'commenter': 'chaiyx'}, {'comment': 'But the order of fields put into returning SortedMap still depends on the order of `fieldList`.', 'commenter': 'caigy'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/PullConsumer.java,"@@ -0,0 +1,172 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import java.io.Closeable;
+import java.time.Duration;
+import java.util.Collection;
+import java.util.Map;
+
+import org.apache.rocketmq.apis.MessageQueue;
+import org.apache.rocketmq.apis.exception.*;
+import org.apache.rocketmq.apis.message.MessageView;
+
+/**
+ * PullConsumer is a thread-safe rocketmq client which is used to consume message by queue.
+ * Unlike push consumer and simple consumer, pull consumer implement load balance based on queue granularity.
+ *
+ * <p>Pull consumer is lightweight consumer that better suited to streaming scenarios.
+ * If you want fully control the message consumption operation by yourself like scan by offset or reconsume repeatedly,
+ * pull consumer should be your first consideration.
+ *
+ * <p>Pull consumer support two load balance mode. First is subscription mode, which full manage the rebalance
+ * operation triggered when group membership or cluster and topic metadata change.Another mode is manual assignment mode,which manage the load balance by yourself.
+ *
+ * <p> Pull consumer divide message consumption to 3 parts.
+ * Firstly, determine whether to continue processing from the last consumption or reset the consumption starting point by call seek method;
+ * Then, pull message from servers.
+ * At last, pull consumer no need to commit message by offset meta.
+ * If there is a consumption error, consumer just call seek api to reset the offset for reconsume message again.
+ */
+public interface PullConsumer extends Closeable {
+    /**
+     * Listener that listens for changes of message queues when use manual assignment mode.
+     */
+    interface MessageQueuesChangeListener {
+        /**
+         * This method will be invoked in the condition of message queues changed, These scenarios occur when the
+         * topic is expanded or shrunk.
+         *
+         * @param messageQueues {@link MessageQueue} of topic.
+         */
+        void onChanged(Collection<MessageQueue> messageQueues);
+    }
+
+    /**
+     * Get metadata about the message queues for a given topic. This method will issue a remote call to the server if it
+     * does not already have any metadata about the given topic.
+     *
+     * @param topic message's topic
+     * @return message queues of topic.
+     */
+    Collection<MessageQueue> topicMessageQueues(String topic) throws ClientException;
+
+    /**
+     * Manually assign messageQueue collections to this consumer.
+     * This interface does not allow for incremental assignment and will replace the previous assignment.
+     * If the given collection is empty, it's treated same as unsubscribe().
+     * Manual assignment through this interface will disable the consumerGroup management functionality
+     * and there will be no rebalance operation triggered when group membership or cluster and topic metadata change.
+     * @param messageQueues are the collection for current consumer.
+     * @throws ClientException when assign
+     */
+    void assign(Collection<MessageQueue> messageQueues) throws ClientException;
+
+    /**
+     * Pull consumer query and update metadata about message queues periodically, listener is triggered once metadata
+     * is updated. The listener is required only in manual assignment mode.
+     * When use the subscription mode, no need to care the messageQueue change events.
+     *
+     * @param topic    topic to query and update metadata.
+     * @param listener listener to receive changes of metadata by topic.
+     */
+    void registerMessageQueuesChangeListener(String topic, MessageQueuesChangeListener listener);
+
+    /**
+     * Add subscription expression dynamically when use subscription mode.
+     *
+     * <p>If first {@link SubscriptionExpression} that contains topicA and tag1 is exists already in consumer, then
+     * second {@link SubscriptionExpression} which contains topicA and tag2, <strong>the result is that the second one
+     * replaces the first one instead of integrating them</strong>.
+     *
+     * @param subscriptionExpression new subscription expression to add.
+     * @return pull consumer instance.
+     */
+    PullConsumer subscribe(SubscriptionExpression subscriptionExpression) throws ClientException;
+
+    /**
+     * Remove subscription expression dynamically by topic.
+     *
+     * <p>Nothing occurs if the specified topic does not exist in subscription expressions of pull consumer.
+     *
+     * @param topic the topic to remove subscription.
+     * @return pull consumer instance.
+     */
+    PullConsumer unsubscribe(String topic) throws ClientException;
+
+    /**
+     * Get the collection of messageQueues currently assigned to current consumer.
+     * @return the collection of messageQueues currently assigned to current consumer
+     */
+    Collection<MessageQueue> assignment();
+
+    /**
+     * Fetch messages from server synchronously. This method returns immediately if there are messages available.
+     * Otherwise, it will await the passed timeout. If the timeout expires, an empty map will be returned.
+     * An error occurs if you do not subscribe or assign messageQueues before polling for data.
+     * @param messageQueue the target messageQueue to pull message.
+     * @param maxMessageNum max message num when server returns.
+     * @return collection of messageViews of this queue.
+     */
+    Collection<MessageView> pull(MessageQueue messageQueue, int maxMessageNum) throws ClientException;
+
+    /**
+     * Commit the offsets for the specified messageQueue.
+     * @param messageQueue the specified messageQueue to commit offset","[{'comment': 'The streaming scenario needs a simple poll(ms) instead of the pull(messagequeue). \r\n\r\nThe user does not need to know the messagequeue at each pull. \r\nAnd, the user may need to handle the queue changement, which is not necessary in most cases.\r\nMore importantly, the underlying pull request will be polished as a batch mode to improve performance, which means one request may contain several messagequeues.\r\n\r\nThis consumer is better to be named as PollConsumer.  Poll means to reduce one by one. ', 'commenter': 'dongeforever'}, {'comment': 'Maybe we need to rethink of the design of PullConsumer.', 'commenter': 'chenzlalvin'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/PushConsumer.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import com.google.common.util.concurrent.Service;
+import java.io.Closeable;
+import java.util.Collection;
+
+import org.apache.rocketmq.apis.exception.*;
+
+/**
+ * PushConsumer is a thread-safe rocketmq client which is used to consume message by group.
+ *
+ * <p>Push consumer is fully-managed consumer, if you are confused to choose your consumer, push consumer should be
+ * your first consideration.
+ *
+ * <p>Consumers belong to the same consumer group share messages from server,
+ * so consumer in the same group must have the same {@link SubscriptionExpression}s, otherwise the behavior is
+ * undefined. If a new consumer group's consumer is started first time, it consumes from the latest position. Once
+ * consumer is started, server records its consumption progress and derives it in subsequent startup.
+ *
+ * <p>You may intend to maintain different consumption progress for different consumer, different consumer group
+ * should be set in this case.
+ *
+ * <p>To accelerate the message consumption, push consumer applies
+ * <a href=""https://en.wikipedia.org/wiki/Reactive_Streams"">reactive streams</a>
+ * . Messages received from server is cached locally before consumption,
+ * {@link PushConsumerBuilder#setMaxCacheMessageCount(int)} and
+ * {@link PushConsumerBuilder#setMaxCacheMessageSizeInBytes(int)} could be used to set the cache threshold in
+ * different dimension.
+ */
+public interface PushConsumer extends Closeable {
+    /**
+     * Get the load balancing group for consumer.
+     *
+     * @return consumer load balancing group.
+     */
+    String getConsumerGroup();
+
+    /**
+     * Get the existed subscription expression in push consumer.
+     *
+     * @return collections of subscription expression.
+     */
+    Collection<SubscriptionExpression> listSubscriptionExpression();
+
+    /**
+     * Add subscription expression dynamically.
+     *
+     * <p>If first {@link SubscriptionExpression} that contains topicA and tag1 is exists already in consumer, then
+     * second {@link SubscriptionExpression} which contains topicA and tag2, <strong>the result is that the second one
+     * replaces the first one instead of integrating them</strong>.
+     *
+     * @param subscriptionExpression new subscription expression to add.
+     * @return push consumer instance.
+     */
+    PushConsumer subscribe(SubscriptionExpression subscriptionExpression) throws ClientException;
+
+    /**
+     * Remove subscription expression dynamically by topic.
+     *
+     * <p>It stops the backend task to fetch message from remote, and besides that, the local cached message whose topic
+     * was removed before would not be delivered to {@link MessageListener} anymore.
+     *
+     * <p>Nothing occurs if the specified topic does not exist in subscription expressions of push consumer.
+     *
+     * @param topic the topic to remove subscription.
+     * @return push consumer instance.
+     */
+    PushConsumer unsubscribe(String topic) throws ClientException;
+
+    /**
+     * Close the push consumer and release all related resources.
+     *
+     * <p>Once push consumer is closed, <strong>it could not be started once again.</strong> we maintained an FSM
+     * (finite-state machine) to record the different states for each producer, which is similar to
+     * {@link Service.State}.
+     */","[{'comment': 'Maybe we need to get the MessageListenner.', 'commenter': 'dongeforever'}, {'comment': 'Can you explain the exact scene that need get MessageListener.', 'commenter': 'chenzlalvin'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/SimpleConsumer.java,"@@ -0,0 +1,128 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import java.io.Closeable;
+import java.time.Duration;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+
+import org.apache.rocketmq.apis.exception.*;
+import org.apache.rocketmq.apis.message.MessageView;
+
+/**
+ * SimpleConsumer is a thread-safe rocketmq client which is used to consume message by group.
+ *
+ * <p>Simple consumer is lightweight consumer , if you want fully control the message consumption operation by yourself,
+ * simple consumer should be your first consideration.
+ *
+ * <p>Consumers belong to the same consumer group share messages from server,
+ * so consumer in the same group must have the same {@link SubscriptionExpression}s, otherwise the behavior is
+ * undefined. If a new consumer group's consumer is started first time, it consumes from the latest position. Once
+ * consumer is started, server records its consumption progress and derives it in subsequent startup.
+ *
+ * <p>You may intend to maintain different consumption progress for different consumer, different consumer group
+ * should be set in this case.
+ *
+ * <p> Simple consumer divide message consumption to 3 parts.
+ * Firstly, call receive api get messages from server; Then process message by yourself; At last, your must call Ack api to commit this message.
+ * If there is error when process message ,your can reconsume the message later which control by the invisibleDuration parameter.
+ * Also, you can change the invisibleDuration by call changeInvisibleDuration api.
+ */
+public interface SimpleConsumer extends Closeable {
+    /**
+     * Get the load balancing group for simple consumer.
+     *
+     * @return consumer load balancing group.
+     */
+    String getConsumerGroup();
+
+    /**
+     * Add subscription expression dynamically.
+     *
+     * <p>If first {@link SubscriptionExpression} that contains topicA and tag1 is exists already in consumer, then
+     * second {@link SubscriptionExpression} which contains topicA and tag2, <strong>the result is that the second one
+     * replaces the first one instead of integrating them</strong>.
+     *
+     * @param subscriptionExpression new subscription expression to add.
+     * @return simple consumer instance.
+     */
+    SimpleConsumer subscribe(SubscriptionExpression subscriptionExpression) throws ClientException;
+
+    /**
+     * Remove subscription expression dynamically by topic.
+     *
+     * <p>It stops the backend task to fetch message from remote, and besides that, the local cached message whose topic
+     * was removed before would not be delivered to {@link MessageListener} anymore.
+     *
+     * <p>Nothing occurs if the specified topic does not exist in subscription expressions of push consumer.
+     *
+     * @param topic the topic to remove subscription.
+     * @return simple consumer instance.
+     */
+    SimpleConsumer unsubscribe(String topic) throws ClientException;
+
+    /**
+     * Fetch messages from server synchronously. This method returns immediately if there are messages available.
+     * Otherwise, it will await the passed timeout. If the timeout expires, an empty map will be returned.
+     * @param topic special topic want to get messages.
+     * @param maxMessageNum max message num when server returns.
+     * @param invisibleDuration set the invisibleDuration of messages return from server. These messages will be invisible to other consumer unless timout.
+     * @return list of messageView
+     */
+    List<MessageView> receive(String topic, int maxMessageNum, Duration invisibleDuration) throws ClientException;
+
+    /**","[{'comment': ""What's the relationship between the topic in receive and topic in subcribe/unsubscribe."", 'commenter': 'dongeforever'}, {'comment': 'we remove the topic param, simpleConsumer must subscribe before receive.', 'commenter': 'chenzlalvin'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/MessageListener.java,"@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import java.util.Collection;
+import org.apache.rocketmq.apis.message.MessageView;
+
+/**
+ * MessageListener is used only for push consumer to process message consumption synchronously.
+ *
+ * <p> Refer to {@link PushConsumer}, push consumer will get message from server
+ * and dispatch the message to backend thread pool which control by parameter threadCount to consumer message concurrently.
+ */
+public interface MessageListener {
+    /**
+     * The callback interface for consume message. Your should process the collection of messageViews
+     * and put committed messageViews to committedList. Push consumer will commit the committedList to server.
+     * If consume message throw unexpected exception, Push consumer also commit the committedList.","[{'comment': 'Add `<p>` here.', 'commenter': 'aaron-ai'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/PullConsumer.java,"@@ -0,0 +1,172 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import java.io.Closeable;
+import java.time.Duration;
+import java.util.Collection;
+import java.util.Map;
+
+import org.apache.rocketmq.apis.MessageQueue;
+import org.apache.rocketmq.apis.exception.*;
+import org.apache.rocketmq.apis.message.MessageView;
+
+/**
+ * PullConsumer is a thread-safe rocketmq client which is used to consume message by queue.
+ * Unlike push consumer and simple consumer, pull consumer implement load balance based on queue granularity.
+ *
+ * <p>Pull consumer is lightweight consumer that better suited to streaming scenarios.
+ * If you want fully control the message consumption operation by yourself like scan by offset or reconsume repeatedly,
+ * pull consumer should be your first consideration.
+ *
+ * <p>Pull consumer support two load balance mode. First is subscription mode, which full manage the rebalance
+ * operation triggered when group membership or cluster and topic metadata change.Another mode is manual assignment mode,which manage the load balance by yourself.
+ *
+ * <p> Pull consumer divide message consumption to 3 parts.
+ * Firstly, determine whether to continue processing from the last consumption or reset the consumption starting point by call seek method;
+ * Then, pull message from servers.
+ * At last, pull consumer no need to commit message by offset meta.
+ * If there is a consumption error, consumer just call seek api to reset the offset for reconsume message again.
+ */
+public interface PullConsumer extends Closeable {
+    /**
+     * Listener that listens for changes of message queues when use manual assignment mode.
+     */
+    interface MessageQueuesChangeListener {
+        /**
+         * This method will be invoked in the condition of message queues changed, These scenarios occur when the
+         * topic is expanded or shrunk.
+         *
+         * @param messageQueues {@link MessageQueue} of topic.
+         */
+        void onChanged(Collection<MessageQueue> messageQueues);
+    }
+
+    /**
+     * Get metadata about the message queues for a given topic. This method will issue a remote call to the server if it
+     * does not already have any metadata about the given topic.
+     *
+     * @param topic message's topic
+     * @return message queues of topic.
+     */
+    Collection<MessageQueue> topicMessageQueues(String topic) throws ClientException;
+
+    /**
+     * Manually assign messageQueue collections to this consumer.
+     * This interface does not allow for incremental assignment and will replace the previous assignment.
+     * If the given collection is empty, it's treated same as unsubscribe().
+     * Manual assignment through this interface will disable the consumerGroup management functionality
+     * and there will be no rebalance operation triggered when group membership or cluster and topic metadata change.
+     * @param messageQueues are the collection for current consumer.
+     * @throws ClientException when assign
+     */
+    void assign(Collection<MessageQueue> messageQueues) throws ClientException;
+
+    /**
+     * Pull consumer query and update metadata about message queues periodically, listener is triggered once metadata
+     * is updated. The listener is required only in manual assignment mode.
+     * When use the subscription mode, no need to care the messageQueue change events.
+     *
+     * @param topic    topic to query and update metadata.
+     * @param listener listener to receive changes of metadata by topic.
+     */
+    void registerMessageQueuesChangeListener(String topic, MessageQueuesChangeListener listener);
+
+    /**
+     * Add subscription expression dynamically when use subscription mode.
+     *
+     * <p>If first {@link SubscriptionExpression} that contains topicA and tag1 is exists already in consumer, then
+     * second {@link SubscriptionExpression} which contains topicA and tag2, <strong>the result is that the second one
+     * replaces the first one instead of integrating them</strong>.
+     *
+     * @param subscriptionExpression new subscription expression to add.
+     * @return pull consumer instance.
+     */
+    PullConsumer subscribe(SubscriptionExpression subscriptionExpression) throws ClientException;
+
+    /**
+     * Remove subscription expression dynamically by topic.
+     *
+     * <p>Nothing occurs if the specified topic does not exist in subscription expressions of pull consumer.
+     *
+     * @param topic the topic to remove subscription.
+     * @return pull consumer instance.
+     */
+    PullConsumer unsubscribe(String topic) throws ClientException;
+
+    /**
+     * Get the collection of messageQueues currently assigned to current consumer.
+     * @return the collection of messageQueues currently assigned to current consumer
+     */
+    Collection<MessageQueue> assignment();
+
+    /**
+     * Fetch messages from server synchronously. This method returns immediately if there are messages available.
+     * Otherwise, it will await the passed timeout. If the timeout expires, an empty map will be returned.
+     * An error occurs if you do not subscribe or assign messageQueues before polling for data.
+     * @param messageQueue the target messageQueue to pull message.
+     * @param maxMessageNum max message num when server returns.
+     * @return collection of messageViews of this queue.
+     */
+    Collection<MessageView> pull(MessageQueue messageQueue, int maxMessageNum) throws ClientException;
+
+    /**
+     * Commit the offsets for the specified messageQueue.
+     * @param messageQueue the specified messageQueue to commit offset
+     * @param committedOffset the specified offset commit to server
+     */
+    void commit(MessageQueue messageQueue, long committedOffset) throws ClientException;","[{'comment': ""The commit needs an async method.\r\n\r\nAnd more importantly, it needs a simple commit().\r\n\r\nIn most cases, the user only wants to control the commit time but doesn't want to manage the offset store.\r\n"", 'commenter': 'dongeforever'}, {'comment': 'Maybe we need to rethink of the design of PullConsumer.', 'commenter': 'chenzlalvin'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/PullConsumer.java,"@@ -0,0 +1,172 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import java.io.Closeable;
+import java.time.Duration;
+import java.util.Collection;
+import java.util.Map;
+
+import org.apache.rocketmq.apis.MessageQueue;
+import org.apache.rocketmq.apis.exception.*;
+import org.apache.rocketmq.apis.message.MessageView;
+
+/**
+ * PullConsumer is a thread-safe rocketmq client which is used to consume message by queue.
+ * Unlike push consumer and simple consumer, pull consumer implement load balance based on queue granularity.
+ *
+ * <p>Pull consumer is lightweight consumer that better suited to streaming scenarios.
+ * If you want fully control the message consumption operation by yourself like scan by offset or reconsume repeatedly,
+ * pull consumer should be your first consideration.
+ *
+ * <p>Pull consumer support two load balance mode. First is subscription mode, which full manage the rebalance
+ * operation triggered when group membership or cluster and topic metadata change.Another mode is manual assignment mode,which manage the load balance by yourself.
+ *
+ * <p> Pull consumer divide message consumption to 3 parts.
+ * Firstly, determine whether to continue processing from the last consumption or reset the consumption starting point by call seek method;
+ * Then, pull message from servers.
+ * At last, pull consumer no need to commit message by offset meta.
+ * If there is a consumption error, consumer just call seek api to reset the offset for reconsume message again.
+ */
+public interface PullConsumer extends Closeable {
+    /**
+     * Listener that listens for changes of message queues when use manual assignment mode.
+     */
+    interface MessageQueuesChangeListener {
+        /**
+         * This method will be invoked in the condition of message queues changed, These scenarios occur when the
+         * topic is expanded or shrunk.
+         *
+         * @param messageQueues {@link MessageQueue} of topic.
+         */
+        void onChanged(Collection<MessageQueue> messageQueues);
+    }
+
+    /**
+     * Get metadata about the message queues for a given topic. This method will issue a remote call to the server if it
+     * does not already have any metadata about the given topic.
+     *
+     * @param topic message's topic
+     * @return message queues of topic.
+     */
+    Collection<MessageQueue> topicMessageQueues(String topic) throws ClientException;
+
+    /**
+     * Manually assign messageQueue collections to this consumer.
+     * This interface does not allow for incremental assignment and will replace the previous assignment.
+     * If the given collection is empty, it's treated same as unsubscribe().
+     * Manual assignment through this interface will disable the consumerGroup management functionality
+     * and there will be no rebalance operation triggered when group membership or cluster and topic metadata change.
+     * @param messageQueues are the collection for current consumer.
+     * @throws ClientException when assign
+     */
+    void assign(Collection<MessageQueue> messageQueues) throws ClientException;
+","[{'comment': ""What would happen if I don't invoke `PullConsumerBuilder#enableManualQueueAssignment` before?"", 'commenter': 'aaron-ai'}, {'comment': 'Maybe we need to rethink of the design of PullConsumer.', 'commenter': 'chenzlalvin'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/PushConsumer.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import com.google.common.util.concurrent.Service;
+import java.io.Closeable;
+import java.util.Collection;
+
+import org.apache.rocketmq.apis.exception.*;
+
+/**
+ * PushConsumer is a thread-safe rocketmq client which is used to consume message by group.
+ *
+ * <p>Push consumer is fully-managed consumer, if you are confused to choose your consumer, push consumer should be
+ * your first consideration.
+ *
+ * <p>Consumers belong to the same consumer group share messages from server,
+ * so consumer in the same group must have the same {@link SubscriptionExpression}s, otherwise the behavior is
+ * undefined. If a new consumer group's consumer is started first time, it consumes from the latest position. Once
+ * consumer is started, server records its consumption progress and derives it in subsequent startup.
+ *
+ * <p>You may intend to maintain different consumption progress for different consumer, different consumer group
+ * should be set in this case.
+ *
+ * <p>To accelerate the message consumption, push consumer applies
+ * <a href=""https://en.wikipedia.org/wiki/Reactive_Streams"">reactive streams</a>
+ * . Messages received from server is cached locally before consumption,
+ * {@link PushConsumerBuilder#setMaxCacheMessageCount(int)} and
+ * {@link PushConsumerBuilder#setMaxCacheMessageSizeInBytes(int)} could be used to set the cache threshold in
+ * different dimension.
+ */
+public interface PushConsumer extends Closeable {
+    /**
+     * Get the load balancing group for consumer.
+     *
+     * @return consumer load balancing group.
+     */
+    String getConsumerGroup();
+
+    /**
+     * Get the existed subscription expression in push consumer.
+     *
+     * @return collections of subscription expression.
+     */
+    Collection<SubscriptionExpression> listSubscriptionExpression();
+
+    /**
+     * Add subscription expression dynamically.
+     *
+     * <p>If first {@link SubscriptionExpression} that contains topicA and tag1 is exists already in consumer, then
+     * second {@link SubscriptionExpression} which contains topicA and tag2, <strong>the result is that the second one
+     * replaces the first one instead of integrating them</strong>.
+     *
+     * @param subscriptionExpression new subscription expression to add.
+     * @return push consumer instance.
+     */
+    PushConsumer subscribe(SubscriptionExpression subscriptionExpression) throws ClientException;
+
+    /**
+     * Remove subscription expression dynamically by topic.
+     *
+     * <p>It stops the backend task to fetch message from remote, and besides that, the local cached message whose topic
+     * was removed before would not be delivered to {@link MessageListener} anymore.
+     *
+     * <p>Nothing occurs if the specified topic does not exist in subscription expressions of push consumer.
+     *
+     * @param topic the topic to remove subscription.
+     * @return push consumer instance.
+     */
+    PushConsumer unsubscribe(String topic) throws ClientException;
+","[{'comment': 'Why do subscribe and unsubscribe have different arguments?\r\n\r\nIt is a little strange intuitively.\r\n', 'commenter': 'dongeforever'}, {'comment': 'The subscribe action contains complex parameters such as filter type and expression, but unsubscribe action applies only to topic granularity. We can not unsub with some expression.', 'commenter': 'chenzlalvin'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/PullConsumer.java,"@@ -0,0 +1,172 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import java.io.Closeable;
+import java.time.Duration;
+import java.util.Collection;
+import java.util.Map;
+
+import org.apache.rocketmq.apis.MessageQueue;
+import org.apache.rocketmq.apis.exception.*;
+import org.apache.rocketmq.apis.message.MessageView;
+
+/**
+ * PullConsumer is a thread-safe rocketmq client which is used to consume message by queue.
+ * Unlike push consumer and simple consumer, pull consumer implement load balance based on queue granularity.
+ *
+ * <p>Pull consumer is lightweight consumer that better suited to streaming scenarios.
+ * If you want fully control the message consumption operation by yourself like scan by offset or reconsume repeatedly,
+ * pull consumer should be your first consideration.
+ *
+ * <p>Pull consumer support two load balance mode. First is subscription mode, which full manage the rebalance
+ * operation triggered when group membership or cluster and topic metadata change.Another mode is manual assignment mode,which manage the load balance by yourself.
+ *
+ * <p> Pull consumer divide message consumption to 3 parts.
+ * Firstly, determine whether to continue processing from the last consumption or reset the consumption starting point by call seek method;
+ * Then, pull message from servers.
+ * At last, pull consumer no need to commit message by offset meta.
+ * If there is a consumption error, consumer just call seek api to reset the offset for reconsume message again.
+ */
+public interface PullConsumer extends Closeable {
+    /**
+     * Listener that listens for changes of message queues when use manual assignment mode.
+     */
+    interface MessageQueuesChangeListener {
+        /**
+         * This method will be invoked in the condition of message queues changed, These scenarios occur when the
+         * topic is expanded or shrunk.
+         *
+         * @param messageQueues {@link MessageQueue} of topic.
+         */
+        void onChanged(Collection<MessageQueue> messageQueues);
+    }
+
+    /**
+     * Get metadata about the message queues for a given topic. This method will issue a remote call to the server if it
+     * does not already have any metadata about the given topic.
+     *
+     * @param topic message's topic
+     * @return message queues of topic.
+     */
+    Collection<MessageQueue> topicMessageQueues(String topic) throws ClientException;
+
+    /**
+     * Manually assign messageQueue collections to this consumer.
+     * This interface does not allow for incremental assignment and will replace the previous assignment.
+     * If the given collection is empty, it's treated same as unsubscribe().
+     * Manual assignment through this interface will disable the consumerGroup management functionality
+     * and there will be no rebalance operation triggered when group membership or cluster and topic metadata change.
+     * @param messageQueues are the collection for current consumer.
+     * @throws ClientException when assign
+     */
+    void assign(Collection<MessageQueue> messageQueues) throws ClientException;
+
+    /**
+     * Pull consumer query and update metadata about message queues periodically, listener is triggered once metadata
+     * is updated. The listener is required only in manual assignment mode.
+     * When use the subscription mode, no need to care the messageQueue change events.
+     *
+     * @param topic    topic to query and update metadata.
+     * @param listener listener to receive changes of metadata by topic.
+     */
+    void registerMessageQueuesChangeListener(String topic, MessageQueuesChangeListener listener);
+
+    /**
+     * Add subscription expression dynamically when use subscription mode.
+     *
+     * <p>If first {@link SubscriptionExpression} that contains topicA and tag1 is exists already in consumer, then
+     * second {@link SubscriptionExpression} which contains topicA and tag2, <strong>the result is that the second one
+     * replaces the first one instead of integrating them</strong>.
+     *
+     * @param subscriptionExpression new subscription expression to add.
+     * @return pull consumer instance.
+     */
+    PullConsumer subscribe(SubscriptionExpression subscriptionExpression) throws ClientException;
+
+    /**
+     * Remove subscription expression dynamically by topic.
+     *
+     * <p>Nothing occurs if the specified topic does not exist in subscription expressions of pull consumer.
+     *
+     * @param topic the topic to remove subscription.
+     * @return pull consumer instance.
+     */
+    PullConsumer unsubscribe(String topic) throws ClientException;
+
+    /**
+     * Get the collection of messageQueues currently assigned to current consumer.
+     * @return the collection of messageQueues currently assigned to current consumer
+     */
+    Collection<MessageQueue> assignment();","[{'comment': 'assignments', 'commenter': 'aaron-ai'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/PullConsumer.java,"@@ -0,0 +1,172 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import java.io.Closeable;
+import java.time.Duration;
+import java.util.Collection;
+import java.util.Map;
+
+import org.apache.rocketmq.apis.MessageQueue;
+import org.apache.rocketmq.apis.exception.*;
+import org.apache.rocketmq.apis.message.MessageView;
+
+/**
+ * PullConsumer is a thread-safe rocketmq client which is used to consume message by queue.
+ * Unlike push consumer and simple consumer, pull consumer implement load balance based on queue granularity.
+ *
+ * <p>Pull consumer is lightweight consumer that better suited to streaming scenarios.
+ * If you want fully control the message consumption operation by yourself like scan by offset or reconsume repeatedly,
+ * pull consumer should be your first consideration.
+ *
+ * <p>Pull consumer support two load balance mode. First is subscription mode, which full manage the rebalance
+ * operation triggered when group membership or cluster and topic metadata change.Another mode is manual assignment mode,which manage the load balance by yourself.
+ *
+ * <p> Pull consumer divide message consumption to 3 parts.
+ * Firstly, determine whether to continue processing from the last consumption or reset the consumption starting point by call seek method;
+ * Then, pull message from servers.
+ * At last, pull consumer no need to commit message by offset meta.
+ * If there is a consumption error, consumer just call seek api to reset the offset for reconsume message again.
+ */
+public interface PullConsumer extends Closeable {
+    /**
+     * Listener that listens for changes of message queues when use manual assignment mode.
+     */
+    interface MessageQueuesChangeListener {
+        /**
+         * This method will be invoked in the condition of message queues changed, These scenarios occur when the
+         * topic is expanded or shrunk.
+         *
+         * @param messageQueues {@link MessageQueue} of topic.
+         */
+        void onChanged(Collection<MessageQueue> messageQueues);
+    }
+
+    /**
+     * Get metadata about the message queues for a given topic. This method will issue a remote call to the server if it
+     * does not already have any metadata about the given topic.
+     *
+     * @param topic message's topic
+     * @return message queues of topic.
+     */
+    Collection<MessageQueue> topicMessageQueues(String topic) throws ClientException;
+
+    /**
+     * Manually assign messageQueue collections to this consumer.
+     * This interface does not allow for incremental assignment and will replace the previous assignment.
+     * If the given collection is empty, it's treated same as unsubscribe().
+     * Manual assignment through this interface will disable the consumerGroup management functionality
+     * and there will be no rebalance operation triggered when group membership or cluster and topic metadata change.
+     * @param messageQueues are the collection for current consumer.
+     * @throws ClientException when assign
+     */
+    void assign(Collection<MessageQueue> messageQueues) throws ClientException;
+
+    /**
+     * Pull consumer query and update metadata about message queues periodically, listener is triggered once metadata
+     * is updated. The listener is required only in manual assignment mode.
+     * When use the subscription mode, no need to care the messageQueue change events.
+     *
+     * @param topic    topic to query and update metadata.
+     * @param listener listener to receive changes of metadata by topic.
+     */
+    void registerMessageQueuesChangeListener(String topic, MessageQueuesChangeListener listener);
+
+    /**
+     * Add subscription expression dynamically when use subscription mode.
+     *
+     * <p>If first {@link SubscriptionExpression} that contains topicA and tag1 is exists already in consumer, then
+     * second {@link SubscriptionExpression} which contains topicA and tag2, <strong>the result is that the second one
+     * replaces the first one instead of integrating them</strong>.
+     *
+     * @param subscriptionExpression new subscription expression to add.
+     * @return pull consumer instance.
+     */
+    PullConsumer subscribe(SubscriptionExpression subscriptionExpression) throws ClientException;
+
+    /**
+     * Remove subscription expression dynamically by topic.
+     *
+     * <p>Nothing occurs if the specified topic does not exist in subscription expressions of pull consumer.
+     *
+     * @param topic the topic to remove subscription.
+     * @return pull consumer instance.
+     */
+    PullConsumer unsubscribe(String topic) throws ClientException;
+
+    /**
+     * Get the collection of messageQueues currently assigned to current consumer.
+     * @return the collection of messageQueues currently assigned to current consumer
+     */
+    Collection<MessageQueue> assignment();
+
+    /**
+     * Fetch messages from server synchronously. This method returns immediately if there are messages available.
+     * Otherwise, it will await the passed timeout. If the timeout expires, an empty map will be returned.
+     * An error occurs if you do not subscribe or assign messageQueues before polling for data.","[{'comment': 'Add `<p>` here', 'commenter': 'aaron-ai'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/ClientServiceProvider.java,"@@ -43,6 +47,27 @@ static ClientServiceProvider loadService() {
      */
     ProducerBuilder newProducerBuilder();
 
+    /**
+     * Get the simple consumer builder by current provider.
+     *
+     * @return the simple consumer builder instance.
+     */
+    SimpleConsumerBuilder newSimpleConsumerBuilder();
+
+    /**
+     * Get the pull consumer builder by current provider.
+     *
+     * @return the pull consumer builder instance.
+     */
+    PullConsumerBuilder newPollConsumerBuilder();","[{'comment': 'newPollConsumerBuilder => newPullConsumerBuilder', 'commenter': 'aaron-ai'}, {'comment': 'got. spelling mistake.', 'commenter': 'chenzlalvin'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/PullConsumer.java,"@@ -0,0 +1,172 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import java.io.Closeable;
+import java.time.Duration;
+import java.util.Collection;
+import java.util.Map;
+
+import org.apache.rocketmq.apis.MessageQueue;
+import org.apache.rocketmq.apis.exception.*;
+import org.apache.rocketmq.apis.message.MessageView;
+
+/**
+ * PullConsumer is a thread-safe rocketmq client which is used to consume message by queue.
+ * Unlike push consumer and simple consumer, pull consumer implement load balance based on queue granularity.
+ *
+ * <p>Pull consumer is lightweight consumer that better suited to streaming scenarios.
+ * If you want fully control the message consumption operation by yourself like scan by offset or reconsume repeatedly,
+ * pull consumer should be your first consideration.
+ *
+ * <p>Pull consumer support two load balance mode. First is subscription mode, which full manage the rebalance
+ * operation triggered when group membership or cluster and topic metadata change.Another mode is manual assignment mode,which manage the load balance by yourself.
+ *
+ * <p> Pull consumer divide message consumption to 3 parts.
+ * Firstly, determine whether to continue processing from the last consumption or reset the consumption starting point by call seek method;
+ * Then, pull message from servers.
+ * At last, pull consumer no need to commit message by offset meta.
+ * If there is a consumption error, consumer just call seek api to reset the offset for reconsume message again.
+ */
+public interface PullConsumer extends Closeable {
+    /**
+     * Listener that listens for changes of message queues when use manual assignment mode.
+     */
+    interface MessageQueuesChangeListener {
+        /**
+         * This method will be invoked in the condition of message queues changed, These scenarios occur when the
+         * topic is expanded or shrunk.
+         *
+         * @param messageQueues {@link MessageQueue} of topic.
+         */
+        void onChanged(Collection<MessageQueue> messageQueues);
+    }
+
+    /**
+     * Get metadata about the message queues for a given topic. This method will issue a remote call to the server if it
+     * does not already have any metadata about the given topic.
+     *
+     * @param topic message's topic
+     * @return message queues of topic.
+     */
+    Collection<MessageQueue> topicMessageQueues(String topic) throws ClientException;
+
+    /**
+     * Manually assign messageQueue collections to this consumer.
+     * This interface does not allow for incremental assignment and will replace the previous assignment.
+     * If the given collection is empty, it's treated same as unsubscribe().
+     * Manual assignment through this interface will disable the consumerGroup management functionality
+     * and there will be no rebalance operation triggered when group membership or cluster and topic metadata change.
+     * @param messageQueues are the collection for current consumer.
+     * @throws ClientException when assign
+     */
+    void assign(Collection<MessageQueue> messageQueues) throws ClientException;
+
+    /**
+     * Pull consumer query and update metadata about message queues periodically, listener is triggered once metadata
+     * is updated. The listener is required only in manual assignment mode.
+     * When use the subscription mode, no need to care the messageQueue change events.
+     *
+     * @param topic    topic to query and update metadata.
+     * @param listener listener to receive changes of metadata by topic.
+     */
+    void registerMessageQueuesChangeListener(String topic, MessageQueuesChangeListener listener);
+","[{'comment': 'Why need to specify the topic argument?', 'commenter': 'dongeforever'}, {'comment': 'Maybe we need to rethink of the design of PullConsumer.', 'commenter': 'chenzlalvin'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/PullConsumer.java,"@@ -0,0 +1,172 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import java.io.Closeable;
+import java.time.Duration;
+import java.util.Collection;
+import java.util.Map;
+
+import org.apache.rocketmq.apis.MessageQueue;
+import org.apache.rocketmq.apis.exception.*;
+import org.apache.rocketmq.apis.message.MessageView;
+
+/**
+ * PullConsumer is a thread-safe rocketmq client which is used to consume message by queue.
+ * Unlike push consumer and simple consumer, pull consumer implement load balance based on queue granularity.
+ *
+ * <p>Pull consumer is lightweight consumer that better suited to streaming scenarios.
+ * If you want fully control the message consumption operation by yourself like scan by offset or reconsume repeatedly,
+ * pull consumer should be your first consideration.
+ *
+ * <p>Pull consumer support two load balance mode. First is subscription mode, which full manage the rebalance
+ * operation triggered when group membership or cluster and topic metadata change.Another mode is manual assignment mode,which manage the load balance by yourself.
+ *
+ * <p> Pull consumer divide message consumption to 3 parts.
+ * Firstly, determine whether to continue processing from the last consumption or reset the consumption starting point by call seek method;
+ * Then, pull message from servers.
+ * At last, pull consumer no need to commit message by offset meta.
+ * If there is a consumption error, consumer just call seek api to reset the offset for reconsume message again.
+ */
+public interface PullConsumer extends Closeable {
+    /**
+     * Listener that listens for changes of message queues when use manual assignment mode.
+     */
+    interface MessageQueuesChangeListener {
+        /**
+         * This method will be invoked in the condition of message queues changed, These scenarios occur when the
+         * topic is expanded or shrunk.
+         *
+         * @param messageQueues {@link MessageQueue} of topic.
+         */
+        void onChanged(Collection<MessageQueue> messageQueues);","[{'comment': 'Could user adjust the frequency that the listener is invoked?', 'commenter': 'aaron-ai'}, {'comment': 'Maybe we need to rethink of the design of PullConsumer.', 'commenter': 'chenzlalvin'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/PullConsumerBuilder.java,"@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import org.apache.rocketmq.apis.ClientConfiguration;
+import org.apache.rocketmq.apis.exception.ClientException;
+
+import java.time.Duration;
+
+public interface PullConsumerBuilder {
+    /**
+     * Set the client configuration for pull consumer.
+     *
+     * @param clientConfiguration client's configuration.
+     * @return the pull consumer builder instance.
+     */
+    PullConsumerBuilder setClientConfiguration(ClientConfiguration clientConfiguration);
+
+    /**
+     * Set the load balancing group for consumer.
+     *
+     * @param consumerGroup consumer load balancing group.
+     * @return the consumer builder instance.
+     */
+    PullConsumerBuilder setConsumerGroup(String consumerGroup);
+
+    /**
+     * Enable manual messageQueue assignment consumption mode.
+     * The default mode is subscription mode which manage the rebalance operation triggered when group membership or cluster and topic metadata change.
+     * When pull consumer manual queue assignment mode, must invoke assign method before pull message.
+     * @return the consumer builder instance.
+     */
+    PushConsumerBuilder enableManualQueueAssignment();
+","[{'comment': 'or enableManualAssignment?', 'commenter': 'aaron-ai'}, {'comment': 'By default, the subscription mode is enabled. After this assgin mode is enabled, active custom allocation is allowed', 'commenter': 'chenzlalvin'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/PushConsumer.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import com.google.common.util.concurrent.Service;
+import java.io.Closeable;
+import java.util.Collection;
+
+import org.apache.rocketmq.apis.exception.*;
+
+/**
+ * PushConsumer is a thread-safe rocketmq client which is used to consume message by group.
+ *
+ * <p>Push consumer is fully-managed consumer, if you are confused to choose your consumer, push consumer should be
+ * your first consideration.
+ *
+ * <p>Consumers belong to the same consumer group share messages from server,
+ * so consumer in the same group must have the same {@link SubscriptionExpression}s, otherwise the behavior is
+ * undefined. If a new consumer group's consumer is started first time, it consumes from the latest position. Once
+ * consumer is started, server records its consumption progress and derives it in subsequent startup.
+ *
+ * <p>You may intend to maintain different consumption progress for different consumer, different consumer group
+ * should be set in this case.
+ *
+ * <p>To accelerate the message consumption, push consumer applies
+ * <a href=""https://en.wikipedia.org/wiki/Reactive_Streams"">reactive streams</a>
+ * . Messages received from server is cached locally before consumption,
+ * {@link PushConsumerBuilder#setMaxCacheMessageCount(int)} and
+ * {@link PushConsumerBuilder#setMaxCacheMessageSizeInBytes(int)} could be used to set the cache threshold in
+ * different dimension.
+ */
+public interface PushConsumer extends Closeable {
+    /**
+     * Get the load balancing group for consumer.
+     *
+     * @return consumer load balancing group.
+     */
+    String getConsumerGroup();
+
+    /**
+     * Get the existed subscription expression in push consumer.
+     *
+     * @return collections of subscription expression.
+     */
+    Collection<SubscriptionExpression> listSubscriptionExpression();","[{'comment': 'Considering the `PullConsumer#assignments()` before, maybe we should keep the same style?', 'commenter': 'aaron-ai'}, {'comment': 'got. spelling mistake.', 'commenter': 'chenzlalvin'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/PullConsumerBuilder.java,"@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import org.apache.rocketmq.apis.ClientConfiguration;
+import org.apache.rocketmq.apis.exception.ClientException;
+
+import java.time.Duration;
+
+public interface PullConsumerBuilder {
+    /**
+     * Set the client configuration for pull consumer.
+     *
+     * @param clientConfiguration client's configuration.
+     * @return the pull consumer builder instance.
+     */
+    PullConsumerBuilder setClientConfiguration(ClientConfiguration clientConfiguration);
+
+    /**
+     * Set the load balancing group for consumer.
+     *
+     * @param consumerGroup consumer load balancing group.
+     * @return the consumer builder instance.
+     */
+    PullConsumerBuilder setConsumerGroup(String consumerGroup);
+
+    /**
+     * Enable manual messageQueue assignment consumption mode.
+     * <p> The default mode is subscription mode which manage the rebalance operation triggered when group membership or cluster and topic metadata change.
+     * When pull consumer manual queue assignment mode, must invoke assign method before pull message.
+     * @return the consumer builder instance.
+     */
+    PushConsumerBuilder enableManualAssignment();","[{'comment': 'Return PullConsumerBuilder', 'commenter': 'zhouxinyu'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/PullConsumerBuilder.java,"@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import org.apache.rocketmq.apis.ClientConfiguration;
+import org.apache.rocketmq.apis.exception.ClientException;
+
+import java.time.Duration;
+
+public interface PullConsumerBuilder {
+    /**
+     * Set the client configuration for pull consumer.
+     *
+     * @param clientConfiguration client's configuration.
+     * @return the pull consumer builder instance.
+     */
+    PullConsumerBuilder setClientConfiguration(ClientConfiguration clientConfiguration);
+
+    /**
+     * Set the load balancing group for consumer.
+     *
+     * @param consumerGroup consumer load balancing group.
+     * @return the consumer builder instance.
+     */
+    PullConsumerBuilder setConsumerGroup(String consumerGroup);
+
+    /**
+     * Enable manual messageQueue assignment consumption mode.
+     * <p> The default mode is subscription mode which manage the rebalance operation triggered when group membership or cluster and topic metadata change.
+     * When pull consumer manual queue assignment mode, must invoke assign method before pull message.
+     * @return the consumer builder instance.
+     */
+    PushConsumerBuilder enableManualAssignment();
+
+    /**
+     * Set the max await time when receive message from server.
+     * <p> The simple consumer will hold this long-polling receive requests until  a message is returned or a timeout occurs.
+     * @param awaitDuration The maximum time to block when no message available.
+     * @return the consumer builder instance.
+     */
+    PushConsumerBuilder setAwaitDuration(Duration awaitDuration);","[{'comment': 'Return PullConsumerBuilder', 'commenter': 'zhouxinyu'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/PullConsumer.java,"@@ -0,0 +1,186 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import java.io.Closeable;
+import java.time.Duration;
+import java.util.Collection;
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+
+import org.apache.rocketmq.apis.MessageQueue;
+import org.apache.rocketmq.apis.exception.*;
+import org.apache.rocketmq.apis.message.MessageView;
+
+/**
+ * <p>PullConsumer is a thread-safe rocketmq client which is used to consume message by queue.
+ * Unlike push consumer and simple consumer, pull consumer implement load balance based on queue granularity.
+ *
+ * <p>Pull consumer is lightweight consumer that better suited to streaming scenarios.
+ * If you want fully control the message consumption operation by yourself like scan by offset or reconsume repeatedly,
+ * pull consumer should be your first consideration.
+ *
+ * <p>Pull consumer support two load balance mode. First is subscription mode, which full manage the rebalance","[{'comment': 'two load balance modes.', 'commenter': 'zhouxinyu'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/SimpleConsumer.java,"@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import java.io.Closeable;
+import java.time.Duration;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+
+import org.apache.rocketmq.apis.exception.*;
+import org.apache.rocketmq.apis.message.MessageView;
+
+/**
+ * SimpleConsumer is a thread-safe rocketmq client which is used to consume message by group.
+ *
+ * <p>Simple consumer is lightweight consumer , if you want fully control the message consumption operation by yourself,
+ * simple consumer should be your first consideration.","[{'comment': 'Consider adding the difference between SimpleConsumer and PullConsumer.', 'commenter': 'zhouxinyu'}]"
4019,apis/src/main/java/org/apache/rocketmq/apis/consumer/SimpleConsumer.java,"@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.apis.consumer;
+
+import java.io.Closeable;
+import java.time.Duration;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+
+import org.apache.rocketmq.apis.exception.*;
+import org.apache.rocketmq.apis.message.MessageView;
+
+/**
+ * SimpleConsumer is a thread-safe rocketmq client which is used to consume message by group.
+ *
+ * <p>Simple consumer is lightweight consumer , if you want fully control the message consumption operation by yourself,
+ * simple consumer should be your first consideration.
+ *
+ * <p>Consumers belong to the same consumer group share messages from server,
+ * so consumer in the same group must have the same {@link SubscriptionExpression}s, otherwise the behavior is
+ * undefined. If a new consumer group's consumer is started first time, it consumes from the latest position. Once
+ * consumer is started, server records its consumption progress and derives it in subsequent startup.
+ *
+ * <p>You may intend to maintain different consumption progress for different consumer, different consumer group
+ * should be set in this case.
+ *
+ * <p> Simple consumer divide message consumption to 3 parts.
+ * Firstly, call receive api get messages from server; Then process message by yourself; At last, your must call Ack api to commit this message.
+ * If there is error when process message ,your can reconsume the message later which control by the invisibleDuration parameter.
+ * Also, you can change the invisibleDuration by call changeInvisibleDuration api.
+ */
+public interface SimpleConsumer extends Closeable {
+    /**
+     * Get the load balancing group for simple consumer.
+     *
+     * @return consumer load balancing group.
+     */
+    String getConsumerGroup();
+
+    /**
+     * Add subscription expression dynamically.
+     *
+     * <p>If first {@link SubscriptionExpression} that contains topicA and tag1 is exists already in consumer, then
+     * second {@link SubscriptionExpression} which contains topicA and tag2, <strong>the result is that the second one
+     * replaces the first one instead of integrating them</strong>.
+     *
+     * @param subscriptionExpression new subscription expression to add.
+     * @return simple consumer instance.
+     */
+    SimpleConsumer subscribe(SubscriptionExpression subscriptionExpression) throws ClientException;","[{'comment': 'Each consumer has subscription management and consumer group, consider abstract a super interface type?', 'commenter': 'zhouxinyu'}]"
4038,tools/src/test/java/org/apache/rocketmq/tools/command/broker/DeleteExpiredCommitLogSubCommandTest.java,"@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tools.command.broker;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Options;
+import org.apache.commons.cli.PosixParser;
+import org.apache.rocketmq.srvutil.ServerUtil;
+import org.apache.rocketmq.tools.command.SubCommandException;
+import org.apache.rocketmq.tools.command.server.ServerResponseMocker;
+import org.junit.Test;
+
+public class DeleteExpiredCommitLogSubCommandTest extends ServerResponseMocker {
+
+    private static final int PORT = 45678;
+
+    @Override
+    protected int getPort() {
+        return PORT;
+    }
+
+    @Override
+    protected byte[] getBody() {
+        return null;
+    }
+
+    @Test
+    public void testExecute() throws SubCommandException {
+        DeleteExpiredCommitLogSubCommand cmd = new DeleteExpiredCommitLogSubCommand();
+        Options options = ServerUtil.buildCommandlineOptions(new Options());
+        String[] subargs = new String[] {""-b 127.0.0.1:"" + PORT, ""-c default-cluster""};
+        final CommandLine commandLine = ServerUtil.parseCmdLine(""mqadmin "" + cmd.commandName(), subargs,
+            cmd.buildCommandlineOptions(options), new PosixParser());
+        cmd.execute(commandLine, options, null);","[{'comment': 'Any assert here?', 'commenter': 'vongosling'}]"
4059,store/src/main/java/org/apache/rocketmq/store/dledger/DLedgerCommitLog.java,"@@ -421,6 +421,11 @@ private void setMessageInfo(MessageExtBrokerInner msg, int tranType) {
 
         setMessageInfo(msg, tranType);
 
+        boolean multiDispatchWrapResult = multiDispatch.wrapMultiDispatch(msg);","[{'comment': 'multiDispatch.wrapMultiDispatch() has a concurrency problem.', 'commenter': 'Git-Yang'}, {'comment': 'fixed', 'commenter': 'chaiyx'}, {'comment': '> fixed\r\n\r\nthe keyBuilder can be ThreadLocal?', 'commenter': 'tianliuliu'}]"
4059,store/src/main/java/org/apache/rocketmq/store/dledger/DLedgerCommitLog.java,"@@ -426,17 +426,31 @@ private void setMessageInfo(MessageExtBrokerInner msg, int tranType) {
         // Back to Results
         AppendMessageResult appendResult;
         AppendFuture<AppendEntryResponse> dledgerFuture;
-        EncodeResult encodeResult;
+        EncodeResult encodeResult = null;
 
-        encodeResult = this.messageSerializer.serialize(msg);
-        if (encodeResult.status != AppendMessageStatus.PUT_OK) {
-            return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, new AppendMessageResult(encodeResult.status)));
+        boolean isMultiDispatch = multiDispatch.isMultiDispatchMsg(msg);
+        if (!isMultiDispatch) {
+            encodeResult = this.messageSerializer.serialize(msg);
+            if (encodeResult.status != AppendMessageStatus.PUT_OK) {
+                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, new AppendMessageResult(encodeResult.status)));
+            }
         }
         putMessageLock.lock(); //spin or ReentrantLock ,depending on store config
         long elapsedTimeInLock;
         long queueOffset;
         try {
             beginTimeInDledgerLock = this.defaultMessageStore.getSystemClock().now();
+            if (isMultiDispatch) {
+                boolean multiDispatchWrapResult = multiDispatch.wrapMultiDispatch(msg);","[{'comment': 'make wrapMultiDispatch method thread safety and not use lock ,because if this the lock will be larger, not good idea', 'commenter': 'tianliuliu'}]"
4075,store/src/main/java/org/apache/rocketmq/store/config/MessageStoreConfig.java,"@@ -84,7 +84,7 @@
     @ImportantField
     private int fileReservedTime = 72;
     // Flow control for ConsumeQueue
-    private int putMsgIndexHightWater = 600000;","[{'comment': 'This field should be addressed in our doc. You know, if we do not have any comments, people would feel a  little quirk in these points.', 'commenter': 'vongosling'}, {'comment': 'Could you tell me which doc this field should be addressed？ I just change this field name，I could not find the field named ""putMsgIndexHightWater"" in any doc under the path rocketmq/docs. thx', 'commenter': 'Hen1ng'}, {'comment': '@ni-ze please help to review this pr', 'commenter': 'Hen1ng'}, {'comment': '> Could you tell me which doc this field should be addressed？ I just change this field name，I could not find the field named ""putMsgIndexHightWater"" in any doc under the path rocketmq/docs. thx\r\n\r\nYou can find it here https://github.com/apache/rocketmq-site \r\nDeployment-Configuration-Broker Configuration', 'commenter': 'HScarb'}, {'comment': '@HScarb thx for the answer', 'commenter': 'Hen1ng'}, {'comment': ""@Hen1ng Fields in `MessageStoreConfig` may be set by reflection (you may find such usage by `org.apache.rocketmq.common.MixAll#properties2Object`), once you change the field names, users who have configured by the previous names will be affected, the values they've changed in property file will be 'restored' to default values. So changing these fields require careful consideration.\r\n\r\nIMO, you'd better move this modification to another dedicated issue, and change the field name in a compatible way also with clear documents  addressing to it."", 'commenter': 'caigy'}]"
4141,docs/en/Example_OpenMessaging.md,"@@ -1,5 +1,5 @@
 # OpenMessaging Example
-[OpenMessaging](https://openmessaging.github.io/), which includes the establishment of industry guidelines and messaging, streaming specifications to provide a common framework for finance, ecommerce, IoT and big-data area. The design principles are the cloud-oriented, simplicity, flexibility, and language independent in distributed heterogeneous environments. Conformance to these specifications will make it possible to develop a heterogeneous messaging applications across all major platforms and operating systems.
+[OpenMessaging](https://openmessaging.github.io/), which includes the establishment of industry guidelines and messaging, streaming specifications to provide a common framework for finance, commerce, IoT and big-data area. The design principles are the cloud-oriented, simplicity, flexibility, and language independent in distributed heterogeneous environments. Conformance to these specifications will make it possible to develop a heterogeneous messaging applications across all major platforms and operating systems.","[{'comment': 'e-commerce would be better', 'commenter': 'vongosling'}]"
4141,docs/en/Troubleshoopting.md,"@@ -73,4 +73,4 @@ SendResult [sendStatus=SEND_OK, msgId=0A42333A0DC818B4AAC246C290FD0000, offsetMs
 ```
 
 - msgId，for the client, the msgId is generated by the producer instance. Specifically, the method `MessageClientIDSetter.createUniqIDBuffer()` is called to generate a unique Id.
-- offsetMsgId, offsetMsgId is generated by the Broker server when writing a message ( string concating ""IP address + port"" and ""CommitLog's physical offset address""), and offsetMsgId is the messageId used to query in the RocketMQ console.
+- offsetMsgId, offsetMsgId is generated by the Broker server when writing a message ( string concat with ""IP address + port"" and ""CommitLog's physical offset address""), and offsetMsgId is the messageId used to query in the RocketMQ console.","[{'comment': 'IMO, better use  ` string consisting of ""IP address + port"" and ""CommitLog\'s physical offset address""`\r\n', 'commenter': 'yuz10'}]"
4146,docs/cn/features.md,"@@ -28,14 +28,17 @@ RocketMQ支持消息的高可靠，影响消息可靠性的几种情况：
 5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。注：RocketMQ从3.0版本开始支持同步双写。
 
 ## 5 至少一次
-至少一次(At least Once)指每个消息必须投递一次。Consumer先Pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。
+至少一次(At Least Once)指每条消息至少投递一次。Consumer先Pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。
 
-## 6 回溯消费
+## 6 至多一次
+至多一次(At Most Once)指每条消息至多投递一次。Producer 的 `sendOneway` 方法，将消息投递给目标 `MessageQueue` 后，忽略 Broker 对投递结果的反馈，也不会有任何重试机制。","[{'comment': 'Would it be better to change it to send here?', 'commenter': 'panzhi33'}, {'comment': '> Would it be better to change it to send here?\r\n\r\nChange what ?\r\nCould you be more detail? Thank you very much.', 'commenter': 'XiaoyiPeng'}, {'comment': '至多一次(At Most Once)指每条消息至多投递一次。我认为这里指的是消费端。\r\n而后面的描述又是producer', 'commenter': 'panzhi33'}, {'comment': '明白啦。', 'commenter': 'XiaoyiPeng'}]"
4146,docs/cn/features.md,"@@ -27,15 +27,22 @@ RocketMQ支持消息的高可靠，影响消息可靠性的几种情况：
 
 5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。注：RocketMQ从3.0版本开始支持同步双写。
 
-## 5 至少一次
-至少一次(At least Once)指每个消息必须投递一次。Consumer先Pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。
+## 5 至少一次(At Least Once)
+- 生产端：当消息发送给 Master Broker 后,如果同步给 Slave Broker 出现超时等异常(不限于这种情况,还有 Broker 收到消息后，发送响应(Ack)信息给 Producer 出现网络异常等)时，消息在重试机制中，可能会被重复发送。
+- 消费端：Consumer先Pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以 RocketMQ 可以很好的支持此特性。
 
-## 6 回溯消费
+## 6 至多一次(At Most Once)
+- 生产端：Producer 的 `sendOneway` 方法，将消息发送给目标 `MessageQueue` 后，忽略 Broker 对发送结果的反馈，也不会有任何重试机制，所以单条消息的发送，可能会失败。","[{'comment': ""IMO **at-most-once delivery** means that message is **guaranteed** to be  delivered once or never to be delivered. In other words, any message won't to be delivered more than once.  You may refer to [akka doc](https://doc.akka.io/docs/akka/current/general/message-delivery-reliability.html?language=scala#discussion-what-does-at-most-once-mean-) or documents of other MQs for details.\r\nIt seems that it is not rigorous **at-most-once delivery** here, but just providing a mechanism for producer approaching to (but is not exactly) at-most-once delivery. \r\nShould it be more suitable as supplement to part 5 instead of an independent part describing at-most-once delivery?"", 'commenter': 'caigy'}]"
4146,docs/cn/features.md,"@@ -27,15 +27,22 @@ RocketMQ支持消息的高可靠，影响消息可靠性的几种情况：
 
 5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。注：RocketMQ从3.0版本开始支持同步双写。
 
-## 5 至少一次
-至少一次(At least Once)指每个消息必须投递一次。Consumer先Pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。
+## 5 至少一次(At Least Once)
+- 生产端：当消息发送给 Master Broker 后,如果同步给 Slave Broker 出现超时等异常(不限于这种情况,还有 Broker 收到消息后，发送响应(Ack)信息给 Producer 出现网络异常等)时，消息在重试机制中，可能会被重复发送。
+- 消费端：Consumer先Pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以 RocketMQ 可以很好的支持此特性。
 
-## 6 回溯消费
+## 6 至多一次(At Most Once)
+- 生产端：Producer 的 `sendOneway` 方法，将消息发送给目标 `MessageQueue` 后，忽略 Broker 对发送结果的反馈，也不会有任何重试机制，所以单条消息的发送，可能会失败。
+
+## 7 严格一次(Exactly Once)
+RocketMQ 不支持消息严格传输一次的特性。","[{'comment': 'Could you provide tips about how to handle duplicate messages? It would be more valuable to users.', 'commenter': 'caigy'}]"
4152,acl/src/main/java/org/apache/rocketmq/acl/AccessValidator.java,"@@ -71,7 +71,7 @@
      *
      * @return
      */
-    boolean updateGlobalWhiteAddrsConfig(List<String> globalWhiteAddrsList);
+    boolean updateGlobalWhiteAddrsConfig(List<String> globalWhiteAddrsList, String aclFileFullPath);
 ","[{'comment': '建议新增`default`接口以保持向前兼容，避免该修改成为重大变更/breaking change。而且两个方法分别对默认路径和指定路径进行更新、语义更加明确。\r\n```java\r\n   default boolean updateGlobalWhiteAddrsConfig(List<String> globalWhiteAddrsList, String aclFileFullPath) {\r\n        return updateGlobalWhiteAddrsConfig(globalWhiteAddrsList);\r\n    }\r\n```', 'commenter': 'dugenkui03'}, {'comment': '+1. Compatibility should be kept.', 'commenter': 'caigy'}]"
4152,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -466,11 +466,11 @@ public boolean deleteAccessConfig(String accesskey) {
         return false;
     }
 
-    public boolean updateGlobalWhiteAddrsConfig(List<String> globalWhiteAddrsList) {
-        return this.updateGlobalWhiteAddrsConfig(globalWhiteAddrsList, this.defaultAclFile);
-    }
-","[{'comment': 'It may be better to keep original implementation for compatibility.', 'commenter': 'caigy'}]"
4152,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -466,11 +466,11 @@ public boolean deleteAccessConfig(String accesskey) {
         return false;
     }
 
-    public boolean updateGlobalWhiteAddrsConfig(List<String> globalWhiteAddrsList) {
-        return this.updateGlobalWhiteAddrsConfig(globalWhiteAddrsList, this.defaultAclFile);
-    }
-
     public boolean updateGlobalWhiteAddrsConfig(List<String> globalWhiteAddrsList, String fileName) {
+        if (fileName == null) {","[{'comment': 'May `fileName` be empty string?', 'commenter': 'caigy'}]"
4152,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -482,6 +482,16 @@ public boolean updateGlobalWhiteAddrsConfig(List<String> globalWhiteAddrsList, S
             return false;
         }
 
+        if (!fileName.startsWith(fileHome)) {
+            log.error(""Parameter value "" + fileName + "" is not in the directory rocketmq.home.dir"");","[{'comment': 'Logging with the value of `rocketmq.home.dir` will be more clear.', 'commenter': 'caigy'}]"
4152,tools/src/main/java/org/apache/rocketmq/tools/admin/MQAdminExt.java,"@@ -77,7 +77,7 @@ void createAndUpdatePlainAccessConfig(final String addr, final PlainAccessConfig
     void deletePlainAccessConfig(final String addr, final String accessKey) throws RemotingException, MQBrokerException,
         InterruptedException, MQClientException;
 
-    void updateGlobalWhiteAddrConfig(final String addr, final String globalWhiteAddrs)throws RemotingException, MQBrokerException,
+    void updateGlobalWhiteAddrConfig(final String addr, final String globalWhiteAddrs, String aclFileFullPath)throws RemotingException, MQBrokerException,","[{'comment': 'It may be more appropriate to add a new method instead of changing its signature in an interface.', 'commenter': 'caigy'}]"
4152,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -471,6 +471,10 @@ public boolean updateGlobalWhiteAddrsConfig(List<String> globalWhiteAddrsList) {
     }
 
     public boolean updateGlobalWhiteAddrsConfig(List<String> globalWhiteAddrsList, String fileName) {
+        if (fileName == null || fileName == """") {","[{'comment': 'use `equals()` instead of `==` for comparison', 'commenter': 'caigy'}]"
4190,store/src/main/java/org/apache/rocketmq/store/schedule/ScheduleMessageService.java,"@@ -327,14 +326,18 @@ private MessageExtBrokerInner messageTimeup(MessageExt msgExt) {
         msgInner.setReconsumeTimes(msgExt.getReconsumeTimes());
 
         msgInner.setWaitStoreMsgOK(false);
-        MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_DELAY_TIME_LEVEL);
 
         msgInner.setTopic(msgInner.getProperty(MessageConst.PROPERTY_REAL_TOPIC));
 
         String queueIdStr = msgInner.getProperty(MessageConst.PROPERTY_REAL_QUEUE_ID);
         int queueId = Integer.parseInt(queueIdStr);
         msgInner.setQueueId(queueId);
 
+        MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_DELAY_TIME_LEVEL);
+        MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC);
+        MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID);
+        MessageAccessor.setProperties(msgInner, msgExt.getProperties());
+","[{'comment': 'It looks like you should clear the properties of msgExt and then set the properties in msgExt to msgInner', 'commenter': 'hzh0425'}, {'comment': 'ok, thanks', 'commenter': 'BurningCN'}]"
4190,store/src/main/java/org/apache/rocketmq/store/schedule/ScheduleMessageService.java,"@@ -327,14 +325,19 @@ private MessageExtBrokerInner messageTimeup(MessageExt msgExt) {
         msgInner.setReconsumeTimes(msgExt.getReconsumeTimes());
 
         msgInner.setWaitStoreMsgOK(false);
-        MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_DELAY_TIME_LEVEL);
 
-        msgInner.setTopic(msgInner.getProperty(MessageConst.PROPERTY_REAL_TOPIC));
+        msgInner.setTopic(msgExt.getProperty(MessageConst.PROPERTY_REAL_TOPIC));
 
-        String queueIdStr = msgInner.getProperty(MessageConst.PROPERTY_REAL_QUEUE_ID);
+        String queueIdStr = msgExt.getProperty(MessageConst.PROPERTY_REAL_QUEUE_ID);
         int queueId = Integer.parseInt(queueIdStr);
         msgInner.setQueueId(queueId);
 
+        MessageAccessor.clearProperty(msgExt, MessageConst.PROPERTY_DELAY_TIME_LEVEL);","[{'comment': ""As a good programming practice, I don't think the contents of the method argument msgExt should change.\r\nHere's my advice:\r\nMessageAccessor.setProperties(msgInner, msgExt.getProperties());\r\nMessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC);\r\n.......\r\nmsgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));"", 'commenter': 'lwclover'}, {'comment': ""> As a good programming practice, I don't think the contents of the method argument msgExt should change. Here's my advice: MessageAccessor.setProperties(msgInner, msgExt.getProperties()); MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC); ....... msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));\r\n\r\nthanks"", 'commenter': 'BurningCN'}]"
4208,example/src/main/java/org/apache/rocketmq/example/benchmark/BatchProducer.java,"@@ -360,17 +364,17 @@ public LongAdder getSendMessageFailedCount() {
 
     public void start() {
 
-        timer.scheduleAtFixedRate(new TimerTask() {
+        executorService.scheduleAtFixedRate(new TimerTask() {","[{'comment': 'It seems better to implement Runnable anonymously', 'commenter': 'lwclover'}, {'comment': 'The code can be more concise, such as using a lambda expression', 'commenter': 'cserwen'}, {'comment': 'Good idea', 'commenter': 'Oliverwqcwrw'}, {'comment': 'Ok', 'commenter': 'Oliverwqcwrw'}]"
4208,example/src/main/java/org/apache/rocketmq/example/benchmark/BatchProducer.java,"@@ -317,7 +320,8 @@ class StatsBenchmarkBatchProducer {
 
     private final LongAdder sendMessageFailedCount = new LongAdder();
 
-    private final Timer timer = new Timer(""BenchmarkTimerThread"", true);
+    private final ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(1,
+            new BasicThreadFactory.Builder().namingPattern(""BenchmarkTimerThread-%d"").daemon(true).build());","[{'comment': 'A unified style is recommended', 'commenter': 'lwclover'}, {'comment': ""Maybe it's better to use `ThreadFactoryImpl`, just like this:\r\nhttps://github.com/apache/rocketmq/blob/5d0102396031b728f9accfa5a562fe20906ac424/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java#L136"", 'commenter': 'cserwen'}, {'comment': 'Emmm, I prefer to like present way', 'commenter': 'Oliverwqcwrw'}, {'comment': ""I don't get your meaning,Can you provide more detail info"", 'commenter': 'Oliverwqcwrw'}, {'comment': 'same as @cserwen mentioned.', 'commenter': 'lwclover'}, {'comment': 'Ok,Thanks for your suggestions', 'commenter': 'Oliverwqcwrw'}]"
4208,example/src/main/java/org/apache/rocketmq/example/benchmark/BatchProducer.java,"@@ -317,7 +318,8 @@ class StatsBenchmarkBatchProducer {
 
     private final LongAdder sendMessageFailedCount = new LongAdder();
 
-    private final Timer timer = new Timer(""BenchmarkTimerThread"", true);
+    private final ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(
+            ""BenchmarkTimerThread""));","[{'comment': 'daemon thread', 'commenter': 'cserwen'}, {'comment': 'Thanks for your checking,I have solved it', 'commenter': 'Oliverwqcwrw'}]"
4208,example/src/main/java/org/apache/rocketmq/example/benchmark/BatchProducer.java,"@@ -317,7 +318,8 @@ class StatsBenchmarkBatchProducer {
 
     private final LongAdder sendMessageFailedCount = new LongAdder();
 
-    private final Timer timer = new Timer(""BenchmarkTimerThread"", true);
+    private final ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(
+            ""BenchmarkTimerThread"", Boolean.TRUE));","[{'comment': 'The indent here maybe wrong, pls import rmq_codeStyle.xml in style folder and reformat the code', 'commenter': 'HScarb'}, {'comment': 'AFAIK, if indent is wrong,the checking will not passing', 'commenter': 'Oliverwqcwrw'}]"
4268,namesrv/src/main/java/org/apache/rocketmq/namesrv/routeinfo/RouteInfoManager.java,"@@ -88,6 +88,36 @@ public void deleteTopic(final String topic) {
         }
     }
 
+    public void deleteTopic(final String topic, final String clusterName) {
+        try {
+            try {
+                this.lock.writeLock().lockInterruptibly();
+                Set<String> brokerNames = this.clusterAddrTable.get(clusterName);
+                if (brokerNames != null
+                    && !brokerNames.isEmpty()) {
+                    Map<String, QueueData> queueDataMap = this.topicQueueTable.get(topic);","[{'comment': 'QueueDataMap should have a non-null determination to avoid repeating requests and reporting exceptions a second time.', 'commenter': 'lwclover'}, {'comment': ""you're right!"", 'commenter': 'sunxi92'}]"
4268,namesrv/src/main/java/org/apache/rocketmq/namesrv/routeinfo/RouteInfoManager.java,"@@ -88,6 +88,36 @@ public void deleteTopic(final String topic) {
         }
     }
 
+    public void deleteTopic(final String topic, final String clusterName) {
+        try {
+            try {
+                this.lock.writeLock().lockInterruptibly();
+                Set<String> brokerNames = this.clusterAddrTable.get(clusterName);
+                if (brokerNames != null
+                    && !brokerNames.isEmpty()) {
+                    Map<String, QueueData> queueDataMap = this.topicQueueTable.get(topic);
+                    for (String brokerName : brokerNames) {
+                        final QueueData removedQD = queueDataMap.remove(brokerName);
+                        if (removedQD != null) {
+                            log.info(""deleteTopic, remove one broker's topic {} {} {}"", brokerName, topic,
+                                removedQD);
+                        }
+
+                        if (queueDataMap.isEmpty()) {","[{'comment': ""My personal recommendation is to put it outside of the for loop, so it's a little more logical."", 'commenter': 'lwclover'}, {'comment': ""> My personal recommendation is to put it outside of the for loop, so it's a little more logical.\r\n\r\n\r\ndone."", 'commenter': 'sunxi92'}]"
4268,namesrv/src/main/java/org/apache/rocketmq/namesrv/routeinfo/RouteInfoManager.java,"@@ -88,6 +88,36 @@ public void deleteTopic(final String topic) {
         }
     }
 
+    public void deleteTopic(final String topic, final String clusterName) {
+        try {
+            try {
+                this.lock.writeLock().lockInterruptibly();
+                Set<String> brokerNames = this.clusterAddrTable.get(clusterName);
+                if (brokerNames != null","[{'comment': ""if(brokerNames == null || brokerNames.isEmpty(){\r\nreturn;\r\n}\r\nPersonally, I suggest that the code looks less nested.\r\nYour code is fine, it's a personal habit. Haha"", 'commenter': 'lwclover'}]"
4295,README.md,"@@ -41,8 +41,8 @@ It offers a variety of features:
 * [RocketMQ Client Go](https://github.com/apache/rocketmq-client-go)
 * [RocketMQ Client Python](https://github.com/apache/rocketmq-client-python)
 * [RocketMQ Client Nodejs](https://github.com/apache/rocketmq-client-nodejs)
-* [RocketMQ Spring](https://github.com/apache/rocketmq-spring)
-* [RocketMQ Exporter](https://github.com/apache/rocketmq-exporter)
+* [RocketMQ Spring](https://github.com/apache/rocketmq-spring): The integration component of RocketMQ and spring framework","[{'comment': ""1. 'spring' should be 'Spring'. \r\n2. Accurately rocketmq-spring is starter of Spring Boot, not integration to Spring Framework itself.\r\n"", 'commenter': 'caigy'}]"
4295,broker/src/main/java/org/apache/rocketmq/broker/plugin/MessageStoreFactory.java,"@@ -22,7 +22,7 @@
 import org.apache.rocketmq.store.MessageStore;
 
 public final class MessageStoreFactory {
-    public final static MessageStore build(MessageStorePluginContext context, MessageStore messageStore)
+    public static MessageStore build(MessageStorePluginContext context, MessageStore messageStore)","[{'comment': 'It seems this change has nothing to do with the issue, you may open another issue to change it.', 'commenter': 'caigy'}]"
4295,README.md,"@@ -41,8 +41,8 @@ It offers a variety of features:
 * [RocketMQ Client Go](https://github.com/apache/rocketmq-client-go)
 * [RocketMQ Client Python](https://github.com/apache/rocketmq-client-python)
 * [RocketMQ Client Nodejs](https://github.com/apache/rocketmq-client-nodejs)
-* [RocketMQ Spring](https://github.com/apache/rocketmq-spring)
-* [RocketMQ Exporter](https://github.com/apache/rocketmq-exporter)
+* [RocketMQ Spring](https://github.com/apache/rocketmq-spring): A project which helps developers quickly integrate RpcketMQ with Spring Boot","[{'comment': ""Please fix typo 'R**p**cketMQ'"", 'commenter': 'caigy'}]"
4296,README.md,"@@ -37,18 +37,18 @@ It offers a variety of features:
 ## Apache RocketMQ Community
 * [RocketMQ Streams](https://github.com/apache/rocketmq-streams)
 * [RocketMQ Flink](https://github.com/apache/rocketmq-flink)
-* [RocketMQ Client CPP](https://github.com/apache/rocketmq-client-cpp)
-* [RocketMQ Client Go](https://github.com/apache/rocketmq-client-go)
+* [RocketMQ Client CPP](https://github.com/apache/rocketmq-client-cpp): RocketMQ CPP Client.
+* [RocketMQ Client Go](https://github.com/apache/rocketmq-client-go): RocketMQ Go Client.
 * [RocketMQ Client Python](https://github.com/apache/rocketmq-client-python)
 * [RocketMQ Client Nodejs](https://github.com/apache/rocketmq-client-nodejs)
 * [RocketMQ Spring](https://github.com/apache/rocketmq-spring)
 * [RocketMQ Exporter](https://github.com/apache/rocketmq-exporter)
-* [RocketMQ Operator](https://github.com/apache/rocketmq-operator)
-* [RocketMQ Docker](https://github.com/apache/rocketmq-docker)
+* [RocketMQ Operator](https://github.com/apache/rocketmq-operator): Provides a way to run an RocketMQ cluster on Kubernetes.
+* [RocketMQ Docker](https://github.com/apache/rocketmq-docker): The Git repo of the Docker Image for Apache RocketMQ.
 * [RocketMQ Dashboard](https://github.com/apache/rocketmq-dashboard)
 * [RocketMQ Connect](https://github.com/apache/rocketmq-connect)
-* [RocketMQ MQTT](https://github.com/apache/rocketmq-mqtt)
-* [RocketMQ Incubating Community Projects](https://github.com/apache/rocketmq-externals)
+* [RocketMQ MQTT](https://github.com/apache/rocketmq-mqtt): A new MQTT protocol architecture model, based on which RocketMQ can better support messages from terminals such as IoT devices and Mobile APP.
+* [RocketMQ Incubating Community Projects](https://github.com/apache/rocketmq-externals): Apache rocketmq is incubating the ecological project warehouse, including Spark, ES, Beats and other connectors.
 ","[{'comment': 'Have you discussed this practice with the community?', 'commenter': 'hzh0425'}]"
4296,README.md,"@@ -35,20 +35,21 @@ It offers a variety of features:
 
 ## Apache RocketMQ Community
 * [RocketMQ Streams](https://github.com/apache/rocketmq-streams): A lightweight stream computing engine based on RocketMQ.
-* [RocketMQ Flink](https://github.com/apache/rocketmq-flink): The RocketMQ connector of Flink that supports source and sink connector in data stream and Table. 
-* [RocketMQ Client CPP](https://github.com/apache/rocketmq-client-cpp)
-* [RocketMQ Client Go](https://github.com/apache/rocketmq-client-go)
+* [RocketMQ Flink](https://github.com/apache/rocketmq-flink): The RocketMQ connector of Flink that supports source and sink connector in data stream and Table.
+* [RocketMQ Client CPP](https://github.com/apache/rocketmq-client-cpp): RocketMQ CPP Client.
+* [RocketMQ Client Go](https://github.com/apache/rocketmq-client-go): RocketMQ Go Client.","[{'comment': 'Seems not more descriptive than the original ones. Maybe you can refer to corresponding projects for more specific description. ', 'commenter': 'caigy'}]"
4296,README.md,"@@ -35,20 +35,21 @@ It offers a variety of features:
 
 ## Apache RocketMQ Community
 * [RocketMQ Streams](https://github.com/apache/rocketmq-streams): A lightweight stream computing engine based on RocketMQ.
-* [RocketMQ Flink](https://github.com/apache/rocketmq-flink): The RocketMQ connector of Flink that supports source and sink connector in data stream and Table. 
-* [RocketMQ Client CPP](https://github.com/apache/rocketmq-client-cpp)
-* [RocketMQ Client Go](https://github.com/apache/rocketmq-client-go)
+* [RocketMQ Flink](https://github.com/apache/rocketmq-flink): The RocketMQ connector of Flink that supports source and sink connector in data stream and Table.
+* [RocketMQ Client CPP](https://github.com/apache/rocketmq-client-cpp): RocketMQ CPP Client.
+* [RocketMQ Client Go](https://github.com/apache/rocketmq-client-go): RocketMQ Go Client.
 * [RocketMQ Client Python](https://github.com/apache/rocketmq-client-python)
 * [RocketMQ Client Nodejs](https://github.com/apache/rocketmq-client-nodejs)
 * [RocketMQ Spring](https://github.com/apache/rocketmq-spring)
 * [RocketMQ Exporter](https://github.com/apache/rocketmq-exporter)
-* [RocketMQ Operator](https://github.com/apache/rocketmq-operator)
-* [RocketMQ Docker](https://github.com/apache/rocketmq-docker)
-* [RocketMQ Dashboard](https://github.com/apache/rocketmq-dashboard): Operation and maintenance console of RocketMQ
-* [RocketMQ Connect](https://github.com/apache/rocketmq-connect): A tool for scalably and reliably streaming data between Apache RocketMQ and other systems
-* [RocketMQ MQTT](https://github.com/apache/rocketmq-mqtt)
-* [RocketMQ Incubating Community Projects](https://github.com/apache/rocketmq-externals)
+* [RocketMQ Operator](https://github.com/apache/rocketmq-operator): Provides a way to run an RocketMQ cluster on Kubernetes.","[{'comment': '1. It seems `Providing` should be used instead of `Provides`.\r\n2. `an Apache RocketMQ cluster` is more appropriate. ', 'commenter': 'caigy'}]"
4296,README.md,"@@ -35,20 +35,21 @@ It offers a variety of features:
 
 ## Apache RocketMQ Community
 * [RocketMQ Streams](https://github.com/apache/rocketmq-streams): A lightweight stream computing engine based on RocketMQ.
-* [RocketMQ Flink](https://github.com/apache/rocketmq-flink): The RocketMQ connector of Flink that supports source and sink connector in data stream and Table. 
-* [RocketMQ Client CPP](https://github.com/apache/rocketmq-client-cpp)
-* [RocketMQ Client Go](https://github.com/apache/rocketmq-client-go)
+* [RocketMQ Flink](https://github.com/apache/rocketmq-flink): The RocketMQ connector of Flink that supports source and sink connector in data stream and Table.
+* [RocketMQ Client CPP](https://github.com/apache/rocketmq-client-cpp): RocketMQ CPP Client.
+* [RocketMQ Client Go](https://github.com/apache/rocketmq-client-go): RocketMQ Go Client.
 * [RocketMQ Client Python](https://github.com/apache/rocketmq-client-python)
 * [RocketMQ Client Nodejs](https://github.com/apache/rocketmq-client-nodejs)
 * [RocketMQ Spring](https://github.com/apache/rocketmq-spring)
 * [RocketMQ Exporter](https://github.com/apache/rocketmq-exporter)
-* [RocketMQ Operator](https://github.com/apache/rocketmq-operator)
-* [RocketMQ Docker](https://github.com/apache/rocketmq-docker)
-* [RocketMQ Dashboard](https://github.com/apache/rocketmq-dashboard): Operation and maintenance console of RocketMQ
-* [RocketMQ Connect](https://github.com/apache/rocketmq-connect): A tool for scalably and reliably streaming data between Apache RocketMQ and other systems
-* [RocketMQ MQTT](https://github.com/apache/rocketmq-mqtt)
-* [RocketMQ Incubating Community Projects](https://github.com/apache/rocketmq-externals)
+* [RocketMQ Operator](https://github.com/apache/rocketmq-operator): Provides a way to run an RocketMQ cluster on Kubernetes.
+* [RocketMQ Docker](https://github.com/apache/rocketmq-docker): The Git repo of the Docker Image for Apache RocketMQ.
+* [RocketMQ Dashboard](https://github.com/apache/rocketmq-dashboard): Operation and maintenance console of RocketMQ.
+* [RocketMQ Connect](https://github.com/apache/rocketmq-connect): A tool for scalably and reliably streaming data between Apache RocketMQ and other systems.
+* [RocketMQ MQTT](https://github.com/apache/rocketmq-mqtt): A new MQTT protocol architecture model, based on which RocketMQ can better support messages from terminals such as IoT devices and Mobile APP.
+* [RocketMQ Incubating Community Projects](https://github.com/apache/rocketmq-externals): Apache rocketmq is incubating the ecological project warehouse, including Spark, ES, Beats and other connectors.","[{'comment': ""1. Please use `Apache RocketMQ` for consistency.\r\n2. Could you please explain the meaning of 'warehouse' here? It is a bit confusing.\r\n3. rocketmq-externals is a repository for incubator projects related to Apache RocketMQ, not limited to connectors. "", 'commenter': 'caigy'}]"
4299,README.md,"@@ -39,8 +39,8 @@ It offers a variety of features:
 * [RocketMQ Flink](https://github.com/apache/rocketmq-flink)
 * [RocketMQ Client CPP](https://github.com/apache/rocketmq-client-cpp)
 * [RocketMQ Client Go](https://github.com/apache/rocketmq-client-go)
-* [RocketMQ Client Python](https://github.com/apache/rocketmq-client-python)
-* [RocketMQ Client Nodejs](https://github.com/apache/rocketmq-client-nodejs)
+* [RocketMQ Client Python：RocketMQ python 客户端](https://github.com/apache/rocketmq-client-python)","[{'comment': 'what the idea to modify it?', 'commenter': 'Oliverwqcwrw'}]"
4301,store/src/main/java/org/apache/rocketmq/store/MappedFile.java,"@@ -371,18 +371,18 @@ private boolean isAbleToFlush(final int flushLeastPages) {
     }
 
     protected boolean isAbleToCommit(final int commitLeastPages) {
-        int flush = this.committedPosition.get();
+        int commit = this.committedPosition.get();","[{'comment': 'I think `flush` is correct,This represents the offset of the flush without changing the variable name', 'commenter': 'Oliverwqcwrw'}, {'comment': 'Hi, thx for your review. But I believe the name ""commit"" would be more suitable for the usage of getting the previous committed position. Using ""flush"" may be confused here since this.flushedPosition.get() in isAbleToFlush() method is also named ""flush"" to represent getting the previous flushed position.', 'commenter': 'tsunghanjacktsai'}]"
4302,README.md,"@@ -34,6 +34,110 @@ It offers a variety of features:
 * Lightweight real-time computing
 ----------
 
+
+## Quick Start
+
+This paragraph guides you through steps of installing RocketMQ in different ways.
+For local development and testing, only one instance will be created for each component.
+
+### Run RocketMQ locally
+
+RocketMQ runs on all major operating systems and requires only a Java JDK version 8 or higher to be installed.
+To check, run `java -version`:
+```shell
+$ java -version
+java version ""1.8.0_121""
+```
+
+Download the latest RocketMQ release from the Apache mirror:
+```shell
+$ wget https://archive.apache.org/dist/rocketmq/4.9.3/rocketmq-all-4.9.3-bin-release.zip
+```
+
+Unpack the release:
+```shell
+$ unzip rocketmq-all-4.9.3-bin-release.zip
+$ cd rocketmq-all-4.9.3-bin-release","[{'comment': ""You'd better not use static version (4.9.3) here."", 'commenter': 'caigy'}, {'comment': ""> You'd better not use static version (4.9.3) here.\r\n\r\nThat‘s what I think, but I didn't find a common method to express the release url of the latest version in Apache mirror."", 'commenter': 'gobbq'}, {'comment': 'ye', 'commenter': 'token01'}]"
4302,README.md,"@@ -34,6 +34,110 @@ It offers a variety of features:
 * Lightweight real-time computing
 ----------
 
+
+## Quick Start
+
+This paragraph guides you through steps of installing RocketMQ in different ways.
+For local development and testing, only one instance will be created for each component.
+
+### Run RocketMQ locally","[{'comment': 'Hope that quick start guides for Windows would be supplemented.', 'commenter': 'caigy'}, {'comment': '> Hope that quick start guides for Windows would be supplemented.\r\n\r\nOK，this is done in the latest commit.', 'commenter': 'gobbq'}]"
4303,README.md,"@@ -39,8 +39,8 @@ It offers a variety of features:
 * [RocketMQ Flink](https://github.com/apache/rocketmq-flink)
 * [RocketMQ Client CPP](https://github.com/apache/rocketmq-client-cpp)
 * [RocketMQ Client Go](https://github.com/apache/rocketmq-client-go)
-* [RocketMQ Client Python](https://github.com/apache/rocketmq-client-python)
-* [RocketMQ Client Nodejs](https://github.com/apache/rocketmq-client-nodejs)
+* [RocketMQ Client Python：RocketMQ python client](https://github.com/apache/rocketmq-client-python)","[{'comment': ""I don't think we need to add this"", 'commenter': 'li-xiao-shuang'}, {'comment': '+1', 'commenter': 'cserwen'}]"
4348,example/src/main/java/org/apache/rocketmq/example/ordermessage/Producer.java,"@@ -19,35 +19,38 @@
 import org.apache.rocketmq.client.exception.MQBrokerException;
 import org.apache.rocketmq.client.exception.MQClientException;
 import org.apache.rocketmq.client.producer.DefaultMQProducer;
-import org.apache.rocketmq.client.producer.MessageQueueSelector;
 import org.apache.rocketmq.client.producer.SendResult;
 import org.apache.rocketmq.common.message.Message;
-import org.apache.rocketmq.common.message.MessageQueue;
 import org.apache.rocketmq.remoting.common.RemotingHelper;
 import org.apache.rocketmq.remoting.exception.RemotingException;
 
 import java.io.UnsupportedEncodingException;
-import java.util.List;
 
 public class Producer {
+
+    public static final String PRODUCER_GROUP = ""please_rename_unique_group_name"";
+    public static final String DEFAULT_NAMESRVADDR = ""127.0.0.1:9876"";
+    public static final String TOPIC = ""TopicTest"";
+    public static final int MESSAGE_COUNT = 100;
+
     public static void main(String[] args) throws UnsupportedEncodingException {
         try {
-            DefaultMQProducer producer = new DefaultMQProducer(""please_rename_unique_group_name"");
+            DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP);
+
+            // If the debugging source code can open comments, you need to set the namesrvAddr to the address of the local namesrvAddr
+//            producer.setNamesrvAddr(DEFAULT_NAMESRVADDR);","[{'comment': '```suggestion\r\n          //  producer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\r\n```\r\nMy obsessive compulsive disorder', 'commenter': 'Oliverwqcwrw'}, {'comment': 'This is the normal format', 'commenter': 'li-xiao-shuang'}]"
4348,example/src/main/java/org/apache/rocketmq/example/ordermessage/Consumer.java,"@@ -28,12 +28,19 @@
 
 public class Consumer {
 
+    public static final String CONSUMER_GROUP = ""please_rename_unique_group_name_3"";
+    public static final String DEFAULT_NAMESRVADDR = ""127.0.0.1:9876"";
+    public static final String TOPIC = ""TopicTest"";
+    public static final String SUB_EXPRESSION = ""TagA || TagC || TagD"";
+
     public static void main(String[] args) throws MQClientException {
-        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(""please_rename_unique_group_name_3"");
+        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
 
+        // If the debugging source code can open comments, you need to set the namesrvAddr to the address of the local namesrvAddr
+//        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);","[{'comment': '```suggestion\r\n      //  consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\r\n```\r\nMy obsessive compulsive disorder', 'commenter': 'Oliverwqcwrw'}]"
4354,example/src/main/java/org/apache/rocketmq/example/transaction/TransactionProducer.java,"@@ -26,32 +26,38 @@
 import java.io.UnsupportedEncodingException;
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
 public class TransactionProducer {
+
+    public static final String PRODUCER_GROUP = ""please_rename_unique_group_name"";
+    public static final String DEFAULT_NAMESRVADDR = ""127.0.0.1:9876"";
+    public static final String TOPIC = ""TopicTest1234"";
+
+    public static final int MESSAGE_COUNT = 10;
+
     public static void main(String[] args) throws MQClientException, InterruptedException {
         TransactionListener transactionListener = new TransactionListenerImpl();
-        TransactionMQProducer producer = new TransactionMQProducer(""please_rename_unique_group_name"");
-        ExecutorService executorService = new ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(2000), new ThreadFactory() {
-            @Override
-            public Thread newThread(Runnable r) {
-                Thread thread = new Thread(r);
-                thread.setName(""client-transaction-msg-check-thread"");
-                return thread;
-            }
+        TransactionMQProducer producer = new TransactionMQProducer(PRODUCER_GROUP);
+
+        // If the debugging source code can open comments, you need to set the namesrvAddr to the address of the local namesrvAddr","[{'comment': 'Hi, LGTM overall. Maybe you could try to rephrase this instruction into ""Uncomment the following line while debugging, namesrvAddr should be set to your local address"".', 'commenter': 'tsunghanjacktsai'}, {'comment': ""Sorry, it doesn't seem like you have made a change before resolving this conversation. Could you maybe try to rephrase a bit of this instruction? That would make this more perfect. Appreciate it. @li-xiao-shuang "", 'commenter': 'tsunghanjacktsai'}, {'comment': ""> Sorry, it doesn't seem like you have made a change before resolving this conversation. Could you maybe try to rephrase a bit of this instruction? That would make this more perfect. Appreciate it. @li-xiao-shuang\r\n\r\nok"", 'commenter': 'li-xiao-shuang'}]"
4366,common/src/main/java/org/apache/rocketmq/common/MixAll.java,"@@ -87,6 +87,8 @@ public class MixAll {
     public static final String REPLY_MESSAGE_FLAG = ""reply"";
     public static final String LMQ_PREFIX = ""%LMQ%"";
     public static final String MULTI_DISPATCH_QUEUE_SPLITTER = "","";
+    public static final String MULTI_SEPARATE = ""//"";
+    public static final String SEPARATE_DOT = ""/."";","[{'comment': 'IMO, maybe someone use hide file as acl config file. BTW, can we use regular expression to check whether acl config file path is legal or not, instead of changing file path?', 'commenter': 'lizhiboo'}, {'comment': '1. i can only judge the last 2 char \r\n2.  what you describe  is when acl config file path is illegal( contain “//” or “ /.” ) ,throw AclException directly?  ', 'commenter': 'fulln'}]"
4376,store/src/main/java/org/apache/rocketmq/store/index/IndexHeader.java,"@@ -22,12 +22,12 @@
 
 public class IndexHeader {
     public static final int INDEX_HEADER_SIZE = 40;
-    private static int beginTimestampIndex = 0;
-    private static int endTimestampIndex = 8;
-    private static int beginPhyoffsetIndex = 16;
-    private static int endPhyoffsetIndex = 24;
-    private static int hashSlotcountIndex = 32;
-    private static int indexCountIndex = 36;
+    private static final int beginTimestampIndex = 0;
+    private static final int endTimestampIndex = 8;
+    private static final int beginPhyoffsetIndex = 16;
+    private static final int endPhyoffsetIndex = 24;
+    private static final int hashSlotcountIndex = 32;
+    private static final int indexCountIndex = 36;","[{'comment': ""This will not pass the ci format check, so it's better not to change it"", 'commenter': 'hzh0425'}]"
4387,docs/en/Configuration_TLS.md,"@@ -0,0 +1,123 @@
+# TLS Configuration
+This section introduce TLS configuration in Rocket MQ.","[{'comment': 'Please remove the blank space between ""Rocket MQ"".', 'commenter': 'tsunghanjacktsai'}, {'comment': 'Updated.\r\nThanks.', 'commenter': 'chris-joys'}]"
4387,docs/en/Configuration_TLS.md,"@@ -0,0 +1,123 @@
+# TLS Configuration
+This section introduce TLS configuration in Rocket MQ.
+
+## 1 Generate Certification Files
+User can generate certification files using OpenSSL. Suggested to gengerate files in Linux.","[{'comment': '> Suggested to gengerate files in Linux.\r\n\r\nCorrect the spelling mistakes in ""gengerate"".', 'commenter': 'tsunghanjacktsai'}, {'comment': 'Updated.\r\nThanks.', 'commenter': 'chris-joys'}]"
4387,docs/en/Configuration_TLS.md,"@@ -0,0 +1,123 @@
+# TLS Configuration
+This section introduce TLS configuration in Rocket MQ.
+
+## 1 Generate Certification Files
+User can generate certification files using OpenSSL. Suggested to gengerate files in Linux.
+
+### 1.1 Generate ca.pem
+```shell
+openssl req -newkey rsa:2048 -keyout ca_rsa_private.pem -x509 -days 365 -out ca.pem
+```
+### 1.2 Generate server.csr
+```shell
+openssl req -newkey rsa:2048 -keyout server_rsa.key  -out server.csr
+```
+### 1.3 Generate server.pem
+```shell
+openssl x509 -req -days 365 -in server.csr -CA ca.pem -CAkey ca_rsa_private.pem -CAcreateserial -out server.pem
+```
+### 1.4 Generate client.csr
+```shell
+openssl req -newkey rsa:2048 -keyout client_rsa.key -out client.csr
+```
+### 1.5 Generate client.pem
+```shell
+openssl x509 -req -days 365 -in client.csr -CA ca.pem -CAkey ca_rsa_private.pem -CAcreateserial -out client.pem
+```
+### 1.6 Generate server.key
+```shell
+openssl pkcs8 -topk8 -v1 PBE-SHA1-RC4-128 -in  server_rsa.key -out server.key
+```
+### 1.7 Generateclient.key
+```shell
+openssl pkcs8 -topk8 -v1 PBE-SHA1-RC4-128 -in client_rsa.key -out client.key
+```
+
+## 2 Create tls.properties
+Create tls.properties，correctly configure the path and password of the generated certificates.
+
+```properties
+# The flag to determine whether use test mode when initialize TLS context. default is true
+tls.test.mode.enable=false                     
+# Indicates how SSL engine respect to client authentication, default is none
+tls.server.need.client.auth=require   
+# The store path of server-side private key
+tls.server.keyPath=/opt/certFiles/server.key
+# The password of the server-side private key
+tls.server.keyPassword=123456
+# The store path of server-side X.509 certificate chain in PEM format
+tls.server.certPath=/opt/certFiles/server.pem
+# To determine whether verify the client endpoint's certificate strictly. default is false
+tls.server.authClient=false
+# The store path of trusted certificates for verifying the client endpoint's certificate
+tls.server.trustCertPath=/opt/certFiles/ca.pem
+```
+
+If you need to authenticate the client connection, you also need to add the following content to the file.
+
+```properties
+# The store path of client-side private key 
+tls.client.keyPath=/opt/certFiles/client.key
+# The password of the client-side private key
+tls.client.keyPassword=123456
+# The store path of client-side X.509 certificate chain in PEM format
+tls.client.certPath=/opt/certFiles/client.pem
+# To determine whether verify the server endpoint's certificate strictly
+tls.client.authServer=false                    
+# The store path of trusted certificates for verifying the server endpoint's certificate
+tls.client.trustCertPath=/opt/certFiles/ca.pem
+```
+
+
+## 3 Update Rocketmq JVM parameters
+
+Edit the configuration file under the rocketmq/bin path to make tls.properties configurations takes effect.","[{'comment': '> make tls.properties configurations takes effect.\r\n\r\n""takes"" should be ""take"".', 'commenter': 'tsunghanjacktsai'}, {'comment': 'Updated.\r\nThanks.', 'commenter': 'chris-joys'}]"
4390,common/src/test/java/org/apache/rocketmq/common/UtilAllTest.java,"@@ -60,11 +60,17 @@ public void testProperties2String() {
         demoConfig.setDemoWidth(456);
         demoConfig.setDemoName(""TestDemo"");
         demoConfig.setDemoOK(true);
+        demoConfig.setDemoByte((byte) 78);
+        demoConfig.setDemoShort((short) 90);
+        demoConfig.setDemoChar('c');
         Properties properties = MixAll.object2Properties(demoConfig);
         assertThat(properties.getProperty(""demoLength"")).isEqualTo(""123"");
         assertThat(properties.getProperty(""demoWidth"")).isEqualTo(""456"");
         assertThat(properties.getProperty(""demoOK"")).isEqualTo(""true"");","[{'comment': 'you have modified properties2Object,  but test object2Properties method?', 'commenter': 'xiaoyifang'}]"
4453,client/src/main/java/org/apache/rocketmq/client/consumer/store/RemoteBrokerOffsetStore.java,"@@ -82,9 +82,8 @@ public long readOffset(final MessageQueue mq, final ReadOffsetType type) {
                     AtomicLong offset = this.offsetTable.get(mq);
                     if (offset != null) {
                         return offset.get();
-                    } else if (ReadOffsetType.READ_FROM_MEMORY == type) {
-                        return -1;","[{'comment': 'offset  will be got from remote broker if it was got failed in local offset table in MEMORY_FIRST_THEN_STORE model.\r\nJust return -1 in READ_FROM_MEMORY model.', 'commenter': 'ShannonDing'}]"
4467,store/src/test/java/org/apache/rocketmq/store/ha/HAServerTest.java,"@@ -193,10 +193,10 @@ public void putRequest_SingleAck() throws IOException, ExecutionException, Inter
 
     @Test
     public void putRequest_MultipleAckAndRequests() throws IOException, ExecutionException, InterruptedException {
-        CommitLog.GroupCommitRequest oneAck = new CommitLog.GroupCommitRequest(124, 4000,1);
+        CommitLog.GroupCommitRequest oneAck = new CommitLog.GroupCommitRequest(124, 4000,2);
         this.haService.putRequest(oneAck);","[{'comment': ""It's better format to (124, 4000, 2)"", 'commenter': 'hzh0425'}]"
4467,store/src/test/java/org/apache/rocketmq/store/ha/HAServerTest.java,"@@ -213,7 +213,7 @@ public void putRequest_MultipleAckAndRequests() throws IOException, ExecutionExc
         doReturn(128L).when(messageStore).getMasterFlushedOffset();
         setUpOneHAClient(messageStore);
 
-        twoAck = new CommitLog.GroupCommitRequest(124, 4000,2);
+        twoAck = new CommitLog.GroupCommitRequest(124, 4000,3);","[{'comment': 'ditto', 'commenter': 'hzh0425'}]"
4467,store/src/main/java/org/apache/rocketmq/store/CommitLog.java,"@@ -803,13 +802,18 @@ public CompletableFuture<PutMessageResult> asyncPutMessage(final MessageExtBroke
         boolean needHandleHA = needHandleHA(msg);
         int needAckNums = 1;
 
-        if (needHandleHA && !this.defaultMessageStore.getMessageStoreConfig().isAllAckInSyncStateSet()) {
-            int inSyncReplicas = Math.min(this.defaultMessageStore.getAliveReplicaNumInGroup(),
-                this.defaultMessageStore.getHaService().inSyncSlaveNums(currOffset) + 1);
-            needAckNums = calcNeedAckNums(inSyncReplicas);
-            if (needAckNums > inSyncReplicas) {
-                // Tell the producer, don't have enough slaves to handle the send request
-                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.IN_SYNC_REPLICAS_NOT_ENOUGH, null));
+        if (needHandleHA) {
+            if (this.defaultMessageStore.getBrokerConfig().isEnableControllerMode() && this.defaultMessageStore.getMessageStoreConfig().isAllAckInSyncStateSet()) {
+                // -1 means all ack in SyncStateSet
+                needAckNums = -1;","[{'comment': 'It may be better to define `-1` as a meaningful constant.', 'commenter': 'caigy'}, {'comment': 'done', 'commenter': 'RongtongJin'}]"
4467,common/src/main/java/org/apache/rocketmq/common/MixAll.java,"@@ -77,6 +77,7 @@ public class MixAll {
     public static final long FIRST_SLAVE_ID = 1L;
     public static final long CURRENT_JVM_PID = getPID();
     public final static int UNIT_PRE_SIZE_FOR_MSG = 28;
+    public final static int ALL_ACK_IN_SYNC_STATE_SET_NUM = -1;","[{'comment': ""Would better just name it in ALL_ACK_IN_SYNC_STATE_SET without NUM since it's only a constant status. Adding NUM seems a bit weird IMO."", 'commenter': 'tsunghanjacktsai'}]"
4477,broker/src/test/java/org/apache/rocketmq/broker/transaction/queue/TransactionEscapeBridgeTest.java,"@@ -0,0 +1,13 @@
+package org.apache.rocketmq.broker.transaction.queue;
+
+import org.junit.Ignore;
+
+/**
+ * @author zhaozhenhang <zhaozhenhang@kuaishou.com>
+ * Created on 2022-06-18
+ */","[{'comment': ""Don't leave author info"", 'commenter': 'hzh0425'}]"
4477,broker/src/test/java/org/apache/rocketmq/broker/transaction/queue/TransactionEscapeBridgeTest.java,"@@ -0,0 +1,13 @@
+package org.apache.rocketmq.broker.transaction.queue;","[{'comment': 'need apache Licence if add new class', 'commenter': 'hzh0425'}]"
4477,broker/src/main/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageServiceImpl.java,"@@ -354,7 +358,13 @@ private PutMessageResult putBackToHalfQueueReturnResult(MessageExt messageExt) {
         PutMessageResult putMessageResult = null;
         try {
             MessageExtBrokerInner msgInner = transactionalMessageBridge.renewHalfMessageInner(messageExt);
-            putMessageResult = transactionalMessageBridge.putMessageReturnResult(msgInner);
+            if (this.transactionalMessageBridge.getBrokerController().isSpecialServiceRunning()
+                    && BrokerRole.SLAVE == this.transactionalMessageBridge.getBrokerController().getMessageStoreConfig()
+                    .getBrokerRole()) {
+                putMessageResult = transactionalMessageBridge.getBrokerController().getEscapeBridge().putMessage(msgInner);
+            } else {
+                putMessageResult = transactionalMessageBridge.putMessageReturnResult(msgInner);
+            }","[{'comment': 'If retry times of the half message reached maximum value, the broker where it escaped would not check it any more, and the broker it was born also had skipped it, that message would be lost.', 'commenter': 'caigy'}, {'comment': 'The transactionmessageserviceimpl#putbacktohalfqueuereturnresult() method needs to rewrite the half message. Here,I think we have to rewrite the topic. I understand that this step should also be carried out by escaping to other masters', 'commenter': 'azhsmesos'}]"
4488,tools/src/main/java/org/apache/rocketmq/tools/admin/DefaultMQAdminExtImpl.java,"@@ -320,8 +321,18 @@ public ConsumeStats examineConsumeStats(String consumerGroup,
         }
 
         if (result.getOffsetTable().isEmpty()) {
-            throw new MQClientException(ResponseCode.CONSUMER_NOT_ONLINE,
-                ""Not found the consumer group consume stats, because return offset table is empty, maybe the consumer not consume any message"");
+            ConsumerConnection connection;
+            try {
+                connection = this.examineConsumerConnectionInfo(consumerGroup);
+            } catch (Exception e) {
+                throw new MQClientException(ResponseCode.CONSUMER_NOT_ONLINE,
+                    ""Not found the consumer group consume stats, because return offset table is empty, maybe the consumer not online"");
+            }
+
+            if (connection.getMessageModel().equals(MessageModel.BROADCASTING)) {
+                throw new MQClientException(ResponseCode.CONSUME_BROADCASTING,
+                    ""Not found the consumer group consume stats, because return offset table is empty, the consumer using in broadcast model"");","[{'comment': 'Hi @zhangjidi2016 ,\r\n\r\nThx for your contribution.\r\n\r\nPlease rephrase the ""the consumer using in broadcast model"" into ""the consumer is under the broadcast mode"". A good exception message would make us more perfect :-)', 'commenter': 'tsunghanjacktsai'}]"
4488,common/src/main/java/org/apache/rocketmq/common/protocol/ResponseCode.java,"@@ -80,4 +80,6 @@ public class ResponseCode extends RemotingSysResponseCode {
 
     public static final int UPDATE_GLOBAL_WHITE_ADDRS_CONFIG_FAILED = 211;
 
+    public static final int CONSUME_BROADCASTING = 212;","[{'comment': '""BROADCAST_CONSUMPTION"" should be better.', 'commenter': 'tsunghanjacktsai'}, {'comment': ""Good suggestion. I'll change it later"", 'commenter': 'zhangjidi2016'}]"
4498,client/src/main/java/org/apache/rocketmq/client/Validators.java,"@@ -107,4 +110,19 @@ public static void isNotAllowedSendTopic(String topic) throws MQClientException
         }
     }
 
+    public static void checkTopicConfig(final TopicConfig topicConfig) throws MQClientException {
+        if (!PermName.isValid(topicConfig.getPerm())) {
+            throw new MQClientException(ResponseCode.NO_PERMISSION,
+                String.format(""brokerPermission value: %s is invalid."", topicConfig.getPerm()));","[{'comment': '`brokerPermission value` should be `topicPermisson value`, and  is more accurate', 'commenter': 'Oliverwqcwrw'}]"
4498,client/src/test/java/org/apache/rocketmq/client/ValidatorsTest.java,"@@ -106,4 +110,63 @@ public void testIsNotAllowedSendTopic() {
             }
         }
     }
+
+    @Test
+    public void testTopicConfigValid() throws MQClientException {
+        TopicConfig topicConfig = new TopicConfig();
+        topicConfig.setPerm(PermName.PERM_INHERIT | PermName.PERM_WRITE | PermName.PERM_READ);
+        Validators.checkTopicConfig(topicConfig);
+
+        topicConfig.setPerm(PermName.PERM_WRITE | PermName.PERM_READ);
+        Validators.checkTopicConfig(topicConfig);
+
+        topicConfig.setPerm(PermName.PERM_READ);
+        Validators.checkTopicConfig(topicConfig);
+
+        try {
+            topicConfig.setPerm(PermName.PERM_PRIORITY);
+            Validators.checkTopicConfig(topicConfig);
+        } catch (MQClientException e) {
+            assertThat(e.getResponseCode()).isEqualTo(ResponseCode.NO_PERMISSION);
+            assertThat(e.getErrorMessage()).isEqualTo(String.format(""brokerPermission value: %s is invalid."", topicConfig.getPerm()));","[{'comment': '`brokerPermission value` should be `topicPermisson value`, and is more accurate', 'commenter': 'Oliverwqcwrw'}]"
4498,client/src/test/java/org/apache/rocketmq/client/ValidatorsTest.java,"@@ -106,4 +110,63 @@ public void testIsNotAllowedSendTopic() {
             }
         }
     }
+
+    @Test
+    public void testTopicConfigValid() throws MQClientException {
+        TopicConfig topicConfig = new TopicConfig();
+        topicConfig.setPerm(PermName.PERM_INHERIT | PermName.PERM_WRITE | PermName.PERM_READ);
+        Validators.checkTopicConfig(topicConfig);
+
+        topicConfig.setPerm(PermName.PERM_WRITE | PermName.PERM_READ);
+        Validators.checkTopicConfig(topicConfig);
+
+        topicConfig.setPerm(PermName.PERM_READ);
+        Validators.checkTopicConfig(topicConfig);
+
+        try {
+            topicConfig.setPerm(PermName.PERM_PRIORITY);
+            Validators.checkTopicConfig(topicConfig);
+        } catch (MQClientException e) {
+            assertThat(e.getResponseCode()).isEqualTo(ResponseCode.NO_PERMISSION);
+            assertThat(e.getErrorMessage()).isEqualTo(String.format(""brokerPermission value: %s is invalid."", topicConfig.getPerm()));
+        }
+
+        try {
+            topicConfig.setPerm(PermName.PERM_PRIORITY | PermName.PERM_WRITE);
+            Validators.checkTopicConfig(topicConfig);
+        } catch (MQClientException e) {
+            assertThat(e.getResponseCode()).isEqualTo(ResponseCode.NO_PERMISSION);
+            assertThat(e.getErrorMessage()).isEqualTo(String.format(""brokerPermission value: %s is invalid."", topicConfig.getPerm()));","[{'comment': '`brokerPermission value` should be `topicPermisson value`, and is more accurate', 'commenter': 'Oliverwqcwrw'}]"
4500,test/src/test/java/org/apache/rocketmq/test/statictopic/StaticTopicIT.java,"@@ -117,7 +116,7 @@ public void testCommandsWithBrokers() throws Exception {
         {
             Set<String> brokers = ImmutableSet.of(broker2Name);
             MQAdminTestUtils.remappingStaticTopicWithCommand(topic, brokers, null, nsAddr);
-            Thread.sleep(500);","[{'comment': 'Fix the magic number, please.', 'commenter': 'lizhanhui'}, {'comment': 'done', 'commenter': 'dongeforever'}]"
4500,test/src/test/java/org/apache/rocketmq/test/statictopic/StaticTopicIT.java,"@@ -340,7 +340,7 @@ public void testDoubleReadCheckConsumerOffset() throws Exception {
             sendMessagesAndCheck(producer, targetBrokers, topic, queueNum, msgEachQueue, (i + 1) * TopicQueueMappingUtils.DEFAULT_BLOCK_SEQ_SIZE);
         }
 
-        TestUtils.waitForSeconds(20);","[{'comment': 'Same here', 'commenter': 'lizhanhui'}, {'comment': 'done', 'commenter': 'dongeforever'}]"
4523,store/src/test/java/org/apache/rocketmq/store/dledger/DLedgerMultiPathTest.java,"@@ -46,8 +46,8 @@ public void multiDirsStorageTest() throws Exception {
             DefaultMessageStore dLedgerStore = createDLedgerMessageStore(base, group, ""n0"", peers, multiStorePath, null);
             Thread.sleep(2000);
             doPutMessages(dLedgerStore, topic, 0, 1000, 0);
-            Assert.assertEquals(11, dLedgerStore.getMaxPhyOffset()/dLedgerStore.getMessageStoreConfig().getMappedFileSizeCommitLog());
             Thread.sleep(500);
+            Assert.assertEquals(11, dLedgerStore.getMaxPhyOffset()/dLedgerStore.getMessageStoreConfig().getMappedFileSizeCommitLog());","[{'comment': 'Nice change here. I guess this is something that causes our CI to fail sometimes. Hope it works. How about making this a separate PR so that we could maybe merge it faster?', 'commenter': 'tsunghanjacktsai'}, {'comment': ""> Nice change here. I guess this is something that causes our CI to fail sometimes. Hope it works. How about making this a separate PR so that we could maybe merge it faster?\r\n\r\n@tsunghanjacktsai  Good suggestion, I'll deal with it later."", 'commenter': 'cserwen'}]"
4523,namesrv/src/main/java/org/apache/rocketmq/namesrv/processor/DefaultRequestProcessor.java,"@@ -240,6 +240,13 @@ public RemotingCommand registerBrokerWithFilterServer(ChannelHandlerContext ctx,
             registerBrokerBody.getFilterServerList(),
             ctx.channel());
 
+        if (result == null) {","[{'comment': 'The `result` seems can not null, it is initialized in first line, please correct me if I understand error\r\n\r\n> public RegisterBrokerResult registerBroker(\r\n            final String clusterName,\r\n            final String brokerAddr,\r\n            final String brokerName,\r\n            final long brokerId,\r\n            final String haServerAddr,\r\n            final TopicConfigSerializeWrapper topicConfigWrapper,\r\n            final List<String> filterServerList,\r\n            final Channel channel) {\r\n        RegisterBrokerResult result = new RegisterBrokerResult();\r\n        try {\r\n            try {\r\n                this.lock.writeLock().lockInterruptibly();', 'commenter': 'Oliverwqcwrw'}, {'comment': '```java\r\nif (topicConfigWrapper.getTopicConfigTable().size() == 1) {\r\n    log.warn(""Can\'t register topicConfigWrapper={} because broker={} has not registered."", topicConfigWrapper, brokerName);\r\n    return null; \r\n}\r\n```\r\n\r\n`null` is returned directly. @Oliverwqcwrw ', 'commenter': 'cserwen'}, {'comment': ""ok, I didn't notice you added this piece of code, thanks for your reply"", 'commenter': 'Oliverwqcwrw'}]"
4523,namesrv/src/main/java/org/apache/rocketmq/namesrv/routeinfo/RouteInfoManager.java,"@@ -156,6 +156,10 @@ public RegisterBrokerResult registerBroker(
 
                 BrokerData brokerData = this.brokerAddrTable.get(brokerName);
                 if (null == brokerData) {
+                    if (topicConfigWrapper.getTopicConfigTable().size() == 1) {","[{'comment': 'I think it is better to judge Greater than or equal to 1, `topicConfigTable` maybe greater than 1 when batch send message', 'commenter': 'Oliverwqcwrw'}, {'comment': ""I think this has nothing to do with sending messages. This is just when a topic is created, the broker will register the topic's routing information with namesrv, and it will only be 1. When the broker is fully registered, the size must be greater than 1, because the number of system topics has exceeded 1, right?"", 'commenter': 'cserwen'}, {'comment': 'Besides, If the judgment is greater than or equal to 1, it will be impossible to distinguish the full registration of the Broker from the registration which the topic is created', 'commenter': 'cserwen'}, {'comment': 'Are you primarily trying to solve the problem of not being able to create a topic before first registering the broker', 'commenter': 'Oliverwqcwrw'}, {'comment': ""> Are you primarily trying to solve the problem of not being able to create a topic before first registering the broker\r\n\r\nI describe the current problem in detail in the issue. If someone creates a topic before the broker first registers with a new namesrv, the broker's first registration will fail. The registration can only be completed when the data version of TopicConfigManager is changed.\r\n"", 'commenter': 'cserwen'}, {'comment': 'Ok, I get it , Thanks for your reply', 'commenter': 'Oliverwqcwrw'}]"
4551,tools/src/main/java/org/apache/rocketmq/tools/command/acl/GetAccessConfigSubCommand.java,"@@ -52,20 +52,19 @@ public class GetAccessConfigSubCommand implements SubCommand {
     @Override public Options buildCommandlineOptions(Options options) {
         OptionGroup optionGroup = new OptionGroup();
 
-        Option opt = new Option(""b"", ""brokerAddr"", true, ""query acl config version for which broker"");
+        Option opt = new Option(""b"", ""brokerAddr"", true, ""query acl config for which broker"");","[{'comment': 'Pls help us change the description to ""query acl config for specified broker"" to make it more formal and consistent with the clusterName one.', 'commenter': 'tsunghanjacktsai'}]"
4551,tools/src/main/java/org/apache/rocketmq/tools/command/acl/GetAccessConfigSubCommand.java,"@@ -116,8 +115,6 @@ private void printClusterBaseInfo(
                     field.setAccessible(true);
                     if (field.get(config) != null) {
                         System.out.printf(""%-1s %-18s: %s\n"", """", field.getName(), field.get(config).toString());
-                    } else {","[{'comment': ""I believe leaving it blank makes sense and would not affect its meaning. Do you think it's really necessary to remove it?"", 'commenter': 'tsunghanjacktsai'}]"
4556,example/src/main/java/org/apache/rocketmq/example/filter/SqlFilterConsumer.java,"@@ -17,33 +17,26 @@
 
 package org.apache.rocketmq.example.filter;
 
-import java.util.List;
 import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
 import org.apache.rocketmq.client.consumer.MessageSelector;
-import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;
 import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
 import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
-import org.apache.rocketmq.common.message.MessageExt;
 
 public class SqlFilterConsumer {
+    public static final String CONSUMER_GROUP = ""please_rename_unique_group_name"";
+    public static final String TOPIC = ""SqlFilterTest"";
 
     public static void main(String[] args) throws Exception {
 
-        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(""please_rename_unique_group_name"");
+        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
 
         // Don't forget to set enablePropertyFilter=true in broker
-        consumer.subscribe(""SqlFilterTest"",
-            MessageSelector.bySql(""(TAGS is not null and TAGS in ('TagA', 'TagB'))"" +
+        consumer.subscribe(TOPIC, MessageSelector.bySql(""(TAGS is not null and TAGS in ('TagA', 'TagB'))"" +
                 ""and (a is not null and a between 0 and 3)""));
 
-        consumer.registerMessageListener(new MessageListenerConcurrently() {
-
-            @Override
-            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
-                ConsumeConcurrentlyContext context) {
-                System.out.printf(""%s Receive New Messages: %s %n"", Thread.currentThread().getName(), msgs);
-                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
-            }
+        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {
+            System.out.printf(""%s Receive New Messages: %s %n"", Thread.currentThread().getName(), msgs);
+            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;","[{'comment': 'Clients should still be compatible with JDK6.', 'commenter': 'caigy'}]"
4562,client/src/main/java/org/apache/rocketmq/client/impl/producer/DefaultMQProducerImpl.java,"@@ -671,8 +676,18 @@ private SendResult sendDefaultImpl(
     private TopicPublishInfo tryToFindTopicPublishInfo(final String topic) {
         TopicPublishInfo topicPublishInfo = this.topicPublishInfoTable.get(topic);
         if (null == topicPublishInfo || !topicPublishInfo.ok()) {
-            this.topicPublishInfoTable.putIfAbsent(topic, new TopicPublishInfo());
-            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);
+            try {
+                if(lockUpdatePublishInfo.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)){","[{'comment': 'IMO, add a new lock before lockNamesrv.tryLock do not make effect. We can check topic route info exists or not again after lockNamesrv.tryLock success to avoid redundant getRouteInfoByTopic.', 'commenter': 'lizhiboo'}, {'comment': '> IMO, add a new lock before lockNamesrv.tryLock do not make effect. We can check topic route info exists or not again after lockNamesrv.tryLock success to avoid redundant getRouteInfoByTopic.\r\n\r\nThank you very much for your reply, but there is such a scenario, the producer during startup, will be intervals of 30 s updated routing information, if add the calibration topicRouter exists within updateTopicRouteInfoFromNameServer method, It may cause topicRouter not to update in time, so I tried to put the lock on a higher level method', 'commenter': 'zhaowenshuai011'}, {'comment': ""We can add a parameter isEmpty2FetchFromNamesrv in mQClientFactory.updateTopicRouteInfoFromNameServer method. if isEmpty2FetchFromNamesrv is true, and double-check topic route info is also empty after tryLock, then update from namesrv. if isEmpty2FetchFromNamesrv is false, and double-check topic route info is not empty after tryLock, then do not update from namesrv. MQClientInstance's scheduled task will update topic route info reguarly."", 'commenter': 'lizhiboo'}, {'comment': ""It's a good idea, I'll try to optimize it"", 'commenter': 'zhaowenshuai011'}]"
4562,client/src/main/java/org/apache/rocketmq/client/impl/producer/DefaultMQProducerImpl.java,"@@ -671,8 +676,18 @@ private SendResult sendDefaultImpl(
     private TopicPublishInfo tryToFindTopicPublishInfo(final String topic) {
         TopicPublishInfo topicPublishInfo = this.topicPublishInfoTable.get(topic);
         if (null == topicPublishInfo || !topicPublishInfo.ok()) {
-            this.topicPublishInfoTable.putIfAbsent(topic, new TopicPublishInfo());
-            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);
+            try {","[{'comment': ""Add a double-check for this topicRoute, if there's existed topicRoute, return it directly, and it seems that we don't need to add another lock"", 'commenter': 'duhenglucky'}]"
4562,client/src/main/java/org/apache/rocketmq/client/impl/factory/MQClientInstance.java,"@@ -603,11 +607,14 @@ private void uploadFilterClassSource() {
         }
     }
 
-    public boolean updateTopicRouteInfoFromNameServer(final String topic, boolean isDefault,
+    public boolean updateTopicRouteInfoFromNameServer(final String topic, boolean isDefault, boolean isEmpty2FetchFromNameServer,","[{'comment': 'IMO, in this merge request, parameter isEmpty2FetchFromNameServer can be replaced by force2FetchFromNameServer that means update topic route info from namesrv directly whether client already have topic info or not. If still using parameter isEmpty2FetchFromNameServer, its value will be reversed.', 'commenter': 'lizhiboo'}]"
4582,broker/src/main/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageServiceImpl.java,"@@ -431,7 +431,7 @@ private MessageQueue getOpQueue(MessageQueue messageQueue) {
         if (opQueue == null) {
             opQueue = new MessageQueue(TransactionalMessageUtil.buildOpTopic(), messageQueue.getBrokerName(),
                 messageQueue.getQueueId());
-            opQueueMap.put(messageQueue, opQueue);
+            opQueueMap.putIfAbsent(messageQueue, opQueue);","[{'comment': 'It seems that if `opQueueMap` contains `messageQueue`, the newly created `opQueue` would not be put in `opQueueMap` but returned.', 'commenter': 'caigy'}, {'comment': 'Thank you for reminding me', 'commenter': 'Oliverwqcwrw'}]"
4590,logging/src/main/java/org/apache/rocketmq/logging/inner/LoggingBuilder.java,"@@ -708,17 +708,30 @@ public synchronized void setFile(String fileName, boolean append, boolean buffer
                     throw ex;
                 }
             }
-            Writer fw = createWriter(ostream);
-            if (bufferedIO) {
-                fw = new BufferedWriter(fw, bufferSize);
+            Writer fw = null;
+            try {
+                fw = createWriter(ostream);
+                if (bufferedIO) {
+                    fw = new BufferedWriter(fw, bufferSize);
+                }
+                this.setQWForFiles(fw);
+                this.fileName = fileName;
+                this.fileAppend = append;
+                this.bufferedIO = bufferedIO;
+                this.bufferSize = bufferSize;
+                writeHeader();
+                SysLogger.debug(""setFile ended"");
+            } catch (Exception e) {
+                throw e;
+            } finally {
+                if (ostream != null) {
+                    ostream.close();
+                }
+                if (fw != null) {","[{'comment': 'The osstream and fw is referenced by the qwWriter, which will be released via coseFile().', 'commenter': 'dongeforever'}, {'comment': 'the ostream and fw cannot be closed here, otherwise, the logger appender will fail to write the log.', 'commenter': 'dongeforever'}, {'comment': 'it is better to reproduce the issue and add some tests.', 'commenter': 'dongeforever'}, {'comment': 'Thank you very much for your advice\r\n\r\nI tried it and did get an error when printing logs asynchronously, so I turned off pr for now', 'commenter': 'Oliverwqcwrw'}]"
4615,client/src/main/java/org/apache/rocketmq/client/consumer/store/RemoteBrokerOffsetStore.java,"@@ -213,6 +213,7 @@ public void updateConsumeOffsetToBroker(MessageQueue mq, long offset, boolean is
             requestHeader.setConsumerGroup(this.groupName);
             requestHeader.setQueueId(mq.getQueueId());
             requestHeader.setCommitOffset(offset);
+            requestHeader.setBname(mq.getBrokerName());","[{'comment': 'Hi @drpmma ,\r\n\r\nWhy not just simply name it ""brokerName"" instead of ""bname"" to make it more straightforward? I felt confused for a second after I saw your description haha.', 'commenter': 'tsunghanjacktsai'}, {'comment': 'The `bname` is not in the scope of this pr, see b6ff649291453d3dc2d702fbba1548d991b610ac for more information.\r\n\r\nI guess `bname` is shorter than `brokerName` thus it is more efficient in tranport.', 'commenter': 'drpmma'}, {'comment': ""@drpmma Oh, okay. That's reasonable."", 'commenter': 'tsunghanjacktsai'}]"
4635,namesrv/src/main/java/org/apache/rocketmq/namesrv/processor/DefaultRequestProcessor.java,"@@ -88,51 +89,51 @@ public RemotingCommand processRequest(ChannelHandlerContext ctx,
 
         switch (request.getCode()) {
             case RequestCode.PUT_KV_CONFIG:
-                return this.putKVConfig(ctx, request);","[{'comment': 'IMO, It may be better to use a uniform signature for these methods, the contents here may be also used later.', 'commenter': 'ltamber'}, {'comment': 'but five years have passed since last modification\r\n![image](https://user-images.githubusercontent.com/16064908/179887642-085f7e67-6d16-4d3f-b99e-a28bd7658e03.png)\r\n![image](https://user-images.githubusercontent.com/16064908/179887667-7870320f-971c-4f6e-93f8-482bb88d7d94.png)\r\n', 'commenter': 'PansonPanson'}, {'comment': '> IMO, It may be better to use a uniform signature for these methods, the contents here may be also used later.\r\n\r\nfile rolled back ', 'commenter': 'PansonPanson'}]"
4637,acl/src/test/java/org/apache/rocketmq/acl/plain/PlainPermissionManagerTest.java,"@@ -45,6 +54,8 @@ public class PlainPermissionManagerTest {
     PlainAccessConfig plainAccessConfig = new PlainAccessConfig();
     Set<Integer> adminCode = new HashSet<>();
 
+    private static final String PATH = ""src/test/resources"";","[{'comment': 'Why not load test resources from classpath? It is a much more idiomatic', 'commenter': 'lizhanhui'}, {'comment': 'I also think so!It is a much more idiomatic!', 'commenter': 'zongtanghu'}, {'comment': 'Thanks  for your review, I have  solved it', 'commenter': 'Oliverwqcwrw'}]"
4637,acl/src/test/java/org/apache/rocketmq/acl/plain/PlainPermissionManagerTest.java,"@@ -20,20 +20,29 @@
 import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import org.apache.commons.lang3.reflect.FieldUtils;
+import org.apache.rocketmq.acl.common.AclConstants;
 import org.apache.rocketmq.acl.common.AclException;
 import org.apache.rocketmq.acl.common.AclUtils;
 import org.apache.rocketmq.acl.common.Permission;
+import org.apache.rocketmq.common.AclConfig;
+import org.apache.rocketmq.common.DataVersion;
 import org.apache.rocketmq.common.PlainAccessConfig;
+import org.assertj.core.api.Assertions;
 import org.assertj.core.util.Lists;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
+import static org.apache.rocketmq.acl.plain.PlainAccessControlFlowTest.DEFAULT_TOPIC;","[{'comment': 'IMO this test is independent of `PlainAccessControlFlowTest`, you can maintain default topic of this test.', 'commenter': 'caigy'}]"
4637,acl/src/test/java/org/apache/rocketmq/acl/plain/PlainPermissionManagerTest.java,"@@ -325,4 +336,77 @@ public void updateAccessConfigTest() {
         plainAccessConfig.setTopicPerms(Lists.newArrayList(""topicA=SUB""));
         plainPermissionManager.updateAccessConfig(plainAccessConfig);
     }
+
+    @Test
+    public void getAllAclFilesTest() {
+        final List<String> notExistList = plainPermissionManager.getAllAclFiles(""aa/bb"");
+        Assertions.assertThat(notExistList).isEmpty();
+        final List<String> files = plainPermissionManager.getAllAclFiles(PATH);
+        Assertions.assertThat(files).isNotEmpty();
+    }
+
+    @Test
+    public void loadTest() {
+        plainPermissionManager.load();
+        final Map<String, DataVersion> map = plainPermissionManager.getDataVersionMap();
+        Assertions.assertThat(map).isNotEmpty();
+    }
+
+    @Test
+    public void updateAclConfigFileVersionTest() {
+        String aclFileName = ""test_plain_acl"";
+        Map<String, Object> updateAclConfigMap  = new HashMap<>();
+        List<Map<String, Object>> versionElement = new ArrayList<>();
+        Map<String, Object> accountsMap = new LinkedHashMap<>();
+        accountsMap.put(AclConstants.CONFIG_COUNTER, 1);
+        accountsMap.put(AclConstants.CONFIG_TIME_STAMP, System.currentTimeMillis());
+        versionElement.add(accountsMap);
+
+        updateAclConfigMap.put(AclConstants.CONFIG_DATA_VERSION, versionElement);
+        final Map<String, Object> map = plainPermissionManager.updateAclConfigFileVersion(aclFileName, updateAclConfigMap);
+        Assertions.assertThat(map).isNotEmpty();","[{'comment': 'It would be better to check actual data version is correct or not.', 'commenter': 'caigy'}]"
4637,acl/src/test/java/org/apache/rocketmq/acl/plain/PlainPermissionManagerTest.java,"@@ -325,4 +336,77 @@ public void updateAccessConfigTest() {
         plainAccessConfig.setTopicPerms(Lists.newArrayList(""topicA=SUB""));
         plainPermissionManager.updateAccessConfig(plainAccessConfig);
     }
+
+    @Test
+    public void getAllAclFilesTest() {
+        final List<String> notExistList = plainPermissionManager.getAllAclFiles(""aa/bb"");
+        Assertions.assertThat(notExistList).isEmpty();
+        final List<String> files = plainPermissionManager.getAllAclFiles(PATH);
+        Assertions.assertThat(files).isNotEmpty();
+    }
+
+    @Test
+    public void loadTest() {
+        plainPermissionManager.load();
+        final Map<String, DataVersion> map = plainPermissionManager.getDataVersionMap();
+        Assertions.assertThat(map).isNotEmpty();
+    }
+
+    @Test
+    public void updateAclConfigFileVersionTest() {
+        String aclFileName = ""test_plain_acl"";
+        Map<String, Object> updateAclConfigMap  = new HashMap<>();
+        List<Map<String, Object>> versionElement = new ArrayList<>();
+        Map<String, Object> accountsMap = new LinkedHashMap<>();
+        accountsMap.put(AclConstants.CONFIG_COUNTER, 1);
+        accountsMap.put(AclConstants.CONFIG_TIME_STAMP, System.currentTimeMillis());
+        versionElement.add(accountsMap);
+
+        updateAclConfigMap.put(AclConstants.CONFIG_DATA_VERSION, versionElement);
+        final Map<String, Object> map = plainPermissionManager.updateAclConfigFileVersion(aclFileName, updateAclConfigMap);
+        Assertions.assertThat(map).isNotEmpty();
+    }
+
+    @Test
+    public void createAclAccessConfigMapTest() {
+        Map<String, Object> existedAccountMap =  new HashMap<>();
+        plainAccessConfig.setAccessKey(""admin123"");
+        plainAccessConfig.setSecretKey(""12345678"");
+        plainAccessConfig.setWhiteRemoteAddress(""192.168.1.1"");
+        plainAccessConfig.setAdmin(false);
+        plainAccessConfig.setDefaultGroupPerm(AclConstants.SUB_PUB);
+        plainAccessConfig.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + ""="" + AclConstants.PUB));
+        plainAccessConfig.setGroupPerms(Lists.newArrayList(""groupA=SUB""));
+
+        final Map<String, Object> map = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);
+        Assertions.assertThat(map).isNotEmpty();","[{'comment': ""You'd better add more checks on `map`."", 'commenter': 'caigy'}]"
4637,acl/src/test/java/org/apache/rocketmq/acl/plain/PlainPermissionManagerTest.java,"@@ -325,4 +336,77 @@ public void updateAccessConfigTest() {
         plainAccessConfig.setTopicPerms(Lists.newArrayList(""topicA=SUB""));
         plainPermissionManager.updateAccessConfig(plainAccessConfig);
     }
+
+    @Test
+    public void getAllAclFilesTest() {
+        final List<String> notExistList = plainPermissionManager.getAllAclFiles(""aa/bb"");
+        Assertions.assertThat(notExistList).isEmpty();
+        final List<String> files = plainPermissionManager.getAllAclFiles(PATH);
+        Assertions.assertThat(files).isNotEmpty();
+    }
+
+    @Test
+    public void loadTest() {
+        plainPermissionManager.load();
+        final Map<String, DataVersion> map = plainPermissionManager.getDataVersionMap();
+        Assertions.assertThat(map).isNotEmpty();
+    }
+
+    @Test
+    public void updateAclConfigFileVersionTest() {
+        String aclFileName = ""test_plain_acl"";
+        Map<String, Object> updateAclConfigMap  = new HashMap<>();
+        List<Map<String, Object>> versionElement = new ArrayList<>();
+        Map<String, Object> accountsMap = new LinkedHashMap<>();
+        accountsMap.put(AclConstants.CONFIG_COUNTER, 1);
+        accountsMap.put(AclConstants.CONFIG_TIME_STAMP, System.currentTimeMillis());
+        versionElement.add(accountsMap);
+
+        updateAclConfigMap.put(AclConstants.CONFIG_DATA_VERSION, versionElement);
+        final Map<String, Object> map = plainPermissionManager.updateAclConfigFileVersion(aclFileName, updateAclConfigMap);
+        Assertions.assertThat(map).isNotEmpty();
+    }
+
+    @Test
+    public void createAclAccessConfigMapTest() {
+        Map<String, Object> existedAccountMap =  new HashMap<>();
+        plainAccessConfig.setAccessKey(""admin123"");
+        plainAccessConfig.setSecretKey(""12345678"");
+        plainAccessConfig.setWhiteRemoteAddress(""192.168.1.1"");
+        plainAccessConfig.setAdmin(false);
+        plainAccessConfig.setDefaultGroupPerm(AclConstants.SUB_PUB);
+        plainAccessConfig.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + ""="" + AclConstants.PUB));
+        plainAccessConfig.setGroupPerms(Lists.newArrayList(""groupA=SUB""));
+
+        final Map<String, Object> map = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);
+        Assertions.assertThat(map).isNotEmpty();
+    }
+
+    @Test
+    public void deleteAccessConfigTest() {
+        // delete not exist accessConfig
+        final boolean flag1 = plainPermissionManager.deleteAccessConfig(""admin123"");
+        assert flag1 == false;
+        //delete existed accessConfig
+        final AclConfig config = plainPermissionManager.getAllAclConfig();
+        final List<PlainAccessConfig> configs = config.getPlainAccessConfigs();
+        final PlainAccessConfig config1 = configs.get(0);
+        final String accessKey = config1.getAccessKey();
+        final boolean flag2 = plainPermissionManager.deleteAccessConfig(accessKey);","[{'comment': 'It may cause side effects if `PlainAccessConfig` is changed but not restored.', 'commenter': 'caigy'}]"
4637,acl/src/test/java/org/apache/rocketmq/acl/plain/PlainPermissionManagerTest.java,"@@ -325,4 +336,77 @@ public void updateAccessConfigTest() {
         plainAccessConfig.setTopicPerms(Lists.newArrayList(""topicA=SUB""));
         plainPermissionManager.updateAccessConfig(plainAccessConfig);
     }
+
+    @Test
+    public void getAllAclFilesTest() {
+        final List<String> notExistList = plainPermissionManager.getAllAclFiles(""aa/bb"");
+        Assertions.assertThat(notExistList).isEmpty();
+        final List<String> files = plainPermissionManager.getAllAclFiles(PATH);
+        Assertions.assertThat(files).isNotEmpty();
+    }
+
+    @Test
+    public void loadTest() {
+        plainPermissionManager.load();
+        final Map<String, DataVersion> map = plainPermissionManager.getDataVersionMap();
+        Assertions.assertThat(map).isNotEmpty();
+    }
+
+    @Test
+    public void updateAclConfigFileVersionTest() {
+        String aclFileName = ""test_plain_acl"";
+        Map<String, Object> updateAclConfigMap  = new HashMap<>();
+        List<Map<String, Object>> versionElement = new ArrayList<>();
+        Map<String, Object> accountsMap = new LinkedHashMap<>();
+        accountsMap.put(AclConstants.CONFIG_COUNTER, 1);
+        accountsMap.put(AclConstants.CONFIG_TIME_STAMP, System.currentTimeMillis());
+        versionElement.add(accountsMap);
+
+        updateAclConfigMap.put(AclConstants.CONFIG_DATA_VERSION, versionElement);
+        final Map<String, Object> map = plainPermissionManager.updateAclConfigFileVersion(aclFileName, updateAclConfigMap);
+        Assertions.assertThat(map).isNotEmpty();
+    }
+
+    @Test
+    public void createAclAccessConfigMapTest() {
+        Map<String, Object> existedAccountMap =  new HashMap<>();
+        plainAccessConfig.setAccessKey(""admin123"");
+        plainAccessConfig.setSecretKey(""12345678"");
+        plainAccessConfig.setWhiteRemoteAddress(""192.168.1.1"");
+        plainAccessConfig.setAdmin(false);
+        plainAccessConfig.setDefaultGroupPerm(AclConstants.SUB_PUB);
+        plainAccessConfig.setTopicPerms(Arrays.asList(DEFAULT_TOPIC + ""="" + AclConstants.PUB));
+        plainAccessConfig.setGroupPerms(Lists.newArrayList(""groupA=SUB""));
+
+        final Map<String, Object> map = plainPermissionManager.createAclAccessConfigMap(existedAccountMap, plainAccessConfig);
+        Assertions.assertThat(map).isNotEmpty();
+    }
+
+    @Test
+    public void deleteAccessConfigTest() {
+        // delete not exist accessConfig
+        final boolean flag1 = plainPermissionManager.deleteAccessConfig(""admin123"");
+        assert flag1 == false;
+        //delete existed accessConfig
+        final AclConfig config = plainPermissionManager.getAllAclConfig();
+        final List<PlainAccessConfig> configs = config.getPlainAccessConfigs();
+        final PlainAccessConfig config1 = configs.get(0);
+        final String accessKey = config1.getAccessKey();
+        final boolean flag2 = plainPermissionManager.deleteAccessConfig(accessKey);
+        assert flag2 == true;
+
+    }
+
+    @Test
+    public void updateGlobalWhiteAddrsConfigTest() {
+        final boolean flag = plainPermissionManager.updateGlobalWhiteAddrsConfig(Lists.newArrayList(""192.168.1.2""));
+        assert flag == true;","[{'comment': 'You may check the actual content of global white lists.', 'commenter': 'caigy'}]"
4637,acl/src/test/java/org/apache/rocketmq/acl/plain/PlainPermissionManagerTest.java,"@@ -247,7 +259,7 @@ public void multiFilePathTest() {
 
     @Test
     public void testWatch() throws IOException, IllegalAccessException, InterruptedException {
-        File file = new File(""src/test/resources"");
+        File file = new File(PATH);
         System.setProperty(""rocketmq.home.dir"", file.getAbsolutePath());
 
         String fileName = System.getProperty(""rocketmq.home.dir"") + File.separator + ""/conf/acl/plain_acl_test.yml"";","[{'comment': 'This line will not be compatible with Windows', 'commenter': 'lizhanhui'}, {'comment': 'Thank you for your advice\r\n\r\nI have changed to it as follows\r\n\r\n`private static final String PATH = PlainPermissionManagerTest.class.getResource(File.separator).getFile();`', 'commenter': 'Oliverwqcwrw'}]"
4637,common/src/main/java/org/apache/rocketmq/common/PlainAccessConfig.java,"@@ -99,4 +99,18 @@ public List<String> getGroupPerms() {
     public void setGroupPerms(List<String> groupPerms) {
         this.groupPerms = groupPerms;
     }
+
+    @Override
+    public String toString() {
+        return ""PlainAccessConfig{"" +","[{'comment': 'It is awkward and error-prone to manually concatenate strings. Why not use JSON.toJsonString(this)?\r\n\r\nAnother thing, it would be better to omit the access secret part for safety reasons.', 'commenter': 'lizhanhui'}, {'comment': ""This toString is generated automatically by the editor I'm using, but for security reasons I've omitted the printing of SecretKey\r\n"", 'commenter': 'Oliverwqcwrw'}]"
4655,broker/src/main/java/org/apache/rocketmq/broker/schedule/ScheduleMessageService.java,"@@ -398,7 +398,12 @@ public void run() {
             } catch (Exception e) {
                 // XXX: warn and notify me
                 log.error(""ScheduleMessageService, executeOnTimeup exception"", e);
-                this.scheduleNextTimerTask(this.offset, DELAY_FOR_A_PERIOD);
+                try {
+                    // Wait for a period of time if an error has occurred.
+                    TimeUnit.MILLISECONDS.sleep(DELAY_FOR_A_PERIOD);
+                } catch (InterruptedException ignored) {
+                    // ignored","[{'comment': 'it is better print the log here, although the process may not come here.', 'commenter': 'ShannonDing'}]"
4655,broker/src/main/java/org/apache/rocketmq/broker/schedule/ScheduleMessageService.java,"@@ -398,7 +398,12 @@ public void run() {
             } catch (Exception e) {
                 // XXX: warn and notify me
                 log.error(""ScheduleMessageService, executeOnTimeup exception"", e);
-                this.scheduleNextTimerTask(this.offset, DELAY_FOR_A_PERIOD);
+                try {
+                    // Wait for a period of time if an error has occurred.
+                    TimeUnit.MILLISECONDS.sleep(DELAY_FOR_A_PERIOD);
+                } catch (InterruptedException ex) {
+                    log.error(""ScheduleMessageService, an error occurred while waiting"", ex);","[{'comment': 'IMO interrupted flag should be restored (`Thread.currentThread().interrupt()`) after  `InterruptedException` is thrown. ', 'commenter': 'caigy'}]"
4659,tools/src/main/java/org/apache/rocketmq/tools/command/acl/GetAccessConfigSubCommand.java,"@@ -52,10 +52,10 @@ public class GetAccessConfigSubCommand implements SubCommand {
     @Override public Options buildCommandlineOptions(Options options) {
         OptionGroup optionGroup = new OptionGroup();
 
-        Option opt = new Option(""b"", ""brokerAddr"", true, ""query acl config version for which broker"");
+        Option opt = new Option(""b"", ""brokerAddr"", true, ""query acl config for which broker"");","[{'comment': 'Hi @meateggmilk ,\r\n\r\nPlease help us correct the description into ""query acl config for specified cluster"" to align with the -c option. Thx.', 'commenter': 'tsunghanjacktsai'}, {'comment': 'ok, done it', 'commenter': 'zhiliatom'}]"
4661,common/src/main/java/org/apache/rocketmq/common/Configuration.java,"@@ -219,6 +221,35 @@ public void persist() {
         }
     }
 
+    public void persistBrokerConf(Properties from) {
+        FileReader reader = null;
+        try {
+            readWriteLock.readLock().lockInterruptibly();
+            String fileName = this.getStorePath();
+            File file = new File(fileName);
+            if (!file.exists()) {
+                file.createNewFile();
+            }
+            Properties properties = new Properties();
+            reader = new FileReader(fileName);
+            properties.load(reader);
+            merge(from, properties);
+            final String str = MixAll.properties2String(properties);
+            MixAll.string2File(str, fileName);
+        } catch (Exception e) {
+            log.error(""persist brokerConf error"", e);
+        } finally {
+            readWriteLock.readLock().unlock();
+            if (reader != null) {
+                try {
+                    reader.close();
+                } catch (IOException e) {
+                    log.error(""Close FileReader occur error"", e);","[{'comment': 'unable to close FileReader', 'commenter': 'tsunghanjacktsai'}, {'comment': 'Thanks for your review, I have solved it', 'commenter': 'Oliverwqcwrw'}]"
4661,common/src/main/java/org/apache/rocketmq/common/Configuration.java,"@@ -219,6 +224,35 @@ public void persist() {
         }
     }
 
+    public void persistBrokerConf(Properties from) {
+        BufferedReader reader = null;
+        try {
+            readWriteLock.readLock().lockInterruptibly();
+            String fileName = this.getStorePath();
+            File file = new File(fileName);
+            if (!file.exists()) {
+                file.createNewFile();
+            }
+            Properties properties = new Properties();
+            reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8));
+            properties.load(reader);
+            merge(from, properties);
+            final String str = MixAll.properties2String(properties);
+            MixAll.string2File(str, fileName);
+        } catch (Exception e) {
+            log.error(""persist brokerConf error"", e);","[{'comment': 'Maybe when an exception is thrown, we also need to close the reader?', 'commenter': 'kaori-seasons'}, {'comment': 'Thanks for your review,i will fix it ', 'commenter': 'Oliverwqcwrw'}]"
4661,common/src/main/java/org/apache/rocketmq/common/Configuration.java,"@@ -219,6 +224,35 @@ public void persist() {
         }
     }
 
+    public void persistBrokerConf(Properties from) {
+        BufferedReader reader = null;
+        try {
+            readWriteLock.readLock().lockInterruptibly();","[{'comment': 'The following inline method already exists in getAllConfigsFormatString Is it possible to take the relevant logic?', 'commenter': 'kaori-seasons'}]"
4674,client/src/main/java/org/apache/rocketmq/client/impl/producer/TopicPublishInfo.java,"@@ -69,19 +69,18 @@ public void setHaveTopicRouterInfo(boolean haveTopicRouterInfo) {
     public MessageQueue selectOneMessageQueue(final String lastBrokerName) {
         if (lastBrokerName == null) {
             return selectOneMessageQueue();
-        } else {
-            for (int i = 0; i < this.messageQueueList.size(); i++) {
-                int index = this.sendWhichQueue.incrementAndGet();
-                int pos = Math.abs(index) % this.messageQueueList.size();
-                if (pos < 0)
-                    pos = 0;
-                MessageQueue mq = this.messageQueueList.get(pos);
-                if (!mq.getBrokerName().equals(lastBrokerName)) {
-                    return mq;
-                }
+        } 
+        for (int i = 0; i < this.messageQueueList.size(); i++) {
+            int index = this.sendWhichQueue.incrementAndGet();
+            int pos = Math.abs(index) % this.messageQueueList.size();
+            if (pos < 0)
+                pos = 0;","[{'comment': '```suggestion\r\n            if (pos < 0) {\r\n                pos = 0;\r\n            }\r\n```', 'commenter': 'aaron-ai'}]"
4768,controller/src/main/java/org/apache/rocketmq/controller/ControllerManager.java,"@@ -91,6 +91,12 @@ protected <T> RunnableFuture<T> newTaskFor(final Runnable runnable, final T valu
             }
         };
         this.heartbeatManager = new DefaultBrokerHeartbeatManager(this.controllerConfig);
+        if (StringUtils.isEmpty(this.controllerConfig.getControllerDLegerPeers())) {
+            throw new IllegalArgumentException(""Attribute value controllerDLegerPeers of ControllerConfig is null"");
+        }
+        if(StringUtils.isEmpty(this.controllerConfig.getControllerDLegerSelfId())){
+            throw new IllegalArgumentException(""Attribute value controllerDLegerSelfId of ControllerConfig is null"");","[{'comment': ""'is null or empty' may be more accurate."", 'commenter': 'caigy'}, {'comment': ""> 'is null or empty' may be more accurate.\r\n\r\nOK I will modify it"", 'commenter': 'mxsm'}]"
4775,client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultLitePullConsumerImpl.java,"@@ -531,6 +533,17 @@ public synchronized void assign(Collection<MessageQueue> messageQueues) {
         }
     }
 
+    public synchronized void setSubExpression4Assgin(final String topic, final String subExpression) {
+        if (subExpression == null || """".equals(subExpression)) {","[{'comment': 'StringUtils.isEmpty  is suggested.', 'commenter': 'ShannonDing'}]"
4775,client/src/main/java/org/apache/rocketmq/client/consumer/DefaultLitePullConsumer.java,"@@ -271,6 +271,11 @@ public void assign(Collection<MessageQueue> messageQueues) {
         defaultLitePullConsumerImpl.assign(queuesWithNamespace(messageQueues));
     }
 
+    @Override
+    public void setSubExpression4Assgin(final String topic, final String subExpresion) {
+        defaultLitePullConsumerImpl.setSubExpression4Assgin(topic, subExpresion);","[{'comment': 'need to consider name space.', 'commenter': 'ShannonDing'}]"
4775,client/src/main/java/org/apache/rocketmq/client/consumer/DefaultLitePullConsumer.java,"@@ -271,6 +271,11 @@ public void assign(Collection<MessageQueue> messageQueues) {
         defaultLitePullConsumerImpl.assign(queuesWithNamespace(messageQueues));
     }
 
+    @Override
+    public void setSubExpression4Assgin(final String topic, final String subExpresion) {","[{'comment': '`setSubExpression4Assgin` -> `setSubExpression4Assign`', 'commenter': 'tsunghanjacktsai'}]"
4775,client/src/main/java/org/apache/rocketmq/client/consumer/DefaultLitePullConsumer.java,"@@ -271,6 +271,11 @@ public void assign(Collection<MessageQueue> messageQueues) {
         defaultLitePullConsumerImpl.assign(queuesWithNamespace(messageQueues));
     }
 
+    @Override
+    public void setSubExpression4Assign(final String topic, final String subExpresion) {","[{'comment': 'Naming is inconsistent with the existing style', 'commenter': 'lizhanhui'}, {'comment': 'do u have any suggestion for this naming?', 'commenter': 'lizhiboo'}, {'comment': 'Use full words to make it easy to follow. No non-standard, obscure, abbreviations. ', 'commenter': 'lizhanhui'}]"
4775,client/src/main/java/org/apache/rocketmq/client/consumer/LitePullConsumer.java,"@@ -75,6 +75,15 @@ public interface LitePullConsumer {
      */
     void assign(Collection<MessageQueue> messageQueues);
 
+    /**
+     * Set topic subExpression for assign mode. This interface does not allow be call after start(). Default value is * if not set.
+     * assignment and will replace the previous assignment (if there is one).
+     *
+     * @param subExpression subscription expression.it only support or operation such as ""tag1 || tag2 || tag3"" <br> if
+     *      * null or * expression,meaning subscribe all
+     */
+    void setSubExpression4Assign(final String topic, final String subExpression);","[{'comment': 'Same here', 'commenter': 'lizhanhui'}]"
4775,client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultLitePullConsumerImpl.java,"@@ -531,6 +534,17 @@ public synchronized void assign(Collection<MessageQueue> messageQueues) {
         }
     }
 
+    public synchronized void setSubExpression4Assign(final String topic, final String subExpression) {","[{'comment': 'Same here', 'commenter': 'lizhanhui'}]"
4775,client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultLitePullConsumerImpl.java,"@@ -121,6 +122,8 @@ private enum SubscriptionType {
 
     private static final long PULL_TIME_DELAY_MILLS_ON_EXCEPTION = 3 * 1000;
 
+    private ConcurrentHashMap<String/* topic */, String/* subExpression */> topic2SubExpression = new ConcurrentHashMap<>();","[{'comment': 'Same here', 'commenter': 'lizhanhui'}]"
4798,controller/src/main/java/org/apache/rocketmq/controller/impl/manager/ReplicasInfoManager.java,"@@ -160,25 +161,30 @@ public ControllerResult<ElectMasterResponseHeader> electMaster(
             // First, check whether the master is still active
             final String oldMaster = syncStateInfo.getMasterAddress();
             if (StringUtils.isNoneEmpty(oldMaster) && brokerAlivePredicate.test(brokerInfo.getClusterName(), oldMaster)) {
-                String err = String.format(""The old master %s is still alive, not need to elect new master for broker %s"", oldMaster, brokerInfo.getBrokerName());
-                log.warn(""{}"", err);
-                result.setCodeAndRemark(ResponseCode.CONTROLLER_INVALID_REQUEST, err);
-                return result;
+
+                if (StringUtils.isBlank(assignBrokerAddress) || StringUtils.equals(oldMaster, assignBrokerAddress)) {","[{'comment': 'It would be better to combine the two if to the one', 'commenter': 'RongtongJin'}]"
4798,tools/src/main/java/org/apache/rocketmq/tools/command/controller/ElectMasterSubCommand.java,"@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tools.command.controller;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.rocketmq.common.protocol.body.BrokerMemberGroup;
+import org.apache.rocketmq.common.protocol.header.namesrv.controller.ElectMasterResponseHeader;
+import org.apache.rocketmq.remoting.RPCHook;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
+import org.apache.rocketmq.tools.command.SubCommand;
+import org.apache.rocketmq.tools.command.SubCommandException;
+
+public class ElectMasterSubCommand implements SubCommand {
+
+    @Override
+    public String commandName() {
+        return ""electMaster"";
+    }
+
+    @Override
+    public String commandDesc() {
+        return ""Elects the specified broker as master"";","[{'comment': '""Re-elect the specified broker as master""', 'commenter': 'RongtongJin'}]"
4798,common/src/main/java/org/apache/rocketmq/common/protocol/header/namesrv/controller/ElectMasterRequestHeader.java,"@@ -20,15 +20,26 @@
 import org.apache.rocketmq.remoting.exception.RemotingCommandException;
 
 public class ElectMasterRequestHeader implements CommandCustomHeader {
+
+    private String clusterName;
+
     private String brokerName;
 
+    private String brokerAddress;","[{'comment': 'It would be better to add @CFNullable annotation', 'commenter': 'RongtongJin'}]"
4798,tools/src/main/java/org/apache/rocketmq/tools/command/controller/ElectMasterSubCommand.java,"@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tools.command.controller;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.rocketmq.common.protocol.body.BrokerMemberGroup;
+import org.apache.rocketmq.common.protocol.header.namesrv.controller.ElectMasterResponseHeader;
+import org.apache.rocketmq.remoting.RPCHook;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
+import org.apache.rocketmq.tools.command.SubCommand;
+import org.apache.rocketmq.tools.command.SubCommandException;
+
+public class ElectMasterSubCommand implements SubCommand {","[{'comment': 'How about rename to “ReElectMasterSubCommand”？', 'commenter': 'RongtongJin'}]"
4798,tools/src/main/java/org/apache/rocketmq/tools/command/controller/ElectMasterSubCommand.java,"@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tools.command.controller;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.rocketmq.common.protocol.body.BrokerMemberGroup;
+import org.apache.rocketmq.common.protocol.header.namesrv.controller.ElectMasterResponseHeader;
+import org.apache.rocketmq.remoting.RPCHook;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
+import org.apache.rocketmq.tools.command.SubCommand;
+import org.apache.rocketmq.tools.command.SubCommandException;
+
+public class ElectMasterSubCommand implements SubCommand {
+
+    @Override
+    public String commandName() {
+        return ""electMaster"";
+    }
+
+    @Override
+    public String commandDesc() {
+        return ""Elects the specified broker as master"";
+    }
+
+    @Override
+    public Options buildCommandlineOptions(Options options) {
+        Option opt = new Option(""a"", ""controllerAddress"", true, ""the address of controller"");
+        opt.setRequired(true);
+        options.addOption(opt);
+
+        opt = new Option(""b"", ""brokerAddress"", true, ""the address of broker"");","[{'comment': '“the address of the broker wants to be master”', 'commenter': 'RongtongJin'}, {'comment': 'which', 'commenter': 'ShannonDing'}]"
4798,tools/src/main/java/org/apache/rocketmq/tools/command/controller/ElectMasterSubCommand.java,"@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tools.command.controller;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.rocketmq.common.protocol.body.BrokerMemberGroup;
+import org.apache.rocketmq.common.protocol.header.namesrv.controller.ElectMasterResponseHeader;
+import org.apache.rocketmq.remoting.RPCHook;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
+import org.apache.rocketmq.tools.command.SubCommand;
+import org.apache.rocketmq.tools.command.SubCommandException;
+
+public class ElectMasterSubCommand implements SubCommand {
+
+    @Override
+    public String commandName() {
+        return ""electMaster"";
+    }
+
+    @Override
+    public String commandDesc() {
+        return ""Elects the specified broker as master"";
+    }
+
+    @Override
+    public Options buildCommandlineOptions(Options options) {
+        Option opt = new Option(""a"", ""controllerAddress"", true, ""the address of controller"");
+        opt.setRequired(true);
+        options.addOption(opt);
+
+        opt = new Option(""b"", ""brokerAddress"", true, ""the address of broker"");
+        opt.setRequired(true);
+        options.addOption(opt);
+
+        opt = new Option(""n"", ""brokerName"", true, ""which broker to elect master"");","[{'comment': '“The broker name of the replicas want to operate”', 'commenter': 'RongtongJin'}]"
4798,controller/src/main/java/org/apache/rocketmq/controller/impl/manager/ReplicasInfoManager.java,"@@ -160,25 +161,30 @@ public ControllerResult<ElectMasterResponseHeader> electMaster(
             // First, check whether the master is still active
             final String oldMaster = syncStateInfo.getMasterAddress();
             if (StringUtils.isNoneEmpty(oldMaster) && brokerAlivePredicate.test(brokerInfo.getClusterName(), oldMaster)) {
-                String err = String.format(""The old master %s is still alive, not need to elect new master for broker %s"", oldMaster, brokerInfo.getBrokerName());
-                log.warn(""{}"", err);
-                result.setCodeAndRemark(ResponseCode.CONTROLLER_INVALID_REQUEST, err);
-                return result;
+
+                if (StringUtils.isBlank(assignBrokerAddress) || StringUtils.equals(oldMaster, assignBrokerAddress)) {
+                    String err = String.format(""The old master %s is still alive, not need to elect new master for broker %s"", oldMaster, brokerInfo.getBrokerName());
+                    log.warn(""{}"", err);
+                    result.setCodeAndRemark(ResponseCode.CONTROLLER_INVALID_REQUEST, err);
+                    return result;
+                }
             }
 
             // Try elect a master in syncStateSet
             if (syncStateSet.size() > 1) {
-                boolean electSuccess = tryElectMaster(result, brokerName, syncStateSet, candidate ->
-                    !candidate.equals(syncStateInfo.getMasterAddress()) && brokerAlivePredicate.test(brokerInfo.getClusterName(), candidate));
+                boolean electSuccess = tryElectMaster(result, brokerName, assignBrokerAddress, syncStateSet, candidate ->
+                    (StringUtils.isEmpty(assignBrokerAddress) ? !StringUtils.equals(candidate, syncStateInfo.getMasterAddress()) : true)","[{'comment': 'This judgment seems unnecessary. -> StringUtils.isEmpty(assignBrokerAddress) ', 'commenter': 'RongtongJin'}, {'comment': ""sorry, I don't understant, what's the meaning of this line?"", 'commenter': 'hzh0425'}, {'comment': 'Redundant check, I remove it', 'commenter': 'mxsm'}]"
4798,controller/src/main/java/org/apache/rocketmq/controller/impl/manager/ReplicasInfoManager.java,"@@ -160,25 +161,30 @@ public ControllerResult<ElectMasterResponseHeader> electMaster(
             // First, check whether the master is still active
             final String oldMaster = syncStateInfo.getMasterAddress();
             if (StringUtils.isNoneEmpty(oldMaster) && brokerAlivePredicate.test(brokerInfo.getClusterName(), oldMaster)) {
-                String err = String.format(""The old master %s is still alive, not need to elect new master for broker %s"", oldMaster, brokerInfo.getBrokerName());
-                log.warn(""{}"", err);
-                result.setCodeAndRemark(ResponseCode.CONTROLLER_INVALID_REQUEST, err);
-                return result;
+
+                if (StringUtils.isBlank(assignBrokerAddress) || StringUtils.equals(oldMaster, assignBrokerAddress)) {
+                    String err = String.format(""The old master %s is still alive, not need to elect new master for broker %s"", oldMaster, brokerInfo.getBrokerName());","[{'comment': 'This err log is inappropriate here', 'commenter': 'hzh0425'}, {'comment': ' I add a new err log for this case', 'commenter': 'mxsm'}, {'comment': '> The old master %s is still alive, not need to elect new master for broker %s\r\n\r\nto:\r\n\r\n> The old master %s is still alive, no need to elect new master for broker %s', 'commenter': 'tsunghanjacktsai'}]"
4798,tools/src/main/java/org/apache/rocketmq/tools/command/controller/ReElectMasterSubCommand.java,"@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tools.command.controller;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.rocketmq.common.protocol.body.BrokerMemberGroup;
+import org.apache.rocketmq.common.protocol.header.namesrv.controller.ElectMasterResponseHeader;
+import org.apache.rocketmq.remoting.RPCHook;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
+import org.apache.rocketmq.tools.command.SubCommand;
+import org.apache.rocketmq.tools.command.SubCommandException;
+
+public class ReElectMasterSubCommand implements SubCommand {
+
+    @Override
+    public String commandName() {
+        return ""electMaster"";
+    }
+
+    @Override
+    public String commandDesc() {
+        return ""Re-elect the specified broker as master"";
+    }
+
+    @Override
+    public Options buildCommandlineOptions(Options options) {
+        Option opt = new Option(""a"", ""controllerAddress"", true, ""The address of controller"");
+        opt.setRequired(true);
+        options.addOption(opt);
+
+        opt = new Option(""b"", ""brokerAddress"", true, ""which address of the broker wants to be master"");","[{'comment': '> which address of the broker wants to be master\r\n\r\nto:\r\n\r\n> The address of the broker which requires to become master', 'commenter': 'tsunghanjacktsai'}]"
4798,tools/src/main/java/org/apache/rocketmq/tools/command/controller/ReElectMasterSubCommand.java,"@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tools.command.controller;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.rocketmq.common.protocol.body.BrokerMemberGroup;
+import org.apache.rocketmq.common.protocol.header.namesrv.controller.ElectMasterResponseHeader;
+import org.apache.rocketmq.remoting.RPCHook;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
+import org.apache.rocketmq.tools.command.SubCommand;
+import org.apache.rocketmq.tools.command.SubCommandException;
+
+public class ReElectMasterSubCommand implements SubCommand {
+
+    @Override
+    public String commandName() {
+        return ""electMaster"";
+    }
+
+    @Override
+    public String commandDesc() {
+        return ""Re-elect the specified broker as master"";
+    }
+
+    @Override
+    public Options buildCommandlineOptions(Options options) {
+        Option opt = new Option(""a"", ""controllerAddress"", true, ""The address of controller"");
+        opt.setRequired(true);
+        options.addOption(opt);
+
+        opt = new Option(""b"", ""brokerAddress"", true, ""which address of the broker wants to be master"");
+        opt.setRequired(true);
+        options.addOption(opt);
+
+        opt = new Option(""n"", ""brokerName"", true, ""The broker name of the replicas want to operate"");","[{'comment': '> The broker name of the replicas want to operate\r\n\r\nto:\r\n\r\n> The broker name of the replicas that require to be manipulated', 'commenter': 'tsunghanjacktsai'}]"
4798,controller/src/main/java/org/apache/rocketmq/controller/impl/manager/ReplicasInfoManager.java,"@@ -160,25 +162,35 @@ public ControllerResult<ElectMasterResponseHeader> electMaster(
             // First, check whether the master is still active
             final String oldMaster = syncStateInfo.getMasterAddress();
             if (StringUtils.isNoneEmpty(oldMaster) && brokerAlivePredicate.test(brokerInfo.getClusterName(), oldMaster)) {
-                String err = String.format(""The old master %s is still alive, not need to elect new master for broker %s"", oldMaster, brokerInfo.getBrokerName());
-                log.warn(""{}"", err);
-                result.setCodeAndRemark(ResponseCode.CONTROLLER_INVALID_REQUEST, err);
-                return result;
+
+                if (StringUtils.isBlank(assignBrokerAddress)) {
+                    String err = String.format(""The old master %s is still alive, not need to elect new master for broker %s"", oldMaster, brokerInfo.getBrokerName());
+                    log.warn(""{}"", err);
+                    result.setCodeAndRemark(ResponseCode.CONTROLLER_INVALID_REQUEST, err);
+                    return result;
+                }
+
+                if (StringUtils.equals(oldMaster, assignBrokerAddress)) {
+                    String err = String.format(""The Re-elect master the same as old master %s and old master is still alive, not need to elect new master for broker %s"", oldMaster, brokerInfo.getBrokerName());","[{'comment': '> The Re-elect master the same as old master %s and old master is still alive, not need to elect new master for broker %s\r\n\r\nto:\r\n\r\n> The Re-elect master is the same as the old master %s which is still alive, no need to elect new master for broker %s', 'commenter': 'tsunghanjacktsai'}]"
4860,acl/src/test/java/org/apache/rocketmq/acl/common/AclSignerTest.java,"@@ -27,8 +28,9 @@ public void calSignatureExceptionTest(){
 
     @Test
     public void calSignatureTest(){
-        AclSigner.calSignature(""RocketMQ"",""12345678"");
-        AclSigner.calSignature(""RocketMQ"".getBytes(),""12345678"");
+        String expectedSignature = ""IUc8rrO/0gDch8CjObLQsW2rsiA="";
+        Assert.assertEquals(expectedSignature, AclSigner.calSignature(""RocketMQ"", ""12345678""));
+        Assert.assertEquals(expectedSignature, AclSigner.calSignature(""RocketMQ"".getBytes(), ""12345678""));","[{'comment': 'Assert.assertEquals(AclSigner.calSignature(""RocketMQ"", ""12345678""), AclSigner.calSignature(""RocketMQ"".getBytes(), ""12345678""));', 'commenter': 'ShannonDing'}]"
4903,store/src/main/java/org/apache/rocketmq/store/logfile/DefaultMappedFile.java,"@@ -548,15 +548,15 @@ public void warmMappedFile(FlushDiskType type, int pages) {
             }
 
             // prevent gc
-            if (j % 1000 == 0) {
-                log.info(""j={}, costTime={}"", j, System.currentTimeMillis() - time);
-                time = System.currentTimeMillis();
-                try {
-                    Thread.sleep(0);
-                } catch (InterruptedException e) {
-                    log.error(""Interrupted"", e);
-                }
-            }
+            // if (j % 1000 == 0) {
+            //     log.info(""j={}, costTime={}"", j, System.currentTimeMillis() - time);
+            //     time = System.currentTimeMillis();
+            //     try {
+            //         Thread.sleep(0);","[{'comment': 'IMO, sleep(0) will give CPU time to another thread. These codes should not be deleted to prevent high CPU usage of this warm-up loop.', 'commenter': 'ShadowySpirits'}]"
4957,store/src/test/java/org/apache/rocketmq/store/ha/autoswitch/AutoSwitchHATest.java,"@@ -72,9 +73,9 @@ public class AutoSwitchHATest {
     private String store2HaAddress;
 
     private BrokerStatsManager brokerStatsManager = new BrokerStatsManager(""simpleTest"", true);
-    private String tmpdir = System.getProperty(""java.io.tmpdir"");
-    private String storePathRootParentDir = (StringUtils.endsWith(tmpdir, File.separator) ? tmpdir : tmpdir + File.separator) + UUID.randomUUID();
-    private String storePathRootDir = storePathRootParentDir + File.separator + ""store"";
+","[{'comment': 'CI is not passed\r\nTests in error: \r\n  AutoSwitchHATest.testTruncateEpochLogAndChangeMaster:380->checkMessage:193 » ConditionTimeout\r\n\r\nTests run: 148, Failures: 0, Errors: 1, Skipped: 9', 'commenter': 'Oliverwqcwrw'}, {'comment': 'I will be fixed it', 'commenter': 'mxsm'}]"
4991,acl/src/test/java/org/apache/rocketmq/acl/plain/PlainPermissionManagerTest.java,"@@ -32,7 +32,9 @@
 import org.assertj.core.util.Lists;
 import org.junit.Assert;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TemporaryFolder;","[{'comment': 'This seems to be the imports of another pull request.', 'commenter': 'RongtongJin'}, {'comment': 'Should we think about merging #4637 and then #4991', 'commenter': 'Oliverwqcwrw'}]"
4991,acl/src/test/java/org/apache/rocketmq/acl/plain/PlainPermissionManagerTest.java,"@@ -215,16 +217,16 @@ public void isWatchStartTest() {
 
     @Test
     public void multiFilePathTest() {
-        File file = new File(""src/test/resources"");
+        File file = new File(""src/test/resources"".replace(""/"", File.separator));
         System.setProperty(""rocketmq.home.dir"", file.getAbsolutePath());
 
         PlainPermissionManager plainPermissionManager = new PlainPermissionManager();
 
-        String samefilePath = file.getAbsolutePath()+""/conf/acl/."";
-        String samefilePath2 = ""/"" +file.getAbsolutePath()+""/conf/acl"";
-        String samefilePath3 = file.getAbsolutePath()+""/conf/acl/../""+file.getAbsolutePath();
-        String samefilePath4 = file.getAbsolutePath()+""/conf/acl///"";
-        String samefilePath5 = file.getAbsolutePath()+""/conf/acl/./"";
+        String samefilePath = file.getAbsolutePath()+""/conf/acl/."".replace(""/"", File.separator);
+        String samefilePath2 = file.getAbsolutePath()+""/conf/acl"".replace(""/"", File.separator);","[{'comment': ""The purpose of `samefilePath2` is to assure '/folder' is equivalent to '//folder' as path. IMO it should not be removed, but just check it in Linux or OS with '/' as path separator."", 'commenter': 'caigy'}, {'comment': 'OK I will handle this case', 'commenter': 'mxsm'}]"
4991,acl/src/test/java/org/apache/rocketmq/acl/plain/PlainPermissionManagerTest.java,"@@ -53,10 +54,12 @@ public class PlainPermissionManagerTest {
     PlainAccessConfig plainAccessConfig = new PlainAccessConfig();
     Set<Integer> adminCode = new HashSet<>();
 
-    private static final String PATH = PlainPermissionManagerTest.class.getResource(File.separator).getFile();
+    private static final String PATH = ""src/test/resources"";","[{'comment': 'This does not seem to need to be modified to be compatible with multiple system separators', 'commenter': 'Oliverwqcwrw'}, {'comment': 'But when I run test case with befor code, not passed on windows platform', 'commenter': 'mxsm'}, {'comment': ""Regrettably, I don't have Windows system so I can't provide more information. I would like to know if this format `src/test/resources` supports Windows now"", 'commenter': 'Oliverwqcwrw'}]"
5014,broker/src/main/java/org/apache/rocketmq/broker/BrokerStartup.java,"@@ -139,6 +138,12 @@ public static BrokerController createBrokerController(String[] args) {
                 System.exit(-2);
             }
 
+            if (!nettyServerConfig.getBindIP().equals(""0.0.0.0"") &&
+                !nettyServerConfig.getBindIP().equals(brokerConfig.getBrokerIP1())) {","[{'comment': 'The host to bind may be different with wildcard address and broker IP1. Broker IP1 is for clients to connect to brokers. For example, in the cloud environment, brokerIP1 is configured to its public IP. \r\nThe ECS itself may have multiple network interfaces wiring virtually to different networks.', 'commenter': 'lizhanhui'}, {'comment': 'In the cloud environment, if public IP is assigned to one virtual network interface, just set brokerIP1 and bindIP to public IP. More generally case is cloud host use nat, which means you can not bind to public IP directly because of OS limition.\r\n\r\n<img width=""641"" alt=""image"" src=""https://user-images.githubusercontent.com/32436597/188814482-1b505bc1-a701-474c-85de-aa9c7d9c135d.png"">\r\n\r\nIn this case, you can set brokerIP1 to public IP and set bindIP to 0.0.0.0. The same is true for binding to multiple network interfaces.', 'commenter': 'ShadowySpirits'}]"
5014,remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingServer.java,"@@ -240,15 +239,18 @@ public void initChannel(SocketChannel ch) {
         addCustomConfig(serverBootstrap);
 
         try {
-            ChannelFuture sync = serverBootstrap.bind(nettyServerConfig.getListenPort()).sync();
+            ChannelFuture sync = serverBootstrap.bind().sync();
             InetSocketAddress addr = (InetSocketAddress) sync.channel().localAddress();
             if (0 == nettyServerConfig.getListenPort()) {
                 this.nettyServerConfig.setListenPort(addr.getPort());
-                log.debug(""Server is listening {}"", this.nettyServerConfig.getListenPort());
+                log.info(""Server is listening {}:{}"", this.nettyServerConfig.getBindIP(), this.nettyServerConfig.getListenPort());
             }
             this.remotingServerTable.put(this.nettyServerConfig.getListenPort(), this);
-        } catch (InterruptedException e1) {
-            throw new RuntimeException(""this.serverBootstrap.bind().sync() InterruptedException"", e1);
+        } catch (Exception e) {
+            if (e instanceof BindException) {
+                throw new RuntimeException(""bind to "" + this.nettyServerConfig.getBindIP() + "":"" + this.nettyServerConfig.getListenPort() + "" failed"", e);
+            }
+            throw new RuntimeException(""this.serverBootstrap.bind().sync() InterruptedException"", e);","[{'comment': '```suggestion\r\n            throw new RuntimeException(""this.serverBootstrap.bind().sync() failed"", e);\r\n```\r\nIMO, If the exception is not BindException, it is not necessarily InterruptedException\r\n', 'commenter': 'Oliverwqcwrw'}, {'comment': ""Let's simply propagate/wrap the internal IllegalStateException, with our intention attached. "", 'commenter': 'lizhanhui'}]"
5027,broker/src/main/java/org/apache/rocketmq/broker/processor/SendMessageProcessor.java,"@@ -351,6 +351,21 @@ private RemotingCommand handlePutMessageResult(PutMessageResult putMessageResult
                 response.setRemark(String.format(""the message is illegal, maybe msg body or properties length not matched. msg body length limit %dB, msg properties length limit 32KB."",
                     this.brokerController.getMessageStoreConfig().getMaxMessageSize()));
                 break;
+            case WHEEL_TIMER_MSG_ILLEGAL:
+                response.setCode(ResponseCode.WHEEL_TIMER_MSG_ILLEGAL);
+                response.setRemark(String.format(""the accurate delay message is illegal, delay time max limit %dms, or check props if setting TIMER_DEL_UNIQKEY or not"",
+                        this.brokerController.getMessageStoreConfig().getTimerMaxDelaySec() * 1000));
+                break;","[{'comment': 'How about reusing ResponseCode.MESSAGE_ILLEGAL for WHEEL_TIMER_MSG_ILLEGAL？', 'commenter': 'RongtongJin'}]"
5027,broker/src/main/java/org/apache/rocketmq/broker/processor/SendMessageProcessor.java,"@@ -351,6 +351,21 @@ private RemotingCommand handlePutMessageResult(PutMessageResult putMessageResult
                 response.setRemark(String.format(""the message is illegal, maybe msg body or properties length not matched. msg body length limit %dB, msg properties length limit 32KB."",
                     this.brokerController.getMessageStoreConfig().getMaxMessageSize()));
                 break;
+            case WHEEL_TIMER_MSG_ILLEGAL:
+                response.setCode(ResponseCode.WHEEL_TIMER_MSG_ILLEGAL);
+                response.setRemark(String.format(""the accurate delay message is illegal, delay time max limit %dms, or check props if setting TIMER_DEL_UNIQKEY or not"",
+                        this.brokerController.getMessageStoreConfig().getTimerMaxDelaySec() * 1000));
+                break;
+            case WHEEL_TIMER_FLOW_CONTROL:
+                response.setCode(ResponseCode.WHEEL_TIMER_FLOW_CONTROL);
+                response.setRemark(String.format(""or send message too much, triggered the flow control max num limit is %d or the current value is greater than %d and less than %d, trigger random flow control"",
+                        this.brokerController.getMessageStoreConfig().getTimerCongestNumEachSlot() * 2L, this.brokerController.getMessageStoreConfig().getTimerCongestNumEachSlot(), this.brokerController.getMessageStoreConfig().getTimerCongestNumEachSlot() * 2L));
+                break;
+            case WHEEL_TIMER_NOT_ENABLE:
+                response.setCode(ResponseCode.WHEEL_TIMER_NOT_ENABLE);
+                response.setRemark(String.format(""accurate delay is not enabled, timerWheelEnable is %s"",
+                        brokerController.getMessageStoreConfig().isTimerWheelEnable()));","[{'comment': 'How about reusing ResponseCode.SYSTEM_ERROR for WHEEL_TIMER_FLOW_CONTROL and WHEEL_TIMER_NOT_ENABLE?', 'commenter': 'RongtongJin'}]"
5027,broker/src/main/java/org/apache/rocketmq/broker/processor/SendMessageProcessor.java,"@@ -351,6 +351,21 @@ private RemotingCommand handlePutMessageResult(PutMessageResult putMessageResult
                 response.setRemark(String.format(""the message is illegal, maybe msg body or properties length not matched. msg body length limit %dB, msg properties length limit 32KB."",
                     this.brokerController.getMessageStoreConfig().getMaxMessageSize()));
                 break;
+            case WHEEL_TIMER_MSG_ILLEGAL:
+                response.setCode(ResponseCode.WHEEL_TIMER_MSG_ILLEGAL);
+                response.setRemark(String.format(""the accurate delay message is illegal, delay time max limit %dms, or check props if setting TIMER_DEL_UNIQKEY or not"",","[{'comment': 'Maybe ""timer message illegal, the delay time should not be bigger than the max delay; or if set del msg, the delay time should be bigger than the current time"" better', 'commenter': 'RongtongJin'}]"
5027,common/src/main/java/org/apache/rocketmq/common/protocol/ResponseCode.java,"@@ -92,6 +92,12 @@ public class ResponseCode extends RemotingSysResponseCode {
 
     public static final int FLOW_CONTROL = 215;
 
+    public static final int WHEEL_TIMER_MSG_ILLEGAL = 216;
+
+    public static final int WHEEL_TIMER_FLOW_CONTROL = 217;
+
+    public static final int WHEEL_TIMER_NOT_ENABLE = 218;
+","[{'comment': 'IMO, It would be better not to add a new response code', 'commenter': 'RongtongJin'}]"
5033,logging/src/main/java/org/apache/rocketmq/logging/dynamic/AbstractProcessUnitImpl.java,"@@ -0,0 +1,116 @@
+package org.apache.rocketmq.logging.dynamic;
+
+import com.alibaba.fastjson.JSONArray;
+import com.alibaba.fastjson.JSONObject;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.logging.log4j.core.config.LoggerConfig;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.slf4j.impl.StaticLoggerBinder;
+
+import java.util.Enumeration;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOG4J2_LOGGER_FACTORY;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOG4J_LOGGER_FACTORY;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGBACK_LOGGER_FACTORY;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGGER_LEVEL;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGGER_LIST;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGGER_NAME;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGGER_TYPE_UNKNOWN;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOG_FRAMEWORK;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.ROOT_KEY;
+
+/**
+ * 日志调整抽象类
+ * 支持log4j、log4j2、logback
+ */","[{'comment': ""remove chinese notes and hints,Other classes also have Chinese annotations. don't have a valid license header.\r\nCode guidelines: https://rocketmq.apache.org/docs/%E8%B4%A1%E7%8C%AE%E6%8C%87%E5%8D%97/30code-guidelines"", 'commenter': 'mxsm'}]"
5033,logging/src/main/java/org/apache/rocketmq/logging/dynamic/AbstractProcessUnitImpl.java,"@@ -0,0 +1,116 @@
+package org.apache.rocketmq.logging.dynamic;
+
+import com.alibaba.fastjson.JSONArray;
+import com.alibaba.fastjson.JSONObject;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.logging.log4j.core.config.LoggerConfig;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.slf4j.impl.StaticLoggerBinder;
+
+import java.util.Enumeration;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOG4J2_LOGGER_FACTORY;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOG4J_LOGGER_FACTORY;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGBACK_LOGGER_FACTORY;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGGER_LEVEL;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGGER_LIST;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGGER_NAME;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGGER_TYPE_UNKNOWN;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOG_FRAMEWORK;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.ROOT_KEY;
+
+/**
+ * 日志调整抽象类
+ * 支持log4j、log4j2、logback
+ */
+public abstract class AbstractProcessUnitImpl implements IProcessUnit {","[{'comment': ""Unlike C#, Interfaces in Java do not start with the prefix 'I' conventionally. "", 'commenter': 'lizhanhui'}]"
5033,logging/src/main/java/org/apache/rocketmq/logging/dynamic/AbstractProcessUnitImpl.java,"@@ -0,0 +1,116 @@
+package org.apache.rocketmq.logging.dynamic;
+
+import com.alibaba.fastjson.JSONArray;
+import com.alibaba.fastjson.JSONObject;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.logging.log4j.core.config.LoggerConfig;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.slf4j.impl.StaticLoggerBinder;
+
+import java.util.Enumeration;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOG4J2_LOGGER_FACTORY;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOG4J_LOGGER_FACTORY;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGBACK_LOGGER_FACTORY;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGGER_LEVEL;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGGER_LIST;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGGER_NAME;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOGGER_TYPE_UNKNOWN;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.LOG_FRAMEWORK;
+import static org.apache.rocketmq.logging.dynamic.LogConstant.ROOT_KEY;
+
+/**
+ * 日志调整抽象类","[{'comment': 'Chinese characters will fail check style', 'commenter': 'lizhanhui'}]"
5033,logging/src/test/java/org/apache/rocketmq/logging/dynamic/ChangeLogLevelProcessUnitTest.java,"@@ -0,0 +1,32 @@
+package org.apache.rocketmq.logging.dynamic;
+
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.slf4j.impl.StaticLoggerBinder;
+
+public class ChangeLogLevelProcessUnitTest {
+    Logger logger = LoggerFactory.getLogger(ChangeLogLevelProcessUnitTest.class);
+    
+    String serverId = ""logback-loglevel-test"";
+    
+    @Test
+    public void setLogLevelTest() {
+        logger.debug(""test start"");
+        logger.debug(""type:{}"", StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr());
+        AbstractProcessUnitImpl process = ProcessUnitFactory.newInstance(serverId).getChangeLogLevelProcess();
+        logger.debug(""frame:{}"", process.logFrameworkType);
+        
+        process.setDefaultLevel(""ERROR"");
+        String a = null;
+        process.setLogLevel(a);
+        logger.debug(""now is debug"");
+        process.setLogLevel(""INFO"");//改成INFO","[{'comment': 'Chinese comments need to be removed', 'commenter': 'mxsm'}]"
5033,logging/src/main/java/org/apache/rocketmq/logging/dynamic/ProcessUnitFactory.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.logging.dynamic;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * service factory
+ */
+public class ProcessUnitFactory {
+    
+    private static final Map<String, ProcessUnitFactory> pufMap = new ConcurrentHashMap<String, ProcessUnitFactory>();
+    
+    /**
+     * service serverId
+     */
+    private String serverId = null;
+    
+    /**
+     * Construct service factory
+     *
+     * @param serverId -- 服务serverId
+     */
+    public ProcessUnitFactory(String serverId) {
+        this.serverId = serverId;
+    }
+    
+    /**
+     * 获取服务工厂
+     *
+     * @param serverId -- 服务serverId
+     * @return -- 服务工厂
+     */","[{'comment': 'Chinese comments need to be removed', 'commenter': 'mxsm'}]"
5099,docs/en/proxy/deploy_guide.md,"@@ -20,7 +20,7 @@ Run the command below.
 nohup sh mqproxy &
 ```
 
-The command will only run `Proxy` itself. It requires `Namesrv` and `Broker` components running.
+The command will only launch the `Proxy` component itself. It assumes that `Namesrv` nodes are already running at the address specified `nameSrvAddr`, and broker nodes, registering themselves with `nameSrvAddr`, are running too.
 
 ## `Local` mode","[{'comment': '```suggestion\r\n## `Local` Mode\r\n```', 'commenter': 'aaron-ai'}]"
5099,docs/en/proxy/deploy_guide.md,"@@ -33,5 +33,4 @@ Run the command below.
 nohup sh mqproxy &
 ```
 
-The command will not only run `Proxy`, but also run `Broker`. It requires `Namesrv` only and there's no need for
-extra `Broker`.
\ No newline at end of file
+The previous command will launch the `Proxy`, with `Broker` in the same process. It asssumes `Namesrv` nodes are running at the address specified by `nameSrvAddr`.","[{'comment': '```suggestion\r\nThe previous command will launch the `Proxy`, with `Broker` in the same process. It assumes `Namesrv` nodes are running at the address specified by `nameSrvAddr`.\r\n```', 'commenter': 'Oliverwqcwrw'}]"
5110,common/src/main/java/org/apache/rocketmq/common/BrokerIdentity.java,"@@ -98,14 +110,8 @@ public void setInBrokerContainer(boolean inBrokerContainer) {
         isInBrokerContainer = inBrokerContainer;
     }
 
-    protected static String localHostName() {
-        try {
-            return InetAddress.getLocalHost().getHostName();
-        } catch (UnknownHostException e) {
-            LOGGER.error(""Failed to obtain the host name"", e);
-        }
-
-        return ""DEFAULT_BROKER"";
+    private String defaultBrokerName() {
+        return localHostName == null ? ""DEFAULT_BROKER"" : localHostName;","[{'comment': '```suggestion\r\n        return StringUtils.isEmpty(localHostName) ? ""DEFAULT_BROKER"" : localHostName;\r\n```', 'commenter': 'Oliverwqcwrw'}]"
5118,Jenkinsfile,"@@ -0,0 +1,138 @@
+import groovy.json.JsonSlurper
+","[{'comment': 'missing license of this file', 'commenter': 'mxsm'}, {'comment': ""Thx for pointing it out. We've now changed it to the GitHub Actions, please have a review again."", 'commenter': 'tsunghanjacktsai'}]"
5118,pom.xml,"@@ -294,6 +295,7 @@
                     <excludes>
                         <exclude>.gitignore</exclude>
                         <exclude>.travis.yml</exclude>
+                        <exclude>Jenkinsfile</exclude>","[{'comment': 'This line should be deleted', 'commenter': 'lizhanhui'}, {'comment': 'Sorry for the careless mistake.', 'commenter': 'tsunghanjacktsai'}]"
5118,.github/workflows/snapshot-automation.yml,"@@ -0,0 +1,21 @@
+name: Snapshot Release Automation
+on:
+  schedule: # schedule the job to run at 12 a.m. daily
+    - cron: ""0 0 * * *""
+jobs:
+  snapshot:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v3
+        with:
+          ref: develop
+      - name: Setup JDK
+        uses: actions/setup-java@v2
+        with:
+          java-version: 8
+          distribution: ""adopt""
+          cache: ""maven""
+      - name: Deploy Snapshot
+        timeout-minutes: 40
+        run: mvn clean deploy -DskipTests=true'","[{'comment': 'Are secrets needed here?', 'commenter': 'aaron-ai'}, {'comment': ""Thinking the same here. But I'm not sure what types of secrets I should add. This would automatically deploy to the Apache repository. The closest one I've referred to was: https://github.com/apache/dubbo/blob/3.1/Jenkinsfile , which seems like they did not apply any secret."", 'commenter': 'tsunghanjacktsai'}, {'comment': 'Create a JIRA ticket, requesting them to add GitHub Secret for you. The secret will be accessible to GitHub Actions. \r\nNote, remember to specify the name of the repository to add to when creating tickets.\r\n\r\nFor the maven part, use variable substitution as described here: https://stackoverflow.com/questions/28071697/is-it-possible-to-pass-a-password-in-maven-deploy-in-the-command-line.\r\n', 'commenter': 'lizhanhui'}, {'comment': 'Here is an example. https://issues.apache.org/jira/browse/INFRA-23612?filter=-2\r\n\r\nThe actual secret Key=Value is expected to be mailed to root@apache.org privately', 'commenter': 'lizhanhui'}, {'comment': ""I've now created a JIRA ticket for it: https://issues.apache.org/jira/browse/INFRA-23708 and waiting for the response from the Infra team."", 'commenter': 'tsunghanjacktsai'}]"
5150,example/src/main/java/org/apache/rocketmq/example/ordermessage/Producer.java,"@@ -52,9 +52,8 @@ public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {
 
                 System.out.printf(""%s%n"", sendResult);
             }
-
             producer.shutdown();
-        } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) {
+        } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException | UnsupportedEncodingException e) {","[{'comment': 'How about  `catch(Exception e)` ?', 'commenter': 'ShannonDing'}, {'comment': 'Just with  e.printStackTrace();', 'commenter': 'alexcao2018'}, {'comment': 'catch (Exception e) {\r\n            e.printStackTrace();\r\n        }', 'commenter': 'ShannonDing'}, {'comment': 'copied that.', 'commenter': 'alexcao2018'}, {'comment': 'So please review my new committed code.', 'commenter': 'alexcao2018'}, {'comment': 'Please review final code committed.', 'commenter': 'alexcao2018'}]"
5150,example/src/main/java/org/apache/rocketmq/example/ordermessage/Producer.java,"@@ -16,21 +16,18 @@
  */
 package org.apache.rocketmq.example.ordermessage;
 
-import org.apache.rocketmq.client.exception.MQBrokerException;
-import org.apache.rocketmq.client.exception.MQClientException;
+
 import org.apache.rocketmq.client.producer.DefaultMQProducer;
 import org.apache.rocketmq.client.producer.MessageQueueSelector;
 import org.apache.rocketmq.client.producer.SendResult;
 import org.apache.rocketmq.common.message.Message;
 import org.apache.rocketmq.common.message.MessageQueue;
 import org.apache.rocketmq.remoting.common.RemotingHelper;
-import org.apache.rocketmq.remoting.exception.RemotingException;
 
-import java.io.UnsupportedEncodingException;
 import java.util.List;
 
 public class Producer {
-    public static void main(String[] args) throws UnsupportedEncodingException {","[{'comment': 'Hello @alexcao2018 , Thanks for your contribution,\r\nhere is a tip,\r\nRemove `UnsupportedEncodingException` before need to `RemotingHelper. DEFAULT_CHARSET` replace `StandardCharsets. UTF_8`, Because there is a compilation exception', 'commenter': 'Oliverwqcwrw'}, {'comment': 'I have fixed what you mentioned in code.', 'commenter': 'alexcao2018'}]"
5153,client/src/main/java/org/apache/rocketmq/client/impl/producer/DefaultMQProducerImpl.java,"@@ -1326,12 +1326,10 @@ public TransactionSendResult sendMessageInTransaction(final Message msg,
                     }
 
                     if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) {
-                        log.info(""executeLocalTransactionBranch return {}"", localTransactionState);
-                        log.info(msg.toString());
+                        log.info(""executeLocalTransactionBranch return: {} message: {}"", localTransactionState, msg.toString());","[{'comment': 'Remove the redundant `toString()` here.', 'commenter': 'aaron-ai'}, {'comment': '@aaron-ai thx for pointing it out,\r\ndone', 'commenter': 'Oliverwqcwrw'}]"
5153,client/src/main/java/org/apache/rocketmq/client/impl/producer/DefaultMQProducerImpl.java,"@@ -1326,12 +1326,10 @@ public TransactionSendResult sendMessageInTransaction(final Message msg,
                     }
 
                     if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) {
-                        log.info(""executeLocalTransactionBranch return {}"", localTransactionState);
-                        log.info(msg.toString());
+                        log.info(""executeLocalTransactionBranch return: {} message: {}"", localTransactionState, msg.toString());
                     }
                 } catch (Throwable e) {
-                    log.info(""executeLocalTransactionBranch exception"", e);
-                    log.info(msg.toString());
+                    log.error(""executeLocalTransactionBranch exception, message: {}"", msg.toString(), e);","[{'comment': 'ditto', 'commenter': 'aaron-ai'}, {'comment': 'done', 'commenter': 'Oliverwqcwrw'}]"
5153,client/src/main/java/org/apache/rocketmq/client/impl/producer/DefaultMQProducerImpl.java,"@@ -1326,12 +1326,10 @@ public TransactionSendResult sendMessageInTransaction(final Message msg,
                     }
 
                     if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) {
-                        log.info(""executeLocalTransactionBranch return {}"", localTransactionState);
-                        log.info(msg.toString());
+                        log.info(""executeLocalTransactionBranch return: {} message: {}"", localTransactionState, msg);
                     }
                 } catch (Throwable e) {
-                    log.info(""executeLocalTransactionBranch exception"", e);
-                    log.info(msg.toString());
+                    log.error(""executeLocalTransactionBranch exception, message: {}"", msg, e);","[{'comment': 'It seems that exception stack cannot be printed correctly here,  please check the method  `org.apache.rocketmq.logging.InternalLogger#error(java.lang.String, java.lang.Throwable)`.\r\n\r\nAlso, `msg` may be very large, logging it in a separate line may be more clear and friendly to GC.', 'commenter': 'caigy'}, {'comment': 'Thanks for your review\r\nLogger supports this format, \r\nmaybe we can just print a few key messages instead of the entire message', 'commenter': 'Oliverwqcwrw'}]"
5153,client/src/main/java/org/apache/rocketmq/client/impl/producer/DefaultMQProducerImpl.java,"@@ -1326,10 +1326,12 @@ public TransactionSendResult sendMessageInTransaction(final Message msg,
                     }
 
                     if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) {
-                        log.info(""executeLocalTransactionBranch return: {} message: {}"", localTransactionState, msg);
+                        log.info(""executeLocalTransactionBranch return: {} messageTopic: {} transactionId: {}"",
+                            localTransactionState, msg.getTopic(), msg.getTransactionId());","[{'comment': 'IMO message tag and key should be logged.', 'commenter': 'caigy'}, {'comment': 'done', 'commenter': 'Oliverwqcwrw'}]"
5171,store/src/main/java/org/apache/rocketmq/store/DefaultMessageStore.java,"@@ -764,7 +764,7 @@ public GetMessageResult getMessage(final String group, final String topic, final
 
                             boolean isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy);
 
-                            if (cqUnit.getQueueOffset() - offset > maxFilterMessageCount) {
+                            if ((cqUnit.getQueueOffset() - offset) * ConsumeQueue.CQ_STORE_UNIT_SIZE > maxFilterMessageCount) {","[{'comment': ""IMO, it's better to modify `maxFilterMessageCount` like this\r\n```java\r\nfinal int maxFilterMessageCount = Math.max(800 /* 16000 / 20 */, maxMsgNums);\r\n```\r\n\r\nThere are 2 kinds of ConsumeQueue in RocketMQ 5.0\r\n`ConsumeQueue` which unit size is 20, and `BatchConsumeQueue` which unit size is 46.\r\n`(cqUnit.getQueueOffset() - offset) * ConsumeQueue.CQ_STORE_UNIT_SIZE` may be confused"", 'commenter': 'HScarb'}, {'comment': ""> For some pulled messages for maxMsgNums could be filter-out. so `Message Count ` is not a good way to limit. Change Count-Limit to Bytes-Limit, you can check code on 4.9.x.\r\n> \r\n> https://github.com/apache/rocketmq/blob/c88686f13e6f4acef1f00c6d3e18589683ec3368/store/src/main/java/org/apache/rocketmq/store/DefaultMessageStore.java#L623\r\n> \r\n> but it seems need some updates on\r\n> \r\n> ```java\r\n> if ((cqUnit.getQueueOffset() - offset) *  CQ_STORE_UNIT_SIZE  > maxFilterMessageCount) {\r\n>     break;\r\n> }\r\n> ```\r\nI'm agree with HScarb cause UNIT_SIZE will be different between BatchConsumeQueue and ConsumeQueue. @francisoliverlee so I wander why we have to use Byte-Limit rather than Count-Limit\r\n"", 'commenter': 'Knowden'}, {'comment': 'count-based comparison is more understandable. If there are implementation-specific subtle differences, there should be a concept to abstract away from them. ', 'commenter': 'lizhanhui'}]"
5182,store/src/main/java/org/apache/rocketmq/store/ha/autoswitch/AutoSwitchHAClient.java,"@@ -444,27 +444,32 @@ protected boolean processReadResult(ByteBuffer byteBufferRead) {
             try {
                 while (true) {
                     int diff = byteBufferRead.position() - AutoSwitchHAClient.this.processPosition;
-                    if (diff >= AutoSwitchHAConnection.MSG_HEADER_SIZE) {
-                        int processPosition = AutoSwitchHAClient.this.processPosition;
-                        int masterState = byteBufferRead.getInt(processPosition + AutoSwitchHAConnection.MSG_HEADER_SIZE - 36);
-                        int bodySize = byteBufferRead.getInt(processPosition + AutoSwitchHAConnection.MSG_HEADER_SIZE - 32);
-                        long masterOffset = byteBufferRead.getLong(processPosition + AutoSwitchHAConnection.MSG_HEADER_SIZE - 28);
-                        int masterEpoch = byteBufferRead.getInt(processPosition + AutoSwitchHAConnection.MSG_HEADER_SIZE - 20);
-                        long masterEpochStartOffset = byteBufferRead.getLong(processPosition + AutoSwitchHAConnection.MSG_HEADER_SIZE - 16);
-                        long confirmOffset = byteBufferRead.getLong(processPosition + AutoSwitchHAConnection.MSG_HEADER_SIZE - 8);
-
+                    if (diff >= AutoSwitchHAConnection.HANDSHAKE_HEADER_SIZE) {
+                        final int processPosition = AutoSwitchHAClient.this.processPosition;
+                        int masterState = byteBufferRead.getInt(processPosition + AutoSwitchHAConnection.HANDSHAKE_HEADER_SIZE - 20);
+                        int bodySize = byteBufferRead.getInt(processPosition + AutoSwitchHAConnection.HANDSHAKE_HEADER_SIZE - 16);
+                        long masterOffset = byteBufferRead.getLong(processPosition + AutoSwitchHAConnection.HANDSHAKE_HEADER_SIZE - 12);
+                        int masterEpoch = byteBufferRead.getInt(processPosition + AutoSwitchHAConnection.HANDSHAKE_HEADER_SIZE - 4);
+                        long masterEpochStartOffset = 0;
+                        long confirmOffset = 0;
+                        // if master send transfer header data, set masterEpochStartOffset and confirmOffset value.
+                        if (masterState == HAConnectionState.TRANSFER.ordinal() && diff >= AutoSwitchHAConnection.TRANSFER_HEADER_SIZE) {
+                            masterEpochStartOffset = byteBufferRead.getLong(processPosition + AutoSwitchHAConnection.TRANSFER_HEADER_SIZE - 16);
+                            confirmOffset = byteBufferRead.getLong(processPosition + AutoSwitchHAConnection.TRANSFER_HEADER_SIZE - 8);
+                        }
                         if (masterState != AutoSwitchHAClient.this.currentState.ordinal()) {
-                            AutoSwitchHAClient.this.processPosition += AutoSwitchHAConnection.MSG_HEADER_SIZE + bodySize;
+                            int headerSize = masterState == HAConnectionState.TRANSFER.ordinal() ? AutoSwitchHAConnection.TRANSFER_HEADER_SIZE : AutoSwitchHAConnection.HANDSHAKE_HEADER_SIZE;
+                            AutoSwitchHAClient.this.processPosition += headerSize + bodySize;
                             AutoSwitchHAClient.this.waitForRunning(1);
                             LOGGER.error(""State not matched, masterState:{}, slaveState:{}, bodySize:{}, offset:{}, masterEpoch:{}, masterEpochStartOffset:{}, confirmOffset:{}"",
                                 masterState, AutoSwitchHAClient.this.currentState, bodySize, masterOffset, masterEpoch, masterEpochStartOffset, confirmOffset);
-                            return true;
+                            return false;
                         }
 
-                        if (diff >= (AutoSwitchHAConnection.MSG_HEADER_SIZE + bodySize)) {
+                        if (diff >= AutoSwitchHAConnection.TRANSFER_HEADER_SIZE + bodySize || diff >= AutoSwitchHAConnection.HANDSHAKE_HEADER_SIZE + bodySize) {","[{'comment': '```suggestion\r\n                        if (diff >= AutoSwitchHAConnection.HANDSHAKE_HEADER_SIZE + bodySize) {\r\n```\r\n\r\nIs it ok to keep only one condition?', 'commenter': 'Oliverwqcwrw'}, {'comment': 'Hi @Oliverwqcwrw thanks for you code review, this Method handle handshake and transfer data. \r\n```\r\nif (diff >= AutoSwitchHAConnection.TRANSFER_HEADER_SIZE + bodySize || diff >= AutoSwitchHAConnection.HANDSHAKE_HEADER_SIZE + bodySize)\r\n```\r\nSo this condition requires judging both cases: handshake and transfer message. And `diff >= AutoSwitchHAConnection.TRANSFER_HEADER_SIZE + bodySize` condition must in front of `diff >= AutoSwitchHAConnection.HANDSHAKE_HEADER_SIZE + bodySize`\r\nIMO, this condition can not remove one of it.', 'commenter': 'mxsm'}, {'comment': 'get it, If this condition is not added, `currentState` may be `TRANSFER`, but diff is less than `TRANSFER_HEADER_SIZE + body size`', 'commenter': 'Oliverwqcwrw'}]"
5193,broker/src/test/java/org/apache/rocketmq/broker/topic/TopicQueueMappingManagerTest.java,"@@ -44,12 +44,12 @@
 public class TopicQueueMappingManagerTest {
     @Mock
     private BrokerController brokerController;
-    private static final String broker1Name = ""broker1"";
+    private static final String BROKER1_NAME = ""broker1"";","[{'comment': '```suggestion\r\n    private static final String BROKER_NAME = ""broker1"";\r\n```\r\nIMO, it could be defined as a brokerName directly because there is only one test broker', 'commenter': 'Oliverwqcwrw'}, {'comment': ""Let's keep this pull request as focused as possible. Keep the code as it is and change where we must, to pass check style. "", 'commenter': 'lizhanhui'}]"
5193,pom.xml,"@@ -278,7 +278,7 @@
                             <inputEncoding>UTF-8</inputEncoding>
                             <consoleOutput>true</consoleOutput>
                             <failsOnError>true</failsOnError>
-                            <includeTestSourceDirectory>false</includeTestSourceDirectory>
+                            <includeTestSourceDirectory>true</includeTestSourceDirectory>","[{'comment': 'Disable checkstyle for test before all module is fixed.', 'commenter': 'aaron-ai'}, {'comment': '```suggestion\r\n                            <includeTestSourceDirectory>false</includeTestSourceDirectory>\r\n```', 'commenter': 'aaron-ai'}]"
5193,.asf.yaml,"@@ -27,7 +27,7 @@ github:
     # Enable squash button
     squash: true
     # Disable merge button
-    merge: true","[{'comment': 'Do not import irrelevant modification.', 'commenter': 'aaron-ai'}]"
5193,README.md,"@@ -1,12 +1,13 @@
-## Apache RocketMQ 
-[![Build Status](https://travis-ci.org/apache/rocketmq.svg?branch=master)](https://travis-ci.org/apache/rocketmq) [![Coverage Status](https://coveralls.io/repos/github/apache/rocketmq/badge.svg?branch=master)](https://coveralls.io/github/apache/rocketmq?branch=master)
-[![CodeCov](https://codecov.io/gh/apache/rocketmq/branch/master/graph/badge.svg)](https://codecov.io/gh/apache/rocketmq)
-[![Maven Central](https://maven-badges.herokuapp.com/maven-central/org.apache.rocketmq/rocketmq-all/badge.svg)](http://search.maven.org/#search%7Cga%7C1%7Corg.apache.rocketmq)
-[![GitHub release](https://img.shields.io/badge/release-download-orange.svg)](https://rocketmq.apache.org/dowloading/releases)
-[![License](https://img.shields.io/badge/license-Apache%202-4EB1BA.svg)](https://www.apache.org/licenses/LICENSE-2.0.html)
-[![Average time to resolve an issue](http://isitmaintained.com/badge/resolution/apache/rocketmq.svg)](http://isitmaintained.com/project/apache/rocketmq ""Average time to resolve an issue"")
-[![Percentage of issues still open](http://isitmaintained.com/badge/open/apache/rocketmq.svg)](http://isitmaintained.com/project/apache/rocketmq ""Percentage of issues still open"")
-[![Twitter Follow](https://img.shields.io/twitter/follow/ApacheRocketMQ?style=social)](https://twitter.com/intent/follow?screen_name=ApacheRocketMQ)","[{'comment': 'ditto', 'commenter': 'aaron-ai'}]"
5193,.asf.yaml,"@@ -27,7 +27,7 @@ github:
     # Enable squash button
     squash: true
     # Disable merge button
-    merge: true
+    merge: false","[{'comment': 'What is the purpose of modifying this parameter?', 'commenter': 'tsunghanjacktsai'}, {'comment': 'Looks some commits from develop branch are merged.', 'commenter': 'lizhanhui'}, {'comment': 'yeah, this submission is the result of rebase the develop branch.', 'commenter': 'nowinkeyy'}]"
5193,README.md,"@@ -1,12 +1,13 @@
-## Apache RocketMQ 
-[![Build Status](https://travis-ci.org/apache/rocketmq.svg?branch=master)](https://travis-ci.org/apache/rocketmq) [![Coverage Status](https://coveralls.io/repos/github/apache/rocketmq/badge.svg?branch=master)](https://coveralls.io/github/apache/rocketmq?branch=master)
-[![CodeCov](https://codecov.io/gh/apache/rocketmq/branch/master/graph/badge.svg)](https://codecov.io/gh/apache/rocketmq)
-[![Maven Central](https://maven-badges.herokuapp.com/maven-central/org.apache.rocketmq/rocketmq-all/badge.svg)](http://search.maven.org/#search%7Cga%7C1%7Corg.apache.rocketmq)
-[![GitHub release](https://img.shields.io/badge/release-download-orange.svg)](https://rocketmq.apache.org/dowloading/releases)
-[![License](https://img.shields.io/badge/license-Apache%202-4EB1BA.svg)](https://www.apache.org/licenses/LICENSE-2.0.html)
-[![Average time to resolve an issue](http://isitmaintained.com/badge/resolution/apache/rocketmq.svg)](http://isitmaintained.com/project/apache/rocketmq ""Average time to resolve an issue"")
-[![Percentage of issues still open](http://isitmaintained.com/badge/open/apache/rocketmq.svg)](http://isitmaintained.com/project/apache/rocketmq ""Percentage of issues still open"")
-[![Twitter Follow](https://img.shields.io/twitter/follow/ApacheRocketMQ?style=social)](https://twitter.com/intent/follow?screen_name=ApacheRocketMQ)
+## Apache RocketMQ
+","[{'comment': 'Is the change relevant to the main purpose of this PR?', 'commenter': 'tsunghanjacktsai'}, {'comment': 'Should have been corrected.', 'commenter': 'lizhanhui'}, {'comment': 'ditto', 'commenter': 'nowinkeyy'}]"
5247,store/src/main/java/org/apache/rocketmq/store/kv/CompactionLog.java,"@@ -0,0 +1,1100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.store.kv;
+
+import com.google.common.collect.Lists;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.lang3.ArrayUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.common.constant.LoggerName;
+import org.apache.rocketmq.common.message.MessageDecoder;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.logging.InternalLogger;
+import org.apache.rocketmq.logging.InternalLoggerFactory;
+import org.apache.rocketmq.store.AppendMessageResult;
+import org.apache.rocketmq.store.AppendMessageStatus;
+import org.apache.rocketmq.store.CompactionAppendMsgCallback;
+import org.apache.rocketmq.store.GetMessageResult;
+import org.apache.rocketmq.store.GetMessageStatus;
+import org.apache.rocketmq.store.MappedFileQueue;
+import org.apache.rocketmq.common.message.MessageExtBrokerInner;
+import org.apache.rocketmq.store.MessageStore;
+import org.apache.rocketmq.store.PutMessageLock;
+import org.apache.rocketmq.store.PutMessageReentrantLock;
+import org.apache.rocketmq.store.PutMessageResult;
+import org.apache.rocketmq.store.PutMessageSpinLock;
+import org.apache.rocketmq.store.PutMessageStatus;
+import org.apache.rocketmq.store.SelectMappedBufferResult;
+import org.apache.rocketmq.store.StoreUtil;
+import org.apache.rocketmq.store.config.BrokerRole;
+import org.apache.rocketmq.store.config.MessageStoreConfig;
+import org.apache.rocketmq.store.logfile.MappedFile;
+import org.apache.rocketmq.store.queue.BatchConsumeQueue;
+import org.apache.rocketmq.store.queue.CqUnit;
+import org.apache.rocketmq.store.queue.ReferredIterator;
+import org.apache.rocketmq.store.queue.SparseConsumeQueue;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Paths;
+import java.security.DigestException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.stream.Collectors;
+
+import static org.apache.rocketmq.common.message.MessageDecoder.BLANK_MAGIC_CODE;
+
+public class CompactionLog {
+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);
+
+    private static final int END_FILE_MIN_BLANK_LENGTH = 4 + 4;
+    private static final int MAX_PULL_MSG_SIZE = 128 * 1024 * 1024;
+    public static final String COMPACTING_SUB_FOLDER = ""compacting"";
+    public static final String REPLICATING_SUB_FOLDER = ""replicating"";
+
+    private final int compactionLogMappedFileSize;
+    private final int compactionCqMappedFileSize;
+    private final String compactionLogFilePath;
+    private final String compactionCqFilePath;
+    private final MessageStore defaultMessageStore;
+    private final CompactionStore compactionStore;
+    private final MessageStoreConfig messageStoreConfig;
+    private final CompactionAppendMsgCallback endMsgCallback;
+    private final String topic;
+    private final int queueId;
+    private final int offsetMapMemorySize;
+    private final PutMessageLock putMessageLock;
+    private final PutMessageLock readMessageLock;
+    private TopicPartitionLog current;
+    private TopicPartitionLog compacting;
+    private TopicPartitionLog replicating;
+    private CompactionPositionMgr positionMgr;
+    private AtomicReference<State> state;
+
+    public CompactionLog(final MessageStore messageStore, final CompactionStore compactionStore, final String topic, final int queueId)
+        throws IOException {
+        this.topic = topic;
+        this.queueId = queueId;
+        this.defaultMessageStore = messageStore;
+        this.compactionStore = compactionStore;
+        this.messageStoreConfig = messageStore.getMessageStoreConfig();
+        this.offsetMapMemorySize = compactionStore.getOffsetMapSize();
+        this.compactionCqMappedFileSize =
+            messageStoreConfig.getCompactionCqMappedFileSize() / BatchConsumeQueue.CQ_STORE_UNIT_SIZE
+                * BatchConsumeQueue.CQ_STORE_UNIT_SIZE;
+        this.compactionLogMappedFileSize = getCompactionLogSize(compactionCqMappedFileSize,
+            messageStoreConfig.getCompactionMappedFileSize());
+        this.compactionLogFilePath = Paths.get(compactionStore.getCompactionLogPath(),
+            topic, String.valueOf(queueId)).toString();
+        this.compactionCqFilePath = compactionStore.getCompactionCqPath();        // batch consume queue already separated
+        this.positionMgr = compactionStore.getPositionMgr();
+
+        this.putMessageLock =
+            messageStore.getMessageStoreConfig().isUseReentrantLockWhenPutMessage() ? new PutMessageReentrantLock() :
+                new PutMessageSpinLock();
+        this.readMessageLock =
+            messageStore.getMessageStoreConfig().isUseReentrantLockWhenPutMessage() ? new PutMessageReentrantLock() :
+                new PutMessageSpinLock();
+        this.endMsgCallback = new CompactionAppendEndMsgCallback();
+        this.state = new AtomicReference<>(State.INITIALIZING);
+        // TODO: join the isr ?
+        log.info(""CompactionLog {}:{} init completed."", topic, queueId);
+    }
+
+    private int getCompactionLogSize(int cqSize, int origLogSize) {
+        int n = origLogSize / cqSize;
+        if (n < 5) {
+            return cqSize * 5;
+        }
+        int m = origLogSize % cqSize;
+        if (m > 0 && m < (cqSize >> 1)) {
+            return n * cqSize;
+        } else {
+            return (n + 1) * cqSize;
+        }
+    }
+
+    public void load(boolean exitOk) throws IOException, RuntimeException {
+        initLogAndCq(exitOk);
+        if (defaultMessageStore.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE
+            && getLog().isMappedFilesEmpty()) {
+            log.info(""{}:{} load compactionLog from remote master"", topic, queueId);
+            loadFromRemoteAsync();
+        } else {
+            state.compareAndSet(State.INITIALIZING, State.NORMAL);
+        }
+    }
+
+    private void initLogAndCq(boolean exitOk) throws IOException, RuntimeException {
+        current = new TopicPartitionLog(this);
+        current.init(exitOk);
+    }
+
+
+    private boolean putMessageFromRemote(byte[] bytes) {
+        ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);
+        // split bytebuffer to avoid encode message again
+        while (byteBuffer.hasRemaining()) {
+            int mark = byteBuffer.position();
+            ByteBuffer bb = byteBuffer.slice();
+            int size = bb.getInt();
+            if (size < 0 || size > byteBuffer.capacity()) {
+                break;
+            } else {
+                bb.limit(size);
+                bb.rewind();
+            }
+
+            MessageExt messageExt = MessageDecoder.decode(bb, false, false);
+            long messageOffset = messageExt.getQueueOffset();
+            long minOffsetInQueue = getCQ().getMinOffsetInQueue();
+            if (getLog().isMappedFilesEmpty() || messageOffset < minOffsetInQueue) {
+                asyncPutMessage(bb, messageExt, replicating);
+            } else {
+                log.info(""{}:{} message offset {} >= minOffsetInQueue {}, stop pull..."",
+                    topic, queueId, messageOffset, minOffsetInQueue);
+                return false;
+            }
+
+            byteBuffer.position(mark + size);
+        }
+
+        return true;
+
+    }
+
+    private void pullMessageFromMaster() throws Exception {
+
+        if (StringUtils.isBlank(compactionStore.getMasterAddr())) {
+            compactionStore.getCompactionSchedule().schedule(() -> {
+                try {
+                    pullMessageFromMaster();
+                } catch (Exception e) {
+                    log.error(""pullMessageFromMaster exception: "", e);
+                }
+            }, 5, TimeUnit.SECONDS);
+            return;
+        }
+
+        replicating = new TopicPartitionLog(this, REPLICATING_SUB_FOLDER);
+        try (MessageFetcher messageFetcher = new MessageFetcher()) {
+            messageFetcher.pullMessageFromMaster(topic, queueId, getCQ().getMinOffsetInQueue(),
+                compactionStore.getMasterAddr(), (currOffset, response) -> {
+                    if (currOffset < 0) {
+                        log.info(""{}:{} current offset {}, stop pull..."", topic, queueId, currOffset);
+                        return false;
+                    }
+                    return putMessageFromRemote(response.getBody());
+//                    positionMgr.setOffset(topic, queueId, currOffset);
+                });
+        }
+
+        // merge files
+        if (getLog().isMappedFilesEmpty()) {
+            replaceFiles(getLog().getMappedFiles(), current, replicating);
+        } else if (replicating.getLog().isMappedFilesEmpty()) {
+            log.info(""replicating message is empty"");   //break
+        } else {
+            List<MappedFile> newFiles = Lists.newArrayList();
+            List<MappedFile> toCompactFiles = Lists.newArrayList(replicating.getLog().getMappedFiles());
+            putMessageLock.lock();
+            try {
+                // combine current and replicating to mappedFileList
+                newFiles = Lists.newArrayList(getLog().getMappedFiles());
+                toCompactFiles.addAll(newFiles);  //all from current
+                current.roll(toCompactFiles.size() * compactionLogMappedFileSize);
+            } catch (Throwable e) {
+                log.error(""roll log and cq exception: "", e);
+            } finally {
+                putMessageLock.unlock();
+            }
+
+            try {
+                // doCompaction with current and replicating
+                compactAndReplace(new ProcessFileList(toCompactFiles, newFiles));
+            } catch (Throwable e) {
+                log.error(""do merge replicating and current exception: "", e);
+            }
+        }
+
+        // cleanReplicatingResource, force clean cq
+        replicating.clean(false, true);
+
+//        positionMgr.setOffset(topic, queueId, currentPullOffset);
+        state.compareAndSet(State.INITIALIZING, State.NORMAL);
+    }
+    private void loadFromRemoteAsync() {
+        compactionStore.getCompactionSchedule().submit(() -> {
+            try {
+                pullMessageFromMaster();
+            } catch (Exception e) {
+                log.error(""fetch message from master exception: "", e);
+            }
+        });
+
+        // update (currentStatus) = LOADING
+
+        // request => get (start, end)
+        // pull message => current message offset > end
+        // done
+        // positionMgr.persist();
+
+        // update (currentStatus) = RUNNING
+    }
+
+    private long nextOffsetCorrection(long oldOffset, long newOffset) {
+        long nextOffset = oldOffset;
+        if (messageStoreConfig.getBrokerRole() != BrokerRole.SLAVE || messageStoreConfig.isOffsetCheckInSlave()) {
+            nextOffset = newOffset;
+        }
+        return nextOffset;
+    }
+
+    private boolean checkInDiskByCommitOffset(long offsetPy, long maxOffsetPy) {
+        long memory = (long) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE *
+            (this.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / 100.0));
+        return (maxOffsetPy - offsetPy) > memory;
+    }
+
+    private boolean isTheBatchFull(int sizePy, int unitBatchNum, int maxMsgNums, long maxMsgSize,
+        int bufferTotal, int messageTotal, boolean isInDisk) {
+
+        if (0 == bufferTotal || 0 == messageTotal) {
+            return false;
+        }
+
+        if (messageTotal + unitBatchNum > maxMsgNums) {
+            return true;
+        }
+
+        if (bufferTotal + sizePy > maxMsgSize) {
+            return true;
+        }
+
+        if (isInDisk) {
+            if ((bufferTotal + sizePy) > this.messageStoreConfig.getMaxTransferBytesOnMessageInDisk()) {
+                return true;
+            }
+
+            if (messageTotal > this.messageStoreConfig.getMaxTransferCountOnMessageInDisk() - 1) {
+                return true;
+            }
+        } else {
+            if ((bufferTotal + sizePy) > this.messageStoreConfig.getMaxTransferBytesOnMessageInMemory()) {
+                return true;
+            }
+
+            if (messageTotal > this.messageStoreConfig.getMaxTransferCountOnMessageInMemory() - 1) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public long rollNextFile(final long offset) {
+        return offset + compactionLogMappedFileSize - offset % compactionLogMappedFileSize;
+    }
+
+    boolean shouldRetainMsg(final MessageExt msgExt, final OffsetMap map) throws DigestException {
+        if (msgExt.getQueueOffset() > map.getLastOffset()) {
+            return true;
+        }
+
+        String key = msgExt.getKeys();
+        if (StringUtils.isNotBlank(key)) {
+            boolean keyNotExistOrOffsetBigger = msgExt.getQueueOffset() >= map.get(key);
+            boolean hasBody = ArrayUtils.isNotEmpty(msgExt.getBody());
+            return keyNotExistOrOffsetBigger && hasBody;
+        } else {
+            log.error(""message has no keys"");
+            return false;
+        }
+    }
+
+    public void checkAndPutMessage(final SelectMappedBufferResult selectMappedBufferResult, final MessageExt msgExt,
+        final OffsetMap offsetMap, final TopicPartitionLog tpLog)
+        throws DigestException {
+        if (shouldRetainMsg(msgExt, offsetMap)) {
+            asyncPutMessage(selectMappedBufferResult.getByteBuffer(), msgExt, tpLog);
+        }
+    }
+
+    public CompletableFuture<PutMessageResult> asyncPutMessage(final SelectMappedBufferResult selectMappedBufferResult) {
+        return asyncPutMessage(selectMappedBufferResult, current);
+    }
+
+    public CompletableFuture<PutMessageResult> asyncPutMessage(final SelectMappedBufferResult selectMappedBufferResult,
+        final TopicPartitionLog tpLog) {
+        MessageExt msgExt = MessageDecoder.decode(selectMappedBufferResult.getByteBuffer(), false, false);
+        return asyncPutMessage(selectMappedBufferResult.getByteBuffer(), msgExt, tpLog);
+    }
+
+    public CompletableFuture<PutMessageResult> asyncPutMessage(final ByteBuffer msgBuffer,
+        final MessageExt msgExt, final TopicPartitionLog tpLog) {
+
+        // fix duplicate
+        if (tpLog.getCQ().getMaxOffsetInQueue() - 1 >= msgExt.getQueueOffset()) {
+            return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null));
+        }
+
+        if (StringUtils.isBlank(msgExt.getKeys())) {
+            log.warn(""message {}-{}:{} have no key, will not put in compaction log"",
+                msgExt.getTopic(), msgExt.getQueueId(), msgExt.getMsgId());
+            return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null));
+        }
+
+        putMessageLock.lock();
+        try {
+            long beginTime = System.nanoTime();
+
+            if (tpLog.isEmptyOrCurrentFileFull()) {
+                try {
+                    tpLog.roll();
+                } catch (IOException e) {
+                    log.error(""create mapped file or consumerQueue exception: "", e);
+                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPPED_FILE_FAILED, null));
+                }
+            }
+
+            MappedFile mappedFile = tpLog.getLog().getLastMappedFile();
+
+            CompactionAppendMsgCallback callback = new CompactionAppendMessageCallback(msgExt, tpLog.getCQ());
+            AppendMessageResult result = mappedFile.appendMessage(msgBuffer, callback);
+
+            switch (result.getStatus()) {
+                case PUT_OK:
+                    break;
+                case END_OF_FILE:
+                    try {
+                        tpLog.roll();
+                    } catch (IOException e) {
+                        log.error(""create mapped file2 error, topic: {}, clientAddr: {}"", msgExt.getTopic(), msgExt.getBornHostString());
+                        return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPPED_FILE_FAILED, result));
+                    }
+                    mappedFile = tpLog.getLog().getLastMappedFile();
+                    result = mappedFile.appendMessage(msgBuffer, callback);
+                    break;
+                default:
+                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result));
+            }
+
+            return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.PUT_OK, result));
+        } finally {
+            putMessageLock.unlock();
+        }
+    }
+
+    private SelectMappedBufferResult getMessage(final long offset, final int size) {
+
+        MappedFile mappedFile = this.getLog().findMappedFileByOffset(offset, offset == 0);
+        if (mappedFile != null) {
+            int pos = (int) (offset % compactionLogMappedFileSize);
+            return mappedFile.selectMappedBuffer(pos, size);
+        }
+        return null;
+    }
+
+    private boolean validateCqUnit(CqUnit cqUnit) {
+        return cqUnit.getPos() >= 0
+            && cqUnit.getSize() > 0
+            && cqUnit.getQueueOffset() >= 0
+            && cqUnit.getBatchNum() > 0;
+    }
+
+    public GetMessageResult getMessage(final String group, final String topic, final int queueId, final long offset,
+        final int maxMsgNums, final int maxTotalMsgSize) {
+        readMessageLock.lock();
+        try {
+            long beginTime = System.nanoTime();
+
+            GetMessageStatus status;
+            long nextBeginOffset = offset;
+            long minOffset = 0;
+            long maxOffset = 0;
+
+            GetMessageResult getResult = new GetMessageResult();
+
+            final long maxOffsetPy = getLog().getMaxOffset();
+
+            SparseConsumeQueue consumeQueue = getCQ();
+            if (consumeQueue != null) {
+                minOffset = consumeQueue.getMinOffsetInQueue();
+                maxOffset = consumeQueue.getMaxOffsetInQueue();
+
+                if (maxOffset == 0) {
+                    status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;
+                    nextBeginOffset = nextOffsetCorrection(offset, 0);
+                } else if (offset == maxOffset) {
+                    status = GetMessageStatus.OFFSET_OVERFLOW_ONE;
+                    nextBeginOffset = nextOffsetCorrection(offset, offset);
+                } else if (offset > maxOffset) {
+                    status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;
+                    if (0 == minOffset) {
+                        nextBeginOffset = nextOffsetCorrection(offset, minOffset);
+                    } else {
+                        nextBeginOffset = nextOffsetCorrection(offset, maxOffset);
+                    }
+                } else {
+
+                    long maxPullSize = Math.max(maxTotalMsgSize, 100);
+                    if (maxPullSize > MAX_PULL_MSG_SIZE) {
+                        log.warn(""The max pull size is too large maxPullSize={} topic={} queueId={}"",
+                            maxPullSize, topic, queueId);
+                        maxPullSize = MAX_PULL_MSG_SIZE;
+                    }
+                    status = GetMessageStatus.NO_MATCHED_MESSAGE;
+                    long maxPhyOffsetPulling = 0;
+                    int cqFileNum = 0;
+
+                    while (getResult.getBufferTotalSize() <= 0 && nextBeginOffset < maxOffset
+                        && cqFileNum++ < this.messageStoreConfig.getTravelCqFileNumWhenGetMessage()) {
+                        ReferredIterator<CqUnit> bufferConsumeQueue = consumeQueue.iterateFromOrNext(nextBeginOffset);
+
+                        if (bufferConsumeQueue == null) {
+                            status = GetMessageStatus.OFFSET_FOUND_NULL;
+                            nextBeginOffset = nextOffsetCorrection(nextBeginOffset, consumeQueue.rollNextFile(nextBeginOffset));
+                            log.warn(""consumer request topic:{}, offset:{}, minOffset:{}, maxOffset:{}, ""
+                                    + ""but access logic queue failed. correct nextBeginOffset to {}"",
+                                topic, offset, minOffset, maxOffset, nextBeginOffset);
+                            break;
+                        }
+
+                        try {
+                            long nextPhyFileStartOffset = Long.MIN_VALUE;
+                            while (bufferConsumeQueue.hasNext() && nextBeginOffset < maxOffset) {
+                                CqUnit cqUnit = bufferConsumeQueue.next();
+                                if (!validateCqUnit(cqUnit)) {
+                                    break;
+                                }
+                                long offsetPy = cqUnit.getPos();
+                                int sizePy = cqUnit.getSize();
+
+                                boolean isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy);
+
+                                if (isTheBatchFull(sizePy, cqUnit.getBatchNum(), maxMsgNums, maxPullSize,
+                                    getResult.getBufferTotalSize(), getResult.getMessageCount(), isInDisk)) {
+                                    break;
+                                }
+
+                                if (getResult.getBufferTotalSize() >= maxPullSize) {
+                                    break;
+                                }
+
+                                maxPhyOffsetPulling = offsetPy;
+
+                                //Be careful, here should before the isTheBatchFull
+                                nextBeginOffset = cqUnit.getQueueOffset() + cqUnit.getBatchNum();
+
+                                if (nextPhyFileStartOffset != Long.MIN_VALUE) {
+                                    if (offsetPy < nextPhyFileStartOffset) {
+                                        continue;
+                                    }
+                                }
+
+                                SelectMappedBufferResult selectResult = getMessage(offsetPy, sizePy);
+                                if (null == selectResult) {
+                                    if (getResult.getBufferTotalSize() == 0) {
+                                        status = GetMessageStatus.MESSAGE_WAS_REMOVING;
+                                    }
+
+                                    // nextPhyFileStartOffset = this.commitLog.rollNextFile(offsetPy);
+                                    nextPhyFileStartOffset = rollNextFile(offsetPy);
+                                    continue;
+                                }
+
+                                getResult.addMessage(selectResult, cqUnit.getQueueOffset(), cqUnit.getBatchNum());
+                                status = GetMessageStatus.FOUND;
+                                nextPhyFileStartOffset = Long.MIN_VALUE;
+                            }
+                        } finally {
+                            bufferConsumeQueue.release();
+                        }
+                    }
+
+                    long diff = maxOffsetPy - maxPhyOffsetPulling;
+                    long memory = (long)(StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE * (this.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / 100.0));
+                    getResult.setSuggestPullingFromSlave(diff > memory);
+                }
+            } else {
+                status = GetMessageStatus.NO_MATCHED_LOGIC_QUEUE;
+                nextBeginOffset = nextOffsetCorrection(offset, 0);
+            }
+
+            getResult.setStatus(status);
+            getResult.setNextBeginOffset(nextBeginOffset);
+            getResult.setMaxOffset(maxOffset);
+            getResult.setMinOffset(minOffset);
+            return getResult;
+        } finally {
+            readMessageLock.unlock();
+        }
+    }
+
+    ProcessFileList getCompactionFile() {
+        List<MappedFile> mappedFileList = Lists.newArrayList(getLog().getMappedFiles());
+        if (mappedFileList.size() < 2) {
+            return null;
+        }
+
+        List<MappedFile> toCompactFiles = mappedFileList.subList(0, mappedFileList.size() - 1);
+
+        //exclude the last writing file
+        List<MappedFile> newFiles = Lists.newArrayList();
+        for (int i = 0; i < mappedFileList.size() - 1; i++) {
+            MappedFile mf = mappedFileList.get(i);
+            long maxQueueOffsetInFile = getCQ().getMaxMsgOffsetFromFile(mf.getFile().getName());
+            if (maxQueueOffsetInFile > positionMgr.getOffset(topic, queueId)) {
+                newFiles.add(mf);
+            }
+        }
+
+        if (newFiles.isEmpty()) {
+            return null;
+        }
+
+        return new ProcessFileList(toCompactFiles, newFiles);
+    }
+
+    void compactAndReplace(ProcessFileList compactFiles) throws Throwable {
+        if (compactFiles == null || compactFiles.isEmpty()) {
+            return;
+        }
+
+        long startTime = System.nanoTime();
+        OffsetMap offsetMap = getOffsetMap(compactFiles.newFiles);
+        compaction(compactFiles.toCompactFiles, offsetMap);
+        replaceFiles(compactFiles.toCompactFiles, current, compacting);
+        positionMgr.setOffset(topic, queueId, offsetMap.lastOffset);
+        positionMgr.persist();
+        compacting.clean(false, false);
+        log.info(""this compaction elapsed {} milliseconds"",
+            TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));
+
+    }
+
+    void doCompaction() {
+        if (!state.compareAndSet(State.NORMAL, State.COMPACTING)) {
+            log.warn(""compactionLog state is {}, skip this time"", state.get());
+            return;
+        }
+
+        try {
+            compactAndReplace(getCompactionFile());
+        } catch (Throwable e) {
+            log.error(""do compaction exception: "", e);
+        }
+        state.compareAndSet(State.COMPACTING, State.NORMAL);
+    }
+
+    protected OffsetMap getOffsetMap(List<MappedFile> mappedFileList) throws NoSuchAlgorithmException, DigestException {
+        OffsetMap offsetMap = new OffsetMap(offsetMapMemorySize);
+
+        for (MappedFile mappedFile : mappedFileList) {
+            Iterator<SelectMappedBufferResult> iterator = mappedFile.iterator(0);
+            while (iterator.hasNext()) {
+                SelectMappedBufferResult smb = null;
+                try {
+                    smb = iterator.next();
+                    //decode bytebuffer
+                    MessageExt msg = MessageDecoder.decode(smb.getByteBuffer(), true, false);
+                    if (msg != null) {
+                        ////get key & offset and put to offsetMap
+                        if (msg.getQueueOffset() > positionMgr.getOffset(topic, queueId)) {
+                            offsetMap.put(msg.getKeys(), msg.getQueueOffset());
+                        }
+                    } else {
+                        // msg is null indicate that file is end
+                        break;
+                    }
+                } catch (DigestException e) {
+                    log.error(""offsetMap put exception: "", e);
+                    throw e;
+                } finally {
+                    if (smb != null) {
+                        smb.release();
+                    }
+                }
+            }
+        }
+        return offsetMap;
+    }
+
+    protected void putEndMessage(MappedFileQueue mappedFileQueue) {
+        MappedFile lastFile = mappedFileQueue.getLastMappedFile();
+        if (!lastFile.isFull()) {
+            lastFile.appendMessage(ByteBuffer.allocate(0), endMsgCallback);
+        }
+    }
+
+    protected void compaction(List<MappedFile> mappedFileList, OffsetMap offsetMap) throws DigestException {
+        compacting = new TopicPartitionLog(this, COMPACTING_SUB_FOLDER);
+
+        for (MappedFile mappedFile : mappedFileList) {
+            Iterator<SelectMappedBufferResult> iterator = mappedFile.iterator(0);
+            while (iterator.hasNext()) {
+                SelectMappedBufferResult smb = null;
+                try {
+                    smb = iterator.next();
+                    MessageExt msgExt = MessageDecoder.decode(smb.getByteBuffer(), true, true);
+                    if (msgExt == null) {
+                        // file end
+                        break;
+                    } else {
+                        checkAndPutMessage(smb, msgExt, offsetMap, compacting);
+                    }
+                } finally {
+                    if (smb != null) {
+                        smb.release();
+                    }
+                }
+            }
+        }
+        putEndMessage(compacting.getLog());
+    }
+
+    protected void replaceFiles(List<MappedFile> mappedFileList, TopicPartitionLog current,
+        TopicPartitionLog newLog) {
+
+        MappedFileQueue dest = current.getLog();
+        MappedFileQueue src = newLog.getLog();
+
+        long beginTime = System.nanoTime();
+//        List<String> fileNameToReplace = mappedFileList.stream()
+//            .map(m -> m.getFile().getName())
+//            .collect(Collectors.toList());
+
+        List<String> fileNameToReplace = dest.getMappedFiles().stream()
+            .filter(mappedFileList::contains)
+            .map(mf -> mf.getFile().getName())
+            .collect(Collectors.toList());
+
+        mappedFileList.forEach(MappedFile::renameToDelete);
+
+        src.getMappedFiles().forEach(mappedFile -> {
+            try {
+                mappedFile.moveToParent();
+            } catch (IOException e) {
+                log.error(""move file {} to parent directory exception: "", mappedFile.getFileName());
+            }
+        });
+
+        dest.getMappedFiles().stream()
+            .filter(m -> !mappedFileList.contains(m))
+            .forEach(m -> src.getMappedFiles().add(m));
+
+        readMessageLock.lock();
+        try {
+            mappedFileList.forEach(mappedFile -> mappedFile.destroy(1000));
+
+            dest.getMappedFiles().clear();
+            dest.getMappedFiles().addAll(src.getMappedFiles());
+            src.getMappedFiles().clear();
+
+            replaceCqFiles(getCQ(), newLog.getCQ(), fileNameToReplace);
+
+            log.info(""replace file elapsed {} milliseconds"",
+                TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beginTime));
+        } finally {
+            readMessageLock.unlock();
+        }
+    }
+
+    protected void replaceCqFiles(SparseConsumeQueue currentBcq, SparseConsumeQueue compactionBcq,
+        List<String> fileNameToReplace) {
+        long beginTime = System.nanoTime();
+
+        MappedFileQueue currentMq = currentBcq.getMappedFileQueue();
+        MappedFileQueue compactMq = compactionBcq.getMappedFileQueue();
+        List<MappedFile> fileListToDelete = currentMq.getMappedFiles().stream().filter(m ->
+            fileNameToReplace.contains(m.getFile().getName())).collect(Collectors.toList());
+
+        fileListToDelete.forEach(MappedFile::renameToDelete);
+        compactMq.getMappedFiles().forEach(mappedFile -> {
+            try {
+                mappedFile.moveToParent();
+            } catch (IOException e) {
+                log.error(""move consume queue file {} to parent directory exception: "", mappedFile.getFileName(), e);
+            }
+        });
+
+        currentMq.getMappedFiles().stream()
+            .filter(m -> !fileListToDelete.contains(m))
+            .forEach(m -> compactMq.getMappedFiles().add(m));
+
+        fileListToDelete.forEach(mappedFile -> mappedFile.destroy(1000));
+
+        currentMq.getMappedFiles().clear();
+        currentMq.getMappedFiles().addAll(compactMq.getMappedFiles());
+        compactMq.getMappedFiles().clear();
+
+        currentBcq.refresh();
+        log.info(""replace consume queue file elapsed {} millsecs."",
+            TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beginTime));
+    }
+
+    public MappedFileQueue getLog() {
+        return current.mappedFileQueue;
+    }
+
+    public SparseConsumeQueue getCQ() {
+        return current.consumeQueue;
+    }
+
+//    public SparseConsumeQueue getCompactionScq() {
+//        return compactionScq;
+//    }
+
+    public void flushCQ(int flushLeastPages) {
+        getCQ().flush(flushLeastPages);
+    }
+
+    static class CompactionAppendEndMsgCallback implements CompactionAppendMsgCallback {
+        @Override
+        public AppendMessageResult doAppend(ByteBuffer bbDest, long fileFromOffset, int maxBlank, ByteBuffer bbSrc) {
+            ByteBuffer endInfo = ByteBuffer.allocate(END_FILE_MIN_BLANK_LENGTH);
+            endInfo.putInt(maxBlank);
+            endInfo.putInt(BLANK_MAGIC_CODE);
+            return new AppendMessageResult(AppendMessageStatus.END_OF_FILE,
+                fileFromOffset + bbDest.position(), maxBlank, System.currentTimeMillis());
+        }
+    }
+
+    static class CompactionAppendMessageCallback implements CompactionAppendMsgCallback {
+        private final MessageExt msgExt;
+        private final SparseConsumeQueue bcq;
+
+        public CompactionAppendMessageCallback(MessageExt msgExt, SparseConsumeQueue bcq) {
+            this.msgExt = msgExt;
+            this.bcq = bcq;
+        }
+
+        @Override
+        public AppendMessageResult doAppend(ByteBuffer bbDest, long fileFromOffset, int maxBlank, ByteBuffer bbSrc) {
+
+            String topic = msgExt.getTopic();
+            int queueId =  msgExt.getQueueId();
+            String tags = msgExt.getTags();
+            long storeTimestamp = msgExt.getStoreTimestamp();
+
+            final int msgLen = bbSrc.getInt(0);
+            MappedFile bcqMappedFile = bcq.getMappedFileQueue().getLastMappedFile();
+            if (bcqMappedFile.getWrotePosition() + BatchConsumeQueue.CQ_STORE_UNIT_SIZE >= bcqMappedFile.getFileSize()
+                || (msgLen + END_FILE_MIN_BLANK_LENGTH) > maxBlank) {      //bcq will full or log will full
+
+                bcq.putEndPositionInfo(bcqMappedFile);
+
+                bbDest.putInt(maxBlank);
+                bbDest.putInt(BLANK_MAGIC_CODE);
+                return new AppendMessageResult(AppendMessageStatus.END_OF_FILE,
+                    fileFromOffset + bbDest.position(), maxBlank, storeTimestamp);
+            }
+
+            //get logic offset and physical offset
+            int logicOffsetPos = 4 + 4 + 4 + 4 + 4;
+            long logicOffset = bbSrc.getLong(logicOffsetPos);
+            int destPos = bbDest.position();
+            long physicalOffset = fileFromOffset + bbDest.position();
+            bbSrc.rewind();
+            bbSrc.limit(msgLen);
+            bbDest.put(bbSrc);
+            bbDest.putLong(destPos + logicOffsetPos + 8, physicalOffset);       //replace physical offset
+
+            boolean result = bcq.putBatchMessagePositionInfo(physicalOffset, msgLen,
+                MessageExtBrokerInner.tagsString2tagsCode(tags), storeTimestamp, logicOffset, (short)1);
+            if (!result) {
+                log.error(""put message {}-{} position info failed"", topic, queueId);
+            }
+            return new AppendMessageResult(AppendMessageStatus.PUT_OK, physicalOffset, msgLen, storeTimestamp);
+        }
+    }
+
+    static class OffsetMap {
+        private ByteBuffer dataBytes;
+        private int capacity;
+        private int entrySize;
+        private int entryNum;
+        private MessageDigest digest;
+        private int hashSize;
+        private long lastOffset;
+        private byte[] hash1;
+        private byte[] hash2;
+
+        public OffsetMap(int memorySize) throws NoSuchAlgorithmException {
+            this(memorySize, MessageDigest.getInstance(""MD5""));","[{'comment': '## Use of a broken or risky cryptographic algorithm\n\nCryptographic algorithm [MD5](1) is weak and should not be used.\n\n[Show more details](https://github.com/apache/rocketmq/security/code-scanning/7)', 'commenter': 'github-advanced-security[bot]'}]"
5260,broker/src/main/java/org/apache/rocketmq/broker/processor/SendMessageProcessor.java,"@@ -245,6 +249,16 @@ public RemotingCommand sendMessage(final ChannelHandlerContext ctx,
         }
 
         MessageAccessor.setProperties(msgInner, oriProps);
+
+        DeletePolicy deletePolicy = DeletePolicyUtils.getDeletePolicy(Optional.of(topicConfig));
+        if (Objects.equals(deletePolicy, DeletePolicy.COMPACTION)) {
+            if (StringUtils.isBlank(msgInner.getKeys())) {
+                response.setCode(ResponseCode.MESSAGE_ILLEGAL);
+                response.setRemark(""the message don't have message key"");","[{'comment': '```suggestion\r\n                response.setRemark(""Required message key is missing"");\r\n```', 'commenter': 'lizhanhui'}]"
5260,common/src/main/java/org/apache/rocketmq/common/attribute/DeletePolicy.java,"@@ -0,0 +1,22 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.rocketmq.common.attribute;
+
+public enum DeletePolicy {
+    NORMAL,","[{'comment': 'STANDARD may be more appropriate than NORMAL.', 'commenter': 'lizhanhui'}]"
5260,.gitignore,"@@ -13,6 +13,7 @@ devenv
 .DS_Store
 localbin
 nohup.out
+docker/","[{'comment': 'If this ignore entry applies to your local development only, best to add it to your user profile .gitignore', 'commenter': 'lizhanhui'}]"
5260,common/src/main/java/org/apache/rocketmq/common/attribute/DeletePolicy.java,"@@ -0,0 +1,22 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.rocketmq.common.attribute;
+
+public enum DeletePolicy {","[{'comment': 'It looks weird DeletePolicy has variants DELETE and COMPACTION, how about renaming DeletePolicy to ReclaimPolicy?', 'commenter': 'lizhanhui'}, {'comment': 'maybe `CleanupPolicy` is more readable ', 'commenter': 'ltamber'}]"
5325,example/src/main/java/org/apache/rocketmq/example/benchmark/Consumer.java,"@@ -17,11 +17,20 @@
 
 package org.apache.rocketmq.example.benchmark;
 
+import java.io.IOException;","[{'comment': ""I think it's best not to change the order of the previous packages"", 'commenter': 'Oliverwqcwrw'}]"
5325,test/src/main/java/org/apache/rocketmq/test/util/MQAdminTestUtils.java,"@@ -17,10 +17,15 @@
 
 package org.apache.rocketmq.test.util;
 
+import java.util.HashMap;","[{'comment': 'ditto', 'commenter': 'Oliverwqcwrw'}, {'comment': 'I use idea tool to fromat the code, so maybe change the the order of the previous packages. I think when need to remove the useless import packages,The functionality of idea is recommended instead of manual operation', 'commenter': 'mxsm'}, {'comment': 'It will be OK if the sort is automatic', 'commenter': 'lizhanhui'}]"
5325,tools/src/test/java/org/apache/rocketmq/tools/command/acl/UpdateAccessConfigSubCommandTest.java,"@@ -49,7 +49,7 @@ public void testExecute() {
         // Note: Posix parser is capable of handling values that contains '='.
         final CommandLine commandLine =
             ServerUtil.parseCmdLine(""mqadmin "" + cmd.commandName(), subargs,
-                cmd.buildCommandlineOptions(options), new PosixParser());
+                cmd.buildCommandlineOptions(options), new DefaultParser());","[{'comment': ""DefaultParser cannot handle values that contain '='. Need to investigate if there is an option to overcome this issue."", 'commenter': 'lizhanhui'}, {'comment': 'See this failure case\r\n1) testExecute(org.apache.rocketmq.tools.command.acl.UpdateAccessConfigSubCommandTest)\r\njava.lang.SecurityException: Test code should never call System.exit()\r\n\tat com.google.testing.junit.runner.util.GoogleTestSecurityManager.checkExit(GoogleTestSecurityManager.java:34)\r\n\tat java.lang.Runtime.exit(Runtime.java:107)\r\n\tat java.lang.System.exit(System.java:973)\r\n\tat org.apache.rocketmq.srvutil.ServerUtil.parseCmdLine(ServerUtil.java:56)\r\n\tat org.apache.rocketmq.tools.command.acl.UpdateAccessConfigSubCommandTest.testExecute(UpdateAccessConfigSubCommandTest.java:[51](https://github.com/apache/rocketmq/actions/runs/3255627851/jobs/5345142856#step:4:52))', 'commenter': 'lizhanhui'}, {'comment': ""> DefaultParser cannot handle values that contain '='. Need to investigate if there is an option to overcome this issue.\r\n\r\nI will"", 'commenter': 'mxsm'}, {'comment': ""hi @lizhanhui The following validation DefaultParser can handle values that contain '='. Please  see if this validation is correct.\r\n**case1:**\r\n![image](https://user-images.githubusercontent.com/15797831/196077246-5026435e-2700-4960-acc3-76734bc18778.png)\r\ndebug result:\r\n![image](https://user-images.githubusercontent.com/15797831/196077419-bd9dab1e-d13f-462f-8624-0d66390deed9.png)\r\n**case 2:**\r\n![image](https://user-images.githubusercontent.com/15797831/196077583-0eb69ad5-ce7a-4d83-a86c-5d61de93e059.png)\r\ndebug result:\r\n![image](https://user-images.githubusercontent.com/15797831/196077532-18d80f54-5901-48de-aa4f-281a52ca7093.png)\r\n\r\n"", 'commenter': 'mxsm'}, {'comment': 'OK. Please look into the failed test case anyway.', 'commenter': 'lizhanhui'}, {'comment': '@lizhanhui  I am watching', 'commenter': 'mxsm'}]"
5357,broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java,"@@ -1517,8 +1517,12 @@ private RemotingCommand getConsumeStats(ChannelHandlerContext ctx,
                     }
                 }
 
+                long pullOffset = this.brokerController.getConsumerOffsetManager().queryPullOffset(
+                    requestHeader.getConsumerGroup(), topic, i);
+
                 offsetWrapper.setBrokerOffset(brokerOffset);
                 offsetWrapper.setConsumerOffset(consumerOffset);
+                offsetWrapper.setPullOffset(pullOffset >= 0 ? pullOffset : 0);","[{'comment': 'It needs to check if pullOffset is bigger than consumerOffset. Otherwise, inflight will be negative when the user resets offset.', 'commenter': 'ShadowySpirits'}, {'comment': 'ok', 'commenter': 'lizhimins'}]"
5416,broker/src/main/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageBridge.java,"@@ -303,9 +303,7 @@ private TopicConfig selectTopicConfig(String topic) {
 
     public boolean writeOp(Integer queueId,Message message) {
         MessageQueue opQueue;
-        if (opQueueMap.containsKey(queueId)) {
-            opQueue = opQueueMap.get(queueId);
-        } else {
+        if ((opQueue = opQueueMap.get(queueId)) == null) {","[{'comment': 'Assigning `opQueue` at first may be better than initializing it in `if` condition.', 'commenter': 'caigy'}, {'comment': ""Ok, I think this can reduce one query, although the time complexity is only O(1) and I don't think it's a good practice to judge first and then get it. If the opQueueMap has a removal operation, there will be problems."", 'commenter': 'CLFutureX'}]"
5435,namesrv/src/main/java/org/apache/rocketmq/namesrv/processor/DefaultRequestProcessor.java,"@@ -635,40 +635,40 @@ private RemotingCommand updateConfig(ChannelHandlerContext ctx, RemotingCommand
         return response;
     }
 
-    private RemotingCommand getConfig(ChannelHandlerContext ctx, RemotingCommand request) {
+  private RemotingCommand getConfig(ChannelHandlerContext ctx, RemotingCommand request) {
         final RemotingCommand response = RemotingCommand.createResponseCommand(null);
 
         String content = this.namesrvController.getConfiguration().getAllConfigsFormatString();
+        if (getResponse(response, content)) {
+            return response;
+        }
+
+        response.setCode(ResponseCode.SUCCESS);
+        response.setRemark(null);
+        return response;
+    }
+
+    private boolean getResponse(RemotingCommand response, String content) {","[{'comment': ""Well, returning true/false with the name `getResponse` here seems a bit odd, since it returns true only if there's an exception being caught. How about considering a better method name to make it more readable?"", 'commenter': 'tsunghanjacktsai'}, {'comment': '> \r\nThanks，I will consider a better method name for it!\r\n', 'commenter': '123monkey'}, {'comment': 'I changed it,you can see it!\r\n private RemotingCommand getConfig(ChannelHandlerContext ctx, RemotingCommand request) {\r\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\r\n\r\n        String content = this.namesrvController.getConfiguration().getAllConfigsFormatString();\r\n        setResponse(response, content);\r\n        return response;\r\n    }\r\n\r\n    private void setResponse(RemotingCommand response, String content) {\r\n        if (StringUtils.isNotBlank(content)) {\r\n            try {\r\n                response.setBody(content.getBytes(MixAll.DEFAULT_CHARSET));\r\n            } catch (UnsupportedEncodingException e) {\r\n                log.error(""getConfig error, "", e);\r\n                response.setCode(ResponseCode.SYSTEM_ERROR);\r\n                response.setRemark(""UnsupportedEncodingException "" + e);\r\n            }\r\n        }\r\n        response.setCode(ResponseCode.SUCCESS);\r\n        response.setRemark(null);\r\n    }\r\n\r\n\r\n    private RemotingCommand getClientConfigs(ChannelHandlerContext ctx, RemotingCommand request) {\r\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\r\n        final GetRemoteClientConfigBody body = GetRemoteClientConfigBody.decode(request.getBody(), GetRemoteClientConfigBody.class);\r\n\r\n        String content = this.namesrvController.getConfiguration().getClientConfigsFormatString(body.getKeys());\r\n        setResponse(response, content);\r\n        return response;\r\n    }', 'commenter': '123monkey'}]"
5435,namesrv/src/main/java/org/apache/rocketmq/namesrv/processor/DefaultRequestProcessor.java,"@@ -635,44 +635,35 @@ private RemotingCommand updateConfig(ChannelHandlerContext ctx, RemotingCommand
         return response;
     }
 
-    private RemotingCommand getConfig(ChannelHandlerContext ctx, RemotingCommand request) {
+   private RemotingCommand getConfig(ChannelHandlerContext ctx, RemotingCommand request) {
         final RemotingCommand response = RemotingCommand.createResponseCommand(null);
 
         String content = this.namesrvController.getConfiguration().getAllConfigsFormatString();
+        setResponse(response, content);
+        return response;
+    }
+
+    private void setResponse(RemotingCommand response, String content) {","[{'comment': 'Occurrence of the extracted method is only 1?', 'commenter': 'lizhanhui'}, {'comment': 'no,two method,getClientConfigs(ChannelHandlerContext ctx, RemotingCommand request)  and getConfig(ChannelHandlerContext ctx, RemotingCommand request).', 'commenter': '123monkey'}]"
5463,remoting/src/main/java/org/apache/rocketmq/remoting/protocol/RemotingCommand.java,"@@ -181,13 +181,12 @@ public static RemotingCommand decode(final ByteBuffer byteBuffer) throws Remotin
 
     public static RemotingCommand decode(final ByteBuf byteBuffer) throws RemotingCommandException {
         int length = byteBuffer.readableBytes();
-        int oriHeaderLen = byteBuffer.readInt();
-        int headerLength = getHeaderLength(oriHeaderLen);
+        int headerLength = byteBuffer.readInt();","[{'comment': 'According to the frame layout, the first byte of the header length is used as a bit-field, flagging how the header is serialized.  Only the following 3 bytes are actually employed to represent header length. ', 'commenter': 'lizhanhui'}, {'comment': 'to optimize the code， support get protocol type from ByteBuf', 'commenter': 'liweiyuan'}]"
5508,common/src/main/java/org/apache/rocketmq/common/attribute/AttributeParser.java,"@@ -16,38 +16,44 @@
  */
 package org.apache.rocketmq.common.attribute;
 
-import com.google.common.base.Joiner;
 import com.google.common.base.Strings;
-
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 public class AttributeParser {
+
+    public static final String COMMA = "","";
+
+    public static final String EQUAL_SIGN = ""="";
+
+    public static final String PLUS_SIGN = ""+"";
+
+    private static final String MINUS_SIGN = ""-"";","[{'comment': ""Pls use more descriptive names, like 'ATTR_ARRAY_SEPARATOR'. "", 'commenter': 'caigy'}, {'comment': '@caigy  test result on related issue\r\n> Although those variables should be constant, are there any test results to show the exact effect in improving the speed of parsing?\r\n\r\n![image](https://user-images.githubusercontent.com/15797831/201060404-fc40e41d-bb5c-4c4b-a88a-b800bfbd9d8f.png)\r\nsplit two times\r\n\r\n```java\r\n@BenchmarkMode(Mode.Throughput)\r\n@Warmup(iterations = 3, time = 1)\r\n@Measurement(iterations = 5, time = 5)\r\n@Threads(1)\r\n@Fork(1)\r\n@State(value = Scope.Benchmark)\r\n@OutputTimeUnit(TimeUnit.SECONDS)\r\npublic class SplitBenchmark {\r\n\r\n    private String bbb = ""1111,2222"";\r\n\r\n    @Benchmark\r\n    public void splitTwo() {\r\n        String s = bbb.split("","")[0];\r\n        String s1 = bbb.split("","")[1];\r\n    }\r\n\r\n    @Benchmark\r\n    public void splitOne() {\r\n        String[] split = bbb.split("","");\r\n        String s = split[0];\r\n        String s1 = split[1];\r\n    }\r\n\r\n    public static void main(String[] args) throws RunnerException {\r\n        Options opt = new OptionsBuilder()\r\n            .include(SplitBenchmark.class.getSimpleName())\r\n            .result(""result.json"")\r\n            .resultFormat(ResultFormatType.JSON).build();\r\n        new Runner(opt).run();\r\n    }\r\n}\r\n```\r\nbenchmark result:\r\n![image](https://user-images.githubusercontent.com/15797831/201061272-d54dd683-3f96-4c29-b64a-defaf37dfa3a.png)\r\n\r\n those variables should be constant is polish code', 'commenter': 'mxsm'}, {'comment': ""> Pls use more descriptive names, like 'ATTR_ARRAY_SEPARATOR'.\r\n\r\nI will do, thanks for you suggest"", 'commenter': 'mxsm'}]"
5508,common/src/main/java/org/apache/rocketmq/common/attribute/AttributeParser.java,"@@ -16,38 +16,44 @@
  */
 package org.apache.rocketmq.common.attribute;
 
-import com.google.common.base.Joiner;
 import com.google.common.base.Strings;
-
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 public class AttributeParser {
+
+    public static final String ATTR_ARRAY_SEPARATOR_COMMA = "","";
+
+    public static final String ATTR_ARRAY_SEPARATOR_EQUAL_SIGN = ""="";
+
+    public static final String ATTR_ARRAY_SEPARATOR_PLUS_SIGN = ""+"";
+
+    private static final String ATTR_ARRAY_SEPARATOR_MINUS_SIGN = ""-"";","[{'comment': ""In fact not all of these constants are separators, pls give them names showing the exact purpose of them, eg. : What's the meaning of 'plus' or 'minus' in the context of attribute parsing?\r\nBTW, I'd prefer making these constant fields as `private`, for they are not referenced outside `AttributeParse`."", 'commenter': 'caigy'}, {'comment': ""> In fact not all of these constants are separators, pls give them names showing the exact purpose of them, eg. : What's the meaning of 'plus' or 'minus' in the context of attribute parsing? BTW, I'd prefer making these constant fields as `private`, for they are not referenced outside `AttributeParse`.\r\n\r\nI see what you mean, thanks for you suggest, I will polish this code again."", 'commenter': 'mxsm'}]"
5514,proxy/src/main/java/org/apache/rocketmq/proxy/ProxyStartup.java,"@@ -173,7 +174,9 @@ protected static MessagingProcessor createMessagingProcessor() {
             PROXY_START_AND_SHUTDOWN.appendStartAndShutdown(proxyMetricsManager);
         } else if (ProxyMode.isLocalMode(proxyModeStr)) {
             BrokerController brokerController = createBrokerController();
-            ProxyMetricsManager.initLocalMode(brokerController.getBrokerMetricsManager(), ConfigurationManager.getProxyConfig());
+            if (brokerController.getBrokerConfig().getMetricsExporterType() != BrokerConfig.MetricsExporterType.DISABLE) {","[{'comment': 'It seems to me that checking this config in ProxyMetricsManager#initLocalMode and ProxyMetricsManager#start should be better.', 'commenter': 'ShadowySpirits'}]"
5514,proxy/src/main/java/org/apache/rocketmq/proxy/metrics/ProxyMetricsManager.java,"@@ -69,6 +69,9 @@ public class ProxyMetricsManager implements StartAndShutdown {
     public static ObservableLongGauge proxyUp = null;
 
     public static void initLocalMode(BrokerMetricsManager brokerMetricsManager, ProxyConfig proxyConfig) {
+        if (brokerMetricsManager.getBrokerConfig().getMetricsExporterType() != BrokerConfig.MetricsExporterType.DISABLE) {","[{'comment': 'The brokerMetricsManager could be null, use ProxyConfig#getMetricsExporterType instead.', 'commenter': 'ShadowySpirits'}]"
5514,proxy/src/main/java/org/apache/rocketmq/proxy/metrics/ProxyMetricsManager.java,"@@ -69,6 +69,9 @@ public class ProxyMetricsManager implements StartAndShutdown {
     public static ObservableLongGauge proxyUp = null;
 
     public static void initLocalMode(BrokerMetricsManager brokerMetricsManager, ProxyConfig proxyConfig) {
+        if (proxyConfig.getMetricsExporterType() != BrokerConfig.MetricsExporterType.DISABLE) {","[{'comment': 'We should skip init process when metrics exporter is disable and not the other way around.', 'commenter': 'ShadowySpirits'}, {'comment': 'This check should also be added in ProxyMetricsManager#start.', 'commenter': 'ShadowySpirits'}, {'comment': '> This check should also be added in ProxyMetricsManager#start.\r\n\r\nProxyMetricsManager#start has existed\r\n', 'commenter': 'mxsm'}, {'comment': 'I will fix some problems and submit again.', 'commenter': 'mxsm'}, {'comment': '@lizhimins thanks for you modify this error', 'commenter': 'mxsm'}]"
5515,broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java,"@@ -1423,6 +1423,8 @@ protected void shutdownScheduledExecutorService(ScheduledExecutorService schedul
         try {
             scheduledExecutorService.awaitTermination(5000, TimeUnit.MILLISECONDS);
         } catch (InterruptedException ignore) {
+            BrokerController.LOG.warn(""shutdown ScheduledExecutorService was Interrupted!  "", ignore);
+        	Thread.currentThread().interrupt();","[{'comment': ""https://github.com/apache/rocketmq/actions/runs/3449152754/jobs/5767526841\r\nError:  /home/runner/work/rocketmq/rocketmq/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java:1427:9: File contains tab characters (this is the first instance). [FileTabCharacter]\r\nError:  /home/runner/work/rocketmq/rocketmq/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java:1427:17: 'catch' child has incorrect indentation level 16, expected level should be 12. [Indentation]\r\n\r\nHere has some problems need to fix in CI."", 'commenter': 'mxsm'}]"
5548,common/src/main/java/org/apache/rocketmq/common/BrokerConfig.java,"@@ -336,6 +336,10 @@ public class BrokerConfig extends BrokerIdentity {
 
     private long syncControllerMetadataPeriod = 10 * 1000;
 
+    // It is an important basis for the controller to choose the broker master. Under the same conditions,","[{'comment': 'How about making the definition of ""higher priority"" clearer in the comment or the document? Like is the priority higher while the value of brokerElectionPriority is larger or smaller?', 'commenter': 'tsunghanjacktsai'}, {'comment': 'Sure', 'commenter': 'hzh0425'}]"
5554,store/src/main/java/org/apache/rocketmq/store/logfile/DefaultMappedFile.java,"@@ -314,6 +314,42 @@ public boolean appendMessage(final byte[] data, final int offset, final int leng
         return false;
     }
 
+    /**
+     * Content of data is written from the offset of the file.
+     *
+     * @param data the byte array to append
+     * @param offset the offset of data appended to the current {@code MappedFile}
+     */
+    @Override
+    public int appendMessageConcurrently(final byte[] data, final long offset) {
+        int expectOffset = (int) (offset % this.fileSize);
+        if ((expectOffset + data.length) <= this.fileSize) {
+            try {
+                ByteBuffer buf = this.mappedByteBuffer.slice();
+                buf.position(expectOffset);
+                buf.put(data, 0, data.length);
+            } catch (Throwable e) {
+                log.error(""Error occurred when append message to mappedFile."", e);
+            }
+            int length = 0;
+            int currentPos = WROTE_POSITION_UPDATER.get(this);
+            if (currentPos == expectOffset) {
+                // todo how to traverse two mappedByteBuffer
+                for (int index = currentPos; index <= this.mappedByteBuffer.limit(); index += 20) {","[{'comment': '20 is magic number. Does it support batch cq?', 'commenter': 'lizhimins'}, {'comment': ""> 20 is magic number. Does it support batch cq?\r\n\r\nIt doesn't support bcq. Only ordinary cq are supported for now."", 'commenter': 'nowinkeyy'}]"
5601,controller/src/main/java/org/apache/rocketmq/controller/impl/manager/ReplicasInfoManager.java,"@@ -466,4 +472,61 @@ private void handleCleanBrokerDataEvent(final CleanBrokerDataEvent event) {
     private boolean isContainsBroker(final String brokerName) {
         return this.replicaInfoTable.containsKey(brokerName) && this.syncStateSetInfoTable.containsKey(brokerName);
     }
+
+    @Override
+    public byte[] encodeMetadata() {
+        byte[] replicaInfoTableBytes = this.serializer.serialize(this.replicaInfoTable);
+        byte[] syncStateSetInfoTableBytes = this.serializer.serialize(this.syncStateSetInfoTable);
+
+        int replicaInfoTableLength = replicaInfoTableBytes == null ? 0 : replicaInfoTableBytes.length;
+        int syncStateSetInfoTableLength = syncStateSetInfoTableBytes == null ? 0 : syncStateSetInfoTableBytes.length;
+
+        ByteBuffer buffer = ByteBuffer.allocate(8 + replicaInfoTableLength + syncStateSetInfoTableLength);
+        buffer.putInt(replicaInfoTableLength);
+        buffer.putInt(syncStateSetInfoTableLength);
+        if (replicaInfoTableBytes != null) {
+            buffer.put(replicaInfoTableBytes);
+        }
+        if (syncStateSetInfoTableBytes != null) {
+            buffer.put(syncStateSetInfoTableBytes);
+        }
+        buffer.flip();
+
+        return buffer.array();
+    }","[{'comment': 'It would be better to directly serialize into readable strings, just like topics.json', 'commenter': 'RongtongJin'}]"
5601,controller/src/main/java/org/apache/rocketmq/controller/impl/manager/ReplicasInfoManager.java,"@@ -466,4 +472,61 @@ private void handleCleanBrokerDataEvent(final CleanBrokerDataEvent event) {
     private boolean isContainsBroker(final String brokerName) {
         return this.replicaInfoTable.containsKey(brokerName) && this.syncStateSetInfoTable.containsKey(brokerName);
     }
+
+    @Override
+    public byte[] encodeMetadata() {
+        byte[] replicaInfoTableBytes = this.serializer.serialize(this.replicaInfoTable);","[{'comment': 'I guess JSON.toJSONString() is enough for human troubleshooting purpose.', 'commenter': 'tsunghanjacktsai'}]"
5685,common/src/main/java/org/apache/rocketmq/common/ControllerConfig.java,"@@ -59,6 +59,11 @@ public class ControllerConfig {
      */
     private volatile boolean notifyBrokerRoleChanged = true;
 
+    /**
+     * How many DLedger logs are committed to trigger a snapshot
+     */
+    private int statemachineSnapshotThreshold = 1000;","[{'comment': 'There\'s also a parameter called ""maxSnapshotReservedNum"", which is for setting the max number of snapshot files keeping within the store. I believe it should be added to the controller config as well.', 'commenter': 'tsunghanjacktsai'}, {'comment': 'Sure', 'commenter': 'hzh0425'}]"
5739,client/src/main/java/org/apache/rocketmq/client/latency/LatencyFaultToleranceImpl.java,"@@ -37,11 +37,7 @@ public void updateFaultItem(final String name, final long currentLatency, final
             faultItem.setCurrentLatency(currentLatency);
             faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);
 
-            old = this.faultItemTable.putIfAbsent(name, faultItem);
-            if (old != null) {
-                old.setCurrentLatency(currentLatency);
-                old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);
-            }
+            this.faultItemTable.putIfAbsent(name, faultItem);","[{'comment': 'The original code is used to update the latency to exists fault item. Could you please write a test case to verify your issue?', 'commenter': 'zhouxinyu'}, {'comment': 'you are right.', 'commenter': 'xiaoyifang'}]"
5769,client/src/main/java/org/apache/rocketmq/client/impl/consumer/ProcessQueue.java,"@@ -102,6 +98,10 @@ public void cleanExpiredMsg(DefaultMQPushConsumer pushConsumer) {
                 log.error(""getExpiredMsg exception"", e);
             }
 
+            if (msg == null) {
+                break;","[{'comment': ""The rest of msgTreeMap's messages can't be processed after the loop terminates,\r\n\r\nIs it OK to skip processing message that are currently empty?"", 'commenter': 'Oliverwqcwrw'}, {'comment': 'I think it should be ok.   \r\n\r\nin most cases , the rest of msgTreeMap should be empty or interrupted ,in these cases , break the loop is reasonable.\r\n\r\nin other cases ,the rest items can wait until the next clean ', 'commenter': 'xiaoyifang'}]"
5771,docs/en/controller/quick_start.md,"@@ -0,0 +1,200 @@
+# Master-Slave automatic switch Quick start 
+
+## Introduction
+
+![架构图](../image/controller/controller_design_2.png)
+
+This document mainly introduces how to quickly build a RocketMQ cluster that supports automatic master-slave switch, as shown in the above diagram. The main addition is the Controller component, which can be deployed independently or embedded in the NameServer.
+
+For detailed design ideas, please refer to [Design Ideas](https://chat.openai.com/chat/design.md).
+
+For detailed guidelines on new cluster deployment and old cluster upgrades, please refer to [Deployment Guide](https://chat.openai.com/chat/deploy.md).
+
+## Compile RocketMQ source code
+
+```shell
+$ git clone https://github.com/apache/rocketmq.git
+
+$ cd rocketmq
+
+$ mvn -Prelease-all -DskipTests clean install -U
+```
+
+## Quick deployment
+
+After successful build
+
+```shell
+#{rocketmq-version} replace with rocketmq actual version. example: 5.0.0-SNAPSHOT
+$ cd distribution/target/rocketmq-{rocketmq-version}/rocketmq-{rocketmq-version}/
+
+$ sh bin/controller/fast-try.sh start
+```
+
+If the above steps are successful, you can view the status of the Controller using the operation and maintenance command.
+
+```shell
+$ sh bin/mqadmin getControllerMetaData -a localhost:9878
+```
+
+`-a` represents the address of any controller in the cluster
+
+At this point, you can send and receive messages in the cluster and perform switch testing.
+
+If you need to shut down the quick cluster, you can execute：","[{'comment': '```suggestion\r\nIf you need to shutdown the cluster quickly, you can execute：\r\n```', 'commenter': 'Oliverwqcwrw'}, {'comment': '@Oliverwqcwrw  I will fix it later, thanks for you  review', 'commenter': 'mxsm'}, {'comment': '@Oliverwqcwrw `shutdown` is a noun... `need to shut down the cluster quickly` is the correct way.', 'commenter': 'lizhanhui'}, {'comment': '@lizhanhui agree with', 'commenter': 'Oliverwqcwrw'}]"
5775,proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/common/GrpcValidator.java,"@@ -106,16 +100,17 @@ public void validateInvisibleTime(long invisibleTime, long minInvisibleTime) {
     }
 
     public void validateTag(String tag) {
-        if (StringUtils.isNotEmpty(tag)) {
-            if (StringUtils.isBlank(tag)) {
-                throw new GrpcProxyException(Code.ILLEGAL_MESSAGE_TAG, ""tag cannot be the char sequence of whitespace"");
-            }
-            if (tag.contains(""|"")) {
-                throw new GrpcProxyException(Code.ILLEGAL_MESSAGE_TAG, ""tag cannot contain '|'"");
-            }
-            if (containControlCharacter(tag)) {
-                throw new GrpcProxyException(Code.ILLEGAL_MESSAGE_TAG, ""tag cannot contain control character"");
-            }
+        if (StringUtils.isEmpty(tag)) {
+            return;
+        }
+        if (StringUtils.isBlank(tag)) {
+            throw new GrpcProxyException(Code.ILLEGAL_MESSAGE_TAG, ""tag cannot be the char sequence of whitespace"");
+        }
+        if (tag.contains(""|"")) {
+            throw new GrpcProxyException(Code.ILLEGAL_MESSAGE_TAG, ""tag cannot contain '|'"");
+        }
+        if (containControlCharacter(tag)) {
+            throw new GrpcProxyException(Code.ILLEGAL_MESSAGE_TAG, ""tag cannot contain control character"");","[{'comment': ""Is this modification related to this issue? If not, you'd better move it to another issue."", 'commenter': 'caigy'}, {'comment': 'Ok, thanks for your review, I modified it and I will add it to a new issue.', 'commenter': 'yx9o'}]"
5826,common/src/main/java/org/apache/rocketmq/common/message/Message.java,"@@ -210,7 +210,7 @@ public String toString() {
             ""topic='"" + topic + '\'' +
             "", flag="" + flag +
             "", properties="" + properties +
-            "", body="" + Arrays.toString(body) +
+            "", body="" + (body != null ? new String(body, StandardCharsets.UTF_8) : """") +","[{'comment': ""The message body may be very large and compressed or serialized. It's better not to print the message body in `toString` function."", 'commenter': 'ShadowySpirits'}, {'comment': ""> The message body may be very large and compressed or serialized. It's better not to print the message body in `toString` function.\r\n\r\nWasn't it also printed before this modification? Do you mean to delete this directly"", 'commenter': 'sunheyi6'}, {'comment': 'IMO, user can choose if to print message body,\r\n\r\nso we can provide a readable format when users need to print message body', 'commenter': 'Oliverwqcwrw'}, {'comment': '> IMO, user can choose if to print message body,\r\n> \r\n> so we can provide a readable format when users need to print message body\r\n\r\n+1. Maybe we can check the size of message body first and only print the message body if the size is small.', 'commenter': 'caigy'}, {'comment': ""> > The message body may be very large and compressed or serialized. It's better not to print the message body in `toString` function.\r\n> \r\n> Wasn't it also printed before this modification? Do you mean to delete this directly\r\n\r\nMaybe print body size instead."", 'commenter': 'ShadowySpirits'}, {'comment': '> > IMO, user can choose if to print message body,\r\n> > so we can provide a readable format when users need to print message body\r\n> \r\n> +1. Maybe we can check the size of message body first and only print the message body if the size is small.\r\n\r\nGood idea, I have limited the length to 3000 at present,WDYT :-)', 'commenter': 'Oliverwqcwrw'}, {'comment': 'Do not print body is better, because the serialize of body is unknown.', 'commenter': 'ni-ze'}]"
5826,common/src/main/java/org/apache/rocketmq/common/message/Message.java,"@@ -228,4 +228,14 @@ public void setDeliverTimeMs(long timeMs) {
     public long getDeliverTimeMs() {
         return Long.parseLong(this.getUserProperty(MessageConst.PROPERTY_TIMER_DELIVER_MS));
     }
+
+    private String getBodyStr(byte[] body) {
+        if (body == null) {
+            return ""body is null"";
+        }
+        if (body.length > 3000) {","[{'comment': 'maybe a better way is use the first 3000 characters？ ', 'commenter': 'leizhiyuan'}]"
5834,store/src/main/java/org/apache/rocketmq/store/DefaultMessageStore.java,"@@ -849,7 +849,11 @@ public GetMessageResult getMessage(final String group, final String topic, final
                                 continue;
                             }
 
-                            this.storeStatsService.getGetMessageTransferredMsgCount().add(cqUnit.getBatchNum());
+                            if (topicConfig.isPresent()) {
+                                if (!topicConfig.get().getTopicName().contains(TopicValidator.RMQ_SYS_REVIVE_LOG)) {","[{'comment': ""Store metrics should not exclude specified topics. It's better to add a new counter in BrokerStatsManager to calculate the message transfer count excluding all system topics."", 'commenter': 'ShadowySpirits'}, {'comment': ""IMO, It will broke the current structure of StoreStatsService if moving the getMessageTranferredMsgCount to BrokerStatsManager,\r\n\r\nbecause not only is getMessageTransferredMsgCount in there but also other metrics is there,\r\n\r\nwhether moving the other metrics if moving getMessageTransferredMsgCount to BrokerStatsManager?\r\n\r\nBTW,other system topics can't influence the consume num"", 'commenter': 'Oliverwqcwrw'}, {'comment': ""I mean add a new counter in BrokerStatsManager and do not remove the current counter. The new counter only records the throughput of the user's topic. This is more general and semantically clear."", 'commenter': 'ShadowySpirits'}, {'comment': 'Get it, I will polish it', 'commenter': 'Oliverwqcwrw'}]"
5834,store/src/main/java/org/apache/rocketmq/store/DefaultMessageStore.java,"@@ -848,8 +848,8 @@ public GetMessageResult getMessage(final String group, final String topic, final
                                 selectResult.release();
                                 continue;
                             }
-
                             this.storeStatsService.getGetMessageTransferredMsgCount().add(cqUnit.getBatchNum());
+                            this.brokerStatsManager.incBrokerGetNumsWithoutSystemTopic(topic, cqUnit.getBatchNum());","[{'comment': ""Using brokerStatsManager in the store module looks weird... It's better to add this counter in BrokerStatsManager#incBrokerGetNums."", 'commenter': 'ShadowySpirits'}, {'comment': 'done', 'commenter': 'Oliverwqcwrw'}]"
5834,store/src/main/java/org/apache/rocketmq/store/stats/BrokerStats.java,"@@ -88,6 +88,6 @@ public long getMsgPutTotalTodayNow() {
     }
 
     public long getMsgGetTotalTodayNow() {","[{'comment': 'How about dealing with getMsgGetTotalYesterdayMorning in the same way?', 'commenter': 'ShadowySpirits'}, {'comment': ""The getMsgGetTotalYesterdayMorning's data is from getGetMessageTransferredMsgCount,\r\nso it's ok to replace the getGetMessageTransferredMsgCount to getNumsWithoutSystemTopic without adding other  counter"", 'commenter': 'Oliverwqcwrw'}]"
5848,broker/src/main/java/org/apache/rocketmq/broker/processor/NotificationProcessor.java,"@@ -244,6 +250,20 @@ private RemotingCommand processRequest(final Channel channel, RemotingCommand re
             int queueId = requestHeader.getQueueId();
             hasMsg = hasMsgFromQueue(false, requestHeader, queueId);
         }
+        // if it has message, fetch retry again","[{'comment': 'not has message?', 'commenter': 'lizhimins'}]"
5856,common/src/main/java/org/apache/rocketmq/common/UtilAll.java,"@@ -604,7 +606,7 @@ public static byte[] getIP() {
                             if (ipCheck(ipByte)) {
                                 if (!isInternalIP(ipByte)) {
                                     return ipByte;
-                                } else if (internalIP == null) {
+                                } else if (internalIP == null || internalIP[0] == (byte) 127) {","[{'comment': 'This judgment changes the behavior of the getIP function. If we only have lo interface, getIP will throw RuntimeException.', 'commenter': 'ShadowySpirits'}, {'comment': 'If we only have lo interface,`internalIP == null || internalIP[0] == (byte) 127)` will be true，so it will set `internalIP` to localhost and return.\nIf we have lo and LAN ip，when it find the LAN ip，`internalIP == null || internalIP[0] == (byte) 127)` also will be true, so it will override the value of `internalIP`.\nAm I missing something？', 'commenter': 'RagingSpud'}, {'comment': 'You are right. Please ignore this review.', 'commenter': 'ShadowySpirits'}]"
5889,store/pom.xml,"@@ -65,5 +65,10 @@
             <artifactId>slf4j-api</artifactId>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>ch.qos.logback</groupId>
+            <artifactId>logback-classic</artifactId>
+            <scope>test</scope>
+        </dependency>","[{'comment': '@mxsm  After I modify it to your method, the previous problem still occurs. It seems that only the official one can be used?\r\n![image](https://user-images.githubusercontent.com/50973219/212636054-d2748819-49f7-4021-8343-b295167c8450.png)\r\n', 'commenter': 'sunheyi6'}, {'comment': '@shy-share  this is netty can’t find SLF4J providers, It has nothing to do with MQ. Your approach can solve the problem\r\n', 'commenter': 'mxsm'}]"
5889,store/pom.xml,"@@ -65,5 +65,10 @@
             <artifactId>slf4j-api</artifactId>","[{'comment': 'Delete this dependency and do not add `logback-classic`', 'commenter': 'ShadowySpirits'}, {'comment': '> Delete this dependency and do not add `logback-classic`\r\n\r\n @ShadowySpirits  why？ The test method is not working properly。', 'commenter': 'sunheyi6'}, {'comment': 'refer to https://github.com/apache/rocketmq/issues/5890#issuecomment-1384779484', 'commenter': 'ShadowySpirits'}]"
5895,example/src/main/java/org/apache/rocketmq/example/quickstart/PopConsumer.java,"@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.example.quickstart;","[{'comment': 'IMO, According to the current directory structure,it is more appropriate moving to simple directory.\r\nWDYT', 'commenter': 'Oliverwqcwrw'}, {'comment': ""ok,I'll modify it."", 'commenter': 'mahaitao617'}]"
5895,example/src/main/java/org/apache/rocketmq/example/simple/PopConsumer.java,"@@ -0,0 +1,101 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.example.simple;
+
+import java.util.Set;
+import java.util.stream.Collectors;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
+import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
+import org.apache.rocketmq.common.message.MessageRequestMode;
+import org.apache.rocketmq.remoting.protocol.body.ClusterInfo;
+import org.apache.rocketmq.remoting.protocol.route.BrokerData;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
+
+/**
+ * This example shows how to subscribe and consume messages using providing {@link DefaultMQPushConsumer}.
+ */
+public class PopConsumer {
+
+    public static final String CONSUMER_GROUP = ""please_rename_unique_group_name_4"";
+    public static final String DEFAULT_NAMESRVADDR = ""127.0.0.1:9876"";
+    public static final String TOPIC = ""TopicTest"";
+
+    public static void main(String[] args) throws Exception {
+
+        switchPop();
+        /*
+         * Instantiate with specified consumer group name.
+         */
+        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
+
+        /*
+         * Specify name server addresses.
+         * <p/>
+         *
+         * Alternatively, you may specify name server addresses via exporting environmental variable: NAMESRV_ADDR
+         * <pre>
+         * {@code
+         * consumer.setNamesrvAddr(""name-server1-ip:9876;name-server2-ip:9876"");
+         * }
+         * </pre>
+         */
+        // Uncomment the following line while debugging, namesrvAddr should be set to your local address
+//        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);
+
+        /*
+         * Specify where to start in case the specific consumer group is a brand-new one.
+         */
+        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
+
+        /*
+         * Subscribe one more topic to consume.
+         */
+        consumer.subscribe(TOPIC, ""*"");
+//        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);
+        /*
+         *  Register callback to execute on arrival of messages fetched from brokers.
+         */
+        consumer.registerMessageListener((MessageListenerConcurrently) (msg, context) -> {
+            System.out.printf(""%s Receive New Messages: %s %n"", Thread.currentThread().getName(), msg);
+            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
+        });
+        consumer.setClientRebalance(false);","[{'comment': 'Simple code comments are ok, you can refer to other demos. Maybe this line is what really needs to be commented.', 'commenter': 'cserwen'}]"
5895,example/src/main/java/org/apache/rocketmq/example/simple/PopConsumer.java,"@@ -0,0 +1,65 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.example.simple;
+
+import java.util.Set;
+import java.util.stream.Collectors;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
+import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
+import org.apache.rocketmq.common.message.MessageRequestMode;
+import org.apache.rocketmq.remoting.protocol.body.ClusterInfo;
+import org.apache.rocketmq.remoting.protocol.route.BrokerData;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
+
+/**
+ * This example shows how to subscribe and consume messages using providing {@link DefaultMQPushConsumer}.
+ */
+public class PopConsumer {
+
+    public static final String CONSUMER_GROUP = ""please_rename_unique_group_name_4"";
+    public static final String DEFAULT_NAMESRVADDR = ""127.0.0.1:9876"";
+    public static final String TOPIC = ""TopicTest"";
+    public static void main(String[] args) throws Exception {
+        switchPop();
+        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
+        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
+        consumer.subscribe(TOPIC, ""*"");
+        consumer.registerMessageListener((MessageListenerConcurrently) (msg, context) -> {
+            System.out.printf(""%s Receive New Messages: %s %n"", Thread.currentThread().getName(), msg);
+            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
+        });
+        consumer.setClientRebalance(false);
+        consumer.start();
+        System.out.printf(""Consumer Started.%n"");
+    }
+
+    private static void switchPop() throws Exception {
+        DefaultMQAdminExt mqAdminExt = new DefaultMQAdminExt();
+        mqAdminExt.setNamesrvAddr(DEFAULT_NAMESRVADDR);
+        mqAdminExt.start();
+
+        ClusterInfo clusterInfo = mqAdminExt.examineBrokerClusterInfo();
+        Set<String> brokerAddrs = clusterInfo.getBrokerAddrTable().values().stream().map(BrokerData::selectBrokerAddr).collect(Collectors.toSet());","[{'comment': 'if namesvr has two clusters, which one is support switch pop ,another is not, this will fail, users should know  this, the should filter the address (which serves the topic) ', 'commenter': 'leizhiyuan'}, {'comment': 'explain this situation in the comments or fix to adapt it?', 'commenter': 'mahaitao617'}, {'comment': '```\r\n  List<BrokerData> brokerDatas = mqAdminExt.examineTopicRouteInfo(TOPIC).getBrokerDatas();\r\n        for (BrokerData brokerData : brokerDatas) {\r\n            Set<String> brokerAddrs = new HashSet<>(brokerData.getBrokerAddrs().values());\r\n            for (String brokerAddr : brokerAddrs) {\r\n                mqAdminExt.setMessageRequestMode(brokerAddr, TOPIC, CONSUMER_GROUP, MessageRequestMode.POP, 8, 3_000);\r\n            }\r\n        }\r\n```', 'commenter': 'leizhiyuan'}, {'comment': '👌', 'commenter': 'mahaitao617'}]"
5895,example/src/main/java/org/apache/rocketmq/example/simple/PushConsumer.java,"@@ -16,32 +16,53 @@
  */
 package org.apache.rocketmq.example.simple;
 
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
 import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;
 import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
 import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
-import org.apache.rocketmq.client.exception.MQClientException;
 import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
 import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.message.MessageRequestMode;
+import org.apache.rocketmq.remoting.protocol.route.BrokerData;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
 
 public class PushConsumer {
-
-    public static void main(String[] args) throws InterruptedException, MQClientException {
-        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(""CID_JODIE_1"");
-        consumer.subscribe(""TopicTest"", ""*"");
+    public static final String DEFAULT_NAMESRVADDR = ""127.0.0.1:9876"";
+    public static final String TOPIC = ""TopicTest"";
+    public static final String CONSUMER_GROUP = ""CID_JODIE_1"";
+    public static void main(String[] args) throws Exception {
+        // switchPop();
+        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
+        consumer.subscribe(TOPIC, ""*"");
         consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
         //wrong time format 2017_0422_221800
         consumer.setConsumeTimestamp(""20181109221800"");","[{'comment': '```suggestion\r\n        consumer.setConsumeTimestamp(""20181109221800"");\r\n        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\r\n```', 'commenter': 'Oliverwqcwrw'}]"
5895,example/src/main/java/org/apache/rocketmq/example/simple/PushConsumer.java,"@@ -16,32 +16,53 @@
  */
 package org.apache.rocketmq.example.simple;
 
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
 import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;
 import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
 import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
-import org.apache.rocketmq.client.exception.MQClientException;
 import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
 import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.message.MessageRequestMode;
+import org.apache.rocketmq.remoting.protocol.route.BrokerData;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
 
 public class PushConsumer {
-
-    public static void main(String[] args) throws InterruptedException, MQClientException {
-        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(""CID_JODIE_1"");
-        consumer.subscribe(""TopicTest"", ""*"");
+    public static final String DEFAULT_NAMESRVADDR = ""127.0.0.1:9876"";","[{'comment': 'DEFAULT_NAMESRVADDR is not necessary and will affect quick start.\r\nhttps://rocketmq.apache.org/docs/quickStart/02quickstart\r\n![image](https://user-images.githubusercontent.com/14222167/215929843-e771615a-bad0-4c3c-8e61-d0582b793c06.png)\r\n', 'commenter': 'odbozhou'}]"
5895,example/src/main/java/org/apache/rocketmq/example/simple/PushConsumer.java,"@@ -16,32 +16,53 @@
  */
 package org.apache.rocketmq.example.simple;
 
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
 import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;
 import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
 import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
-import org.apache.rocketmq.client.exception.MQClientException;
 import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
 import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.message.MessageRequestMode;
+import org.apache.rocketmq.remoting.protocol.route.BrokerData;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
 
 public class PushConsumer {
-
-    public static void main(String[] args) throws InterruptedException, MQClientException {
-        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(""CID_JODIE_1"");
-        consumer.subscribe(""TopicTest"", ""*"");
+    public static final String DEFAULT_NAMESRVADDR = ""127.0.0.1:9876"";
+    public static final String TOPIC = ""TopicTest"";
+    public static final String CONSUMER_GROUP = ""CID_JODIE_1"";
+    public static void main(String[] args) throws Exception {
+        // switchPop();","[{'comment': 'pop can add a new class such as PopConsumer', 'commenter': 'odbozhou'}, {'comment': 'i have solved it，pls review it again,ths', 'commenter': 'mahaitao617'}]"
5895,example/src/main/java/org/apache/rocketmq/example/simple/PopConsumer.java,"@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.example.simple;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;
+import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
+import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.apache.rocketmq.common.message.MessageRequestMode;
+import org.apache.rocketmq.remoting.protocol.route.BrokerData;
+import org.apache.rocketmq.tools.admin.DefaultMQAdminExt;
+
+public class PopConsumer {
+    public static final String TOPIC = ""TopicTest"";
+    public static final String CONSUMER_GROUP = ""CID_JODIE_1"";
+    public static void main(String[] args) throws Exception {
+        switchPop();
+        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
+        consumer.subscribe(TOPIC, ""*"");
+        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
+        //wrong time format 2017_0422_221800
+        consumer.setConsumeTimestamp(""20181109221800"");
+        consumer.setNamesrvAddr(""127.0.0.1:9876"");","[{'comment': 'Comment out namesrvAddr, as with the other examples', 'commenter': 'odbozhou'}, {'comment': ""I notice that this line doesn't exist in the latest code,\r\nhow about adding it to avoid user doesn't set environment variable"", 'commenter': 'Oliverwqcwrw'}]"
5922,broker/src/main/java/org/apache/rocketmq/broker/controller/ReplicasManager.java,"@@ -448,6 +445,17 @@ private void stopCheckSyncStateSet() {
         }
     }
 
+    private void updateControlllerAddr() {","[{'comment': '```suggestion\r\n    private void updateControllerAddr() {\r\n```', 'commenter': 'Oliverwqcwrw'}]"
5922,broker/src/main/java/org/apache/rocketmq/broker/controller/ReplicasManager.java,"@@ -108,6 +103,8 @@ enum State {
     }
 
     public void start() {
+        updateControlllerAddr();","[{'comment': '```suggestion\r\n        updateControllerAddr();\r\n```', 'commenter': 'Oliverwqcwrw'}, {'comment': 'done', 'commenter': 'RongtongJin'}]"
5958,tools/src/main/java/org/apache/rocketmq/tools/command/ha/GetSyncStateSetSubCommand.java,"@@ -123,13 +123,23 @@ private void printData(String controllerAddress, List<String> brokerNames,
                     next.getKey(), next.getValue().getMasterAddress(), next.getValue().getMasterEpoch(), next.getValue().getSyncStateSetEpoch(),
                     inSyncReplicas.size());
                 for (BrokerReplicasInfo.ReplicaIdentity member : inSyncReplicas) {
-                    System.out.printf(""\n InSyncReplica:\t%s\n"", member.toString());
+                    System.out.printf(""\n InSyncReplica:\t%s\n"", member.toString() + acquireBrokerStatus(defaultMQAdminExt, member.getAddress()));
                 }
 
                 for (BrokerReplicasInfo.ReplicaIdentity member : notInSyncReplicas) {
-                    System.out.printf(""\n NotInSyncReplica:\t%s\n"", member.toString());
+                    System.out.printf(""\n NotInSyncReplica:\t%s\n"", member.toString() + acquireBrokerStatus(defaultMQAdminExt, member.getAddress()));","[{'comment': 'Format the message in `printf` formatter instead of concatenating strings directly.', 'commenter': 'caigy'}, {'comment': 'i have fixed it', 'commenter': 'mahaitao617'}]"
5958,tools/src/main/java/org/apache/rocketmq/tools/command/ha/GetSyncStateSetSubCommand.java,"@@ -123,13 +123,23 @@ private void printData(String controllerAddress, List<String> brokerNames,
                     next.getKey(), next.getValue().getMasterAddress(), next.getValue().getMasterEpoch(), next.getValue().getSyncStateSetEpoch(),
                     inSyncReplicas.size());
                 for (BrokerReplicasInfo.ReplicaIdentity member : inSyncReplicas) {
-                    System.out.printf(""\n InSyncReplica:\t%s\n"", member.toString());
+                    System.out.printf(""\n InSyncReplica:\t%s\n"", member.toString() + acquireBrokerStatus(defaultMQAdminExt, member.getAddress()));
                 }
 
                 for (BrokerReplicasInfo.ReplicaIdentity member : notInSyncReplicas) {
-                    System.out.printf(""\n NotInSyncReplica:\t%s\n"", member.toString());
+                    System.out.printf(""\n NotInSyncReplica:\t%s\n"", member.toString() + acquireBrokerStatus(defaultMQAdminExt, member.getAddress()));
                 }
             }
         }
     }
+
+    private String acquireBrokerStatus(DefaultMQAdminExt defaultMQAdminExt,String brokerAddr) {
+        String status = "" online"";","[{'comment': '`status` should not contain format characters (like white spaces), do formatting work where it is necessary.', 'commenter': 'caigy'}, {'comment': 'i have fixed it', 'commenter': 'mahaitao617'}]"
6037,.github/PULL_REQUEST_TEMPLATE.md,"@@ -3,7 +3,12 @@
 
 ## What is the purpose of the change
 
-XXXXX
+<!--
+If this PR fixes a GitHub issue, please add `fixes #<XXX>` or `cloese #<XXX>`.Please refer to the documentation for more information:","[{'comment': '```suggestion\r\nIf this PR fixes a GitHub issue, please add `fixes #<XXX>` or `closes #<XXX>`.Please refer to the documentation for more information:\r\n```', 'commenter': 'Oliverwqcwrw'}, {'comment': 'done', 'commenter': 'mxsm'}]"
6037,.github/PULL_REQUEST_TEMPLATE.md,"@@ -3,7 +3,12 @@
 
 ## What is the purpose of the change
 
-XXXXX
+<!--
+If this PR fixes a GitHub issue, please add `fixes #<XXX>` or `closes #<XXX>`.Please refer to the documentation for more information:","[{'comment': 'Sorry for being nitpicking, please add a space between the period of ""`closes #<XXX>`."" and ""Please"" in the next sentence.', 'commenter': 'tsunghanjacktsai'}, {'comment': '@tsunghanjacktsai Done, PTAL', 'commenter': 'mxsm'}]"
6037,.github/PULL_REQUEST_TEMPLATE.md,"@@ -3,7 +3,12 @@
 
 ## What is the purpose of the change
 
-XXXXX
+<!--
+If this PR fixes a GitHub issue, please add `fixes #<XXX>` or `closes #<XXX>`. Please refer to the documentation for more information:
+https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue
+-->
+
+fix #<xxx> <!-- <xxx> replace with PR id -->","[{'comment': '![image](https://user-images.githubusercontent.com/21963954/218623666-388b89a0-672c-42a0-b121-d8d0ff66229b.png)\r\nWhen I preview, there seems to be no text display', 'commenter': 'RongtongJin'}, {'comment': '@RongtongJin \r\n\r\nYour page is a completed page and this modification is used when creating a PR upon submission, as shown in the following figure.\r\n![image](https://user-images.githubusercontent.com/15797831/218624875-14be6bd2-aba9-489a-9d3d-ad22c2bb582d.png)\r\n', 'commenter': 'mxsm'}]"
6090,acl/pom.xml,"@@ -13,7 +13,7 @@
     <parent>
         <groupId>org.apache.rocketmq</groupId>
         <artifactId>rocketmq-all</artifactId>
-        <version>5.0.1-SNAPSHOT</version>
+        <version>5.1.1-SNAPSHOT</version>","[{'comment': 'Is this should be 5.1.0?', 'commenter': 'ShadowySpirits'}, {'comment': ""It's the version after release. See commit for more information"", 'commenter': 'drpmma'}]"
6115,tools/src/main/java/org/apache/rocketmq/tools/command/message/QueryMsgTraceByIdSubCommand.java,"@@ -47,6 +47,19 @@ public Options buildCommandlineOptions(Options options) {
         opt = new Option(""t"", ""traceTopic"", true, ""The name value of message trace topic"");
         opt.setRequired(false);
         options.addOption(opt);
+
+        opt = new Option(""b"", ""beginTimestamp"", true, ""Begin timestamp(ms). default:0, eg:1676730526212"");
+        opt.setRequired(false);
+        options.addOption(opt);
+
+        opt = new Option(""e"", ""endTimestamp"", true, ""End timestamp(ms). default:Long.MAX_VALUE, eg:1676730526212"");
+        opt.setRequired(false);
+        options.addOption(opt);
+
+        opt = new Option(""num"", ""maxNum"", true, ""The maximum number of messages returned by the query, default:64"");","[{'comment': 'How about change the option name to `c`(messageNumber), like the `ConsumeMessageCommand`. Simple unified use of single letter.', 'commenter': 'echooymxq'}, {'comment': ""I was thinking about this before, and I didn't think of the right shorthand, so I used num.\r\nYour suggestion is very good. I'll revise it."", 'commenter': 'socutes'}]"
6116,remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingClient.java,"@@ -95,7 +96,7 @@ public class NettyRemotingClient extends NettyRemotingAbstract implements Remoti
     private final ConcurrentHashMap<String /* cidr */, Bootstrap> bootstrapMap = new ConcurrentHashMap<>();
     private final ConcurrentMap<String /* addr */, ChannelWrapper> channelTables = new ConcurrentHashMap<>();
 
-    private final Timer timer = new Timer(""ClientHouseKeepingService"", true);
+    private final HashedWheelTimer timer = new HashedWheelTimer(r -> new Thread(r, ""ClientHouseKeepingService""));","[{'comment': 'we should  keep it simple .  it is necessary ?', 'commenter': 'hYuang'}, {'comment': 'HashedWheelTimer is more accurate than java.util.Time.', 'commenter': 'drpmma'}, {'comment': 'In my opinion, the network module as the basic component, we should try to optimize every detail.\r\nEspecially in the stream processing scenario, some details of the performance issues, this can cause some unexpected performance problems.\r\nHashedWheelTimer is more reasonable and better than Timer in terms of performance and implementation.\r\n', 'commenter': 'socutes'}]"
6122,store/src/main/java/org/apache/rocketmq/store/ha/DefaultHAClient.java,"@@ -35,11 +35,26 @@
 
 public class DefaultHAClient extends ServiceThread implements HAClient {
 
+    /**
+     * Report header buffer size. Schema: slaveMaxOffset. Format:
+     *
+     * <pre>
+     * ┌───────────────────────┬───────────────────────┐
+     * │                  slaveMaxOffset               │
+     * │                    (8bytes)                   │
+     * ├───────────────────────┴───────────────────────┤
+     * │                                               │
+     * │                  Report Header                │
+     * </pre>
+     * <p>
+     */
+    public static final int REPORT_HEADER = 8;","[{'comment': 'How about to use REPORT_HEADER_SIZE?', 'commenter': 'Oliverwqcwrw'}, {'comment': '> How about to use REPORT_HEADER_SIZE?\r\n\r\nseems better!', 'commenter': 'TheR1sing3un'}]"
6122,store/src/main/java/org/apache/rocketmq/store/ha/DefaultHAConnection.java,"@@ -31,6 +31,22 @@
 import org.apache.rocketmq.store.SelectMappedBufferResult;
 
 public class DefaultHAConnection implements HAConnection {
+
+    /**
+     * Transfer Header buffer size. Schema: physic offset and body size. Format:
+     *
+     * <pre>
+     * ┌───────────────────────┬───────────────────────┬───────────────────────┐
+     * │                  physicOffset                 │         bodySize      │
+     * │                    (8bytes)                   │         (4bytes)      │
+     * ├───────────────────────┴───────────────────────┴───────────────────────┤
+     * │                                                                       │
+     * │                           Transfer Header                             │
+     * </pre>
+     * <p>
+     */","[{'comment': 'how about consolidation form\r\n```\r\n/**\r\n     * Transfer Header buffer size. Schema: physic offset and body size. Format:\r\n     *\r\n     * <pre>\r\n     * ┌───────────────────────────────────────────────┬───────────────────────┐\r\n     * │                  physicOffset                 │         bodySize      │\r\n     * │                    (8bytes)                   │         (4bytes)      │\r\n     * ├───────────────────────────────────────────────┴───────────────────────┤\r\n     * │                                                                       │\r\n     * │                           Transfer Header                             │\r\n     * </pre>\r\n     * <p>\r\n     */\r\n```', 'commenter': 'mxsm'}, {'comment': '> how about consolidation form\r\n> \r\n> ```\r\n> /**\r\n>      * Transfer Header buffer size. Schema: physic offset and body size. Format:\r\n>      *\r\n>      * <pre>\r\n>      * ┌───────────────────────────────────────────────┬───────────────────────┐\r\n>      * │                  physicOffset                 │         bodySize      │\r\n>      * │                    (8bytes)                   │         (4bytes)      │\r\n>      * ├───────────────────────────────────────────────┴───────────────────────┤\r\n>      * │                                                                       │\r\n>      * │                           Transfer Header                             │\r\n>      * </pre>\r\n>      * <p>\r\n>      */\r\n> ```\r\n\r\nsounds good!', 'commenter': 'TheR1sing3un'}]"
6122,store/src/main/java/org/apache/rocketmq/store/ha/DefaultHAClient.java,"@@ -35,11 +35,26 @@
 
 public class DefaultHAClient extends ServiceThread implements HAClient {
 
+    /**
+     * Report header buffer size. Schema: slaveMaxOffset. Format:
+     *
+     * <pre>
+     * ┌───────────────────────┬───────────────────────┐
+     * │                  slaveMaxOffset               │
+     * │                    (8bytes)                   │
+     * ├───────────────────────┴───────────────────────┤
+     * │                                               │
+     * │                  Report Header                │","[{'comment': 'So is this place.', 'commenter': 'mxsm'}]"
6135,README.md,"@@ -1,4 +1,4 @@
-## Apache RocketMQ
+## Apache RocketMQ ","[{'comment': 'Is this modification necessary?', 'commenter': 'caigy'}, {'comment': 'Sorry，have git revert this commit', 'commenter': 'cryptoya'}]"
6207,remoting/src/main/java/org/apache/rocketmq/remoting/protocol/subscription/SubscriptionGroupConfig.java,"@@ -149,6 +153,14 @@ public void setConsumeTimeoutMinute(int consumeTimeoutMinute) {
         this.consumeTimeoutMinute = consumeTimeoutMinute;
     }
 
+    public Set<SimpleSubscriptionData> getSubscriptionDataSet() {","[{'comment': 'why not use a map like `Map<String /* topic */, SimpleSubscriptionData>`.', 'commenter': 'ShadowySpirits'}, {'comment': ""Because it's possible that there's more than one SimpleSubscriptionData for a topic."", 'commenter': 'drpmma'}]"
6234,common/src/main/java/org/apache/rocketmq/common/BrokerConfig.java,"@@ -376,12 +379,13 @@ public boolean isEnable() {
         }
     }
 
-    private MetricsExporterType metricsExporterType = MetricsExporterType.DISABLE;
+    private MetricsExporterType metricsExporterType = MetricsExporterType.LOGGER;","[{'comment': 'Please do not change the default value.', 'commenter': 'ShadowySpirits'}, {'comment': '@aaron-ai Could you please approve running the ci? And we need to add a jul to sl4j bridge in [aliyunmq/rocketmq-shaded-slf4j-api-bridge](https://github.com/aliyunmq/rocketmq-shaded-slf4j-api-bridge/tree/master).', 'commenter': 'ShadowySpirits'}, {'comment': 'Actually there is [an official bridge from SLF4j](https://www.slf4j.org/legacy.html#:~:text=endless%20loop.-,jul%2Dto%2Dslf4j%20bridge,-The%20jul%2Dto), @lrybbs just try it out.', 'commenter': 'aaron-ai'}, {'comment': '> Actually there is [an official bridge from SLF4j](https://www.slf4j.org/legacy.html#:~:text=endless%20loop.-,jul%2Dto%2Dslf4j%20bridge,-The%20jul%2Dto), @lrybbs just try it out.\r\n\r\nYou are right, but we should make it compatible with shaded sl4j. Can you give some guide for @lrybbs?', 'commenter': 'ShadowySpirits'}, {'comment': 'Since https://github.com/apache/rocketmq/pull/5959 has been merge, the unshaded SLF4j is compatible with the shaded SLF4j we introduced now. This means that after using the [jul-to-slf4j bridge](https://www.slf4j.org/legacy.html#:~:text=endless%20loop.-,jul%2Dto%2Dslf4j%20bridge,-The%20jul%2Dto), the logs can be automatically redirected to the shaded SLF4j.\r\n\r\nHere is the related link you could refer to: https://stackoverflow.com/questions/9117030/jul-to-slf4j-bridge', 'commenter': 'aaron-ai'}, {'comment': '@aaron-ai Now, broker metrics and proxy metric could output to ""rocketmqlogs"" folder. Their names are ""broker_metric.log"" and ""proxy_metric.log"", respectively.', 'commenter': 'lrybbs'}]"
6254,broker/src/main/java/org/apache/rocketmq/broker/processor/AckMessageProcessor.java,"@@ -94,16 +94,15 @@ public boolean isPopReviveServiceRunning() {
     @Override
     public RemotingCommand processRequest(final ChannelHandlerContext ctx,
         RemotingCommand request) throws RemotingCommandException {
-        return this.processRequest(ctx.channel(), request, true);
+        return this.processRequest(ctx.channel(), request);
     }
 
     @Override
     public boolean rejectRequest() {
         return false;
     }
 
-    private RemotingCommand processRequest(final Channel channel, RemotingCommand request,
-        boolean brokerAllowSuspend) throws RemotingCommandException {
+    private RemotingCommand processRequest(final Channel channel, RemotingCommand request) throws RemotingCommandException {","[{'comment': 'This param may be useful in the future, so pls communicate with the community before modify it.', 'commenter': 'caigy'}]"
6254,broker/src/main/java/org/apache/rocketmq/broker/processor/AckMessageProcessor.java,"@@ -160,8 +159,7 @@ private RemotingCommand processRequest(final Channel channel, RemotingCommand re
             if (requestHeader.getOffset() < oldOffset) {
                 return response;
             }
-            while (!this.brokerController.getPopMessageProcessor().getQueueLockManager().tryLock(lockKey)) {
-            }
+","[{'comment': 'Could you explain the reason to remove the locking statement?', 'commenter': 'caigy'}]"
6254,broker/src/main/java/org/apache/rocketmq/broker/processor/ForwardRequestProcessor.java,"@@ -1,45 +0,0 @@
-/*","[{'comment': 'Have you launched a discuss about removing this class in community?', 'commenter': 'caigy'}]"
6278,client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultLitePullConsumerImpl.java,"@@ -450,20 +462,22 @@ public PullAPIWrapper getPullAPIWrapper() {
 
     private void startPullTask(Collection<MessageQueue> mqSet) {
         for (MessageQueue messageQueue : mqSet) {
-            if (!this.taskTable.containsKey(messageQueue)) {
-                PullTaskImpl pullTask = new PullTaskImpl(messageQueue);
-                this.taskTable.put(messageQueue, pullTask);
-                this.scheduledThreadPoolExecutor.schedule(pullTask, 0, TimeUnit.MILLISECONDS);
+            if (!this.messageQueueTable.containsKey(messageQueue)) {
+//                PullTaskImpl pullTask = new PullTaskImpl(messageQueue);","[{'comment': ""It's suggested to remove the comment line."", 'commenter': 'drpmma'}]"
6278,client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultLitePullConsumerImpl.java,"@@ -131,9 +128,17 @@ private enum SubscriptionType {
 
     private DefaultLitePullConsumer defaultLitePullConsumer;
 
+    private PullMessageQueueService pullMessageQueueService;
+
     private final ConcurrentMap<MessageQueue, PullTaskImpl> taskTable =
         new ConcurrentHashMap<>();
 
+    // Dummy value to associate with an Object in the backing Map
+    private static final Object PRESENT = new Object();
+
+    private final ConcurrentMap<MessageQueue, Object> messageQueueTable =","[{'comment': ""It's quite strange to use Object as the map value. Are you attempting to create a concurrent set? If that is the case, you may use the keySet of a ConcurrentMap instead."", 'commenter': 'drpmma'}]"
6278,client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultLitePullConsumerImpl.java,"@@ -1021,16 +1032,154 @@ public MessageQueue getMessageQueue() {
         }
     }
 
+    public void pullMessage(final MessageQueue messageQueue) {","[{'comment': 'Is it possible to abstract a method for the purpose of code reuse rather than duplicating it?\r\n\r\nhttps://github.com/apache/rocketmq/blob/a3228ad2736c0311592b12f994361b06cf4f72a9/client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultLitePullConsumerImpl.java#L896-L1020', 'commenter': 'drpmma'}, {'comment': ""Thanks for your reply, I don't have a good idea, my thinking is to add a parameter to judge sync or async, and then if... else handle differently"", 'commenter': 'Ceilzcx'}]"
6322,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainAccessData.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.acl.plain;
+
+import org.apache.rocketmq.common.PlainAccessConfig;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class PlainAccessData {
+    List<String> globalWhiteRemoteAddresses = new ArrayList<>();
+    List<PlainAccessConfig> accounts = new ArrayList<>();
+    List<DataVersion> dataVersion = new ArrayList<>();","[{'comment': 'These fields should be private.', 'commenter': 'caigy'}]"
6322,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainPermissionManager.java,"@@ -50,6 +32,22 @@
 import org.apache.rocketmq.remoting.protocol.DataVersion;
 import org.apache.rocketmq.srvutil.AclFileWatchService;
 
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.FileAlreadyExistsException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicLong;","[{'comment': 'It seems unnecessary to reorder imports.', 'commenter': 'caigy'}]"
6322,acl/src/main/java/org/apache/rocketmq/acl/plain/PlainAccessData.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.acl.plain;
+
+import org.apache.rocketmq.common.PlainAccessConfig;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class PlainAccessData {","[{'comment': 'The class should implement `Serializable` and override its own `hashCode()` and `equals()`.', 'commenter': 'caigy'}]"
6359,docs/cn/controller/persistent_unique_broker_id.md,"@@ -0,0 +1,207 @@
+# 持久化的唯一BrokerId
+
+## 现阶段问题
+现在采用`BrokerAddress`作为Broker在Controller模式下的唯一标识。导致如下情景出现问题：
+
+- 容器环境下，每次Broker的重启或升级都可能会导致IP发生变化，导致之前的`BrokerAddress`留下的记录没办法和重启后的Broker联系起来，比如说`ReplicaInfo`, `SyncStateSet`等数据。
+## 改进方案
+在Controller侧采用`BrokerName:BrokerId`作为唯一标识，不再以`BrokerAddress`作为唯一标识。并且需要对`BrokerId`进行持久化存储，由于`ClusterName`和`BrokerName`都是启动的时候在配置文件中配置好的，所以只需要处理`BrokerId`的分配和持久化问题。
+Broker第一次上线的时候，只有配置文件中配置的`ClusterName`和`BrokerName`，以及自身的`BrokerAddress`。那么我们需要和`Controller`协商出一个在整个集群生命周期中都唯一确定的标识：`BrokerId`，该`BrokerId`从1开始分配。当Broker被选为Master的时候，它会在Name Server中重新注册，此时为了兼容之前的无HA的Master-Slave架构，那么需要在这一步暂时更改为`BrokerId`为0(之前的逻辑里面id为0代表着Broker是Master身份)。
+### 上线流程
+
+![](../image/controller/persistent_unique_broker_id/register_process.png)
+
+#### 1. GetNextBrokerId Request
+这时候发起一个`GetNextBrokerId`的请求到Controller，为了拿到当前的下一个待分配的`BrokerId`(从1开始分配)。
+#### 1.1 ReadFromDLedger
+此时Controller接收到请求，然后走DLedger去获取到状态机的`NextBrokerId`数据。
+#### 2. GetNextBrokerId Response
+Controller将`NextBrokerId`返回给Broker。
+#### 2.1, 2.2 CreateTempMetaFile
+Broker拿到`NextBrokerId`之后，创建一个临时文件`.broker.meta.temp`，里面记录了`NextBrokerId`(也就是期望应用的`BrokerId`)，以及自己生成一个`RegisterCode`(用于之后的身份校验)也持久化到临时文件中。
+#### 3. ApplyBrokerId Request
+Broker携带着当前自己的基本数据(`ClusterName`、`BrokerName`和`BrokerAddress`)以及此时期望应用的`BrokerId`和`RegisterCode`，发送一个`ApplyBrokerId`的请求到Controller。
+#### 3.1 CASApplyBrokerId
+Controller通过DLedger写入该事件，当该事件(日志)被应用到状态机的时候，判断此时是否可以应用该`BrokerId`(若`BrokerId`已被分配并且也不是分配给该Broker时则失败)。并且此时会记录下来该`BrokerId`和`RegisterCode`之间的关系。
+#### 4. ApplyBrokerId Response
+若上一步成功应用了该`BrokerId`，此时则返回成功给Broker，若失败则返回当前的`NextBrokerId`。
+#### 4.1, 4.2 CreateMetaFileFromTemp
+若上一步成功的应用了该`BrokerId`，那么此时可以视为Broker侧成功的分配了该BrokerId，那么此时我们也需要彻底将这个BrokerId的信息持久化，那么我们就可以直接原子删除`.broker.meta.temp`并创建`.broker.meta`。删除和创建这两步需为原子操作。
+> 经过上述流程，第一次上线的broker和controller成功协商出一个双方都认同的brokeId并持久化保存起来。
+
+#### 5 RegisterBrokerToController Request
+之前的步骤已经正确协商出了`BrokerId`，但是这时候有可能Controller侧保存的`BrokerAddress`是上次Broker上线的时候的`BrokerAddress`，所以现在需要更新一下`BrokerAddress`，发送一个`RegisterBrokerToController` 请求并带上当前的`BrokerAddress`。
+#### 5.1 UpdateBrokerAddress
+Controller比对当前该Broker在Controller状态机中保存的`BrokerAddress`，若和请求中携带的不一致则更新为请求中的`BrokerAddress`。
+#### 6 RegisterBrokerToController Response
+Controller侧在更新完`BrokerAddress`之后可携带着当前该Broker所在的`Broker-set`的主从信息返回，用于通知Broker进行相应的身份转变。
+### 注册状态轮转
+
+![](../image/controller/persistent_unique_broker_id/register_state_transfer.png)
+
+### 故障容错
+> 如果在正常上线流程中出现了各种情况的宕机，则以下流程保证正确的`BrokerId`分配
+
+#### 正常重启后的节点上线
+若是正常重启，那么则已经在双方协商出唯一的`BrokerId`，并且本地也在`broker.meta`中有该`BrokerId`的数据，那么就该注册流程不需要进行，直接继续后面的流程即可。即从`RegisterBrokerToController`处继续上线即可。
+
+![image.png](../image/controller/persistent_unique_broker_id/normal_restart.png)
+
+#### CreateTempMetaFile失败
+
+![image.png](../image/controller/persistent_unique_broker_id/fail_create_temp_metadata_file.png) 
+
+如果是上图中的流程失败的话，那么Broker重启后，Controller侧的状态机本身也没有分配任何`BrokerId`。Broker自身也没有任何数据被保存。因此直接重新按照上述流程从头开始走即可。
+#### CreateTempMetaFile成功，ApplyBrokerId未成功
+若是Controller侧已经认为本次`ApplyBrokerId`请求不对(请求去分配一个已被分配的`BrokerId`并且该	`RegisterCode`不相等)，并且此时返回当前的`NextBrokerId`给Broker，那么此时Broker直接删除`.broker.meta.temp`文件，接下来回到第2步，重新开始该流程以及后续流程。
+
+![image.png](../image/controller/persistent_unique_broker_id/fail_apply_broker_id.png)
+
+#### ApplyBrokerId成功，CreateMetaFileFromTemp未成功
+上述情况可以出现在`ApplyResult`丢失、CAS删除并创建`broker.meta`失败，这俩流程中。
+那么重启后，Controller侧是已经认为我们`ApplyBrokerId`流程是成功的了，而且也已经在状态机中修改了BrokerId的分配数据，那么我们这时候重新直接开始步骤3，也就是发送`ApplyBrokerId`请求的这一步。
+
+![image.png](../image/controller/persistent_unique_broker_id/fail_create_metadata_file_and_delete_temp.png)
+
+因为我们有`.broker.meta.temp`文件，可以从中拿到我们之前成功在Controller侧应用的`BrokerId`和`RegisterCode`，那么直接发送给Controller，如果Controller中存在该`BrokerId`并且`RegisterCode`和请求中的`RegisterCode`相等，那么视为成功。
+### 正确上线后使用BrokerId作为唯一标识
+当正确上线之后，之后Broker的请求和状态记录都以`BrokerId`作为唯一标识。心跳等数据的记录都以`BrokerId`为标识。
+同时Controller侧也会记录当前该`BrokerId`的`BrokerAddress`，在主从切换等时候用于通知Broker状态变化。
+## 升级方案
+4.x版本升级遵守5.0升级文档流程即可。
+5.x非持久化BrokerId版本升级到持久化BrokerId版本按照如下流程:
+### 升级Controller
+
+1. 将旧版本Controller组停机。
+2. 清除Controller数据，即默认在`~/DLedgerController`下的数据文件。
+3. 上线新版Controller组。
+> 在上述升级Controller流程中，Broker仍可正常运行，但无法切换。
+
+### 升级Broker
+
+1. 将Broker从节点停机。
+2. 将Broker主节点停机。
+3. 将所有的Broker的Epoch文件删除，即默认为`~/store/epochFileCheckpoint`和`~/store/epochFileCheckpoint.bak`。
+4. 将原先的主Broker先上线，等待该Broker当选为master。(可使用`admin`命令的`getSyncStateSet`来观察)
+5. 将原来的从Broker全部上线。
+> 建议停机时先停从再停主，上线时先上原先的主再上原先的从，这样可以保证原来的主备关系。
+若需要改变升级前后主备关系，则需要停机时保证主、备的CommitLog对齐，否则可能导致数据被截断而丢失。
+
+### 测试
+> 启动一个namesrv
+
+```bash
+nohup sh bin/mqnamesrv &
+```
+> 启动一个旧版controller
+
+```bash
+nohup sh bin/mqcontroller -c ./conf/controller/controller-standalone.conf &
+```
+> 查看controller是否被正确启动
+
+```bash
+sh bin/mqadmin getControllerMetaData -a localhost:9878","[{'comment': '要不测试相关内容去掉吧', 'commenter': 'RongtongJin'}]"
6359,docs/cn/controller/persistent_unique_broker_id.md,"@@ -0,0 +1,207 @@
+# 持久化的唯一BrokerId
+
+## 现阶段问题
+现在采用`BrokerAddress`作为Broker在Controller模式下的唯一标识。导致如下情景出现问题：
+
+- 容器环境下，每次Broker的重启或升级都可能会导致IP发生变化，导致之前的`BrokerAddress`留下的记录没办法和重启后的Broker联系起来，比如说`ReplicaInfo`, `SyncStateSet`等数据。
+## 改进方案
+在Controller侧采用`BrokerName:BrokerId`作为唯一标识，不再以`BrokerAddress`作为唯一标识。并且需要对`BrokerId`进行持久化存储，由于`ClusterName`和`BrokerName`都是启动的时候在配置文件中配置好的，所以只需要处理`BrokerId`的分配和持久化问题。
+Broker第一次上线的时候，只有配置文件中配置的`ClusterName`和`BrokerName`，以及自身的`BrokerAddress`。那么我们需要和`Controller`协商出一个在整个集群生命周期中都唯一确定的标识：`BrokerId`，该`BrokerId`从1开始分配。当Broker被选为Master的时候，它会在Name Server中重新注册，此时为了兼容之前的无HA的Master-Slave架构，那么需要在这一步暂时更改为`BrokerId`为0(之前的逻辑里面id为0代表着Broker是Master身份)。
+### 上线流程
+
+![](../image/controller/persistent_unique_broker_id/register_process.png)
+
+#### 1. GetNextBrokerId Request
+这时候发起一个`GetNextBrokerId`的请求到Controller，为了拿到当前的下一个待分配的`BrokerId`(从1开始分配)。
+#### 1.1 ReadFromDLedger
+此时Controller接收到请求，然后走DLedger去获取到状态机的`NextBrokerId`数据。
+#### 2. GetNextBrokerId Response
+Controller将`NextBrokerId`返回给Broker。
+#### 2.1, 2.2 CreateTempMetaFile
+Broker拿到`NextBrokerId`之后，创建一个临时文件`.broker.meta.temp`，里面记录了`NextBrokerId`(也就是期望应用的`BrokerId`)，以及自己生成一个`RegisterCode`(用于之后的身份校验)也持久化到临时文件中。","[{'comment': '需要删除2.2', 'commenter': 'mxsm'}]"
6359,docs/cn/image/controller/persistent_unique_broker_id/normal_restart.png,,"[{'comment': 'Remove this useless file.', 'commenter': 'ShadowySpirits'}]"
6495,.ijwb/.bazelproject,"@@ -0,0 +1,4 @@
+directories:
+  .
+
+derive_targets_from_directories: false","[{'comment': 'Why do we need this file? ', 'commenter': 'ShadowySpirits'}]"
6495,tieredstore/src/main/java/org/apache/rocketmq/tieredstore/common/TieredMessageStoreConfig.java,"@@ -105,6 +105,14 @@ public boolean check(TieredStorageLevel targetLevel) {
     private String ossAccessKey = """";
     private String ossSecretKey = """";
 
+    private String s3Region = """";
+
+    private String s3Bucket = """";
+
+    private String s3AccessKey = """";","[{'comment': 'maybe we should unify all ak/sk name from different providers.', 'commenter': 'ShadowySpirits'}]"
6495,tieredstore/src/main/java/org/apache/rocketmq/tieredstore/provider/TieredStoreProvider.java,"@@ -69,6 +75,6 @@ public interface TieredStoreProvider {
      * @param append try to append or create a new file
      * @return put result, <code>true</code> if data successfully write; <code>false</code> otherwise
      */
-    CompletableFuture<Boolean> commit0(TieredFileSegment.TieredFileSegmentInputStream inputStream,
-        long position, int length, boolean append);
+    CompletableFuture<Boolean> commit0(InputStream inputStream,","[{'comment': 'We should not change this.', 'commenter': 'ShadowySpirits'}]"
6495,tieredstore/src/main/java/org/apache/rocketmq/tieredstore/provider/s3/TieredStorageS3Client.java,"@@ -0,0 +1,325 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.s3;
+
+import com.google.common.annotations.VisibleForTesting;
+import org.apache.rocketmq.common.ThreadFactoryImpl;
+import org.apache.rocketmq.logging.org.slf4j.Logger;
+import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
+import software.amazon.awssdk.core.async.AsyncRequestBody;
+import software.amazon.awssdk.core.async.AsyncResponseTransformer;
+import software.amazon.awssdk.regions.Region;
+import software.amazon.awssdk.services.s3.S3AsyncClient;
+import software.amazon.awssdk.services.s3.model.AbortMultipartUploadRequest;
+import software.amazon.awssdk.services.s3.model.CompleteMultipartUploadRequest;
+import software.amazon.awssdk.services.s3.model.CompletedMultipartUpload;
+import software.amazon.awssdk.services.s3.model.CompletedPart;
+import software.amazon.awssdk.services.s3.model.CreateMultipartUploadRequest;
+import software.amazon.awssdk.services.s3.model.CreateMultipartUploadResponse;
+import software.amazon.awssdk.services.s3.model.Delete;
+import software.amazon.awssdk.services.s3.model.DeleteObjectsRequest;
+import software.amazon.awssdk.services.s3.model.GetObjectRequest;
+import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;
+import software.amazon.awssdk.services.s3.model.ObjectIdentifier;
+import software.amazon.awssdk.services.s3.model.PutObjectRequest;
+import software.amazon.awssdk.services.s3.model.PutObjectResponse;
+import software.amazon.awssdk.services.s3.model.UploadPartCopyRequest;
+
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.stream.Collectors;
+
+public class TieredStorageS3Client {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(TieredStoreUtil.TIERED_STORE_LOGGER_NAME);
+    private volatile static TieredStorageS3Client instance;
+
+    private final String region;
+
+    private final String bucket;
+
+    private final TieredMessageStoreConfig tieredMessageStoreConfig;
+
+    private final ExecutorService asyncRequestBodyExecutor;
+
+    private S3AsyncClient client;
+
+    public static TieredStorageS3Client getInstance(TieredMessageStoreConfig config) {
+        if (config == null) {
+            return instance;
+        }
+        if (instance == null) {
+            synchronized (TieredStorageS3Client.class) {
+                if (instance == null) {
+                    instance = new TieredStorageS3Client(config, true);
+                }
+            }
+        }
+        return instance;
+    }
+
+    @VisibleForTesting
+    public TieredStorageS3Client(TieredMessageStoreConfig config) {
+        this(config, false);
+    }","[{'comment': 'This constructor is already public.', 'commenter': 'ShadowySpirits'}]"
6495,tieredstore/src/main/java/org/apache/rocketmq/tieredstore/provider/s3/TieredStorageS3Client.java,"@@ -0,0 +1,325 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.s3;
+
+import com.google.common.annotations.VisibleForTesting;
+import org.apache.rocketmq.common.ThreadFactoryImpl;
+import org.apache.rocketmq.logging.org.slf4j.Logger;
+import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
+import software.amazon.awssdk.core.async.AsyncRequestBody;
+import software.amazon.awssdk.core.async.AsyncResponseTransformer;
+import software.amazon.awssdk.regions.Region;
+import software.amazon.awssdk.services.s3.S3AsyncClient;
+import software.amazon.awssdk.services.s3.model.AbortMultipartUploadRequest;
+import software.amazon.awssdk.services.s3.model.CompleteMultipartUploadRequest;
+import software.amazon.awssdk.services.s3.model.CompletedMultipartUpload;
+import software.amazon.awssdk.services.s3.model.CompletedPart;
+import software.amazon.awssdk.services.s3.model.CreateMultipartUploadRequest;
+import software.amazon.awssdk.services.s3.model.CreateMultipartUploadResponse;
+import software.amazon.awssdk.services.s3.model.Delete;
+import software.amazon.awssdk.services.s3.model.DeleteObjectsRequest;
+import software.amazon.awssdk.services.s3.model.GetObjectRequest;
+import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;
+import software.amazon.awssdk.services.s3.model.ObjectIdentifier;
+import software.amazon.awssdk.services.s3.model.PutObjectRequest;
+import software.amazon.awssdk.services.s3.model.PutObjectResponse;
+import software.amazon.awssdk.services.s3.model.UploadPartCopyRequest;
+
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.stream.Collectors;
+
+public class TieredStorageS3Client {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(TieredStoreUtil.TIERED_STORE_LOGGER_NAME);
+    private volatile static TieredStorageS3Client instance;
+
+    private final String region;
+
+    private final String bucket;
+
+    private final TieredMessageStoreConfig tieredMessageStoreConfig;
+
+    private final ExecutorService asyncRequestBodyExecutor;
+
+    private S3AsyncClient client;
+
+    public static TieredStorageS3Client getInstance(TieredMessageStoreConfig config) {
+        if (config == null) {
+            return instance;
+        }
+        if (instance == null) {
+            synchronized (TieredStorageS3Client.class) {
+                if (instance == null) {
+                    instance = new TieredStorageS3Client(config, true);
+                }
+            }
+        }
+        return instance;
+    }
+
+    @VisibleForTesting
+    public TieredStorageS3Client(TieredMessageStoreConfig config) {
+        this(config, false);
+    }
+
+    private TieredStorageS3Client(TieredMessageStoreConfig config, boolean createClient) {
+        this.tieredMessageStoreConfig = config;
+        this.region = config.getS3Region();
+        this.bucket = config.getS3Bucket();
+        if (createClient) {
+            AwsBasicCredentials basicCredentials = AwsBasicCredentials.create(this.tieredMessageStoreConfig.getS3AccessKey(), this.tieredMessageStoreConfig.getS3SecretKey());
+            this.client = S3AsyncClient.builder().credentialsProvider(() -> basicCredentials).region(Region.of(config.getS3Region())).build();
+        }
+        this.asyncRequestBodyExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryImpl(""S3AsyncRequestBodyExecutor_""));
+    }
+
+
+    public CompletableFuture<Boolean> writeChunk(String key, InputStream inputStream, long length) {
+        PutObjectRequest putObjectRequest = PutObjectRequest.builder().bucket(this.bucket).key(key).build();
+        AsyncRequestBody requestBody = AsyncRequestBody.fromInputStream(inputStream, length, this.asyncRequestBodyExecutor);
+        CompletableFuture<PutObjectResponse> putObjectResponseCompletableFuture = this.client.putObject(putObjectRequest, requestBody);
+        CompletableFuture<Boolean> completableFuture = new CompletableFuture<>();
+        putObjectResponseCompletableFuture.whenComplete((putObjectResponse, throwable) -> {
+            if (throwable != null) {
+                LOGGER.error(""Upload file to S3 failed, key: {}, region: {}, bucket: {}"", key, this.region, this.bucket, throwable);
+                completableFuture.complete(false);
+            } else {
+                completableFuture.complete(true);
+            }
+        });
+        return completableFuture;
+    }
+
+    public CompletableFuture<List<ChunkMetadata>> listChunks(String prefix) {
+        CompletableFuture<List<ChunkMetadata>> completableFuture = new CompletableFuture<>();
+        CompletableFuture<ListObjectsV2Response> listFuture = this.client.listObjectsV2(builder -> builder.bucket(this.bucket).prefix(prefix));
+        listFuture.whenComplete((listObjectsV2Response, throwable) -> {
+            if (throwable != null) {
+                LOGGER.error(""List objects from S3 failed, prefix: {}, region: {}, bucket: {}"", prefix, this.region, this.bucket, throwable);
+                completableFuture.complete(Collections.emptyList());
+            } else {
+                listObjectsV2Response.contents().forEach(s3Object -> {
+                    LOGGER.info(""List objects from S3, key: {}, region: {}, bucket: {}"", s3Object.key(), this.region, this.bucket);
+                });
+                completableFuture.complete(listObjectsV2Response.contents().stream().map(obj -> {
+                    ChunkMetadata chunkMetadata = new ChunkMetadata();
+                    String key = obj.key();
+                    chunkMetadata.setChunkName(key);
+                    chunkMetadata.setChunkSize(obj.size().intValue());
+                    String[] paths = key.split(""/"");
+                    String chunkSubName = paths[paths.length - 1];
+                    Integer startPosition = Integer.valueOf(chunkSubName.split(""-"")[1]);
+                    chunkMetadata.setStartPosition(startPosition);
+                    return chunkMetadata;
+                }).sorted(new Comparator<ChunkMetadata>() {
+                    @Override
+                    public int compare(ChunkMetadata o1, ChunkMetadata o2) {
+                        return (int) (o1.getStartPosition() - o2.getStartPosition());
+                    }
+                }).collect(Collectors.toList()));
+            }
+        });
+        return completableFuture;
+    }
+
+    public CompletableFuture<Boolean> exist(String prefix) {
+        CompletableFuture<ListObjectsV2Response> listFuture = this.client.listObjectsV2(builder -> builder.bucket(this.bucket).prefix(prefix));
+        return listFuture.thenApply(resp -> {
+            return resp.contents().size() > 0;
+        });
+    }
+
+    public CompletableFuture<Boolean> deleteObject(String key) {
+        CompletableFuture<Boolean> future = new CompletableFuture<>();
+        this.client.deleteObject(builder -> builder.bucket(this.bucket).key(key)).whenComplete((deleteObjectResponse, throwable) -> {
+            if (throwable != null) {
+                LOGGER.error(""Delete object from S3 failed, key: {}, region: {}, bucket: {}"", key, this.region, this.bucket, throwable);
+                future.complete(false);
+            } else {
+                LOGGER.info(""Delete object from S3, key: {}, region: {}, bucket: {}"", key, this.region, this.bucket);
+                future.complete(true);
+            }
+        });
+        return future;
+    }
+
+    public CompletableFuture<List<String/*undeleted keys*/>> deleteObjets(final List<String> keys) {
+        if (keys == null || keys.isEmpty()) {
+            return CompletableFuture.completedFuture(Collections.emptyList());
+        }
+        List<ObjectIdentifier> objects = keys.stream().map(key -> ObjectIdentifier.builder().key(key).build()).collect(Collectors.toList());
+        Delete delete = Delete.builder().objects(objects).build();
+        DeleteObjectsRequest deleteObjectsRequest = DeleteObjectsRequest.builder().bucket(this.bucket).delete(delete).build();
+        return this.client.deleteObjects(deleteObjectsRequest).thenApply(resp -> {
+            List<String> undeletedKeys = null;
+            if (resp.deleted().size() != keys.size()) {
+                List<String> deleted = resp.deleted().stream().map(deletedObject -> deletedObject.key()).collect(Collectors.toList());
+                undeletedKeys = keys.stream().filter(key -> !deleted.contains(key)).collect(Collectors.toList());
+            } else {
+                undeletedKeys = Collections.emptyList();
+            }
+            return undeletedKeys;
+        }).exceptionally(throwable -> {
+            LOGGER.error(""Delete objects from S3 failed, keys: {}, region: {}, bucket: {}"", keys, this.region, this.bucket, throwable);
+            return keys;
+        });
+    }
+
+    public CompletableFuture<List<String>> deleteObjects(String prefix) {
+        CompletableFuture<List<String>> readObjectsByPrefix = this.client.listObjectsV2(builder -> builder.bucket(this.bucket).prefix(prefix)).thenApply(resp -> {
+            return resp.contents().stream().map(s3Object -> s3Object.key()).collect(Collectors.toList());
+        });
+        return readObjectsByPrefix.thenCompose(keys -> {
+            return this.deleteObjets(keys);","[{'comment': 'Many lambda functions in this file could be simplified, please follow the suggestions from idea.', 'commenter': 'ShadowySpirits'}]"
6495,tieredstore/src/main/java/org/apache/rocketmq/tieredstore/provider/s3/ChunkMetadata.java,"@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.s3;
+
+/**
+ * Metadata of a chunk in S3.
+ *
+ * <p>
+ * There are two types of chunks in S3:
+ * <ul>
+ *     <li>Normal chunk, represents a normal chunk in S3, which size is usually less than {@link org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig#tieredStoreGroupCommitSize}
+ *     <li>Segment chunk, means that this all normal chunks in one logic segment have been merged into a single chunk, which is named as segment chunk,
+ *     which size is usually equals to {@link org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig#tieredStoreCommitLogMaxSize} or {@link org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig#tieredStoreConsumeQueueMaxSize}","[{'comment': '`tieredStoreCommitLogMaxSize` is private, use the get function instead.', 'commenter': 'ShadowySpirits'}]"
6495,tieredstore/src/main/java/org/apache/rocketmq/tieredstore/provider/s3/ChunkMetadata.java,"@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.s3;
+
+/**
+ * Metadata of a chunk in S3.
+ *
+ * <p>
+ * There are two types of chunks in S3:
+ * <ul>
+ *     <li>Normal chunk, represents a normal chunk in S3, which size is usually less than {@link org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig#tieredStoreGroupCommitSize}
+ *     <li>Segment chunk, means that this all normal chunks in one logic segment have been merged into a single chunk, which is named as segment chunk,
+ *     which size is usually equals to {@link org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig#tieredStoreCommitLogMaxSize} or {@link org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig#tieredStoreConsumeQueueMaxSize}
+ * </ul>
+ * Once a segment chunk is created, it will never be changed, and we should delete all normal chunks in this segment.
+ */
+public class ChunkMetadata {
+
+    /**
+     * Name of the chunk in S3. Format:
+     * <p>
+     * Chunk:
+     * <pre>
+     *     {@link S3FileSegment#storePath}/chunk/chunk-${startPosition}","[{'comment': 'Ditto.', 'commenter': 'ShadowySpirits'}]"
6507,broker/src/main/java/org/apache/rocketmq/broker/coldctr/ColdDataPullRequestHoldService.java,"@@ -0,0 +1,105 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.broker.coldctr;
+
+import java.util.Iterator;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import org.apache.rocketmq.broker.BrokerController;
+import org.apache.rocketmq.broker.longpolling.PullRequest;
+import org.apache.rocketmq.common.ServiceThread;
+import org.apache.rocketmq.common.SystemClock;
+import org.apache.rocketmq.common.constant.LoggerName;
+import org.apache.rocketmq.logging.org.slf4j.Logger;
+import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
+
+/**
+ * just requests are type of pull have the qualification to be put into this hold queue.
+ * if the pull request is reading cold data and that request will be cold at the first time,
+ * then the pull request will be cold in this @code pullRequestLinkedBlockingQueue,
+ * in @code coldTimeoutMillis later the pull request will be warm and marked holded
+ */
+public class ColdDataPullRequestHoldService extends ServiceThread {
+
+    private static final Logger log = LoggerFactory.getLogger(LoggerName.ROCKETMQ_COLDCTR_LOGGER_NAME);
+    public static final String NO_SUSPEND_KEY = ""_noSuspend_"";
+
+    private final long coldHoldTimeoutMillis = 3000;
+    private final SystemClock systemClock = new SystemClock();
+    private final BrokerController brokerController;
+    private final LinkedBlockingQueue<PullRequest> pullRequestColdHoldQueue = new LinkedBlockingQueue<>(10000);
+
+    public void suspendColdDataReadRequest(PullRequest pullRequest) {
+        if (this.brokerController.getMessageStoreConfig().isColdDataFlowControlEnable()) {
+            pullRequestColdHoldQueue.offer(pullRequest);
+        }
+    }
+
+    public ColdDataPullRequestHoldService(BrokerController brokerController) {
+        this.brokerController = brokerController;
+    }
+
+    @Override
+    public String getServiceName() {
+        return ColdDataPullRequestHoldService.class.getSimpleName();
+    }
+
+    @Override
+    public void run() {
+        log.info(""{} service started"", this.getServiceName());
+        while (!this.isStopped()) {
+            try {
+                if (!this.brokerController.getMessageStoreConfig().isColdDataFlowControlEnable()) {
+                    this.waitForRunning(20 * 1000);","[{'comment': 'Is it possible to continue after waiting for 20 seconds here? If cold control is not enabled, can the subsequent process of processing pullRequest be skipped?', 'commenter': 'GenerousMan'}]"
6507,broker/src/main/java/org/apache/rocketmq/broker/coldctr/PIDAdaptiveColdCtrStrategy.java,"@@ -0,0 +1,79 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.broker.coldctr;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+public class PIDAdaptiveColdCtrStrategy implements ColdCtrStrategy {
+    private static final int MAX_STORE_NUMS = 10;
+    private static final Double KP = 0.5, KI = 0.3, KD = 0.2;","[{'comment': 'Maybe add some explanation would be better? Because the design of PID is very intelligent, and it can deal with different scenarios by setting the values of P, I, and D. However, the setting of KP, KI, and KD values needs to follow some principles, we could add some clarification or constraints here.', 'commenter': 'GenerousMan'}, {'comment': 'There are many esoteric values in this code. A brief explanation of these values can help users better adjust the strategy according to their own conditions.', 'commenter': 'GenerousMan'}]"
6507,broker/src/main/resources/rmq.broker.logback.xml,"@@ -498,6 +498,34 @@
         <appender-ref ref=""RocketmqPopSiftingAppender_inner""/>
     </appender>
 
+    <appender name=""RocketmqColdCtrSiftingAppender"" class=""ch.qos.logback.classic.sift.SiftingAppender"">
+        <discriminator>
+            <key>brokerContainerLogDir</key>
+            <defaultValue>${file.separator}</defaultValue>
+        </discriminator>
+        <sift>
+            <appender name=""RocketmqPopAppender""","[{'comment': ""The appender's name should be renamed."", 'commenter': 'GenerousMan'}]"
6507,tools/pom.xml,"@@ -60,5 +60,9 @@
             <groupId>com.google.guava</groupId>
             <artifactId>guava</artifactId>
         </dependency>
+        <dependency>
+            <groupId>org.apache.rocketmq</groupId>","[{'comment': 'Using ${project.groupId} will be better.', 'commenter': 'GenerousMan'}]"
6507,broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java,"@@ -1547,6 +1561,16 @@ protected void startBasicService() throws Exception {
             this.brokerPreOnlineService.start();
         }
 
+        if (this.coldDataPullRequestHoldService != null) {
+            this.coldDataPullRequestHoldService.start();
+        }
+
+        if (this.coldDataCgCtrService != null) {
+            this.coldDataCgCtrService.start();
+        }
+
+        //Init state version after messageStore initialized.
+        //this.topicConfigManager.initStateVersion();","[{'comment': 'It would be better to remove comment lines', 'commenter': 'RongtongJin'}]"
6507,broker/src/main/java/org/apache/rocketmq/broker/coldctr/ColdCtrStrategy.java,"@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.broker.coldctr;
+
+public interface ColdCtrStrategy {
+    Double decisionFactor();
+
+    void promote(String consumerGroup, Long currentThreshold);
+
+    void decelerate(String consumerGroup, Long currentThreshold);
+
+    void collect(Long globalAcc);","[{'comment': 'It would be better to add some comments on interface to explain the meaning of methods and parameters.', 'commenter': 'RongtongJin'}, {'comment': ""That's a very good idea～"", 'commenter': 'zk-drizzle'}]"
6507,broker/src/main/resources/rmq.broker.logback.xml,"@@ -595,6 +623,15 @@
         <appender-ref ref=""RocketmqPopSiftingAppender""/>
     </logger>
 
+    <logger name=""RocketmqColdCtr"" additivity=""false"">
+        <level value=""INFO""/>
+        <appender-ref ref=""RocketmqColdCtrSiftingAppender""/>
+    </logger>
+
+    <logger name=""RocketmqTraffic"" additivity=""false"">
+        <level value=""INFO""/>
+    </logger>","[{'comment': 'Why add this logger? It seems to have nothing to do with this PR', 'commenter': 'RongtongJin'}]"
6507,tools/pom.xml,"@@ -60,5 +60,9 @@
             <groupId>com.google.guava</groupId>
             <artifactId>guava</artifactId>
         </dependency>
+        <dependency>
+            <groupId>org.apache.rocketmq</groupId>
+            <artifactId>rocketmq-store</artifactId>
+        </dependency>","[{'comment': 'IMO, tools module should not depend on store module.', 'commenter': 'RongtongJin'}]"
6507,store/src/main/java/org/apache/rocketmq/store/DefaultMessageStore.java,"@@ -872,6 +872,10 @@ public GetMessageResult getMessage(final String group, final String topic, final
                                 continue;
                             }
 
+                            if (messageStoreConfig.isColdDataFlowControlEnable() && !selectResult.isInCache()) {","[{'comment': 'System Consumer Groups(such as TOOLS_CONSUMER_GROUP) need to be considered, to prevent them from being limited.', 'commenter': 'GenerousMan'}, {'comment': 'yes, good idea~', 'commenter': 'zk-drizzle'}]"
6507,store/src/main/java/org/apache/rocketmq/store/DefaultMessageStore.java,"@@ -1686,6 +1690,16 @@ public boolean checkInDiskByCommitOffset(long offsetPy) {
         return offsetPy >= commitLog.getMinOffset();
     }
 
+    /**
+     * The ratio val is estimated by the experiment and experience
+     * so that the result is not high accurate for different business
+     * @return
+     */
+    public boolean checkInColdAreaByCommitOffset(long offsetPy, long maxOffsetPy) {","[{'comment': 'IMO, using linux system call mincore() method to check file been cached or not will achieve higher accuracy, just like pcstat command in https://github.com/tobert/pcstat', 'commenter': 'lizhiboo'}, {'comment': 'This method mainily helps us distinguish between logical cold data and not. Sometimes it can prevent normal consumers from being cold controlled.', 'commenter': 'zk-drizzle'}, {'comment': 'Thank you for your review ～', 'commenter': 'zk-drizzle'}]"
6507,store/src/main/java/org/apache/rocketmq/store/util/LibC.java,"@@ -50,4 +52,8 @@ public interface LibC extends Library {
     int mlockall(int flags);
 
     int msync(Pointer p, NativeLong length, int flags);
+
+    int mincore(Pointer p, NativeLong length, byte[] vec);","[{'comment': 'We do not need to introduce mincore with JNI but use `MappedByteBuffer#isLoaded0` instead. Please see `DefaultMessageStore#checkInMemByCommitOffset` for example.', 'commenter': 'ShadowySpirits'}, {'comment': 'First of all, thank you very much for your review and reply. The MappedByteBuffer#isLoaded0 method was also considered early on to solve this problem, but the granularity of this method is a little somewhat broad (it only returns true if all pages of the detected block of data are in physical memory).', 'commenter': 'zk-drizzle'}, {'comment': '`MappedByteBuffer#isLoaded0` supports specifying the page you want to detect as a parameter\r\n\r\n```java\r\nprivate native boolean isLoaded0(long address, long length, int pageCount);\r\n```', 'commenter': 'ShadowySpirits'}, {'comment': 'In addition, there is already an `isLoaded` method in the MappedFile interface：\r\n\r\n```java\r\n/**\r\n * Check mapped file is loaded to memory with given position and size\r\n * @param position start offset of data\r\n * @param size data size\r\n * @return data is resided in memory or not\r\n */\r\nboolean isLoaded(long position, int size);\r\n```', 'commenter': 'ShadowySpirits'}]"
6507,store/src/main/java/org/apache/rocketmq/store/CommitLog.java,"@@ -1966,4 +2000,196 @@ public void cleanSwappedMap(long forceCleanSwapIntervalMs) {
     public FlushManager getFlushManager() {
         return flushManager;
     }
+
+    public class ColdDataCheckService extends ServiceThread {
+        private final SystemClock systemClock = new SystemClock();
+        private final ConcurrentHashMap<String, byte[]> pageCacheMap = new ConcurrentHashMap<>();
+        private int pageSize = -1;
+        private int sampleSteps = 32;
+
+        public ColdDataCheckService() {
+            sampleSteps = defaultMessageStore.getMessageStoreConfig().getSampleSteps();
+            if (sampleSteps <= 0) {
+                sampleSteps = 32;
+            }
+            initPageSize();
+            scanFilesInPageCache();
+        }
+
+        @Override
+        public String getServiceName() {
+            return ColdDataCheckService.class.getSimpleName();
+        }
+
+        @Override
+        public void run() {
+            log.info(""{} service started"", this.getServiceName());
+            while (!this.isStopped()) {
+                try {
+                    if (!defaultMessageStore.getMessageStoreConfig().isColdDataFlowControlEnable() || !defaultMessageStore.getMessageStoreConfig().isColdDataScanEnable()) {
+                        pageCacheMap.clear();
+                        this.waitForRunning(180 * 1000);
+                        continue;
+                    } else {
+                        this.waitForRunning(defaultMessageStore.getMessageStoreConfig().getTimerColdDataCheckIntervalMs());
+                    }
+                    long beginClockTimestamp = this.systemClock.now();
+                    scanFilesInPageCache();
+                    long costTime = this.systemClock.now() - beginClockTimestamp;
+                    log.info(""[{}] scanFilesInPageCache-cost {} ms."", costTime > 30 * 1000 ? ""NOTIFYME"" : ""OK"", costTime);
+                } catch (Throwable e) {
+                    log.warn(this.getServiceName() + "" service has e: {}"", e);
+                }
+            }
+            log.info(""{} service end"", this.getServiceName());
+        }
+
+        public boolean isDataInPageCache(final long offset) {
+            if (!defaultMessageStore.getMessageStoreConfig().isColdDataFlowControlEnable()) {
+                return true;
+            }
+            if (pageSize <= 0 || sampleSteps <= 0) {
+                return true;
+            }
+            if (!defaultMessageStore.checkInColdAreaByCommitOffset(offset, getMaxOffset())) {
+                return true;
+            }
+            if (!defaultMessageStore.getMessageStoreConfig().isColdDataScanEnable()) {
+                return false;
+            }
+
+            MappedFile mappedFile = mappedFileQueue.findMappedFileByOffset(offset, offset == 0);
+            if (null == mappedFile) {
+                return true;
+            }
+            byte[] bytes = pageCacheMap.get(mappedFile.getFileName());
+            if (null == bytes) {
+                return true;
+            }
+
+            int pos = (int)(offset % defaultMessageStore.getMessageStoreConfig().getMappedFileSizeCommitLog());
+            int realIndex = pos / pageSize / sampleSteps;
+            return bytes.length - 1 >= realIndex && bytes[realIndex] != 0;
+        }
+
+        private void scanFilesInPageCache() {
+            if (!defaultMessageStore.getMessageStoreConfig().isColdDataFlowControlEnable() || !defaultMessageStore.getMessageStoreConfig().isColdDataScanEnable()) {
+                return;
+            }
+
+            try {
+                log.info(""pageCacheMap key size: {}"", pageCacheMap.size());
+                clearExpireMappedFile();
+                mappedFileQueue.getMappedFiles().stream().forEach(mappedFile -> {","[{'comment': 'stream() is not need for forEach', 'commenter': 'dingshuangxi888'}, {'comment': ""Thank you very much for your review，I'd be happy to take your advice."", 'commenter': 'zk-drizzle'}]"
6507,store/src/main/java/org/apache/rocketmq/store/CommitLog.java,"@@ -1966,4 +2000,196 @@ public void cleanSwappedMap(long forceCleanSwapIntervalMs) {
     public FlushManager getFlushManager() {
         return flushManager;
     }
+
+    public class ColdDataCheckService extends ServiceThread {
+        private final SystemClock systemClock = new SystemClock();
+        private final ConcurrentHashMap<String, byte[]> pageCacheMap = new ConcurrentHashMap<>();
+        private int pageSize = -1;
+        private int sampleSteps = 32;
+
+        public ColdDataCheckService() {
+            sampleSteps = defaultMessageStore.getMessageStoreConfig().getSampleSteps();
+            if (sampleSteps <= 0) {
+                sampleSteps = 32;
+            }
+            initPageSize();
+            scanFilesInPageCache();
+        }
+
+        @Override
+        public String getServiceName() {
+            return ColdDataCheckService.class.getSimpleName();
+        }
+
+        @Override
+        public void run() {
+            log.info(""{} service started"", this.getServiceName());
+            while (!this.isStopped()) {
+                try {
+                    if (!defaultMessageStore.getMessageStoreConfig().isColdDataFlowControlEnable() || !defaultMessageStore.getMessageStoreConfig().isColdDataScanEnable()) {
+                        pageCacheMap.clear();
+                        this.waitForRunning(180 * 1000);
+                        continue;
+                    } else {
+                        this.waitForRunning(defaultMessageStore.getMessageStoreConfig().getTimerColdDataCheckIntervalMs());
+                    }
+                    long beginClockTimestamp = this.systemClock.now();
+                    scanFilesInPageCache();
+                    long costTime = this.systemClock.now() - beginClockTimestamp;
+                    log.info(""[{}] scanFilesInPageCache-cost {} ms."", costTime > 30 * 1000 ? ""NOTIFYME"" : ""OK"", costTime);
+                } catch (Throwable e) {
+                    log.warn(this.getServiceName() + "" service has e: {}"", e);
+                }
+            }
+            log.info(""{} service end"", this.getServiceName());
+        }
+
+        public boolean isDataInPageCache(final long offset) {
+            if (!defaultMessageStore.getMessageStoreConfig().isColdDataFlowControlEnable()) {
+                return true;
+            }
+            if (pageSize <= 0 || sampleSteps <= 0) {
+                return true;
+            }
+            if (!defaultMessageStore.checkInColdAreaByCommitOffset(offset, getMaxOffset())) {
+                return true;
+            }
+            if (!defaultMessageStore.getMessageStoreConfig().isColdDataScanEnable()) {
+                return false;
+            }
+
+            MappedFile mappedFile = mappedFileQueue.findMappedFileByOffset(offset, offset == 0);
+            if (null == mappedFile) {
+                return true;
+            }
+            byte[] bytes = pageCacheMap.get(mappedFile.getFileName());
+            if (null == bytes) {
+                return true;
+            }
+
+            int pos = (int)(offset % defaultMessageStore.getMessageStoreConfig().getMappedFileSizeCommitLog());
+            int realIndex = pos / pageSize / sampleSteps;
+            return bytes.length - 1 >= realIndex && bytes[realIndex] != 0;
+        }
+
+        private void scanFilesInPageCache() {
+            if (!defaultMessageStore.getMessageStoreConfig().isColdDataFlowControlEnable() || !defaultMessageStore.getMessageStoreConfig().isColdDataScanEnable()) {
+                return;
+            }
+
+            try {
+                log.info(""pageCacheMap key size: {}"", pageCacheMap.size());
+                clearExpireMappedFile();
+                mappedFileQueue.getMappedFiles().stream().forEach(mappedFile -> {
+                    byte[] pageCacheTable = checkFileInPageCache(mappedFile);
+                    if (sampleSteps > 1) {
+                        pageCacheTable = sampling(pageCacheTable, sampleSteps);
+                    }
+                    pageCacheMap.put(mappedFile.getFileName(), pageCacheTable);
+                });
+            } catch (Exception e) {
+                log.error(""scanFilesInPageCache exception"", e);
+            }
+        }
+
+        private void clearExpireMappedFile() {
+            Set<String> currentFileSet = mappedFileQueue.getMappedFiles()
+                .stream().map(MappedFile::getFileName).collect(Collectors.toSet());
+            pageCacheMap.entrySet().stream().forEach(entry -> {","[{'comment': 'stream() is not need for forEach', 'commenter': 'dingshuangxi888'}, {'comment': ""Thank you very much for your review，I'd be happy to take your advice."", 'commenter': 'zk-drizzle'}]"
6522,proxy/src/main/java/org/apache/rocketmq/proxy/grpc/interceptor/AuthenticationInterceptor.java,"@@ -48,7 +48,7 @@ public <R, W> ServerCall.Listener<R> interceptCall(ServerCall<R, W> call, Metada
             @Override
             public void onMessage(R message) {
                 GeneratedMessageV3 messageV3 = (GeneratedMessageV3) message;
-                headers.put(InterceptorConstants.RPC_NAME, messageV3.getDescriptorForType().getFullName());
+                headers.put(InterceptorConstants.RPC_NAME, messageV3.getDescriptorForType().getName());","[{'comment': 'FullName is needed for future version compatibility.', 'commenter': 'drpmma'}, {'comment': 'I have followed your suggestion and used the new SIMPLE_RPC_NAME attribute to record the action name needed later.', 'commenter': 'lyx2000'}, {'comment': '@drpmma Please take a look.', 'commenter': 'lyx2000'}]"
6522,proxy/src/main/java/org/apache/rocketmq/proxy/common/ProxyContext.java,"@@ -122,4 +122,13 @@ public String getAction() {
         return this.getVal(ContextVariable.ACTION);
     }
 
+    public ProxyContext setProtocol(String protocol) {","[{'comment': 'Rename to `ProtocolType` is better', 'commenter': 'xdkxlk'}, {'comment': 'Roger', 'commenter': 'lyx2000'}]"
6522,proxy/src/main/java/org/apache/rocketmq/proxy/common/ContextVariable.java,"@@ -26,4 +26,6 @@ public class ContextVariable {
     public static final String CLIENT_VERSION = ""client-version"";
     public static final String REMAINING_MS = ""remaining-ms"";
     public static final String ACTION = ""action"";
+    public static final String PROTOCOL = ""protocol"";","[{'comment': 'Rename to `protocol-type` is better', 'commenter': 'xdkxlk'}]"
6522,proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/ClientManagerActivity.java,"@@ -82,6 +83,7 @@ protected RemotingCommand heartBeat(ChannelHandlerContext ctx, RemotingCommand r
                 this.remotingChannelManager.createProducerChannel(ctx.channel(), data.getGroupName(), clientId),
                 clientId, request.getLanguage(),
                 request.getVersion());
+            setClientPropertiesToChannelAttr(clientChannelInfo);","[{'comment': 'Why do we need to add properties to the channel attribute when we have already passed the `clientId`, `language`, and `version` to `ClientChannelInfo`?', 'commenter': 'xdkxlk'}, {'comment': ""Well, that's the problem. `ClientChannelInfo` only appears and can be accessed when client heartbeat. However, when it comes to message actions, which can not access `ClientChannelInfo`, their ProxyContext's  `clientId`, `language`, and `version` is empty. So in my pr, I put ClientChannelInfo to channel attr, in order that message actions' ProxyContext also have those client properties."", 'commenter': 'lyx2000'}]"
6522,proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/GrpcMessagingApplication.java,"@@ -171,9 +172,10 @@ protected ProxyContext createContext() {
             .setLocalAddress(getDefaultStringMetadataInfo(headers, InterceptorConstants.LOCAL_ADDRESS))
             .setRemoteAddress(getDefaultStringMetadataInfo(headers, InterceptorConstants.REMOTE_ADDRESS))
             .setClientID(getDefaultStringMetadataInfo(headers, InterceptorConstants.CLIENT_ID))
+            .setProtocolType(ChannelProtocolType.GRPC_V2.getName())
             .setLanguage(getDefaultStringMetadataInfo(headers, InterceptorConstants.LANGUAGE))
             .setClientVersion(getDefaultStringMetadataInfo(headers, InterceptorConstants.CLIENT_VERSION))
-            .setAction(getDefaultStringMetadataInfo(headers, InterceptorConstants.RPC_NAME));
+            .setAction(getDefaultStringMetadataInfo(headers, InterceptorConstants.SIMPLE_RPC_NAME));","[{'comment': ""It's recommended to keep RPC_NAME."", 'commenter': 'drpmma'}, {'comment': 'For the class `ProxyContext`, I have already added the `PROTOCOL_TYPE` attribute to record the protocol. In order to align with the proxyContext of remoteing, there is no need to repeat protocol prefix.', 'commenter': 'lyx2000'}]"
6538,broker/src/main/java/org/apache/rocketmq/broker/BrokerStartup.java,"@@ -167,7 +167,6 @@ public static BrokerController buildBrokerController(String[] args) throws Excep
             System.exit(-4);
         }
 
-        messageStoreConfig.setHaListenPort(nettyServerConfig.getListenPort() + 1);","[{'comment': 'If the user has not configured it, could the default port for HA be set to nettyServerConfig.getListenPort() + 1 ?', 'commenter': 'RongtongJin'}, {'comment': ""haListenPort default value is nettyServerConfig.getListenPort()'default value +1\r\n\r\n![image](https://user-images.githubusercontent.com/63851981/230263729-f9e4a30d-99b5-441a-af42-0464d4464fed.png)\r\n"", 'commenter': 'haiyanghan'}, {'comment': 'nettyServerConfig.listenPort default value is 10911\r\n\r\n![image](https://user-images.githubusercontent.com/63851981/230264596-867b5f78-86da-452b-8f0d-a326f9cb520b.png)\r\n', 'commenter': 'haiyanghan'}, {'comment': 'IMO this PR will break the compatibility, that is, the default value of `haLitenPort` is `listenPort + 1`. Users setting `listenPort` but not setting `haLitenPort` explicitly will find `haLitenPort` changes after updating to new version.\r\n\r\nThe more appropriate way may be: \r\n\r\n- if `haLitenPort` is set explicitly, use the value set by user; \r\n- if `haLitenPort` is not set, assign `listenPort + 1` to it.\r\n', 'commenter': 'caigy'}]"
6568,client/src/main/java/org/apache/rocketmq/client/common/ThreadLocalIndex.java,"@@ -33,6 +33,13 @@ public int incrementAndGet() {
         return Math.abs(index & POSITIVE_MASK);
     }
 
+    public void reset() {
+        int index = Math.abs(random.nextInt());
+        if (index < 0)
+            index = 0;","[{'comment': ' the code redundant', 'commenter': 'fuyou001'}]"
6568,client/src/main/java/org/apache/rocketmq/client/ClientConfig.java,"@@ -79,6 +89,10 @@ public class ClientConfig {
      */
     protected boolean enableStreamRequestType = false;
 
+    private boolean sendLatencyEnable = Boolean.parseBoolean(System.getProperty(SEND_LATENCY_ENABLE, ""false""));","[{'comment': 'Would it be prudent to incorporate a warning concerning order message within the document,may be order message  is disturbed', 'commenter': 'fuyou001'}]"
6568,client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java,"@@ -2846,6 +2849,37 @@ public void setMessageRequestMode(final String brokerAddr, final String topic, f
             throw new MQClientException(response.getCode(), response.getRemark());
         }
     }
+    public Properties queryRemoteClientConfig(long timeoutMillis)","[{'comment': ' may be increased namesrv server load', 'commenter': 'fuyou001'}, {'comment': 'OK, I will remove this design.', 'commenter': 'GenerousMan'}]"
6568,client/src/main/java/org/apache/rocketmq/client/RemoteClientConfig.java,"@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.client;
+
+import org.apache.rocketmq.client.impl.factory.MQClientInstance;
+import org.apache.rocketmq.logging.org.slf4j.Logger;
+import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
+
+/**
+ * Remoting Client Common configuration
+ */
+public class RemoteClientConfig {
+    private final static Logger log = LoggerFactory.getLogger(MQClientInstance.class);","[{'comment': 'It seems more appropriate to write it like this:\r\n`private final static Logger log = LoggerFactory.getLogger(RemoteClientConfig.class);`', 'commenter': 'HScarb'}, {'comment': 'Yes, It should be. But I think I will remove this RemoteClientConfig... \r\nThe switches in clientConfig are enough.', 'commenter': 'GenerousMan'}]"
6568,client/src/main/java/org/apache/rocketmq/client/impl/producer/DefaultMQProducerImpl.java,"@@ -153,6 +157,38 @@ public DefaultMQProducerImpl(final DefaultMQProducer defaultMQProducer, RPCHook
             semaphoreAsyncSendSize = new Semaphore(1024 * 1024, true);
             log.info(""semaphoreAsyncSendSize can not be smaller than 1M."");
         }
+
+        ServiceDetector serviceDetector = new ServiceDetector() {
+            @Override
+            public boolean detect(String endpoint, long timeoutMillis) {
+                Optional<String> candidateTopic = pickTopic();
+                if (!candidateTopic.isPresent()) {
+                    return false;
+                }
+                try {
+                    MessageQueue mq = new MessageQueue(candidateTopic.get(), null, 0);
+                    mQClientFactory.getMQClientAPIImpl()
+                            .getMaxOffset(endpoint, mq, timeoutMillis);
+                    return true;
+                } catch (Exception e) {
+                    return false;
+                }
+            }
+        };","[{'comment': ""When there are many clients (such as 1 million producers or consumers, which by default probe every broker every 3 seconds), is GetMaxOffset a relatively heavy operation? Could it put pressure on the broker? Here are my two suggestions:\r\n\r\n1.The RemotingClient's isAddressReachable method could be used to complete connection detection and check if the long connection channel is normal, which is lighter weight.\r\n2.If it is necessary to check if the broker's execution logic is normal, could it be replaced with VIEW_BROKER_STATS_DATA? This request does not require topic or message queue related data and does not involve the store layer."", 'commenter': 'RongtongJin'}, {'comment': 'Very elegant solution. I will modify as you said.', 'commenter': 'GenerousMan'}]"
6568,proxy/src/main/java/org/apache/rocketmq/proxy/service/route/MessageQueueSelector.java,"@@ -154,6 +157,82 @@ public AddressableMessageQueue selectOne(boolean onlyBroker) {
         return selectOneByIndex(nextIndex, onlyBroker);
     }
 
+    public AddressableMessageQueue selectOneByPipeline(TopicRouteService topicRouteService, boolean onlyBroker) {","[{'comment': 'It would be better to pass the TopicRouteService when constructing the MessageQueueSelector', 'commenter': 'xdkxlk'}, {'comment': 'You are right. I have modified codes as you said. You can check the commit history.\r\nThank you~', 'commenter': 'GenerousMan'}]"
6568,proxy/src/main/java/org/apache/rocketmq/proxy/service/route/MessageQueueSelector.java,"@@ -154,6 +171,82 @@ public AddressableMessageQueue selectOne(boolean onlyBroker) {
         return selectOneByIndex(nextIndex, onlyBroker);
     }
 
+    public AddressableMessageQueue selectOneByPipeline(boolean onlyBroker) {
+        if (topicRouteService.getMqFaultStrategy().isSendLatencyFaultEnable() && topicRouteService != null) {","[{'comment': 'TopicRouteService could be null if it is not passed into the constructor.\r\nMoreover, if the constructor without topicRouteService is no longer used, we can delete it.', 'commenter': 'xdkxlk'}, {'comment': 'Yes, I have modified as you said. You can check commits history.\r\nThank you!', 'commenter': 'GenerousMan'}]"
6568,proxy/src/main/java/org/apache/rocketmq/proxy/processor/ProducerProcessor.java,"@@ -102,11 +108,18 @@ public CompletableFuture<List<SendResult>> sendMessage(ProxyContext ctx, QueueSe
                         if (SendStatus.SEND_OK.equals(sendResult.getSendStatus()) &&
                             tranType == MessageSysFlag.TRANSACTION_PREPARED_TYPE &&
                             StringUtils.isNotBlank(sendResult.getTransactionId())) {
-                            fillTransactionData(ctx, producerGroup, messageQueue, sendResult, messageList);
+                            fillTransactionData(ctx, producerGroup, finalMessageQueue, sendResult, messageList);
                         }
                     }
+                    endTimestamp.set(System.currentTimeMillis());
+                    this.serviceManager.getTopicRouteService().updateFaultItem(finalMessageQueue.getBrokerName(),endTimestamp.get() - beginTimestampFirst, false, true);
                     return sendResultList;
-                }, this.executor);
+                }, this.executor)
+                    .exceptionally(t -> {","[{'comment': 'Use whenComplete is better. When an exception occurs, the upper layer function will get null in thenApply', 'commenter': 'xdkxlk'}]"
6568,client/src/main/java/org/apache/rocketmq/client/latency/LatencyFaultToleranceImpl.java,"@@ -65,68 +140,99 @@ public void remove(final String name) {
     @Override
     public String pickOneAtLeast() {
         final Enumeration<FaultItem> elements = this.faultItemTable.elements();
-        List<FaultItem> tmpList = new LinkedList<>();
+        List<FaultItem> tmpList = new LinkedList<FaultItem>();
         while (elements.hasMoreElements()) {
             final FaultItem faultItem = elements.nextElement();
             tmpList.add(faultItem);
         }
+
         if (!tmpList.isEmpty()) {
-            Collections.sort(tmpList);
-            final int half = tmpList.size() / 2;
-            if (half <= 0) {
-                return tmpList.get(0).getName();
-            } else {
-                final int i = this.randomItem.incrementAndGet() % half;
-                return tmpList.get(i).getName();
+            Collections.shuffle(tmpList);
+            //Collections.sort(tmpList);","[{'comment': 'annotation could be removed', 'commenter': 'drpmma'}]"
6568,proxy/src/main/java/org/apache/rocketmq/proxy/processor/ProducerProcessor.java,"@@ -102,11 +108,19 @@ public CompletableFuture<List<SendResult>> sendMessage(ProxyContext ctx, QueueSe
                         if (SendStatus.SEND_OK.equals(sendResult.getSendStatus()) &&
                             tranType == MessageSysFlag.TRANSACTION_PREPARED_TYPE &&
                             StringUtils.isNotBlank(sendResult.getTransactionId())) {
-                            fillTransactionData(ctx, producerGroup, messageQueue, sendResult, messageList);
+                            fillTransactionData(ctx, producerGroup, finalMessageQueue, sendResult, messageList);
                         }
                     }
                     return sendResultList;
-                }, this.executor);
+                }, this.executor)
+                    .whenComplete((result, exception) -> {
+                        endTimestamp.set(System.currentTimeMillis());","[{'comment': 'There is no need to use AtomicLong for `endTimestamp`, just a local variable would be fine', 'commenter': 'drpmma'}]"
6568,proxy/src/main/java/org/apache/rocketmq/proxy/service/route/MessageQueueSelector.java,"@@ -44,8 +47,9 @@ public class MessageQueueSelector {
     private final Map<String, AddressableMessageQueue> brokerNameQueueMap = new ConcurrentHashMap<>();
     private final AtomicInteger queueIndex;
     private final AtomicInteger brokerIndex;
+    private TopicRouteService topicRouteService;
 
-    public MessageQueueSelector(TopicRouteWrapper topicRouteWrapper, boolean read) {
+    public MessageQueueSelector(TopicRouteWrapper topicRouteWrapper, TopicRouteService topicRouteService, boolean read) {","[{'comment': 'Why not pass MqFaultStrategy instead of TopicRouteService as TopicRouteService is not actually used in this class.', 'commenter': 'drpmma'}]"
6580,client/src/main/java/org/apache/rocketmq/client/trace/AsyncTraceDispatcher.java,"@@ -328,13 +330,12 @@ public void addTraceTransferBean(TraceTransferBean traceTransferBean) {
             initFirstBeanAddTime();
             this.traceTransferBeanList.add(traceTransferBean);
             this.currentMsgSize += traceTransferBean.getTransData().length();
-            if (currentMsgSize >= traceProducer.getMaxMessageSize() - 10 * 1000) {
+            traceTransferBean.getTransKey().forEach(x -> this.currentMsgKeySize += x.length());","[{'comment': '[reduce](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-), IMO, is a better fit here.', 'commenter': 'lizhanhui'}, {'comment': '> Will `reduce` be a better fit than `forEach`?\r\n\r\nIs it modified like this `this.currentMsgKeySize = traceTransferBean.getTransKey().stream()\r\n                .reduce(currentMsgKeySize, (acc, x) -> acc + x.length(), Integer::sum);`? I feel even more complicated.', 'commenter': 'RongtongJin'}, {'comment': 'But JVM may potentially vectorize this loop, making SIMD possible', 'commenter': 'lizhanhui'}]"
6744,.github/workflows/snapshot-automation.yml,"@@ -1,11 +1,206 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
 name: Snapshot Release Automation
 on:
   schedule: # schedule the job to run at 12 a.m. daily","[{'comment': 'Could we rename this file since the function of this workflow has been changed.', 'commenter': 'aaron-ai'}]"
6744,.github/workflows/snapshot-automation.yml,"@@ -1,11 +1,206 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
 name: Snapshot Release Automation
 on:
   schedule: # schedule the job to run at 12 a.m. daily
     - cron: ""0 0 * * *""
 ","[{'comment': 'Do we need to allow manual triggering of builds and specifying of git commit id to help us perform builds and tests on any commit at any time?\r\n\r\nSee: https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch', 'commenter': 'aaron-ai'}, {'comment': 'Good idea, I will support it soon', 'commenter': 'cryptoya'}, {'comment': 'Manual trigger runs via branch or commitId are now supported', 'commenter': 'cryptoya'}]"
6744,.github/workflows/snapshot-automation.yml,"@@ -1,11 +1,206 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
 name: Snapshot Release Automation
 on:
   schedule: # schedule the job to run at 12 a.m. daily
     - cron: ""0 0 * * *""
 
+env:
+  MAVEN_OPTS: -Dhttp.keepAlive=false -Dmaven.wagon.http.pool=false -Dmaven.wagon.httpconnectionManager.ttlSeconds=120
+  DOCKER_REPO: apache/rocketmq-ci
+
 jobs:
+  dist-tar:
+    name: Build dist tar
+    runs-on: ubuntu-latest
+    timeout-minutes: 30
+    steps:
+      - uses: actions/checkout@v3
+        with:
+          submodules: true
+      - uses: actions/setup-java@v3
+        with:
+          distribution: ""temurin""
+          java-version: ""8""
+          cache: ""maven""
+      - name: Build distribution tar
+        env:
+          MAVEN_SETTINGS: ${{ github.workspace }}/.github/asf-deploy-settings.xml
+        run: |
+          mvn -Prelease-all -DskipTests -Dspotbugs.skip=true clean install -U
+      - uses: actions/upload-artifact@v3
+        name: Upload distribution tar
+        with:
+          name: rocketmq
+          path: distribution/target/rocketmq*/rocketmq*
+
+  docker-build:
+    if: ${{ success() }}
+    name: Docker images
+    needs: [ dist-tar ]
+    runs-on: ubuntu-latest
+    timeout-minutes: 30
+    strategy:
+      matrix:
+        base-image: [ ""ubuntu"" ]
+        java-version: [ ""8"" ]
+    steps:
+      - uses: actions/checkout@v3
+        with:
+          repository: apache/rocketmq-docker.git
+          ref: master
+          path: rocketmq-docker
+      - uses: actions/download-artifact@v3
+        name: Download distribution tar
+        with:
+          name: rocketmq
+          path: rocketmq
+      - name: docker-login
+        uses: docker/login-action@v2
+        with:
+          registry: ${{ env.REGISTRY }}
+          username: ${{ secrets.DOCKERHUB_USER }}
+          password: ${{ secrets.DOCKERHUB_TOKEN }}
+      - name: Build and save docker images
+        id: build-images
+        run: |
+          cd rocketmq-docker/image-build-ci
+          version=${{ github.event.pull_request.number || github.ref_name }}-$(uuidgen)
+          mkdir versionlist
+          touch versionlist/""${version}-`echo ${{ matrix.base-image }} | sed -e ""s/:/-/g""`""
+          sh ./build-image-local.sh ${version} ${{ matrix.base-image }} ${{ matrix.java-version }} ${DOCKER_REPO}
+      - uses: actions/upload-artifact@v3
+        name: Upload distribution tar
+        with:
+          name: versionlist
+          path: rocketmq-docker/image-build-ci/versionlist/*
+
+  list-version:
+    if: always()
+    name: List version
+    needs: [ docker-build ]
+    runs-on: ubuntu-latest
+    timeout-minutes: 30
+    outputs:
+      version-json: ${{ steps.show_versions.outputs.version-json }}
+    steps:
+      - uses: actions/download-artifact@v3
+        name: Download versionlist
+        with:
+          name: versionlist
+          path: versionlist
+      - name: Show versions
+        id: show_versions
+        run: |
+          a=(`ls versionlist`)
+          printf '%s\n' ""${a[@]}"" | jq -R . | jq -s .
+          echo version-json=`printf '%s\n' ""${a[@]}"" | jq -R . | jq -s .` >> $GITHUB_OUTPUT
+
+  deploy-rocketmq:
+    if: ${{ success() }}
+    name: Deploy RocketMQ
+    needs: [ list-version,docker-build ]
+    runs-on: ubuntu-latest
+    timeout-minutes: 60
+    strategy:
+      matrix:
+        version: ${{ fromJSON(needs.list-version.outputs.version-json) }}
+    steps:
+      - uses: apache/rocketmq-test-tool@1a646589accad17070423eabf0f54925e52b0666
+        name: Deploy rocketmq
+        with:
+          action: ""deploy""
+          ask-config: ""${{ secrets.ASK_CONFIG_VIRGINA }}""
+          test-version: ""${{ matrix.version }}""
+          chart-git: ""https://ghproxy.com/https://github.com/apache/rocketmq-docker.git""","[{'comment': ""It's unnecessary to use a proxy in servers of Github actions."", 'commenter': 'caigy'}, {'comment': ""I don't see what you mean. Can you explain it in detail"", 'commenter': 'cryptoya'}, {'comment': ""> It's unnecessary to use a proxy in servers of Github actions.\r\n\r\nok, it has removed"", 'commenter': 'cryptoya'}]"
6778,common/src/main/java/org/apache/rocketmq/common/UtilAll.java,"@@ -765,4 +765,31 @@ private static void createDirIfNotExist(String dirName) {
             STORE_LOG.info(dirName + "" mkdir "" + (result ? ""OK"" : ""Failed""));
         }
     }
+
+    public static long calculateFileSizeInPath(File path) {
+        long size = 0;
+        try {
+            if (!path.exists()) {
+                return 0;
+            }
+            if (path.isFile()) {
+                return path.length();
+            }
+            if (path.isDirectory()) {
+                File[] files = path.listFiles();
+                if (files != null) {
+                    for (File file : files) {
+                        long fileSize = 0;
+                        fileSize = calculateFileSizeInPath(file);","[{'comment': ""You'd better check whether the file is a symbolic link before recursion."", 'commenter': 'caigy'}, {'comment': ""It's unnecessary to initialize `fileSize` as 0 as it's assigned right after initialization."", 'commenter': 'caigy'}]"
6778,controller/pom.xml,"@@ -58,5 +58,9 @@
             <groupId>${project.groupId}</groupId>
             <artifactId>rocketmq-srvutil</artifactId>
         </dependency>
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>jul-to-slf4j</artifactId>
+        </dependency>","[{'comment': 'Any reasons to add this dependency?', 'commenter': 'caigy'}, {'comment': '> Any reasons to add this dependency?\r\n\r\nWe need to use log as mertric exporter. \r\n<img width=""1302"" alt=""image"" src=""https://github.com/apache/rocketmq/assets/87409330/9c927052-40cb-4eed-824e-5133279279e7"">\r\n', 'commenter': 'TheR1sing3un'}]"
6778,controller/src/main/java/org/apache/rocketmq/controller/BrokerHeartbeatManager.java,"@@ -63,4 +64,10 @@ void onBrokerHeartbeat(final String clusterName, final String brokerName, final
      * Check whether broker active
      */
     boolean isBrokerActive(final String clusterName, final String brokerName, final Long brokerId);
+
+    /**
+     * Count the number of active brokers in each broker-set of each cluster
+     * @return active brokers count
+     */
+    Map<String/*cluster*/, Map<String/*broker-set*/, Long/*active broker num*/>> getActiveBrokersNum();","[{'comment': ""It's unnecessary to use type `Long` for the number of brokers, `Integer` is enough."", 'commenter': 'caigy'}]"
6778,controller/src/main/java/org/apache/rocketmq/controller/impl/heartbeat/DefaultBrokerHeartbeatManager.java,"@@ -173,4 +175,15 @@ public boolean isBrokerActive(String clusterName, String brokerName, Long broker
         return false;
     }
 
+    @Override
+    public Map<String, Map<String, Long>> getActiveBrokersNum() {
+        Map<String, Map<String, Long>> map = new HashMap<>();
+        this.brokerLiveTable.keySet().forEach(id -> {
+            map.computeIfAbsent(id.getClusterName(), k -> new HashMap<>());
+            map.get(id.getClusterName()).compute(id.getBrokerName(), (broker, num) ->
+                 num == null ? 0L : num + 1L
+            );
+        });
+        return map;
+    }","[{'comment': ""- Whether a broker is 'active' should be checked by `isBrokerActive()`, rather than just checking if it is in`brokerLiveTable`.\r\n-   IMO this method provides a dynamic view of `brokerLiveTable`. As the returned data structure is used only in metrics instead of heat beat of brokers, it seems inappropriate to add methods in the  interface `BrokerHeartbeatManager`. Placing it in metric-related packages may be more appropriate."", 'commenter': 'caigy'}]"
7120,store/src/main/java/org/apache/rocketmq/store/MessageStore.java,"@@ -693,14 +704,20 @@ void onCommitLogDispatch(DispatchRequest dispatchRequest, boolean doDispatch, Ma
      * Truncate dirty logic files
      *
      * @param phyOffset physical offset
+     * @throws RocksDBException only in rocksdb mode
      */
-    void truncateDirtyLogicFiles(long phyOffset);
+    void truncateDirtyLogicFiles(long phyOffset) throws RocksDBException;
 
     /**
      * Destroy logics files
      */
     void destroyLogics();
 
+    /**
+     * Load logics files
+     */
+    boolean loadLogics();","[{'comment': 'It would be better to move this method to consumeQueueStore', 'commenter': 'RongtongJin'}, {'comment': 'ok', 'commenter': 'fujian-zfj'}]"
7120,store/src/main/java/org/apache/rocketmq/store/MessageStore.java,"@@ -973,4 +992,21 @@ DispatchRequest checkMessageAndReturnSize(final ByteBuffer byteBuffer, final boo
      * @param attributesBuilderSupplier metrics attributes builder
      */
     void initMetrics(Meter meter, Supplier<AttributesBuilder> attributesBuilderSupplier);
+
+    /**
+     * Recover topic queue table
+     */
+    void recoverTopicQueueTable();
+
+    /**
+     * Get store time from commitlog by cqUnit
+     * @param cqUnit
+     * @return
+     */
+    long getStoreTime(CqUnit cqUnit);","[{'comment': 'It would be better to move this method to consumeQueueStore', 'commenter': 'RongtongJin'}]"
7120,store/src/main/java/org/apache/rocketmq/store/queue/RocksDBConsumeQueueTable.java,"@@ -0,0 +1,312 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.store.queue;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.rocketmq.common.Pair;
+import org.apache.rocketmq.common.constant.LoggerName;
+import org.apache.rocketmq.logging.org.slf4j.Logger;
+import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
+import org.apache.rocketmq.store.DefaultMessageStore;
+import org.apache.rocketmq.store.DispatchRequest;
+import org.apache.rocketmq.store.queue.RocksDBConsumeQueueOffsetTable.PhyAndCQOffset;
+import org.apache.rocketmq.store.rocksdb.ConsumeQueueRocksDBStorage;
+import org.rocksdb.ColumnFamilyHandle;
+import org.rocksdb.RocksDBException;
+import org.rocksdb.WriteBatch;
+
+import static org.apache.rocketmq.common.utils.DataConverter.CHARSET_UTF8;
+import static org.apache.rocketmq.store.queue.RocksDBConsumeQueueStore.CTRL_0;
+import static org.apache.rocketmq.store.queue.RocksDBConsumeQueueStore.CTRL_1;
+import static org.apache.rocketmq.store.queue.RocksDBConsumeQueueStore.CTRL_2;
+
+/**
+ * We use RocksDBConsumeQueueTable to store cqUnit.
+ */
+public class RocksDBConsumeQueueTable {
+    private static final Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);
+    private static final Logger ROCKSDB_LOG = LoggerFactory.getLogger(LoggerName.ROCKSDB_LOGGER_NAME);
+    private static final Logger ERROR_LOG = LoggerFactory.getLogger(LoggerName.STORE_ERROR_LOGGER_NAME);
+
+    /**
+     * Rocksdb ConsumeQueue's store unit. Format:
+     *
+     * <pre>
+     * ┌─────────────────────────┬───────────┬───────────────────────┬───────────┬───────────┬───────────┬───────────────────────┐
+     * │ Topic Bytes Array Size  │  CTRL_1   │   Topic Bytes Array   │  CTRL_1   │  QueueId  │  CTRL_1   │  ConsumeQueue Offset  │
+     * │        (4 Bytes)        │ (1 Bytes) │       (n Bytes)       │ (1 Bytes) │ (4 Bytes) │ (1 Bytes) │     (8 Bytes)         │
+     * ├─────────────────────────┴───────────┴───────────────────────┴───────────┴───────────┴───────────┴───────────────────────┤
+     * │                                                    Key Unit                                                             │
+     * │                                                                                                                         │
+     * </pre>
+     *
+     * <pre>
+     * ┌─────────────────────────────┬───────────────────┬──────────────────┬──────────────────┐
+     * │  CommitLog Physical Offset  │      Body Size    │   Tag HashCode   │  Msg Store Time  │
+     * │        (8 Bytes)            │      (4 Bytes)    │    (8 Bytes)     │    (8 Bytes)     │
+     * ├─────────────────────────────┴───────────────────┴──────────────────┴──────────────────┤
+     * │                                                    Value Unit                         │
+     * │                                                                                       │
+     * </pre>
+     * ConsumeQueue's store unit. Size:
+     * CommitLog Physical Offset(8) + Body Size(4) + Tag HashCode(8) + Msg Store Time(8) = 28 Bytes
+     */
+    private static final int PHY_OFFSET_OFFSET = 0;
+    private static final int PHY_MSG_LEN_OFFSET = 8;
+    private static final int MSG_TAG_HASHCODE_OFFSET = 12;
+    private static final int MSG_STORE_TIME_SIZE_OFFSET = 20;
+    public static final int CQ_UNIT_SIZE = 8 + 4 + 8 + 8;
+
+    /**
+     * ┌─────────────────────────┬───────────┬───────────┬───────────┬───────────┬───────────────────────┐
+     * │ Topic Bytes Array Size  │  CTRL_1   │  CTRL_1   │  QueueId  │  CTRL_1   │  ConsumeQueue Offset  │
+     * │        (4 Bytes)        │ (1 Bytes) │ (1 Bytes) │ (4 Bytes) │ (1 Bytes) │     (8 Bytes)         │
+     * ├─────────────────────────┴───────────┴───────────┴───────────┴───────────┴───────────────────────┤
+     */
+    private static final int CQ_KEY_LENGTH_WITHOUT_TOPIC_BYTES = 4 + 1 + 1 + 4 + 1 + 8;
+
+    /**
+     * ┌─────────────────────────┬───────────┬───────────┬───────────┬───────────────────┐
+     * │ Topic Bytes Array Size  │  CTRL_1   │  CTRL_1   │  QueueId  │  CTRL_0(CTRL_2)   │
+     * │        (4 Bytes)        │ (1 Bytes) │ (1 Bytes) │ (4 Bytes) │     (1 Bytes)     │
+     * ├─────────────────────────┴───────────┴───────────┴───────────┴───────────────────┤
+     */
+    private static final int DELETE_CQ_KEY_LENGTH_WITHOUT_TOPIC_BYTES = 4 + 1 + 1 + 4 + 1;
+
+    private final ConsumeQueueRocksDBStorage rocksDBStorage;
+    private final DefaultMessageStore messageStore;
+
+    private ColumnFamilyHandle defaultCFH;
+
+    public RocksDBConsumeQueueTable(ConsumeQueueRocksDBStorage rocksDBStorage, DefaultMessageStore messageStore) {
+        this.rocksDBStorage = rocksDBStorage;
+        this.messageStore = messageStore;
+    }
+
+    public void load() {
+        this.defaultCFH = this.rocksDBStorage.getDefaultCFHandle();
+    }
+
+    public void buildAndPutCQByteBuffer(final Pair<ByteBuffer, ByteBuffer> cqBBPair,
+        final byte[] topicBytes, final DispatchRequest request, final WriteBatch writeBatch) throws RocksDBException {
+        final ByteBuffer cqKey = cqBBPair.getObject1();
+        buildCQKeyBB(cqKey, topicBytes, request.getQueueId(), request.getConsumeQueueOffset());
+
+        final ByteBuffer cqValue = cqBBPair.getObject2();
+        buildCQValueBB(cqValue, request.getCommitLogOffset(), request.getMsgSize(), request.getTagsCode(), request.getStoreTimestamp());
+
+        writeBatch.put(defaultCFH, cqKey, cqValue);
+    }
+
+    public ByteBuffer getCQInKV(final String topic, final int queueId, final long cqOffset) throws RocksDBException {
+        final byte[] topicBytes = topic.getBytes(CHARSET_UTF8);
+        final ByteBuffer keyBB = buildCQKeyBB(topicBytes, queueId, cqOffset);
+        byte[] value = this.rocksDBStorage.getCQ(keyBB.array());
+        return (value != null) ? ByteBuffer.wrap(value) : null;
+    }
+
+    public List<ByteBuffer> rangeQuery(final String topic, final int queueId, final long startIndex, final int num) throws RocksDBException {
+        final byte[] topicBytes = topic.getBytes(CHARSET_UTF8);
+        final List<ColumnFamilyHandle> defaultCFHList = new ArrayList(num);
+        final ByteBuffer[] resultList = new ByteBuffer[num];
+        final List<Integer> kvIndexList = new ArrayList(num);
+        final List<byte[]> kvKeyList = new ArrayList(num);
+        for (int i = 0; i < num; i++) {
+            final ByteBuffer keyBB = buildCQKeyBB(topicBytes, queueId, startIndex + i);
+            kvIndexList.add(i);
+            kvKeyList.add(keyBB.array());
+            defaultCFHList.add(defaultCFH);
+        }
+        int keyNum = kvIndexList.size();
+        if (keyNum > 0) {
+            List<byte[]> kvValueList = this.rocksDBStorage.multiGet(defaultCFHList, kvKeyList);
+            final int valueNum = kvValueList.size();
+            if (keyNum != valueNum) {
+                throw new RocksDBException(""rocksdb bug, multiGet"");
+            }
+            for (int i = 0; i < valueNum; i++) {
+                byte[] value = kvValueList.get(i);
+                if (value == null) {
+                    continue;
+                }
+                ByteBuffer byteBuffer = ByteBuffer.wrap(value);
+                resultList[kvIndexList.get(i)] = byteBuffer;
+            }
+        }
+
+        final int resultSize = resultList.length;
+        List<ByteBuffer> bbValueList = new ArrayList(resultSize);
+        for (int i = 0; i < resultSize; i++) {
+            ByteBuffer byteBuffer = resultList[i];
+            if (byteBuffer == null) {
+                break;
+            }
+            bbValueList.add(byteBuffer);
+        }
+        return bbValueList;
+    }
+
+    /**
+     * When topic is deleted, we clean up its CqUnit in rocksdb.
+     * @param topic
+     * @param queueId
+     * @throws RocksDBException
+     */
+    public void destroyCQ(final String topic, final int queueId, WriteBatch writeBatch) throws RocksDBException {
+        final byte[] topicBytes = topic.getBytes(CHARSET_UTF8);
+        final ByteBuffer cqStartKey = buildDeleteCQKey(true, topicBytes, queueId);
+        final ByteBuffer cqEndKey = buildDeleteCQKey(false, topicBytes, queueId);
+
+        writeBatch.deleteRange(defaultCFH, cqStartKey.array(), cqEndKey.array());
+
+        log.info(""Rocksdb consumeQueue table delete topic. {}, {}"", topic, queueId);
+    }
+
+    public long binarySearchInCQByTime(String topic, int queueId, long high, long low, long timestamp,
+        long minPhysicOffset) throws RocksDBException {
+        long result = 0;
+        long targetOffset = -1L, leftOffset = -1L, rightOffset = -1L;
+        long leftValue = -1L, rightValue = -1L;
+        while (high >= low) {
+            long midOffset = low + ((high - low) >>> 1);
+            ByteBuffer byteBuffer = getCQInKV(topic, queueId, midOffset);
+            if (byteBuffer == null) {
+                ERROR_LOG.warn(""binarySearchInCQByTimeStamp Failed. topic: {}, queueId: {}, timestamp: {}, result: null"",
+                    topic, queueId, timestamp);
+                low = midOffset + 1;
+                continue;
+            }
+
+            long phyOffset = byteBuffer.getLong(PHY_OFFSET_OFFSET);
+            if (phyOffset < minPhysicOffset) {
+                low = midOffset + 1;
+                leftOffset = midOffset;
+                continue;
+            }
+            long storeTime = byteBuffer.getLong(MSG_STORE_TIME_SIZE_OFFSET);
+            if (storeTime < 0) {
+                return 0;
+            } else if (storeTime == timestamp) {
+                targetOffset = midOffset;
+                break;
+            } else if (storeTime > timestamp) {
+                high = midOffset - 1;
+                rightOffset = midOffset;
+                rightValue = storeTime;
+            } else {
+                low = midOffset + 1;
+                leftOffset = midOffset;
+                leftValue = storeTime;
+            }
+        }
+        if (targetOffset != -1) {
+            result = targetOffset;
+        } else {
+            if (leftValue == -1) {
+                result = rightOffset;
+            } else if (rightValue == -1) {
+                result = leftOffset;
+            } else {
+                result = Math.abs(timestamp - leftValue) > Math.abs(timestamp - rightValue) ? rightOffset : leftOffset;
+            }
+        }
+        return result;
+    }
+
+    public PhyAndCQOffset binarySearchInCQ(String topic, int queueId, long high, long low, long targetPhyOffset,
+        boolean min) throws RocksDBException {
+        long resultCQOffset = -1L;
+        long resultPhyOffset = -1L;
+        while (high >= low) {
+            long midCQOffset = low + ((high - low) >>> 1);
+            ByteBuffer byteBuffer = getCQInKV(topic, queueId, midCQOffset);
+            if (this.messageStore.getMessageStoreConfig().isEnableRocksDBLog()) {
+                ROCKSDB_LOG.warn(""binarySearchInCQ. {}, {}, {}, {}, {}"", topic, queueId, midCQOffset, low, high);
+            }
+            if (byteBuffer == null) {
+                low = midCQOffset + 1;
+                continue;
+            }
+
+            final long phyOffset = byteBuffer.getLong(PHY_OFFSET_OFFSET);
+            if (phyOffset == targetPhyOffset) {
+                if (min) {
+                    resultCQOffset =  midCQOffset;
+                    resultPhyOffset = phyOffset;
+                }
+                break;
+            } else if (phyOffset > targetPhyOffset) {
+                high = midCQOffset - 1;
+                if (min) {
+                    resultCQOffset = midCQOffset;
+                    resultPhyOffset = phyOffset;
+                }
+            } else {
+                low = midCQOffset + 1;
+                if (!min) {
+                    resultCQOffset = midCQOffset;
+                    resultPhyOffset = phyOffset;
+                }
+            }
+        }
+        return new PhyAndCQOffset(resultPhyOffset, resultCQOffset);
+    }
+
+    public static Pair<ByteBuffer, ByteBuffer> getCQByteBufferPair() {
+        ByteBuffer cqKey = ByteBuffer.allocateDirect(RocksDBConsumeQueueStore.MAX_KEY_LEN);
+        ByteBuffer cqValue = ByteBuffer.allocateDirect(CQ_UNIT_SIZE);
+        return new Pair<>(cqKey, cqValue);
+    }
+
+    private ByteBuffer buildCQKeyBB(final byte[] topicBytes, final int queueId, final long cqOffset) {
+        final ByteBuffer bb = ByteBuffer.allocate(CQ_KEY_LENGTH_WITHOUT_TOPIC_BYTES + topicBytes.length);
+        buildCQKeyBB0(bb, topicBytes, queueId, cqOffset);
+        return bb;
+    }
+
+    private void buildCQKeyBB(final ByteBuffer bb, final byte[] topicBytes, final int queueId, final long cqOffset) {
+        bb.position(0).limit(CQ_KEY_LENGTH_WITHOUT_TOPIC_BYTES + topicBytes.length);
+        buildCQKeyBB0(bb, topicBytes, queueId, cqOffset);
+    }
+
+    private void buildCQKeyBB0(final ByteBuffer bb, final byte[] topicBytes, final int queueId, final long cqOffset) {
+        bb.putInt(topicBytes.length).put(CTRL_1).put(topicBytes).put(CTRL_1).putInt(queueId).put(CTRL_1).putLong(cqOffset);
+        bb.flip();
+    }
+
+    private void buildCQValueBB(final ByteBuffer bb, final long phyOffset, final int msgSize, final long tagsCode, final long storeTimestamp) {
+        bb.position(0).limit(CQ_UNIT_SIZE);
+        buildCQValueBB0(bb, phyOffset, msgSize, tagsCode, storeTimestamp);
+    }
+
+    private void buildCQValueBB0(final ByteBuffer bb, final long phyOffset, final int msgSize,","[{'comment': 'Suggest changing all \'BB\' to ""ByteBuffer""', 'commenter': 'RongtongJin'}, {'comment': 'ok', 'commenter': 'fujian-zfj'}]"
7120,tieredstore/src/main/java/org/apache/rocketmq/tieredstore/TieredMessageStore.java,"@@ -392,7 +396,7 @@ public void destroy() {
     }
 
     @Override
-    public int cleanUnusedTopic(Set<String> retainTopics) {
+    public int cleanUnusedTopic(Set<String> retainTopics) throws RocksDBException {","[{'comment': '这里不建议改接口，元数据的存储可以有多种实现，比如默认的 json 就不会有 rocksdb exception', 'commenter': 'lizhimins'}, {'comment': 'OK', 'commenter': 'fujian-zfj'}]"
7200,proxy/src/main/java/org/apache/rocketmq/proxy/service/message/LocalRemotingCommand.java,"@@ -37,4 +40,5 @@ public CommandCustomHeader decodeCommandCustomHeader(
         Class<? extends CommandCustomHeader> classHeader) throws RemotingCommandException {
         return classHeader.cast(readCustomHeader());
     }
+    ","[{'comment': 'redundant line', 'commenter': 'joeCarf'}]"
7200,remoting/src/main/java/org/apache/rocketmq/remoting/protocol/LanguageCode.java,"@@ -50,4 +55,10 @@ public static LanguageCode valueOf(byte code) {
     public byte getCode() {
         return code;
     }
+    
+    ","[{'comment': 'redundant line', 'commenter': 'joeCarf'}, {'comment': 'BTW, I think the pr title can be named like [ISSUE #xxx] Fix: xxxx', 'commenter': 'joeCarf'}]"
7200,proxy/src/main/java/org/apache/rocketmq/proxy/service/message/LocalRemotingCommand.java,"@@ -17,15 +17,18 @@
 package org.apache.rocketmq.proxy.service.message;
 
 import java.util.HashMap;
+import org.apache.rocketmq.proxy.common.ProxyContext;
 import org.apache.rocketmq.remoting.CommandCustomHeader;
 import org.apache.rocketmq.remoting.exception.RemotingCommandException;
+import org.apache.rocketmq.remoting.protocol.LanguageCode;
 import org.apache.rocketmq.remoting.protocol.RemotingCommand;
 
 public class LocalRemotingCommand extends RemotingCommand {
 
-    public static LocalRemotingCommand createRequestCommand(int code, CommandCustomHeader customHeader) {
+    public static LocalRemotingCommand createRequestCommand(int code, CommandCustomHeader customHeader, ProxyContext ctx) {","[{'comment': ""It's better to pass language rather than proxyContext into the constructor of LocalRemotingCommand."", 'commenter': 'drpmma'}]"
