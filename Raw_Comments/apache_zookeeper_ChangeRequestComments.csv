Pull,Path,Diff_hunk,Comment
99,src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,"@@ -716,7 +716,12 @@ public void process(WatchedEvent event) {
         // Convert WatchedEvent to a type that can be sent over the wire
         WatcherEvent e = event.getWrapper();
 
-        sendResponse(h, e, ""notification"");
+        try {
+            sendResponse(h, e, ""notification"");
+        } catch (IOException ex) {
+            LOG.debug(""Problem sending to "" + getRemoteSocketAddress(), ex);
+            close();","[{'comment': 'this is an interesting change -- how/when were we closing the connection before?\n', 'commenter': 'rgs1'}, {'comment': 'It was not closing (I think) before as exception was swallowed since sendResponse in NIOServerCnxn was not throwing IOException\n', 'commenter': 'yufeldman'}, {'comment': 'hmm, that would be a pretty bad leak given all what goes on in close():\n\n```\n    @Override                                                                                                                                                                     \n    public void close() {                                                                                                                                                         \n        if (!factory.removeCnxn(this)) {                                                                                                                                          \n            return;                                                                                                                                                               \n        }                                                                                                                                                                         \n\n        if (zkServer != null) {                                                                                                                                                   \n            zkServer.removeCnxn(this);                                                                                                                                            \n        }                                                                                                                                                                         \n\n        if (sk != null) {                                                                                                                                                         \n            try {                                                                                                                                                                 \n                // need to cancel this selection key from the selector                                                                                                            \n                sk.cancel();                                                                                                                                                      \n            } catch (Exception e) {                                                                                                                                               \n                if (LOG.isDebugEnabled()) {                                                                                                                                       \n                    LOG.debug(""ignoring exception during selectionkey cancel"", e);                                                                                                \n                }                                                                                                                                                                 \n            }                                                                                                                                                                     \n        }                                                                                                                                                                         \n\n        closeSock();                                                                                                                                                              \n    } \n```\n\nshould we add a test case for making sure close is called then? although i think it\'s handled somewhere else, let me re-read the code. \n', 'commenter': 'rgs1'}, {'comment': 'I agree that it must be closing somewhere - just need to trace where\n', 'commenter': 'yufeldman'}, {'comment': "">> It was not closing (I think) before as exception was swallowed since sendResponse in NIOServerCnxn was not throwing IOException\r\n\r\nYes, I think the connection was not closing before in cases of exception thrown from `NIOServerCnxn.sendResponse` which swallows everything. The change in this PR changes the behavior by closing the connection in case of exceptions occur in sendResponse. I am leaning towards the old behavior of NOT closing the connection, because the connection looks pretty innocent - in fact `NIOServerCnxn.sendResponse` does not involve any socket IO I believe, it just queuing stuff to be send over sockets. So if something goes wrong, we just do our best effort by logging what's wrong - rather than trying mess up with sockets which seems out of responsibilities of `NIOServerCnxn.sendResponse`. Similarly since `NIOServerCnxn.sendResponse` does not directly involve sockets, there should not be any leaks in case sendResponse screw up."", 'commenter': 'hanm'}, {'comment': 'Will remove close() from catch block', 'commenter': 'yufeldman'}]"
99,src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,"@@ -716,7 +716,12 @@ public void process(WatchedEvent event) {
         // Convert WatchedEvent to a type that can be sent over the wire
         WatcherEvent e = event.getWrapper();
 
-        sendResponse(h, e, ""notification"");
+        try {
+            sendResponse(h, e, ""notification"");
+        } catch (IOException ex) {
+            LOG.debug(""Problem sending to "" + getRemoteSocketAddress(), ex);","[{'comment': 'i have mixed feelings with concatenating strings in a hot path (IOException happening here is a hot path when, for instance, a network blip happens). \n', 'commenter': 'rgs1'}, {'comment': 'Any suggestion here? Not to getRemoteSocketAddress() at all?\n', 'commenter': 'yufeldman'}, {'comment': ""We're using LOG.debug, so it shouldn't be an issue on prod."", 'commenter': 'lvfangmin'}, {'comment': 'nit: I would use a modern debug format:\r\n\r\n``\r\nLOG.debug(""Problem sending to {}"", getRemoteSocketAddress(), ex);\r\n``', 'commenter': 'eribeiro'}]"
99,src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -630,6 +640,22 @@ public static ByteBuffer getDirectBuffer() {
      * limits of the operating system). startup(zks) must be called subsequently.
      */
     public NIOServerCnxnFactory() {
+        String serverCnxnClassName = System.getProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN);
+        if ( serverCnxnClassName != null ) {","[{'comment': 'nit: extra spaces\n', 'commenter': 'rgs1'}]"
99,src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -842,7 +868,26 @@ private void addCnxn(NIOServerCnxn cnxn) {
 
     protected NIOServerCnxn createConnection(SocketChannel sock,
             SelectionKey sk, SelectorThread selectorThread) throws IOException {
-        return new NIOServerCnxn(zkServer, sock, sk, this, selectorThread);
+
+        NIOServerCnxn cnxn = null;
+
+        if (serverCnxnClassCtr != null) {","[{'comment': 'why not set serverCnxnClassCtr to NIOServerCnxn by default to avoid looking up the right constructor every time we want to create a new connection (a bit of a hot path)?\n', 'commenter': 'rgs1'}, {'comment': 'Actually I tend to come back to double instantiation - as it will be used only in UnitTests (serverCnxnClassCtr != null), while manipulation with constructor (invocation of newInstance) instead of directly creating instance of NIOServerCnxn will be really a hot path \n', 'commenter': 'yufeldman'}, {'comment': ""what's wrong with setting serverCnxnClassCtr to NettyServerCnxn by default (by doing all the reflection magic)?\n"", 'commenter': 'rgs1'}, {'comment': 'nothing is wrong with it per say - just overhead, as we will call ""newInstance"" on the constructor for every code path - test or not.\n', 'commenter': 'yufeldman'}]"
99,src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -105,8 +115,26 @@ public void channelConnected(ChannelHandlerContext ctx,
                 LOG.trace(""Channel connected "" + e);
             }
 
-            NettyServerCnxn cnxn = new NettyServerCnxn(ctx.getChannel(),
-                    zkServer, NettyServerCnxnFactory.this);
+            NettyServerCnxn cnxn = null;
+            if (serverCnxnClassCtr != null) {","[{'comment': 'same as for NIO, lets set serverCnxnClassCtr to NettyServerCnxn by default\n', 'commenter': 'rgs1'}]"
99,src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -165,31 +163,35 @@ public void process(WatchedEvent event) {
     @Override
     public void sendResponse(ReplyHeader h, Record r, String tag)
             throws IOException {
-        if (!channel.isOpen()) {
-            return;
-        }
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        // Make space for length
-        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);
         try {
-            baos.write(fourBytes);
-            bos.writeRecord(h, ""header"");
-            if (r != null) {
-                bos.writeRecord(r, tag);
+            if (!channel.isOpen()) {
+                return;
             }
-            baos.close();
-        } catch (IOException e) {
-            LOG.error(""Error serializing response"");
-        }
-        byte b[] = baos.toByteArray();
-        ByteBuffer bb = ByteBuffer.wrap(b);
-        bb.putInt(b.length - 4).rewind();
-        sendBuffer(bb);
-        if (h.getXid() > 0) {
-            // zks cannot be null otherwise we would not have gotten here!
-            if (!zkServer.shouldThrottle(outstandingCount.decrementAndGet())) {
-                enableRecv();
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            // Make space for length
+            BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);
+            try {
+                baos.write(fourBytes);
+                bos.writeRecord(h, ""header"");
+                if (r != null) {
+                    bos.writeRecord(r, tag);
+                }
+                baos.close();
+            } catch (IOException e) {","[{'comment': 'This IOException is swallowed either, should we re-throw it?', 'commenter': 'lvfangmin'}, {'comment': 'I did not modify this code - it was like that before, but potentially - yes it makes sense to rethrow\r\nI would say there are multiple places I came across where exceptions are swallowed ', 'commenter': 'yufeldman'}, {'comment': 'Agree on re-throw the exception here. We could just remove the try - catch block here given there is a new try - catch block added in this PR that wraps the entire `sendResponse.` \r\nWe can start triaging other places where the exceptions are swallowed but should re-throw after this PR merging in.', 'commenter': 'hanm'}]"
99,src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -71,7 +71,7 @@
     NettyServerCnxnFactory factory;
     boolean initialized;
     
-    NettyServerCnxn(Channel channel, ZooKeeperServer zks, NettyServerCnxnFactory factory) {
+    public NettyServerCnxn(Channel channel, ZooKeeperServer zks, NettyServerCnxnFactory factory) {","[{'comment': 'It is not obvious to me why the access specifier of `NettyServerCnxn` should be changed public here.', 'commenter': 'hanm'}, {'comment': 'I think I did this to match NIOServerCnxn constructor. It can be kept package level, as my test class is in the same package namespace. I can change it back, but it will be inconsistent with NIO\r\n', 'commenter': 'yufeldman'}, {'comment': 'Take my words back. I need it to be public as I use reflection to create it in NettyServerCnxnFactory and if it is not I would have to do couple of more steps during init to set access to public which is unnecessary', 'commenter': 'yufeldman'}, {'comment': ""@yufeldman Thanks for explaining, makes sense to me. It is required to run the tests, however I do find another problem with tests: it looks like the Netty tests (testNetty*) never run with current configuration. Proof: remove the public access specifier appertain to `NettyServerCnxn` and all tests of `ServerCxnExceptionsTest` still pass. We expect Netty related tests fail here without public access specifier, right? Now put back the public for `NettyServerCnxn` but remove the public access specifier appertains to `NIOServercCnxn`, now all tests failed while we expect only NIO tests fail but Netty tests pass. \r\n\r\nIt's likely caused by the intervening of the java system properties that controls the Netty vs NIO server selection. One solution is to split the `ServerCxnExceptionsTest` into Netty and NIO specific tests. "", 'commenter': 'hanm'}, {'comment': '@hanm - there is nothing wrong with the tests, they do run fine. They do not use ctor from NettyServerCnxn, but from MockNettyServerCnxn - that has public ctor.\r\nYou can make MockNettyServerCnxn not public and you will have the same issue. And BTW \r\norg.apache.zookeeper.server.NettyServerCnxnTest fails with not public ctor in NettyServerCnxn ', 'commenter': 'yufeldman'}, {'comment': ""@yufeldman Yeah the tests are fine. What I mentioned that leads to `NettyServerCnxnx` not get instantiated only happens in erroneous cases when `ZOOKEEPER_SERVER_CNXN_FACTORY` is not initialized properly - this happens when the public specifier was removed so all tests fall back to create `NIOServerCnxnx` instead. That's not a real alarm."", 'commenter': 'hanm'}, {'comment': ""@hanm - >>> so all tests fall back to create NIOServerCnxnx instead\r\n\r\nIt is not the case, they don't fall back to NIO - they fail.\r\nHere is printout from running tests with both Netty and MockNettyServerCnxn not having public ctor:\r\n   [junit] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.159 sec\r\n  **[junit] Test org.apache.zookeeper.server.NettyServerCnxnTest FAILED**\r\n    [junit] Running org.apache.zookeeper.server.PrepRequestProcessorTest\r\n    [junit] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.279 sec\r\n    [junit] Running org.apache.zookeeper.server.PurgeTxnTest\r\n    [junit] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.431 sec\r\n    [junit] Running org.apache.zookeeper.server.ReferenceCountedACLCacheTest\r\n    [junit] Tests run: 10, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.089 sec\r\n    [junit] Running org.apache.zookeeper.server.SerializationPerfTest\r\n    [junit] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.114 sec\r\n    [junit] Running org.apache.zookeeper.server.ServerCxnExceptionsTest\r\n    [junit] Tests run: 6, Failures: 0, Errors: 6, Skipped: 0, Time elapsed: 0.284 sec\r\n**[junit] Test org.apache.zookeeper.server.ServerCxnExceptionsTest FAILED**\r\n\r\n"", 'commenter': 'yufeldman'}, {'comment': "">> It is not the case, they don't fall back to NIO - they fail.\r\n\r\nThe fallback I was referring to is https://github.com/apache/zookeeper/blob/master/src/java/main/org/apache/zookeeper/server/ServerCnxnFactory.java#L130. It gets hit when public was removed from NIOServerCnxn for Netty* tests. An example call stack (note that a Netty test complaining about NIOServerCnxnFactory):\r\n` INFO  [main:ZKTestCase$1@70] - FAILED testNettyRunTimeException\r\njava.io.IOException: Couldn't instantiate org.apache.zookeeper.server.NIOServerCnxnFactory\r\n>-------at org.apache.zookeeper.server.ServerCnxnFactory.createFactory(ServerCnxnFactory.java:142)\r\n>-------at org.apache.zookeeper.server.ServerCnxnFactory.createFactory(ServerCnxnFactory.java:158)\r\n>-------at org.apache.zookeeper.server.ServerCnxnFactory.createFactory(ServerCnxnFactory.java:152)`\r\n\r\nThanks for persisting on this, but I don't think this erroneous case need to be investigated further as it would not happen when real test cases were running."", 'commenter': 'hanm'}, {'comment': ""Interesting. For me it actually is:\r\n\r\n2016-12-05 11:11:02,523 [myid:] - INFO  [Time-limited test:JUnit4ZKTestRunner$LoggedInvokeMethod@98] - TEST METHOD FAILED testNettyRunTimeException\r\n**java.io.IOException: Couldn't instantiate org.apache.zookeeper.server.NettyServerCnxnFactory at org.apache.zookeeper.server.ServerCnxnFactory.createFactory(ServerCnxnFactory.java:141) at org.apache.zookeeper.server.ServerCnxnFactory.createFactory(ServerCnxnFactory.java:157)\r\nat org.apache.zookeeper.server.ServerCnxnFactory.createFactory(ServerCnxnFactory.java:151)**\r\n"", 'commenter': 'yufeldman'}, {'comment': '@hanm - thank you for all the reviews and feedback. Really appreciate it.', 'commenter': 'yufeldman'}]"
99,src/java/test/org/apache/zookeeper/server/ServerCxnExceptionsTest.java,"@@ -0,0 +1,170 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server;
+
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.AfterClass;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static org.junit.Assert.fail;
+
+/**
+ * Unit tests to test different exceptions scenarious in sendResponse","[{'comment': 'typo: ``scenarios``', 'commenter': 'eribeiro'}]"
102,src/java/main/org/apache/jute/compiler/CGenerator.java,"@@ -61,70 +61,88 @@ void genCode() throws IOException {
                         + outputDirectory);
             }
         }
-        FileWriter c = new FileWriter(new File(outputDirectory, mName+"".c""));
-        FileWriter h = new FileWriter(new File(outputDirectory, mName+"".h""));
 
-        h.write(""/**\n"");
-        h.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");
-        h.write(""* or more contributor license agreements.  See the NOTICE file\n"");
-        h.write(""* distributed with this work for additional information\n"");
-        h.write(""* regarding copyright ownership.  The ASF licenses this file\n"");
-        h.write(""* to you under the Apache License, Version 2.0 (the\n"");
-        h.write(""* \""License\""); you may not use this file except in compliance\n"");
-        h.write(""* with the License.  You may obtain a copy of the License at\n"");
-        h.write(""*\n"");
-        h.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");
-        h.write(""*\n"");
-        h.write(""* Unless required by applicable law or agreed to in writing, software\n"");
-        h.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");
-        h.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");
-        h.write(""* See the License for the specific language governing permissions and\n"");
-        h.write(""* limitations under the License.\n"");
-        h.write(""*/\n"");
-        h.write(""\n"");
+        FileWriter c = null, h = null;
+        try {
+            c = new FileWriter(new File(outputDirectory, mName + "".c""));
+            h = new FileWriter(new File(outputDirectory, mName + "".h""));
 
-        c.write(""/**\n"");
-        c.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");
-        c.write(""* or more contributor license agreements.  See the NOTICE file\n"");
-        c.write(""* distributed with this work for additional information\n"");
-        c.write(""* regarding copyright ownership.  The ASF licenses this file\n"");
-        c.write(""* to you under the Apache License, Version 2.0 (the\n"");
-        c.write(""* \""License\""); you may not use this file except in compliance\n"");
-        c.write(""* with the License.  You may obtain a copy of the License at\n"");
-        c.write(""*\n"");
-        c.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");
-        c.write(""*\n"");
-        c.write(""* Unless required by applicable law or agreed to in writing, software\n"");
-        c.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");
-        c.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");
-        c.write(""* See the License for the specific language governing permissions and\n"");
-        c.write(""* limitations under the License.\n"");
-        c.write(""*/\n"");
-        c.write(""\n"");
+            h.write(""/**\n"");
+            h.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");
+            h.write(""* or more contributor license agreements.  See the NOTICE file\n"");
+            h.write(""* distributed with this work for additional information\n"");
+            h.write(""* regarding copyright ownership.  The ASF licenses this file\n"");
+            h.write(""* to you under the Apache License, Version 2.0 (the\n"");
+            h.write(""* \""License\""); you may not use this file except in compliance\n"");
+            h.write(""* with the License.  You may obtain a copy of the License at\n"");
+            h.write(""*\n"");
+            h.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");
+            h.write(""*\n"");
+            h.write(""* Unless required by applicable law or agreed to in writing, software\n"");
+            h.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");
+            h.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");
+            h.write(""* See the License for the specific language governing permissions and\n"");
+            h.write(""* limitations under the License.\n"");
+            h.write(""*/\n"");
+            h.write(""\n"");
 
-        h.write(""#ifndef __""+mName.toUpperCase().replace('.','_')+""__\n"");
-        h.write(""#define __""+mName.toUpperCase().replace('.','_')+""__\n"");
+            c.write(""/**\n"");
+            c.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");
+            c.write(""* or more contributor license agreements.  See the NOTICE file\n"");
+            c.write(""* distributed with this work for additional information\n"");
+            c.write(""* regarding copyright ownership.  The ASF licenses this file\n"");
+            c.write(""* to you under the Apache License, Version 2.0 (the\n"");
+            c.write(""* \""License\""); you may not use this file except in compliance\n"");
+            c.write(""* with the License.  You may obtain a copy of the License at\n"");
+            c.write(""*\n"");
+            c.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");
+            c.write(""*\n"");
+            c.write(""* Unless required by applicable law or agreed to in writing, software\n"");
+            c.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");
+            c.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");
+            c.write(""* See the License for the specific language governing permissions and\n"");
+            c.write(""* limitations under the License.\n"");
+            c.write(""*/\n"");
+            c.write(""\n"");
 
-        h.write(""#include \""recordio.h\""\n"");
-        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext();) {
-            JFile f = i.next();
-            h.write(""#include \""""+f.getName()+"".h\""\n"");
-        }
-        // required for compilation from C++
-        h.write(""\n#ifdef __cplusplus\nextern \""C\"" {\n#endif\n\n"");
+            h.write(""#ifndef __"" + mName.toUpperCase().replace('.', '_') + ""__\n"");
+            h.write(""#define __"" + mName.toUpperCase().replace('.', '_') + ""__\n"");
 
-        c.write(""#include <stdlib.h>\n""); // need it for calloc() & free()
-        c.write(""#include \""""+mName+"".h\""\n\n"");
+            h.write(""#include \""recordio.h\""\n"");
+            for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext(); ) {
+                JFile f = i.next();
+                h.write(""#include \"""" + f.getName() + "".h\""\n"");
+            }
+            // required for compilation from C++
+            h.write(""\n#ifdef __cplusplus\nextern \""C\"" {\n#endif\n\n"");
 
-        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext();) {
-            JRecord jr = i.next();
-            jr.genCCode(h, c);
-        }
+            c.write(""#include <stdlib.h>\n""); // need it for calloc() & free()
+            c.write(""#include \"""" + mName + "".h\""\n\n"");
 
-        h.write(""\n#ifdef __cplusplus\n}\n#endif\n\n"");
-        h.write(""#endif //""+mName.toUpperCase().replace('.','_')+""__\n"");
+            for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {
+                JRecord jr = i.next();
+                jr.genCCode(h, c);
+            }
 
-        h.close();
-        c.close();
+            h.write(""\n#ifdef __cplusplus\n}\n#endif\n\n"");
+            h.write(""#endif //"" + mName.toUpperCase().replace('.', '_') + ""__\n"");
+        } catch (IOException e) {
+            throw e;
+        } finally {
+            if (h != null) {
+                try {
+                    h.close();
+                } catch (IOException ex) {
+                    throw ex;
+                } finally {
+                    if (c != null) {
+                        c.close();
+                    }
+                }
+            }
+            if (c != null) {","[{'comment': ""It's sad that we have to close c twice (one here, one in the finally block earlier.). Findbugs is not happy if either of them is missing. It could be that the flow sensitive engine of findbug need an improvement.\n"", 'commenter': 'hanm'}, {'comment': 'i think try with resources would clean this up. we are on java7 now right?\n', 'commenter': 'breed'}, {'comment': ""Yeah I thought about using try / with  - for some reasons I had the impression that we also need to support JDK 1.6 (that's probably only for 3.4.x). I'll update with try / with.\n"", 'commenter': 'hanm'}]"
102,src/java/main/org/apache/zookeeper/cli/DeleteCommand.java,"@@ -59,11 +59,6 @@ private void retainCompatibility(String[] cmdArgs) throws CliParseException {
         // delete path [version]
         if (args.length > 2) {
             // rewrite to option","[{'comment': 'you can remove the comment too :)\n', 'commenter': 'breed'}]"
102,src/java/main/org/apache/zookeeper/version/util/VerGen.java,"@@ -93,6 +93,14 @@ public static void generateFile(File outputDir, Version version, int rev, String
         } catch (IOException e) {
             System.out.println(""Unable to generate version.Info file: ""
                     + e.getMessage());
+            if (w != null) {","[{'comment': 'wow this is a weird one... we have it in the finally... try with resources would make this a bit nicer too...\n', 'commenter': 'breed'}, {'comment': 'Findbug complains here because we use System.exit in catch block - in that case it is not guaranteed that the finally block will be executed.\n', 'commenter': 'hanm'}]"
102,src/java/main/org/apache/zookeeper/version/util/VerGen.java,"@@ -50,10 +50,8 @@ public static void generateFile(File outputDir, Version version, int rev, String
             System.out.println(path + "" is not a directory."");
             System.exit(1);
         }
-        File file = new File(pkgdir, TYPE_NAME + "".java"");
-        FileWriter w = null;
-        try {
-            w = new FileWriter(file);
+
+        try (FileWriter w = new FileWriter(new File(pkgdir, TYPE_NAME + "".java""));) {","[{'comment': 'nit: spurious "";""\n', 'commenter': 'eribeiro'}]"
102,src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java,"@@ -344,9 +345,10 @@ public boolean containsQuorum(Set<Long> set){
          * Check if all groups have majority
          */
         int majGroupCounter = 0;
-        for(long gid : expansion.keySet()) {
-            LOG.debug(""Group info: "" + expansion.get(gid) + "", "" + gid + "", "" + groupWeight.get(gid));
-            if(expansion.get(gid) > (groupWeight.get(gid) / 2) )
+        for (Entry<Long, Long> entry : expansion.entrySet()) {
+            Long gid = entry.getKey();
+            LOG.debug(""Group info: "" + entry.getValue() + "", "" + gid + "", "" + groupWeight.get(gid));","[{'comment': 'We could use modern LOG printing here: \n\n`\nLOG.debug(""Group info: {}, {}, {}"", entry.getValue(), gid, groupWeight.get(gid));\n`\n', 'commenter': 'eribeiro'}]"
102,src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java,"@@ -344,9 +345,10 @@ public boolean containsQuorum(Set<Long> set){
          * Check if all groups have majority
          */
         int majGroupCounter = 0;
-        for(long gid : expansion.keySet()) {
-            LOG.debug(""Group info: "" + expansion.get(gid) + "", "" + gid + "", "" + groupWeight.get(gid));
-            if(expansion.get(gid) > (groupWeight.get(gid) / 2) )
+        for (Entry<Long, Long> entry : expansion.entrySet()) {
+            Long gid = entry.getKey();
+            LOG.debug(""Group info: "" + entry.getValue() + "", "" + gid + "", "" + groupWeight.get(gid));
+            if(entry.getValue() > (groupWeight.get(gid) / 2) )","[{'comment': 'nit: add space after the `if` and remove space before the last parenthesis.\n', 'commenter': 'eribeiro'}]"
102,src/java/main/org/apache/zookeeper/server/DataTree.java,"@@ -1293,13 +1293,12 @@ public synchronized WatchesSummary getWatchesSummary() {
      * @param pwriter the output to write to
      */
     public void dumpEphemerals(PrintWriter pwriter) {
-        Set<Long> keys = ephemerals.keySet();
         pwriter.println(""Sessions with Ephemerals (""
-                + keys.size() + ""):"");
-        for (long k : keys) {
-            pwriter.print(""0x"" + Long.toHexString(k));
+                + ephemerals.keySet().size() + ""):"");
+        for (Entry<Long, HashSet<String>> entry : ephemerals.entrySet()) {
+            pwriter.print(""0x"" + Long.toHexString(entry.getKey()));
             pwriter.println("":"");
-            HashSet<String> tmp = ephemerals.get(k);
+            HashSet<String> tmp = entry.getValue();","[{'comment': 'Could we define `tmp` as `Set` instead of `HashSet`?\n', 'commenter': 'eribeiro'}, {'comment': ""Is there any benefit of doing so? It's sad we don't have auto keyword in Java.\n"", 'commenter': 'hanm'}, {'comment': 'Usually, prefer to use the interface if we only use the methods defined in the interface, which makes it flexible (or less change needed) in case we want to use another Set implementation. \n\nThere is a best practice defined in Effective Java 2nd Edition, Item 52: Refer to objects by their interfaces:\nIf appropriate interface types exist, then parameters, return values, and fields should all be declared using interface types. If you get into the habit of using interface types, your program will be much more flexible. It is entirely appropriate to refer to an object by a class if no appropriate interface exists.\n', 'commenter': 'lvfangmin'}, {'comment': '@lvfangmin Thanks for the reference. It makes sense to me. There are a couple of other places in code base that could be refactored, so rather than mixing this change with this PR I created ZOOKEEPER-2630 for the refactoring task.\n', 'commenter': 'hanm'}, {'comment': 'Ya @lvfangmin, one of my favourite books on Java, and was the reference to my comment above. Thanks pointing out. :smiley:\n\nAgree with @hanm, better to create a separate issue for dealing with this legacy technical debt. :+1: \n', 'commenter': 'eribeiro'}]"
102,src/java/main/org/apache/jute/compiler/JRecord.java,"@@ -141,109 +141,128 @@ public String genCsharpWriteWrapper(String fname, String tag) {
 
     static HashMap<String, String> vectorStructs = new HashMap<String, String>();
     public void genCCode(FileWriter h, FileWriter c) throws IOException {
-        for (JField f : mFields) {
-            if (f.getType() instanceof JVector) {
-                JVector jv = (JVector)f.getType();
-                JType jvType = jv.getElementType();
-                String struct_name = JVector.extractVectorName(jvType);
-                if (vectorStructs.get(struct_name) == null) {
-                    vectorStructs.put(struct_name, struct_name);
-                    h.write(""struct "" + struct_name + "" {\n    int32_t count;\n"" + jv.getElementType().genCDecl(""*data"") + ""\n};\n"");
-                    h.write(""int serialize_"" + struct_name + ""(struct oarchive *out, const char *tag, struct "" + struct_name + "" *v);\n"");
-                    h.write(""int deserialize_"" + struct_name + ""(struct iarchive *in, const char *tag, struct "" + struct_name + "" *v);\n"");
-                    h.write(""int allocate_"" + struct_name + ""(struct "" + struct_name + "" *v, int32_t len);\n"");
-                    h.write(""int deallocate_"" + struct_name + ""(struct "" + struct_name + "" *v);\n"");
-                    c.write(""int allocate_"" + struct_name + ""(struct "" + struct_name + "" *v, int32_t len) {\n"");
-                    c.write(""    if (!len) {\n"");
-                    c.write(""        v->count = 0;\n"");
-                    c.write(""        v->data = 0;\n"");
-                    c.write(""    } else {\n"");
-                    c.write(""        v->count = len;\n"");
-                    c.write(""        v->data = calloc(sizeof(*v->data), len);\n"");
-                    c.write(""    }\n"");
-                    c.write(""    return 0;\n"");
-                    c.write(""}\n"");
-                    c.write(""int deallocate_"" + struct_name + ""(struct "" + struct_name + "" *v) {\n"");
-                    c.write(""    if (v->data) {\n"");
-                    c.write(""        int32_t i;\n"");
-                    c.write(""        for(i=0;i<v->count; i++) {\n"");
-                    c.write(""            deallocate_""+JRecord.extractMethodSuffix(jvType)+""(&v->data[i]);\n"");
-                    c.write(""        }\n"");
-                    c.write(""        free(v->data);\n"");
-                    c.write(""        v->data = 0;\n"");
-                    c.write(""    }\n"");
-                    c.write(""    return 0;\n"");
-                    c.write(""}\n"");
-                    c.write(""int serialize_"" + struct_name + ""(struct oarchive *out, const char *tag, struct "" + struct_name + "" *v)\n"");
-                    c.write(""{\n"");
-                    c.write(""    int32_t count = v->count;\n"");
-                    c.write(""    int rc = 0;\n"");
-                    c.write(""    int32_t i;\n"");
-                    c.write(""    rc = out->start_vector(out, tag, &count);\n"");
-                    c.write(""    for(i=0;i<v->count;i++) {\n"");
-                    genSerialize(c, jvType, ""data"", ""data[i]"");
-                    c.write(""    }\n"");
-                    c.write(""    rc = rc ? rc : out->end_vector(out, tag);\n"");
-                    c.write(""    return rc;\n"");
-                    c.write(""}\n"");
-                    c.write(""int deserialize_"" + struct_name + ""(struct iarchive *in, const char *tag, struct "" + struct_name + "" *v)\n"");
-                    c.write(""{\n"");
-                    c.write(""    int rc = 0;\n"");
-                    c.write(""    int32_t i;\n"");
-                    c.write(""    rc = in->start_vector(in, tag, &v->count);\n"");
-                    c.write(""    v->data = calloc(v->count, sizeof(*v->data));\n"");
-                    c.write(""    for(i=0;i<v->count;i++) {\n"");
-                    genDeserialize(c, jvType, ""value"", ""data[i]"");
-                    c.write(""    }\n"");
-                    c.write(""    rc = in->end_vector(in, tag);\n"");
-                    c.write(""    return rc;\n"");
-                    c.write(""}\n"");
-
+        try {
+            for (JField f : mFields) {
+                if (f.getType() instanceof JVector) {
+                    JVector jv = (JVector) f.getType();
+                    JType jvType = jv.getElementType();
+                    String struct_name = JVector.extractVectorName(jvType);
+                    if (vectorStructs.get(struct_name) == null) {
+                        vectorStructs.put(struct_name, struct_name);
+                        h.write(""struct "" + struct_name + "" {\n    int32_t count;\n"" + jv.getElementType().genCDecl(""*data"") + ""\n};\n"");
+                        h.write(""int serialize_"" + struct_name + ""(struct oarchive *out, const char *tag, struct "" + struct_name + "" *v);\n"");
+                        h.write(""int deserialize_"" + struct_name + ""(struct iarchive *in, const char *tag, struct "" + struct_name + "" *v);\n"");
+                        h.write(""int allocate_"" + struct_name + ""(struct "" + struct_name + "" *v, int32_t len);\n"");
+                        h.write(""int deallocate_"" + struct_name + ""(struct "" + struct_name + "" *v);\n"");
+                        c.write(""int allocate_"" + struct_name + ""(struct "" + struct_name + "" *v, int32_t len) {\n"");
+                        c.write(""    if (!len) {\n"");
+                        c.write(""        v->count = 0;\n"");
+                        c.write(""        v->data = 0;\n"");
+                        c.write(""    } else {\n"");
+                        c.write(""        v->count = len;\n"");
+                        c.write(""        v->data = calloc(sizeof(*v->data), len);\n"");
+                        c.write(""    }\n"");
+                        c.write(""    return 0;\n"");
+                        c.write(""}\n"");
+                        c.write(""int deallocate_"" + struct_name + ""(struct "" + struct_name + "" *v) {\n"");
+                        c.write(""    if (v->data) {\n"");
+                        c.write(""        int32_t i;\n"");
+                        c.write(""        for(i=0;i<v->count; i++) {\n"");
+                        c.write(""            deallocate_"" + JRecord.extractMethodSuffix(jvType) + ""(&v->data[i]);\n"");
+                        c.write(""        }\n"");
+                        c.write(""        free(v->data);\n"");
+                        c.write(""        v->data = 0;\n"");
+                        c.write(""    }\n"");
+                        c.write(""    return 0;\n"");
+                        c.write(""}\n"");
+                        c.write(""int serialize_"" + struct_name + ""(struct oarchive *out, const char *tag, struct "" + struct_name + "" *v)\n"");
+                        c.write(""{\n"");
+                        c.write(""    int32_t count = v->count;\n"");
+                        c.write(""    int rc = 0;\n"");
+                        c.write(""    int32_t i;\n"");
+                        c.write(""    rc = out->start_vector(out, tag, &count);\n"");
+                        c.write(""    for(i=0;i<v->count;i++) {\n"");
+                        genSerialize(c, jvType, ""data"", ""data[i]"");
+                        c.write(""    }\n"");
+                        c.write(""    rc = rc ? rc : out->end_vector(out, tag);\n"");
+                        c.write(""    return rc;\n"");
+                        c.write(""}\n"");
+                        c.write(""int deserialize_"" + struct_name + ""(struct iarchive *in, const char *tag, struct "" + struct_name + "" *v)\n"");
+                        c.write(""{\n"");
+                        c.write(""    int rc = 0;\n"");
+                        c.write(""    int32_t i;\n"");
+                        c.write(""    rc = in->start_vector(in, tag, &v->count);\n"");
+                        c.write(""    v->data = calloc(v->count, sizeof(*v->data));\n"");
+                        c.write(""    for(i=0;i<v->count;i++) {\n"");
+                        genDeserialize(c, jvType, ""value"", ""data[i]"");
+                        c.write(""    }\n"");
+                        c.write(""    rc = in->end_vector(in, tag);\n"");
+                        c.write(""    return rc;\n"");
+                        c.write(""}\n"");
+
+                    }
                 }
             }
-        }
-        String rec_name = getName();
-        h.write(""struct "" + rec_name + "" {\n"");
-        for (JField f : mFields) {
-            h.write(f.genCDecl());
-        }
-        h.write(""};\n"");
-        h.write(""int serialize_"" + rec_name + ""(struct oarchive *out, const char *tag, struct "" + rec_name + "" *v);\n"");
-        h.write(""int deserialize_"" + rec_name + ""(struct iarchive *in, const char *tag, struct "" + rec_name + ""*v);\n"");
-        h.write(""void deallocate_"" + rec_name + ""(struct "" + rec_name + ""*);\n"");
-        c.write(""int serialize_"" + rec_name + ""(struct oarchive *out, const char *tag, struct "" + rec_name + "" *v)"");
-        c.write(""{\n"");
-        c.write(""    int rc;\n"");
-        c.write(""    rc = out->start_record(out, tag);\n"");
-        for(JField f : mFields) {
-            genSerialize(c, f.getType(), f.getTag(), f.getName());
-        }
-        c.write(""    rc = rc ? rc : out->end_record(out, tag);\n"");
-        c.write(""    return rc;\n"");
-        c.write(""}\n"");
-        c.write(""int deserialize_"" + rec_name + ""(struct iarchive *in, const char *tag, struct "" + rec_name + ""*v)"");
-        c.write(""{\n"");
-        c.write(""    int rc;\n"");
-        c.write(""    rc = in->start_record(in, tag);\n"");
-        for(JField f : mFields) {
-            genDeserialize(c, f.getType(), f.getTag(), f.getName());
-        }
-        c.write(""    rc = rc ? rc : in->end_record(in, tag);\n"");
-        c.write(""    return rc;\n"");
-        c.write(""}\n"");
-        c.write(""void deallocate_"" + rec_name + ""(struct "" + rec_name + ""*v)"");
-        c.write(""{\n"");
-        for(JField f : mFields) {
-            if (f.getType() instanceof JRecord) {
-                c.write(""    deallocate_"" + extractStructName(f.getType()) + ""(&v->"" + f.getName() + "");\n"");
-            } else if (f.getType() instanceof JVector) {
-                JVector vt = (JVector)f.getType();
-                c.write(""    deallocate_"" + JVector.extractVectorName(vt.getElementType())+ ""(&v->""+f.getName()+"");\n"");
-            } else if (f.getType() instanceof JCompType) {
-                c.write(""    deallocate_"" + extractMethodSuffix(f.getType()) + ""(&v->""+f.getName()+"");\n"");
+            String rec_name = getName();
+            h.write(""struct "" + rec_name + "" {\n"");
+            for (JField f : mFields) {
+                h.write(f.genCDecl());
+            }
+            h.write(""};\n"");
+            h.write(""int serialize_"" + rec_name + ""(struct oarchive *out, const char *tag, struct "" + rec_name + "" *v);\n"");
+            h.write(""int deserialize_"" + rec_name + ""(struct iarchive *in, const char *tag, struct "" + rec_name + ""*v);\n"");
+            h.write(""void deallocate_"" + rec_name + ""(struct "" + rec_name + ""*);\n"");
+            c.write(""int serialize_"" + rec_name + ""(struct oarchive *out, const char *tag, struct "" + rec_name + "" *v)"");
+            c.write(""{\n"");
+            c.write(""    int rc;\n"");
+            c.write(""    rc = out->start_record(out, tag);\n"");
+            for (JField f : mFields) {
+                genSerialize(c, f.getType(), f.getTag(), f.getName());
+            }
+            c.write(""    rc = rc ? rc : out->end_record(out, tag);\n"");
+            c.write(""    return rc;\n"");
+            c.write(""}\n"");
+            c.write(""int deserialize_"" + rec_name + ""(struct iarchive *in, const char *tag, struct "" + rec_name + ""*v)"");
+            c.write(""{\n"");
+            c.write(""    int rc;\n"");
+            c.write(""    rc = in->start_record(in, tag);\n"");
+            for (JField f : mFields) {
+                genDeserialize(c, f.getType(), f.getTag(), f.getName());
+            }
+            c.write(""    rc = rc ? rc : in->end_record(in, tag);\n"");
+            c.write(""    return rc;\n"");
+            c.write(""}\n"");
+            c.write(""void deallocate_"" + rec_name + ""(struct "" + rec_name + ""*v)"");
+            c.write(""{\n"");
+            for (JField f : mFields) {
+                if (f.getType() instanceof JRecord) {
+                    c.write(""    deallocate_"" + extractStructName(f.getType()) + ""(&v->"" + f.getName() + "");\n"");
+                } else if (f.getType() instanceof JVector) {
+                    JVector vt = (JVector) f.getType();
+                    c.write(""    deallocate_"" + JVector.extractVectorName(vt.getElementType()) + ""(&v->"" + f.getName() + "");\n"");
+                } else if (f.getType() instanceof JCompType) {
+                    c.write(""    deallocate_"" + extractMethodSuffix(f.getType()) + ""(&v->"" + f.getName() + "");\n"");
+                }
+            }
+            c.write(""}\n"");
+        } catch (IOException e) {
+            throw e;
+        } finally {
+            if (h != null) {","[{'comment': ""Just speculating here: couldn't we write this snippet as:\n\n```\nprivate IOException maybeClose(FileWriter file) {\n       IOException t = null;\n       if (file != null) {\n             try {\n                     file.close();\n             } catch (IOException ex) {\n                   t = ex;\n             }          \n     }\n    return t;\n}\n\n(...)\n\n} finally {\n\n    IOException e1 = maybeClose(h);\n    IOException e2 = maybeClose(c);\n\n    if (e1 != null) {\n        throw e1;\n    }\n\n   if (e2 != null) {\n       throw e2;\n   }\n}\n\n\n```\n"", 'commenter': 'eribeiro'}, {'comment': 'updated with a more concise version that findbug is happy with.\n', 'commenter': 'hanm'}]"
102,src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java,"@@ -151,9 +153,13 @@
      */
     public final static int telnetCloseCmd = 0xfff4fffd;
 
-    public final static HashMap<Integer, String> cmd2String =
+    final static HashMap<Integer, String> cmd2String =","[{'comment': 'Same here, we can also define this as Map to keep consistent with the others.\n', 'commenter': 'lvfangmin'}, {'comment': ""We just need to make sure this doesn't break any client exposed public field. Looks like it is **not** this case (that is, we can make it a `Map`), but unfortunately I guess not all concrete declarations in ZK codebase can be changed to interfaces without breaking backward compatibility. It is not that we are not going to change it, but probably only at major release version.\n"", 'commenter': 'eribeiro'}, {'comment': 'If we can remove this `public`, then I think we should. Also agree with the consistent `Map` declaration comment.', 'commenter': 'fpj'}]"
102,src/java/main/org/apache/jute/compiler/JRecord.java,"@@ -403,168 +410,165 @@ public void genJavaCode(File outputDirectory) throws IOException {
         } else if (!pkgdir.isDirectory()) {
             throw new IOException(pkgpath + "" is not a directory."");
         }
-        File jfile = new File(pkgdir, getName()+"".java"");
-        FileWriter jj = new FileWriter(jfile);
-        jj.write(""// File generated by hadoop record compiler. Do not edit.\n"");
-        jj.write(""/**\n"");
-        jj.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");
-        jj.write(""* or more contributor license agreements.  See the NOTICE file\n"");
-        jj.write(""* distributed with this work for additional information\n"");
-        jj.write(""* regarding copyright ownership.  The ASF licenses this file\n"");
-        jj.write(""* to you under the Apache License, Version 2.0 (the\n"");
-        jj.write(""* \""License\""); you may not use this file except in compliance\n"");
-        jj.write(""* with the License.  You may obtain a copy of the License at\n"");
-        jj.write(""*\n"");
-        jj.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");
-        jj.write(""*\n"");
-        jj.write(""* Unless required by applicable law or agreed to in writing, software\n"");
-        jj.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");
-        jj.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");
-        jj.write(""* See the License for the specific language governing permissions and\n"");
-        jj.write(""* limitations under the License.\n"");
-        jj.write(""*/\n"");
-        jj.write(""\n"");
-        jj.write(""package ""+getJavaPackage()+"";\n\n"");
-        jj.write(""import org.apache.jute.*;\n"");
-        jj.write(""public class ""+getName()+"" implements Record {\n"");
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext();) {
-            JField jf = i.next();
-            jj.write(jf.genJavaDecl());
-        }
-        jj.write(""  public ""+getName()+""() {\n"");
-        jj.write(""  }\n"");
+        try (FileWriter jj = new FileWriter(new File(pkgdir, getName()+"".java""))) {
+            jj.write(""// File generated by hadoop record compiler. Do not edit.\n"");
+            jj.write(""/**\n"");
+            jj.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");
+            jj.write(""* or more contributor license agreements.  See the NOTICE file\n"");
+            jj.write(""* distributed with this work for additional information\n"");
+            jj.write(""* regarding copyright ownership.  The ASF licenses this file\n"");
+            jj.write(""* to you under the Apache License, Version 2.0 (the\n"");
+            jj.write(""* \""License\""); you may not use this file except in compliance\n"");
+            jj.write(""* with the License.  You may obtain a copy of the License at\n"");
+            jj.write(""*\n"");
+            jj.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");
+            jj.write(""*\n"");
+            jj.write(""* Unless required by applicable law or agreed to in writing, software\n"");
+            jj.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");
+            jj.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");
+            jj.write(""* See the License for the specific language governing permissions and\n"");
+            jj.write(""* limitations under the License.\n"");
+            jj.write(""*/\n"");
+            jj.write(""\n"");
+            jj.write(""package "" + getJavaPackage() + "";\n\n"");
+            jj.write(""import org.apache.jute.*;\n"");
+            jj.write(""public class "" + getName() + "" implements Record {\n"");
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); ) {
+                JField jf = i.next();
+                jj.write(jf.genJavaDecl());
+            }
+            jj.write(""  public "" + getName() + ""() {\n"");
+            jj.write(""  }\n"");
 
-        jj.write(""  public ""+getName()+""(\n"");
-        int fIdx = 0;
-        int fLen = mFields.size();
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaConstructorParam(jf.getName()));
-            jj.write((fLen-1 == fIdx)?"""":"",\n"");
-        }
-        jj.write("") {\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaConstructorSet(jf.getName()));
-        }
-        jj.write(""  }\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaGetSet(fIdx));
-        }
-        jj.write(""  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\n"");
-        jj.write(""    a_.startRecord(this,tag);\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaWriteMethodName());
-        }
-        jj.write(""    a_.endRecord(this,tag);\n"");
-        jj.write(""  }\n"");
+            jj.write(""  public "" + getName() + ""(\n"");
+            int fIdx = 0;
+            int fLen = mFields.size();
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaConstructorParam(jf.getName()));
+                jj.write((fLen - 1 == fIdx) ? """" : "",\n"");
+            }
+            jj.write("") {\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaConstructorSet(jf.getName()));
+            }
+            jj.write(""  }\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaGetSet(fIdx));
+            }
+            jj.write(""  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\n"");
+            jj.write(""    a_.startRecord(this,tag);\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaWriteMethodName());
+            }
+            jj.write(""    a_.endRecord(this,tag);\n"");
+            jj.write(""  }\n"");
 
-        jj.write(""  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\n"");
-        jj.write(""    a_.startRecord(tag);\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaReadMethodName());
-        }
-        jj.write(""    a_.endRecord(tag);\n"");
-        jj.write(""}\n"");
-
-        jj.write(""  public String toString() {\n"");
-        jj.write(""    try {\n"");
-        jj.write(""      java.io.ByteArrayOutputStream s =\n"");
-        jj.write(""        new java.io.ByteArrayOutputStream();\n"");
-        jj.write(""      CsvOutputArchive a_ = \n"");
-        jj.write(""        new CsvOutputArchive(s);\n"");
-        jj.write(""      a_.startRecord(this,\""\"");\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaWriteMethodName());
-        }
-        jj.write(""      a_.endRecord(this,\""\"");\n"");
-        jj.write(""      return new String(s.toByteArray(), \""UTF-8\"");\n"");
-        jj.write(""    } catch (Throwable ex) {\n"");
-        jj.write(""      ex.printStackTrace();\n"");
-        jj.write(""    }\n"");
-        jj.write(""    return \""ERROR\"";\n"");
-        jj.write(""  }\n"");
-
-        jj.write(""  public void write(java.io.DataOutput out) throws java.io.IOException {\n"");
-        jj.write(""    BinaryOutputArchive archive = new BinaryOutputArchive(out);\n"");
-        jj.write(""    serialize(archive, \""\"");\n"");
-        jj.write(""  }\n"");
-
-        jj.write(""  public void readFields(java.io.DataInput in) throws java.io.IOException {\n"");
-        jj.write(""    BinaryInputArchive archive = new BinaryInputArchive(in);\n"");
-        jj.write(""    deserialize(archive, \""\"");\n"");
-        jj.write(""  }\n"");
-
-        jj.write(""  public int compareTo (Object peer_) throws ClassCastException {\n"");
-        boolean unimplemented = false;
-        for (JField f : mFields) {
-            if ((f.getType() instanceof JMap)
-                    || (f.getType() instanceof JVector))
-            {
-                unimplemented = true;
+            jj.write(""  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\n"");
+            jj.write(""    a_.startRecord(tag);\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaReadMethodName());
             }
-        }
-        if (unimplemented) {
-            jj.write(""    throw new UnsupportedOperationException(\""comparing ""
-                    + getName() + "" is unimplemented\"");\n"");
-        } else {
-            jj.write(""    if (!(peer_ instanceof ""+getName()+"")) {\n"");
-            jj.write(""      throw new ClassCastException(\""Comparing different types of records.\"");\n"");
+            jj.write(""    a_.endRecord(tag);\n"");
+            jj.write(""}\n"");
+
+            jj.write(""  public String toString() {\n"");
+            jj.write(""    try {\n"");
+            jj.write(""      java.io.ByteArrayOutputStream s =\n"");
+            jj.write(""        new java.io.ByteArrayOutputStream();\n"");
+            jj.write(""      CsvOutputArchive a_ = \n"");
+            jj.write(""        new CsvOutputArchive(s);\n"");
+            jj.write(""      a_.startRecord(this,\""\"");\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaWriteMethodName());
+            }
+            jj.write(""      a_.endRecord(this,\""\"");\n"");
+            jj.write(""      return new String(s.toByteArray(), \""UTF-8\"");\n"");
+            jj.write(""    } catch (Throwable ex) {\n"");
+            jj.write(""      ex.printStackTrace();\n"");
             jj.write(""    }\n"");
-            jj.write(""    ""+getName()+"" peer = (""+getName()+"") peer_;\n"");
-            jj.write(""    int ret = 0;\n"");
+            jj.write(""    return \""ERROR\"";\n"");
+            jj.write(""  }\n"");
+
+            jj.write(""  public void write(java.io.DataOutput out) throws java.io.IOException {\n"");
+            jj.write(""    BinaryOutputArchive archive = new BinaryOutputArchive(out);\n"");
+            jj.write(""    serialize(archive, \""\"");\n"");
+            jj.write(""  }\n"");
+
+            jj.write(""  public void readFields(java.io.DataInput in) throws java.io.IOException {\n"");
+            jj.write(""    BinaryInputArchive archive = new BinaryInputArchive(in);\n"");
+            jj.write(""    deserialize(archive, \""\"");\n"");
+            jj.write(""  }\n"");
+
+            jj.write(""  public int compareTo (Object peer_) throws ClassCastException {\n"");
+            boolean unimplemented = false;
+            for (JField f : mFields) {
+                if ((f.getType() instanceof JMap)
+                        || (f.getType() instanceof JVector)) {
+                    unimplemented = true;
+                }
+            }
+            if (unimplemented) {
+                jj.write(""    throw new UnsupportedOperationException(\""comparing ""
+                        + getName() + "" is unimplemented\"");\n"");
+            } else {
+                jj.write(""    if (!(peer_ instanceof "" + getName() + "")) {\n"");
+                jj.write(""      throw new ClassCastException(\""Comparing different types of records.\"");\n"");
+                jj.write(""    }\n"");
+                jj.write(""    "" + getName() + "" peer = ("" + getName() + "") peer_;\n"");
+                jj.write(""    int ret = 0;\n"");
+                for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                    JField jf = i.next();
+                    jj.write(jf.genJavaCompareTo());
+                    jj.write(""    if (ret != 0) return ret;\n"");
+                }
+                jj.write(""     return ret;\n"");
+            }
+            jj.write(""  }\n"");
+
+            jj.write(""  public boolean equals(Object peer_) {\n"");
+            jj.write(""    if (!(peer_ instanceof "" + getName() + "")) {\n"");
+            jj.write(""      return false;\n"");
+            jj.write(""    }\n"");
+            jj.write(""    if (peer_ == this) {\n"");
+            jj.write(""      return true;\n"");
+            jj.write(""    }\n"");
+            jj.write(""    "" + getName() + "" peer = ("" + getName() + "") peer_;\n"");
+            jj.write(""    boolean ret = false;\n"");
             for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
                 JField jf = i.next();
-                jj.write(jf.genJavaCompareTo());
-                jj.write(""    if (ret != 0) return ret;\n"");
+                jj.write(jf.genJavaEquals());","[{'comment': ""What's the reason for changing to `genJavaEquals`?"", 'commenter': 'fpj'}, {'comment': 'Similarly, there is no actual change here.', 'commenter': 'hanm'}]"
102,src/java/main/org/apache/jute/compiler/JRecord.java,"@@ -403,168 +410,165 @@ public void genJavaCode(File outputDirectory) throws IOException {
         } else if (!pkgdir.isDirectory()) {
             throw new IOException(pkgpath + "" is not a directory."");
         }
-        File jfile = new File(pkgdir, getName()+"".java"");
-        FileWriter jj = new FileWriter(jfile);
-        jj.write(""// File generated by hadoop record compiler. Do not edit.\n"");
-        jj.write(""/**\n"");
-        jj.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");
-        jj.write(""* or more contributor license agreements.  See the NOTICE file\n"");
-        jj.write(""* distributed with this work for additional information\n"");
-        jj.write(""* regarding copyright ownership.  The ASF licenses this file\n"");
-        jj.write(""* to you under the Apache License, Version 2.0 (the\n"");
-        jj.write(""* \""License\""); you may not use this file except in compliance\n"");
-        jj.write(""* with the License.  You may obtain a copy of the License at\n"");
-        jj.write(""*\n"");
-        jj.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");
-        jj.write(""*\n"");
-        jj.write(""* Unless required by applicable law or agreed to in writing, software\n"");
-        jj.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");
-        jj.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");
-        jj.write(""* See the License for the specific language governing permissions and\n"");
-        jj.write(""* limitations under the License.\n"");
-        jj.write(""*/\n"");
-        jj.write(""\n"");
-        jj.write(""package ""+getJavaPackage()+"";\n\n"");
-        jj.write(""import org.apache.jute.*;\n"");
-        jj.write(""public class ""+getName()+"" implements Record {\n"");
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext();) {
-            JField jf = i.next();
-            jj.write(jf.genJavaDecl());
-        }
-        jj.write(""  public ""+getName()+""() {\n"");
-        jj.write(""  }\n"");
+        try (FileWriter jj = new FileWriter(new File(pkgdir, getName()+"".java""))) {
+            jj.write(""// File generated by hadoop record compiler. Do not edit.\n"");
+            jj.write(""/**\n"");
+            jj.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");
+            jj.write(""* or more contributor license agreements.  See the NOTICE file\n"");
+            jj.write(""* distributed with this work for additional information\n"");
+            jj.write(""* regarding copyright ownership.  The ASF licenses this file\n"");
+            jj.write(""* to you under the Apache License, Version 2.0 (the\n"");
+            jj.write(""* \""License\""); you may not use this file except in compliance\n"");
+            jj.write(""* with the License.  You may obtain a copy of the License at\n"");
+            jj.write(""*\n"");
+            jj.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");
+            jj.write(""*\n"");
+            jj.write(""* Unless required by applicable law or agreed to in writing, software\n"");
+            jj.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");
+            jj.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");
+            jj.write(""* See the License for the specific language governing permissions and\n"");
+            jj.write(""* limitations under the License.\n"");
+            jj.write(""*/\n"");
+            jj.write(""\n"");
+            jj.write(""package "" + getJavaPackage() + "";\n\n"");
+            jj.write(""import org.apache.jute.*;\n"");
+            jj.write(""public class "" + getName() + "" implements Record {\n"");
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); ) {
+                JField jf = i.next();
+                jj.write(jf.genJavaDecl());
+            }
+            jj.write(""  public "" + getName() + ""() {\n"");
+            jj.write(""  }\n"");
 
-        jj.write(""  public ""+getName()+""(\n"");
-        int fIdx = 0;
-        int fLen = mFields.size();
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaConstructorParam(jf.getName()));
-            jj.write((fLen-1 == fIdx)?"""":"",\n"");
-        }
-        jj.write("") {\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaConstructorSet(jf.getName()));
-        }
-        jj.write(""  }\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaGetSet(fIdx));
-        }
-        jj.write(""  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\n"");
-        jj.write(""    a_.startRecord(this,tag);\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaWriteMethodName());
-        }
-        jj.write(""    a_.endRecord(this,tag);\n"");
-        jj.write(""  }\n"");
+            jj.write(""  public "" + getName() + ""(\n"");
+            int fIdx = 0;
+            int fLen = mFields.size();
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaConstructorParam(jf.getName()));
+                jj.write((fLen - 1 == fIdx) ? """" : "",\n"");
+            }
+            jj.write("") {\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaConstructorSet(jf.getName()));
+            }
+            jj.write(""  }\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaGetSet(fIdx));
+            }
+            jj.write(""  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\n"");
+            jj.write(""    a_.startRecord(this,tag);\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaWriteMethodName());
+            }
+            jj.write(""    a_.endRecord(this,tag);\n"");
+            jj.write(""  }\n"");
 
-        jj.write(""  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\n"");
-        jj.write(""    a_.startRecord(tag);\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaReadMethodName());
-        }
-        jj.write(""    a_.endRecord(tag);\n"");
-        jj.write(""}\n"");
-
-        jj.write(""  public String toString() {\n"");
-        jj.write(""    try {\n"");
-        jj.write(""      java.io.ByteArrayOutputStream s =\n"");
-        jj.write(""        new java.io.ByteArrayOutputStream();\n"");
-        jj.write(""      CsvOutputArchive a_ = \n"");
-        jj.write(""        new CsvOutputArchive(s);\n"");
-        jj.write(""      a_.startRecord(this,\""\"");\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaWriteMethodName());
-        }
-        jj.write(""      a_.endRecord(this,\""\"");\n"");
-        jj.write(""      return new String(s.toByteArray(), \""UTF-8\"");\n"");
-        jj.write(""    } catch (Throwable ex) {\n"");
-        jj.write(""      ex.printStackTrace();\n"");
-        jj.write(""    }\n"");
-        jj.write(""    return \""ERROR\"";\n"");
-        jj.write(""  }\n"");
-
-        jj.write(""  public void write(java.io.DataOutput out) throws java.io.IOException {\n"");
-        jj.write(""    BinaryOutputArchive archive = new BinaryOutputArchive(out);\n"");
-        jj.write(""    serialize(archive, \""\"");\n"");
-        jj.write(""  }\n"");
-
-        jj.write(""  public void readFields(java.io.DataInput in) throws java.io.IOException {\n"");
-        jj.write(""    BinaryInputArchive archive = new BinaryInputArchive(in);\n"");
-        jj.write(""    deserialize(archive, \""\"");\n"");
-        jj.write(""  }\n"");
-
-        jj.write(""  public int compareTo (Object peer_) throws ClassCastException {\n"");
-        boolean unimplemented = false;
-        for (JField f : mFields) {
-            if ((f.getType() instanceof JMap)
-                    || (f.getType() instanceof JVector))
-            {
-                unimplemented = true;
+            jj.write(""  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\n"");
+            jj.write(""    a_.startRecord(tag);\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaReadMethodName());
             }
-        }
-        if (unimplemented) {
-            jj.write(""    throw new UnsupportedOperationException(\""comparing ""
-                    + getName() + "" is unimplemented\"");\n"");
-        } else {
-            jj.write(""    if (!(peer_ instanceof ""+getName()+"")) {\n"");
-            jj.write(""      throw new ClassCastException(\""Comparing different types of records.\"");\n"");
+            jj.write(""    a_.endRecord(tag);\n"");
+            jj.write(""}\n"");
+
+            jj.write(""  public String toString() {\n"");
+            jj.write(""    try {\n"");
+            jj.write(""      java.io.ByteArrayOutputStream s =\n"");
+            jj.write(""        new java.io.ByteArrayOutputStream();\n"");
+            jj.write(""      CsvOutputArchive a_ = \n"");
+            jj.write(""        new CsvOutputArchive(s);\n"");
+            jj.write(""      a_.startRecord(this,\""\"");\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaWriteMethodName());
+            }
+            jj.write(""      a_.endRecord(this,\""\"");\n"");
+            jj.write(""      return new String(s.toByteArray(), \""UTF-8\"");\n"");
+            jj.write(""    } catch (Throwable ex) {\n"");
+            jj.write(""      ex.printStackTrace();\n"");
             jj.write(""    }\n"");
-            jj.write(""    ""+getName()+"" peer = (""+getName()+"") peer_;\n"");
-            jj.write(""    int ret = 0;\n"");
+            jj.write(""    return \""ERROR\"";\n"");
+            jj.write(""  }\n"");
+
+            jj.write(""  public void write(java.io.DataOutput out) throws java.io.IOException {\n"");
+            jj.write(""    BinaryOutputArchive archive = new BinaryOutputArchive(out);\n"");
+            jj.write(""    serialize(archive, \""\"");\n"");
+            jj.write(""  }\n"");
+
+            jj.write(""  public void readFields(java.io.DataInput in) throws java.io.IOException {\n"");
+            jj.write(""    BinaryInputArchive archive = new BinaryInputArchive(in);\n"");
+            jj.write(""    deserialize(archive, \""\"");\n"");
+            jj.write(""  }\n"");
+
+            jj.write(""  public int compareTo (Object peer_) throws ClassCastException {\n"");
+            boolean unimplemented = false;
+            for (JField f : mFields) {
+                if ((f.getType() instanceof JMap)
+                        || (f.getType() instanceof JVector)) {
+                    unimplemented = true;
+                }
+            }
+            if (unimplemented) {
+                jj.write(""    throw new UnsupportedOperationException(\""comparing ""
+                        + getName() + "" is unimplemented\"");\n"");
+            } else {
+                jj.write(""    if (!(peer_ instanceof "" + getName() + "")) {\n"");
+                jj.write(""      throw new ClassCastException(\""Comparing different types of records.\"");\n"");
+                jj.write(""    }\n"");
+                jj.write(""    "" + getName() + "" peer = ("" + getName() + "") peer_;\n"");
+                jj.write(""    int ret = 0;\n"");
+                for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                    JField jf = i.next();
+                    jj.write(jf.genJavaCompareTo());","[{'comment': 'Why are we changing to `genJavaEquals` below and not here?', 'commenter': 'fpj'}, {'comment': 'This diff presented by git is not very accurate to reflect the state of the changes. There is no literal changes to these code blocks except indentations. We can compare the vanilla source file in master branch and in my working branch where the PR is created to double check:\r\nJRecord.java in master: https://github.com/apache/zookeeper/blob/master/src/java/main/org/apache/jute/compiler/JRecord.java#L525\r\nJRecord.java in PR branch:\r\nhttps://github.com/hanm/zookeeper/blob/ZOOKEEPER-2628/src/java/main/org/apache/jute/compiler/JRecord.java#L530\r\nStarting from these lines, compare both file side by side, they are the same. I am not sure why the diff was formatted this way. ', 'commenter': 'hanm'}]"
102,src/java/main/org/apache/zookeeper/cli/DeleteCommand.java,"@@ -56,14 +56,7 @@ public CliCommand parse(String[] cmdArgs) throws CliParseException {
     }
 
     private void retainCompatibility(String[] cmdArgs) throws CliParseException {
-        // delete path [version]
         if (args.length > 2) {
-            // rewrite to option
-            String [] newCmd = new String[4];","[{'comment': 'Why are we removing this rewrite?', 'commenter': 'fpj'}, {'comment': ""These are dead code. newCmd was declared but not used so it's better to remove them. "", 'commenter': 'hanm'}]"
102,src/java/test/config/findbugsExcludeFile.xml,"@@ -144,4 +144,10 @@
     <Bug pattern=""DM_DEFAULT_ENCODING"" />
   </Match>
 
+  <!-- Disable 'Malicious code vulnerability warnings' due to mutable collection types in interface.","[{'comment': 'We probably want to leave a note in ZOOKEEPER-1362 to remind ourselves to do it.', 'commenter': 'fpj'}, {'comment': 'Gonna say that! At least a TODO mark I guess...', 'commenter': 'eribeiro'}, {'comment': 'Comments added to ZOOKEEPER-1362.', 'commenter': 'hanm'}]"
102,src/java/main/org/apache/jute/compiler/JRecord.java,"@@ -576,174 +580,174 @@ public void genCsharpCode(File outputDirectory) throws IOException {
         } else if (!outputDirectory.isDirectory()) {
             throw new IOException(outputDirectory + "" is not a directory."");
         }
-        File csharpFile = new File(outputDirectory, getName()+"".cs"");
-        FileWriter cs = new FileWriter(csharpFile);
-        cs.write(""// File generated by hadoop record compiler. Do not edit.\n"");
-        cs.write(""/**\n"");
-        cs.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");
-        cs.write(""* or more contributor license agreements.  See the NOTICE file\n"");
-        cs.write(""* distributed with this work for additional information\n"");
-        cs.write(""* regarding copyright ownership.  The ASF licenses this file\n"");
-        cs.write(""* to you under the Apache License, Version 2.0 (the\n"");
-        cs.write(""* \""License\""); you may not use this file except in compliance\n"");
-        cs.write(""* with the License.  You may obtain a copy of the License at\n"");
-        cs.write(""*\n"");
-        cs.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");
-        cs.write(""*\n"");
-        cs.write(""* Unless required by applicable law or agreed to in writing, software\n"");
-        cs.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");
-        cs.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");
-        cs.write(""* See the License for the specific language governing permissions and\n"");
-        cs.write(""* limitations under the License.\n"");
-        cs.write(""*/\n"");
-        cs.write(""\n"");
-        cs.write(""using System;\n"");
-        cs.write(""using Org.Apache.Jute;\n"");
-        cs.write(""\n"");        
-        cs.write(""namespace ""+getCsharpNameSpace()+""\n"");
-        cs.write(""{\n"");
-
-        String className = getCsharpName();
-        cs.write(""public class ""+className+"" : IRecord, IComparable \n"");
-        cs.write(""{\n"");
-        cs.write(""  public ""+ className +""() {\n"");
-        cs.write(""  }\n"");
-
-        cs.write(""  public ""+className+""(\n"");
-        int fIdx = 0;
-        int fLen = mFields.size();
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));
-            cs.write((fLen-1 == fIdx)?"""":"",\n"");
-        }
-        cs.write("") {\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));
-        }
-        cs.write(""  }\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            cs.write(jf.genCsharpGetSet(fIdx));
+
+        try (FileWriter cs = new FileWriter(new File(outputDirectory, getName() + "".cs""));) {
+            cs.write(""// File generated by hadoop record compiler. Do not edit.\n"");
+            cs.write(""/**\n"");
+            cs.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");
+            cs.write(""* or more contributor license agreements.  See the NOTICE file\n"");
+            cs.write(""* distributed with this work for additional information\n"");
+            cs.write(""* regarding copyright ownership.  The ASF licenses this file\n"");
+            cs.write(""* to you under the Apache License, Version 2.0 (the\n"");
+            cs.write(""* \""License\""); you may not use this file except in compliance\n"");
+            cs.write(""* with the License.  You may obtain a copy of the License at\n"");
+            cs.write(""*\n"");
+            cs.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");
+            cs.write(""*\n"");
+            cs.write(""* Unless required by applicable law or agreed to in writing, software\n"");
+            cs.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");
+            cs.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");
+            cs.write(""* See the License for the specific language governing permissions and\n"");
+            cs.write(""* limitations under the License.\n"");
+            cs.write(""*/\n"");
             cs.write(""\n"");
-        }
-        cs.write(""  public void Serialize(IOutputArchive a_, String tag) {\n"");
-        cs.write(""    a_.StartRecord(this,tag);\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            cs.write(jf.genCsharpWriteMethodName());
-        }
-        cs.write(""    a_.EndRecord(this,tag);\n"");
-        cs.write(""  }\n"");
+            cs.write(""using System;\n"");
+            cs.write(""using Org.Apache.Jute;\n"");
+            cs.write(""\n"");
+            cs.write(""namespace "" + getCsharpNameSpace() + ""\n"");
+            cs.write(""{\n"");
+
+            String className = getCsharpName();
+            cs.write(""public class "" + className + "" : IRecord, IComparable \n"");
+            cs.write(""{\n"");
+            cs.write(""  public "" + className + ""() {\n"");
+            cs.write(""  }\n"");
+
+            cs.write(""  public "" + className + ""(\n"");
+            int fIdx = 0;
+            int fLen = mFields.size();
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));
+                cs.write((fLen - 1 == fIdx) ? """" : "",\n"");
+            }
+            cs.write("") {\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));
+            }
+            cs.write(""  }\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                cs.write(jf.genCsharpGetSet(fIdx));
+                cs.write(""\n"");
+            }
+            cs.write(""  public void Serialize(IOutputArchive a_, String tag) {\n"");
+            cs.write(""    a_.StartRecord(this,tag);\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                cs.write(jf.genCsharpWriteMethodName());
+            }
+            cs.write(""    a_.EndRecord(this,tag);\n"");
+            cs.write(""  }\n"");
 
-        cs.write(""  public void Deserialize(IInputArchive a_, String tag) {\n"");
-        cs.write(""    a_.StartRecord(tag);\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            cs.write(jf.genCsharpReadMethodName());
-        }
-        cs.write(""    a_.EndRecord(tag);\n"");
-        cs.write(""}\n"");
-
-        cs.write(""  public override String ToString() {\n"");
-        cs.write(""    try {\n"");
-        cs.write(""      System.IO.MemoryStream ms = new System.IO.MemoryStream();\n"");
-        cs.write(""      MiscUtil.IO.EndianBinaryWriter writer =\n"");
-        cs.write(""        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);\n"");
-        cs.write(""      BinaryOutputArchive a_ = \n"");
-        cs.write(""        new BinaryOutputArchive(writer);\n"");
-        cs.write(""      a_.StartRecord(this,\""\"");\n"");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            cs.write(jf.genCsharpWriteMethodName());
-        }
-        cs.write(""      a_.EndRecord(this,\""\"");\n"");
-        cs.write(""      ms.Position = 0;\n"");
-        cs.write(""      return System.Text.Encoding.UTF8.GetString(ms.ToArray());\n"");
-        cs.write(""    } catch (Exception ex) {\n"");
-        cs.write(""      Console.WriteLine(ex.StackTrace);\n"");
-        cs.write(""    }\n"");
-        cs.write(""    return \""ERROR\"";\n"");
-        cs.write(""  }\n"");
-
-        cs.write(""  public void Write(MiscUtil.IO.EndianBinaryWriter writer) {\n"");
-        cs.write(""    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\n"");
-        cs.write(""    Serialize(archive, \""\"");\n"");
-        cs.write(""  }\n"");
-
-        cs.write(""  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) {\n"");
-        cs.write(""    BinaryInputArchive archive = new BinaryInputArchive(reader);\n"");
-        cs.write(""    Deserialize(archive, \""\"");\n"");
-        cs.write(""  }\n"");
-
-        cs.write(""  public int CompareTo (object peer_) {\n"");
-        boolean unimplemented = false;
-        for (JField f : mFields) {
-            if ((f.getType() instanceof JMap)
-                    || (f.getType() instanceof JVector))
-            {
-                unimplemented = true;
+            cs.write(""  public void Deserialize(IInputArchive a_, String tag) {\n"");
+            cs.write(""    a_.StartRecord(tag);\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                cs.write(jf.genCsharpReadMethodName());
             }
-        }
-        if (unimplemented) {
-            cs.write(""    throw new InvalidOperationException(\""comparing ""
-                    + getCsharpName() + "" is unimplemented\"");\n"");
-        } else {
-            cs.write(""    if (!(peer_ is ""+getCsharpName()+"")) {\n"");
-            cs.write(""      throw new InvalidOperationException(\""Comparing different types of records.\"");\n"");
+            cs.write(""    a_.EndRecord(tag);\n"");
+            cs.write(""}\n"");
+
+            cs.write(""  public override String ToString() {\n"");
+            cs.write(""    try {\n"");
+            cs.write(""      System.IO.MemoryStream ms = new System.IO.MemoryStream();\n"");
+            cs.write(""      MiscUtil.IO.EndianBinaryWriter writer =\n"");
+            cs.write(""        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);\n"");
+            cs.write(""      BinaryOutputArchive a_ = \n"");
+            cs.write(""        new BinaryOutputArchive(writer);\n"");
+            cs.write(""      a_.StartRecord(this,\""\"");\n"");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                cs.write(jf.genCsharpWriteMethodName());
+            }
+            cs.write(""      a_.EndRecord(this,\""\"");\n"");
+            cs.write(""      ms.Position = 0;\n"");
+            cs.write(""      return System.Text.Encoding.UTF8.GetString(ms.ToArray());\n"");
+            cs.write(""    } catch (Exception ex) {\n"");
+            cs.write(""      Console.WriteLine(ex.StackTrace);\n"");
             cs.write(""    }\n"");
-            cs.write(""    ""+getCsharpName()+"" peer = (""+getCsharpName()+"") peer_;\n"");
-            cs.write(""    int ret = 0;\n"");
+            cs.write(""    return \""ERROR\"";\n"");
+            cs.write(""  }\n"");
+
+            cs.write(""  public void Write(MiscUtil.IO.EndianBinaryWriter writer) {\n"");
+            cs.write(""    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\n"");
+            cs.write(""    Serialize(archive, \""\"");\n"");
+            cs.write(""  }\n"");
+
+            cs.write(""  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) {\n"");
+            cs.write(""    BinaryInputArchive archive = new BinaryInputArchive(reader);\n"");
+            cs.write(""    Deserialize(archive, \""\"");\n"");
+            cs.write(""  }\n"");
+
+            cs.write(""  public int CompareTo (object peer_) {\n"");
+            boolean unimplemented = false;
+            for (JField f : mFields) {
+                if ((f.getType() instanceof JMap)
+                        || (f.getType() instanceof JVector)) {
+                    unimplemented = true;
+                }
+            }
+            if (unimplemented) {
+                cs.write(""    throw new InvalidOperationException(\""comparing ""
+                        + getCsharpName() + "" is unimplemented\"");\n"");
+            } else {
+                cs.write(""    if (!(peer_ is "" + getCsharpName() + "")) {\n"");
+                cs.write(""      throw new InvalidOperationException(\""Comparing different types of records.\"");\n"");
+                cs.write(""    }\n"");
+                cs.write(""    "" + getCsharpName() + "" peer = ("" + getCsharpName() + "") peer_;\n"");
+                cs.write(""    int ret = 0;\n"");
+                for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                    JField jf = i.next();
+                    cs.write(jf.genCsharpCompareTo());
+                    cs.write(""    if (ret != 0) return ret;\n"");
+                }
+                cs.write(""     return ret;\n"");
+            }
+            cs.write(""  }\n"");
+
+            cs.write(""  public override bool Equals(object peer_) {\n"");
+            cs.write(""    if (!(peer_ is "" + getCsharpName() + "")) {\n"");
+            cs.write(""      return false;\n"");
+            cs.write(""    }\n"");
+            cs.write(""    if (peer_ == this) {\n"");
+            cs.write(""      return true;\n"");
+            cs.write(""    }\n"");
+            cs.write(""    bool ret = false;\n"");
+            cs.write(""    "" + getCsharpName() + "" peer = ("" + getCsharpName() + "")peer_;\n"");
             for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
                 JField jf = i.next();
-                cs.write(jf.genCsharpCompareTo());
-                cs.write(""    if (ret != 0) return ret;\n"");
+                cs.write(jf.genCsharpEquals());","[{'comment': ""What's the reason for changing to `genCsharpEquals`? I suppose is is the same reason for changing to `genJavaEquals`..."", 'commenter': 'fpj'}, {'comment': 'Similarly, there is no actual change here. ', 'commenter': 'hanm'}]"
118,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1322,23 +1322,55 @@ public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOE
             }
             return;
         } else if (h.getType() == OpCode.sasl) {
-            Record rsp = processSasl(incomingBuffer,cnxn);
-            ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());
-            cnxn.sendResponse(rh,rsp, ""response""); // not sure about 3rd arg..what is it?
-            return;
+            processSasl(incomingBuffer,cnxn, h);
         } else {
+          if (shouldRequireClientSaslAuth() && !hasCnxSASLAuthenticated(cnxn)) {
+            ReplyHeader replyHeader = new ReplyHeader(h.getXid(), 0,
+                Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue());
+            cnxn.sendResponse(replyHeader, null, ""response"");
+            cnxn.sendCloseSession();
+            cnxn.disableRecv();
+          } else {
             Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(),
-              h.getType(), incomingBuffer, cnxn.getAuthInfo());
+                h.getType(), incomingBuffer, cnxn.getAuthInfo());
             si.setOwner(ServerCnxn.me);
             // Always treat packet from the client as a possible
             // local request.
             setLocalSessionFlag(si);
             submitRequest(si);
-            return;
+          }
         }
     }
 
-    private Record processSasl(ByteBuffer incomingBuffer, ServerCnxn cnxn) throws IOException {
+  private boolean shouldAllowSaslFailedClientsConnect() {
+    String allowSaslFailedClients = System.getProperty(""zookeeper.allowSaslFailedClients"");
+    if (allowSaslFailedClients == null) {
+      return false;
+    } else {
+      return allowSaslFailedClients.equals(""true"");
+    }
+  }
+
+  private boolean shouldRequireClientSaslAuth() {
+    String sessionRequireClientSASLAuth = System.getProperty(""zookeeper.sessionRequireClientSASLAuth"");","[{'comment': 'Can we sample the system property only once? (At boot for instance).\r\nWe are not on the hot write/read path but reading system properties should be treated like a slow operation.\r\n\r\nNot a blocker', 'commenter': 'eolivelli'}, {'comment': 'The cost of caching properties is, we have to invent new variables to store these properties and sometimes, we need worry about cache coherence as the properties could be updated at runtime (mostly for unit test cases where we switch properties settings.). This will increase code complexity. The cost of accessing a property is negligible, so I prefer using simple code to access the properties. This is also consistent with existing code base where almost all properties are accessed without being cached.\r\n\r\nI do update the PR to use a simpler method to query the properties though.', 'commenter': 'hanm'}]"
118,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1322,23 +1322,55 @@ public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOE
             }
             return;
         } else if (h.getType() == OpCode.sasl) {
-            Record rsp = processSasl(incomingBuffer,cnxn);
-            ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());
-            cnxn.sendResponse(rh,rsp, ""response""); // not sure about 3rd arg..what is it?
-            return;
+            processSasl(incomingBuffer,cnxn, h);
         } else {
+          if (shouldRequireClientSaslAuth() && !hasCnxSASLAuthenticated(cnxn)) {
+            ReplyHeader replyHeader = new ReplyHeader(h.getXid(), 0,
+                Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue());
+            cnxn.sendResponse(replyHeader, null, ""response"");
+            cnxn.sendCloseSession();
+            cnxn.disableRecv();
+          } else {
             Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(),
-              h.getType(), incomingBuffer, cnxn.getAuthInfo());
+                h.getType(), incomingBuffer, cnxn.getAuthInfo());
             si.setOwner(ServerCnxn.me);
             // Always treat packet from the client as a possible
             // local request.
             setLocalSessionFlag(si);
             submitRequest(si);
-            return;
+          }
         }
     }
 
-    private Record processSasl(ByteBuffer incomingBuffer, ServerCnxn cnxn) throws IOException {
+  private boolean shouldAllowSaslFailedClientsConnect() {
+    String allowSaslFailedClients = System.getProperty(""zookeeper.allowSaslFailedClients"");
+    if (allowSaslFailedClients == null) {
+      return false;
+    } else {
+      return allowSaslFailedClients.equals(""true"");
+    }
+  }
+
+  private boolean shouldRequireClientSaslAuth() {
+    String sessionRequireClientSASLAuth = System.getProperty(""zookeeper.sessionRequireClientSASLAuth"");
+    if (sessionRequireClientSASLAuth == null) {
+      return false;
+    } else {
+      return sessionRequireClientSASLAuth.equals(""true"");
+    }
+  }
+
+  private boolean hasCnxSASLAuthenticated(ServerCnxn cnxn) {
+    for (Id id : cnxn.getAuthInfo()) {
+      if (id.getScheme().equals(""sasl"")) {","[{'comment': ""Do we have a constant for 'sasl'?"", 'commenter': 'eolivelli'}]"
118,zookeeper-server/src/test/java/org/apache/zookeeper/test/SaslAuthRequiredFailWrongSASLTest.java,"@@ -0,0 +1,53 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class SaslAuthRequiredFailWrongSASLTest extends ClientBase {
+  static {
+    System.setProperty(SaslTestUtil.requireSASLAuthProperty, ""true"");","[{'comment': ""Aren't we resetting these properties?\r\nWe should use BeforeClass and AfterClass to clean up"", 'commenter': 'eolivelli'}, {'comment': 'Updated.', 'commenter': 'hanm'}]"
118,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1361,27 +1393,39 @@ private Record processSasl(ByteBuffer incomingBuffer, ServerCnxn cnxn) throws IO
                         cnxn.addAuthInfo(new Id(""super"", """"));
                     }
                 }
-            }
-            catch (SaslException e) {
+            } catch (SaslException e) {
                 LOG.warn(""Client failed to SASL authenticate: "" + e, e);
-                if ((System.getProperty(""zookeeper.allowSaslFailedClients"") != null)
-                  &&
-                  (System.getProperty(""zookeeper.allowSaslFailedClients"").equals(""true""))) {
-                    LOG.warn(""Maintaining client connection despite SASL authentication failure."");
+                if (shouldAllowSaslFailedClientsConnect() && !shouldRequireClientSaslAuth()) {
+                  LOG.warn(""Maintaining client connection despite SASL authentication failure."");
                 } else {
+                  int error;
+                  if (shouldRequireClientSaslAuth()) {
+                    LOG.warn(""Closing client connection due to server requires client SASL authenticaiton,"" +
+                        ""but client SASL authentication has failed, or client is not configured with SASL "" +
+                        ""authentication."");
+                    error = Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue();
+                  } else {
                     LOG.warn(""Closing client connection due to SASL authentication failure."");
-                    cnxn.close();
+                    error = Code.AUTHFAILED.intValue();
+                  }
+
+                  ReplyHeader replyHeader = new ReplyHeader(requestHeader.getXid(), 0, error);
+                  cnxn.sendResponse(replyHeader, new SetSASLResponse(null), ""response"");
+                  cnxn.sendCloseSession();
+                  cnxn.disableRecv();
+                  return;
                 }
             }
-        }
-        catch (NullPointerException e) {
+        } catch (NullPointerException e) {","[{'comment': 'This was there before, but actually I think catch NullPointerException is really a code smell.\r\nDo you think we could drop this line and improve the code in the scope of this patch?\r\n', 'commenter': 'eolivelli'}, {'comment': ""I think this is out of scope of this patch, as this is existing code, and justifications of removing it requires more thoughts, as it's possible we have this exception if login failed (jaas file missing for example). "", 'commenter': 'hanm'}]"
118,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1322,23 +1325,45 @@ public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOE
             }
             return;
         } else if (h.getType() == OpCode.sasl) {
-            Record rsp = processSasl(incomingBuffer,cnxn);
-            ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());
-            cnxn.sendResponse(rh,rsp, ""response""); // not sure about 3rd arg..what is it?
-            return;
+            processSasl(incomingBuffer,cnxn, h);
         } else {
+          if (shouldRequireClientSaslAuth() && !hasCnxSASLAuthenticated(cnxn)) {
+            ReplyHeader replyHeader = new ReplyHeader(h.getXid(), 0,
+                Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue());
+            cnxn.sendResponse(replyHeader, null, ""response"");
+            cnxn.sendCloseSession();
+            cnxn.disableRecv();
+          } else {
             Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(),
-              h.getType(), incomingBuffer, cnxn.getAuthInfo());
+                h.getType(), incomingBuffer, cnxn.getAuthInfo());
             si.setOwner(ServerCnxn.me);
             // Always treat packet from the client as a possible
             // local request.
             setLocalSessionFlag(si);
             submitRequest(si);
-            return;
+          }
         }
     }
 
-    private Record processSasl(ByteBuffer incomingBuffer, ServerCnxn cnxn) throws IOException {
+  private boolean shouldAllowSaslFailedClientsConnect() {","[{'comment': 'Last nit: static', 'commenter': 'eolivelli'}]"
118,zookeeper-server/src/main/java/org/apache/zookeeper/client/ZooKeeperSaslClient.java,"@@ -128,6 +128,8 @@ public ZooKeeperSaslClient(final String serverPrincipal, ZKClientConfig clientCo
         try {
             entries = Configuration.getConfiguration()
                     .getAppConfigurationEntry(clientSection);
+            LOG.info(""fuck {}"", clientSection);","[{'comment': 'Drop the bad word please', 'commenter': 'eolivelli'}]"
118,zookeeper-server/src/main/java/org/apache/zookeeper/client/ZooKeeperSaslClient.java,"@@ -136,6 +138,8 @@ public ZooKeeperSaslClient(final String serverPrincipal, ZKClientConfig clientCo
             // configuration isn't set. We can reevaluate whether to catch RuntimeException instead when more 
             // different types of RuntimeException found
             runtimeException = e;
+        } catch (Exception e) {
+            LOG.info(""shit {}"", e);","[{'comment': 'Drop this debug and bad word', 'commenter': 'eolivelli'}]"
118,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1322,23 +1325,45 @@ public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOE
             }
             return;
         } else if (h.getType() == OpCode.sasl) {
-            Record rsp = processSasl(incomingBuffer,cnxn);
-            ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());
-            cnxn.sendResponse(rh,rsp, ""response""); // not sure about 3rd arg..what is it?
-            return;
+            processSasl(incomingBuffer,cnxn, h);
         } else {
+          if (shouldRequireClientSaslAuth() && !hasCnxSASLAuthenticated(cnxn)) {
+            ReplyHeader replyHeader = new ReplyHeader(h.getXid(), 0,
+                Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue());
+            cnxn.sendResponse(replyHeader, null, ""response"");
+            cnxn.sendCloseSession();
+            cnxn.disableRecv();
+          } else {
             Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(),
-              h.getType(), incomingBuffer, cnxn.getAuthInfo());
+                h.getType(), incomingBuffer, cnxn.getAuthInfo());
             si.setOwner(ServerCnxn.me);
             // Always treat packet from the client as a possible
             // local request.
             setLocalSessionFlag(si);
             submitRequest(si);
-            return;
+          }
         }
     }
 
-    private Record processSasl(ByteBuffer incomingBuffer, ServerCnxn cnxn) throws IOException {
+  private boolean shouldAllowSaslFailedClientsConnect() {
+    return Boolean.getBoolean(ALLOW_SASL_FAILED_CLIENTS);
+  }
+
+  private boolean shouldRequireClientSaslAuth() {","[{'comment': 'Last nit: static', 'commenter': 'eolivelli'}]"
118,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1361,27 +1386,39 @@ private Record processSasl(ByteBuffer incomingBuffer, ServerCnxn cnxn) throws IO
                         cnxn.addAuthInfo(new Id(""super"", """"));
                     }
                 }
-            }
-            catch (SaslException e) {
+            } catch (SaslException e) {
                 LOG.warn(""Client failed to SASL authenticate: "" + e, e);
-                if ((System.getProperty(""zookeeper.allowSaslFailedClients"") != null)
-                  &&
-                  (System.getProperty(""zookeeper.allowSaslFailedClients"").equals(""true""))) {
-                    LOG.warn(""Maintaining client connection despite SASL authentication failure."");
+                if (shouldAllowSaslFailedClientsConnect() && !shouldRequireClientSaslAuth()) {
+                  LOG.warn(""Maintaining client connection despite SASL authentication failure."");
                 } else {
+                  int error;
+                  if (shouldRequireClientSaslAuth()) {
+                    LOG.warn(""Closing client connection due to server requires client SASL authenticaiton,"" +","[{'comment': 'Is it possible to report at least the client ip address? This way it is simpler to correlate the errors.\r\nNot blocker for me, this class already has logs without references to the client. It could be a more global enhancement for the future', 'commenter': 'eolivelli'}]"
122,src/java/main/org/apache/zookeeper/ZooKeeper.java,"@@ -39,32 +39,10 @@
 import org.apache.zookeeper.client.ZKClientConfig;
 import org.apache.zookeeper.client.ZooKeeperSaslClient;
 import org.apache.zookeeper.common.PathUtils;
+import org.apache.zookeeper.common.StringUtils;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
-import org.apache.zookeeper.proto.CheckWatchesRequest;
-import org.apache.zookeeper.proto.Create2Response;
-import org.apache.zookeeper.proto.CreateRequest;
-import org.apache.zookeeper.proto.CreateResponse;
-import org.apache.zookeeper.proto.CreateTTLRequest;
-import org.apache.zookeeper.proto.DeleteRequest;
-import org.apache.zookeeper.proto.ExistsRequest;
-import org.apache.zookeeper.proto.GetACLRequest;
-import org.apache.zookeeper.proto.GetACLResponse;
-import org.apache.zookeeper.proto.GetChildren2Request;
-import org.apache.zookeeper.proto.GetChildren2Response;
-import org.apache.zookeeper.proto.GetChildrenRequest;
-import org.apache.zookeeper.proto.GetChildrenResponse;
-import org.apache.zookeeper.proto.GetDataRequest;
-import org.apache.zookeeper.proto.GetDataResponse;
-import org.apache.zookeeper.proto.RemoveWatchesRequest;
-import org.apache.zookeeper.proto.ReplyHeader;
-import org.apache.zookeeper.proto.RequestHeader;
-import org.apache.zookeeper.proto.SetACLRequest;
-import org.apache.zookeeper.proto.SetACLResponse;
-import org.apache.zookeeper.proto.SetDataRequest;
-import org.apache.zookeeper.proto.SetDataResponse;
-import org.apache.zookeeper.proto.SyncRequest;
-import org.apache.zookeeper.proto.SyncResponse;
+import org.apache.zookeeper.proto.*;","[{'comment': 'If I remember well, Patrick Hunt once told me during a code review that we should use explicit imports instead of wildcards. Right, @phunt ?', 'commenter': 'eribeiro'}, {'comment': 'fixed', 'commenter': 'Randgalt'}]"
122,src/java/main/org/apache/zookeeper/ZooKeeper.java,"@@ -2910,4 +2923,49 @@ private ClientCnxnSocket getClientCnxnSocket() throws IOException {
             throw ioe;
         }
     }
+
+    protected byte[] internalReconfig(String joiningServers, String leavingServers, String newMembers, long fromConfig, Stat stat) throws KeeperException, InterruptedException
+    {","[{'comment': 'nit: inconsistent brace style for method names from line onwards.', 'commenter': 'eribeiro'}, {'comment': 'fixed', 'commenter': 'Randgalt'}]"
122,src/docs/src/documentation/content/xdocs/zookeeperReconfig.xml,"@@ -300,6 +300,11 @@ server.3=125.23.63.25:2782:2785:participant</programlisting>
               from ZooKeeper class, and use of this API requires ACL setup and user
               authentication (see <xref linkend=""sc_reconfig_access_control""/> for more information.).
             </para>
+
+            <para>Note: for temporary backward compatibility, the reconfig() APIs will remain in ZooKeeper.java
+              where they were for a few alpha versions of 3.5.x. However, these APIs are deprecated and users
+              should move to the reconfig() APIs in ZooKeeperAdmin.java.","[{'comment': 'Small typo: `reconfig()` should be `reconfigure()`.', 'commenter': 'fpj'}]"
148,ivy.xml,"@@ -41,13 +41,20 @@
 
   <dependencies>
     <dependency org=""org.slf4j"" name=""slf4j-api"" rev=""1.7.5""/>
-    <dependency org=""org.slf4j"" name=""slf4j-log4j12"" rev=""1.7.5"" transitive=""false""/>
+    
+    <dependency org=""org.apache.logging.log4j"" name=""log4j-api"" rev=""2.7"" transitive=""false""/>
+    <dependency org=""org.apache.logging.log4j"" name=""log4j-core"" rev=""2.7"" transitive=""false""/>
+    <dependency org=""org.apache.logging.log4j"" name=""log4j-slf4j-impl"" rev=""2.7"" transitive=""false""/>
+
+    <!-- disruptor for Async loggers -->    
+    <dependency org=""com.lmax"" name=""disruptor"" rev=""3.3.0"" transitive=""false""/>","[{'comment': 'Why are you using an older version of disruptor?', 'commenter': 'jvz'}, {'comment': 'This is the version that log4j 2 uses itself, when you enable async logging.', 'commenter': 'revans2'}, {'comment': ""At first I read that it was version 3.0.0, sorry. Anyways, log4j 2 tends to stick with the latest versions of dependencies, so I'd recommend 3.3.6."", 'commenter': 'jvz'}]"
148,ivy.xml,"@@ -41,13 +41,20 @@
 
   <dependencies>
     <dependency org=""org.slf4j"" name=""slf4j-api"" rev=""1.7.5""/>
-    <dependency org=""org.slf4j"" name=""slf4j-log4j12"" rev=""1.7.5"" transitive=""false""/>
+    
+    <dependency org=""org.apache.logging.log4j"" name=""log4j-api"" rev=""2.7"" transitive=""false""/>
+    <dependency org=""org.apache.logging.log4j"" name=""log4j-core"" rev=""2.7"" transitive=""false""/>
+    <dependency org=""org.apache.logging.log4j"" name=""log4j-slf4j-impl"" rev=""2.7"" transitive=""false""/>
+
+    <!-- disruptor for Async loggers -->    
+    <dependency org=""com.lmax"" name=""disruptor"" rev=""3.3.0"" transitive=""false""/>
+    
     <dependency org=""commons-cli"" name=""commons-cli"" rev=""1.2"" />
   
     <dependency org=""org.apache.maven.wagon"" name=""wagon-http"" rev=""2.4"" conf=""mvn-ant-task->default""/>
     <dependency org=""org.apache.maven"" name=""maven-ant-tasks"" rev=""2.1.3"" conf=""mvn-ant-task->master""/>
     <!-- transitive false turns off dependency checking, log4j deps seem borked -->
-    <dependency org=""log4j"" name=""log4j"" rev=""1.2.17"" transitive=""false""/>
+    <!-- dependency org=""log4j"" name=""log4j"" rev=""1.2.17"" transitive=""false""/ -->","[{'comment': ""If anything is using log4j 1's API still, you'll need `log4j-1.2-api` as well."", 'commenter': 'jvz'}, {'comment': ""I don't think we should be using 'log4j 1' at all"", 'commenter': 'praste'}, {'comment': 'Agreed, just pointing out in case anything is still using the old API.', 'commenter': 'jvz'}]"
148,conf/log4j2.xml,"@@ -0,0 +1,56 @@
+<?xml version=""1.0"" encoding=""UTF-8"" ?>
+<!-- All loggers are Async if
+    -DLog4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector if is set -->
+<Configuration status=""warn"" strict=""true"">","[{'comment': ""Not sure why you're using strict mode here. You're not using the right XML elements for strict mode. See the [docs](http://logging.apache.org/log4j/2.x/manual/configuration.html#Strict_XML). It'd be simpler to just remove the strict attribute as it's not the same type of strict as JS or Perl, for example (it's mainly useful for XSD validation)."", 'commenter': 'jvz'}]"
148,conf/log4j2.xml,"@@ -0,0 +1,56 @@
+<?xml version=""1.0"" encoding=""UTF-8"" ?>
+<!-- All loggers are Async if
+    -DLog4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector if is set -->
+<Configuration status=""warn"" strict=""true"">
+  <Properties>
+    <Property name=""consoleLayoutPattern"">%d{ISO8601} [myid:%X{myid}] - %-5p [%t:%C{1}@%L] - %m%n</Property>","[{'comment': ""I'd generally advise against [enabling location information](http://logging.apache.org/log4j/2.x/manual/layouts.html#LocationInformation) by default due to performance issues. I personally don't find location information all that useful outside of caught exceptions anyways."", 'commenter': 'jvz'}, {'comment': 'I was trying to make sure that I can generate log4j2.xml configuration compatible with the current log4j.properties ', 'commenter': 'praste'}, {'comment': 'Ok, makes sense. Would be something good to note somewhere, though.', 'commenter': 'jvz'}]"
148,src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -618,23 +618,23 @@ server.3=zoo3:2888:3888</programlisting>
     <para>
         ZooKeeper uses <emphasis role=""bold""><ulink url=""http://www.slf4j.org"">SLF4J</ulink></emphasis>
         version 1.7.5 as its logging infrastructure. For backward compatibility it is bound to
-        <emphasis role=""bold"">LOG4J</emphasis> but you can use
-        <emphasis role=""bold""><ulink url=""http://logback.qos.ch/"">LOGBack</ulink></emphasis>
+        <emphasis role=""bold"">LOG4J2</emphasis> but you can use","[{'comment': ""This paragraph doesn't make much sense anymore."", 'commenter': 'jvz'}]"
148,src/docs/src/documentation/content/xdocs/zookeeperInternals.xml,"@@ -399,11 +399,11 @@ hierarchy of groups.
 <para>
 Zookeeper uses 
 <ulink url=""http://www.slf4j.org/index.html"">slf4j</ulink> as an abstraction layer for logging. 
-<ulink url=""http://logging.apache.org/log4j"">log4j</ulink> in version 1.2 is chosen as the final logging implementation for now.
+<ulink url=""http://logging.apache.org/log4j/2.x/"">log4j2</ulink> in version 2 is chosen as the final logging implementation for now.","[{'comment': ""Could you make this an https link? I've been trying to encourage the use of the https site."", 'commenter': 'jvz'}]"
148,src/docs/src/documentation/content/xdocs/zookeeperJMX.xml,"@@ -100,15 +100,15 @@
       started the server you will be able to monitor and manage various
       service related features.</para>
 
-    <para>Also note that ZooKeeper will register log4j MBeans as
+    <!--  <para>Also note that ZooKeeper will register log4j MBeans as","[{'comment': 'This paragraph can be updated with the [native JMX functionality in Log4j 2](https://logging.apache.org/log4j/2.x/manual/jmx.html).', 'commenter': 'jvz'}]"
148,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -413,13 +418,18 @@ public void testBadPeerAddressInQuorum() throws Exception {
         ClientBase.setupTestEnv();
 
         // setup the logger to capture all logs
+        LoggerContext loggerContext =  (LoggerContext) LogManager.getContext(false);","[{'comment': 'If this test is just storing log messages for verification at the end of the test, then I recommend using log4j-core:test\'s `LoggerContextRule` and `ListAppender`. Example: [LoggerTest](https://github.com/apache/logging-log4j2/blob/master/log4j-core/src/test/java/org/apache/logging/log4j/core/LoggerTest.java), [config.xml](https://github.com/apache/logging-log4j2/blob/master/log4j-core/src/test/resources/log4j-test2.xml) (see the `<List name=""foo""/>` appender configs). This way, the test won\'t break if internal details of log4j-core change.', 'commenter': 'jvz'}, {'comment': '@jvz Thanks for the suggestion, will look into it. ', 'commenter': 'praste'}, {'comment': 'I am not familiar with Ivy. any idea how to add  maven dependencies with tests qualifier in Ivy?', 'commenter': 'praste'}, {'comment': ""@jvz - I tried to update tests using the `ListAppender` but I don't think, it is the right way to verify the log messages. I observed that when I run all the tests in the `QuorumPeerMainTest` or `ReadOnlyModeTest`, tests fail. However, running \r\nfollowing test using `test.method=` option works fine \r\n`QuorumPeerMainTest. testInconsistentPeerType` \r\n`QuorumPeerMainTest. testQuorumDefaults`\r\n`QuorumPeerMainTest. testBadPeerAddressInQuorum`\r\n`ReadOnlyModeTest.testSeekForRwServer`\r\n\r\nNot sure what am I missing here.\r\n\r\nLet me know what you think."", 'commenter': 'praste'}, {'comment': '@jvz is using ListAppender absolutely necessary? \r\n\r\nCan we merge this with  current changes? ', 'commenter': 'praste'}, {'comment': 'Oh sorry, I meant to get back to you on this much sooner. You can merge without using it; just thought it would be a less hacky test.', 'commenter': 'jvz'}]"
148,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -413,13 +418,18 @@ public void testBadPeerAddressInQuorum() throws Exception {
         ClientBase.setupTestEnv();
 
         // setup the logger to capture all logs
+        LoggerContext loggerContext =  (LoggerContext) LogManager.getContext(false);
+        Configuration logConfig = loggerContext.getConfiguration();
+        
         Layout layout =
-                Logger.getRootLogger().getAppender(""CONSOLE"").getLayout();
+        		logConfig.getRootLogger().getAppenders().get(""STDOUT"").getLayout();
+        String appenderName = ""quorumAppender"";
         ByteArrayOutputStream os = new ByteArrayOutputStream();
-        WriterAppender appender = new WriterAppender(layout, os);
-        appender.setThreshold(Level.WARN);
-        Logger qlogger = Logger.getLogger(""org.apache.zookeeper.server.quorum"");
-        qlogger.addAppender(appender);
+        WriterAppender appender = WriterAppender.createAppender((StringLayout)layout, null, new OutputStreamWriter(os), appenderName, false, true);","[{'comment': ""It's probably a good idea to use the builder to create the appender:\r\n\r\n```\r\nWriterAppender.newBuilder().setLayout((StringLayout)layout).setTarget(new OutputStreamWriter(os)).setName(appenderName).build();\r\n```\r\n"", 'commenter': 'mikaelstaldal'}]"
148,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -470,16 +481,20 @@ public void testBadPeerAddressInQuorum() throws Exception {
     @Test
     public void testInconsistentPeerType() throws Exception {
         ClientBase.setupTestEnv();
-
-        // setup the logger to capture all logs
+        
+        LoggerContext loggerContext =  (LoggerContext) LogManager.getContext(false);
+        Configuration logConfig = loggerContext.getConfiguration();
+        
         Layout layout =
-                Logger.getRootLogger().getAppender(""CONSOLE"").getLayout();
+        		logConfig.getRootLogger().getAppenders().get(""STDOUT"").getLayout();
+        String appenderName = ""quorumAppender"";
         ByteArrayOutputStream os = new ByteArrayOutputStream();
-        WriterAppender appender = new WriterAppender(layout, os);
-        appender.setThreshold(Level.INFO);
-        Logger qlogger = Logger.getLogger(""org.apache.zookeeper.server.quorum"");
-        qlogger.addAppender(appender);
-
+        WriterAppender appender = WriterAppender.createAppender((StringLayout)layout, null, new OutputStreamWriter(os), appenderName, false, true);","[{'comment': ""It's probably a good idea to use the builder to create the appender (see above)."", 'commenter': 'mikaelstaldal'}]"
148,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -615,14 +631,18 @@ public void testQuorumDefaults() throws Exception {
         ClientBase.setupTestEnv();
 
         // setup the logger to capture all logs
+        LoggerContext loggerContext =  (LoggerContext) LogManager.getContext(false);
+        Configuration logConfig = loggerContext.getConfiguration();
+        
         Layout layout =
-                Logger.getRootLogger().getAppender(""CONSOLE"").getLayout();
+        		logConfig.getRootLogger().getAppenders().get(""STDOUT"").getLayout();
+        String appenderName = ""quorumAppender"";
         ByteArrayOutputStream os = new ByteArrayOutputStream();
-        WriterAppender appender = new WriterAppender(layout, os);
-        appender.setImmediateFlush(true);
-        appender.setThreshold(Level.INFO);
-        Logger zlogger = Logger.getLogger(""org.apache.zookeeper"");
-        zlogger.addAppender(appender);
+        WriterAppender appender = WriterAppender.createAppender((StringLayout)layout, null, new OutputStreamWriter(os), appenderName, false, true);","[{'comment': ""It's probably a good idea to use the builder to create the appender (see above)."", 'commenter': 'mikaelstaldal'}]"
148,src/java/test/org/apache/zookeeper/test/ReadOnlyModeTest.java,"@@ -251,14 +257,19 @@ public void testSessionEstablishment() throws Exception {
     @Test(timeout = 90000)
     public void testSeekForRwServer() throws Exception {
         // setup the logger to capture all logs
-        Layout layout = Logger.getRootLogger().getAppender(""CONSOLE"")
-                .getLayout();
+        LoggerContext loggerContext =  (LoggerContext) LogManager.getContext(false);
+        Configuration logConfig = loggerContext.getConfiguration();
+        
+        Layout layout =
+        		logConfig.getRootLogger().getAppenders().get(""STDOUT"").getLayout();
+        String appenderName = ""zkAppender"";
         ByteArrayOutputStream os = new ByteArrayOutputStream();
-        WriterAppender appender = new WriterAppender(layout, os);
-        appender.setImmediateFlush(true);
-        appender.setThreshold(Level.INFO);
-        Logger zlogger = Logger.getLogger(""org.apache.zookeeper"");
-        zlogger.addAppender(appender);
+        WriterAppender appender = WriterAppender.createAppender((StringLayout)layout, null, new OutputStreamWriter(os), appenderName, false, true);","[{'comment': ""It's probably a good idea to use the builder to create the appender (see above)."", 'commenter': 'mikaelstaldal'}]"
157,src/java/main/org/apache/zookeeper/server/quorum/Learner.java,"@@ -364,10 +367,12 @@ else if (qp.getType() == Leader.SNAP) {
             
             long lastQueued = 0;
 
-            // in V1.0 we take a snapshot when we get the NEWLEADER message, but in pre V1.0
+            // in Zab V1.0 (ZK 3.4+) we might take a snapshot when we get the NEWLEADER message, but in pre V1.0
             // we take the snapshot at the UPDATE, since V1.0 also gets the UPDATE (after the NEWLEADER)
             // we need to make sure that we don't take the snapshot twice.
-            boolean snapshotTaken = false;
+            boolean isPreZAB1_0 = true;
+            //If we are not going to take the snapshot be sure the edits are not applied in memory
+            boolean writeToEditLog = !snapshotNeeded;","[{'comment': ""The changes here are using `edit` to refer to `txns`. I'd rather use `txn` to be consistent across the project. Specifically here, you're using `EditLog` to refer to the `TxnLog`, please change accordingly to have it consistent across the project."", 'commenter': 'fpj'}, {'comment': 'Sorry about that I am still a bit new at the internal terminology.  I will update it.', 'commenter': 'revans2'}]"
157,src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java,"@@ -839,6 +839,13 @@ public void converseWithFollower(InputArchive ia, OutputArchive oa,
                     Assert.assertEquals(1, f.self.getAcceptedEpoch());
                     Assert.assertEquals(1, f.self.getCurrentEpoch());
                     
+                    //Wait for the edits to be written out","[{'comment': ""I need to think some more whether it makes any sense to add test cases for this. The test cases we already have probably cover this enough given that there is no real change of behavior.\r\n\r\nThis change here is necessary, though. We don't really care about time in general in our tests because we can never be sure of the timing we will get across runs and with different settings."", 'commenter': 'fpj'}]"
157,src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java,"@@ -839,12 +839,25 @@ public void converseWithFollower(InputArchive ia, OutputArchive oa,
                     Assert.assertEquals(1, f.self.getAcceptedEpoch());
                     Assert.assertEquals(1, f.self.getCurrentEpoch());
                     
+                    //Wait for the transactions to be written out. The thread that writes them out
+                    // does not send anything back when it is done.
+                    long start = System.currentTimeMillis();
+                    while (createSessionZxid != f.fzk.getLastProcessedZxid() && (System.currentTimeMillis() - start) < 50) {","[{'comment': 'just an idea, not sure if it is worth the effort and it may be outside the scope of this patch.\r\n\r\nwe could play with the test infrastructure here a little bit and do some dependency injection in `createFollower` that can let us track if db clearing and snapshotting occurs when expected.', 'commenter': 'afine'}, {'comment': 'It does seem a bit beyond the scope of this.  But if you really want me to I can look into it.', 'commenter': 'revans2'}, {'comment': 'it would be nice, a good way of actually validating everything is behaving as expected', 'commenter': 'afine'}, {'comment': 'OK Will see what I can do', 'commenter': 'revans2'}]"
157,src/java/main/org/apache/zookeeper/server/quorum/Learner.java,"@@ -321,13 +321,16 @@ protected void syncWithLeader(long newLeaderZxid) throws IOException, Interrupte
         QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);
         QuorumPacket qp = new QuorumPacket();
         long newEpoch = ZxidUtils.getEpochFromZxid(newLeaderZxid);
-        
-        readPacket(qp);   
+        //In the DIFF case we don't need to do a snapshot because the transactions will sync on top of any existing snapshot","[{'comment': 'nit: I think we generally put spaces after the //', 'commenter': 'afine'}]"
157,src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -507,9 +507,12 @@ public synchronized void shutdown() {
         if (firstProcessor != null) {
             firstProcessor.shutdown();
         }
-        if (zkDb != null) {
-            zkDb.clear();
-        }
+
+        // There is no need to clear the database
+        //  * When a new quorum is established we can still apply the diff
+        //    on top of the same zkDb data
+        //  * If we fetch a new snapshot from leader, the zkDb will be
+        //    cleared anyway before loading the snapshot
 ","[{'comment': ""There is one case we may still want to clear db here - when one of the ZooKeeper critical threads (such as * processors, session trackers) fail, ZooKeeper server will shutdown (see runFromConfig) and consequently invoke ZooKeeper#shutdown. In this case, I don't see a particular reason not to clear the db, though not doing it might be fine (as one could argue the server will be dead anyway), but I tend to lean towards the safe side on cleaning the db. One way to conditionally do that is to add a Boolean parameter to ZooKeeper#shutdown so we can have fine grained control over when to clear db in what code path."", 'commenter': 'hanm'}]"
182,src/docs/src/documentation/content/xdocs/zookeeperProgrammers.xml,"@@ -899,9 +899,12 @@
         single id, <emphasis>anyone</emphasis>, that represents
         anyone.</para></listitem>
 
-        <listitem><para><emphasis role=""bold"">auth</emphasis> doesn't
-        use any id, represents any authenticated
-        user.</para></listitem>
+        <listitem><para><emphasis role=""bold"">auth</emphasis> is a convenience
+        scheme which defaults to the currently-authenticated user and scheme.
+        Any ID which is provided using this scheme is ignored by ZooKeeper.","[{'comment': ""Thanks for the patch, it is a good improvement on doc.\r\n\r\nI think the ID here refers to the id of the scheme:id pair of the ID object in the ACL, correct? Mentioning this because the auth scheme is also referenced in command line where people can do 'setAcl /node auth:username:password:crdwa' in which case the username (sometimes overloaded as id) is required. \r\n"", 'commenter': 'hanm'}, {'comment': ""Thanks for taking a look, @hanm!\r\n\r\n> I think the ID here refers to the id of the scheme:id pair of the ID object in the ACL, correct?\r\n\r\nYup, that's what I was intending. Perhaps I should try to clarify that better :)\r\n\r\n> the auth scheme is also referenced in command line where people can do 'setAcl /node auth:username:password:crdwa' in which case the username (sometimes overloaded as id) is required.\r\n\r\nOK, that's a good point which I didn't realize. I would have expected that `auth:username:password:crdwa` would have resulted in ignoring `username:password`. Let me play with that to better understand it.."", 'commenter': 'joshelser'}]"
182,src/docs/src/documentation/content/xdocs/zookeeperProgrammers.xml,"@@ -841,9 +841,9 @@
     itself, ZooKeeper associates all the ids that correspond to a
     client with the clients connection. These ids are checked against
     the ACLs of znodes when a clients tries to access a node. ACLs are
-    made up of pairs of <emphasis>(scheme:expression,
+    made up of pairs of <emphasis>(scheme:id,","[{'comment': 'I\'m not sure if this is the best way to clarify here. As demonstrated below with the ip address example, the second field can be an ""expression"" that matches against ids. Although in the code we occasionally refer to the second term as an ""id"" (`ap.matches(authId.getId(), id.getId())` in `PrepRequestProcessor`) we do also refer to it as an ""expression"" in other places (`boolean matches(String id, String aclExpr)` in `AuthenticationProvider`).\r\n\r\nI think continuing to refer to the second term as an ""expression"" and explaining exactly what an ""expression"" is may be clearer.', 'commenter': 'afine'}, {'comment': '> I think continuing to refer to the second term as an ""expression"" and explaining exactly what an ""expression"" is may be clearer.\r\n\r\nOk, I can do that instead. I was trying to consolidate the use of ""id"" and ""expression"" in these different contexts to prevent more confusion (as you realized). Will try to come up with something better :)', 'commenter': 'joshelser'}, {'comment': 'Oh, I see. ID is meant to be the complete `scheme:expression`. Need more coffee...', 'commenter': 'joshelser'}]"
182,src/docs/src/documentation/content/xdocs/zookeeperProgrammers.xml,"@@ -899,9 +899,16 @@
         single id, <emphasis>anyone</emphasis>, that represents
         anyone.</para></listitem>
 
-        <listitem><para><emphasis role=""bold"">auth</emphasis> doesn't
-        use any id, represents any authenticated
-        user.</para></listitem>
+        <listitem><para><emphasis role=""bold"">auth</emphasis> is a special
+        scheme which ignores any provided ID and instead uses the current user,
+        credentials, and scheme. Any ID (whether, 'user' like with SASL","[{'comment': 'not sure the comma after whether is needed', 'commenter': 'afine'}, {'comment': 'Agreed :)', 'commenter': 'joshelser'}]"
182,src/docs/src/documentation/content/xdocs/zookeeperProgrammers.xml,"@@ -899,9 +899,16 @@
         single id, <emphasis>anyone</emphasis>, that represents
         anyone.</para></listitem>
 
-        <listitem><para><emphasis role=""bold"">auth</emphasis> doesn't
-        use any id, represents any authenticated
-        user.</para></listitem>
+        <listitem><para><emphasis role=""bold"">auth</emphasis> is a special
+        scheme which ignores any provided ID and instead uses the current user,
+        credentials, and scheme. Any ID (whether, 'user' like with SASL
+        authentication or 'user:password' like with DIGEST authentication) provided is ignored
+        by the ZooKeeper server when persisting the ACL. However, the ID must be
+        provided in the ACL because the ACL must match the form 'scheme:id:perms'.
+        This scheme is provided as a convenience as it is a common use-case for
+        a client to create a znode and then restrict access to that znode to only that client.","[{'comment': 'perhaps ""only that user"" would be clearer?', 'commenter': 'afine'}, {'comment': 'Avoiding the word ""user"" was intentional as a nod to some of the other auth schemes (e.g. the IP address one), but maybe that just creates more confusion than it\'s worth.', 'commenter': 'joshelser'}]"
189,src/docs/src/documentation/content/xdocs/zookeeperProgrammers.xml,"@@ -1714,7 +1714,115 @@ public abstract class ServerAuthenticationProvider implements AuthenticationProv
     <section id=""sc_connectingToZk"">
       <title>Connecting to ZooKeeper</title>
 
-      <para></para>
+      <para>Before we begin, you will have to set up a running Zookeeper server so that we can start developing the client. For C client bindings, we will be using the multithreaded library(zookeeper_mt) with a simple example written in C. To establish a connection with Zookeeper server, we make use of C API - <emphasis>zookeeper_init</emphasis> with the following signature:</para>
+
+      <programlisting><emphasis>int</emphasis> <emphasis>zookeeper_init</emphasis>(<emphasis>const</emphasis> <emphasis>char</emphasis> *host, watcher_fn fn, <emphasis>int</emphasis> recv_timeout, <emphasis>const</emphasis> clientid_t *clientid, <emphasis>void</emphasis> *context, <emphasis>int</emphasis> flags);</programlisting>
+
+      <variablelist>
+        <varlistentry>
+          <term>*host</term>
+            <listitem>
+              <para>Connection string to zookeeper server in the format of host:port. If there are multiple servers, use comma as separator after specifying the host:port pairs. Eg: ""127.0.0.1:2181,127.0.0.1:3001,127.0.0.1:3002""</para>
+            </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>fn</term>
+          <listitem>
+              <para>Watcher function to process events when a notification is triggered.</para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>recv_timeout</term>
+          <listitem>
+              <para>Session expiration time in milliseconds.</para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>*clientid</term>
+          <listitem>
+              <para>We can specify 0 for a new session. If a session has already establish previously, we could provide that client ID and it would reconnect to that previous session.</para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>*context</term>
+          <listitem>
+              <para>Context object that can be associated with the zkhandle_t handler. If it is not used, we can set it to 0.</para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>flags</term>
+          <listitem>
+              <para>In an initiation, we can leave it for 0.</para>
+          </listitem>
+        </varlistentry>
+      </variablelist>
+
+      <para>We will demonstrate client that outputs ""Connected to Zookeeper"" after successful connection or an error message otherwise. Let's call the following code <emphasis>zkClient.cc</emphasis> :</para>
+      <programlisting>
+#include &lt;stdio.h>
+#include &lt;zookeeper/zookeeper.h>
+#include &lt;errno.h>
+using namespace std;
+
+// Keeping track of the connection state
+static int connected = 0;
+static int expired   = 0;
+
+// *zkHandler handles the connection with Zookeeper
+static zhandle_t *zkHandler;
+
+// watcher function would process events
+void watcher(zhandle_t *zkH, int type, int state, const char *path, void *watcherCtx)
+{
+    if (type == ZOO_SESSION_EVENT) {
+
+        // state refers to states of zookeeper connection.
+        // To keep it simple, we would demonstrate these 3: ZOO_EXPIRED_SESSION_STATE, ZOO_CONNECTED_STATE, ZOO_NOTCONNECTED_STATE
+        // If you are using ACL, you should be aware of an authentication failure state - ZOO_AUTH_FAILED_STATE
+        if (state == ZOO_CONNECTED_STATE) {
+            connected = 1;
+        } else if (state == ZOO_NOTCONNECTED_STATE ) {
+            connected = 0;
+        } else if (state == ZOO_EXPIRED_SESSION_STATE) {
+            expired = 1;
+            connected = 0;
+            zookeeper_close(zkH);
+        }
+    }
+}
+
+int main(){
+    zoo_set_debug_level(ZOO_LOG_LEVEL_DEBUG);
+
+    // zookeeper_init returns the handler upon a successful connection, null otherwise
+    zkHandler = zookeeper_init(""localhost:2181"", watcher, 10000, 0, 0, 0);
+    
+    if (!zkHandler) {
+        return errno;
+    }else{
+        printf(""Connection established with Zookeeper. \n"");
+    }
+
+    // Close Zookeeper connection
+    zookeeper_close(zkHandler);
+
+    return 0;
+}
+      </programlisting>
+
+      <para>Compile the code with the multithreaded library mentioned before.</para>
+      <para><command>&gt; g++ -Iinclude/ zkClient.cpp -lzookeeper_mt -o Client</command></para>","[{'comment': 'can we use a c compiler for consistency?', 'commenter': 'afine'}, {'comment': 'Will change it to C compiler.', 'commenter': 'Unknown'}, {'comment': ""Btw, I tested the code, and zoo_init doesn't seem to validate the port number. Given an invalid hostname, the zkhandler wont initialize. But given a wrong port number, it'd still work. Should I report it as a bug? or just specify in the documentation that a valid zookeeper port should be given?"", 'commenter': 'Unknown'}, {'comment': 'I would file a JIRA for that so we can make the best decision there.', 'commenter': 'afine'}]"
191,src/java/test/org/apache/zookeeper/test/ClientBase.java,"@@ -96,24 +96,34 @@ public void process(WatchedEvent event) { /* nada */ }
     public static class CountdownWatcher implements Watcher {
         // XXX this doesn't need to be volatile! (Should probably be final)
         volatile CountDownLatch clientConnected;
+        // Set to true when connected to a read-only server, or a read-write (quorum) server.
         volatile boolean connected;
+        // Set to true when connected to a quorum server.
+        volatile boolean syncConnected;
 
         public CountdownWatcher() {
             reset();
         }
         synchronized public void reset() {
             clientConnected = new CountDownLatch(1);
             connected = false;
+            syncConnected = false;
         }
         synchronized public void process(WatchedEvent event) {
-            if (event.getState() == KeeperState.SyncConnected ||
-                event.getState() == KeeperState.ConnectedReadOnly) {
+            KeeperState state = event.getState();
+            if (state == KeeperState.SyncConnected) {
+                connected = true;
+                syncConnected = true;
+            } else if (state == KeeperState.ConnectedReadOnly) {
                 connected = true;","[{'comment': 'would there be value in setting syncConnected to false here?', 'commenter': 'afine'}, {'comment': 'watcher.reset should be called between two process calls so syncConnected should be false here, no need reset.', 'commenter': 'hanm'}, {'comment': 'but what if some event happens that causes the state to drop from syncconnected -> connectedreadonly during a test (before reset is ever called). If expecting a reset call was sufficient, we would not need the ""else"" clause in that if statement right?', 'commenter': 'afine'}, {'comment': 'yeah fair enough , fixing ...', 'commenter': 'hanm'}]"
205,src/java/main/org/apache/zookeeper/common/RateLimiter.java,"@@ -0,0 +1,99 @@
+/**
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* ""License""); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.apache.zookeeper.common;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A connection rate limiter.
+ *
+ */
+public interface RateLimiter {
+
+    /**
+     * If maxClientCnxnRate or maxClientCnxnBurst is set to this value, rate is
+     * not limited
+     */
+    public static int BYPASS = -1;","[{'comment': 'Fields in interfaces are implicitly public, static, and final. Declaring such keywords is redundant here', 'commenter': 'eribeiro'}]"
205,src/java/main/org/apache/zookeeper/common/RateLimiter.java,"@@ -0,0 +1,99 @@
+/**
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* ""License""); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.apache.zookeeper.common;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A connection rate limiter.
+ *
+ */
+public interface RateLimiter {
+
+    /**
+     * If maxClientCnxnRate or maxClientCnxnBurst is set to this value, rate is
+     * not limited
+     */
+    public static int BYPASS = -1;
+
+    /**
+     * A {@code RateLimiter} that does not do any rate limiting
+     */
+    public static RateLimiter BYPASS_RATE_LIMITER = new RateLimiter() {","[{'comment': 'As above, no need for public static modifiers.', 'commenter': 'eribeiro'}, {'comment': 'What abou to name this as NOOP_RATE_LIMITER? Bypass is a verb, right?', 'commenter': 'eribeiro'}]"
205,src/java/main/org/apache/zookeeper/common/RateLimiter.java,"@@ -0,0 +1,99 @@
+/**
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* ""License""); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.apache.zookeeper.common;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A connection rate limiter.
+ *
+ */
+public interface RateLimiter {
+
+    /**
+     * If maxClientCnxnRate or maxClientCnxnBurst is set to this value, rate is
+     * not limited
+     */
+    public static int BYPASS = -1;
+
+    /**
+     * A {@code RateLimiter} that does not do any rate limiting
+     */
+    public static RateLimiter BYPASS_RATE_LIMITER = new RateLimiter() {
+        @Override
+        public boolean tryAquire() {
+            return true;
+        }
+
+        @Override
+        public void configure(int maxClientCnxnRate, int maxClientCnxnBurst) {
+            //not needed","[{'comment': 'Nit: do nothing', 'commenter': 'eribeiro'}]"
205,src/java/main/org/apache/zookeeper/common/RateLimiter.java,"@@ -0,0 +1,99 @@
+/**
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* ""License""); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.apache.zookeeper.common;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A connection rate limiter.
+ *
+ */
+public interface RateLimiter {
+
+    /**
+     * If maxClientCnxnRate or maxClientCnxnBurst is set to this value, rate is
+     * not limited
+     */
+    public static int BYPASS = -1;
+
+    /**
+     * A {@code RateLimiter} that does not do any rate limiting
+     */
+    public static RateLimiter BYPASS_RATE_LIMITER = new RateLimiter() {
+        @Override
+        public boolean tryAquire() {
+            return true;
+        }
+
+        @Override
+        public void configure(int maxClientCnxnRate, int maxClientCnxnBurst) {
+            //not needed
+        }
+    };
+
+    /**
+     * Attempts to acquire a permit
+     *
+     * @return true if a permit was acquired, false otherwise
+     */
+    public boolean tryAquire();
+
+    /**
+     * @param maxClientCnxnRate the max client connection rate
+     * @param maxClientCnxnBurst the max client connection burst
+     */
+    public void configure(int maxClientCnxnRate, int maxClientCnxnBurst);
+
+    public static class Factory {
+
+        private static final Logger LOG = LoggerFactory.getLogger(RateLimiter.Factory.class);
+
+        /**
+         * Creates a {@code RateLimiter} with a stable average throughput of
+         * {@code averageRate} and a maximum burst size of {@code burstRate}
+         *
+         * @param rateLimiterImplClass the {@code RateLimiter} implementation to use","[{'comment': 'Please, specify that if this String is null then a TokenBucket will be chosen by default. By the way, I am not so sure if BYPASS_RATE_LIMITER would not be better in this case... :thinking:', 'commenter': 'eribeiro'}]"
205,src/java/test/org/apache/zookeeper/test/MaxCnxnRateTest.java,"@@ -0,0 +1,124 @@
+/**
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* ""License""); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.apache.zookeeper.test;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.ArrayList;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.zookeeper.common.TokenBucket;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
+import org.apache.zookeeper.test.MaxCnxnsTest.CnxnThread;
+import org.junit.Test;
+
+public class MaxCnxnRateTest extends ClientBase {
+
+    private int maxClientCnxnRate = 1;
+    private int maxClientCnxnBurst = 10;
+    private String host;
+    private int port;
+    static CountDownLatch startLatch;
+
+    @Override
+    public void startServer() throws Exception {
+        LOG.info(""STARTING server"");
+        maxCnxns = 1000;
+        String split[] = hostPort.split("":"");
+        host = split[0];
+        port = Integer.parseInt(split[1]);
+        QuorumPeerConfig.setRateLimiterImpl(TokenBucket.class.getName());
+        QuorumPeerConfig.setClientCnxnRate(maxClientCnxnRate);
+        QuorumPeerConfig.setClientCnxnBurst(maxClientCnxnBurst);
+        serverFactory = ServerCnxnFactory.createFactory(port, maxCnxns);
+        startServer(serverFactory);
+        startLatch = new CountDownLatch(1);
+    }
+
+    static class LatchedCnxnThread extends CnxnThread {
+
+        public LatchedCnxnThread(int i, String host, int port, AtomicInteger connectionCounter) {
+            super(i, host, port, connectionCounter);
+        }
+
+        @Override
+        public void run() {
+            try {
+                startLatch.await();
+                super.run();
+","[{'comment': 'Unnecessary blank line.', 'commenter': 'eribeiro'}]"
205,src/java/main/org/apache/zookeeper/common/TokenBucket.java,"@@ -0,0 +1,88 @@
+/**
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* ""License""); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package org.apache.zookeeper.common;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * Simple rate limiter based on a token bucket.
+  */
+public class TokenBucket implements RateLimiter {
+
+    // VisibleForTesting
+    long refreshPeriodNanos = TimeUnit.SECONDS.toNanos(1L);
+    // VisibleForTesting
+    volatile long nextRefillTime;
+    private AtomicLong tokens;
+    private long capacity;
+    private long tokensPerPeriod;
+
+    public TokenBucket() { }
+
+    // VisibleForTesting","[{'comment': 'Imo, it needs more api documentation, maybe a reference to a paper/book/wiki that explains the rationale behind this algorithm.', 'commenter': 'eribeiro'}]"
205,src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -607,9 +618,28 @@ public static ByteBuffer getDirectBuffer() {
     // sessionMap is used by closeSession()
     private final ConcurrentHashMap<Long, NIOServerCnxn> sessionMap =
         new ConcurrentHashMap<Long, NIOServerCnxn>();
-    // ipMap is used to limit connections per IP
-    private final ConcurrentHashMap<InetAddress, Set<NIOServerCnxn>> ipMap =
-        new ConcurrentHashMap<InetAddress, Set<NIOServerCnxn>>( );
+    // ipMap is used to limit connections and connection rate per IP
+    private final ConcurrentHashMap<InetAddress, IpCnxns> ipMap
+        = new ConcurrentHashMap<InetAddress, IpCnxns>();
+
+    // for each IP, we keep a RateLimiter to limit connection rate,
+    // as well as a set of connections to limit total number of connections
+    private static class IpCnxns {
+        private IpCnxns(RateLimiter rateLimiter) {
+            this.rateLimiter = rateLimiter;
+        }
+
+        // in general we will see 1 connection from each
+        // host, setting the initial cap to 2 allows us
+        // to minimize mem usage in the common case
+        // of 1 entry -- we need to set the initial cap
+        // to 2 to avoid rehash when the first entry is added
+        // Construct a ConcurrentHashSet using a ConcurrentHashMap
+        private Set<NIOServerCnxn> cnxnSet = Collections","[{'comment': 'We put the fields before the constructor here, so these fields should be moved up.', 'commenter': 'eribeiro'}, {'comment': 'Please, make cnxnSet final.', 'commenter': 'eribeiro'}]"
205,src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -607,9 +618,28 @@ public static ByteBuffer getDirectBuffer() {
     // sessionMap is used by closeSession()
     private final ConcurrentHashMap<Long, NIOServerCnxn> sessionMap =
         new ConcurrentHashMap<Long, NIOServerCnxn>();
-    // ipMap is used to limit connections per IP
-    private final ConcurrentHashMap<InetAddress, Set<NIOServerCnxn>> ipMap =
-        new ConcurrentHashMap<InetAddress, Set<NIOServerCnxn>>( );
+    // ipMap is used to limit connections and connection rate per IP
+    private final ConcurrentHashMap<InetAddress, IpCnxns> ipMap
+        = new ConcurrentHashMap<InetAddress, IpCnxns>();
+
+    // for each IP, we keep a RateLimiter to limit connection rate,
+    // as well as a set of connections to limit total number of connections
+    private static class IpCnxns {
+        private IpCnxns(RateLimiter rateLimiter) {
+            this.rateLimiter = rateLimiter;
+        }
+
+        // in general we will see 1 connection from each
+        // host, setting the initial cap to 2 allows us
+        // to minimize mem usage in the common case
+        // of 1 entry -- we need to set the initial cap
+        // to 2 to avoid rehash when the first entry is added
+        // Construct a ConcurrentHashSet using a ConcurrentHashMap
+        private Set<NIOServerCnxn> cnxnSet = Collections
+                .newSetFromMap(new ConcurrentHashMap<NIOServerCnxn, Boolean>(2));
+
+        private RateLimiter rateLimiter;","[{'comment': ""rateLimiter can be final, right? It doesn't change once passed to constructor."", 'commenter': 'eribeiro'}]"
205,src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java,"@@ -750,4 +761,46 @@ public static void setReconfigEnabled(boolean enabled) {
         reconfigEnabled = enabled;
     }
 
+    /**
+     * @return the {@code RateLimiter} to use
+     */
+    public static String getRateLimiterImpl() {","[{'comment': 'I am not so sure that creating a couple of static fields is the best approach here...', 'commenter': 'eribeiro'}]"
205,src/java/test/org/apache/zookeeper/test/MaxCnxnRateTest.java,"@@ -0,0 +1,124 @@
+/**
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* ""License""); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.apache.zookeeper.test;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.ArrayList;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.zookeeper.common.TokenBucket;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
+import org.apache.zookeeper.test.MaxCnxnsTest.CnxnThread;
+import org.junit.Test;
+
+public class MaxCnxnRateTest extends ClientBase {
+
+    private int maxClientCnxnRate = 1;
+    private int maxClientCnxnBurst = 10;
+    private String host;
+    private int port;
+    static CountDownLatch startLatch;
+
+    @Override
+    public void startServer() throws Exception {
+        LOG.info(""STARTING server"");
+        maxCnxns = 1000;
+        String split[] = hostPort.split("":"");
+        host = split[0];
+        port = Integer.parseInt(split[1]);
+        QuorumPeerConfig.setRateLimiterImpl(TokenBucket.class.getName());
+        QuorumPeerConfig.setClientCnxnRate(maxClientCnxnRate);
+        QuorumPeerConfig.setClientCnxnBurst(maxClientCnxnBurst);
+        serverFactory = ServerCnxnFactory.createFactory(port, maxCnxns);
+        startServer(serverFactory);
+        startLatch = new CountDownLatch(1);
+    }
+
+    static class LatchedCnxnThread extends CnxnThread {
+
+        public LatchedCnxnThread(int i, String host, int port, AtomicInteger connectionCounter) {
+            super(i, host, port, connectionCounter);
+        }
+
+        @Override
+        public void run() {
+            try {
+                startLatch.await();
+                super.run();
+
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    /**
+     * Creates more connection threads than our burst size.  All try to connect
+     * simultaneously.  Ensures that only the burst size succeeded.
+     */
+    @Test
+    public void testMaxCnxnBurst() throws InterruptedException {
+        AtomicInteger connectionCounter = new AtomicInteger(0);
+        ArrayList<LatchedCnxnThread> threads = new ArrayList<>(maxClientCnxnBurst+5);
+        for (int i = 0; i < maxClientCnxnBurst+5; i++) {
+            LatchedCnxnThread thread = new LatchedCnxnThread(i, host, port, connectionCounter);
+            thread.start();
+            threads.add(thread);
+        }
+
+        startLatch.countDown();
+
+        for (LatchedCnxnThread thread : threads) {
+            thread.join();
+        }
+        assertEquals(maxClientCnxnBurst, connectionCounter.get());
+    }
+
+    /**
+     * Creates connections in a tight loop, and ensures rate is limited
+     */
+    @Test
+    public void testMaxCnxnRate() throws InterruptedException {
+        AtomicInteger connectionCounter = new AtomicInteger(0);
+        int i = 0;
+        ArrayList<CnxnThread> threads = new ArrayList<>(300);","[{'comment': 'Nit: `List<CnxnThread> threads = ...`', 'commenter': 'eribeiro'}]"
205,src/java/test/org/apache/zookeeper/common/TokenBucketTest.java,"@@ -0,0 +1,180 @@
+/**
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* ""License""); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.apache.zookeeper.common;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.*;","[{'comment': 'IIRC, we prefer to use explicity imports instead of wildcards.', 'commenter': 'eribeiro'}]"
205,src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -39,6 +39,8 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.LinkedBlockingQueue;
 
+import org.apache.zookeeper.common.RateLimiter;","[{'comment': 'Where is the corresponding `NettyCnxnServerFactory`???', 'commenter': 'eribeiro'}, {'comment': '+1 to this', 'commenter': 'afine'}]"
205,src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -607,9 +618,28 @@ public static ByteBuffer getDirectBuffer() {
     // sessionMap is used by closeSession()
     private final ConcurrentHashMap<Long, NIOServerCnxn> sessionMap =
         new ConcurrentHashMap<Long, NIOServerCnxn>();
-    // ipMap is used to limit connections per IP
-    private final ConcurrentHashMap<InetAddress, Set<NIOServerCnxn>> ipMap =
-        new ConcurrentHashMap<InetAddress, Set<NIOServerCnxn>>( );
+    // ipMap is used to limit connections and connection rate per IP
+    private final ConcurrentHashMap<InetAddress, IpCnxns> ipMap
+        = new ConcurrentHashMap<InetAddress, IpCnxns>();
+
+    // for each IP, we keep a RateLimiter to limit connection rate,
+    // as well as a set of connections to limit total number of connections
+    private static class IpCnxns {","[{'comment': 'Eventually, we need to implement same logic for NettyServerCnxnFactory so better to up this class to ServerCnxnFactory or make it a top level class. The former is fine, imho.', 'commenter': 'eribeiro'}]"
205,src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -794,8 +825,9 @@ public boolean removeCnxn(NIOServerCnxn cnxn) {
 
         InetAddress addr = cnxn.getSocketAddress();
         if (addr != null) {
-            Set<NIOServerCnxn> set = ipMap.get(addr);
-            if (set != null) {
+            IpCnxns ipCnxns = ipMap.get(addr);
+            if (ipCnxns != null) {
+                Set<NIOServerCnxn> set = ipCnxns.cnxnSet;","[{'comment': 'Direct field access... I see ipCnxns is internal... But awkward yet. :smile:', 'commenter': 'eribeiro'}]"
205,src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -817,24 +849,23 @@ public void touchCnxn(NIOServerCnxn cnxn) {
 
     private void addCnxn(NIOServerCnxn cnxn) {
         InetAddress addr = cnxn.getSocketAddress();
-        Set<NIOServerCnxn> set = ipMap.get(addr);
-        if (set == null) {
-            // in general we will see 1 connection from each
-            // host, setting the initial cap to 2 allows us
-            // to minimize mem usage in the common case
-            // of 1 entry --  we need to set the initial cap
-            // to 2 to avoid rehash when the first entry is added
-            // Construct a ConcurrentHashSet using a ConcurrentHashMap
-            set = Collections.newSetFromMap(
-                new ConcurrentHashMap<NIOServerCnxn, Boolean>(2));
-            // Put the new set in the map, but only if another thread
+        IpCnxns ipCnxns = ipMap.get(addr);
+
+        if (ipCnxns == null) {
+            // create an IpCnxns which is a wrapper that holds a RateLimiter and
+            // a set of connections for each ip
+            RateLimiter rateLimiter = RateLimiter.Factory.create(
+                    QuorumPeerConfig.getRateLimiterImpl(), QuorumPeerConfig.getClientCnxnBurst(),
+                    QuorumPeerConfig.getClientCnxnRate());
+            ipCnxns = new IpCnxns(rateLimiter);
+            // Put the ip limiter/set in the map, but only if another thread
             // hasn't beaten us to it
-            Set<NIOServerCnxn> existingSet = ipMap.putIfAbsent(addr, set);
-            if (existingSet != null) {
-                set = existingSet;
+            IpCnxns existingIpCnxns = ipMap.putIfAbsent(addr, ipCnxns);
+            if (existingIpCnxns != null) {
+                ipCnxns = existingIpCnxns;
             }
         }
-        set.add(cnxn);
+        ipCnxns.cnxnSet.add(cnxn);
 ","[{'comment': 'Nit: direct field access... again. But no problem, tbh. ', 'commenter': 'eribeiro'}]"
205,src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -845,6 +845,40 @@ server.3=zoo3:2888:3888</programlisting>
            </varlistentry>
 
            <varlistentry>
+            <term>rateLimiterImpl</term>
+            <listitem>
+              <para>(No Java system property)</para>","[{'comment': 'Those params can be passed as System.properties. ;)', 'commenter': 'eribeiro'}]"
205,src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -845,6 +845,40 @@ server.3=zoo3:2888:3888</programlisting>
            </varlistentry>
 
            <varlistentry>
+            <term>rateLimiterImpl</term>
+            <listitem>
+              <para>(No Java system property)</para>
+
+              <para>Specifies an implementation of
+              org.apache.zookeeper.common.RateLimiter to use to limit the rate
+              at which a single client, identified by IP address, can make
+              connections to a single member of the ZooKeeper ensemble.</para>
+            </listitem>
+           </varlistentry>
+
+           <varlistentry>
+            <term>maxClientCnxnRate</term>
+            <listitem>
+              <para>(No Java system property)</para>","[{'comment': '`zookeeper.maxClientCnxnRate`', 'commenter': 'eribeiro'}]"
205,src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -607,9 +618,28 @@ public static ByteBuffer getDirectBuffer() {
     // sessionMap is used by closeSession()
     private final ConcurrentHashMap<Long, NIOServerCnxn> sessionMap =
         new ConcurrentHashMap<Long, NIOServerCnxn>();
-    // ipMap is used to limit connections per IP
-    private final ConcurrentHashMap<InetAddress, Set<NIOServerCnxn>> ipMap =
-        new ConcurrentHashMap<InetAddress, Set<NIOServerCnxn>>( );
+    // ipMap is used to limit connections and connection rate per IP
+    private final ConcurrentHashMap<InetAddress, IpCnxns> ipMap","[{'comment': 'If you are changing we can declare the field as `ConcurrentMap`.', 'commenter': 'eribeiro'}]"
205,src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -845,6 +845,40 @@ server.3=zoo3:2888:3888</programlisting>
            </varlistentry>
 
            <varlistentry>
+            <term>rateLimiterImpl</term>
+            <listitem>
+              <para>(No Java system property)</para>
+
+              <para>Specifies an implementation of
+              org.apache.zookeeper.common.RateLimiter to use to limit the rate
+              at which a single client, identified by IP address, can make
+              connections to a single member of the ZooKeeper ensemble.</para>
+            </listitem>
+           </varlistentry>
+
+           <varlistentry>
+            <term>maxClientCnxnRate</term>","[{'comment': 'Would it make sense to tie this configuration to the implementation that is being used, rather than specifying at the top level what configuration is needed for the rate limiter?', 'commenter': 'afine'}, {'comment': '+1 to this. :+1: ', 'commenter': 'eribeiro'}]"
205,src/java/main/org/apache/zookeeper/common/TokenBucket.java,"@@ -0,0 +1,88 @@
+/**
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* ""License""); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package org.apache.zookeeper.common;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * Simple rate limiter based on a token bucket.
+  */
+public class TokenBucket implements RateLimiter {
+
+    // VisibleForTesting
+    long refreshPeriodNanos = TimeUnit.SECONDS.toNanos(1L);
+    // VisibleForTesting
+    volatile long nextRefillTime;
+    private AtomicLong tokens;
+    private long capacity;
+    private long tokensPerPeriod;
+
+    public TokenBucket() { }
+
+    // VisibleForTesting
+    public TokenBucket(long capacity, long tokensPerSecond, long initialTokens) {
+        this.tokens = new AtomicLong(initialTokens);
+        this.capacity = Math.max(capacity, tokensPerSecond);
+        this.tokensPerPeriod = tokensPerSecond;
+        this.nextRefillTime = System.nanoTime() + refreshPeriodNanos;
+    }
+
+    @Override
+    public boolean tryAquire() {
+        refill();
+        long current = tokens.get();
+        while (current > 0) {
+            if (tokens.compareAndSet(current, current - 1)) {
+                return true;
+            }
+            current = tokens.get();
+        }
+        return false;
+    }
+
+    private void refill() {
+        long currentTime = System.nanoTime();
+        if (currentTime >= nextRefillTime) {
+            synchronized (this) {
+                if (currentTime >= nextRefillTime) {
+                    long elapsedNanos = currentTime - nextRefillTime + refreshPeriodNanos;
+                    long elapsedPeriods = elapsedNanos / refreshPeriodNanos;
+                    long newTokens = elapsedPeriods * tokensPerPeriod;
+                    tokens.set(Math.min(capacity, tokens.get() + newTokens));
+                    nextRefillTime = currentTime + refreshPeriodNanos - (elapsedNanos % refreshPeriodNanos);
+                }
+            }
+        }
+    }
+
+    // VisibleForTesting
+    long getTokenCount() {","[{'comment': 'nit: I think we generally prefer to explicitly state the access modifiers.', 'commenter': 'afine'}, {'comment': '+1.', 'commenter': 'eribeiro'}]"
205,src/java/main/org/apache/zookeeper/common/RateLimiter.java,"@@ -0,0 +1,99 @@
+/**
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* ""License""); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.apache.zookeeper.common;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A connection rate limiter.
+ *
+ */
+public interface RateLimiter {
+
+    /**
+     * If maxClientCnxnRate or maxClientCnxnBurst is set to this value, rate is
+     * not limited
+     */
+    public static int BYPASS = -1;
+
+    /**
+     * A {@code RateLimiter} that does not do any rate limiting
+     */
+    public static RateLimiter BYPASS_RATE_LIMITER = new RateLimiter() {
+        @Override
+        public boolean tryAquire() {
+            return true;
+        }
+
+        @Override
+        public void configure(int maxClientCnxnRate, int maxClientCnxnBurst) {
+            //not needed
+        }
+    };
+
+    /**
+     * Attempts to acquire a permit
+     *
+     * @return true if a permit was acquired, false otherwise
+     */
+    public boolean tryAquire();
+
+    /**
+     * @param maxClientCnxnRate the max client connection rate
+     * @param maxClientCnxnBurst the max client connection burst
+     */
+    public void configure(int maxClientCnxnRate, int maxClientCnxnBurst);
+
+    public static class Factory {
+
+        private static final Logger LOG = LoggerFactory.getLogger(RateLimiter.Factory.class);
+
+        /**
+         * Creates a {@code RateLimiter} with a stable average throughput of
+         * {@code averageRate} and a maximum burst size of {@code burstRate}
+         *
+         * @param rateLimiterImplClass the {@code RateLimiter} implementation to use
+         * @param burstSize
+         *            The maximum burst size - i.e. max number of permits that
+         *            can be acquired in a second
+         * @param averageRate
+         *            The stable average rate in permits per second
+         * @return the {@code RateLimiter}
+         */
+        public static RateLimiter create(String rateLimiterImplClass, int burstSize,
+                int averageRate) {
+            if (burstSize == BYPASS || averageRate == BYPASS) {
+                return BYPASS_RATE_LIMITER;
+            }
+            if (rateLimiterImplClass == null) {
+                rateLimiterImplClass = TokenBucket.class.getName();
+            }
+            try {
+                RateLimiter limiter = (RateLimiter) Class.forName(rateLimiterImplClass).newInstance();","[{'comment': 'it would be great to log which ratelimiter has been chosen', 'commenter': 'afine'}]"
205,src/java/main/org/apache/zookeeper/common/TokenBucket.java,"@@ -0,0 +1,88 @@
+/**
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* ""License""); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package org.apache.zookeeper.common;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * Simple rate limiter based on a token bucket.
+  */
+public class TokenBucket implements RateLimiter {
+
+    // VisibleForTesting
+    long refreshPeriodNanos = TimeUnit.SECONDS.toNanos(1L);
+    // VisibleForTesting
+    volatile long nextRefillTime;
+    private AtomicLong tokens;
+    private long capacity;
+    private long tokensPerPeriod;
+
+    public TokenBucket() { }
+
+    // VisibleForTesting
+    public TokenBucket(long capacity, long tokensPerSecond, long initialTokens) {
+        this.tokens = new AtomicLong(initialTokens);
+        this.capacity = Math.max(capacity, tokensPerSecond);
+        this.tokensPerPeriod = tokensPerSecond;
+        this.nextRefillTime = System.nanoTime() + refreshPeriodNanos;","[{'comment': 'nit: do we need nano seconds? can we just use org.apache.zookeeper.common.Time.currentElapsedTime() ?', 'commenter': 'afine'}]"
205,src/java/main/org/apache/zookeeper/common/TokenBucket.java,"@@ -0,0 +1,88 @@
+/**
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* ""License""); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package org.apache.zookeeper.common;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * Simple rate limiter based on a token bucket.
+  */
+public class TokenBucket implements RateLimiter {
+
+    // VisibleForTesting
+    long refreshPeriodNanos = TimeUnit.SECONDS.toNanos(1L);
+    // VisibleForTesting
+    volatile long nextRefillTime;
+    private AtomicLong tokens;
+    private long capacity;
+    private long tokensPerPeriod;
+
+    public TokenBucket() { }
+
+    // VisibleForTesting
+    public TokenBucket(long capacity, long tokensPerSecond, long initialTokens) {
+        this.tokens = new AtomicLong(initialTokens);
+        this.capacity = Math.max(capacity, tokensPerSecond);
+        this.tokensPerPeriod = tokensPerSecond;
+        this.nextRefillTime = System.nanoTime() + refreshPeriodNanos;
+    }
+
+    @Override
+    public boolean tryAquire() {","[{'comment': 'would things be easier if we just made this synchronized?', 'commenter': 'afine'}, {'comment': '+1.', 'commenter': 'eribeiro'}]"
227,src/java/main/org/apache/zookeeper/server/ConnectionBean.java,"@@ -21,15 +21,18 @@
 import java.net.Inet6Address;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
+import java.net.SocketAddress;
 import java.util.Arrays;
 
 import javax.management.ObjectName;
+import org.apache.zookeeper.common.SocketAddressUtils;
 
 import org.apache.zookeeper.common.Time;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.jmx.MBeanRegistry;
 import org.apache.zookeeper.jmx.ZKMBeanInfo;
+import org.jboss.netty.channel.local.LocalAddress;","[{'comment': 'unused import', 'commenter': 'afine'}]"
227,src/java/main/org/apache/zookeeper/common/SocketAddressUtils.java,"@@ -0,0 +1,97 @@
+/* Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.common;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.data.Id;","[{'comment': 'unused imports', 'commenter': 'afine'}]"
227,src/java/main/org/apache/zookeeper/common/SocketAddressUtils.java,"@@ -0,0 +1,97 @@
+/* Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.common;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.data.Id;
+import org.jboss.netty.channel.local.LocalAddress;
+
+public class SocketAddressUtils {
+
+    public static InetAddress getInetAddress(SocketAddress socketAddress) {
+        if (socketAddress instanceof InetSocketAddress) {
+            return ((InetSocketAddress) socketAddress).getAddress();
+        } else if (socketAddress instanceof LocalAddress) {
+            return InetAddress.getLoopbackAddress();
+        } else {
+            throw new IllegalArgumentException(""Unexpected address type "" + socketAddress.getClass().getName() + "": "" + socketAddress.toString());
+        }
+    }
+
+    public static LocalAddress mapToLocalAddress(InetSocketAddress socketAddress) {
+        if (socketAddress.getAddress().getHostAddress().equals(""0.0.0.0"")) {
+            return new LocalAddress(InetAddress.getLoopbackAddress().getHostAddress() + "":"" + socketAddress.getPort());
+        } else {
+            return new LocalAddress(socketAddress.getAddress().getHostAddress() + "":"" + socketAddress.getPort());
+        }
+    }
+
+    public static int getPort(SocketAddress socketAddress) {
+        if (socketAddress instanceof InetSocketAddress) {
+            return ((InetSocketAddress) socketAddress).getPort();
+        } else if (socketAddress instanceof LocalAddress) {
+            LocalAddress local = (LocalAddress) socketAddress;
+            String id = local.getId();
+            try {
+                int colon = id.lastIndexOf(':');
+                return Integer.parseInt(id.substring(colon + 1));
+            } catch (NumberFormatException | IndexOutOfBoundsException err) {
+                throw new IllegalArgumentException(""Unexpected local address "" + id);
+            }
+        } else {
+            throw new IllegalArgumentException(""Unexpected address type "" + socketAddress.getClass().getName() + "": "" + socketAddress.toString());
+        }
+    }
+
+    public static String getHostString(SocketAddress socketAddress) {
+        if (socketAddress instanceof InetSocketAddress) {
+            return ((InetSocketAddress) socketAddress).getHostString();
+        } else if (socketAddress instanceof LocalAddress) {
+            LocalAddress local = (LocalAddress) socketAddress;
+            String id = local.getId();
+            try {
+                int colon = id.lastIndexOf(':');
+                return id.substring(0, colon);
+            } catch (IndexOutOfBoundsException err) {
+                throw new IllegalArgumentException(""Unexpected local address "" + id);
+            }
+        } else {
+            throw new IllegalArgumentException(""Unexpected address type "" + socketAddress.getClass().getName() + "": "" + socketAddress.toString());
+        }
+    }
+
+    public static String getHostAddress(SocketAddress socketAddress) {
+
+        if (socketAddress instanceof InetSocketAddress) {
+            return ((InetSocketAddress) socketAddress).getAddress().getHostAddress();
+        } else if (socketAddress instanceof LocalAddress) {
+            LocalAddress local = (LocalAddress) socketAddress;","[{'comment': 'this code seems to be shared with getHostString, is there a way that duplication can be reduced?', 'commenter': 'afine'}]"
227,src/java/main/org/apache/zookeeper/server/ConnectionBean.java,"@@ -69,12 +72,17 @@ public String getSessionId() {
     }
 
     public String getSourceIP() {
-        InetSocketAddress sockAddr = connection.getRemoteSocketAddress();
+        SocketAddress sockAddr = connection.getRemoteSocketAddress();
         if (sockAddr == null) {","[{'comment': 'i believe instanceof can be safely used with null, so you can just remove this if statement', 'commenter': 'afine'}]"
227,src/java/test/org/apache/zookeeper/test/NettyLocalChannelSuiteBase.java,"@@ -0,0 +1,136 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.test;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+
+import org.apache.zookeeper.ClientCnxnSocketNetty;
+import org.apache.zookeeper.client.ZKClientConfig;
+import org.apache.zookeeper.common.SocketAddressUtils;
+import org.apache.zookeeper.server.NettyServerCnxnFactory;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.jboss.netty.bootstrap.ClientBootstrap;
+import org.jboss.netty.bootstrap.ServerBootstrap;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFactory;
+import org.jboss.netty.channel.ChannelFuture;
+import org.jboss.netty.channel.ServerChannelFactory;","[{'comment': 'unused import', 'commenter': 'afine'}]"
227,src/java/test/org/apache/zookeeper/test/NettyLocalSuiteTest.java,"@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.test;
+
+import org.junit.runners.Suite;
+
+/**
+ * Run tests with: Netty Client against Netty server
+ */
+@Suite.SuiteClasses({","[{'comment': 'it seems like it can get tedious to track which tests are running with local channels. Can we turn this functionality on and off across the entire suite with a command line arg when starting the tests?', 'commenter': 'afine'}, {'comment': '@afine Thank you for your review.\r\nI have addressed most of your comments (fix imports, duplicate code...)\r\n\r\nRegarding the tests, \r\nIt will be interesting in order to see that all the code can run cleanly without network.\r\nBut IMHO a new system property/run time flag will add the need to run always twice the full suite at every build/release.\r\nI have added the least possible testcases to cover basic features so that future refactor will not drop the ability to use the Local Transport.\r\nAt this moment I think it is not the time to add an official ""local transport"" netty connection factory.\r\n\r\n\r\nRegarding server-to-server communications:\r\nI can\'t find how to enable Netty for server-to-server communications, I will dig deeply into the code. It seems that the Learner class uses directly a Socket, so it is not possible to leverage Netty local transport feature. ', 'commenter': 'eolivelli'}, {'comment': '> But IMHO a new system property/run time flag will add the need to run always twice the full suite at every build/release.\r\n\r\nMaybe. We have a good degree of flakyness in our testing and wondering if using this type of change for our precommit  hook will increase performance and stability (especially if we can use something similar for server<->server).\r\n\r\n> At this moment I think it is not the time to add an official ""local transport"" netty connection factory.\r\n\r\nAgreed.\r\n\r\n> I can\'t find how to enable Netty for server-to-server communications\r\n\r\nIt is currently not possible. All communications there are handled by old fashioned sockets.  I was incorrect in my other comment, although I still think my point is valid. Is there a way to have similar functionality with old fashioned java sockets? I don\'t think this change makes too much sense for testing unless we can take zk off the OS network stack entirely.', 'commenter': 'afine'}, {'comment': ""@afine I'm sorry it is not possible for old style sockets. We should provide  a full custom SocketImpl.\r\n\r\nThis change will help testing apps which use ZooKeeper and usually launch only a single node embedded ZK server inside the JVM which is running the unit test.\r\n\r\nI think that a switch to Netty for the server-to-server communications will be a good enhancement for the future. I saw recent work about SSL on server-to-server, using Netty it would have been very simple.\r\n\r\nI can create a JIRA for Netty on server-to-server, eventually I can work on a proposal in the near future"", 'commenter': 'eolivelli'}, {'comment': 'That makes sense. +1', 'commenter': 'afine'}, {'comment': '@afine  Thank you for your review\r\n\r\nis this patch ready for merge ?\r\ncan you push it to the 3.5 branch too ?', 'commenter': 'eolivelli'}, {'comment': 'tagging @arshadmohammad @hanm  for review/merge\r\n\r\n@Randgalt do you think this new feature would be useful for Curator and for local testing of apps which use ZooKeeper ?', 'commenter': 'eolivelli'}, {'comment': 'Ping', 'commenter': 'eolivelli'}]"
234,src/contrib/cppclient/DelegatingSessionEventWatcher.h,"@@ -0,0 +1,151 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <folly/Synchronized.h>
+#include <list>
+#include <mutex>
+#include ""zeus/client/ZookeeperClient.h""","[{'comment': 'Include here should be just ""ZookeeperClient.h"" (and there are a couple of other places that involves zeus/client includes), since there is no zeus folder included as part of this pr.', 'commenter': 'hanm'}]"
234,src/contrib/cppclient/detail/BasicZookeeperClient.cpp,"@@ -0,0 +1,1112 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include ""zeus/client/detail/BasicZookeeperClient.h""
+#include <cstring>
+
+namespace facebook {
+namespace zeus {
+namespace client {
+namespace detail {
+
+std::string BasicZookeeperClient::buildConnectionString(
+    const std::vector<folly::SocketAddress>& servers,
+    const std::string& chroot) {
+  std::vector<std::string> hostPorts;
+  for (const auto& server : servers) {
+    hostPorts.push_back(folly::to<std::string>(
+        server.getIPAddress().toFullyQualified(), ':', server.getPort()));
+  }
+  return folly::join(',', hostPorts) + chroot;
+}
+
+Stat BasicZookeeperClient::convertStat(const ::Stat& s) {
+  return Stat{s.czxid,
+              s.mzxid,
+              std::chrono::system_clock::time_point() +
+                  std::chrono::milliseconds(s.ctime),
+              std::chrono::system_clock::time_point() +
+                  std::chrono::milliseconds(s.mtime),
+              s.version,
+              s.cversion,
+              s.aversion,
+              s.ephemeralOwner,
+              s.dataLength,
+              s.numChildren,
+              s.pzxid};
+}
+
+int BasicZookeeperClient::convertCreateMode(const CreateMode& m) {
+  int flags = 0;
+  if (m.isEphemeral) {
+    flags |= ZOO_EPHEMERAL;
+  }
+  if (m.isSequential) {
+    flags |= ZOO_SEQUENCE;
+  }
+  return flags;
+}
+
+SessionState BasicZookeeperClient::convertStateType(int state) {
+  if (state == ZOO_EXPIRED_SESSION_STATE) {
+    return SessionState::EXPIRED;
+  } else if (state == ZOO_AUTH_FAILED_STATE) {
+    return SessionState::AUTH_FAILED;
+  } else if (state == ZOO_CONNECTING_STATE) {
+    return SessionState::CONNECTING;
+  } else if (state == ZOO_ASSOCIATING_STATE) {
+    return SessionState::ASSOCIATING;
+  } else if (state == ZOO_CONNECTED_STATE) {
+    return SessionState::CONNECTED;
+  } else if (state == 0 || state == ZOO_NOTCONNECTED_STATE) {
+    return SessionState::DISCONNECTED;
+  } else if (state == ZOO_TIMED_OUT_STATE) {
+    return SessionState::TIMED_OUT;
+  } else {
+    throw std::runtime_error(
+        folly::to<std::string>(""unrecognized ZK state "", state));
+  }
+}
+
+NodeEvent BasicZookeeperClient::convertWatchEventType(
+    const char* path,
+    int inType,
+    int inState,
+    size_t index) {
+  WatchEventType type;
+  if (inType == ZOO_CREATED_EVENT) {
+    type = WatchEventType::CREATED;
+  } else if (inType == ZOO_DELETED_EVENT) {
+    type = WatchEventType::DELETED;
+  } else if (inType == ZOO_CHANGED_EVENT) {
+    type = WatchEventType::CHANGED;
+  } else if (inType == ZOO_CHILD_EVENT) {
+    type = WatchEventType::CHILD;
+  } else if (inType == ZOO_SESSION_EVENT) {
+    type = WatchEventType::SESSION;
+  } else if (inType == ZOO_NOTWATCHING_EVENT) {
+    type = WatchEventType::NOT_WATCHING;
+  } else {
+    throw std::runtime_error(
+        folly::to<std::string>(""unexpected watch event type "", inType));
+  }
+
+  return NodeEvent{index, path, type, convertStateType(inState)};
+}
+
+BasicZookeeperClient::BasicZookeeperClient(
+    const std::string& connectionString,
+    std::chrono::milliseconds sessionTimeout,
+    const SessionToken* token,
+    InitialWatches&& initialWatches)
+    : initialWatches_(std::move(initialWatches)) {
+  std::vector<const char*> dataWatchPaths;
+  for (const auto& dataWatchPath : initialWatches_.getDataWatchPaths()) {
+    dataWatchPaths.push_back(dataWatchPath.c_str());
+  }
+  std::vector<const char*> childWatchPaths;
+  for (const auto& childWatchPath : initialWatches_.getChildWatchPaths()) {
+    childWatchPaths.push_back(childWatchPath.c_str());
+  }
+
+  std::unique_ptr<::clientid_t> clientid;
+  if (token) {
+    clientid = std::make_unique<::clientid_t>();
+    clientid->client_id = token->sessionId;
+    memcpy(clientid->passwd, token->passwd.data(), 16);
+  }
+
+  folly::SharedMutex::WriteHolder g(zhLock_);
+  zh_ = zookeeper_init_with_watches(","[{'comment': 'This function does exist in the open source C client.', 'commenter': 'packysauce'}]"
234,src/contrib/cppclient/detail/BasicZookeeperClient.h,"@@ -0,0 +1,486 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <zookeeper/zookeeper.h>
+#include <forward_list>
+#include <mutex>
+#include <unordered_map>
+#include ""zeus/client/ZookeeperClient.h""
+#include ""zeus/client/detail/InitialWatches.h""","[{'comment': 'File not included.', 'commenter': 'packysauce'}]"
234,src/contrib/cppclient/detail/BasicZookeeperClient.cpp,"@@ -0,0 +1,1112 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include ""zeus/client/detail/BasicZookeeperClient.h""
+#include <cstring>
+
+namespace facebook {
+namespace zeus {
+namespace client {
+namespace detail {
+
+std::string BasicZookeeperClient::buildConnectionString(
+    const std::vector<folly::SocketAddress>& servers,
+    const std::string& chroot) {
+  std::vector<std::string> hostPorts;
+  for (const auto& server : servers) {
+    hostPorts.push_back(folly::to<std::string>(
+        server.getIPAddress().toFullyQualified(), ':', server.getPort()));
+  }
+  return folly::join(',', hostPorts) + chroot;
+}
+
+Stat BasicZookeeperClient::convertStat(const ::Stat& s) {
+  return Stat{s.czxid,
+              s.mzxid,
+              std::chrono::system_clock::time_point() +
+                  std::chrono::milliseconds(s.ctime),
+              std::chrono::system_clock::time_point() +
+                  std::chrono::milliseconds(s.mtime),
+              s.version,
+              s.cversion,
+              s.aversion,
+              s.ephemeralOwner,
+              s.dataLength,
+              s.numChildren,
+              s.pzxid};
+}
+
+int BasicZookeeperClient::convertCreateMode(const CreateMode& m) {
+  int flags = 0;
+  if (m.isEphemeral) {
+    flags |= ZOO_EPHEMERAL;
+  }
+  if (m.isSequential) {
+    flags |= ZOO_SEQUENCE;
+  }
+  return flags;
+}
+
+SessionState BasicZookeeperClient::convertStateType(int state) {
+  if (state == ZOO_EXPIRED_SESSION_STATE) {
+    return SessionState::EXPIRED;
+  } else if (state == ZOO_AUTH_FAILED_STATE) {
+    return SessionState::AUTH_FAILED;
+  } else if (state == ZOO_CONNECTING_STATE) {
+    return SessionState::CONNECTING;
+  } else if (state == ZOO_ASSOCIATING_STATE) {
+    return SessionState::ASSOCIATING;
+  } else if (state == ZOO_CONNECTED_STATE) {
+    return SessionState::CONNECTED;
+  } else if (state == 0 || state == ZOO_NOTCONNECTED_STATE) {
+    return SessionState::DISCONNECTED;
+  } else if (state == ZOO_TIMED_OUT_STATE) {
+    return SessionState::TIMED_OUT;
+  } else {
+    throw std::runtime_error(
+        folly::to<std::string>(""unrecognized ZK state "", state));
+  }
+}
+
+NodeEvent BasicZookeeperClient::convertWatchEventType(
+    const char* path,
+    int inType,
+    int inState,
+    size_t index) {
+  WatchEventType type;
+  if (inType == ZOO_CREATED_EVENT) {
+    type = WatchEventType::CREATED;
+  } else if (inType == ZOO_DELETED_EVENT) {
+    type = WatchEventType::DELETED;
+  } else if (inType == ZOO_CHANGED_EVENT) {
+    type = WatchEventType::CHANGED;
+  } else if (inType == ZOO_CHILD_EVENT) {
+    type = WatchEventType::CHILD;
+  } else if (inType == ZOO_SESSION_EVENT) {
+    type = WatchEventType::SESSION;
+  } else if (inType == ZOO_NOTWATCHING_EVENT) {
+    type = WatchEventType::NOT_WATCHING;
+  } else {
+    throw std::runtime_error(
+        folly::to<std::string>(""unexpected watch event type "", inType));
+  }
+
+  return NodeEvent{index, path, type, convertStateType(inState)};
+}
+
+BasicZookeeperClient::BasicZookeeperClient(
+    const std::string& connectionString,
+    std::chrono::milliseconds sessionTimeout,
+    const SessionToken* token,
+    InitialWatches&& initialWatches)
+    : initialWatches_(std::move(initialWatches)) {
+  std::vector<const char*> dataWatchPaths;
+  for (const auto& dataWatchPath : initialWatches_.getDataWatchPaths()) {
+    dataWatchPaths.push_back(dataWatchPath.c_str());
+  }
+  std::vector<const char*> childWatchPaths;
+  for (const auto& childWatchPath : initialWatches_.getChildWatchPaths()) {
+    childWatchPaths.push_back(childWatchPath.c_str());
+  }
+
+  std::unique_ptr<::clientid_t> clientid;
+  if (token) {
+    clientid = std::make_unique<::clientid_t>();
+    clientid->client_id = token->sessionId;
+    memcpy(clientid->passwd, token->passwd.data(), 16);
+  }
+
+  folly::SharedMutex::WriteHolder g(zhLock_);
+  zh_ = zookeeper_init_with_watches(
+      connectionString.c_str(),
+      sSessionWatchCallback,
+      sessionTimeout.count(),
+      clientid.get(),
+      this,
+      1,
+      0,
+      dataWatchPaths.size(),
+      dataWatchPaths.empty() ? nullptr : dataWatchPaths.data(),
+      childWatchPaths.size(),
+      childWatchPaths.empty() ? nullptr : childWatchPaths.data(),
+      initialWatches_.getLastZxid());
+  if (zh_ == nullptr) {
+    throw ZookeeperSystemErrorException();
+  }
+}
+
+BasicZookeeperClient::BasicZookeeperClient(
+    const std::vector<folly::SocketAddress>& servers,
+    const std::string& chroot,
+    std::chrono::milliseconds sessionTimeout,
+    const SessionToken* token,
+    InitialWatches&& iw)
+    : BasicZookeeperClient(
+          buildConnectionString(servers, chroot),
+          sessionTimeout,
+          token,
+          std::move(iw)) {}
+
+BasicZookeeperClient::~BasicZookeeperClient() {
+  folly::SharedMutex::WriteHolder g(zhLock_);
+  if (zh_ != nullptr) {
+    int rc = zookeeper_close(zh_);
+    if (rc != ZOK) {
+      LOG(ERROR) << ""error closing Zookeeper session, error code = "" << rc;
+    }
+    contextStorage_.closeAll();
+  }
+}
+
+int64_t BasicZookeeperClient::getSessionID() const {
+  folly::SharedMutex::ReadHolder g(zhLock_);
+  return zoo_client_id(zh_)->client_id;
+}
+
+SessionToken BasicZookeeperClient::getSessionToken() const {
+  SessionToken rval;
+  folly::SharedMutex::ReadHolder g(zhLock_);
+  auto* id = zoo_client_id(zh_);
+  rval.sessionId = id->client_id;
+  std::memcpy(rval.passwd.data(), id->passwd, sizeof(char) * 16);
+  return rval;
+}
+
+std::chrono::milliseconds BasicZookeeperClient::getSessionTimeout() const {
+  folly::SharedMutex::ReadHolder g(zhLock_);
+  return std::chrono::milliseconds(zoo_recv_timeout(zh_));
+}
+
+SessionState BasicZookeeperClient::getState() const {
+  folly::SharedMutex::ReadHolder g(zhLock_);
+  if (zh_ == nullptr) {
+    return SessionState::DISCONNECTED;
+  } else {
+    auto rc = zoo_state(zh_);
+    g.unlock();
+    return convertStateType(rc);
+  }
+}
+
+template <class T>
+static T processSynchronousErrorCodes(int rc) {
+  switch (rc) {
+    case ZBADARGUMENTS:
+      throw ZookeeperBadArgumentsException();
+    case ZINVALIDSTATE:
+      throw ZookeeperInvalidStateException();
+    case ZMARSHALLINGERROR:
+      throw ZookeeperMarshallingException();
+    case ZSYSTEMERROR:
+      throw ZookeeperSystemErrorException();
+    default:
+      throw ZookeeperUnexpectedException(rc);
+  }
+}
+
+void BasicZookeeperClient::close() {
+  folly::SharedMutex::WriteHolder g(zhLock_);
+  if (zh_ != nullptr) {
+    int rc = zookeeper_close(zh_);
+    zh_ = nullptr;
+    contextStorage_.closeAll();
+    if (rc != ZOK) {
+      processSynchronousErrorCodes<void>(rc);
+    }
+  }
+}
+
+void BasicZookeeperClient::sSessionWatchCallback(
+    zhandle_t*,
+    int type,
+    int state,
+    const char* path,
+    void* watcherCtx) {
+  auto* c =
+      reinterpret_cast<BasicZookeeperClient*>(const_cast<void*>(watcherCtx));
+  auto e = convertWatchEventType(path, type, state);
+  std::unique_lock<std::mutex> g(c->initialWatchesLock_);
+  c->initialWatches_.onWatchEvent(e.type, e.state, e.path);
+  g.unlock();
+  if (e.type == WatchEventType::SESSION) {
+    c->onSessionEvent(e.state);
+  }
+}
+
+template <class T>
+void BasicZookeeperClient::sCallbackException(folly::Promise<T>& p, int rc) {
+  switch (rc) {
+    case ZNOAUTH:
+      p.setException(ZookeeperNoAuthException());
+      break;
+    case ZCONNECTIONLOSS:
+      p.setException(ZookeeperConnectionLossException());
+      break;
+    case ZOPERATIONTIMEOUT:
+      p.setException(ZookeeperTimeoutException());
+      break;
+    case ZSESSIONEXPIRED:
+      p.setException(ZookeeperSessionExpiredException());
+      break;
+    default:
+      p.setException(ZookeeperUnexpectedException(rc));
+      break;
+  }
+}
+
+void BasicZookeeperClient::sGetCallback(
+    int rc,
+    const char* value,
+    int value_len,
+    const ::Stat* stat,
+    const void* data) {
+  if (rc == ZCLOSING) {
+    return;
+  }
+
+  auto c = ContextStorage::extract<GetContext>(data);
+  if (!c) {
+    return;
+  }
+
+  switch (rc) {
+    case ZOK:
+      c->getPromise().setValue(
+          GetDataResult{std::make_unique<folly::IOBuf>(
+                            folly::IOBuf::COPY_BUFFER, value, value_len),
+                        convertStat(*stat)});
+      break;
+    case ZNONODE:
+      c->getPromise().setException(
+          ZookeeperNoNodeException(std::move(c->path)));
+      break;
+    default:
+      sCallbackException(c->getPromise(), rc);
+      break;
+  }
+}
+
+void BasicZookeeperClient::sWatchCallback(
+    zhandle_t*,
+    int type,
+    int state,
+    const char* path,
+    void* watcherCtx) {
+  if (type == ZOO_SESSION_EVENT) {
+    reinterpret_cast<WatchContext*>(watcherCtx)
+        ->getSessionEventWatcher()
+        ->onSessionEvent(convertStateType(state));
+  } else {
+    auto c = ContextStorage::extract<WatchContext>(watcherCtx);
+    auto sessionEventWatcher = c->getSessionEventWatcher();
+
+    NodeEvent e(convertWatchEventType(
+        path, type, state, sessionEventWatcher->getNextIndex()));
+
+    c->getPromise().setValue(std::move(e));
+  }
+}
+
+void BasicZookeeperClient::sStatCallback(
+    int rc,
+    const ::Stat* stat,
+    const void* data) {
+  if (rc == ZCLOSING) {
+    return;
+  }
+
+  auto c = ContextStorage::extract<StatContext>(data);
+  if (!c) {
+    return;
+  }
+
+  switch (rc) {
+    case ZOK:
+      c->getPromise().setValue(convertStat(*stat));
+      break;
+    case ZBADVERSION:
+      c->getPromise().setException(
+          ZookeeperBadVersionException(std::move(c->path)));
+      break;
+    case ZNONODE:
+      c->getPromise().setException(
+          ZookeeperNoNodeException(std::move(c->path)));
+      break;
+    default:
+      sCallbackException(c->getPromise(), rc);
+      break;
+  }
+}
+
+void BasicZookeeperClient::sOptionalStatCallback(
+    int rc,
+    const ::Stat* stat,
+    const void* data) {
+  if (rc == ZCLOSING) {
+    return;
+  }
+
+  auto c = ContextStorage::extract<OptionalStatContext>(data);
+  if (!c) {
+    return;
+  }
+
+  switch (rc) {
+    case ZOK:
+      c->getPromise().setValue(convertStat(*stat));
+      break;
+    case ZNONODE:
+      c->getPromise().setValue(folly::none);
+      break;
+    case ZBADVERSION:
+      c->getPromise().setException(
+          ZookeeperBadVersionException(std::move(c->path)));
+      break;
+    default:
+      sCallbackException(c->getPromise(), rc);
+      break;
+  }
+}
+
+void BasicZookeeperClient::sCreateCallback(
+    int rc,
+    const char* value,
+    const void* data) {
+  if (rc == ZCLOSING) {
+    return;
+  }
+
+  auto c = ContextStorage::extract<CreateContext>(data);
+  if (!c) {
+    return;
+  }
+
+  switch (rc) {
+    case ZOK:
+      c->getPromise().setValue(CreateResult{value, folly::none});
+      break;
+    case ZNOCHILDRENFOREPHEMERALS:
+      c->getPromise().setException(
+          ZookeeperNoChildrenForEphemeralsException(std::move(c->path)));
+      break;
+    case ZNODEEXISTS:
+      c->getPromise().setException(
+          ZookeeperNodeExistsException(std::move(c->path)));
+      break;
+    case ZNONODE:
+      // Parent does not exist
+      c->getPromise().setException(
+          ZookeeperNoNodeException(c->path.substr(0, c->path.rfind('/'))));
+      break;
+    case ZINVALIDACL:
+      c->getPromise().setException(
+          ZookeeperInvalidACLException(std::move(c->path)));
+      break;
+    default:
+      sCallbackException(c->getPromise(), rc);
+      break;
+  }
+}
+
+void BasicZookeeperClient::sVoidCallback(int rc, const void* data) {
+  if (rc == ZCLOSING) {
+    return;
+  }
+
+  auto c = ContextStorage::extract<VoidContext>(data);
+  if (!c) {
+    return;
+  }
+
+  switch (rc) {
+    case ZOK:
+      c->getPromise().setValue();
+      break;
+    case ZBADVERSION:
+      c->getPromise().setException(
+          ZookeeperBadVersionException(std::move(c->path)));
+      break;
+    case ZNONODE:
+      c->getPromise().setException(
+          ZookeeperNoNodeException(std::move(c->path)));
+      break;
+    case ZNOTEMPTY:
+      c->getPromise().setException(
+          ZookeeperNotEmptyException(std::move(c->path)));
+      break;
+    default:
+      sCallbackException(c->getPromise(), rc);
+      break;
+  }
+}
+
+void BasicZookeeperClient::sSizeCallback(
+    int rc,
+    const int64_t* size,
+    const void* data) {
+  if (rc == ZCLOSING) {
+    return;
+  }
+
+  auto c = ContextStorage::extract<SizeContext>(size);
+  if (!c) {
+    return;
+  }
+
+  switch (rc) {
+    case ZOK:
+      c->getPromise().setValue(*size);
+      break;
+    case ZNONODE:
+      c->getPromise().setException(
+          ZookeeperNoNodeException(std::move(c->path)));
+      break;
+    default:
+      sCallbackException(c->getPromise(), rc);
+      break;
+  }
+}
+
+void BasicZookeeperClient::sAuthCallback(int rc, const void* data) {
+  if (rc == ZCLOSING) {
+    return;
+  }
+
+  auto c = ContextStorage::extract<AuthContext>(data);
+  if (!c) {
+    return;
+  }
+
+  switch (rc) {
+    case ZOK:
+      c->getPromise().setValue();
+      break;
+    case ZAUTHFAILED:
+      c->getPromise().setException(ZookeeperAuthFailedException());
+      break;
+    default:
+      sCallbackException(c->getPromise(), rc);
+      break;
+  }
+}
+
+void BasicZookeeperClient::sGetChildrenCallback(
+    int rc,
+    const ::String_vector* strings,
+    const ::Stat* stat,
+    const void* data) {
+  if (rc == ZCLOSING) {
+    return;
+  }
+
+  auto c = ContextStorage::extract<GetChildrenContext>(data);
+  if (!c) {
+    return;
+  }
+
+  if (rc == ZOK) {
+    std::vector<std::string> children;
+    for (int i = 0; i < strings->count; ++i) {
+      children.emplace_back(strings->data[i]);
+    }
+    c->getPromise().setValue(
+        GetChildrenResult{std::move(children), convertStat(*stat)});
+  } else {
+    switch (rc) {
+      case ZNONODE:
+        c->getPromise().setException(
+            ZookeeperNoNodeException(std::move(c->path)));
+        break;
+      default:
+        sCallbackException(c->getPromise(), rc);
+        break;
+    }
+  }
+}
+
+void BasicZookeeperClient::sGetAclCallback(
+    int rc,
+    ::ACL_vector* inACL,
+    ::Stat* stat,
+    const void* data) {
+  if (rc == ZCLOSING) {
+    return;
+  }
+
+  auto c = ContextStorage::extract<GetAclContext>(data);
+  if (!c) {
+    return;
+  }
+
+  if (rc == ZOK) {
+    ACL acl;
+    for (int i = 0; i < inACL->count; ++i) {
+      const auto& e = inACL->data[i];
+      acl.push_back(ACLElement{e.perms, Id{e.id.scheme, e.id.id}});
+    }
+    c->getPromise().setValue(GetAclResult{convertStat(*stat), std::move(acl)});
+  } else {
+    switch (rc) {
+      case ZNONODE:
+        c->getPromise().setException(
+            ZookeeperNoNodeException(std::move(c->path)));
+        break;
+      default:
+        sCallbackException(c->getPromise(), rc);
+        break;
+    }
+  }
+}
+
+OpResponse BasicZookeeperClient::buildOpResponse(
+    const ::zoo_op_result_t& r,
+    MultiOpType opType) {
+  OpResponse out;
+  if (r.value) {
+    if (opType == MultiOpType::CREATE) {
+      out.path = std::make_unique<std::string>(r.value);
+    } else {
+      out.data = std::make_unique<folly::IOBuf>(
+          folly::IOBuf::COPY_BUFFER, r.value, r.valuelen);
+    }
+  }
+  if (opType == MultiOpType::SETDATA) {
+    out.stat = std::make_unique<Stat>(convertStat(*r.stat));
+  }
+  return out;
+}
+
+void BasicZookeeperClient::sMultiCallback(int rc, const void* data) {
+  if (rc == ZCLOSING) {
+    return;
+  }
+
+  auto c = ContextStorage::extract<MultiContext>(data);
+  if (!c) {
+    return;
+  }
+
+  if (rc == ZOK) {
+    std::vector<OpResponse> rval;
+    rval.reserve(c->paths.size());
+    for (int i = 0; i < c->paths.size(); ++i) {
+      rval.push_back(buildOpResponse(c->opResults.at(i), c->opTypes.at(i)));
+    }
+    c->getPromise().setValue(std::move(rval));
+  } else {
+    std::vector<folly::Try<OpResponse>> responses;
+    int i = 0;
+    auto itr = c->paths.begin();
+    while (itr != c->paths.end()) {
+      if (c->opResults.at(i).err == ZOK) {
+        responses.emplace_back(
+            buildOpResponse(c->opResults.at(i), c->opTypes.at(i)));
+      } else {
+        switch (c->opResults.at(i).err) {
+          case ZNONODE:
+            responses.emplace_back(
+                ZookeeperNoNodeException(std::move(*itr)));
+            break;
+          case ZBADVERSION:
+            responses.emplace_back(
+                ZookeeperBadVersionException(std::move(*itr)));
+            break;
+          case ZNOTEMPTY:
+            responses.emplace_back(
+                ZookeeperNotEmptyException(std::move(*itr)));
+            break;
+          case ZINVALIDACL:
+            responses.emplace_back(
+                ZookeeperInvalidACLException(std::move(*itr)));
+            break;
+          case ZNOCHILDRENFOREPHEMERALS:
+            responses.emplace_back(ZookeeperNoChildrenForEphemeralsException(
+                std::move(*itr)));
+            break;
+          case ZNODEEXISTS:
+            responses.emplace_back(
+                ZookeeperNodeExistsException(std::move(*itr)));
+            break;
+          case ZNOAUTH:
+            responses.emplace_back(ZookeeperNoAuthException());
+            break;
+          case ZCONNECTIONLOSS:
+            responses.emplace_back(ZookeeperConnectionLossException());
+            break;
+          case ZOPERATIONTIMEOUT:
+            responses.emplace_back(ZookeeperTimeoutException());
+            break;
+          default:
+            responses.emplace_back(
+                ZookeeperUnexpectedException(c->opResults.at(i).err));
+            break;
+        }
+      }
+      i++;
+      itr++;
+    }
+    c->getPromise().setException(
+        ZookeeperMultiOpException(rc, std::move(responses)));
+  }
+}
+
+void BasicZookeeperClient::setServers(
+    const std::vector<folly::SocketAddress>& servers) {
+  auto connectString = buildConnectionString(servers);
+  folly::SharedMutex::ReadHolder g(zhLock_);
+  auto rc = zoo_set_servers(zh_, connectString.c_str());
+  if (rc != ZOK) {
+    processSynchronousErrorCodes<void>(rc);
+  }
+}
+
+folly::Future<GetDataResult> BasicZookeeperClient::getData(
+    const std::string& path) {
+  auto* c = contextStorage_.add(std::make_unique<GetContext>(path));
+  auto f = c->getPromise().getFuture();
+
+  folly::SharedMutex::ReadHolder zhg(zhLock_);
+  int rc =
+      zoo_aget(zh_, path.c_str(), 0, sGetCallback, reinterpret_cast<void*>(c));
+  zhg.unlock();
+
+  if (rc == ZOK) {
+    return f;
+  } else {
+    contextStorage_.erase(c);
+    return processSynchronousErrorCodes<folly::Future<GetDataResult>>(rc);
+  }
+}
+
+DataWithWatch BasicZookeeperClient::getDataWithWatch(const std::string& path) {
+  auto* gc = contextStorage_.add(std::make_unique<GetContext>(path));
+  auto gf = gc->getPromise().getFuture();
+  auto* wc = contextStorage_.add(std::make_unique<WatchContext>());
+  auto wf = wc->getPromise().getFuture();
+
+  folly::SharedMutex::ReadHolder zhg(zhLock_);
+  int rc = zoo_awget(zh_, path.c_str(), sWatchCallback, wc, sGetCallback, gc);
+  zhg.unlock();
+
+  if (rc == ZOK) {
+    return DataWithWatch{
+        std::move(gf), wc->getSessionEventWatcher(), std::move(wf)};
+  } else {
+    contextStorage_.erase(gc);
+    contextStorage_.erase(wc);
+    return processSynchronousErrorCodes<DataWithWatch>(rc);
+  }
+}
+
+folly::Future<Stat> BasicZookeeperClient::setDataInternal(
+    const std::string& path,
+    folly::ByteRange data,
+    int version) {
+  auto* c = contextStorage_.add(std::make_unique<StatContext>(path));
+  auto f = c->getPromise().getFuture();
+
+  folly::SharedMutex::ReadHolder zhg(zhLock_);
+  int rc = zoo_aset(
+      zh_,
+      path.c_str(),
+      reinterpret_cast<const char*>(data.data()),
+      data.size(),
+      version,
+      sStatCallback,
+      reinterpret_cast<void*>(c));
+  zhg.unlock();
+
+  if (rc == ZOK) {
+    return f;
+  } else {
+    contextStorage_.erase(c);
+    return processSynchronousErrorCodes<folly::Future<Stat>>(rc);
+  }
+}
+
+BasicZookeeperClient::CACL::CACL(const ACL& acl)
+    : aclVector_(nullptr), acls_(nullptr) {
+  if (!acl.empty()) {
+    aclVector_ = std::make_unique<::ACL_vector>();
+    aclVector_->count = acl.size();
+
+    acls_.reset(new ::ACL[acl.size()]);
+    for (int i = 0; i < acl.size(); ++i) {
+      acls_[i].perms = acl[i].perms;
+
+      // We only return a const* to acls_.
+      acls_[i].id.scheme = const_cast<char*>(acl[i].id.scheme.c_str());
+      acls_[i].id.id = const_cast<char*>(acl[i].id.id.c_str());
+    }
+
+    aclVector_->data = acls_.get();
+  }
+}
+
+folly::Future<CreateResult> BasicZookeeperClient::createNodeInternal(
+    const std::string& path,
+    folly::ByteRange data,
+    CreateMode createMode,
+    const ACL& acl) {
+  auto* c = contextStorage_.add(std::make_unique<CreateContext>(path));
+  auto f = c->getPromise().getFuture();
+
+  CACL cACL(acl);
+
+  folly::SharedMutex::ReadHolder zhg(zhLock_);
+  int rc = zoo_acreate(
+      zh_,
+      path.c_str(),
+      reinterpret_cast<const char*>(data.data()),
+      data.size(),
+      cACL.getCPtr(),
+      convertCreateMode(createMode),
+      sCreateCallback,
+      reinterpret_cast<void*>(c));
+  zhg.unlock();
+
+  if (rc == ZOK) {
+    return f;
+  } else {
+    contextStorage_.erase(c);
+    return processSynchronousErrorCodes<folly::Future<CreateResult>>(rc);
+  }
+}
+
+folly::Future<folly::Unit> BasicZookeeperClient::deleteNode(
+    const std::string& path,
+    int version) {
+  auto* c = contextStorage_.add(std::make_unique<VoidContext>(path));
+  auto f = c->getPromise().getFuture();
+
+  folly::SharedMutex::ReadHolder zhg(zhLock_);
+  int rc = zoo_adelete(
+      zh_, path.c_str(), version, sVoidCallback, reinterpret_cast<void*>(c));
+  zhg.unlock();
+
+  if (rc == ZOK) {
+    return f;
+  } else {
+    contextStorage_.erase(c);
+    return processSynchronousErrorCodes<folly::Future<folly::Unit>>(rc);
+  }
+}
+
+folly::Future<GetChildrenResult> BasicZookeeperClient::getChildren(
+    const std::string& path) {
+  auto* c = contextStorage_.add(
+      std::make_unique<GetChildrenContext>(path));
+  auto f = c->getPromise().getFuture();
+
+  folly::SharedMutex::ReadHolder zhg(zhLock_);
+  int rc = zoo_aget_children2(
+      zh_, path.c_str(), 0, sGetChildrenCallback, reinterpret_cast<void*>(c));
+  zhg.unlock();
+
+  if (rc == ZOK) {
+    return f;
+  } else {
+    contextStorage_.erase(c);
+    return processSynchronousErrorCodes<folly::Future<GetChildrenResult>>(rc);
+  }
+}
+
+ChildrenWithWatch BasicZookeeperClient::getChildrenWithWatch(
+    const std::string& path) {
+  auto* cc = contextStorage_.add(
+      std::make_unique<GetChildrenContext>(path));
+  auto cf = cc->getPromise().getFuture();
+  auto* wc = contextStorage_.add(std::make_unique<WatchContext>());
+  auto wf = wc->getPromise().getFuture();
+
+  folly::SharedMutex::ReadHolder zhg(zhLock_);
+  int rc = zoo_awget_children2(
+      zh_,
+      path.c_str(),
+      sWatchCallback,
+      reinterpret_cast<void*>(wc),
+      sGetChildrenCallback,
+      reinterpret_cast<void*>(cc));
+  zhg.unlock();
+
+  if (rc == ZOK) {
+    return ChildrenWithWatch{
+        std::move(cf), wc->getSessionEventWatcher(), std::move(wf)};
+  } else {
+    contextStorage_.erase(cc);
+    contextStorage_.erase(wc);
+    return processSynchronousErrorCodes<ChildrenWithWatch>(rc);
+  }
+}
+
+folly::Future<folly::Optional<Stat>> BasicZookeeperClient::exists(
+    const std::string& path) {
+  auto* c = contextStorage_.add(
+      std::make_unique<OptionalStatContext>(path));
+  auto f = c->getPromise().getFuture();
+
+  folly::SharedMutex::ReadHolder zhg(zhLock_);
+  int rc = zoo_aexists(
+      zh_, path.c_str(), 0, sOptionalStatCallback, reinterpret_cast<void*>(c));
+  zhg.unlock();
+
+  if (rc == ZOK) {
+    return f;
+  } else {
+    contextStorage_.erase(c);
+    return processSynchronousErrorCodes<folly::Future<folly::Optional<Stat>>>(
+        rc);
+  }
+}
+
+StatWithWatch BasicZookeeperClient::existsWithWatch(const std::string& path) {
+  auto* ec = contextStorage_.add(
+      std::make_unique<OptionalStatContext>(path));
+  auto ef = ec->getPromise().getFuture();
+  auto* wc = contextStorage_.add(std::make_unique<WatchContext>());
+  auto wf = wc->getPromise().getFuture();
+
+  folly::SharedMutex::ReadHolder zhg(zhLock_);
+  int rc = zoo_awexists(
+      zh_,
+      path.c_str(),
+      sWatchCallback,
+      reinterpret_cast<void*>(wc),
+      sOptionalStatCallback,
+      reinterpret_cast<void*>(ec));
+  zhg.unlock();
+
+  if (rc == ZOK) {
+    return StatWithWatch{
+        std::move(ef), wc->getSessionEventWatcher(), std::move(wf)};
+  } else {
+    contextStorage_.erase(ec);
+    contextStorage_.erase(wc);
+    return processSynchronousErrorCodes<StatWithWatch>(rc);
+  }
+}
+
+folly::Future<int64_t> BasicZookeeperClient::getSubtreeSize(
+    const std::string& path) {
+  auto* c = contextStorage_.add(std::make_unique<SizeContext>(path));
+  auto f = c->getPromise().getFuture();
+
+  folly::SharedMutex::ReadHolder zhg(zhLock_);
+  int rc = zoo_aget_subtree_size(","[{'comment': ""Doesn't exist in upstream either"", 'commenter': 'packysauce'}]"
238,src/java/main/org/apache/jute/Utils.java,"@@ -190,19 +190,32 @@ static String fromCSVString(String s) throws IOException {
     }
     
     /**
+     * convert byte array to a string in hex format
      * 
-     * @param s 
-     * @return 
+     * @param barr
+     * @return
      */
-    static String toXMLBuffer(byte barr[]) {","[{'comment': 'Great catch @alburthoffman\r\n\r\nJust wondering if there is anything wrong with java\'s built in XML tooling here. Using the example from the JIRA:\r\n`javax.xml.bind.DatatypeConverter.printHexBinary(new byte[] {0x10, 0x05, -0x20})` => ""1005E0""\r\n\r\nThe implementation appears to be identical and this way we don\'t need to ""think about it"" in zk code.', 'commenter': 'afine'}, {'comment': 'you are right. printHexBinary works exactly as same as toHexString.\r\nI will change it to use printHexBinary and add test cases.\r\n\r\nThx for ur suggestion', 'commenter': 'alburthoffman'}, {'comment': ""@afine found the reason why not use DatatypeConverter:\r\nJAXB Providers are required to call the setDatatypeConverter api at some point before the first marshal or unmarshal operation (perhaps during the call to JAXBContext.newInstance). This step is necessary to configure the converter that should be used to perform the print and parse functionality.\r\n\r\nIn utils class, initialize JAXB is too heavy, so let's make it simple...."", 'commenter': 'alburthoffman'}, {'comment': 'I know next to nothing about JAXB so I can definitely be wrong, but I was able to drop `DatatypeConverter.printHexBinary` in place and have everything just work. Digging through the implementation and DatatypeConverter instantiation happening behind the scenes everything looked reasonable. Can you link me to something that shows what I am missing?\r\n\r\nThanks', 'commenter': 'afine'}, {'comment': ""I'm not able to dig into Zookeeper internal to find the root cause.\r\nbut this link would help:\r\nhttp://stackoverflow.com/questions/12498256/why-the-npe-using-static-method-of-datatypeconverter\r\nhttps://developer.ibm.com/answers/questions/200553/jaxb-datatypeconverter-throws-nullpointerexception.html\r\n"", 'commenter': 'alburthoffman'}, {'comment': ""I went through the links that you provided. Would you mind including the version of the JVM that you are running? According to https://issues.apache.org/jira/browse/CAMEL-4893 the issue I think you are running into was fixed in JDK's greater than 1.7.0_02.\r\n\r\nIt would also be great if you could include a stack trace of the issue you are running into."", 'commenter': 'afine'}, {'comment': '@afine I belive it\'s the testing environment, because the tests for datatypeconverter will fail. here is what I found from their jenkins job console:\r\njava version ""1.7.0_80""\r\nJava(TM) SE Runtime Environment (build 1.7.0_80-b15)\r\nJava HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode) ', 'commenter': 'alburthoffman'}, {'comment': 'Hi @alburthoffman -\r\n\r\nI have been trying to reproduce the issue that you described. A stack trace would be helpful here. Do you know exactly which test was failing for you (as I don\'t think the logs for any relevant jenkins job still exists)? I was able to get the whole test suite to pass with `DatatypeConverter.printHexBinary`. \r\n\r\nAlthough, if I do not add null check I can get `testJuteToString` to fail. \r\n\r\n```\r\njava.lang.NullPointerException\r\n\tat javax.xml.bind.DatatypeConverterImpl.printHexBinary(DatatypeConverterImpl.java:479)\r\n\tat javax.xml.bind.DatatypeConverter.printHexBinary(DatatypeConverter.java:626)\r\n\tat org.apache.jute.Utils.toHexString(Utils.java:203)\r\n\tat org.apache.jute.Utils.toCSVBuffer(Utils.java:242)\r\n\tat org.apache.jute.CsvOutputArchive.writeBuffer(CsvOutputArchive.java:100)\r\n\tat org.apache.zookeeper.proto.SetDataRequest.toString(SetDataRequest.java:77)\r\n\tat org.apache.zookeeper.server.ToStringTest.testJuteToString(ToStringTest.java:36)\r\n```\r\n\r\nI was able to remedy this with a null check before the javax call. \r\n\r\n```\r\n    private static String toHexString(byte barr[]) {\r\n        if (barr == null) {\r\n            return """";\r\n        }\r\n        return javax.xml.bind.DatatypeConverter.printHexBinary(barr);\r\n    }\r\n```\r\n\r\nThanks for your patience on this.\r\n\r\nAbe', 'commenter': 'afine'}, {'comment': ""@afine I changed the code to use DatatypeConverter.printHexBinary(barr). but the tests keep failing. \r\nI take a look at the failures. it's very wired, because should not be caused by this change.\r\n\r\nAlso I got different test cases failure in local and in hadoop jenkins report. \r\n\r\nNot sure how to trigger hadoop jenkins job to run tests, so no way to paste it here."", 'commenter': 'alburthoffman'}]"
257,src/java/test/org/apache/zookeeper/test/CnxManagerTest.java,"@@ -18,36 +18,32 @@
 
 package org.apache.zookeeper.test;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.net.InetSocketAddress;
-import java.nio.ByteBuffer;
-import java.nio.channels.SocketChannel;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.Random;
-import java.util.concurrent.TimeUnit;
-import java.net.Socket;
-
-import org.apache.zookeeper.common.Time;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.PortAssignment;
 import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.common.Time;
 import org.apache.zookeeper.server.quorum.QuorumCnxManager;
-import org.apache.zookeeper.server.quorum.QuorumCnxManager.Message;
 import org.apache.zookeeper.server.quorum.QuorumCnxManager.InitialMessage;
+import org.apache.zookeeper.server.quorum.QuorumCnxManager.Message;
 import org.apache.zookeeper.server.quorum.QuorumPeer;
 import org.apache.zookeeper.server.quorum.QuorumPeer.LearnerType;
 import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
 import org.apache.zookeeper.server.quorum.QuorumPeer.ServerState;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.*;","[{'comment': '@asdf2014 FYI, ZK codebase gives preference to explicit imports instead of using wildcards.', 'commenter': 'eribeiro'}, {'comment': 'I see. I will roll it back.', 'commenter': 'asdf2014'}]"
257,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -660,6 +665,9 @@ public void run() {
                             ""Ignoring exception"", ie);
                     }
                     closeSocket(client);
+                } catch (ConfigException ce) {
+                    LOG.error(ce.getMessage());
+                    throw new RuntimeException(ce);","[{'comment': ""Don't we have to call `closeSocket(client)` here before throwing the `RuntimeException`? Relying on OS/JVM to close a socket can be too much optimistic and leak resources. If I am right (please double check) then line 667 can be moved to a finally block just below this catch clause.\r\n\r\nAlso, as the program flow is interrupted if a `ConfigException` is thrown lines 679-687 wouldn't be called and then `ServerSocket` also is not properly closed, right?\r\n\r\nPS: I am not sure, would have to look carefully later and don't have time now, so excuse me if I am misunderstood it.\r\n"", 'commenter': 'eribeiro'}, {'comment': ""You are right. Throwing 'RuntimeException' does skip the closing `ServerSocket` part, so I moved it to the end of the` run` method."", 'commenter': 'asdf2014'}]"
257,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -657,9 +663,12 @@ public void run() {
                         LOG.error(""Error closing server socket"", ie);
                     } catch (InterruptedException ie) {
                         LOG.error(""Interrupted while sleeping. "" +
-                            ""Ignoring exception"", ie);
+                                ""Ignoring exception"", ie);
                     }
                     closeSocket(client);
+                } catch (ConfigException e) {
+                    LOG.error(e.getMessage());
+                    ce = e;","[{'comment': "":+1: BUT you need to call `closeSocket(client);` here too. See line 668. ;) It is the ServerSocket and Socket we need to close in case of error. I know we close the socket previously before throwing the exception, but `Socket#close()` is idempotent so, I would advise to put it here too. In fact, we could remove line 668 and add a `finally` block with the  `closeSocket(client);` after line 672.\r\n\r\n**Most important!** The latest change doesn't break the while loop so it only leave after reaching the maximum number of retries or shutdown is called (I bet the first). We should include a `break;` at line 672. ;)\r\n"", 'commenter': 'eribeiro'}, {'comment': 'Great! I will fix it.', 'commenter': 'asdf2014'}]"
257,src/java/test/org/apache/zookeeper/test/CnxManagerTest.java,"@@ -351,15 +351,55 @@ public void testSocketTimeout() throws Exception {
         LOG.info(""Election port: "" + port);
         Thread.sleep(1000);
 
-        Socket sock = new Socket();
-        sock.connect(peers.get(1L).electionAddr, 5000);
-        long begin = Time.currentElapsedTime();
-        // Read without sending data. Verify timeout.
-        cnxManager.receiveConnection(sock);
-        long end = Time.currentElapsedTime();
-        if((end - begin) > ((peer.getSyncLimit() * peer.getTickTime()) + 500)) Assert.fail(""Waited more than necessary"");
-        cnxManager.halt();
-        Assert.assertFalse(cnxManager.listener.isAlive());
+        try (Socket sock = new Socket()) {","[{'comment': ""It looks like the reason for changing those lines was to include a ARM block, right?\r\n\r\nI understand the motivation and have to refrain myself from doing the same a couple of times, but this kind of refactoring would be goal of a separate issue as **it is not related to the bug/feature of this issue** (aka _don't fix if it's not broken_).\r\n\r\nSo, it revert it to the original one, please. :)\r\n"", 'commenter': 'eribeiro'}, {'comment': '+1, although please feel free to submit a jira and fix it there!', 'commenter': 'afine'}, {'comment': 'Okay! I will separate it into a different `jira`.', 'commenter': 'asdf2014'}]"
257,src/java/test/org/apache/zookeeper/test/CnxManagerTest.java,"@@ -351,15 +351,55 @@ public void testSocketTimeout() throws Exception {
         LOG.info(""Election port: "" + port);
         Thread.sleep(1000);
 
-        Socket sock = new Socket();
-        sock.connect(peers.get(1L).electionAddr, 5000);
-        long begin = Time.currentElapsedTime();
-        // Read without sending data. Verify timeout.
-        cnxManager.receiveConnection(sock);
-        long end = Time.currentElapsedTime();
-        if((end - begin) > ((peer.getSyncLimit() * peer.getTickTime()) + 500)) Assert.fail(""Waited more than necessary"");
-        cnxManager.halt();
-        Assert.assertFalse(cnxManager.listener.isAlive());
+        try (Socket sock = new Socket()) {
+            sock.connect(peers.get(1L).electionAddr, 5000);
+            long begin = Time.currentElapsedTime();
+            // Read without sending data. Verify timeout.
+            cnxManager.receiveConnection(sock);
+            long end = Time.currentElapsedTime();
+            if ((end - begin) > ((peer.getSyncLimit() * peer.getTickTime()) + 500))
+                Assert.fail(""Waited more than necessary"");
+            cnxManager.halt();
+            Assert.assertFalse(cnxManager.listener.isAlive());
+        }
+    }
+
+    /*
+     * Test if a duplicate SID appears in the cluster
+     */
+    @Test
+    public void testSameSID() throws Exception {
+        QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[2], peerTmpdir[2], peerClientPort[2], 3, 2, 2000, 2, 2);
+        QuorumCnxManager cnxManager = new QuorumCnxManager(peer);
+        QuorumCnxManager.Listener listener = cnxManager.listener;
+        if (listener != null) {
+            Thread.UncaughtExceptionHandler handler = new Thread.UncaughtExceptionHandler() {
+                @Override
+                public void uncaughtException(Thread th, Throwable ex) {
+                    if (ex instanceof RuntimeException) {
+                        String msg = ex.getMessage();
+                        LOG.error(msg);
+                        Assert.assertEquals(""org.apache.zookeeper.server.quorum.QuorumPeerConfig$ConfigException:"" +
+                                "" Appearing duplicate SID: 2"", msg);
+                    }
+                }
+            };
+            listener.setUncaughtExceptionHandler(handler);
+            listener.start();
+        } else {
+            LOG.error(""Null listener when initializing cnx manager"");
+        }
+        try (Socket sock = new Socket()) {
+            InetSocketAddress electionAddr = peers.get(peer.getId()).electionAddr;
+            LOG.info(""Creating socket connection, host: {}, port: {}"",
+                    electionAddr.getHostString(), electionAddr.getPort());
+            sock.connect(electionAddr, 30000);","[{'comment': 'The timeout here is way to big (30000 ms) with relation to the other tests (5000 ms). It is really necessary to be this big?', 'commenter': 'eribeiro'}, {'comment': 'I want to fix the `Connection Refused`. I thought the environment `jenkins` is not stable...', 'commenter': 'asdf2014'}]"
257,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -310,8 +311,8 @@ public boolean initiateConnection(Socket sock, Long sid) {
      * possible long value to lose the challenge.
      *
      */
-    public void receiveConnection(Socket sock) {
-        Long sid = null, protocolVersion = null;
+    public void receiveConnection(Socket sock) throws ConfigException {
+        Long sid, protocolVersion;","[{'comment': 'As we removed the extraneous `null` here we could also use the primitive long type, right? I don\'t see any gain of using boxed types here. I see a lot of boxing/unboxing down in this method, so it could be simply `int sid, protocolVersion;` (this slightly falls into ""the don\'t fix if..."" adage, but we can ignore this for once ;) ).', 'commenter': 'eribeiro'}, {'comment': 'Yeah, actually it could be a problem. `Long == Long` will call `Long.valueof` method, and compare the address of Object. And the `Long.valueof` method will create a new `Long` Object when the value of `Long` Object more than 127. So, it could return the `false`.\r\n```java\r\n/*\r\n127L == 127L: true\r\n128L == 128L: false\r\n128L equals 128L: true\r\n127 == 127: true\r\n128 == 128: true\r\n */\r\npublic static void main(String... args) {\r\n    Long l1 = 127L, l2 = 127L, l3 = 128L, l4 = 128L;\r\n    System.out.println(""127L == 127L: "" + (l1 == l2));\r\n    System.out.println(""128L == 128L: "" + (l3 == l4));\r\n    System.out.println(""128L equals 128L: "" + (l3.equals(l4)));\r\n    long ll1 = 127, ll2 = 127, ll3 = 128, ll4 = 128;\r\n    System.out.println(""127 == 127: "" + (ll1 == ll2));\r\n    System.out.println(""128 == 128: "" + (ll3 == ll4));\r\n}\r\n```', 'commenter': 'asdf2014'}]"
257,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -371,6 +372,10 @@ public void receiveConnection(Socket sock) {
                 connectOne(sid);
             }
 
+        }else if (sid == self.getId()) {","[{'comment': 'nit: space between `{` and `else`', 'commenter': 'eribeiro'}, {'comment': 'Thanks! I will fix it.', 'commenter': 'asdf2014'}]"
257,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -545,6 +545,7 @@ public void testInconsistentPeerType() throws Exception {
                 defaultedToObserver = true;
             }
             if (warningPresent && defaultedToObserver) {
+                LOG.debug(""Content from console is: {}"", line);","[{'comment': 'Ugh?! What is the purpose of this for the issue at hand?', 'commenter': 'eribeiro'}, {'comment': '""QuorumPeerMainTest"" has no reason to fail in `jinkens`, so add a logger to figure out why. I will remove it.', 'commenter': 'asdf2014'}]"
257,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -677,6 +686,7 @@ public void run() {
                     LOG.debug(""Error closing server socket"", ie);
                 }
             }
+            if (ce !=null) throw new RuntimeException(ce);","[{'comment': 'Okay, I am still unsure if throwing a Runtime exception is the best approach here.', 'commenter': 'eribeiro'}, {'comment': 'Would it be possible to refactor this so the exception never leaves its catch block? Perhaps the logic ""in between"" can be captured with ""finally"". Then I think we will fix https://github.com/apache/zookeeper/pull/257/files#r117407300 as well.', 'commenter': 'afine'}, {'comment': 'Thx a lot! I will using `finally` deal with closing `socket`.', 'commenter': 'asdf2014'}]"
257,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -18,6 +18,12 @@
 
 package org.apache.zookeeper.server.quorum;
 
+import org.apache.zookeeper.server.ZooKeeperThread;","[{'comment': 'a few unnecessary reordering of imports, these should be kept to a minimum to keep the diff clean', 'commenter': 'afine'}, {'comment': 'Thank you! I will pay attention. :D', 'commenter': 'asdf2014'}]"
257,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -620,6 +625,7 @@ public void run() {
             int numRetries = 0;
             InetSocketAddress addr;
             Socket client = null;
+            ConfigException ce = null;","[{'comment': 'nit: can we use better variable naming?', 'commenter': 'afine'}, {'comment': 'Using `configExceptioin`?', 'commenter': 'asdf2014'}, {'comment': '+1 about `configException` :+1:', 'commenter': 'eribeiro'}, {'comment': 'Okay!', 'commenter': 'asdf2014'}]"
257,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -657,9 +663,12 @@ public void run() {
                         LOG.error(""Error closing server socket"", ie);
                     } catch (InterruptedException ie) {
                         LOG.error(""Interrupted while sleeping. "" +
-                            ""Ignoring exception"", ie);
+                                ""Ignoring exception"", ie);","[{'comment': 'nit: whitespace change', 'commenter': 'afine'}, {'comment': 'Thanks! I will roll it back.', 'commenter': 'asdf2014'}]"
257,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -371,6 +372,10 @@ public void receiveConnection(Socket sock) {
                 connectOne(sid);
             }
 
+        }else if (sid == self.getId()) {
+            closeSocket(sock);
+            throw new ConfigException(String.format(""Appearing duplicate SID: %s"", sid));","[{'comment': 'I think this message could be more descriptive or reshaped. English is not my 1st language, but what about _""Inconsistent ensemble setup: duplicate SID %s found""?_', 'commenter': 'eribeiro'}, {'comment': 'Great! I will change it.', 'commenter': 'asdf2014'}]"
274,docs/zookeeperAdmin.html,"@@ -1446,7 +1446,17 @@ <h3 class=""h4"">Configuration Parameters</h3>
               </pre>
 </dd>
 
-        
+<dt>
+<term>tcpKeepAlive</term>
+</dt>
+<dd>
+<p>(No Java system property)</p>","[{'comment': 'A config option by default will automatically be added as a system property with its name as the suffix. In this case, the property will be ""zookeeper.tcpKeepAlive"", when the zoo.cfg file is parsed. See QuorumPeerConfig.java for more details. So this doc should be updated.\r\n\r\nHaving it as a system property is actually better as we can query the property when we need it, instead of change the signatures of various classes and pass it around.', 'commenter': 'hanm'}, {'comment': ""Updated previous comment: I haven't seen your change to QuorumPeerConfig when commented on this. Though I think having a system property might be a more flexible option with less changes required. I don't think we have firm standard on which config option should have system properties and which ones should not, so I am ok either way."", 'commenter': 'hanm'}]"
274,src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java,"@@ -270,6 +271,8 @@ public void parseProperties(Properties zkProp)
                 quorumServicePrincipal = value;
             } else if (key.equals(""quorum.cnxn.threads.size"")) {
                 quorumCnxnThreadsSize = Integer.parseInt(value);
+            } else if (key.equals(""tcpKeepAlive"")) {
+                tcpKeepAlive = Boolean.parseBoolean(value);","[{'comment': 'As previously mentioned you can just let it fall through and query the system property when we need set the sock option. \r\nIf we do need parse it, then we need handle potential exceptions on illegal values here.', 'commenter': 'hanm'}, {'comment': 'Got it, making changes now!', 'commenter': 'bensherman'}]"
274,docs/zookeeperAdmin.html,"@@ -1446,7 +1446,17 @@ <h3 class=""h4"">Configuration Parameters</h3>
               </pre>
 </dd>
 
-        
+<dt>
+<term>tcpKeepAlive</term>
+</dt>
+<dd>
+<p>(Java system property: <strong>zookeeper.tcpKeepAlive</strong>)</p>","[{'comment': 'it would be great to provide a brief explanation for users why they may want to do this. without them needing to refer to the JIRA. ', 'commenter': 'afine'}, {'comment': 'Without digging into TCP options too deeply, I did the best I could.  Thanks for the suggestion.', 'commenter': 'bensherman'}, {'comment': 'Excellent explanation. +1', 'commenter': 'afine'}]"
275,src/contrib/loggraph/web/org/apache/zookeeper/graph/resources/raphael.js,"@@ -3018,9 +3018,9 @@ Raphael = (function () {
                         };
                         break;
                     case ""path"":
-                        var pathes = path2curve(from[attr], to[attr]);
-                        from[attr] = pathes[0];
-                        var toPath = pathes[1];
+                        var paths = path2curve(from[attr], to[attr]);","[{'comment': 'lets not make unnecessary code changes', 'commenter': 'afine'}]"
275,src/java/main/org/apache/zookeeper/server/WatchManager.java,"@@ -94,7 +94,7 @@ synchronized void removeWatcher(Watcher watcher) {
         return triggerWatch(path, type, null);
     }
 
-    Set<Watcher> triggerWatch(String path, EventType type, Set<Watcher> supress) {
+    Set<Watcher> triggerWatch(String path, EventType type, Set<Watcher> suppress) {","[{'comment': 'I think we should avoid code changes here. ', 'commenter': 'afine'}]"
294,zookeeper-server/src/main/java/org/apache/zookeeper/jmx/ManagedUtil.java,"@@ -71,7 +71,7 @@ public static void registerLog4jMBeans() throws JMException {
                 // org.apache.log4j.jmx.HierarchyDynamicMBean hdm = new org.apache.log4j.jmx.HierarchyDynamicMBean();
                 Object hdm = Class.forName(""org.apache.log4j.jmx.HierarchyDynamicMBean"").getDeclaredConstructor().newInstance();
 
-                ObjectName mbo = new ObjectName(""log4j:hiearchy=default"");
+                ObjectName mbo = new ObjectName(""log4j:hierarchy=default"");","[{'comment': 'Is change may have an impact on integrated systems.\r\nMaybe we could make this name configurable so that people will be able to revert the name.\r\nThis change can be only in master (3.6.0) as it is a public configuration/API change', 'commenter': 'eolivelli'}, {'comment': ""Hi, @eolivelli . Thanks for your reviewing. Indeed, turning it into a configurable one would be very helpful in upgrading an integrated system. So, let's be clear, should we add a new JVM option or add a new environment variable to the operating system?"", 'commenter': 'asdf2014'}]"
294,zookeeper-server/src/main/java/org/apache/zookeeper/jmx/ManagedUtil.java,"@@ -69,9 +69,13 @@ public static void registerLog4jMBeans() throws JMException {
             try {
                 // Create and Register the top level Log4J MBean
                 // org.apache.log4j.jmx.HierarchyDynamicMBean hdm = new org.apache.log4j.jmx.HierarchyDynamicMBean();
-                Object hdm = Class.forName(""org.apache.log4j.jmx.HierarchyDynamicMBean"").getDeclaredConstructor().newInstance();
+                Object hdm = Class.forName(""org.apache.log4j.jmx.HierarchyDynamicMBean"").getConstructor().newInstance();
 
-                ObjectName mbo = new ObjectName(""log4j:hiearchy=default"");
+                String mbean = System.getenv(""zookeeper.jmx.log4j.mbean"");","[{'comment': 'You should use System.getProperty(name,defaultvalue)', 'commenter': 'eolivelli'}, {'comment': '> I would go for a system property\r\n\r\nFYI, `System.getenv()` is for Operating System environment variables, whereas `System.getProperty()` is for JVM arguments which are passed as `-DpropName=value` to Java application launcher.\r\n\r\nSo, maybe use `getenv()` would be more reasonable.', 'commenter': 'asdf2014'}, {'comment': 'As far as I know in ZK it is common to use System Properties and not environment variables.\r\n\r\nI think that the launcher for the server process is setting as system property every configuration parameter.\r\n\r\nDo you have any example of usages of getEnv in ZooKeeper ?', 'commenter': 'eolivelli'}, {'comment': '@eolivelli Okay, I will modify it.', 'commenter': 'asdf2014'}]"
296,src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -332,11 +333,13 @@ public synchronized void commit() throws IOException {
             if (forceSync) {
                 long startSyncNS = System.nanoTime();
 
-                log.getChannel().force(false);
+                FileChannel channel = log.getChannel();
+                channel.force(false);
 
                 syncElapsedMS = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startSyncNS);
                 if (syncElapsedMS > fsyncWarningThresholdMS) {
-                    LOG.warn(""fsync-ing the write ahead log in ""
+                    LOG.warn(""fsync-ing the write ahead log (""
+                            + channel.size() + "" bytes) in ""","[{'comment': 'According to the javadoc, `size()` returns ""Returns the current size of this channel\'s file."" Can you explain why this is valuable?', 'commenter': 'afine'}, {'comment': '@afine Thank you for code review. When we got the warn message, will confuse that reason is `too large log` or `too busy disk I/O`? So, need to show the size of log to eliminate the `too large log` possibility.', 'commenter': 'asdf2014'}, {'comment': ""@asdf2014 can you move the changed text after the first sentence?\r\n\r\n... latency. File size is ### bytes. See ...\r\n\r\nThe reason being that I know a number of users who have log triggers on this log message and I'd like to minimize the impact as much as possible."", 'commenter': 'phunt'}, {'comment': ""@asdf2014 as soon as @phunt's comment is addressed I can merge this in."", 'commenter': 'afine'}]"
300,src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java,"@@ -327,6 +257,95 @@ public void run() {
         LOG.info(""CommitProcessor exited loop!"");
     }
 
+    private void processCommittedRequest() throws IOException, InterruptedException {
+        // In case of a spurious wakeup in waitForCommittedRequests we should not
+        // remove the request from the queue until it has been processed
+        Request request = committedRequests.peek();
+
+        if (request == null) {
+            committedRequests.poll();","[{'comment': 'If request==null then the committedRequests queue is already empty. Why do you need to poll() here?', 'commenter': 'anmolnar'}, {'comment': ""we don't"", 'commenter': 'afine'}]"
300,src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java,"@@ -240,84 +240,14 @@ public void run() {
                     }
 
                     // Process committed head
-                    if ((request = committedRequests.poll()) == null) {
-                        throw new IOException(""Error: committed head is null"");
-                    }
-
-                    /*
-                     * Check if request is pending, if so, update it with the committed info
-                     */
-                    LinkedList<Request> sessionQueue = pendingRequests
-                            .get(request.sessionId);
-                    if (sessionQueue != null) {
-                        // If session queue != null, then it is also not empty.
-                        Request topPending = sessionQueue.poll();
-                        if (request.cxid != topPending.cxid) {
-                            /*
-                             * TL;DR - we should not encounter this scenario often under normal load.
-                             * We pass the commit to the next processor and put the pending back with a warning.
-                             *
-                             * Generally, we can get commit requests that are not at the queue head after
-                             * a session moved (see ZOOKEEPER-2684). Let's denote the previous server of the session
-                             * with A, and the server that the session moved to with B (keep in mind that it is
-                             * possible that the session already moved from B to a new server C, and maybe C=A).
-                             * 1. If request.cxid < topPending.cxid : this means that the session requested this update
-                             * from A, then moved to B (i.e., which is us), and now B receives the commit
-                             * for the update after the session already performed several operations in B
-                             * (and therefore its cxid is higher than that old request).
-                             * 2. If request.cxid > topPending.cxid : this means that the session requested an updated
-                             * from B with cxid that is bigger than the one we know therefore in this case we
-                             * are A, and we lost the connection to the session. Given that we are waiting for a commit
-                             * for that update, it means that we already sent the request to the leader and it will
-                             * be committed at some point (in this case the order of cxid won't follow zxid, since zxid
-                             * is an increasing order). It is not safe for us to delete the session's queue at this
-                             * point, since it is possible that the session has newer requests in it after it moved
-                             * back to us. We just leave the queue as it is, and once the commit arrives (for the old
-                             * request), the finalRequestProcessor will see a closed cnxn handle, and just won't send a
-                             * response.
-                             * Also note that we don't have a local session, therefore we treat the request
-                             * like any other commit for a remote request, i.e., we perform the update without sending
-                             * a response.
-                             */
-                            LOG.warn(""Got request "" + request +
-                                    "" but we are expecting request "" + topPending);
-                            sessionQueue.addFirst(topPending);
-                        } else {
-                            /*
-                             * Generally, we want to send to the next processor our version of the request,
-                             * since it contains the session information that is needed for post update processing.
-                             * In more details, when a request is in the local queue, there is (or could be) a client
-                             * attached to this server waiting for a response, and there is other bookkeeping of
-                             * requests that are outstanding and have originated from this server
-                             * (e.g., for setting the max outstanding requests) - we need to update this info when an
-                             * outstanding request completes. Note that in the other case (above), the operation
-                             * originated from a different server and there is no local bookkeeping or a local client
-                             * session that needs to be notified.
-                             */
-                            topPending.setHdr(request.getHdr());
-                            topPending.setTxn(request.getTxn());
-                            topPending.zxid = request.zxid;
-                            request = topPending;
-                        }
-                    }
-
-                    sendToNextProcessor(request);
-
-                    waitForEmptyPool();
-
-                    /*
-                     * Process following reads if any, remove session queue if
-                     * empty.
-                     */
-                    if (sessionQueue != null) {
-                        while (!stopped && !sessionQueue.isEmpty()
-                                && !needCommit(sessionQueue.peek())) {
-                            sendToNextProcessor(sessionQueue.poll());
-                        }
-                        // Remove empty queues
-                        if (sessionQueue.isEmpty()) {
-                            pendingRequests.remove(request.sessionId);
+                    // We only need to perform synchronization if we are on the last request in the queue
+                    if (committedRequests.size() == 1) {
+                        synchronized (committedRequests) {","[{'comment': 'Does synchronized - notifyAll() have any performance hit in normal operation of the follower?', 'commenter': 'anmolnar'}, {'comment': 'I believe I was able to mitigate any potential performance impact by only entering a synchronized block when there is only a single committed request in the queue.', 'commenter': 'afine'}, {'comment': 'Ok\r\n', 'commenter': 'anmolnar'}]"
308,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -880,19 +876,20 @@ public void run() {
          * 
          * @return boolean  Value of variable running
          */
-        synchronized boolean finish() {
-            if(!running){
-                /*
-                 * Avoids running finish() twice. 
-                 */
-                return running;
-            }
-            running = false;            
-
-            this.interrupt();
-            threadCnt.decrementAndGet();
-            return running;
-        }
+		boolean finish() {","[{'comment': ""I understand what you are trying to do here and why this is optimized. I'm just concerned that that any performance increase here would not be worth the decrease in readability."", 'commenter': 'afine'}, {'comment': 'Yes.we should keep a blance between optimization and readability.the most importance thing for this optimization is whether this function has faced a performace problem and this optimization is overdesign. Haha.self-criticism.However ,I find the shadow of this programming paradigm in zk code base [Line501~Line507](https://github.com/apache/zookeeper/blob/master/src/java/main/org/apache/zookeeper/ClientCnxn.java ) \r\n', 'commenter': 'maoling'}]"
308,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -233,25 +233,25 @@ public QuorumCnxManager(QuorumPeer self) {
         listener = new Listener();
         listener.setName(""QuorumPeerListener"");
     }
-
+    ","[{'comment': 'style changes are great but would it be possible to separate them from changes to functionality? that way it becomes easier to understand changes that are made when going through the version control log', 'commenter': 'afine'}, {'comment': 'I cannot help doing this although I know it will increase review work.I will keep it in my mind next time. **""When we say ""do it separately"" in the context of zk, it probably implies \'never\'""** Quotation from hanm.', 'commenter': 'maoling'}]"
308,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -233,25 +233,25 @@ public QuorumCnxManager(QuorumPeer self) {
         listener = new Listener();
         listener.setName(""QuorumPeerListener"");
     }
-
+    
     /**
-     * Invokes initiateConnection for testing purposes
-     * 
+     * establish Connection with sid using its electionAddr.
      * @param sid
+     * @param sock
+     * @throws IOException
      */
-    public void testInitiateConnection(long sid) throws Exception {
-        LOG.debug(""Opening channel to server "" + sid);
-        Socket sock = new Socket();
+	public void establishConnection(Long sid, Socket sock) throws IOException {
+		LOG.debug(""Opening channel to server "" + sid);
         setSockOpts(sock);
         sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);
-        initiateConnection(sock, sid);
-    }
+        LOG.debug(""Connected to server "" + sid);
+	}
     
     /**
      * If this server has initiated the connection, then it gives up on the
      * connection if it loses challenge. Otherwise, it keeps the connection.
      */
-    public boolean initiateConnection(Socket sock, Long sid) {
+    public boolean initiateConnection(Long sid, Socket sock) {","[{'comment': 'nit: why did this need to be changed?', 'commenter': 'afine'}, {'comment': 'I think put the mutable variables after fixed variables may be better in the parameter list;\r\nsuch as :\r\n`private void myMethod(int a, Integer b, String s1, StringBuilder s2){}`', 'commenter': 'maoling'}]"
312,src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -275,20 +307,9 @@ public synchronized void closeSession(long sessionId) {
 
     @SuppressWarnings(""unchecked"")
     private void closeSessionWithoutWakeup(long sessionId) {
-        HashSet<NIOServerCnxn> cnxns;
-        synchronized (this.cnxns) {
-            cnxns = (HashSet<NIOServerCnxn>)this.cnxns.clone();
-        }
-
-        for (NIOServerCnxn cnxn : cnxns) {
-            if (cnxn.getSessionId() == sessionId) {
-                try {
-                    cnxn.close();
-                } catch (Exception e) {
-                    LOG.warn(""exception during session close"", e);
-                }
-                break;
-            }
+        NIOServerCnxn cnxn = sessionMap.remove(sessionId);
+        if (cnxn != null) {
+            cnxn.close();","[{'comment': 'Why did you remove the `try-catch` block around `cnxn.close()`? We still can have exceptions being thrown during `cnxn.close()`, right?', 'commenter': 'eribeiro'}, {'comment': '@eribeiro good catch, I will fix it.', 'commenter': 'CheneySun'}]"
312,src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -62,6 +63,10 @@
     */
     final ByteBuffer directBuffer = ByteBuffer.allocateDirect(64 * 1024);
 
+    // sessionMap is used to accelerate closeSession()
+    private final ConcurrentHashMap<Long, NIOServerCnxn> sessionMap =","[{'comment': '`private final ConcurrentMap<Long, NIOServerCnxn> sessionMap = `', 'commenter': 'eribeiro'}]"
312,src/java/main/org/apache/zookeeper/server/ServerCnxn.java,"@@ -101,6 +102,13 @@ public boolean removeAuthInfo(Id id) {
 
     abstract void setSessionTimeout(int sessionTimeout);
 
+    /**
+     * Wrapper method to return the socket address
+     */
+    public InetAddress getSocketAddress() {","[{'comment': '`public abstract InetAddress getSocketAddress();`', 'commenter': 'eribeiro'}, {'comment': 'fixed. Thanks @eribeiro .', 'commenter': 'CheneySun'}]"
312,src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,"@@ -1001,25 +1010,14 @@ public String toString() {
     @Override
     public void close() {
         synchronized(factory.cnxns){","[{'comment': 'The removeCnxn already synchronizes on the cnxns so this synchronization can be removed. ', 'commenter': 'hanm'}, {'comment': 'Other than this the patch looks good. ', 'commenter': 'hanm'}, {'comment': '@CheneySun Please let me know if what you think regarding my comment about removing the excessive synchronization here. ', 'commenter': 'hanm'}, {'comment': '@hanm the synchronization is indeed excessive. already removed.', 'commenter': 'CheneySun'}]"
320,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -52,34 +52,36 @@
      * 
      * @param serverAddresses
      *            possibly unresolved ZooKeeper server addresses
-     * @throws UnknownHostException
      * @throws IllegalArgumentException
      *             if serverAddresses is empty or resolves to an empty list
      */
-    public StaticHostProvider(Collection<InetSocketAddress> serverAddresses)
-            throws UnknownHostException {
+    public StaticHostProvider(Collection<InetSocketAddress> serverAddresses) {
         for (InetSocketAddress address : serverAddresses) {
-            InetAddress ia = address.getAddress();
-            InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia!=null) ? ia.getHostAddress():
-                address.getHostName());
-            for (InetAddress resolvedAddress : resolvedAddresses) {
-                // If hostName is null but the address is not, we can tell that
-                // the hostName is an literal IP address. Then we can set the host string as the hostname
-                // safely to avoid reverse DNS lookup.
-                // As far as i know, the only way to check if the hostName is null is use toString().
-                // Both the two implementations of InetAddress are final class, so we can trust the return value of
-                // the toString() method.
-                if (resolvedAddress.toString().startsWith(""/"") 
-                        && resolvedAddress.getAddress() != null) {
-                    this.serverAddresses.add(
-                            new InetSocketAddress(InetAddress.getByAddress(
-                                    address.getHostName(),
-                                    resolvedAddress.getAddress()), 
-                                    address.getPort()));
-                } else {
-                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
-                }  
-            }
+        	try {","[{'comment': 'Indentation here is a little bit off. 4 spaces instead of 8. Please update. Other than this patch looks good.', 'commenter': 'hanm'}]"
321,src/java/main/org/apache/zookeeper/server/ZKDatabase.java,"@@ -98,6 +98,16 @@ public ZKDatabase(FileTxnSnapLog snapLog) {
         dataTree = new DataTree();
         sessionsWithTimeouts = new ConcurrentHashMap<Long, Integer>();
         this.snapLog = snapLog;
+
+        // Read system property
+        String value = System.getProperty(SNAPSHOT_SIZE_FACTOR, ""0.33"");
+        try {
+            snapshotSizeFactor = Double.parseDouble(value);
+        } catch (NumberFormatException e) {
+            LOG.error(""Error parsing "" + SNAPSHOT_SIZE_FACTOR","[{'comment': 'Please use parameterized log messages.', 'commenter': 'hanm'}]"
323,build.xml,"@@ -578,7 +578,7 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
             <fileset dir=""${java.src.dir}""/>
             <fileset dir=""${src_generated.dir}"" excludes=""**/.generated""/>
             <manifest>
-                <attribute name=""Main-Class"" value=""org.apache.zookeeper.server.quorum.QuorumPeer"" />
+                <attribute name=""Main-Class"" value=""org.apache.zookeeper.server.quorum.QuorumPeerMain"" />","[{'comment': 'does this change also need to be made on https://github.com/apache/zookeeper/pull/323/files#diff-2cccd7bf48b7a9cc113ff564acd802a8R622 (line 622)?', 'commenter': 'afine'}]"
338,src/docs/src/documentation/content/xdocs/site.xml,"@@ -52,6 +52,7 @@ See http://forrest.apache.org/docs/linking.html for more info.
       <jmx   label=""JMX""                    href=""zookeeperJMX.html"" />
       <observers label=""Observers Guide"" href=""zookeeperObservers.html"" />
       <reconfig label=""Dynamic Reconfiguration"" href=""zookeeperReconfig.html"" />
+      <reconfig label=""Audit Logging"" href=""zookeeperAuditLogs.html"" />","[{'comment': 'Shouldn\'t this be something like `<audit label=""Audit Logging"" href=""zookeeperAuditLogs.html"" />` rather than `<reconfig `?', 'commenter': 'hanm'}, {'comment': 'yes it should be <audit. Corrected it', 'commenter': 'arshadmohammad'}]"
338,src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -931,7 +931,19 @@ server.3=zoo3:2888:3888</programlisting>
               feature. Default is ""true""</para>
             </listitem>
           </varlistentry>
-
+          <varlistentry>
+            <term>audit.enabled</term>
+            <listitem>
+                <para>(Java system property:
+                    <emphasis role=""bold"">zookeeper.audit.enabled</emphasis>)
+                </para>
+                <para>
+                    <emphasis role=""bold"">New in 3.5.3:</emphasis>","[{'comment': ""This should be 3.5.4 at least. We've shipped 3.5.3 already :)"", 'commenter': 'hanm'}, {'comment': 'corrected it', 'commenter': 'arshadmohammad'}]"
338,src/docs/src/documentation/content/xdocs/zookeeperAuditLogs.xml,"@@ -0,0 +1,205 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Copyright 2002-2004 The Apache Software Foundation
+
+  Licensed under the Apache License, Version 2.0 (the ""License"");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<!DOCTYPE article PUBLIC ""-//OASIS//DTD Simplified DocBook XML V1.0//EN""
+""http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd"">
+<article id=""ar_auditLogs"">
+  <title>ZooKeeper Audit Logging</title>
+  <articleinfo>
+    <legalnotice>
+      <para>Licensed under the Apache License, Version 2.0 (the ""License"");
+      you may not use this file except in compliance with the License. You may
+      obtain a copy of the License at <ulink
+      url=""http://www.apache.org/licenses/LICENSE-2.0"">http://www.apache.org/licenses/LICENSE-2.0</ulink>.</para>
+
+      <para>Unless required by applicable law or agreed to in writing,
+      software distributed under the License is distributed on an ""AS IS""
+      BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied. See the License for the specific language governing permissions
+      and limitations under the License.</para>
+    </legalnotice>
+
+    <abstract>
+        <para>This document contains information about Audit Logs in ZooKeeper.</para>
+    </abstract>
+  </articleinfo>
+  <section id=""ch_auditLogs"">
+    <title>ZooKeeper Audit Logs</title>
+    <para>Apache ZooKeeper supports audit logs form version 3.5.3. By default audit logs are disabled. To enable audit
+    logs configure audit.enable=true in conf/zoo.cfg. Audit logs are not logged on all the ZooKeeper servers, but logged
+    only on the servers where client is connected as depicted in bellow figure.</para>
+    <mediaobject id=""fg_audit"" >
+        <imageobject>
+            <imagedata fileref=""images/zkAuditLogs.jpg""/>
+        </imageobject>
+    </mediaobject>
+    <para>The audit log captures the detailed information for the operations that are selected to be audited. The audit
+    information is written as a set of key=value pairs for the following keys</para>","[{'comment': 'Nit: missing full stop after `following keys`', 'commenter': 'hanm'}, {'comment': 'Corrected it', 'commenter': 'arshadmohammad'}]"
338,conf/log4j.properties,"@@ -63,3 +63,20 @@ log4j.appender.TRACEFILE.File=${zookeeper.tracelog.dir}/${zookeeper.tracelog.fil
 log4j.appender.TRACEFILE.layout=org.apache.log4j.PatternLayout
 ### Notice we are including log4j's NDC here (%x)
 log4j.appender.TRACEFILE.layout.ConversionPattern=%d{ISO8601} [myid:%X{myid}] - %-5p [%t:%C{1}@%L][%x] - %m%n
+#
+# zk audit logging
+#
+zookeeper.auditlog.file=zookeeper_audit.log
+zookeeper.auditlog.threshold=INFO
+audit.logger=INFO, RFAAUDIT
+log4j.logger.org.apache.zookeeper.audit.ZKAuditLogger=${audit.logger}
+log4j.additivity.org.apache.zookeeper.audit.ZKAuditLogger=false
+log4j.appender.RFAAUDIT=org.apache.log4j.RollingFileAppender","[{'comment': ""I'm sure this is a very dumb question, why is this called RFAAUDIT?"", 'commenter': 'afine'}]"
338,conf/log4j.properties,"@@ -63,3 +63,20 @@ log4j.appender.TRACEFILE.File=${zookeeper.tracelog.dir}/${zookeeper.tracelog.fil
 log4j.appender.TRACEFILE.layout=org.apache.log4j.PatternLayout
 ### Notice we are including log4j's NDC here (%x)
 log4j.appender.TRACEFILE.layout.ConversionPattern=%d{ISO8601} [myid:%X{myid}] - %-5p [%t:%C{1}@%L][%x] - %m%n
+#
+# zk audit logging
+#
+zookeeper.auditlog.file=zookeeper_audit.log
+zookeeper.auditlog.threshold=INFO
+audit.logger=INFO, RFAAUDIT
+log4j.logger.org.apache.zookeeper.audit.ZKAuditLogger=${audit.logger}
+log4j.additivity.org.apache.zookeeper.audit.ZKAuditLogger=false
+log4j.appender.RFAAUDIT=org.apache.log4j.RollingFileAppender
+log4j.appender.RFAAUDIT.File=${zookeeper.log.dir}/${zookeeper.auditlog.file}
+log4j.appender.RFAAUDIT.layout=org.apache.log4j.PatternLayout
+log4j.appender.RFAAUDIT.layout.ConversionPattern=%d{ISO8601} %p %c{2}: %m%n","[{'comment': ""Why don't we use the same conversion pattern as the other log types?"", 'commenter': 'afine'}]"
338,src/docs/src/documentation/content/xdocs/index.xml,"@@ -66,6 +66,7 @@
       <li><a href=""zookeeperHierarchicalQuorums.html"">Hierarchical quorums</a></li>
       <li><a href=""zookeeperObservers.html"">Observers</a> - non-voting ensemble members that easily improve ZooKeeper's scalability</li>
       <li><a href=""zookeeperReconfig.html"">Dynamic Reconfiguration</a> - a guide on how to use dynamic reconfiguration in ZooKeeper</li>
+      <li><a href=""zookeeperAuditLogs.html"">Audit Logging</a> - a guide on how to configure audit logs in ZooKeeper Server and what contents are logged.</li>","[{'comment': 'nit: I don\'t think we need the ""and what contents are logged.""', 'commenter': 'afine'}]"
338,src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -931,7 +931,19 @@ server.3=zoo3:2888:3888</programlisting>
               feature. Default is ""true""</para>
             </listitem>
           </varlistentry>
-
+          <varlistentry>
+            <term>audit.enabled</term>
+            <listitem>
+                <para>(Java system property:
+                    <emphasis role=""bold"">zookeeper.audit.enabled</emphasis>)
+                </para>
+                <para>
+                    <emphasis role=""bold"">New in 3.5.4:</emphasis>
+                    By default audit logs are disabled. Set to ""true"" to enable this feature. Default is ""false"". See","[{'comment': ""nit: We don't need to tell the user what the default is twice."", 'commenter': 'afine'}]"
338,src/docs/src/documentation/content/xdocs/zookeeperAuditLogs.xml,"@@ -0,0 +1,205 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Copyright 2002-2004 The Apache Software Foundation
+
+  Licensed under the Apache License, Version 2.0 (the ""License"");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<!DOCTYPE article PUBLIC ""-//OASIS//DTD Simplified DocBook XML V1.0//EN""
+""http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd"">
+<article id=""ar_auditLogs"">
+  <title>ZooKeeper Audit Logging</title>
+  <articleinfo>
+    <legalnotice>
+      <para>Licensed under the Apache License, Version 2.0 (the ""License"");
+      you may not use this file except in compliance with the License. You may
+      obtain a copy of the License at <ulink
+      url=""http://www.apache.org/licenses/LICENSE-2.0"">http://www.apache.org/licenses/LICENSE-2.0</ulink>.</para>
+
+      <para>Unless required by applicable law or agreed to in writing,
+      software distributed under the License is distributed on an ""AS IS""
+      BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied. See the License for the specific language governing permissions
+      and limitations under the License.</para>
+    </legalnotice>
+
+    <abstract>
+        <para>This document contains information about Audit Logs in ZooKeeper.</para>
+    </abstract>
+  </articleinfo>
+  <section id=""ch_auditLogs"">
+    <title>ZooKeeper Audit Logs</title>
+    <para>Apache ZooKeeper supports audit logs form version 3.5.4. By default audit logs are disabled. To enable audit","[{'comment': '""from version""', 'commenter': 'afine'}]"
338,src/docs/src/documentation/content/xdocs/zookeeperAuditLogs.xml,"@@ -0,0 +1,205 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Copyright 2002-2004 The Apache Software Foundation
+
+  Licensed under the Apache License, Version 2.0 (the ""License"");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<!DOCTYPE article PUBLIC ""-//OASIS//DTD Simplified DocBook XML V1.0//EN""
+""http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd"">
+<article id=""ar_auditLogs"">
+  <title>ZooKeeper Audit Logging</title>
+  <articleinfo>
+    <legalnotice>
+      <para>Licensed under the Apache License, Version 2.0 (the ""License"");
+      you may not use this file except in compliance with the License. You may
+      obtain a copy of the License at <ulink
+      url=""http://www.apache.org/licenses/LICENSE-2.0"">http://www.apache.org/licenses/LICENSE-2.0</ulink>.</para>
+
+      <para>Unless required by applicable law or agreed to in writing,
+      software distributed under the License is distributed on an ""AS IS""
+      BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied. See the License for the specific language governing permissions
+      and limitations under the License.</para>
+    </legalnotice>
+
+    <abstract>
+        <para>This document contains information about Audit Logs in ZooKeeper.</para>
+    </abstract>
+  </articleinfo>
+  <section id=""ch_auditLogs"">
+    <title>ZooKeeper Audit Logs</title>
+    <para>Apache ZooKeeper supports audit logs form version 3.5.4. By default audit logs are disabled. To enable audit
+    logs configure audit.enable=true in conf/zoo.cfg. Audit logs are not logged on all the ZooKeeper servers, but logged
+    only on the servers where client is connected as depicted in bellow figure.</para>","[{'comment': '""where a client is connected as depicted below"" (no need for figure)', 'commenter': 'afine'}]"
338,src/docs/src/documentation/content/xdocs/zookeeperAuditLogs.xml,"@@ -0,0 +1,205 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Copyright 2002-2004 The Apache Software Foundation
+
+  Licensed under the Apache License, Version 2.0 (the ""License"");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<!DOCTYPE article PUBLIC ""-//OASIS//DTD Simplified DocBook XML V1.0//EN""
+""http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd"">
+<article id=""ar_auditLogs"">
+  <title>ZooKeeper Audit Logging</title>
+  <articleinfo>
+    <legalnotice>
+      <para>Licensed under the Apache License, Version 2.0 (the ""License"");
+      you may not use this file except in compliance with the License. You may
+      obtain a copy of the License at <ulink
+      url=""http://www.apache.org/licenses/LICENSE-2.0"">http://www.apache.org/licenses/LICENSE-2.0</ulink>.</para>
+
+      <para>Unless required by applicable law or agreed to in writing,
+      software distributed under the License is distributed on an ""AS IS""
+      BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied. See the License for the specific language governing permissions
+      and limitations under the License.</para>
+    </legalnotice>
+
+    <abstract>
+        <para>This document contains information about Audit Logs in ZooKeeper.</para>
+    </abstract>
+  </articleinfo>
+  <section id=""ch_auditLogs"">
+    <title>ZooKeeper Audit Logs</title>
+    <para>Apache ZooKeeper supports audit logs form version 3.5.4. By default audit logs are disabled. To enable audit
+    logs configure audit.enable=true in conf/zoo.cfg. Audit logs are not logged on all the ZooKeeper servers, but logged
+    only on the servers where client is connected as depicted in bellow figure.</para>
+    <mediaobject id=""fg_audit"" >
+        <imageobject>
+            <imagedata fileref=""images/zkAuditLogs.jpg""/>
+        </imageobject>
+    </mediaobject>
+    <para>The audit log captures the detailed information for the operations that are selected to be audited. The audit","[{'comment': '""captures detailed information""', 'commenter': 'afine'}]"
338,src/docs/src/documentation/content/xdocs/zookeeperAuditLogs.xml,"@@ -0,0 +1,205 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Copyright 2002-2004 The Apache Software Foundation
+
+  Licensed under the Apache License, Version 2.0 (the ""License"");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<!DOCTYPE article PUBLIC ""-//OASIS//DTD Simplified DocBook XML V1.0//EN""
+""http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd"">
+<article id=""ar_auditLogs"">
+  <title>ZooKeeper Audit Logging</title>
+  <articleinfo>
+    <legalnotice>
+      <para>Licensed under the Apache License, Version 2.0 (the ""License"");
+      you may not use this file except in compliance with the License. You may
+      obtain a copy of the License at <ulink
+      url=""http://www.apache.org/licenses/LICENSE-2.0"">http://www.apache.org/licenses/LICENSE-2.0</ulink>.</para>
+
+      <para>Unless required by applicable law or agreed to in writing,
+      software distributed under the License is distributed on an ""AS IS""
+      BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied. See the License for the specific language governing permissions
+      and limitations under the License.</para>
+    </legalnotice>
+
+    <abstract>
+        <para>This document contains information about Audit Logs in ZooKeeper.</para>
+    </abstract>
+  </articleinfo>
+  <section id=""ch_auditLogs"">
+    <title>ZooKeeper Audit Logs</title>
+    <para>Apache ZooKeeper supports audit logs form version 3.5.4. By default audit logs are disabled. To enable audit
+    logs configure audit.enable=true in conf/zoo.cfg. Audit logs are not logged on all the ZooKeeper servers, but logged
+    only on the servers where client is connected as depicted in bellow figure.</para>
+    <mediaobject id=""fg_audit"" >
+        <imageobject>
+            <imagedata fileref=""images/zkAuditLogs.jpg""/>
+        </imageobject>
+    </mediaobject>
+    <para>The audit log captures the detailed information for the operations that are selected to be audited. The audit
+    information is written as a set of key=value pairs for the following keys.</para>
+    <table>
+        <title>Audit Log Content</title>
+        <tgroup cols=""5"" align=""left"" colsep=""1"" rowsep=""4"">
+            <thead>
+                <row>
+                    <entry>Key</entry>
+                    <entry>Value</entry>
+                </row>
+            </thead>
+            <tbody>
+                <row>
+                    <entry>session</entry>
+                    <entry>client session id</entry>
+                </row>
+                <row>
+                    <entry>user</entry>
+                    <entry>
+                        comma separated list of users who are associate with a client session. To know who is taken as user in audit logs","[{'comment': '""Comma separated list of users associated with a client session."" \r\n\r\nI\'m not sure I understand the second sentence, can you clarify?', 'commenter': 'afine'}]"
338,src/docs/src/documentation/content/xdocs/zookeeperAuditLogs.xml,"@@ -0,0 +1,205 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Copyright 2002-2004 The Apache Software Foundation
+
+  Licensed under the Apache License, Version 2.0 (the ""License"");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<!DOCTYPE article PUBLIC ""-//OASIS//DTD Simplified DocBook XML V1.0//EN""
+""http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd"">
+<article id=""ar_auditLogs"">
+  <title>ZooKeeper Audit Logging</title>
+  <articleinfo>
+    <legalnotice>
+      <para>Licensed under the Apache License, Version 2.0 (the ""License"");
+      you may not use this file except in compliance with the License. You may
+      obtain a copy of the License at <ulink
+      url=""http://www.apache.org/licenses/LICENSE-2.0"">http://www.apache.org/licenses/LICENSE-2.0</ulink>.</para>
+
+      <para>Unless required by applicable law or agreed to in writing,
+      software distributed under the License is distributed on an ""AS IS""
+      BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied. See the License for the specific language governing permissions
+      and limitations under the License.</para>
+    </legalnotice>
+
+    <abstract>
+        <para>This document contains information about Audit Logs in ZooKeeper.</para>
+    </abstract>
+  </articleinfo>
+  <section id=""ch_auditLogs"">
+    <title>ZooKeeper Audit Logs</title>
+    <para>Apache ZooKeeper supports audit logs form version 3.5.4. By default audit logs are disabled. To enable audit
+    logs configure audit.enable=true in conf/zoo.cfg. Audit logs are not logged on all the ZooKeeper servers, but logged
+    only on the servers where client is connected as depicted in bellow figure.</para>
+    <mediaobject id=""fg_audit"" >
+        <imageobject>
+            <imagedata fileref=""images/zkAuditLogs.jpg""/>
+        </imageobject>
+    </mediaobject>
+    <para>The audit log captures the detailed information for the operations that are selected to be audited. The audit
+    information is written as a set of key=value pairs for the following keys.</para>
+    <table>
+        <title>Audit Log Content</title>
+        <tgroup cols=""5"" align=""left"" colsep=""1"" rowsep=""4"">
+            <thead>
+                <row>
+                    <entry>Key</entry>
+                    <entry>Value</entry>
+                </row>
+            </thead>
+            <tbody>
+                <row>
+                    <entry>session</entry>
+                    <entry>client session id</entry>
+                </row>
+                <row>
+                    <entry>user</entry>
+                    <entry>
+                        comma separated list of users who are associate with a client session. To know who is taken as user in audit logs
+                        refer section
+                        <xref linkend=""ch_zkAuditUser""/>
+                    </entry>
+                </row>
+                <row>
+                    <entry>ip</entry>
+                    <entry>client IP address</entry>","[{'comment': 'nit: We should consistently capitalize the first letter of the first word in these descriptions.', 'commenter': 'afine'}]"
338,src/docs/src/documentation/content/xdocs/zookeeperAuditLogs.xml,"@@ -0,0 +1,205 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Copyright 2002-2004 The Apache Software Foundation
+
+  Licensed under the Apache License, Version 2.0 (the ""License"");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<!DOCTYPE article PUBLIC ""-//OASIS//DTD Simplified DocBook XML V1.0//EN""
+""http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd"">
+<article id=""ar_auditLogs"">
+  <title>ZooKeeper Audit Logging</title>
+  <articleinfo>
+    <legalnotice>
+      <para>Licensed under the Apache License, Version 2.0 (the ""License"");
+      you may not use this file except in compliance with the License. You may
+      obtain a copy of the License at <ulink
+      url=""http://www.apache.org/licenses/LICENSE-2.0"">http://www.apache.org/licenses/LICENSE-2.0</ulink>.</para>
+
+      <para>Unless required by applicable law or agreed to in writing,
+      software distributed under the License is distributed on an ""AS IS""
+      BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied. See the License for the specific language governing permissions
+      and limitations under the License.</para>
+    </legalnotice>
+
+    <abstract>
+        <para>This document contains information about Audit Logs in ZooKeeper.</para>
+    </abstract>
+  </articleinfo>
+  <section id=""ch_auditLogs"">
+    <title>ZooKeeper Audit Logs</title>
+    <para>Apache ZooKeeper supports audit logs form version 3.5.4. By default audit logs are disabled. To enable audit
+    logs configure audit.enable=true in conf/zoo.cfg. Audit logs are not logged on all the ZooKeeper servers, but logged
+    only on the servers where client is connected as depicted in bellow figure.</para>
+    <mediaobject id=""fg_audit"" >
+        <imageobject>
+            <imagedata fileref=""images/zkAuditLogs.jpg""/>
+        </imageobject>
+    </mediaobject>
+    <para>The audit log captures the detailed information for the operations that are selected to be audited. The audit
+    information is written as a set of key=value pairs for the following keys.</para>
+    <table>
+        <title>Audit Log Content</title>
+        <tgroup cols=""5"" align=""left"" colsep=""1"" rowsep=""4"">
+            <thead>
+                <row>
+                    <entry>Key</entry>
+                    <entry>Value</entry>
+                </row>
+            </thead>
+            <tbody>
+                <row>
+                    <entry>session</entry>
+                    <entry>client session id</entry>
+                </row>
+                <row>
+                    <entry>user</entry>
+                    <entry>
+                        comma separated list of users who are associate with a client session. To know who is taken as user in audit logs
+                        refer section
+                        <xref linkend=""ch_zkAuditUser""/>
+                    </entry>
+                </row>
+                <row>
+                    <entry>ip</entry>
+                    <entry>client IP address</entry>
+                </row>
+                <row>
+                    <entry>operation</entry>
+                    <entry>any one of the selected operations for audit. Possible values are
+                        (serverStart| serverStop| create| delete| setData| setAcl| multiOperation| reconfig| ephemeralZNodeDeleteOnSessionClose)
+                    </entry>
+                </row>
+                <row>
+                    <entry>znode</entry>
+                    <entry>path of the znode</entry>
+                </row>
+                <row>
+                    <entry>acl</entry>
+                    <entry>String representation of znode ACL like cdrwa(create, delete,read, write, admin). This is logged
+                        only for setAcl operation</entry>","[{'comment': 'for the setAcl operation', 'commenter': 'afine'}]"
338,src/docs/src/documentation/content/xdocs/zookeeperAuditLogs.xml,"@@ -0,0 +1,205 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Copyright 2002-2004 The Apache Software Foundation
+
+  Licensed under the Apache License, Version 2.0 (the ""License"");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<!DOCTYPE article PUBLIC ""-//OASIS//DTD Simplified DocBook XML V1.0//EN""
+""http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd"">
+<article id=""ar_auditLogs"">
+  <title>ZooKeeper Audit Logging</title>
+  <articleinfo>
+    <legalnotice>
+      <para>Licensed under the Apache License, Version 2.0 (the ""License"");
+      you may not use this file except in compliance with the License. You may
+      obtain a copy of the License at <ulink
+      url=""http://www.apache.org/licenses/LICENSE-2.0"">http://www.apache.org/licenses/LICENSE-2.0</ulink>.</para>
+
+      <para>Unless required by applicable law or agreed to in writing,
+      software distributed under the License is distributed on an ""AS IS""
+      BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied. See the License for the specific language governing permissions
+      and limitations under the License.</para>
+    </legalnotice>
+
+    <abstract>
+        <para>This document contains information about Audit Logs in ZooKeeper.</para>
+    </abstract>
+  </articleinfo>
+  <section id=""ch_auditLogs"">
+    <title>ZooKeeper Audit Logs</title>
+    <para>Apache ZooKeeper supports audit logs form version 3.5.4. By default audit logs are disabled. To enable audit
+    logs configure audit.enable=true in conf/zoo.cfg. Audit logs are not logged on all the ZooKeeper servers, but logged
+    only on the servers where client is connected as depicted in bellow figure.</para>
+    <mediaobject id=""fg_audit"" >
+        <imageobject>
+            <imagedata fileref=""images/zkAuditLogs.jpg""/>
+        </imageobject>
+    </mediaobject>
+    <para>The audit log captures the detailed information for the operations that are selected to be audited. The audit
+    information is written as a set of key=value pairs for the following keys.</para>
+    <table>
+        <title>Audit Log Content</title>
+        <tgroup cols=""5"" align=""left"" colsep=""1"" rowsep=""4"">
+            <thead>
+                <row>
+                    <entry>Key</entry>
+                    <entry>Value</entry>
+                </row>
+            </thead>
+            <tbody>
+                <row>
+                    <entry>session</entry>
+                    <entry>client session id</entry>
+                </row>
+                <row>
+                    <entry>user</entry>
+                    <entry>
+                        comma separated list of users who are associate with a client session. To know who is taken as user in audit logs
+                        refer section
+                        <xref linkend=""ch_zkAuditUser""/>
+                    </entry>
+                </row>
+                <row>
+                    <entry>ip</entry>
+                    <entry>client IP address</entry>
+                </row>
+                <row>
+                    <entry>operation</entry>
+                    <entry>any one of the selected operations for audit. Possible values are
+                        (serverStart| serverStop| create| delete| setData| setAcl| multiOperation| reconfig| ephemeralZNodeDeleteOnSessionClose)
+                    </entry>
+                </row>
+                <row>
+                    <entry>znode</entry>
+                    <entry>path of the znode</entry>
+                </row>
+                <row>
+                    <entry>acl</entry>
+                    <entry>String representation of znode ACL like cdrwa(create, delete,read, write, admin). This is logged
+                        only for setAcl operation</entry>
+                </row>
+                <row>
+                    <entry>result</entry>
+                    <entry>result of the operation. Possible values are (success|failure|invoked). Result ""invoked"" is used","[{'comment': '""is only used"" may be clearer (if correct)', 'commenter': 'afine'}]"
338,src/docs/src/documentation/content/xdocs/zookeeperAuditLogs.xml,"@@ -0,0 +1,205 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Copyright 2002-2004 The Apache Software Foundation
+
+  Licensed under the Apache License, Version 2.0 (the ""License"");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<!DOCTYPE article PUBLIC ""-//OASIS//DTD Simplified DocBook XML V1.0//EN""
+""http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd"">
+<article id=""ar_auditLogs"">
+  <title>ZooKeeper Audit Logging</title>
+  <articleinfo>
+    <legalnotice>
+      <para>Licensed under the Apache License, Version 2.0 (the ""License"");
+      you may not use this file except in compliance with the License. You may
+      obtain a copy of the License at <ulink
+      url=""http://www.apache.org/licenses/LICENSE-2.0"">http://www.apache.org/licenses/LICENSE-2.0</ulink>.</para>
+
+      <para>Unless required by applicable law or agreed to in writing,
+      software distributed under the License is distributed on an ""AS IS""
+      BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied. See the License for the specific language governing permissions
+      and limitations under the License.</para>
+    </legalnotice>
+
+    <abstract>
+        <para>This document contains information about Audit Logs in ZooKeeper.</para>
+    </abstract>
+  </articleinfo>
+  <section id=""ch_auditLogs"">
+    <title>ZooKeeper Audit Logs</title>
+    <para>Apache ZooKeeper supports audit logs form version 3.5.4. By default audit logs are disabled. To enable audit
+    logs configure audit.enable=true in conf/zoo.cfg. Audit logs are not logged on all the ZooKeeper servers, but logged
+    only on the servers where client is connected as depicted in bellow figure.</para>
+    <mediaobject id=""fg_audit"" >
+        <imageobject>
+            <imagedata fileref=""images/zkAuditLogs.jpg""/>
+        </imageobject>
+    </mediaobject>
+    <para>The audit log captures the detailed information for the operations that are selected to be audited. The audit
+    information is written as a set of key=value pairs for the following keys.</para>
+    <table>
+        <title>Audit Log Content</title>
+        <tgroup cols=""5"" align=""left"" colsep=""1"" rowsep=""4"">
+            <thead>
+                <row>
+                    <entry>Key</entry>
+                    <entry>Value</entry>
+                </row>
+            </thead>
+            <tbody>
+                <row>
+                    <entry>session</entry>
+                    <entry>client session id</entry>
+                </row>
+                <row>
+                    <entry>user</entry>
+                    <entry>
+                        comma separated list of users who are associate with a client session. To know who is taken as user in audit logs
+                        refer section
+                        <xref linkend=""ch_zkAuditUser""/>
+                    </entry>
+                </row>
+                <row>
+                    <entry>ip</entry>
+                    <entry>client IP address</entry>
+                </row>
+                <row>
+                    <entry>operation</entry>
+                    <entry>any one of the selected operations for audit. Possible values are
+                        (serverStart| serverStop| create| delete| setData| setAcl| multiOperation| reconfig| ephemeralZNodeDeleteOnSessionClose)
+                    </entry>
+                </row>
+                <row>
+                    <entry>znode</entry>
+                    <entry>path of the znode</entry>
+                </row>
+                <row>
+                    <entry>acl</entry>
+                    <entry>String representation of znode ACL like cdrwa(create, delete,read, write, admin). This is logged
+                        only for setAcl operation</entry>
+                </row>
+                <row>
+                    <entry>result</entry>
+                    <entry>result of the operation. Possible values are (success|failure|invoked). Result ""invoked"" is used
+                        for serverStop operation because stop is logged before ensuring that server actually stopped.
+                    </entry>
+                </row>
+            </tbody>
+        </tgroup>
+    </table>
+    <para>Below are sample audit logs for all operations, where client is connected from 192.168.1.2, client principal is
+        zkcli@HADOOP.COM, server principal is zookeeper/192.168.1.3@HADOOP.COM</para>
+    <programlisting>
+        user=zookeeper/192.168.1.3 operation=serverStart   result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/a    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/a    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setData   znode=/a    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setData   znode=/a    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setAcl    znode=/a    acl=world:anyone:cdrwa  result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setAcl    znode=/a    acl=world:anyone:cdrwa  result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/b    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setData   znode=/b    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=delete    znode=/b    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=multiOperation    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=delete    znode=/a    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=delete    znode=/a    result=success
+        session=0x19344730001   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/ephemral result=success
+        session=0x19344730001   user=zookeeper/192.168.1.3   operation=ephemeralZNodeDeletionOnSessionCloseOrExpire  znode=/ephemral result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=reconfig  znode=/zookeeper/config result=success
+        user=zookeeper/192.168.1.3 operation=serverStop    result=invoked
+    </programlisting>
+  </section>
+  <section id=""ch_auditConfig"">
+    <title>ZooKeeper Audit Log Configuration</title>
+    <para>By default audit logs are disabled. To enable audit logs configure audit.enable=true in conf/zoo.cfg. Audit
+        logging is done using log4j. Following is the default log4j configuration for audit logs in conf/log4j.properties
+    </para>
+    <programlisting>
+        #","[{'comment': ""It's a little concerning to repeat this code in two places and things could get out of sync if this code is changed. Do we really need to have it in the documentation?"", 'commenter': 'afine'}]"
338,src/docs/src/documentation/content/xdocs/zookeeperAuditLogs.xml,"@@ -0,0 +1,205 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Copyright 2002-2004 The Apache Software Foundation
+
+  Licensed under the Apache License, Version 2.0 (the ""License"");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<!DOCTYPE article PUBLIC ""-//OASIS//DTD Simplified DocBook XML V1.0//EN""
+""http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd"">
+<article id=""ar_auditLogs"">
+  <title>ZooKeeper Audit Logging</title>
+  <articleinfo>
+    <legalnotice>
+      <para>Licensed under the Apache License, Version 2.0 (the ""License"");
+      you may not use this file except in compliance with the License. You may
+      obtain a copy of the License at <ulink
+      url=""http://www.apache.org/licenses/LICENSE-2.0"">http://www.apache.org/licenses/LICENSE-2.0</ulink>.</para>
+
+      <para>Unless required by applicable law or agreed to in writing,
+      software distributed under the License is distributed on an ""AS IS""
+      BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied. See the License for the specific language governing permissions
+      and limitations under the License.</para>
+    </legalnotice>
+
+    <abstract>
+        <para>This document contains information about Audit Logs in ZooKeeper.</para>
+    </abstract>
+  </articleinfo>
+  <section id=""ch_auditLogs"">
+    <title>ZooKeeper Audit Logs</title>
+    <para>Apache ZooKeeper supports audit logs form version 3.5.4. By default audit logs are disabled. To enable audit
+    logs configure audit.enable=true in conf/zoo.cfg. Audit logs are not logged on all the ZooKeeper servers, but logged
+    only on the servers where client is connected as depicted in bellow figure.</para>
+    <mediaobject id=""fg_audit"" >
+        <imageobject>
+            <imagedata fileref=""images/zkAuditLogs.jpg""/>
+        </imageobject>
+    </mediaobject>
+    <para>The audit log captures the detailed information for the operations that are selected to be audited. The audit
+    information is written as a set of key=value pairs for the following keys.</para>
+    <table>
+        <title>Audit Log Content</title>
+        <tgroup cols=""5"" align=""left"" colsep=""1"" rowsep=""4"">
+            <thead>
+                <row>
+                    <entry>Key</entry>
+                    <entry>Value</entry>
+                </row>
+            </thead>
+            <tbody>
+                <row>
+                    <entry>session</entry>
+                    <entry>client session id</entry>
+                </row>
+                <row>
+                    <entry>user</entry>
+                    <entry>
+                        comma separated list of users who are associate with a client session. To know who is taken as user in audit logs
+                        refer section
+                        <xref linkend=""ch_zkAuditUser""/>
+                    </entry>
+                </row>
+                <row>
+                    <entry>ip</entry>
+                    <entry>client IP address</entry>
+                </row>
+                <row>
+                    <entry>operation</entry>
+                    <entry>any one of the selected operations for audit. Possible values are
+                        (serverStart| serverStop| create| delete| setData| setAcl| multiOperation| reconfig| ephemeralZNodeDeleteOnSessionClose)
+                    </entry>
+                </row>
+                <row>
+                    <entry>znode</entry>
+                    <entry>path of the znode</entry>
+                </row>
+                <row>
+                    <entry>acl</entry>
+                    <entry>String representation of znode ACL like cdrwa(create, delete,read, write, admin). This is logged
+                        only for setAcl operation</entry>
+                </row>
+                <row>
+                    <entry>result</entry>
+                    <entry>result of the operation. Possible values are (success|failure|invoked). Result ""invoked"" is used
+                        for serverStop operation because stop is logged before ensuring that server actually stopped.
+                    </entry>
+                </row>
+            </tbody>
+        </tgroup>
+    </table>
+    <para>Below are sample audit logs for all operations, where client is connected from 192.168.1.2, client principal is
+        zkcli@HADOOP.COM, server principal is zookeeper/192.168.1.3@HADOOP.COM</para>
+    <programlisting>
+        user=zookeeper/192.168.1.3 operation=serverStart   result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/a    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/a    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setData   znode=/a    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setData   znode=/a    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setAcl    znode=/a    acl=world:anyone:cdrwa  result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setAcl    znode=/a    acl=world:anyone:cdrwa  result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/b    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setData   znode=/b    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=delete    znode=/b    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=multiOperation    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=delete    znode=/a    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=delete    znode=/a    result=success
+        session=0x19344730001   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/ephemral result=success
+        session=0x19344730001   user=zookeeper/192.168.1.3   operation=ephemeralZNodeDeletionOnSessionCloseOrExpire  znode=/ephemral result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=reconfig  znode=/zookeeper/config result=success
+        user=zookeeper/192.168.1.3 operation=serverStop    result=invoked
+    </programlisting>
+  </section>
+  <section id=""ch_auditConfig"">
+    <title>ZooKeeper Audit Log Configuration</title>
+    <para>By default audit logs are disabled. To enable audit logs configure audit.enable=true in conf/zoo.cfg. Audit
+        logging is done using log4j. Following is the default log4j configuration for audit logs in conf/log4j.properties
+    </para>
+    <programlisting>
+        #
+        # zk audit logging
+        #
+        zookeeper.auditlog.file=zookeeper_audit.log
+        zookeeper.auditlog.threshold=INFO
+        audit.logger=INFO, RFAAUDIT
+        log4j.logger.org.apache.zookeeper.audit.ZKAuditLogger=${audit.logger}
+        log4j.additivity.org.apache.zookeeper.audit.ZKAuditLogger=false
+        log4j.appender.RFAAUDIT=org.apache.log4j.RollingFileAppender
+        log4j.appender.RFAAUDIT.File=${zookeeper.log.dir}/${zookeeper.auditlog.file}
+        log4j.appender.RFAAUDIT.layout=org.apache.log4j.PatternLayout
+        log4j.appender.RFAAUDIT.layout.ConversionPattern=%d{ISO8601} %p %c{2}: %m%n
+        log4j.appender.RFAAUDIT.Threshold=${zookeeper.auditlog.threshold}
+
+        # Max log file size of 10MB
+        log4j.appender.RFAAUDIT.MaxFileSize=10MB
+        log4j.appender.RFAAUDIT.MaxBackupIndex=10
+    </programlisting>
+    <para>Change above configuration to customize the auditlog file, number of backups, max file size etc.</para>
+  </section>
+  <section id=""ch_zkAuditUser"">
+    <title>Who is taken as user in audit logs?</title>","[{'comment': 'I\'m still a little confused by what is meant by ""taken as user"". If I\'m understanding correctly, it may be a little clearer to say ""How is the user determined for the audit logs?""', 'commenter': 'afine'}]"
338,src/docs/src/documentation/content/xdocs/zookeeperAuditLogs.xml,"@@ -0,0 +1,205 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Copyright 2002-2004 The Apache Software Foundation
+
+  Licensed under the Apache License, Version 2.0 (the ""License"");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<!DOCTYPE article PUBLIC ""-//OASIS//DTD Simplified DocBook XML V1.0//EN""
+""http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd"">
+<article id=""ar_auditLogs"">
+  <title>ZooKeeper Audit Logging</title>
+  <articleinfo>
+    <legalnotice>
+      <para>Licensed under the Apache License, Version 2.0 (the ""License"");
+      you may not use this file except in compliance with the License. You may
+      obtain a copy of the License at <ulink
+      url=""http://www.apache.org/licenses/LICENSE-2.0"">http://www.apache.org/licenses/LICENSE-2.0</ulink>.</para>
+
+      <para>Unless required by applicable law or agreed to in writing,
+      software distributed under the License is distributed on an ""AS IS""
+      BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied. See the License for the specific language governing permissions
+      and limitations under the License.</para>
+    </legalnotice>
+
+    <abstract>
+        <para>This document contains information about Audit Logs in ZooKeeper.</para>
+    </abstract>
+  </articleinfo>
+  <section id=""ch_auditLogs"">
+    <title>ZooKeeper Audit Logs</title>
+    <para>Apache ZooKeeper supports audit logs form version 3.5.4. By default audit logs are disabled. To enable audit
+    logs configure audit.enable=true in conf/zoo.cfg. Audit logs are not logged on all the ZooKeeper servers, but logged
+    only on the servers where client is connected as depicted in bellow figure.</para>
+    <mediaobject id=""fg_audit"" >
+        <imageobject>
+            <imagedata fileref=""images/zkAuditLogs.jpg""/>
+        </imageobject>
+    </mediaobject>
+    <para>The audit log captures the detailed information for the operations that are selected to be audited. The audit
+    information is written as a set of key=value pairs for the following keys.</para>
+    <table>
+        <title>Audit Log Content</title>
+        <tgroup cols=""5"" align=""left"" colsep=""1"" rowsep=""4"">
+            <thead>
+                <row>
+                    <entry>Key</entry>
+                    <entry>Value</entry>
+                </row>
+            </thead>
+            <tbody>
+                <row>
+                    <entry>session</entry>
+                    <entry>client session id</entry>
+                </row>
+                <row>
+                    <entry>user</entry>
+                    <entry>
+                        comma separated list of users who are associate with a client session. To know who is taken as user in audit logs
+                        refer section
+                        <xref linkend=""ch_zkAuditUser""/>
+                    </entry>
+                </row>
+                <row>
+                    <entry>ip</entry>
+                    <entry>client IP address</entry>
+                </row>
+                <row>
+                    <entry>operation</entry>
+                    <entry>any one of the selected operations for audit. Possible values are
+                        (serverStart| serverStop| create| delete| setData| setAcl| multiOperation| reconfig| ephemeralZNodeDeleteOnSessionClose)
+                    </entry>
+                </row>
+                <row>
+                    <entry>znode</entry>
+                    <entry>path of the znode</entry>
+                </row>
+                <row>
+                    <entry>acl</entry>
+                    <entry>String representation of znode ACL like cdrwa(create, delete,read, write, admin). This is logged
+                        only for setAcl operation</entry>
+                </row>
+                <row>
+                    <entry>result</entry>
+                    <entry>result of the operation. Possible values are (success|failure|invoked). Result ""invoked"" is used
+                        for serverStop operation because stop is logged before ensuring that server actually stopped.
+                    </entry>
+                </row>
+            </tbody>
+        </tgroup>
+    </table>
+    <para>Below are sample audit logs for all operations, where client is connected from 192.168.1.2, client principal is
+        zkcli@HADOOP.COM, server principal is zookeeper/192.168.1.3@HADOOP.COM</para>
+    <programlisting>
+        user=zookeeper/192.168.1.3 operation=serverStart   result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/a    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/a    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setData   znode=/a    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setData   znode=/a    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setAcl    znode=/a    acl=world:anyone:cdrwa  result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setAcl    znode=/a    acl=world:anyone:cdrwa  result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/b    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setData   znode=/b    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=delete    znode=/b    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=multiOperation    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=delete    znode=/a    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=delete    znode=/a    result=success
+        session=0x19344730001   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/ephemral result=success
+        session=0x19344730001   user=zookeeper/192.168.1.3   operation=ephemeralZNodeDeletionOnSessionCloseOrExpire  znode=/ephemral result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=reconfig  znode=/zookeeper/config result=success
+        user=zookeeper/192.168.1.3 operation=serverStop    result=invoked
+    </programlisting>
+  </section>
+  <section id=""ch_auditConfig"">
+    <title>ZooKeeper Audit Log Configuration</title>
+    <para>By default audit logs are disabled. To enable audit logs configure audit.enable=true in conf/zoo.cfg. Audit
+        logging is done using log4j. Following is the default log4j configuration for audit logs in conf/log4j.properties
+    </para>
+    <programlisting>
+        #
+        # zk audit logging
+        #
+        zookeeper.auditlog.file=zookeeper_audit.log
+        zookeeper.auditlog.threshold=INFO
+        audit.logger=INFO, RFAAUDIT
+        log4j.logger.org.apache.zookeeper.audit.ZKAuditLogger=${audit.logger}
+        log4j.additivity.org.apache.zookeeper.audit.ZKAuditLogger=false
+        log4j.appender.RFAAUDIT=org.apache.log4j.RollingFileAppender
+        log4j.appender.RFAAUDIT.File=${zookeeper.log.dir}/${zookeeper.auditlog.file}
+        log4j.appender.RFAAUDIT.layout=org.apache.log4j.PatternLayout
+        log4j.appender.RFAAUDIT.layout.ConversionPattern=%d{ISO8601} %p %c{2}: %m%n
+        log4j.appender.RFAAUDIT.Threshold=${zookeeper.auditlog.threshold}
+
+        # Max log file size of 10MB
+        log4j.appender.RFAAUDIT.MaxFileSize=10MB
+        log4j.appender.RFAAUDIT.MaxBackupIndex=10
+    </programlisting>
+    <para>Change above configuration to customize the auditlog file, number of backups, max file size etc.</para>
+  </section>
+  <section id=""ch_zkAuditUser"">
+    <title>Who is taken as user in audit logs?</title>
+    <para>By default there are only four authentication provider</para>","[{'comment': '""providers""', 'commenter': 'afine'}]"
338,src/docs/src/documentation/content/xdocs/zookeeperAuditLogs.xml,"@@ -0,0 +1,205 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Copyright 2002-2004 The Apache Software Foundation
+
+  Licensed under the Apache License, Version 2.0 (the ""License"");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<!DOCTYPE article PUBLIC ""-//OASIS//DTD Simplified DocBook XML V1.0//EN""
+""http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd"">
+<article id=""ar_auditLogs"">
+  <title>ZooKeeper Audit Logging</title>
+  <articleinfo>
+    <legalnotice>
+      <para>Licensed under the Apache License, Version 2.0 (the ""License"");
+      you may not use this file except in compliance with the License. You may
+      obtain a copy of the License at <ulink
+      url=""http://www.apache.org/licenses/LICENSE-2.0"">http://www.apache.org/licenses/LICENSE-2.0</ulink>.</para>
+
+      <para>Unless required by applicable law or agreed to in writing,
+      software distributed under the License is distributed on an ""AS IS""
+      BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied. See the License for the specific language governing permissions
+      and limitations under the License.</para>
+    </legalnotice>
+
+    <abstract>
+        <para>This document contains information about Audit Logs in ZooKeeper.</para>
+    </abstract>
+  </articleinfo>
+  <section id=""ch_auditLogs"">
+    <title>ZooKeeper Audit Logs</title>
+    <para>Apache ZooKeeper supports audit logs form version 3.5.4. By default audit logs are disabled. To enable audit
+    logs configure audit.enable=true in conf/zoo.cfg. Audit logs are not logged on all the ZooKeeper servers, but logged
+    only on the servers where client is connected as depicted in bellow figure.</para>
+    <mediaobject id=""fg_audit"" >
+        <imageobject>
+            <imagedata fileref=""images/zkAuditLogs.jpg""/>
+        </imageobject>
+    </mediaobject>
+    <para>The audit log captures the detailed information for the operations that are selected to be audited. The audit
+    information is written as a set of key=value pairs for the following keys.</para>
+    <table>
+        <title>Audit Log Content</title>
+        <tgroup cols=""5"" align=""left"" colsep=""1"" rowsep=""4"">
+            <thead>
+                <row>
+                    <entry>Key</entry>
+                    <entry>Value</entry>
+                </row>
+            </thead>
+            <tbody>
+                <row>
+                    <entry>session</entry>
+                    <entry>client session id</entry>
+                </row>
+                <row>
+                    <entry>user</entry>
+                    <entry>
+                        comma separated list of users who are associate with a client session. To know who is taken as user in audit logs
+                        refer section
+                        <xref linkend=""ch_zkAuditUser""/>
+                    </entry>
+                </row>
+                <row>
+                    <entry>ip</entry>
+                    <entry>client IP address</entry>
+                </row>
+                <row>
+                    <entry>operation</entry>
+                    <entry>any one of the selected operations for audit. Possible values are
+                        (serverStart| serverStop| create| delete| setData| setAcl| multiOperation| reconfig| ephemeralZNodeDeleteOnSessionClose)
+                    </entry>
+                </row>
+                <row>
+                    <entry>znode</entry>
+                    <entry>path of the znode</entry>
+                </row>
+                <row>
+                    <entry>acl</entry>
+                    <entry>String representation of znode ACL like cdrwa(create, delete,read, write, admin). This is logged
+                        only for setAcl operation</entry>
+                </row>
+                <row>
+                    <entry>result</entry>
+                    <entry>result of the operation. Possible values are (success|failure|invoked). Result ""invoked"" is used
+                        for serverStop operation because stop is logged before ensuring that server actually stopped.
+                    </entry>
+                </row>
+            </tbody>
+        </tgroup>
+    </table>
+    <para>Below are sample audit logs for all operations, where client is connected from 192.168.1.2, client principal is
+        zkcli@HADOOP.COM, server principal is zookeeper/192.168.1.3@HADOOP.COM</para>
+    <programlisting>
+        user=zookeeper/192.168.1.3 operation=serverStart   result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/a    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/a    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setData   znode=/a    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setData   znode=/a    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setAcl    znode=/a    acl=world:anyone:cdrwa  result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setAcl    znode=/a    acl=world:anyone:cdrwa  result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/b    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=setData   znode=/b    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=delete    znode=/b    result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=multiOperation    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=delete    znode=/a    result=failure
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=delete    znode=/a    result=success
+        session=0x19344730001   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=create    znode=/ephemral result=success
+        session=0x19344730001   user=zookeeper/192.168.1.3   operation=ephemeralZNodeDeletionOnSessionCloseOrExpire  znode=/ephemral result=success
+        session=0x19344730000   user=192.168.1.2,zkcli@HADOOP.COM  ip=192.168.1.2    operation=reconfig  znode=/zookeeper/config result=success
+        user=zookeeper/192.168.1.3 operation=serverStop    result=invoked
+    </programlisting>
+  </section>
+  <section id=""ch_auditConfig"">
+    <title>ZooKeeper Audit Log Configuration</title>
+    <para>By default audit logs are disabled. To enable audit logs configure audit.enable=true in conf/zoo.cfg. Audit
+        logging is done using log4j. Following is the default log4j configuration for audit logs in conf/log4j.properties
+    </para>
+    <programlisting>
+        #
+        # zk audit logging
+        #
+        zookeeper.auditlog.file=zookeeper_audit.log
+        zookeeper.auditlog.threshold=INFO
+        audit.logger=INFO, RFAAUDIT
+        log4j.logger.org.apache.zookeeper.audit.ZKAuditLogger=${audit.logger}
+        log4j.additivity.org.apache.zookeeper.audit.ZKAuditLogger=false
+        log4j.appender.RFAAUDIT=org.apache.log4j.RollingFileAppender
+        log4j.appender.RFAAUDIT.File=${zookeeper.log.dir}/${zookeeper.auditlog.file}
+        log4j.appender.RFAAUDIT.layout=org.apache.log4j.PatternLayout
+        log4j.appender.RFAAUDIT.layout.ConversionPattern=%d{ISO8601} %p %c{2}: %m%n
+        log4j.appender.RFAAUDIT.Threshold=${zookeeper.auditlog.threshold}
+
+        # Max log file size of 10MB
+        log4j.appender.RFAAUDIT.MaxFileSize=10MB
+        log4j.appender.RFAAUDIT.MaxBackupIndex=10
+    </programlisting>
+    <para>Change above configuration to customize the auditlog file, number of backups, max file size etc.</para>
+  </section>
+  <section id=""ch_zkAuditUser"">
+    <title>Who is taken as user in audit logs?</title>
+    <para>By default there are only four authentication provider</para>
+    <itemizedlist>
+        <listitem>
+            <para>IPAuthenticationProvider</para>
+        </listitem>
+        <listitem>
+            <para>SASLAuthenticationProvider</para>
+        </listitem>
+        <listitem>
+            <para>X509AuthenticationProvider</para>
+        </listitem>
+        <listitem>
+            <para>DigestAuthenticationProvider</para>
+        </listitem>
+    </itemizedlist>
+    <para>User is decided based on the configured authentication provider.</para>","[{'comment': '""The user is determined""', 'commenter': 'afine'}]"
338,src/java/main/org/apache/zookeeper/audit/AuditConstants.java,"@@ -0,0 +1,37 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+public class AuditConstants {
+    public static final String SUCCESS = ""success"";
+    public static final String FAILURE = ""failure"";
+    // operation is performed, result is not known yet
+    public static final String INVOKED = ""invoked"";
+    public static final String KEY_VAL_SEPARATOR = ""="";
+    public static final char PAIR_SEPARATOR = '\t';
+
+    public static final String OP_START = ""serverStart"";","[{'comment': ""I'm concerned about having another listing of ZooKeeper operations. Can we possibly do something in ZooDefs that keeps these string versions of the operations closer to the Opcodes?"", 'commenter': 'afine'}]"
338,src/java/main/org/apache/zookeeper/audit/ZKAuditLogger.java,"@@ -0,0 +1,118 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ZKAuditLogger {
+    public static final String SYSPROP_AUDIT_ENABLED = ""zookeeper.audit.enabled"";
+    private static final Logger LOG = LoggerFactory.getLogger(ZKAuditLogger.class);
+    // By default audit logging is disabled
+    public static final boolean isAuditEnabled = Boolean.getBoolean(SYSPROP_AUDIT_ENABLED);
+    public static final boolean isAuditDisabled = !isAuditEnabled;","[{'comment': 'not convinced this needs to be its own variable', 'commenter': 'afine'}]"
338,src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -465,6 +490,129 @@ public void processRequest(Request request) {
         }
     }
 
+    private void addSuccessAudit(Request request,ServerCnxn cnxn, String op, String path) {
+        addSuccessAudit(request, cnxn, op, path, null);
+    }
+
+    private void addSuccessAudit(Request request,ServerCnxn cnxn, String op, String path, String acl) {
+        if (ZKAuditLogger.isAuditDisabled) {
+            return;
+        }
+        ZKAuditLogger.logSuccess(request.getUsers(), op, path, acl,
+                getSessionId(cnxn), getHostAddress(cnxn));
+    }
+
+    private void addFailureAudit(Request request,ServerCnxn cnxn, String op, String path) {
+        addFailureAudit(request, cnxn, op, path, null);
+    }
+
+    private void addFailureAudit(Request request,ServerCnxn cnxn, String op, String path, String acl) {
+        if (ZKAuditLogger.isAuditDisabled) {
+            return;
+        }
+        ZKAuditLogger.logFailure(request.getUsers(), op, path, acl,
+                getSessionId(cnxn), getHostAddress(cnxn));
+    }
+
+    private void addAuditLog(Request request, ServerCnxn cnxn, String op, String path, String acl,
+            Code err) {
+        if (ZKAuditLogger.isAuditDisabled) {
+            return;
+        }
+        if (err == Code.OK) {
+            ZKAuditLogger.logSuccess(request.getUsers(), op, path, acl, getSessionId(cnxn),
+                    getHostAddress(cnxn));
+        } else {
+            ZKAuditLogger.logFailure(request.getUsers(), op, path, acl, getSessionId(cnxn),
+                    getHostAddress(cnxn));
+        }
+    }
+
+    private String getACLs(Request request)
+    {
+        ByteBuffer reqData = request.request.duplicate();
+        reqData.rewind();
+        SetACLRequest setACLRequest = new SetACLRequest();
+        try {
+            ByteBufferInputStream.byteBuffer2Record(reqData, setACLRequest);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return ZKUtil.aclToString(setACLRequest.getAcl());
+    }
+
+    private void addFailedTxnAduitLog(Request request) {
+        if (ZKAuditLogger.isAuditDisabled) {
+            return;
+        }
+        String op = AuditConstants.OP_CREATE;
+        if (request.cnxn == null) {
+            return;
+        }
+        String path=null;
+        long sessionId = -1;
+        String address = null;
+        String acls = null;
+        boolean exceptionOccured = false;
+        ByteBuffer reqData = request.request.duplicate();
+        reqData.rewind();
+        try {
+            sessionId = request.cnxn.getSessionId();
+            switch (request.type) {
+            case OpCode.create:
+            case  OpCode.create2:
+            case  OpCode.createContainer:
+                op = AuditConstants.OP_CREATE;
+                CreateRequest createRequest = new CreateRequest();
+                ByteBufferInputStream.byteBuffer2Record(reqData, createRequest);
+                path=createRequest.getPath();
+                break;
+            case OpCode.delete:
+            case OpCode.deleteContainer:
+                op = AuditConstants.OP_DELETE;
+                //path = new String(request.request.array());
+                DeleteRequest deleteRequest = new DeleteRequest();
+                ByteBufferInputStream.byteBuffer2Record(reqData, deleteRequest);
+                path=deleteRequest.getPath();
+                break;
+            case OpCode.setData:
+                op = AuditConstants.OP_SETDATA;
+                SetDataRequest setDataRequest = new SetDataRequest();
+                ByteBufferInputStream.byteBuffer2Record(reqData, setDataRequest);
+                path=setDataRequest.getPath();
+                break;
+            case OpCode.setACL:
+                op = AuditConstants.OP_SETACL;
+                SetACLRequest setACLRequest = new SetACLRequest();
+                ByteBufferInputStream.byteBuffer2Record(reqData, setACLRequest);
+                path=setACLRequest.getPath();
+                acls = ZKUtil.aclToString(setACLRequest.getAcl());
+                break;
+            case OpCode.multi:
+                op = AuditConstants.OP_MULTI_OP;
+                break;
+            case OpCode.reconfig:
+                op = AuditConstants.OP_RECONFIG;
+                break;
+            }
+            if (request.cnxn != null
+                    && request.cnxn.getRemoteSocketAddress() != null
+                    && request.cnxn.getRemoteSocketAddress().getAddress() != null) {
+                address = request.cnxn.getRemoteSocketAddress().getAddress()
+                        .getHostAddress();
+            }
+        } catch (Throwable e) {
+            exceptionOccured = true;
+            LOG.error(""Failed to audit log request {} failure"", request.type, e);
+        }
+        if (!exceptionOccured) {
+            if (ZKAuditLogger.isAuditEnabled) {","[{'comment': 'nit: we can combine these if statements\r\n\r\nalternatively you can return in the catch block', 'commenter': 'afine'}]"
338,src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -476,6 +624,33 @@ private boolean connClosedByClient(Request request) {
         return request.cnxn == null;
     }
 
+    private String getHostAddress(ServerCnxn cnxn) {
+        try {
+            if (cnxn == null) {
+                return """";
+            }
+            InetSocketAddress remoteSocketAddress = cnxn
+                    .getRemoteSocketAddress();
+            if (remoteSocketAddress == null) {
+                return """";
+            }
+            InetAddress address = remoteSocketAddress.getAddress();
+            if (address == null) {
+                return """";
+            }
+            return address.getHostAddress();
+        } catch (Exception e) {
+            // ignore
+        }
+        return """";
+    }
+
+    private String getSessionId(ServerCnxn cnxn) {","[{'comment': 'perhaps we can move this string formatting code to somewhere more appropriate', 'commenter': 'afine'}]"
338,src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -476,6 +624,33 @@ private boolean connClosedByClient(Request request) {
         return request.cnxn == null;
     }
 
+    private String getHostAddress(ServerCnxn cnxn) {","[{'comment': 'perhaps we could do this logic in ServerCnxn?', 'commenter': 'afine'}]"
338,src/java/main/org/apache/zookeeper/server/ServerCnxnFactory.java,"@@ -54,6 +54,7 @@
      */
     static final ByteBuffer closeConn = ByteBuffer.allocate(0);
 
+    private static String loginUser = System.getProperty(""user.name"", ""<NA>"");","[{'comment': 'final?', 'commenter': 'eolivelli'}, {'comment': 'I think loginUser can not be marked as final', 'commenter': 'arshadmohammad'}]"
338,src/java/test/org/apache/zookeeper/server/util/AuthUtilTest.java,"@@ -0,0 +1,58 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server.util;
+
+import static org.junit.Assert.*;","[{'comment': 'nit: avoid * imports', 'commenter': 'afine'}]"
338,src/java/test/org/apache/zookeeper/server/util/AuthUtilTest.java,"@@ -0,0 +1,58 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server.util;
+
+import static org.junit.Assert.*;
+
+import org.apache.zookeeper.data.Id;
+import org.junit.Test;
+
+public class AuthUtilTest {
+
+    @Test
+    public void testGetUserFromAllAuthenticationScheme() {
+        System.setProperty(""zookeeper.authProvider.sasl"",","[{'comment': 'Do we have/need a test for custom authentication schemes?', 'commenter': 'afine'}]"
338,src/java/test/org/apache/zookeeper/audit/ZKAuditLoggerTest.java,"@@ -0,0 +1,377 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+import static org.apache.zookeeper.test.ClientBase.CONNECTION_TIMEOUT;
+import static org.junit.Assert.assertEquals;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.LineNumberReader;
+import java.io.StringReader;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.log4j.Layout;
+import org.apache.log4j.Level;
+import org.apache.log4j.Logger;
+import org.apache.log4j.SimpleLayout;
+import org.apache.log4j.WriterAppender;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.KeeperException.Code;
+import org.apache.zookeeper.Op;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZKUtil;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.data.ACL;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.server.Request;
+import org.apache.zookeeper.server.ServerCnxn;
+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase.MainThread;
+import org.apache.zookeeper.test.ClientBase;
+import org.apache.zookeeper.test.ClientBase.CountdownWatcher;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class ZKAuditLoggerTest extends ZKTestCase {
+    private static final Logger LOG = Logger.getLogger(ZKAuditLoggerTest.class);
+    private static int SERVER_COUNT = 3;
+    private MainThread[] mt;
+    private ZooKeeper zk;
+
+    @Test
+    public void testAuditLogs() throws Exception {","[{'comment': 'I really like this integration test. I think it would be great if it was a little more rigorous. \r\n\r\nWould it be possible to use multiple auth providers oruse multiple servers and make sure logs are only appearing on the correct server? ', 'commenter': 'afine'}]"
342,src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -1155,6 +1134,19 @@ public void run() {
         }
     }
 
+    private void electionAndSetCurVote() {
+        reconfigFlagClear();
+        if (shuttingDownLE) {
+            startLeaderElection();","[{'comment': ""How come we don't need to set shuttingDownLE back to false here?"", 'commenter': 'DanBenediktson'}, {'comment': ""oh, sorry. it's my negligence. i will fix"", 'commenter': 'bitgaoshu'}]"
342,src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -1155,6 +1134,19 @@ public void run() {
         }
     }
 
+    private void electionAndSetCurVote() {","[{'comment': 'IMHO,If you really want to refactor the code block(**Line1137-Line1149**)  **,throws Exception** may be better than catching exception in this function!', 'commenter': 'maoling'}, {'comment': 'enen, i think the exception can be appropriately handled in this function, why need to throw the exception to  caller?  :)  thanks', 'commenter': 'bitgaoshu'}]"
345,src/java/main/org/apache/zookeeper/client/ConnectStringParser.java,"@@ -20,8 +20,11 @@
 
 import java.net.InetSocketAddress;
 import java.util.ArrayList;
+import java.util.List;
 
 import org.apache.zookeeper.common.PathUtils;
+import static org.apache.zookeeper.common.StringUtils.split;
+","[{'comment': 'nit: extra empty line', 'commenter': 'afine'}, {'comment': 'afine: Removed it. please review', 'commenter': 'nikhilbhide'}]"
345,src/java/main/org/apache/zookeeper/client/ConnectStringParser.java,"@@ -20,8 +20,11 @@
 
 import java.net.InetSocketAddress;
 import java.util.ArrayList;
+import java.util.List;
 
 import org.apache.zookeeper.common.PathUtils;
+import static org.apache.zookeeper.common.StringUtils.split;","[{'comment': 'nit: I could be wrong on this, but I think in general we prefer to import classes and not static methods directly. ', 'commenter': 'afine'}, {'comment': 'Static import of individual member is allowed as it sometimes improves the readability\r\nPlease let me know your opinion on this and if required I will change it.', 'commenter': 'nikhilbhide'}, {'comment': 'This code is similar to existing one in master and branch-3.5. For consistency, we could use what kind of import it uses, imo.', 'commenter': 'eribeiro'}, {'comment': 'eribeiro: I have kept the code same, in master and branch-3.5 static method member is imported i.e import static org.apache.zookeeper.common.StringUtils.split', 'commenter': 'nikhilbhide'}, {'comment': 'eribeiro: Can you please complete the review comments? Can you please approve the changes so that patch can be created.\r\n\r\n\r\n', 'commenter': 'nikhilbhide'}]"
345,src/java/main/org/apache/zookeeper/common/StringUtils.java,"@@ -0,0 +1,44 @@
+/* Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;","[{'comment': 'nit: add a space here', 'commenter': 'afine'}, {'comment': 'afine: added required space. please review', 'commenter': 'nikhilbhide'}, {'comment': 'Hi afine: Can you please complete the review comments? Can you please approve the changes so that patch can be created.', 'commenter': 'nikhilbhide'}]"
345,src/java/test/org/apache/zookeeper/test/StringUtilTest.java,"@@ -0,0 +1,44 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.test;
+
+
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.common.StringUtils;
+import org.junit.Test;
+
+import java.util.Arrays;
+
+import static org.junit.Assert.assertEquals;
+
+public class StringUtilTest extends ZKTestCase {
+
+    @Test
+    public void testStrings() {
+
+        String s1 = ""   a  ,   b  , "";
+        assertEquals(""[a, b]"", StringUtils.split(s1, "","").toString());","[{'comment': ""I'm wondering if it would be possible to compare lists themselves rather than comparing the output of toString?"", 'commenter': 'afine'}, {'comment': 'afine: Conversion to string is required as output of StringUtils.split returns java.util.Collections$UnmodifiableRandomAccessList<[a, b]>', 'commenter': 'nikhilbhide'}, {'comment': 'What is wrong with using\r\n```\r\n  String s1 = ""   a  ,   b  , "";\r\n  List<String> expected = Arrays.asList(""a"", ""b"");\r\n  assertTrue(expected.equals(StringUtils.split(s1, "","")));\r\n```\r\n????', 'commenter': 'eribeiro'}, {'comment': 'It works, and I can change the asserts. However, I have retrofitted the test from master and branch 3.5 so is it okay to change it in this particular branch? Please let me know.', 'commenter': 'nikhilbhide'}]"
348,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -653,6 +653,9 @@ public void run() {
                                      + ""see ZOOKEEPER-2836"");
                         }
                     }
+                } catch (UnresolvedAddressException e) {                   
+                    LOG.warn(""Listener thread cannot open channel to "" + self.getId()","[{'comment': 'I think we may want to consider making this an ""error"".', 'commenter': 'afine'}]"
348,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -621,7 +621,7 @@ public Listener() {
         @Override
         public void run() {
             int numRetries = 0;
-            InetSocketAddress addr;
+            InetSocketAddress addr = null;","[{'comment': 'why is this needed?', 'commenter': 'afine'}, {'comment': '@afine \r\nfor logging the **addr** in LINE_657\r\nBTW,this pr just catches a exception,If it really needs a testcase,I will give one', 'commenter': 'maoling'}, {'comment': '@maoling I think a test case would be great because catching that exception does ""change behavior"". ', 'commenter': 'afine'}]"
349,src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -823,10 +823,10 @@ server.3=zoo3:2888:3888</programlisting>
               role=""bold"">zookeeper.snapCount</emphasis>)</para>
 
               <para>ZooKeeper logs transactions to a transaction
-              log. After snapCount transactions are written to a log
-              file a snapshot is started and a new transaction log
-              file is created. The default snapCount is
-              100,000.</para>
+              log. After the count of transactions which are written to a log
+              file exceed a runtime-set limit in [snapCount/2, snapCount),a snapshot ","[{'comment': 'I think this is an excellent documentation improvement, but we still may be able to phrase this in a clearer way. It may be good to reiterate that ZooKeeper writes to a transaction log between snapshotting here, so the reader understands the purpose of the snapCount.\r\n\r\nPerhaps something like:\r\n\r\n> ZooKeeper records its transactions using snapshots and a transaction log (think write-ahead log). The number of transactions recorded in the transaction log before a snapshot can be taken (and the transaction log rolled) is determined by snapCount. In order to prevent all of the machines in the quorum from taking a snapshot at the same time, each ZooKeeper server will take a snapshot when the number of transactions in the transaction log reaches a runtime generated random value in the [snapCount/2, snapCount) range.', 'commenter': 'afine'}, {'comment': '- awesome suggestions. especially emphasizing the purpose of this snapshot strategy is to  prevent all of the machines in the quorum from taking a snapshot at the same time\r\n- done', 'commenter': 'maoling'}]"
354,src/java/main/org/apache/jute/compiler/JRecord.java,"@@ -21,9 +21,7 @@
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
+import java.util.*;","[{'comment': 'we generally avoid using * inputs', 'commenter': 'afine'}, {'comment': 'working on the fix in my next commit', 'commenter': 'tamaashu'}]"
355,src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,"@@ -374,14 +373,12 @@ void doIO(SelectionKey k) throws InterruptedException {
             // expecting close to log session closure
             close();
         } catch (EndOfStreamException e) {
-            LOG.warn(""caught end of stream exception"",e); // tell user why
-
+            LOG.warn(e.getMessage());","[{'comment': 'Do we want to log the whole stack trace if debug is enabled here?', 'commenter': 'afine'}, {'comment': ""Yes, it would make sense to log the stack trace at debug level for EndOfStreamException too, so that we don't get less information in the log after this change is applied. The reason why I did not include it first, was to keep this change a pure backport from master and branch-3.5 to branch-3.4 as the original change does not include this additional logging statement. I've added it now, but probably then we should also add it to master as well if we wish to keep it."", 'commenter': 'Unknown'}]"
377,src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java,"@@ -84,6 +84,9 @@ public static long initializeNextSession(long id) {
         long nextSid;
         nextSid = (Time.currentElapsedTime() << 24) >>> 8;
         nextSid =  nextSid | (id <<56);
+        if (nextSid == EphemeralType.CONTAINER_EPHEMERAL_OWNER) {
+            ++nextSid;  // this is an unlikely edge case, but check it just in case","[{'comment': ""This makes me nervous but I can't think of a reason why it wont work. It may be worth changing the comment on this method because it is no longer strictly true. "", 'commenter': 'afine'}, {'comment': ""Actually it still is true. If `Time.currentElapsedTime()` returns 0 and server Id is 0x80, this will happen. That's why nextSid has to be incremented in that case."", 'commenter': 'Randgalt'}]"
377,src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -125,6 +125,8 @@
     private final ZooKeeperServerListener listener;
     private ZooKeeperServerShutdownHandler zkShutdownHandler;
 
+    private volatile boolean defaultTtlNodesEnabled = true;","[{'comment': ""for the sake of clarity, why can't this be false?"", 'commenter': 'afine'}, {'comment': ""If it's false, then TTL nodes won't be available in Standalone mode."", 'commenter': 'Randgalt'}]"
377,conf/zoo_sample.cfg,"@@ -6,6 +6,10 @@ initLimit=10
 # The number of ticks that can pass between 
 # sending a request and getting an acknowledgement
 syncLimit=5
+# enable TTL Nodes
+# IMPORTANT: when enabled, your server ID cannot be greater than 254
+# See https://zookeeper.apache.org/doc/r3.5.3-beta/zookeeperAdmin.html#sc_configuration for details","[{'comment': ""Perhaps note the document and section, rather than the link? It's going to get out of date quickly."", 'commenter': 'phunt'}]"
377,conf/zoo_sample.cfg,"@@ -6,6 +6,10 @@ initLimit=10
 # The number of ticks that can pass between 
 # sending a request and getting an acknowledgement
 syncLimit=5
+# enable TTL Nodes
+# IMPORTANT: when enabled, your server ID cannot be greater than 254
+# See https://zookeeper.apache.org/doc/r3.5.3-beta/zookeeperAdmin.html#sc_configuration for details
+ttlNodesEnabled=false","[{'comment': ""I was actually thinking that this specific line (not in general) should be true by default. That way anyone starting out would get the feature enabled by default - and they wouldn't have any legacy serverids specified. What do you think?"", 'commenter': 'phunt'}]"
377,conf/zoo_sample.cfg,"@@ -6,6 +6,10 @@ initLimit=10
 # The number of ticks that can pass between 
 # sending a request and getting an acknowledgement
 syncLimit=5
+# enable TTL Nodes
+# IMPORTANT: when enabled, your server ID cannot be greater than 254","[{'comment': ""Same comment I left on the JIRA ticket: shouldn't it be 127, not 254? My understanding of the problem was that the whole high bit was being used, not the whole byte sequence of 255."", 'commenter': 'DanBenediktson'}, {'comment': ""@DanBenediktson 127 is the case with the existing bug. I re-wrote how this is handled so that now it's 254. The high bit is now used to signal that the ephemeralOwner is special. "", 'commenter': 'Randgalt'}]"
377,src/java/main/org/apache/zookeeper/server/EphemeralType.java,"@@ -40,19 +39,21 @@
     TTL;
 
     public static final long CONTAINER_EPHEMERAL_OWNER = Long.MIN_VALUE;
-    public static final long MAX_TTL = 0x0fffffffffffffffL;
-    public static final long TTL_MASK = 0x8000000000000000L;
+    public static final long MAX_TTL = 0x00ffffffffffffffL;
+    public static final long TTL_MASK = 0xff00000000000000L;
+    public static final long MAX_TTL_SERVER_ID = 0xfe;  // 254
 
     public static EphemeralType get(long ephemeralOwner) {
         if (ephemeralOwner == CONTAINER_EPHEMERAL_OWNER) {
             return CONTAINER;
         }
-        if (ephemeralOwner < 0) {
+        if ((ephemeralOwner & TTL_MASK) == TTL_MASK) {","[{'comment': 'I think this is broken. If, for example, org.apache.zookeeper.server.DataTree#deleteNode calls this method with TTL turned off, but using a server id of 255 it will end up calling this code\r\n\r\n            } else if (ephemeralType == EphemeralType.TTL) {\r\n                ttls.remove(path);\r\n\r\nand the node will not be removed properly in deleteNode.', 'commenter': 'phunt'}, {'comment': 'In particular you need to add a bunch more testing to ensure this case is working properly.', 'commenter': 'phunt'}]"
377,src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -949,14 +949,15 @@ server.3=zoo3:2888:3888</programlisting>
           </varlistentry>
 
           <varlistentry>
-            <term>ttlNodesEnabled</term>
+            <term>zookeeper.extendedTypesEnabled</term>","[{'comment': 'Do we are have any room left for this? iiuc ttls are the last, no more space left to consider addl types.\r\n\r\nMy concern here - won\'t people be confused by this, e.g. ""are containers extended types""?\r\n\r\nWhat do you think @Randgalt ?', 'commenter': 'phunt'}, {'comment': ""I only thought that we might be able to use the setting for other things in the future. But, I'm OK either way. Let me know."", 'commenter': 'Randgalt'}]"
377,src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -949,14 +949,15 @@ server.3=zoo3:2888:3888</programlisting>
           </varlistentry>
 
           <varlistentry>
-            <term>ttlNodesEnabled</term>
+            <term>zookeeper.extendedTypesEnabled</term>
 
             <listitem>
-              <para>(No Java system property)</para>
+                <para>(Java system property only: <emphasis","[{'comment': 'This is a bit confusing given QuorumPeerConfig line 326\r\n\r\n                System.setProperty(""zookeeper."" + key, value);\r\n\r\nSee the doc for forceSync for an example of a better way to set this up. (forceSync works this same way)\r\n', 'commenter': 'phunt'}]"
377,src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -476,9 +474,12 @@ public ZooKeeperServerListener getZooKeeperServerListener() {
         return listener;
     }
 
+    // Visible for testing
+    static volatile int serverId = 1;","[{'comment': 'This is really ugly. Why not using a quorum peer instead? Given you want to control the serverid.', 'commenter': 'phunt'}, {'comment': ""@phunt I'm not sure what you mean about quorum peer. I could find another way to set this value. Also, it's only for testing and clearly marked. What do you suggest?"", 'commenter': 'Randgalt'}, {'comment': ""I looked at it a bit originally, iirc I figured that you'd pass it through in some way (during instance creation) rather than making it a global."", 'commenter': 'phunt'}, {'comment': ""As I recall that was extremely difficult. Config is not shared between different parts of the code. The only way to do that type of thing is via System defines. That's why I did this."", 'commenter': 'Randgalt'}, {'comment': ""It being a global seems to kick the problem down the road to the next person. I'm worried that setting this jvm wide could have an impact when developing tests in the future. That's why it caught my eye."", 'commenter': 'phunt'}, {'comment': ""Here's the issue @phunt - `serverId` is consumed by `ZooKeeperServer.createSessionTracker()`. For tests, the ZooKeeperServer is created by the **static** method `ClientBase.startServerInstance()`. So, _I'm_ the person down the road that has to deal with the static method created long ago. It would take significant re-write for `ClientBase.startServerInstance()` to be non-static and parameterized."", 'commenter': 'Randgalt'}, {'comment': ""That said - I could probably do it. Let me know. If you think it's important I'll see what I can do."", 'commenter': 'Randgalt'}]"
377,src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -949,14 +949,15 @@ server.3=zoo3:2888:3888</programlisting>
           </varlistentry>
 
           <varlistentry>
-            <term>ttlNodesEnabled</term>
+            <term>zookeeper.extendedTypesEnabled</term>
 
             <listitem>
-              <para>(No Java system property)</para>
+                <para>(Java system property only: <emphasis
+                    role=""bold"">zookeeper.extendedTypesEnabled</emphasis>)</para>
 
-              <para><emphasis role=""bold"">New in 3.5.4, 3.6.0:</emphasis> Set to ""true"" to enable
-              the creation of <ulink url=""zookeeperProgrammers.html#TTL+Nodes"">TTL Nodes</ulink>.
-              They are disabled by default. IMPORTANT: when TTL Nodes are enabled server IDs must
+              <para><emphasis role=""bold"">New in 3.5.4, 3.6.0:</emphasis> Define to ""true"" to enable
+              extended features such as the creation of <ulink url=""zookeeperProgrammers.html#TTL+Nodes"">TTL Nodes</ulink>.","[{'comment': 'obv update this to reflect.', 'commenter': 'phunt'}]"
377,src/docs/src/documentation/content/xdocs/zookeeperProgrammers.xml,"@@ -271,9 +271,9 @@
           is not modified within the TTL and has no children it will become a candidate
           to be deleted by the server at some point in the future.</para>
 
-        <para>Note: TTL Nodes must be enabled in your ZooKeeper configuration file as
+        <para>Note: TTL Nodes must be enabled via System property as","[{'comment': 'and this.', 'commenter': 'phunt'}]"
377,src/java/main/org/apache/zookeeper/server/EphemeralType.java,"@@ -40,19 +39,40 @@
     TTL;
 
     public static final long CONTAINER_EPHEMERAL_OWNER = Long.MIN_VALUE;
-    public static final long MAX_TTL = 0x0fffffffffffffffL;
-    public static final long TTL_MASK = 0x8000000000000000L;
+    public static final long MAX_TTL = 0x00ffffffffffffffL;
+    public static final long TTL_MASK = 0xff00000000000000L;
+    public static final long MAX_TTL_SERVER_ID = 0xfe;  // 254
+
+    public static final String EXTENDED_TYPES_ENABLED_PROPERTY = ""zookeeper.extendedTypesEnabled"";
+
+    public static boolean extendedEphemeralTypesEnabled() {
+        return Boolean.getBoolean(EXTENDED_TYPES_ENABLED_PROPERTY);
+    }
 
     public static EphemeralType get(long ephemeralOwner) {
+        if ( extendedEphemeralTypesEnabled() ) {
+            if ((ephemeralOwner & TTL_MASK) == TTL_MASK) {","[{'comment': ""To keep backward compatible, shouldn't we keep use 0x80 as the TTL byte? \r\n\r\nPeople may not use sid larger than 127, it's more likely they will use the TTL with 0x80 highest byte. With this change, those nodes won't be expired anymore."", 'commenter': 'lvfangmin'}, {'comment': ""We discussed this earlier in the PR. Problem is it's b/w incompat one way or the other. Given serverid has been around forever, and TTL only added in 3.5.3 (a beta) we went forward with this approach."", 'commenter': 'phunt'}]"
377,src/java/main/org/apache/zookeeper/server/EphemeralType.java,"@@ -40,19 +39,40 @@
     TTL;
 
     public static final long CONTAINER_EPHEMERAL_OWNER = Long.MIN_VALUE;
-    public static final long MAX_TTL = 0x0fffffffffffffffL;
-    public static final long TTL_MASK = 0x8000000000000000L;
+    public static final long MAX_TTL = 0x00ffffffffffffffL;
+    public static final long TTL_MASK = 0xff00000000000000L;
+    public static final long MAX_TTL_SERVER_ID = 0xfe;  // 254
+
+    public static final String EXTENDED_TYPES_ENABLED_PROPERTY = ""zookeeper.extendedTypesEnabled"";
+
+    public static boolean extendedEphemeralTypesEnabled() {
+        return Boolean.getBoolean(EXTENDED_TYPES_ENABLED_PROPERTY);
+    }
 
     public static EphemeralType get(long ephemeralOwner) {
+        if ( extendedEphemeralTypesEnabled() ) {
+            if ((ephemeralOwner & TTL_MASK) == TTL_MASK) {
+                return TTL;
+            }
+        }
         if (ephemeralOwner == CONTAINER_EPHEMERAL_OWNER) {
             return CONTAINER;
         }
-        if (ephemeralOwner < 0) {
-            return TTL;
-        }
         return (ephemeralOwner == 0) ? VOID : NORMAL;
     }
 
+    public static void validateServerId(long serverId) {","[{'comment': 'Maybe we should not start the server if the server id is conflict with TTL feature, we can do this in QuorumPeerConfig.checkValidity.', 'commenter': 'lvfangmin'}]"
377,src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -950,6 +952,39 @@ server.3=zoo3:2888:3888</programlisting>
             </listitem>
           </varlistentry>
 
+          <varlistentry>
+            <term>zookeeper.extendedTypesEnabled</term>
+
+            <listitem>
+                <para>(Java system property only: <emphasis
+                    role=""bold"">zookeeper.extendedTypesEnabled</emphasis>)</para>
+
+              <para><emphasis role=""bold"">New in 3.5.4, 3.6.0:</emphasis> Define to ""true"" to enable
+              extended features such as the creation of <ulink url=""zookeeperProgrammers.html#TTL+Nodes"">TTL Nodes</ulink>.
+              They are disabled by default. IMPORTANT: when enabled server IDs must
+              be less than 255 due to internal limitations.
+              </para>
+            </listitem>
+          </varlistentry>
+
+          <varlistentry>
+            <term>zookeeper.emulate353TTLNodes</term>","[{'comment': ""What's the plan for deprecating this? Keeping this parameter around forever seems like a bad idea. Adds complication that we don't really need to carry around. Perhaps we can deprecate in 3.5.4 and remove in 3.5.5? Similarly I don't think we should include this at all in 3.6.0 (trunk)."", 'commenter': 'phunt'}]"
377,src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -950,6 +952,39 @@ server.3=zoo3:2888:3888</programlisting>
             </listitem>
           </varlistentry>
 
+          <varlistentry>
+            <term>zookeeper.extendedTypesEnabled</term>
+
+            <listitem>
+                <para>(Java system property only: <emphasis
+                    role=""bold"">zookeeper.extendedTypesEnabled</emphasis>)</para>
+
+              <para><emphasis role=""bold"">New in 3.5.4, 3.6.0:</emphasis> Define to ""true"" to enable
+              extended features such as the creation of <ulink url=""zookeeperProgrammers.html#TTL+Nodes"">TTL Nodes</ulink>.
+              They are disabled by default. IMPORTANT: when enabled server IDs must
+              be less than 255 due to internal limitations.
+              </para>
+            </listitem>
+          </varlistentry>
+
+          <varlistentry>
+            <term>zookeeper.emulate353TTLNodes</term>
+
+            <listitem>
+                <para>(Java system property only: <emphasis
+                    role=""bold"">zookeeper.emulate353TTLNodes</emphasis>)</para>
+
+              <para><emphasis role=""bold"">New in 3.5.4, 3.6.0:</emphasis> Due to
+                <ulink url=""https://issues.apache.org/jira/browse/ZOOKEEPER-2901"">ZOOKEEPER-2901</ulink> TTL nodes
+                created in version 3.5.3 are not supported in 3.5.4/3.6.0. However, a workaround is provided via the
+                zookeeper.emulate353TTLNodes system property. If you used TTL nodes in ZooKeeper 3.5.3 and need to maintain
+                compatibility set <emphasis role=""bold"">zookeeper.emulate353TTLNodes</emphasis> to ""true"" in addition to
+                <emphasis role=""bold"">zookeeper.extendedTypesEnabled</emphasis>. NOTE: due to the bug, server IDs
+                must be 127 or less. Additionally, the maximum support TTL value is 1099511627775 which is smaller
+                than what was allowed in 3.5.3 (1152921504606846975)</para>","[{'comment': ""Is there documentation around this? I'd recommend documenting the bounds."", 'commenter': 'phunt'}]"
377,src/java/main/org/apache/zookeeper/server/OldEphemeralType.java,"@@ -0,0 +1,74 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+/**
+ * See https://issues.apache.org/jira/browse/ZOOKEEPER-2901
+ *
+ * version 3.5.3 introduced bugs associated with how TTL nodes were implemented. version 3.5.4
+ * fixes the problems but makes TTL nodes created in 3.5.3 invalid. OldEphemeralType is a copy
+ * of the old - bad - implementation that is provided as a workaround. {@link EphemeralType#TTL_3_5_3_EMULATION_PROPERTY}
+ * can be used to emulate support of the badly specified TTL nodes.
+ */
+public enum OldEphemeralType {
+    /**
+     * Not ephemeral
+     */
+    VOID,
+    /**
+     * Standard, pre-3.5.x EPHEMERAL
+     */
+    NORMAL,
+    /**
+     * Container node
+     */
+    CONTAINER,
+    /**
+     * TTL node
+     */
+    TTL;
+
+    public static final long CONTAINER_EPHEMERAL_OWNER = Long.MIN_VALUE;
+    public static final long MAX_TTL = 0x0fffffffffffffffL;
+    public static final long TTL_MASK = 0x8000000000000000L;
+
+    public static OldEphemeralType get(long ephemeralOwner) {","[{'comment': 'Do think it has value to keep this ""old"" type in the codebase?\r\nFor backward compatibility reason I don\'t think it makes sense on a non-stable branch.\r\nIts contents only used from the ""new"" type and tests.\r\nI\'d rather put the logic which is still needed in the ""new"" type and get rid of this one completely keeping EphemeralType nice and clean.\r\nWhat do you think?', 'commenter': 'anmolnar'}, {'comment': 'We should create a new task to delete it after a while. However, I know that this will be important. Whoever used TTLs in 3.5.3 will run into problems when they upgrade. We need to have a workaround for these users.', 'commenter': 'Randgalt'}]"
377,src/java/main/org/apache/zookeeper/server/EphemeralType.java,"@@ -37,41 +77,152 @@
     /**
      * TTL node
      */
-    TTL;
+    TTL() {
+        @Override
+        public long maxValue() {
+            return EXTENDED_FEATURE_VALUE_MASK;  // 12725 days, about 34 years
+        }
+
+        @Override
+        public long toEphemeralOwner(long ttl) {
+            if ((ttl > TTL.maxValue()) || (ttl <= 0)) {
+                throw new IllegalArgumentException(""ttl must be positive and cannot be larger than: "" + TTL.maxValue());
+            }
+            //noinspection PointlessBitwiseExpression
+            return EXTENDED_MASK | EXTENDED_BIT_TTL | ttl;  // TTL_RESERVED_BIT is actually zero - but it serves to document that the proper extended bit needs to be set
+        }
+
+        @Override
+        public long getValue(long ephemeralOwner) {
+            return getExtendedFeatureValue(ephemeralOwner);
+        }
+    };
+
+    /**
+     * For types that support it, the maximum extended value
+     *
+     * @return 0 or max
+     */
+    public long maxValue() {
+        return 0;
+    }
+
+    /**
+     * For types that support it, convert a value to an extended ephemeral owner
+     *
+     * @return 0 or extended ephemeral owner
+     */
+    public long toEphemeralOwner(long value) {
+        return 0;
+    }
+
+    /**
+     * For types that support it, return the extended value from an extended ephemeral owner
+     *
+     * @return 0 or extended value
+     */
+    public long getValue(long ephemeralOwner) {
+        return 0;
+    }
 
     public static final long CONTAINER_EPHEMERAL_OWNER = Long.MIN_VALUE;
-    public static final long MAX_TTL = 0x0fffffffffffffffL;
-    public static final long TTL_MASK = 0x8000000000000000L;
+    public static final long MAX_EXTENDED_SERVER_ID = 0xfe;  // 254
+
+    private static final long EXTENDED_MASK = 0xff00000000000000L;
+    private static final long EXTENDED_BIT_TTL = 0x0000;
+    private static final long RESERVED_BITS_MASK = 0x00ffff0000000000L;
+    private static final long RESERVED_BITS_SHIFT = 40;
+
+    private static final Map<Long, EphemeralType> extendedFeatureMap;
 
+    static {
+        Map<Long, EphemeralType> map = new HashMap<>();
+        map.put(EXTENDED_BIT_TTL, TTL);
+        extendedFeatureMap = Collections.unmodifiableMap(map);
+    }
+
+    private static final long EXTENDED_FEATURE_VALUE_MASK = ~(EXTENDED_MASK | RESERVED_BITS_MASK);
+
+    // Visible for testing
+    static final String EXTENDED_TYPES_ENABLED_PROPERTY = ""zookeeper.extendedTypesEnabled"";
+    static final String TTL_3_5_3_EMULATION_PROPERTY = ""zookeeper.emulate353TTLNodes"";
+
+    /**
+     * Return true if extended ephemeral types are enabled
+     *
+     * @return true/false
+     */
+    public static boolean extendedEphemeralTypesEnabled() {","[{'comment': ""Maybe I'm missing the point here. Would you please elaborate a little bit on what's the additional benefit of making this generic by extended ephemeral types?\r\nWhy don't you just KISS (keep it simple), because YAGNI (you ain't gonna need) the extended types?"", 'commenter': 'anmolnar'}]"
384,build.xml,"@@ -1558,8 +1565,8 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
                classpathref=""releaseaudit-classpath""/>
     </target>
 
-    <target name=""owasp-taskdef"" depends=""ivy-retrieve-releaseaudit"">","[{'comment': ""Notice that the release audit jars are being dumped into build/lib - I'd recommend we fix that as part of this patch as well."", 'commenter': 'phunt'}, {'comment': '+1', 'commenter': 'afine'}]"
384,build.xml,"@@ -121,6 +121,7 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
     <property name=""ivy.test.lib"" value=""${build.dir}/test/lib""/>
     <property name=""ivy.jdiff.lib"" value=""${build.dir}/jdiff/lib""/>
     <property name=""ivy.javacc.lib"" value=""${build.dir}/javacc/lib""/>
+    <property name=""ivy.owasp.lib"" value=""${build.dir}/owasp/lib""/>","[{'comment': 'iirc the reports are output to build/test/owasp/.... perhaps you should move them here as well rather than spreading around?', 'commenter': 'phunt'}, {'comment': 'the reports are output to build/test/owasp/ in order to match what we do with clover\r\nso i felt it was best to follow convention rather than drop the actual report in with the dependencies', 'commenter': 'afine'}]"
400,src/docs/src/documentation/content/xdocs/zookeeperTutorial.xml,"@@ -361,7 +361,40 @@ from each one.</para>
 </programlisting>
  
 </section>
-<section id=""sc_sourceListing""><title>Complete Source Listing</title>
+
+<section>
+<title>Complete example</title>
+<para>
+In the following section you can find a complete command line application to demonstrate the above mentioned
+recipes. Use the following command to run it.
+</para>
+<programlisting>
+export CLASSPATH="".:$ZOOKEEPER_HOME/*:$ZOOKEEPER_HOME/lib/*:$ZOOKEEPER_HOME/conf""","[{'comment': 'we use different instructions for defining the classpath in the Administrators guide. It would be great to be consistent here. Also, is conf needed in the classpath?', 'commenter': 'afine'}, {'comment': ""Sure, makes sense.\r\nI've stolen this from the Hadoop Definitive Guide.\r\nWill take a look at the other."", 'commenter': 'anmolnar'}]"
409,src/java/test/org/apache/zookeeper/test/LoadFromLogTest.java,"@@ -18,49 +18,31 @@
 
 package org.apache.zookeeper.test;
 
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.zookeeper.common.Time;
-import org.apache.jute.BinaryInputArchive;
-import org.apache.jute.BinaryOutputArchive;
-import org.apache.jute.Record;
-import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.*;","[{'comment': 'We generally avoid * imports', 'commenter': 'afine'}]"
409,src/java/test/org/apache/zookeeper/test/LoadFromLogTest.java,"@@ -70,24 +52,37 @@
     private static final int TOTAL_TRANSACTIONS = NUM_MESSAGES + TRANSACTION_OVERHEAD;
     private volatile boolean connected;
 
-    /**
-     * test that all transactions from the Log are loaded, and only once
-     * @throws Exception an exception might be thrown here
-     */
-    @Test
-    public void testLoad() throws Exception {
+    private ZooKeeper zk;
+    private ServerCnxnFactory f;","[{'comment': ""i know you didn't pick this variable name but I think it wouldn't be the worst thing to slip a change to this under the radar."", 'commenter': 'afine'}]"
409,src/java/test/org/apache/zookeeper/test/LoadFromLogNoServerTest.java,"@@ -0,0 +1,175 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZooDefs.OpCode;
+import org.apache.zookeeper.common.Time;
+import org.apache.zookeeper.server.DataNode;
+import org.apache.zookeeper.server.DataTree;
+import org.apache.zookeeper.server.persistence.FileHeader;
+import org.apache.zookeeper.server.persistence.FileTxnLog;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.txn.*;","[{'comment': 'We generally avoid * imports', 'commenter': 'afine'}]"
409,src/java/test/org/apache/zookeeper/test/LoadFromLogNoServerTest.java,"@@ -0,0 +1,175 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZooDefs.OpCode;
+import org.apache.zookeeper.common.Time;
+import org.apache.zookeeper.server.DataNode;
+import org.apache.zookeeper.server.DataTree;
+import org.apache.zookeeper.server.persistence.FileHeader;
+import org.apache.zookeeper.server.persistence.FileTxnLog;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.txn.*;
+import org.junit.Assert;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * These tests has been extracted from LoadFromTest, because they don't need test ZK server to run.","[{'comment': '""have been""', 'commenter': 'afine'}]"
411,src/java/test/org/apache/zookeeper/server/quorum/CommitProcessorConcurrencyTest.java,"@@ -376,4 +377,123 @@ public void noStarvationOfReadRequestsTest() throws Exception {
                     !processedRequests.contains(r));
         }
     }
+
+    /**
+     * In the following test, we verify that we can handle the case that we got a commit
+     * of a request we never seen since the session that we just established. This can happen
+     * when a session is just established and there is request waiting to be committed in the
+     * in the session queue but it sees a commit for a request that belongs to the previous connection.
+     */
+    @Test(timeout = 1000)
+    public void noCrashOnCommittedRequestsOfUnseenRequestTest() throws Exception {
+        final String path = ""/noCrash/OnCommittedRequests/OfUnseenRequestTest"";
+        final int numberofReads = 10;
+        final int sessionid = 0x123456;
+        final int firstCXid = 0x100;
+        int readReqId = firstCXid;
+        processor.stoppedMainLoop = true;
+        HashSet<Request> localRequests = new HashSet<Request>();
+        // queue the blocking write request to queuedRequests
+        Request firstCommittedReq = newRequest(
+                new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE,
+                        CreateMode.PERSISTENT_SEQUENTIAL.toFlag()),
+                OpCode.create, sessionid, readReqId++);
+        processor.queuedRequests.add(firstCommittedReq);
+        localRequests.add(firstCommittedReq);
+
+        // queue read requests to queuedRequests
+        for (; readReqId <= numberofReads+firstCXid; ++readReqId) {
+            Request readReq = newRequest(new GetDataRequest(path, false),
+                    OpCode.getData, sessionid, readReqId);
+            processor.queuedRequests.add(readReq);
+            localRequests.add(readReq);
+        }
+
+        //run once
+        Assert.assertTrue(processor.queuedRequests.containsAll(localRequests));
+        processor.initThreads(numberofReads* 2);
+        processor.run();
+
+        //We verify that the processor is waiting for the commit
+        Assert.assertTrue(processedRequests.isEmpty());
+
+        // We add a commit that belongs to the same session but with smaller cxid,
+        // i.e., commit of an update from previous connection of this session.
+        Request preSessionCommittedReq = newRequest(
+                new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE,
+                        CreateMode.PERSISTENT_SEQUENTIAL.toFlag()),
+                OpCode.create, sessionid, firstCXid - 2);
+        processor.committedRequests.add(preSessionCommittedReq);
+        processor.committedRequests.add(firstCommittedReq);
+        processor.run();
+
+        //We verify that the commit processor processed the old commit prior to the newer messages
+        Assert.assertTrue(processedRequests.peek() == preSessionCommittedReq);
+
+        processor.run();
+
+        //We verify that the commit processor handle all messages.
+        Assert.assertTrue(processedRequests.containsAll(localRequests));
+    }
+
+    /**
+     * In the following test, we verify if we handle the case in which we get a commit
+     * for a request that has higher Cxid than the one we are waiting. This can happen
+     * when a session connection is lost but there is a request waiting to be committed in the
+     * session queue. However, since the session has moved, new requests can get to
+     * the leader out of order. Hence, the commits can also arrive ""out of order"" w.r.t. cxid.
+     * We should commit the requests according to the order we receive from the leader, i.e., wait for the relevant commit.","[{'comment': ""1) I think its worth while explaining the two scenarios in the CommitProcessor.java comments. I mean how its possible to get higher cxid and lower cxid from leader compared to what you expect. Including the part where requests may reach the leader out of cxid order if session is moved. \r\n\r\n2) I wonder if in this case (receiving higher cxid from leader) we should also empty the local pending requests ? What's the value of keeping the requests in the local queue ?"", 'commenter': 'shralex'}, {'comment': ""Regarding 2 - I've answered the question also in the new comments. I think we shouldn't empty the queue because it is possible that the session returned to us (i.e., moved back). It does no harm to keep the old requests, given that the cnxn handle in the old request shows that the old connection is closed."", 'commenter': 'kfirlevari'}]"
411,src/java/test/org/apache/zookeeper/server/quorum/CommitProcessorConcurrencyTest.java,"@@ -376,4 +377,123 @@ public void noStarvationOfReadRequestsTest() throws Exception {
                     !processedRequests.contains(r));
         }
     }
+
+    /**
+     * In the following test, we verify that we can handle the case that we got a commit
+     * of a request we never seen since the session that we just established. This can happen
+     * when a session is just established and there is request waiting to be committed in the
+     * in the session queue but it sees a commit for a request that belongs to the previous connection.","[{'comment': 'typo: ""in the in the""', 'commenter': 'afine'}, {'comment': 'Fixed', 'commenter': 'kfirlevari'}]"
411,src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java,"@@ -255,24 +255,23 @@ public void run() {
                         // If session queue != null, then it is also not empty.
                         Request topPending = sessionQueue.poll();
                         if (request.cxid != topPending.cxid) {
-                            LOG.error(
-                                    ""Got cxid 0x""
-                                            + Long.toHexString(request.cxid)
-                                            + "" expected 0x"" + Long.toHexString(
-                                                    topPending.cxid)
-                                    + "" for client session id ""
-                                    + Long.toHexString(request.sessionId));
-                            throw new IOException(""Error: unexpected cxid for""
-                                    + ""client session"");
+                            // we can get commit requests that are not at the queue head after
+                            // a session moved (see ZOOKEEPER-2684). We will just pass the
+                            // commit to the next processor and put the pending back with
+                            // a warning, we should not see this often under normal load
+                            LOG.warn(""Got request "" + request +
+                                    "" but we are expecting request "" + topPending);
+                            sessionQueue.addFirst(topPending);
+                        } else {
+                            /*
+                             * We want to send our version of the request. the
+                             * pointer to the connection in the request
+                             */
+                            topPending.setHdr(request.getHdr());","[{'comment': 'Would you mind explaining why we normally want to send our version of the request and why it is ok not to in this case?', 'commenter': 'afine'}, {'comment': 'I added an explanation, let me know if you meant something more specific. ', 'commenter': 'kfirlevari'}]"
411,src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java,"@@ -246,33 +246,51 @@ public void run() {
                     }
 
                     /*
-                     * Check if request is pending, if so, update it with the
-                     * committed info
+                     * Check if request is pending, if so, update it with the committed info
                      */
                     LinkedList<Request> sessionQueue = pendingRequests
                             .get(request.sessionId);
                     if (sessionQueue != null) {
                         // If session queue != null, then it is also not empty.
                         Request topPending = sessionQueue.poll();
                         if (request.cxid != topPending.cxid) {
-                            LOG.error(
-                                    ""Got cxid 0x""
-                                            + Long.toHexString(request.cxid)
-                                            + "" expected 0x"" + Long.toHexString(
-                                                    topPending.cxid)
-                                    + "" for client session id ""
-                                    + Long.toHexString(request.sessionId));
-                            throw new IOException(""Error: unexpected cxid for""
-                                    + ""client session"");
+                            // TL;DR - we should not encounter this scenario often under normal load.","[{'comment': 'I hate to be ""that guy"" but we generally use ""/*"" comments for long blocks like this.', 'commenter': 'afine'}, {'comment': 'NP ;)', 'commenter': 'kfirlevari'}]"
411,src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java,"@@ -246,33 +246,51 @@ public void run() {
                     }
 
                     /*
-                     * Check if request is pending, if so, update it with the
-                     * committed info
+                     * Check if request is pending, if so, update it with the committed info
                      */
                     LinkedList<Request> sessionQueue = pendingRequests
                             .get(request.sessionId);
                     if (sessionQueue != null) {
                         // If session queue != null, then it is also not empty.
                         Request topPending = sessionQueue.poll();
                         if (request.cxid != topPending.cxid) {
-                            LOG.error(
-                                    ""Got cxid 0x""
-                                            + Long.toHexString(request.cxid)
-                                            + "" expected 0x"" + Long.toHexString(
-                                                    topPending.cxid)
-                                    + "" for client session id ""
-                                    + Long.toHexString(request.sessionId));
-                            throw new IOException(""Error: unexpected cxid for""
-                                    + ""client session"");
+                            // TL;DR - we should not encounter this scenario often under normal load.
+                            // We pass the commit to the next processor and put the pending back with a warning.
+
+                            // Generally, we can get commit requests that are not at the queue head after
+                            // a session moved (see ZOOKEEPER-2684). Let's denote the previous server of the session
+                            // with A, and the server that the session moved to with B (keep in mind that it is
+                            // possible that the session already moved from B to a new server C, and maybe C=A).
+                            // 1. If request.cxid < topPending.cxid : this means that the session requested this update
+                            // from A, then moved to B (i.e., which is us), and now B receives the commit
+                            // for the update after the session already performed several operations in B
+                            // (and therefore its cxid is higher than that old request).
+                            // 2. If request.cxid > topPending.cxid : this means that the session requested an updated
+                            // from B with cxid that is bigger than the one we know therefore in this case we
+                            // are A, and we lost the connection to the session. Given that we are waiting for a commit
+                            // for that update, it means that we already sent the request to the leader and it will
+                            // be committed at some point (in this case the order of cxid won't follow zxid, since zxid
+                            // is an increasing order). It is not safe for us to delete the session's queue at this
+                            // point, since it is possible that the session has newer requests in it after it moved
+                            // back to us. We just leave the queue as it is, and once the commit arrives (for the old
+                            // request), the finalRequestProcessor will see a closed cnxn handle, and just won't send a
+                            // response.
+                            // Also note that we don't have a local session, therefore we treat the request
+                            // like any other commit for a remote request, i.e., we perform the update without sending
+                            // a response.
+
+                            LOG.warn(""Got request "" + request +
+                                    "" but we are expecting request "" + topPending);
+                            sessionQueue.addFirst(topPending);
+                        } else {
+                            // We want to send to the next processor our version of the request,
+                            // since it contains the session information that is needed
+                            // for post update processing (e.g., using request.cnxn we send a response to the client).
+                            topPending.setHdr(request.getHdr());","[{'comment': 'The explanation is really great. I was also hoping you could shed some light on this part of the code. Why do we ""want to send to the next processor our version of the request"" and why can we proceed in the other case if this is required here?', 'commenter': 'afine'}, {'comment': 'My understanding is that when a request is in the local queue, there is (or could be) a client attached to this server waiting for a response, and there is other bookeeping of requests that are outstanding and have originated from this server (e.g., for setting the max outstanding requests) - we need to update this info when an outstanding request completes. In the other case, the operation originated from a different server and there is no local bookeeeping or a local client session that needs to be notified. ', 'commenter': 'shralex'}, {'comment': 'Updated accordingly', 'commenter': 'kfirlevari'}]"
412,src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -905,10 +907,22 @@ protected void pRequest(Request request) throws RequestProcessorException {
                 request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue()));
             }
         }
+        checkProposalSize(request);
         request.zxid = zks.getZxid();
         nextProcessor.processRequest(request);
     }
 
+    private void checkProposalSize(Request request) {
+        if (request.getHdr() == null) return;
+        byte[] data = SerializeUtils.serializeRequest(request);","[{'comment': ""I'm concerned about possible performance implications here. Are we serializing this request an extra time here?"", 'commenter': 'afine'}]"
412,src/java/main/org/apache/zookeeper/server/util/SerializeUtils.java,"@@ -148,4 +152,20 @@ public static void serializeSnapshot(DataTree dt,OutputArchive oa,
         dt.serialize(oa, ""tree"");
     }
 
+    public static byte[] serializeRequest(Request request) {
+        if (request == null || request.getHdr() == null) return null;","[{'comment': 'what are the situations where this could return null?', 'commenter': 'afine'}]"
412,src/java/main/org/apache/jute/BinaryOutputArchive.java,"@@ -115,6 +115,11 @@ public void writeBuffer(byte barr[], String tag)
     		out.writeInt(-1);
     		return;
     	}
+    	if (barr.length >= BinaryInputArchive.maxBuffer) {","[{'comment': 'I\'m not sure how valid this check is. The output buffer could contain other data that makes it larger than the maxBuffer even if barr is small right? Wouldn\'t it make more sense to track how much data has been written to ""out""?', 'commenter': 'afine'}, {'comment': 'maybe we could also use UNREASONABLE_LENGTH from BinaryInputArchive?', 'commenter': 'afine'}]"
412,src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -905,10 +907,22 @@ protected void pRequest(Request request) throws RequestProcessorException {
                 request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue()));
             }
         }
+        checkProposalSize(request);
         request.zxid = zks.getZxid();
         nextProcessor.processRequest(request);
     }
 
+    private void checkProposalSize(Request request) {
+        if (request.getHdr() == null) return;
+        byte[] data = SerializeUtils.serializeRequest(request);
+        if (data.length > BinaryInputArchive.maxBuffer) {","[{'comment': 'why do we need this if we are also checking how much data has been written when writing to the binary output archive?', 'commenter': 'afine'}]"
412,src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -905,10 +907,22 @@ protected void pRequest(Request request) throws RequestProcessorException {
                 request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue()));
             }
         }
+        checkProposalSize(request);
         request.zxid = zks.getZxid();
         nextProcessor.processRequest(request);
     }
 
+    private void checkProposalSize(Request request) {
+        if (request.getHdr() == null) return;
+        byte[] data = SerializeUtils.serializeRequest(request);
+        if (data.length > BinaryInputArchive.maxBuffer) {
+            LOG.error(""Len error {}, larger than max buffer: {} set by jute.maxbuffer"",
+              data.length, BinaryInputArchive.maxBuffer);","[{'comment': 'maybe there is a more appropriate place for maxBuffer since it applies to input and output archive', 'commenter': 'afine'}]"
413,src/recipes/lock/test/org/apache/zookeeper/recipes/lock/ZNodeNameTest.java,"@@ -37,17 +37,30 @@ public void testOrderWithSamePrefix() throws Exception {
     @Test
     public void testOrderWithDifferentPrefixes() throws Exception {
         String[] names = { ""r-3"", ""r-2"", ""r-1"", ""w-2"", ""w-1"" };
-        String[] expected = { ""r-1"", ""r-2"", ""r-3"", ""w-1"", ""w-2"" };
+        // names with duplicated sequence numbers are not included in the result
+        String[] expected = { ""r-1"", ""r-2"", ""r-3"" };","[{'comment': 'Why have you removed ""w-1"" and ""w-2"" elements from here?\r\nI think the expected list could be:\r\n`String[] expected = { ""r-1"", ""w-1"", ""r-2"", ""w-2"", ""r-3""};`', 'commenter': 'anmolnar'}, {'comment': 'I agree it is a confusing behaviour of the current implementation. The reason is that we are using a TreeSet to do the sorting so when a new ZNodeName is added and the compareTo method returns 0 with any of the existing Set members, then it is considered a duplicate and it is not added. So in this case w-2 will be considered a duplicate of r-2 because they share the same sequence number. In the WriteLock context trying to sort znodes with duplicated sequence numbers will probably indicate some problem. \r\n\r\nTo adhere to the principle of least surprise I have changed the implementation of the compareTo so it produces the expected result.\r\n\r\n\r\n\r\n', 'commenter': 'javicacheiro'}]"
415,src/java/main/org/apache/zookeeper/server/quorum/Leader.java,"@@ -34,12 +33,12 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;","[{'comment': 'unused import', 'commenter': 'afine'}, {'comment': 'Good catch, thanks.', 'commenter': 'anmolnar'}]"
415,src/java/main/org/apache/zookeeper/server/quorum/Leader.java,"@@ -984,8 +990,6 @@ public void commitAndActivate(long zxid, long designatedLeader) {
 
     /**
      * Create an inform packet and send it to all observers.
-     * @param zxid
-     * @param proposal","[{'comment': 'Not that it adds much value, but why does this line need to be removed?', 'commenter': 'afine'}, {'comment': ""Intellij keep notifying me about these comments not referring to valid parameters in the method definition anymore. I thought it'd be nice to do some cleanup together with the patch."", 'commenter': 'anmolnar'}]"
415,src/java/test/org/apache/zookeeper/server/quorum/LeaderStatsTest.java,"@@ -0,0 +1,39 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class LeaderStatsTest {
+    @Test
+    public void testSetProposalSize_SetMinMax() {","[{'comment': 'nit:  the underscore in the test name is a little unconventional I think', 'commenter': 'afine'}, {'comment': 'Removed.', 'commenter': 'anmolnar'}]"
415,src/java/test/org/apache/zookeeper/server/quorum/LeaderStatsTest.java,"@@ -0,0 +1,39 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class LeaderStatsTest {
+    @Test
+    public void testSetProposalSize_SetMinMax() {
+        LeaderStats stats = new LeaderStats();","[{'comment': 'Maybe we should check what the min and max are before a proposal is received to make sure we set that behavior in stone.', 'commenter': 'afine'}, {'comment': ""Good point. I've also added checking the lastProposalSize size value besides min/max."", 'commenter': 'anmolnar'}]"
415,src/java/test/org/apache/zookeeper/server/util/SerializeUtilsTest.java,"@@ -0,0 +1,73 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import org.apache.jute.OutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.server.Request;
+import org.apache.zookeeper.txn.TxnHeader;
+import org.junit.Test;
+import org.mockito.InOrder;
+
+import java.io.IOException;
+
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+public class SerializeUtilsTest {
+
+    @Test
+    public void testSerializeRequest_RequestIsNull() {
+        byte[] data = SerializeUtils.serializeRequest(null);
+        assertNull(data);
+    }
+
+    @Test
+    public void testSerializeRequest_RequestHeaderIsNull() {
+        Request request = new Request(0, 0, 0, null, null, 0);
+        byte[] data = SerializeUtils.serializeRequest(request);
+        assertNull(data);
+    }
+
+    @Test
+    public void testSerializeRequest_WithoutTxn() throws IOException {
+        TxnHeader header = mock(TxnHeader.class);
+        Request request = new Request(1, 2, 3, header, null, 4);
+        byte[] data = SerializeUtils.serializeRequest(request);
+        assertNotNull(data);
+        verify(header).serialize(any(OutputArchive.class), eq(""hdr""));
+    }
+
+    @Test
+    public void testSerializeRequest_WithTxn() throws IOException {
+        Record txn = mock(Record.class);
+        TxnHeader header = mock(TxnHeader.class);
+        Request request = new Request(1, 2, 3, header, txn, 4);
+        byte[] data = SerializeUtils.serializeRequest(request);
+        assertNotNull(data);
+        InOrder inOrder = inOrder(header, txn);","[{'comment': ""I'm concerned that we do not actually check that the result of serializing the header and transaction ever make it into `data`. Would it be possible to write this test to mock out the serialization of the `header` and `txn` then make sure we get the `data` we expect?"", 'commenter': 'afine'}, {'comment': ""Very good question, I'd been thinking about it for a while. The reason why I eventually left it out is that this unit test verifies the behaviour of serializeRequest() method and _not_ the serialization itself. So basically we have to verify that the right serialize() methods get called in the right order instead of what they actually do. \r\n\r\nOn the other hand, you're right, because if we mock the serialize() methods, they won't have sideeffect on our test.\r\n\r\nWhat do you think?\r\n"", 'commenter': 'anmolnar'}]"
415,src/java/main/org/apache/zookeeper/server/ZooKeeperServerBean.java,"@@ -167,4 +167,9 @@ public String getSecureClientAddress() {
     public long getTxnLogElapsedSyncTime() {
         return zks.getTxnLogElapsedSyncTime();
     }
+
+    @Override
+    public int getJuteMaxBufferSize() {
+        return Integer.getInteger(""jute.maxbuffer"", 0xfffff);","[{'comment': 'I think the magic number 0xfffff is defined elsewhere in the code, it would be great to only have it in one place.', 'commenter': 'afine'}, {'comment': 'I deal with it in the other way around. Directly access BinaryInputArchive.maxBuffer from here.', 'commenter': 'anmolnar'}]"
415,src/java/main/org/apache/zookeeper/server/quorum/LeaderStats.java,"@@ -0,0 +1,61 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+/**
+ * Provides live statistics about a running Leader.
+ */
+class LeaderStats {","[{'comment': 'nit: Maybe we can call this `ProposalStats` at least it until it includes something not related to proposals', 'commenter': 'afine'}, {'comment': 'Done.', 'commenter': 'anmolnar'}]"
415,src/java/main/org/apache/zookeeper/server/quorum/LeaderStats.java,"@@ -0,0 +1,61 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+/**
+ * Provides live statistics about a running Leader.
+ */
+class LeaderStats {
+    /**
+     * Size of the last generated proposal. This should fit into server's jute.maxbuffer setting.
+     */
+    private int lastProposalSize = 0;
+
+    /**
+     * Size of the smallest proposal which has been generated since the server was started.
+     */
+    private int minProposalSize = -1;
+
+    /**
+     * Size of the largest proposal which has been generated since the server was started.
+     */
+    private int maxProposalSize = 0;","[{'comment': 'nit: can we set all of these to -1 for consistency', 'commenter': 'afine'}, {'comment': 'Done.', 'commenter': 'anmolnar'}]"
415,src/java/test/org/apache/zookeeper/server/quorum/StatResetCommandTest.java,"@@ -0,0 +1,112 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.server.ServerCnxn;
+import org.apache.zookeeper.server.ServerStats;
+import org.apache.zookeeper.server.ZooKeeperServer;
+import org.apache.zookeeper.server.command.StatResetCommand;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+public class StatResetCommandTest {
+    private static final String ZK_NOT_SERVING = ""This ZooKeeper instance is not currently serving requests\n"";","[{'comment': 'nit: maybe we should make the version of this in AbstractFourLetterCommand visible to this class for the purpose of testing.', 'commenter': 'afine'}, {'comment': 'Done.', 'commenter': 'anmolnar'}]"
415,src/java/test/org/apache/zookeeper/server/quorum/StatCommandTest.java,"@@ -0,0 +1,106 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.server.ServerCnxn;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.apache.zookeeper.server.ServerStats;
+import org.apache.zookeeper.server.ZKDatabase;
+import org.apache.zookeeper.server.command.FourLetterCommands;
+import org.apache.zookeeper.server.command.StatCommand;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.hamcrest.core.StringContains.containsString;","[{'comment': 'According to: https://github.com/junit-team/junit4/wiki/matchers-and-assertthat we should probably use `import static org.hamcrest.CoreMatchers.containsString;`\r\n\r\nIn addition, this will not resolve in intellij until we allow transitive test dependencies to be imported by changing build.xml:1820', 'commenter': 'afine'}, {'comment': 'Thanks for the investigation. All done.', 'commenter': 'anmolnar'}]"
415,build.xml,"@@ -1817,7 +1817,7 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
              description=""Create eclipse project files"">
        <ivy:resolve useOrigin=""true"" conf=""test""/>
        <ivy:cachepath pathid=""default.path.id"" conf=""default"" />
-       <ivy:cachepath pathid=""junit.path.id"" conf=""test"" transitive=""false""/>
+       <ivy:cachepath pathid=""junit.path.id"" conf=""test"" transitive=""true""/>","[{'comment': 'nit: we can just remove the transitive property to be consistent', 'commenter': 'afine'}]"
420,src/java/test/org/apache/zookeeper/test/LoadFromLogTest.java,"@@ -69,25 +54,42 @@
     private static final int TRANSACTION_OVERHEAD = 2;
     private static final int TOTAL_TRANSACTIONS = NUM_MESSAGES + TRANSACTION_OVERHEAD;
 
-    /**
-     * test that all transactions from the Log are loaded, and only once
-     * @throws Exception an exception might be thrown here
-     */
-    @Test
-    public void testLoad() throws Exception {
-        final String hostPort = HOST + PortAssignment.unique();
+    private String hostPort;
+    private int port;
+    private ZooKeeper zk;
+    private ServerCnxnFactory serverCnxnFactory;
+    private File tmpDir;
+    private ZooKeeperServer zks;
+
+    @Before
+    public void setUp() throws Exception {
+        hostPort = HOST + PortAssignment.unique();","[{'comment': ""While you're in here can you also fix this? We should be using this value from ClientBase. Is there a reason why we can't convert this class over to subclass ClientBase?"", 'commenter': 'phunt'}]"
420,src/java/test/org/apache/zookeeper/test/LoadFromLogTest.java,"@@ -69,25 +54,42 @@
     private static final int TRANSACTION_OVERHEAD = 2;
     private static final int TOTAL_TRANSACTIONS = NUM_MESSAGES + TRANSACTION_OVERHEAD;
 
-    /**
-     * test that all transactions from the Log are loaded, and only once
-     * @throws Exception an exception might be thrown here
-     */
-    @Test
-    public void testLoad() throws Exception {
-        final String hostPort = HOST + PortAssignment.unique();
+    private String hostPort;
+    private int port;
+    private ZooKeeper zk;
+    private ServerCnxnFactory serverCnxnFactory;
+    private File tmpDir;
+    private ZooKeeperServer zks;
+
+    @Before
+    public void setUp() throws Exception {
+        hostPort = HOST + PortAssignment.unique();
+        port = Integer.parseInt(hostPort.split("":"")[1]);
+
         // setup a single server cluster
-        File tmpDir = ClientBase.createTmpDir();
+        tmpDir = ClientBase.createTmpDir();
         ClientBase.setupTestEnv();
-        ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);
+        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);
         SyncRequestProcessor.setSnapCount(100);
-        final int PORT = Integer.parseInt(hostPort.split("":"")[1]);
-        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);
-        f.startup(zks);
+        serverCnxnFactory = ServerCnxnFactory.createFactory(port, -1);
+        serverCnxnFactory.startup(zks);
         Assert.assertTrue(""waiting for server being up "",
                 ClientBase.waitForServerUp(hostPort,CONNECTION_TIMEOUT));","[{'comment': ""Notice the issue here - this class has defined it's own constant for CONNECTION_TIMEOUT which is too small. If we were a subclass of ClientBase this would be handled for us already (incl the setup and teardown)."", 'commenter': 'phunt'}]"
420,src/java/test/org/apache/zookeeper/test/LoadFromLogTest.java,"@@ -18,77 +18,58 @@
 
 package org.apache.zookeeper.test;
 
-import java.io.ByteArrayOutputStream;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.zookeeper.common.Time;
-import org.apache.jute.BinaryInputArchive;
-import org.apache.jute.BinaryOutputArchive;
-import org.apache.jute.Record;
+
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.KeeperException.NoNodeException;
-import org.apache.zookeeper.PortAssignment;
-import org.apache.zookeeper.ZKTestCase;
 import org.apache.zookeeper.ZooDefs.Ids;
-import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.ZooKeeper;
 import org.apache.zookeeper.data.Stat;
-import org.apache.zookeeper.server.DataNode;
-import org.apache.zookeeper.server.DataTree;
 import org.apache.zookeeper.server.ServerCnxnFactory;
 import org.apache.zookeeper.server.SyncRequestProcessor;
 import org.apache.zookeeper.server.ZooKeeperServer;
-import org.apache.zookeeper.server.persistence.FileHeader;
 import org.apache.zookeeper.server.persistence.FileTxnLog;
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
 import org.apache.zookeeper.server.persistence.Util;
 import org.apache.zookeeper.server.persistence.FileTxnLog.FileTxnIterator;
 import org.apache.zookeeper.server.persistence.TxnLog.TxnIterator;
-import org.apache.zookeeper.txn.CreateTxn;
-import org.apache.zookeeper.txn.DeleteTxn;
-import org.apache.zookeeper.txn.MultiTxn;
-import org.apache.zookeeper.txn.Txn;
 import org.apache.zookeeper.txn.TxnHeader;
+import org.eclipse.jetty.util.SocketAddressResolver;
+import org.junit.After;
 import org.junit.Assert;
+import org.junit.Before;
 import org.junit.Test;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class LoadFromLogTest extends ZKTestCase {
-    private static final String HOST = ""127.0.0.1:"";
-    private static final int CONNECTION_TIMEOUT = 3000;
+public class LoadFromLogTest extends ClientBase {
     private static final int NUM_MESSAGES = 300;
     protected static final Logger LOG = LoggerFactory.getLogger(LoadFromLogTest.class);
 
     // setting up the quorum has a transaction overhead for creating and closing the session
     private static final int TRANSACTION_OVERHEAD = 2;
     private static final int TOTAL_TRANSACTIONS = NUM_MESSAGES + TRANSACTION_OVERHEAD;
 
+    @Before
+    public void setUp() throws Exception {
+        SyncRequestProcessor.setSnapCount(100);
+        super.setUp();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        stopServer();","[{'comment': ""shouldn't this should be calling super.tearDown() ?"", 'commenter': 'phunt'}, {'comment': ""Good point. super.tearDown() includes stopServer() so I'll remove this one completely."", 'commenter': 'anmolnar'}]"
420,src/java/test/org/apache/zookeeper/test/LoadFromLogTest.java,"@@ -18,77 +18,58 @@
 
 package org.apache.zookeeper.test;
 
-import java.io.ByteArrayOutputStream;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.zookeeper.common.Time;
-import org.apache.jute.BinaryInputArchive;
-import org.apache.jute.BinaryOutputArchive;
-import org.apache.jute.Record;
+
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.KeeperException.NoNodeException;
-import org.apache.zookeeper.PortAssignment;
-import org.apache.zookeeper.ZKTestCase;
 import org.apache.zookeeper.ZooDefs.Ids;
-import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.ZooKeeper;
 import org.apache.zookeeper.data.Stat;
-import org.apache.zookeeper.server.DataNode;
-import org.apache.zookeeper.server.DataTree;
 import org.apache.zookeeper.server.ServerCnxnFactory;
 import org.apache.zookeeper.server.SyncRequestProcessor;
 import org.apache.zookeeper.server.ZooKeeperServer;
-import org.apache.zookeeper.server.persistence.FileHeader;
 import org.apache.zookeeper.server.persistence.FileTxnLog;
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
 import org.apache.zookeeper.server.persistence.Util;
 import org.apache.zookeeper.server.persistence.FileTxnLog.FileTxnIterator;
 import org.apache.zookeeper.server.persistence.TxnLog.TxnIterator;
-import org.apache.zookeeper.txn.CreateTxn;
-import org.apache.zookeeper.txn.DeleteTxn;
-import org.apache.zookeeper.txn.MultiTxn;
-import org.apache.zookeeper.txn.Txn;
 import org.apache.zookeeper.txn.TxnHeader;
+import org.eclipse.jetty.util.SocketAddressResolver;
+import org.junit.After;
 import org.junit.Assert;
+import org.junit.Before;
 import org.junit.Test;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class LoadFromLogTest extends ZKTestCase {
-    private static final String HOST = ""127.0.0.1:"";
-    private static final int CONNECTION_TIMEOUT = 3000;
+public class LoadFromLogTest extends ClientBase {
     private static final int NUM_MESSAGES = 300;
     protected static final Logger LOG = LoggerFactory.getLogger(LoadFromLogTest.class);
 
     // setting up the quorum has a transaction overhead for creating and closing the session
     private static final int TRANSACTION_OVERHEAD = 2;
     private static final int TOTAL_TRANSACTIONS = NUM_MESSAGES + TRANSACTION_OVERHEAD;
 
+    @Before
+    public void setUp() throws Exception {
+        SyncRequestProcessor.setSnapCount(100);","[{'comment': ""Unfortunately this is going to have the side-effect that all servers of all the tests in this class will be started with a snapCount of 100. Subsequently setting this value in the test itself will have no effect as the server has already been started (syncprocessor thread running). Unless the server is restarted of course.\r\n\r\nSee comments below and please verify this finding yourself.\r\n\r\nI'm thinking that you might need to make this setup empty, and call setUp from the very beginning of the test after setting the count explicitly."", 'commenter': 'phunt'}, {'comment': 'I think @phunt is mostly correct. There are a couple issues with `snapCount`. \r\n\r\nFirst, if want to change it while the syncProcessor thread has started, shouldn\'t it be volatile? \r\n\r\nSecond, I disagree that it has ""no effect"" on a server that has already been started but the effect is not the desired behavior. Taking the issue of the `snapCount` field not being volatile out of the picture, the code in `SyncProcessor` looks like:\r\n```java\r\n    public void run() {\r\n        try {\r\n            int randRoll = r.nextInt(snapCount/2);\r\n            while (true) {\r\n                Request si = null;\r\n                //get a request\r\n                if (si != null) {\r\n                    // track the number of records written to the log\r\n                    if (zks.getZKDatabase().append(si)) {\r\n                        logCount++;\r\n                        if (logCount > (snapCount / 2 + randRoll)) {\r\n                            randRoll = r.nextInt(snapCount/2);\r\n```\r\n\r\nSo my reading is that if `snapCount` is changed from `previousSnapCount` while the `SyncProcessor` is already running to `desiredSnapCount` it will take at least `desiredSnapCount` and at worst `desiredSnapCount + previousSnapCount/2` transactions for the ""effective"" `snapCount` to become `desiredSnapCount` (again ignoring the volatility issue).\r\n\r\nI agree with @phunt\'s solution.\r\n', 'commenter': 'afine'}]"
420,src/java/test/org/apache/zookeeper/test/LoadFromLogTest.java,"@@ -136,21 +113,10 @@ public void testLoad() throws Exception {
      */
     @Test
     public void testLoadFailure() throws Exception {
-        final String hostPort = HOST + PortAssignment.unique();
-        // setup a single server cluster
-        File tmpDir = ClientBase.createTmpDir();
-        ClientBase.setupTestEnv();
-        ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);
-        // So we have at least 4 logs
         SyncRequestProcessor.setSnapCount(50);","[{'comment': 'iiuc the server has already been started in setUp method and as a result this will have no effect. Am I reading that right. Instead you might need to set this then call setUp.', 'commenter': 'phunt'}]"
420,src/java/test/org/apache/zookeeper/test/LoadFromLogTest.java,"@@ -332,20 +173,10 @@ public void testPad() throws Exception {
      */
     @Test
     public void testRestore() throws Exception {
-        final String hostPort = HOST + PortAssignment.unique();
-        // setup a single server cluster
-        File tmpDir = ClientBase.createTmpDir();
-        ClientBase.setupTestEnv();
-        ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);
         SyncRequestProcessor.setSnapCount(10000);","[{'comment': 'Same issue here...', 'commenter': 'phunt'}]"
420,src/java/test/org/apache/zookeeper/test/LoadFromLogTest.java,"@@ -370,20 +202,17 @@ public void testRestore() throws Exception {
         // Force snapshot and restore
         zks.takeSnapshot();
         zks.shutdown();
-        f.shutdown();
+        stopServer();
 
-        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);
         SyncRequestProcessor.setSnapCount(10000);","[{'comment': 'I believe this is ok as the server is restarted (but you might want to verify).', 'commenter': 'phunt'}]"
420,src/java/test/org/apache/zookeeper/test/LoadFromLogTest.java,"@@ -413,20 +240,10 @@ public void testRestore() throws Exception {
      */
     @Test
     public void testRestoreWithTransactionErrors() throws Exception {
-        final String hostPort = HOST + PortAssignment.unique();
-        // setup a single server cluster
-        File tmpDir = ClientBase.createTmpDir();
-        ClientBase.setupTestEnv();
-        ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);
         SyncRequestProcessor.setSnapCount(10000);","[{'comment': 'same...', 'commenter': 'phunt'}]"
420,src/java/test/org/apache/zookeeper/test/LoadFromLogTest.java,"@@ -449,50 +267,25 @@ public void testRestoreWithTransactionErrors() throws Exception {
         // Force snapshot and restore
         zks.takeSnapshot();
         zks.shutdown();
-        f.shutdown();
+        stopServer();
 
         zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);
         SyncRequestProcessor.setSnapCount(10000);
-        f = ServerCnxnFactory.createFactory(PORT, -1);
-        f.startup(zks);
-        Assert.assertTrue(""waiting for server being up "", ClientBase
-                .waitForServerUp(hostPort, CONNECTION_TIMEOUT));
-
-        f.shutdown();
-        zks.shutdown();
+        startServer();
     }
 
     /**
      * Verify snap/log dir create with/without autocreate enabled.
      */
     @Test
     public void testDatadirAutocreate() throws Exception {
-        ClientBase.setupTestEnv();","[{'comment': 'not sure if it matters here and in the following test method but the snapcount is different after the current patch.', 'commenter': 'phunt'}]"
420,src/java/test/org/apache/zookeeper/test/LoadFromLogTest.java,"@@ -18,77 +18,58 @@
 
 package org.apache.zookeeper.test;
 
-import java.io.ByteArrayOutputStream;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.zookeeper.common.Time;
-import org.apache.jute.BinaryInputArchive;
-import org.apache.jute.BinaryOutputArchive;
-import org.apache.jute.Record;
+
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.KeeperException.NoNodeException;
-import org.apache.zookeeper.PortAssignment;
-import org.apache.zookeeper.ZKTestCase;
 import org.apache.zookeeper.ZooDefs.Ids;
-import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.ZooKeeper;
 import org.apache.zookeeper.data.Stat;
-import org.apache.zookeeper.server.DataNode;
-import org.apache.zookeeper.server.DataTree;
 import org.apache.zookeeper.server.ServerCnxnFactory;
 import org.apache.zookeeper.server.SyncRequestProcessor;
 import org.apache.zookeeper.server.ZooKeeperServer;
-import org.apache.zookeeper.server.persistence.FileHeader;
 import org.apache.zookeeper.server.persistence.FileTxnLog;
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
 import org.apache.zookeeper.server.persistence.Util;
 import org.apache.zookeeper.server.persistence.FileTxnLog.FileTxnIterator;
 import org.apache.zookeeper.server.persistence.TxnLog.TxnIterator;
-import org.apache.zookeeper.txn.CreateTxn;
-import org.apache.zookeeper.txn.DeleteTxn;
-import org.apache.zookeeper.txn.MultiTxn;
-import org.apache.zookeeper.txn.Txn;
 import org.apache.zookeeper.txn.TxnHeader;
+import org.eclipse.jetty.util.SocketAddressResolver;","[{'comment': 'nit: not sure this import is needed', 'commenter': 'afine'}]"
423,src/java/main/org/apache/zookeeper/ClientCnxnSocketNetty.java,"@@ -340,13 +340,24 @@ public static Packet getInstance() {
             return instance;
         }
     }
+
     /**
      * ZKClientPipelineFactory is the netty pipeline factory for this netty
      * connection implementation.
      */
     private class ZKClientPipelineFactory implements ChannelPipelineFactory {
         private SSLContext sslContext = null;
         private SSLEngine sslEngine = null;
+        private String host;
+        private int port;
+
+        public ZKClientPipelineFactory() {","[{'comment': 'do we still need this constructor?', 'commenter': 'afine'}, {'comment': 'I second that. host & port are now mandatory parameters.', 'commenter': 'anmolnar'}, {'comment': ""Maybe not，but  it's just a good thing to keep the default constructor when I define a constructor with parameters. isn't it?"", 'commenter': 'abel-von'}, {'comment': ""I don't think we need it here."", 'commenter': 'afine'}]"
425,src/contrib/monitoring/check_zookeeper.py,"@@ -251,6 +256,13 @@ def _parse_stat(self, data):
                 result['zk_znode_count'] = int(m.group(1))
                 continue
 
+            m = re.match('Zxid: (0x[0-9a-fA-F]+)', line)
+            if m is not None:
+                result['zk_zxid']         = int(m.group(1), 16) # convert from hex","[{'comment': 'Since the zxid is being split up below, it may be valuable to leave this in hex.', 'commenter': 'afine'}, {'comment': 'Sounds good, update coming up.', 'commenter': 'alexbb'}]"
425,src/contrib/monitoring/check_zookeeper.py,"@@ -169,11 +169,16 @@ def __init__(self, host='localhost', port='2181', timeout=1):
     def get_stats(self):
         """""" Get ZooKeeper server stats as a map """"""
         data = self._send_cmd('mntr')
+        stat = self._parse_stat(self._send_cmd('stat'))
         if data:
-            return self._parse(data)
+            mntr = self._parse(data)
+            missing = ['zk_zxid', 'zk_zxid_counter', 'zk_zxid_epoch']","[{'comment': 'why not just include all of the output from stat?', 'commenter': 'afine'}, {'comment': ""Because the rest of the stat output is already present in the mntr output. Previously for servers that support the mntr command the script wouldn't run stat at all: I only added it because the zxid info is not in mntr."", 'commenter': 'alexbb'}, {'comment': ""How about changing the below to:\r\n\r\n```python\r\nfor s in stat:\r\n    if s not in mntr:\r\n        mntr[s] = stat[s]\r\n```\r\n\r\nIt will have the same effect now, but if future things are added to stat but not mntr we'd pick them up."", 'commenter': 'alexbb'}, {'comment': ""@afine are you ok with this? Looks like a useful idea that I'd like to include once you're satisfied."", 'commenter': 'phunt'}]"
430,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -1232,11 +1233,12 @@ public void run() {
                         } else if (e instanceof RWServerFoundException) {
                             LOG.info(e.getMessage());
                         } else {
+                            SocketAddress remoteAddr = clientCnxnSocket.getRemoteSocketAddress();
                             LOG.warn(
                                     ""Session 0x""
                                             + Long.toHexString(getSessionId())
                                             + "" for server ""
-                                            + clientCnxnSocket.getRemoteSocketAddress()
+                                            + (remoteAddr == null ? addr : remoteAddr)","[{'comment': 'I believe that, if `clientCnxnSocket.getRemoteSocketAddress()` is non-null, the value is always the same as `addr`.\r\n\r\nIf so, then this could be simplified to just `addr` without the ternary operation.', 'commenter': 'paulmillar'}, {'comment': 'Of course this comment is [non-blocking]', 'commenter': 'paulmillar'}, {'comment': ""Makes sense. I'll just use 'addr' here."", 'commenter': 'anmolnar'}]"
430,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -1041,6 +1041,8 @@ private void sendPing() {
 
         private InetSocketAddress rwServerAddress = null;
 
+        private InetSocketAddress addr = null;","[{'comment': '[non-blocking]\r\n\r\nThe name could be an ambiguous: is this the address of the local (client) side of the connection, or the remote (server) side of the connection?  Especially as there is `rwServerAddress` field member defined immediately above.\r\n\r\nSuggest `serverAddress` (or similar)', 'commenter': 'paulmillar'}, {'comment': ""Remote side of the connection. Basically the ip address that the client is trying to connect to. ```rwServerAddress``` is the address of non-R/O server found if there's any.\r\n\r\nI'll change this to ```serverAddress```."", 'commenter': 'anmolnar'}]"
430,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -1236,7 +1237,7 @@ public void run() {
                                     ""Session 0x""
                                             + Long.toHexString(getSessionId())
                                             + "" for server ""
-                                            + clientCnxnSocket.getRemoteSocketAddress()
+                                            + serverAddress
                                             + "", unexpected error""
                                             + RETRY_CONN_MSG, e);","[{'comment': ""I think it would be good to address the other issue Paul mentioned - no need to dump a stack if we know this is NoRouteToHostException - why wouldn't we add another elseif to check for this type?"", 'commenter': 'phunt'}, {'comment': ""We're talking about the same thing in the Jira. It's arguable which exception should be logged at INFO level without the stack trace, I ended up separating SocketExceptions altogether and leaving the rest for the original handler."", 'commenter': 'anmolnar'}]"
430,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -1041,6 +1041,8 @@ private void sendPing() {
 
         private InetSocketAddress rwServerAddress = null;
 
+        private InetSocketAddress serverAddress = null;","[{'comment': 'This seems kinda bogus to me - why push this up to a field. Can\'t we determine the server address in ""run"" method, as a local variable, and call startConnect with that as an argument? That seems like an improvement to startConnect call at the same time. What do you think @anmolnar , does that make sense or am I missing something?', 'commenter': 'phunt'}, {'comment': ""Good idea. I've made the change."", 'commenter': 'anmolnar'}]"
430,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -1231,14 +1231,14 @@ public void run() {
                             LOG.info(e.getMessage() + RETRY_CONN_MSG);
                         } else if (e instanceof RWServerFoundException) {
                             LOG.info(e.getMessage());
+                        } else if (e instanceof SocketException) {
+                            LOG.info(""Socket error occurred: {}: {}"", serverAddress, e.getMessage());
                         } else {
-                            LOG.warn(
-                                    ""Session 0x""
-                                            + Long.toHexString(getSessionId())
-                                            + "" for server ""
-                                            + clientCnxnSocket.getRemoteSocketAddress()
-                                            + "", unexpected error""
-                                            + RETRY_CONN_MSG, e);
+                            LOG.warn(""Session 0x{} for server {}, unexpected error{}"",","[{'comment': '[non-blocking]\r\n\r\nAlthough this isn\'t a regression, you probably want a "": "" here (and a space); e.g.,\r\n\r\n    ""Session 0x{} for server {}, unexpected error: {}""', 'commenter': 'paulmillar'}, {'comment': 'No, because the RETRY_CONN_MSG should go right after it. (starts with "", "")', 'commenter': 'anmolnar'}]"
438,src/java/main/org/apache/zookeeper/server/quorum/Leader.java,"@@ -1183,8 +1183,10 @@ public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws Interrupt
             if (lastAcceptedEpoch >= epoch) {
                 epoch = lastAcceptedEpoch+1;
             }
-            connectingFollowers.add(sid);
             QuorumVerifier verifier = self.getQuorumVerifier();
+            if(verifier.getVotingMembers().containsKey(sid)) {","[{'comment': ""I'm wondering if this logic is best suited for the `QuorumVerifier`. In other words, the quorum verifier should be able to determine if a quorum is present from a set of ids while taking into account which sids represent voting members."", 'commenter': 'afine'}, {'comment': '+1', 'commenter': 'anmolnar'}, {'comment': ""If I recall correctly, the reason this wasn't done are concerns around the impact on performance - containsQuorum is called every time an ACK is received for every operation proposal. So if you need 3 asks to commit an operation, we'll be doing these checks (figuring out who's a participant and who's not} for {ACK1}, for {ACK1, ACK2} and for {ACK1, ACK2, ACK3}. This compared to comparing two ints as it stands now. So this is why it wasn't done..."", 'commenter': 'shralex'}, {'comment': '+1 makes sense.', 'commenter': 'anmolnar'}]"
440,build.xml,"@@ -198,7 +198,7 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
     <!-- ====================================================== -->
     <!-- Dependency versions                                    -->
     <!-- ====================================================== -->
-    <property name=""slf4j.version"" value=""1.7.25""/>
+    <property name=""slf4j.version"" value=""1.7.22""/>","[{'comment': 'what is the reason for the downgrade?', 'commenter': 'afine'}, {'comment': 'Not sure how to get an evidence, but if remember correctly it was dropwizard-core which forced me to use an earlier version of slf4j.', 'commenter': 'anmolnar'}, {'comment': 'So do we still need this lower version?', 'commenter': 'afine'}, {'comment': 'yes, to be consistent with slf4j', 'commenter': 'anmolnar'}, {'comment': ""Here's the issue:\r\n> BUILD FAILED\r\n> /git/my-zookeeper/build.xml:420: impossible to resolve dependencies:\r\n> \torg.slf4j#slf4j-api;1.7.22 (needed by [io.dropwizard.metrics#metrics-core;3.2.5]) conflicts with org.slf4j#slf4j-api;1.7.25 (needed by [org.apache.zookeeper#zookeeper;3.6.0-SNAPSHOT])\r\n"", 'commenter': 'anmolnar'}, {'comment': 'Can we just exclude org.slf4j#slf4j-api;1.7.22 ?', 'commenter': 'afine'}, {'comment': 'Great. Works.', 'commenter': 'anmolnar'}]"
440,src/java/main/org/apache/zookeeper/server/quorum/ProposalStats.java,"@@ -0,0 +1,70 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import com.codahale.metrics.ExponentiallyDecayingReservoir;","[{'comment': ""I don't see much being pulled in from dropwizard, only codahale. Is codahale.metrics available independently? \r\n\r\nIt doesn't look like it but I only checked briefly.\r\n  "", 'commenter': 'afine'}, {'comment': ""Doesn't look like it has separate package for that."", 'commenter': 'anmolnar'}]"
440,src/java/main/org/apache/zookeeper/server/quorum/ProposalStats.java,"@@ -0,0 +1,70 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import com.codahale.metrics.ExponentiallyDecayingReservoir;
+import com.codahale.metrics.Histogram;
+import com.codahale.metrics.JmxReporter;
+import com.codahale.metrics.MetricRegistry;
+import com.codahale.metrics.Reservoir;
+import com.codahale.metrics.Snapshot;
+import org.apache.zookeeper.jmx.CommonNames;
+import org.apache.zookeeper.jmx.MBeanRegistry;
+
+import static com.codahale.metrics.MetricRegistry.name;
+
+/**
+ * Provides real-time metrics on Leader's proposal size.
+ * The class uses a histogram included in Dropwizard metrics library with ExponentiallyDecayingReservoir.
+ * It provides stats of proposal sizes from the last 5 minutes with acceptable cpu/memory footprint optimized for streaming data.
+ */
+public class ProposalStats {
+    private final Histogram proposalSizes;
+
+    ProposalStats() {
+        final MetricRegistry metrics = new MetricRegistry();
+        Reservoir reservoir = new ExponentiallyDecayingReservoir();","[{'comment': ""I won't pretend to know much about exponentially decaying reservoirs. I'm curious what the behavior is with minimum and maximum values. Are these guaranteed to always be exact and for what time period?"", 'commenter': 'afine'}, {'comment': 'Perhaps a user configurable SlidingTimeWindowReservoir may be more appropriate?', 'commenter': 'afine'}, {'comment': ""I'm not an expert either. According to the following article I think we've the following reservoir options:\r\nhttp://taint.org/2014/01/16/145944a.html\r\n\r\n**SlidingTimeWindowReservoir**: the standard one, but looks like the memory footprint could be potentially high in some cases.\r\n**SlidingTimeWindowArrayReservoir**: similar to the previous with much better memory handling\r\n**ExponentiallyDecayingReservoir**: good memory/cpu footprint and optimised for streaming data. The main difference is that if there's no data comes in within the configured number of samples, previously collected statistics will be presented on JMX. SlidingTimeWindow reservoirs will zero out, which sounds correct behaviour to me, but it might be less convenient.\r\n\r\n  "", 'commenter': 'anmolnar'}, {'comment': ""@afine Would you approve the PR with existing reservoir or do you still think it'd be better to go with configurable sliding window?"", 'commenter': 'anmolnar'}, {'comment': 'From: http://metrics.dropwizard.io/3.1.0/manual/core/#exponentially-decaying-reservoirs\r\n\r\n> A histogram with an exponentially decaying reservoir produces quantiles which are representative of (roughly) the last five minutes of data.\r\n\r\nMy guess is that we would want more than data representing the last 5 minutes right?', 'commenter': 'afine'}, {'comment': ""http://metrics.dropwizard.io/3.1.0/apidocs/com/codahale/metrics/ExponentiallyDecayingReservoir.html\r\nDefault constructor:\r\n> Creates a new ExponentiallyDecayingReservoir of 1028 elements, which offers a 99.9% confidence level with a 5% margin of error assuming a normal distribution, and an alpha factor of 0.015, which heavily biases the reservoir to the past 5 minutes of measurements.\r\n\r\nThere're 2 other constructors which the reservoir can be configured with by size, alpha and clock. So, the window can be extended, though it's not as obvious as with `SlidingWindow`.\r\n\r\nLet's go with that as you suggested."", 'commenter': 'anmolnar'}]"
440,ivy.xml,"@@ -133,6 +133,12 @@
     <dependency org=""org.codehaus.jackson"" name=""jackson-mapper-asl""
                 rev=""${jackson-mapper-asl.version}"" conf=""optional->default""/>
 
+    <dependency org=""io.dropwizard.metrics"" name=""metrics-core""
+                rev=""${dropwizard.version}"" conf=""default"" />
+
+    <dependency org=""org.hamcrest"" name=""hamcrest-all"" rev=""1.3""","[{'comment': ""doesn't mockito pull these in already?"", 'commenter': 'afine'}, {'comment': ""Unfortunately not. Mockito pulls in hamcrest-core only which contains the CoreMatchers namespaces. The matcher I use in the test is only included in hamcrest-all.\r\n\r\nI believe it'd be good start using more of Hamcrest matchers anyway."", 'commenter': 'anmolnar'}]"
440,src/java/test/org/apache/zookeeper/server/quorum/LeaderBeanTest.java,"@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.jute.OutputArchive;","[{'comment': 'nit: there are a couple unused imports here', 'commenter': 'afine'}, {'comment': 'thanks, done.', 'commenter': 'anmolnar'}]"
440,src/java/test/org/apache/zookeeper/server/quorum/LeaderBeanTest.java,"@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.jute.OutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.server.Request;
+import org.apache.zookeeper.server.ZKDatabase;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
+import org.apache.zookeeper.server.util.SerializeUtils;
+import org.apache.zookeeper.test.ClientBase;
+import org.apache.zookeeper.txn.TxnHeader;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+import java.io.File;
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+
+public class LeaderBeanTest {
+    private Leader leader;
+    private LeaderBean leaderBean;
+    private FileTxnSnapLog fileTxnSnapLog;
+    private LeaderZooKeeperServer zks;
+    private QuorumPeer qp;
+
+    @Before
+    public void setUp() throws IOException {
+        qp = new QuorumPeer();
+        QuorumVerifier quorumVerifierMock = mock(QuorumVerifier.class);
+        qp.setQuorumVerifier(quorumVerifierMock, false);
+        File tmpDir = ClientBase.createEmptyTestDir();
+        fileTxnSnapLog = new FileTxnSnapLog(new File(tmpDir, ""data""),
+                new File(tmpDir, ""data_txnlog""));
+        ZKDatabase zkDb = new ZKDatabase(fileTxnSnapLog);
+
+        zks = new LeaderZooKeeperServer(fileTxnSnapLog, qp, zkDb);
+        leader = new Leader(qp, zks);
+        leaderBean = new LeaderBean(leader, zks);
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        fileTxnSnapLog.close();
+    }
+
+    @Test
+    public void testGetName() {
+        assertEquals(""Leader"", leaderBean.getName());
+    }
+
+    @Test
+    public void testGetCurrentZxid() {
+        // Arrange
+        zks.setZxid(1);
+
+        // Assert
+        assertEquals(""0x1"", leaderBean.getCurrentZxid());
+    }
+
+    @Test
+    public void testGetElectionTimeTaken() {
+        // Arrange
+        qp.setElectionTimeTaken(1);
+
+        // Assert
+        assertEquals(1, leaderBean.getElectionTimeTaken());
+    }
+
+    private Request createMockRequest() throws IOException {","[{'comment': 'is this ever used?', 'commenter': 'afine'}, {'comment': 'No, removed.', 'commenter': 'anmolnar'}]"
440,src/java/main/org/apache/zookeeper/server/ZKDatabase.java,"@@ -264,19 +262,8 @@ public void addCommittedProposal(Request request) {
                 maxCommittedLog = request.zxid;
             }
 
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
-            try {
-                request.getHdr().serialize(boa, ""hdr"");
-                if (request.getTxn() != null) {
-                    request.getTxn().serialize(boa, ""txn"");
-                }
-                baos.close();
-            } catch (IOException e) {
-                LOG.error(""This really should be impossible"", e);
-            }
-            QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid,
-                    baos.toByteArray(), null);
+            byte[] data = SerializeUtils.serializeRequest(request);","[{'comment': 'Is this really apropos to the stated reason for the PR? If not separating out to another PR means 1) easier to review this patch, and 2) might be easier to get this committed separately rather than tying it to another issue.', 'commenter': 'phunt'}, {'comment': ""Just a small refactoring. I'm happy to submit in another PR."", 'commenter': 'anmolnar'}]"
443,ivy.xml,"@@ -133,6 +133,8 @@
     <dependency org=""org.codehaus.jackson"" name=""jackson-mapper-asl""
                 rev=""${jackson-mapper-asl.version}"" conf=""optional->default""/>
 
+    <dependency org=""org.openclover"" name=""clover"" rev=""${clover.version}""/>","[{'comment': ""doesn't this need to be in it's own conf, similar to owasp, releaseaudit, etc.. ?"", 'commenter': 'phunt'}]"
443,build.xml,"@@ -124,6 +160,7 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
     <property name=""ivy.javacc.lib"" value=""${build.dir}/javacc/lib""/>
     <property name=""ivy.releaseaudit.lib"" value=""${build.dir}/releaseaudit/lib""/>
     <property name=""ivy.owasp.lib"" value=""${build.dir}/owasp/lib""/>
+    <property name=""ivy.coverage.lib"" value=""${test.java.build.dir}/lib""/>","[{'comment': 'This directory is inconsistent with all the other tools - why?', 'commenter': 'phunt'}, {'comment': ""I did see the naming inconsistency, but on the other hand code coverage measurement belongs to testing, and everything related to testing is placed under build/test. Not all the tools have their own subdirectory under the build directory (like javacc, releaseaudit, owasp), e.g. JUnit does not have. If JUnit does not have its own subdirectory under build/, then why should OpenClover have. If the reason to put OpenClover under an own build/coverage directory instead of putting it into build/test/lib is packaging, i.e. not delivering the clover jar in releases, then basically the answer is that a ZK compiled with Clover should not be released. I also verified that ant tar does not include build/test/lib jars. If ant targets tar, jar, compile, test-core-java etc. are run without the -Drun.clover=true parameter, then the clover jar is not even retrieved by ivy, so it won't be included, everything will run as before. Another reason is, that originally in current code everything related to Clover (db, reports) is configured to be under build/test/clover. If Clover db and reports are under build/test/clover, then why should the clover jar be put in build/coverage/lib and not in build/test/lib? All-in-all, these were the reasons behind my decision to put Clover under build/test/lib instead of build/coverage/lib. However, I agree that this is a naming inconsistency and I can see the reason that everything which has its own ivy configuration should have its own directory under build, so I can change the location of Clover if you prefer having Clover under build/coverage/lib."", 'commenter': 'Unknown'}, {'comment': 'My concern here is around classpath issues. Ideally I would like to make sure that clover and its dependencies (my understanding is that there are none currently but this could change) are only included when we are instrumenting coverage. The given setup may see us including clover in the test classpath even when not intended. For example, a developer wants to run the tests with clover and then immediately after without. If my understanding is correct, it there is no `clean` before those two executions clover will be included in the classpath of the second. \r\n', 'commenter': 'afine'}, {'comment': 'Ok. So would changing the location of Clover to ${build.dir}/clover/lib solve this problem?\r\n\r\n* Are you ok with the following directory structure:\r\nbuild/clover/db for Clover database,\r\nbuild/clover/jar for Clover jar,\r\nbuild/clover/reports for Clover reports, and\r\nclover.home=${build.dir}/clover\r\n\r\n* Should I change property name ""ivy.coverage.lib"" to ""ivy.clover.lib""?', 'commenter': 'Unknown'}]"
443,build.xml,"@@ -132,21 +169,16 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
     <property name=""ant_task_repo_url""
         value=""${mvnrepo}${tsk.org}${ant-task.version}/maven-ant-tasks-${ant-task.version}.jar""/>
     <property name=""ant_task.jar"" location=""${ivy.lib}/maven-ant-tasks-${ant-task.version}.jar""/>
-    
-    <available property=""clover.present""
-               classname=""com.cenqua.clover.CloverInstr""
-               classpath=""${clover.home}/lib/clover.jar""/>
 
-    <available file=""${c.src.dir}/Makefile"" property=""Makefile.present""/>
-
-    <!-- check if clover reports should be generated -->
-    <condition property=""clover.enabled"">
-      <and>
-        <isset property=""run.clover""/>
-        <isset property=""clover.present""/>
-      </and>
-    </condition>
+    <!-- clover property set -->
+    <property name=""clover.home"" location=""${test.java.build.dir}""/>","[{'comment': ""Similar as comment above - can't we contain this all in it's own subdir?"", 'commenter': 'phunt'}, {'comment': ""The main reason why I set clover.home to ${test.java.build.dir} is because originally in master, 3.5 and 3.4 Clover db is set to ${test.java.build.dir}/clover/db and Clover reports are set to ${test.java.build.dir}/clover/reports. This indicates that clover.home should be ${test.java.build.dir}. Since Clover was in use before this change, I thought it's better to keep the original settings as other tools (e.g. a Jenkins job) might rely on reports being generated under this location. @anmolnar also recommended to use this setting in his comment. Setting clover.home to ${test.java.build.dir} does not put everything related to Clover directly under build/test, as Clover db goes into build/test/clover/db, Clover reports go under build/test/clover/reports and clover jar is placed in /build/test/lib. Of course, I can change clover.home to point to any other location, e.g. to build/coverage, but one reason against it might be that Clover code coverage is more related to test than to build."", 'commenter': 'Unknown'}]"
443,build.xml,"@@ -1406,50 +1410,53 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
 
     <target name=""test-core"" depends=""test-core-java, test-core-cppunit""/>
 
+    <target name=""test-coverage-java"">","[{'comment': 'Why do we need this given we have a ""clover"" target?\r\n\r\nI\'m also hesitant to explicitly code that ""coverage"" == clover. In the past we\'ve allowed coverage other than clover to be used.\r\n\r\nperhaps ""test-coverage-clover-java"" instead?', 'commenter': 'phunt'}, {'comment': 'Because the ""clover"" target does not generate the HTML and XML reports. \r\nIt\'s used to initialise and setup Clover and it\'s called as a dependency of ""compile"" to instrument source code.\r\n\r\nI think declaring a ""test-coverage-java"" target to run Clover does not mean ""coverage"" == clover. The fact that it currently calls ""test-core-java"" and ""generate-clover-reports"" does not mean that we would not allow anybody to add/use other code coverage tools here.\r\n\r\nThe reason behind the naming was that I\'m also planning to add C code coverage tests, and following the already existing ant target names ""test-core-java"" and ""test-core-cppunit"" as naming patterns, there could be targets ""test-coverage-java"" and ""test-coverage-cppunit"" to generate coverage reports for Java and C, respectively. \r\n\r\nTheir parent target could be ""test-coverage"", which would run ""test-coverage-java"" and ""test-coverage-cppunit"" to prepare a complete coverage report for both Java and C.\r\n\r\nThen running a full coverage report for ZK would be as simple as running ""test-coverage"".\r\nPlease let me know what you think.', 'commenter': 'Unknown'}, {'comment': '@phunt Actually, if you prefer, I could rename both the ivy configuration and the ant target for clover to ""test-coverage-clover-java"" as this does not exclude the possibility of including it into a test-coverage-java target later.', 'commenter': 'Unknown'}, {'comment': '""I think declaring a ""test-coverage-java"" target to run Clover does not mean ""coverage"" == clover. The fact that it currently calls ""test-core-java"" and ""generate-clover-reports"" does not mean that we would not allow anybody to add/use other code coverage tools here.""\r\n\r\nNotice how we have cobertura down below in the build.xml file. This is what I mean. ""test-coverage-java"" just calls clover. If we had created a ""test-coverage-java"" in the past that called cobertura it seems like that\'s a statement. It\'s not a big deal, but hopefully you see what I mean.\r\n\r\nRenaming to be more clover specific seems reasonable to me.', 'commenter': 'phunt'}]"
443,build.xml,"@@ -23,6 +23,48 @@ xmlns:artifact=""antlib:org.apache.maven.artifact.ant""
 xmlns:maven=""antlib:org.apache.maven.artifact.ant""
 xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
 
+    <!-- ====================================================== -->","[{'comment': 'why was this stuff moved?', 'commenter': 'afine'}, {'comment': '@afine \r\nBecause I need\r\n`<property name=""clover.version"" value=""4.2.1"" />`\r\nin\r\n`<property name=""clover.jar"" location=""${clover.home}/lib/clover-${clover.version}.jar""/>`\r\nand the dependency versions at their original location were declared later than clover.jar, so clover.version was undefined at this point.\r\n\r\nI had 3 choices:\r\n1. move the clover property set behind the dependency version declarations just before the macro definitions, separating it from the other property set declarations,\r\n1. move all the dependency version declarations before the clover property set,\r\n1. or just declare the clover.version separately from the other dependency versions in the clover property set block.\r\n\r\nI\'ve chosen option 2 as I thought that was the best out of the three.\r\nPlease let me know if there is a better way to solve this.', 'commenter': 'Unknown'}]"
443,build.xml,"@@ -1406,50 +1410,53 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
 
     <target name=""test-core"" depends=""test-core-java, test-core-cppunit""/>
 
+    <target name=""test-coverage-java"">
+        <antcall target=""test-core-java"">
+            <param name=""run.clover"" value=""true""/>
+        </antcall>
+        <antcall target=""generate-clover-reports""/>
+    </target>
+
     <!-- ====================================================== -->
     <!-- Run optional third-party tool targets                  -->
     <!-- ====================================================== -->
 
     <!-- clover code coverage -->
-    <target name=""clover"" depends=""clover.setup, clover.info"" 
-            description=""Instrument the Unit tests using Clover.  Requires a Clover license and CLOVER_HOME environment variable set appropriately.  To use, specify -Drun.clover=true on the command line.""/>
+    <target name=""clover"" if=""run.clover"" depends=""ivy-retrieve-test-coverage-java, clover.check, clover.setup""
+            description=""Instrument the Unit tests using Clover. To use, specify -Drun.clover=true on the command line.""/>","[{'comment': 'we should update this description to show that we have an ant task that can be used instead of specifying a system property', 'commenter': 'afine'}]"
443,build.xml,"@@ -1861,4 +1876,18 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
        <delete dir=""${build.dir.eclipse}"" />
      </target>
 
+    <target name=""print_compile_classpath"">","[{'comment': 'As we discussed offline please move these useful targets to a new JIRA.', 'commenter': 'afine'}]"
446,src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -1751,7 +1751,7 @@ public synchronized void initConfigInZKDatabase() {
         if (zkDb != null) zkDb.initConfigInZKDatabase(getQuorumVerifier());
     }
     
-    public void setRunning(boolean running) {
+    private void setRunning(boolean running) {","[{'comment': ""I can't see the point of using a private setter. Set the field directly instead."", 'commenter': 'anmolnar'}, {'comment': ""I'm also ambiguous about this change.could you give me some your insight?"", 'commenter': 'maoling'}, {'comment': 'Where are we with this @maoling @anmolnar ?', 'commenter': 'phunt'}, {'comment': ""Sorry for the late answer. It's not too much of an insight, rather - in general - I don't see the point of using a private setter without logic. In other words, is there any objection against setting the field directly?"", 'commenter': 'anmolnar'}, {'comment': '@maoling ?', 'commenter': 'phunt'}, {'comment': '+1 to @anmolnar i think we can remote the setter', 'commenter': 'afine'}]"
447,src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -579,13 +579,8 @@ protected void pRequest2Txn(int type, long zxid, Request request,
                 int to = request.request.getInt();
                 request.setTxn(new CreateSessionTxn(to));
                 request.request.rewind();
-                if (request.isLocalSession()) {
-                    // This will add to local session tracker if it is enabled
-                    zks.sessionTracker.addSession(request.sessionId, to);
-                } else {
-                    // Explicitly add to global session if the flag is not set
-                    zks.sessionTracker.addGlobalSession(request.sessionId, to);
-                }
+                // only add the global session tracker but not to ZKDb
+                zks.sessionTracker.addGlobalSession(request.sessionId, to);","[{'comment': 'You could remove this check safely, because effectively there was no difference between `addSession()` and `addGlobalSession()` calls.', 'commenter': 'anmolnar'}, {'comment': 'On LeaderSessionTracker, we need to differentiate add local session or global session, but since we only call createSession when add local session, I think I can simplify the interface more by removing addGlobalSession and rename addSession to trackSession.', 'commenter': 'lvfangmin'}]"
447,src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java,"@@ -280,6 +278,12 @@ public synchronized boolean addSession(long id, int sessionTimeout) {
         return added;
     }
 
+    public synchronized boolean commitSession(long id, int sessionTimeout) {","[{'comment': ""`sessionsWithTimeout` is a Map within ZKdb, so adding sessions to it is equivalent to persisting them.\r\n\r\nI think you could also remove the `addGlobalSession()` method completely, because it doesn't do anything special than forwarding the call to `addSession()`."", 'commenter': 'anmolnar'}, {'comment': ""Yes, that's kind of commit changes to ZkDB, like the usual txns commit to DataTree in ZkDB."", 'commenter': 'lvfangmin'}]"
447,src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1187,13 +1187,8 @@ private ProcessTxnResult processTxn(Request request, TxnHeader hdr,
         if (opCode == OpCode.createSession) {
             if (hdr != null && txn instanceof CreateSessionTxn) {
                 CreateSessionTxn cst = (CreateSessionTxn) txn;
-                sessionTracker.addGlobalSession(sessionId, cst.getTimeOut());
-            } else if (request != null && request.isLocalSession()) {
-                request.request.rewind();
-                int timeout = request.request.getInt();
-                request.request.rewind();
-                sessionTracker.addSession(request.sessionId, timeout);
-            } else {
+                sessionTracker.commitSession(sessionId, cst.getTimeOut());
+            } else if (request == null || !request.isLocalSession()) {","[{'comment': ""Do you need this check here?\r\nBasically you removed the part of requesting localSession creation, because it has already happened in PrepRequestProcessor and it's safe to leave the default 'else' handler as it was."", 'commenter': 'anmolnar'}, {'comment': ""Local session creation is happened in ZooKeeperServer when the when processing connection request, PrepRequestProcessor only deals with the global sessions.\r\n\r\nLocal session creation will also send a createSession op into the processor pipeline, so if we remove the else check, a lot of warning log will show for local session createSession op, that's not what we wanted."", 'commenter': 'lvfangmin'}]"
447,src/java/main/org/apache/zookeeper/server/quorum/LearnerSessionTracker.java,"@@ -102,32 +101,42 @@ public boolean isGlobalSession(long sessionId) {
     }
 
     public boolean addGlobalSession(long sessionId, int sessionTimeout) {
+        // no global session tracker, do nothing
+        return false;","[{'comment': 'Is it possible to throw UnsupportedOperationException instead?', 'commenter': 'anmolnar'}]"
447,src/java/test/org/apache/zookeeper/test/SessionTrackerCheckTest.java,"@@ -185,8 +182,8 @@ public void testLeaderSessionTracker() throws Exception {
                 TICK_TIME, expirer.sid, false, testZKSListener());
 
         // Global session
-        sessionId = 0xdeadbeef;
-        tracker.addSession(sessionId, CONNECTION_TIMEOUT);
+        sessionId = 0xdeadbef0;","[{'comment': 'Why have you changed this? :)', 'commenter': 'anmolnar'}, {'comment': ""I think this is not changed by intention, might happen when merge patch, I'll get this fixed."", 'commenter': 'lvfangmin'}]"
447,src/java/test/org/apache/zookeeper/server/quorum/SessionUpgradeTest.java,"@@ -0,0 +1,516 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.concurrent.ConcurrentHashMap;
+import javax.security.sasl.SaslException;
+
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.ZooKeeper.States;
+import org.apache.zookeeper.data.Id;
+import org.apache.zookeeper.proto.CreateRequest;
+import org.apache.zookeeper.test.ClientBase;
+import org.apache.zookeeper.test.ClientBase.CountdownWatcher;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.server.ByteBufferInputStream;
+import org.apache.zookeeper.server.Request;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.zookeeper.test.QuorumBase;
+import org.apache.zookeeper.test.DisconnectableZooKeeper;
+
+/**
+ * Tests that session upgrade works from local to global sessions.
+ * Expected behavior is that if global-only sessions are unset,
+ * and no upgrade interval is specified, then sessions will be
+ * created locally to the host.  They will be upgraded to global
+ * sessions iff an operation is done on that session which requires
+ * persistence, i.e. creating an ephemeral node.
+ */
+public class SessionUpgradeTest extends QuorumPeerTestBase {
+    protected static final Logger LOG = LoggerFactory.getLogger(SessionUpgradeTest.class);
+    public static final int CONNECTION_TIMEOUT = ClientBase.CONNECTION_TIMEOUT;
+
+    private final QuorumBase qb = new QuorumBase();
+
+    @Before
+    public void setUp() throws Exception {
+        LOG.info(""STARTING quorum "" + getClass().getName());
+        qb.localSessionsEnabled = true;
+        qb.localSessionsUpgradingEnabled = true;
+        qb.setUp();
+        ClientBase.waitForServerUp(qb.hostPort, 10000);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        LOG.info(""STOPPING quorum "" + getClass().getName());
+        qb.tearDown();
+    }
+
+    @Test
+    public void testLocalSessionsWithoutEphemeralOnFollower() throws Exception {
+        testLocalSessionsWithoutEphemeral(false);
+    }
+
+    @Test
+    public void testLocalSessionsWithoutEphemeralOnLeader() throws Exception {
+        testLocalSessionsWithoutEphemeral(true);
+    }
+
+    private void testLocalSessionsWithoutEphemeral(boolean testLeader)
+            throws Exception {
+        String nodePrefix = ""/testLocalSessions-""
+            + (testLeader ? ""leaderTest-"" : ""followerTest-"");
+        int leaderIdx = qb.getLeaderIndex();
+        Assert.assertFalse(""No leader in quorum?"", leaderIdx == -1);
+        int followerIdx = (leaderIdx + 1) % 5;
+        int otherFollowerIdx = (leaderIdx + 2) % 5;
+        int testPeerIdx = testLeader ? leaderIdx : followerIdx;
+        String hostPorts[] = qb.hostPort.split("","");
+        CountdownWatcher watcher = new CountdownWatcher();
+        DisconnectableZooKeeper zk = new DisconnectableZooKeeper(
+                hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);
+        watcher.waitForConnected(CONNECTION_TIMEOUT);
+
+        // Try creating some data.
+        for (int i = 0; i < 5; i++) {
+            zk.create(nodePrefix + i, new byte[0],
+                      ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+        }
+
+        long localSessionId = zk.getSessionId();
+        byte[] localSessionPwd = zk.getSessionPasswd().clone();
+
+        // Try connecting with the same session id on a different
+        // server.  This should fail since it is a local sesion.
+        try {
+            watcher.reset();
+            DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(
+                    hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher,
+                    localSessionId, localSessionPwd);
+
+            zknew.create(nodePrefix + ""5"", new byte[0],
+                         ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+            Assert.fail(""Connection on the same session ID should fail."");
+        } catch (KeeperException.SessionExpiredException e) {
+        } catch (KeeperException.ConnectionLossException e) {
+        }
+
+        // If we're testing a follower, also check the session id on the
+        // leader. This should also fail
+        if (!testLeader) {
+            try {
+                watcher.reset();
+                DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(
+                        hostPorts[leaderIdx], CONNECTION_TIMEOUT,
+                        watcher, localSessionId, localSessionPwd);
+
+                zknew.create(nodePrefix + ""5"", new byte[0],
+                             ZooDefs.Ids.OPEN_ACL_UNSAFE,
+                             CreateMode.PERSISTENT);
+                Assert.fail(""Connection on the same session ID should fail."");
+            } catch (KeeperException.SessionExpiredException e) {
+            } catch (KeeperException.ConnectionLossException e) {
+            }
+        }
+
+        // However, we should be able to disconnect and reconnect to the same
+        // server with the same session id (as long as we do it quickly
+        // before expiration).
+        zk.disconnect();
+
+        watcher.reset();
+        zk = new DisconnectableZooKeeper(
+                hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher,
+                localSessionId, localSessionPwd);
+        watcher.waitForConnected(CONNECTION_TIMEOUT);
+
+        zk.create(nodePrefix + ""6"", new byte[0],
+                  ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+
+        // If we explicitly close the session, then the session id should no
+        // longer be valid.
+        zk.close();
+        try {
+            watcher.reset();
+            zk = new DisconnectableZooKeeper(
+                    hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher,
+                    localSessionId, localSessionPwd);
+
+            zk.create(nodePrefix + ""7"", new byte[0],
+                      ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+            Assert.fail(""Reconnecting to a closed session ID should fail."");
+        } catch (KeeperException.SessionExpiredException e) {
+        }
+    }
+
+    @Test
+    public void testUpgradeWithEphemeralOnFollower() throws Exception {
+        testUpgradeWithEphemeral(false);
+    }
+
+    @Test
+    public void testUpgradeWithEphemeralOnLeader() throws Exception {
+        testUpgradeWithEphemeral(true);
+    }
+
+    private void testUpgradeWithEphemeral(boolean testLeader)
+            throws Exception {
+        String nodePrefix = ""/testUpgrade-""
+            + (testLeader ? ""leaderTest-"" : ""followerTest-"");
+        int leaderIdx = qb.getLeaderIndex();
+        Assert.assertFalse(""No leader in quorum?"", leaderIdx == -1);
+        int followerIdx = (leaderIdx + 1) % 5;
+        int otherFollowerIdx = (leaderIdx + 2) % 5;
+        int testPeerIdx = testLeader ? leaderIdx : followerIdx;
+        String hostPorts[] = qb.hostPort.split("","");
+
+        CountdownWatcher watcher = new CountdownWatcher();
+        DisconnectableZooKeeper zk = new DisconnectableZooKeeper(
+                hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);
+        watcher.waitForConnected(CONNECTION_TIMEOUT);
+
+        // Create some ephemeral nodes.  This should force the session to
+        // be propagated to the other servers in the ensemble.
+        for (int i = 0; i < 5; i++) {
+            zk.create(nodePrefix + i, new byte[0],
+                      ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
+        }
+
+        // We should be able to reconnect with the same session id on a
+        // different server, since it has been propagated.
+        long localSessionId = zk.getSessionId();
+        byte[] localSessionPwd = zk.getSessionPasswd().clone();
+
+        zk.disconnect();
+        watcher.reset();
+        zk = new DisconnectableZooKeeper(
+                hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher,
+                localSessionId, localSessionPwd);
+        watcher.waitForConnected(CONNECTION_TIMEOUT);
+
+        // The created ephemeral nodes are still around.
+        for (int i = 0; i < 5; i++) {
+            Assert.assertNotNull(zk.exists(nodePrefix + i, null));
+        }
+
+        // When we explicitly close the session, we should not be able to
+        // reconnect with the same session id
+        zk.close();
+
+        try {
+            watcher.reset();
+            zk = new DisconnectableZooKeeper(
+                    hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher,
+                    localSessionId, localSessionPwd);
+            zk.exists(nodePrefix + ""0"", null);
+            Assert.fail(""Reconnecting to a closed session ID should fail."");
+        } catch (KeeperException.SessionExpiredException e) {
+        }
+
+        watcher.reset();
+        // And the ephemeral nodes will be gone since the session died.
+        zk = new DisconnectableZooKeeper(
+                hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);
+        watcher.waitForConnected(CONNECTION_TIMEOUT);
+        for (int i = 0; i < 5; i++) {
+            Assert.assertNull(zk.exists(nodePrefix + i, null));
+        }
+    }
+
+    @Test
+    public void testLocalSessionUpgradeSnapshot() throws IOException, InterruptedException {
+        // setup the env with RetainDB and local session upgrading
+        ClientBase.setupTestEnv();
+
+        final int SERVER_COUNT = 3;
+        final int clientPorts[] = new int[SERVER_COUNT];
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            clientPorts[i] = PortAssignment.unique();
+            sb.append(""server."").append(i).append(""=127.0.0.1:"")
+              .append(PortAssignment.unique()).append("":"")
+              .append(PortAssignment.unique()).append(""\n"");
+        }
+        sb.append(""localSessionsEnabled=true\n"");
+        sb.append(""localSessionsUpgradingEnabled=true\n"");
+        String cfg = sb.toString();
+
+        // create a 3 server ensemble
+        MainThread mt[] = new MainThread[SERVER_COUNT];
+        final TestQPMainDropSessionUpgrading qpMain[] =
+                new TestQPMainDropSessionUpgrading[SERVER_COUNT];
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            final TestQPMainDropSessionUpgrading qp = new TestQPMainDropSessionUpgrading();
+            qpMain[i] = qp;
+            mt[i] = new MainThread(i, clientPorts[i], cfg, false) {
+                @Override
+                public TestQPMain getTestQPMain() {
+                    return qp;
+                }
+            };
+            mt[i].start();
+        }
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            Assert.assertTrue(""waiting for server "" + i + "" being up"",
+                    ClientBase.waitForServerUp(""127.0.0.1:"" + clientPorts[i],
+                            CONNECTION_TIMEOUT));
+        }","[{'comment': ""Test initialization logic is better placed in setUp() method especially when it's common in multiple tests.\r\n(That would be one benefit of moving new tests to new file)"", 'commenter': 'anmolnar'}]"
447,src/java/test/org/apache/zookeeper/server/quorum/SessionUpgradeTest.java,"@@ -0,0 +1,516 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.concurrent.ConcurrentHashMap;
+import javax.security.sasl.SaslException;
+
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.ZooKeeper.States;
+import org.apache.zookeeper.data.Id;
+import org.apache.zookeeper.proto.CreateRequest;
+import org.apache.zookeeper.test.ClientBase;
+import org.apache.zookeeper.test.ClientBase.CountdownWatcher;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.server.ByteBufferInputStream;
+import org.apache.zookeeper.server.Request;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.zookeeper.test.QuorumBase;
+import org.apache.zookeeper.test.DisconnectableZooKeeper;
+
+/**
+ * Tests that session upgrade works from local to global sessions.
+ * Expected behavior is that if global-only sessions are unset,
+ * and no upgrade interval is specified, then sessions will be
+ * created locally to the host.  They will be upgraded to global
+ * sessions iff an operation is done on that session which requires
+ * persistence, i.e. creating an ephemeral node.
+ */
+public class SessionUpgradeTest extends QuorumPeerTestBase {
+    protected static final Logger LOG = LoggerFactory.getLogger(SessionUpgradeTest.class);
+    public static final int CONNECTION_TIMEOUT = ClientBase.CONNECTION_TIMEOUT;
+
+    private final QuorumBase qb = new QuorumBase();
+
+    @Before
+    public void setUp() throws Exception {
+        LOG.info(""STARTING quorum "" + getClass().getName());
+        qb.localSessionsEnabled = true;
+        qb.localSessionsUpgradingEnabled = true;
+        qb.setUp();
+        ClientBase.waitForServerUp(qb.hostPort, 10000);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        LOG.info(""STOPPING quorum "" + getClass().getName());
+        qb.tearDown();
+    }
+
+    @Test
+    public void testLocalSessionsWithoutEphemeralOnFollower() throws Exception {
+        testLocalSessionsWithoutEphemeral(false);
+    }
+
+    @Test
+    public void testLocalSessionsWithoutEphemeralOnLeader() throws Exception {
+        testLocalSessionsWithoutEphemeral(true);
+    }
+
+    private void testLocalSessionsWithoutEphemeral(boolean testLeader)
+            throws Exception {
+        String nodePrefix = ""/testLocalSessions-""
+            + (testLeader ? ""leaderTest-"" : ""followerTest-"");
+        int leaderIdx = qb.getLeaderIndex();
+        Assert.assertFalse(""No leader in quorum?"", leaderIdx == -1);
+        int followerIdx = (leaderIdx + 1) % 5;
+        int otherFollowerIdx = (leaderIdx + 2) % 5;
+        int testPeerIdx = testLeader ? leaderIdx : followerIdx;
+        String hostPorts[] = qb.hostPort.split("","");
+        CountdownWatcher watcher = new CountdownWatcher();
+        DisconnectableZooKeeper zk = new DisconnectableZooKeeper(
+                hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);
+        watcher.waitForConnected(CONNECTION_TIMEOUT);
+
+        // Try creating some data.
+        for (int i = 0; i < 5; i++) {
+            zk.create(nodePrefix + i, new byte[0],
+                      ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+        }
+
+        long localSessionId = zk.getSessionId();
+        byte[] localSessionPwd = zk.getSessionPasswd().clone();
+
+        // Try connecting with the same session id on a different
+        // server.  This should fail since it is a local sesion.
+        try {
+            watcher.reset();
+            DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(
+                    hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher,
+                    localSessionId, localSessionPwd);
+
+            zknew.create(nodePrefix + ""5"", new byte[0],
+                         ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+            Assert.fail(""Connection on the same session ID should fail."");
+        } catch (KeeperException.SessionExpiredException e) {
+        } catch (KeeperException.ConnectionLossException e) {
+        }
+
+        // If we're testing a follower, also check the session id on the
+        // leader. This should also fail
+        if (!testLeader) {
+            try {
+                watcher.reset();
+                DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(
+                        hostPorts[leaderIdx], CONNECTION_TIMEOUT,
+                        watcher, localSessionId, localSessionPwd);
+
+                zknew.create(nodePrefix + ""5"", new byte[0],
+                             ZooDefs.Ids.OPEN_ACL_UNSAFE,
+                             CreateMode.PERSISTENT);
+                Assert.fail(""Connection on the same session ID should fail."");
+            } catch (KeeperException.SessionExpiredException e) {
+            } catch (KeeperException.ConnectionLossException e) {
+            }
+        }
+
+        // However, we should be able to disconnect and reconnect to the same
+        // server with the same session id (as long as we do it quickly
+        // before expiration).
+        zk.disconnect();
+
+        watcher.reset();
+        zk = new DisconnectableZooKeeper(
+                hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher,
+                localSessionId, localSessionPwd);
+        watcher.waitForConnected(CONNECTION_TIMEOUT);
+
+        zk.create(nodePrefix + ""6"", new byte[0],
+                  ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+
+        // If we explicitly close the session, then the session id should no
+        // longer be valid.
+        zk.close();
+        try {
+            watcher.reset();
+            zk = new DisconnectableZooKeeper(
+                    hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher,
+                    localSessionId, localSessionPwd);
+
+            zk.create(nodePrefix + ""7"", new byte[0],
+                      ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+            Assert.fail(""Reconnecting to a closed session ID should fail."");
+        } catch (KeeperException.SessionExpiredException e) {
+        }
+    }
+
+    @Test
+    public void testUpgradeWithEphemeralOnFollower() throws Exception {
+        testUpgradeWithEphemeral(false);
+    }
+
+    @Test
+    public void testUpgradeWithEphemeralOnLeader() throws Exception {
+        testUpgradeWithEphemeral(true);
+    }
+
+    private void testUpgradeWithEphemeral(boolean testLeader)
+            throws Exception {
+        String nodePrefix = ""/testUpgrade-""
+            + (testLeader ? ""leaderTest-"" : ""followerTest-"");
+        int leaderIdx = qb.getLeaderIndex();
+        Assert.assertFalse(""No leader in quorum?"", leaderIdx == -1);
+        int followerIdx = (leaderIdx + 1) % 5;
+        int otherFollowerIdx = (leaderIdx + 2) % 5;
+        int testPeerIdx = testLeader ? leaderIdx : followerIdx;
+        String hostPorts[] = qb.hostPort.split("","");
+
+        CountdownWatcher watcher = new CountdownWatcher();
+        DisconnectableZooKeeper zk = new DisconnectableZooKeeper(
+                hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);
+        watcher.waitForConnected(CONNECTION_TIMEOUT);
+
+        // Create some ephemeral nodes.  This should force the session to
+        // be propagated to the other servers in the ensemble.
+        for (int i = 0; i < 5; i++) {
+            zk.create(nodePrefix + i, new byte[0],
+                      ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
+        }
+
+        // We should be able to reconnect with the same session id on a
+        // different server, since it has been propagated.
+        long localSessionId = zk.getSessionId();
+        byte[] localSessionPwd = zk.getSessionPasswd().clone();
+
+        zk.disconnect();
+        watcher.reset();
+        zk = new DisconnectableZooKeeper(
+                hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher,
+                localSessionId, localSessionPwd);
+        watcher.waitForConnected(CONNECTION_TIMEOUT);
+
+        // The created ephemeral nodes are still around.
+        for (int i = 0; i < 5; i++) {
+            Assert.assertNotNull(zk.exists(nodePrefix + i, null));
+        }
+
+        // When we explicitly close the session, we should not be able to
+        // reconnect with the same session id
+        zk.close();
+
+        try {
+            watcher.reset();
+            zk = new DisconnectableZooKeeper(
+                    hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher,
+                    localSessionId, localSessionPwd);
+            zk.exists(nodePrefix + ""0"", null);
+            Assert.fail(""Reconnecting to a closed session ID should fail."");
+        } catch (KeeperException.SessionExpiredException e) {
+        }
+
+        watcher.reset();
+        // And the ephemeral nodes will be gone since the session died.
+        zk = new DisconnectableZooKeeper(
+                hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);
+        watcher.waitForConnected(CONNECTION_TIMEOUT);
+        for (int i = 0; i < 5; i++) {
+            Assert.assertNull(zk.exists(nodePrefix + i, null));
+        }
+    }
+
+    @Test
+    public void testLocalSessionUpgradeSnapshot() throws IOException, InterruptedException {
+        // setup the env with RetainDB and local session upgrading
+        ClientBase.setupTestEnv();
+
+        final int SERVER_COUNT = 3;
+        final int clientPorts[] = new int[SERVER_COUNT];
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            clientPorts[i] = PortAssignment.unique();
+            sb.append(""server."").append(i).append(""=127.0.0.1:"")
+              .append(PortAssignment.unique()).append("":"")
+              .append(PortAssignment.unique()).append(""\n"");
+        }
+        sb.append(""localSessionsEnabled=true\n"");
+        sb.append(""localSessionsUpgradingEnabled=true\n"");
+        String cfg = sb.toString();
+
+        // create a 3 server ensemble
+        MainThread mt[] = new MainThread[SERVER_COUNT];
+        final TestQPMainDropSessionUpgrading qpMain[] =
+                new TestQPMainDropSessionUpgrading[SERVER_COUNT];
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            final TestQPMainDropSessionUpgrading qp = new TestQPMainDropSessionUpgrading();
+            qpMain[i] = qp;
+            mt[i] = new MainThread(i, clientPorts[i], cfg, false) {
+                @Override
+                public TestQPMain getTestQPMain() {
+                    return qp;
+                }
+            };
+            mt[i].start();
+        }
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            Assert.assertTrue(""waiting for server "" + i + "" being up"",
+                    ClientBase.waitForServerUp(""127.0.0.1:"" + clientPorts[i],
+                            CONNECTION_TIMEOUT));
+        }
+
+        // select the candidate of follower
+        int leader = -1;
+        int followerA = -1;
+        for (int i = SERVER_COUNT - 1; i >= 0; i--) {
+            if (mt[i].main.quorumPeer.leader != null) {
+                leader = i;
+            } else if (followerA == -1) {
+                followerA = i;
+            }
+        }
+
+        LOG.info(""follower A is {}"", followerA);
+        qpMain[followerA].setDropCreateSession(true);
+
+        // create a client, and create an ephemeral node to trigger the
+        // upgrading process
+        final String node = ""/node-1"";
+        ZooKeeper zk = new ZooKeeper(""127.0.0.1:"" + clientPorts[followerA],
+                    ClientBase.CONNECTION_TIMEOUT, this);
+
+        waitForOne(zk, States.CONNECTED);
+
+        // clone the session id and passwd for later usage
+        long sessionId = zk.getSessionId();
+
+        // should fail because of the injection
+        try {
+            zk.create(node, new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE,
+                    CreateMode.EPHEMERAL);
+            Assert.fail(""expect to failed to upgrade session due to the "" +
+                    ""TestQPMainDropSessionUpgrading is being used"");
+        } catch (KeeperException e) {
+            LOG.info(""KeeperException when create ephemeral node, {}"", e);
+        }
+
+        // force to take snapshot
+        qpMain[followerA].quorumPeer.follower.zk.takeSnapshot(true);
+
+        // wait snapshot finish
+        Thread.sleep(500);
+
+        // shutdown all servers
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i].shutdown();
+        }
+
+        ArrayList<States> waitStates =new ArrayList<States>();
+        waitStates.add(States.CONNECTING);
+        waitStates.add(States.CLOSED);
+        waitForOne(zk, waitStates);
+
+        // start the servers again, start follower A last as we want to
+        // keep it running as follower
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i].start();
+        }
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            Assert.assertTrue(""waiting for server "" + i + "" being up"",
+                    ClientBase.waitForServerUp(""127.0.0.1:"" + clientPorts[i],
+                            CONNECTION_TIMEOUT));
+        }
+
+        // check global session not exist on follower A
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            ConcurrentHashMap<Long, Integer> sessions =
+                    mt[i].main.quorumPeer.getZkDb().getSessionWithTimeOuts();
+            Assert.assertFalse(""server "" + i + "" should not have global "" +
+                    ""session "" + sessionId, sessions.containsKey(sessionId));
+        }
+
+        // clean al the setups and close the zk","[{'comment': 'Similiarly cleanup logic should be moved to tearDown().', 'commenter': 'anmolnar'}]"
447,src/java/test/org/apache/zookeeper/test/ClientBase.java,"@@ -72,7 +72,7 @@
     static final File BASETEST =
         new File(System.getProperty(""build.test.dir"", ""build""));
 
-    protected String hostPort = ""127.0.0.1:"" + PortAssignment.unique();
+    public String hostPort = ""127.0.0.1:"" + PortAssignment.unique();","[{'comment': 'I am not sure why this change is required. ', 'commenter': 'hanm'}, {'comment': ""Was trying to change these settings to public so I can reference it in the SessionUpgradeQuorumTest.java, I guess I find a different way to to that and forgot to revert this change, will verify and remove this change if it's not necessary."", 'commenter': 'lvfangmin'}]"
447,src/java/test/org/apache/zookeeper/test/QuorumBase.java,"@@ -53,32 +53,32 @@
     protected int port3;
     protected int port4;
     protected int port5;
-    
+
     protected int portLE1;
     protected int portLE2;
     protected int portLE3;
     protected int portLE4;
     protected int portLE5;
-    
+
     protected int portClient1;
     protected int portClient2;
     protected int portClient3;
     protected int portClient4;
     protected int portClient5;
 
-    protected boolean localSessionsEnabled = false;
-    protected boolean localSessionsUpgradingEnabled = false;
+    public boolean localSessionsEnabled = false;
+    public boolean localSessionsUpgradingEnabled = false;","[{'comment': 'Not sure why this change is required. ', 'commenter': 'hanm'}, {'comment': ""Same reason, will check and remove it if it's not required."", 'commenter': 'lvfangmin'}]"
447,src/java/main/org/apache/zookeeper/server/quorum/UpgradeableSessionTracker.java,"@@ -19,6 +19,8 @@
 
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+import java.util.Set;
+import java.util.HashSet;","[{'comment': ""Are both imports needed? I don't see any new data structure introduced. "", 'commenter': 'hanm'}, {'comment': 'Yes, dangling import after implementation change, will remove. ', 'commenter': 'lvfangmin'}]"
447,src/java/main/org/apache/zookeeper/server/SessionTracker.java,"@@ -47,21 +47,20 @@
     long createSession(int sessionTimeout);
 
     /**
-     * Add a global session to those being tracked.
+     * Track the session expire, not add to ZkDb.
      * @param id sessionId
      * @param to sessionTimeout
      * @return whether the session was newly added (if false, already existed)","[{'comment': 'This comment on return value should be updated now with the function name change.', 'commenter': 'hanm'}]"
447,src/java/main/org/apache/zookeeper/server/SessionTracker.java,"@@ -47,21 +47,20 @@
     long createSession(int sessionTimeout);
 
     /**
-     * Add a global session to those being tracked.
+     * Track the session expire, not add to ZkDb.
      * @param id sessionId
      * @param to sessionTimeout
      * @return whether the session was newly added (if false, already existed)
      */
-    boolean addGlobalSession(long id, int to);
+    boolean trackSession(long id, int to);
 
     /**
-     * Add a session to those being tracked. The session is added as a local
-     * session if they are enabled, otherwise as global.
+     * Add the session to the under layer storage.","[{'comment': ""I think the comment here is a little bit confusing. `commitSession`itself does not directly add session to storage, it's the snapshot that does this. I think the comment should mention that this function will add the session to the zkDB, this also maps to the `trackSession` comment (which does not modify zkDB.). It would be great if a reader can instantly get what `commit` means here by just reading the comment."", 'commenter': 'hanm'}, {'comment': 'In LocalSessionTracker, commitSession is used to update the in memory local session map, which is not in zkDB. How about change it to:\r\n\r\n""Add the session to the local session map or global one in zkDB.""', 'commenter': 'lvfangmin'}]"
447,src/java/main/org/apache/zookeeper/server/SessionTracker.java,"@@ -47,21 +47,20 @@
     long createSession(int sessionTimeout);
 
     /**
-     * Add a global session to those being tracked.
+     * Track the session expire, not add to ZkDb.
      * @param id sessionId
      * @param to sessionTimeout
      * @return whether the session was newly added (if false, already existed)
      */
-    boolean addGlobalSession(long id, int to);
+    boolean trackSession(long id, int to);
 
     /**
-     * Add a session to those being tracked. The session is added as a local
-     * session if they are enabled, otherwise as global.
+     * Add the session to the under layer storage.
      * @param id sessionId
      * @param to sessionTimeout
      * @return whether the session was newly added (if false, already existed)","[{'comment': ""Similarly it'll be great if the comment on the return value here is updated."", 'commenter': 'hanm'}, {'comment': 'This comment about the return value is still correct', 'commenter': 'lvfangmin'}]"
447,src/java/main/org/apache/zookeeper/server/quorum/LeaderSessionTracker.java,"@@ -85,31 +85,43 @@ public boolean isGlobalSession(long sessionId) {
         return globalSessionTracker.isTrackingSession(sessionId);
     }
 
-    public boolean addGlobalSession(long sessionId, int sessionTimeout) {
-        boolean added =
-            globalSessionTracker.addSession(sessionId, sessionTimeout);
-        if (localSessionsEnabled && added) {
+    public boolean trackSession(long sessionId, int sessionTimeout) {
+        boolean tracked =
+            globalSessionTracker.trackSession(sessionId, sessionTimeout);
+        if (localSessionsEnabled && tracked) {
             // Only do extra logging so we know what kind of session this is
             // if we're supporting both kinds of sessions
-            LOG.info(""Adding global session 0x"" + Long.toHexString(sessionId));
+            LOG.info(""Tracking global session 0x"" + Long.toHexString(sessionId));
         }
-        return added;
+        return tracked;
     }
 
-    public boolean addSession(long sessionId, int sessionTimeout) {
-        boolean added;
-        if (localSessionsEnabled && !isGlobalSession(sessionId)) {
-            added = localSessionTracker.addSession(sessionId, sessionTimeout);","[{'comment': 'With this being removed, how would a `LeaderSessionTracker` now add (or track, with the new term) a new local session (when local session is enabled on Leader server)? The `LeaderSessionTracker.trackSession` does not track local session.', 'commenter': 'hanm'}, {'comment': ""When local session feature is enabled, the createSession method in ZooKeeperServer will create, track and 'commit' (update the local session in memory map) the local session immediately."", 'commenter': 'lvfangmin'}]"
447,src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java,"@@ -280,6 +275,11 @@ public synchronized boolean addSession(long id, int sessionTimeout) {
         return added;
     }
 
+    public synchronized boolean commitSession(long id, int sessionTimeout) {
+        sessionsWithTimeout.put(id, sessionTimeout);
+        return true;","[{'comment': 'Should we make this `void commitSession` given this always returns true?', 'commenter': 'hanm'}, {'comment': ""The LeaderSessionTracker.commitSession will return whether it has successfully added the new session, but the return value is not being used anywhere in the code currently.\r\n\r\nI'll update this to reflect that as well."", 'commenter': 'lvfangmin'}]"
447,src/java/main/org/apache/zookeeper/server/SessionTracker.java,"@@ -47,21 +47,20 @@
     long createSession(int sessionTimeout);
 
     /**
-     * Add a global session to those being tracked.
+     * Track the session expire, not add to ZkDb.
      * @param id sessionId
      * @param to sessionTimeout
      * @return whether the session was newly added (if false, already existed)
      */
-    boolean addGlobalSession(long id, int to);
+    boolean trackSession(long id, int to);","[{'comment': 'Is `trackSession` now only tracking global sessions? ', 'commenter': 'hanm'}, {'comment': 'Local session tracker will start track session when creating session.', 'commenter': 'lvfangmin'}]"
447,src/java/main/org/apache/zookeeper/server/quorum/LearnerSessionTracker.java,"@@ -101,33 +100,44 @@ public boolean isGlobalSession(long sessionId) {
         return globalSessionsWithTimeouts.containsKey(sessionId);
     }
 
-    public boolean addGlobalSession(long sessionId, int sessionTimeout) {
+    public boolean trackSession(long sessionId, int sessionTimeout) {
+        // Learner doesn't track global session, do nothing here
+        return false;
+    }
+
+    /**
+     * Synchronized on this to avoid race condition of adding a local session
+     * after committed global session, which may cause the same session being
+     * tracked on this server and leader.
+     */
+    public synchronized boolean commitSession(
+            long sessionId, int sessionTimeout) {
         boolean added =
             globalSessionsWithTimeouts.put(sessionId, sessionTimeout) == null;
-        if (localSessionsEnabled && added) {
+
+        if (added) {
             // Only do extra logging so we know what kind of session this is
             // if we're supporting both kinds of sessions
-            LOG.info(""Adding global session 0x"" + Long.toHexString(sessionId));
+            LOG.info(""Committing global session 0x"" + Long.toHexString(sessionId));
         }
-        touchTable.get().put(sessionId, sessionTimeout);
-        return added;
-    }
 
-    public boolean addSession(long sessionId, int sessionTimeout) {","[{'comment': ""Here a similar question as asked in `LeaderSessionTracker`: with this being removed how would `LearnerSessionTracker` track a local session? The `trackSession` here as commented, just return false and I don't see any way of adding a local session to `LearnerSessionTracker`."", 'commenter': 'hanm'}, {'comment': 'Explained in the previous comment, createSession will add and track it.', 'commenter': 'lvfangmin'}]"
448,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -107,16 +112,43 @@ public StaticHostProvider(Collection<InetSocketAddress> serverAddresses,
         lastIndex = -1;              
     }
 
+    private Set<Class<? extends InetAddress>> supportedAddressTypes() {
+        Set<Class<? extends InetAddress>> types = new HashSet<>();
+        try {
+            Enumeration<NetworkInterface> inets = NetworkInterface.getNetworkInterfaces();
+            while (inets.hasMoreElements()) {
+                NetworkInterface ne = inets.nextElement();
+
+                Enumeration<InetAddress> addrs = ne.getInetAddresses();
+                while (addrs.hasMoreElements()) {
+                    InetAddress addr = addrs.nextElement();
+                    if (addr.isLinkLocalAddress() || addr.isLoopbackAddress()) {
+                        continue;
+                    }
+                    types.add(addr.getClass());
+                }
+            }
+        } catch (SocketException e) {
+            LOG.error(""Failed to resolve supported address types: "", e);","[{'comment': 'Catching this exception here could result the method returning empty list of supported address types which later will make the client unable to connect to any servers.\r\nI think the client should be terminated either in the case of empty list or the first time when this is exception is caught. ', 'commenter': 'anmolnar'}]"
448,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -107,16 +112,43 @@ public StaticHostProvider(Collection<InetSocketAddress> serverAddresses,
         lastIndex = -1;              
     }
 
+    private Set<Class<? extends InetAddress>> supportedAddressTypes() {
+        Set<Class<? extends InetAddress>> types = new HashSet<>();
+        try {
+            Enumeration<NetworkInterface> inets = NetworkInterface.getNetworkInterfaces();
+            while (inets.hasMoreElements()) {
+                NetworkInterface ne = inets.nextElement();
+
+                Enumeration<InetAddress> addrs = ne.getInetAddresses();
+                while (addrs.hasMoreElements()) {
+                    InetAddress addr = addrs.nextElement();
+                    if (addr.isLinkLocalAddress() || addr.isLoopbackAddress()) {
+                        continue;
+                    }
+                    types.add(addr.getClass());
+                }
+            }
+        } catch (SocketException e) {
+            LOG.error(""Failed to resolve supported address types: "", e);
+        }
+        return types;
+    }
+
     private List<InetSocketAddress> resolveAndShuffle(Collection<InetSocketAddress> serverAddresses) {
-        List<InetSocketAddress> tmpList = new ArrayList<InetSocketAddress>(serverAddresses.size());       
+        List<InetSocketAddress> tmpList = new ArrayList<InetSocketAddress>(serverAddresses.size());
+        Set<Class<? extends InetAddress>> supprtedInetTypes = supportedAddressTypes();
+
         for (InetSocketAddress address : serverAddresses) {
             try {
                 InetAddress ia = address.getAddress();
                 String addr = (ia != null) ? ia.getHostAddress() : address.getHostString();
                 InetAddress resolvedAddresses[] = InetAddress.getAllByName(addr);
                 for (InetAddress resolvedAddress : resolvedAddresses) {
                     InetAddress taddr = InetAddress.getByAddress(address.getHostString(), resolvedAddress.getAddress());
-                    tmpList.add(new InetSocketAddress(taddr, address.getPort()));
+                    // try to use IP address only if it's supported by our network stack
+                    if (!supprtedInetTypes.isEmpty() && supprtedInetTypes.contains(taddr.getClass())) {","[{'comment': ""It'd also work to skip the validation if supportedInetTypes is empty."", 'commenter': 'anmolnar'}]"
448,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -107,16 +112,43 @@ public StaticHostProvider(Collection<InetSocketAddress> serverAddresses,
         lastIndex = -1;              
     }
 
+    private Set<Class<? extends InetAddress>> supportedAddressTypes() {
+        Set<Class<? extends InetAddress>> types = new HashSet<>();
+        try {
+            Enumeration<NetworkInterface> inets = NetworkInterface.getNetworkInterfaces();
+            while (inets.hasMoreElements()) {
+                NetworkInterface ne = inets.nextElement();
+
+                Enumeration<InetAddress> addrs = ne.getInetAddresses();
+                while (addrs.hasMoreElements()) {
+                    InetAddress addr = addrs.nextElement();
+                    if (addr.isLinkLocalAddress() || addr.isLoopbackAddress()) {
+                        continue;
+                    }
+                    types.add(addr.getClass());
+                }
+            }
+        } catch (SocketException e) {
+            LOG.error(""Failed to resolve supported address types: "", e);
+        }
+        return types;
+    }
+
     private List<InetSocketAddress> resolveAndShuffle(Collection<InetSocketAddress> serverAddresses) {
-        List<InetSocketAddress> tmpList = new ArrayList<InetSocketAddress>(serverAddresses.size());       
+        List<InetSocketAddress> tmpList = new ArrayList<InetSocketAddress>(serverAddresses.size());
+        Set<Class<? extends InetAddress>> supprtedInetTypes = supportedAddressTypes();","[{'comment': 'typo in the variable name', 'commenter': 'anmolnar'}]"
450,src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -136,13 +136,51 @@ public FileTxnSnapLog(File dataDir, File snapDir) throws IOException {
             throw new DatadirException(""Cannot write to snap directory "" + this.snapDir);
         }
 
+        // check content of transaction log and snapshot dirs if they are two different directories
+        if(!this.dataDir.getPath().equals(this.snapDir.getPath())){
+            checkLogDir();
+            checkSnapDir();
+        }
+
         txnLog = new FileTxnLog(this.dataDir);
         snapLog = new FileSnap(this.snapDir);
 
         autoCreateDB = Boolean.parseBoolean(System.getProperty(ZOOKEEPER_DB_AUTOCREATE,
                 ZOOKEEPER_DB_AUTOCREATE_DEFAULT));
     }
 
+    private void checkLogDir() throws LogdirContentCheckException {
+        File[] files = this.dataDir.listFiles();","[{'comment': 'What do you think of using one of the filtered version of listFiles() rather than getting all the files in the directory?\r\nFor example, using with FilenameFilter:\r\nhttps://docs.oracle.com/javase/7/docs/api/java/io/File.html#listFiles(java.io.FilenameFilter)', 'commenter': 'anmolnar'}, {'comment': 'If I used FilenameFilter, then Util.isSnapshotFile() / Util.isLogFile() check would be run for all the files in the directory and listFiles(FilenameFilter filter) would return all the files satisfying the filter condition, however I need only the first occurrence which satisfies the condition, not all of them. The current logic quits from the for loop immediately when it finds a file violating the configuration and throws an exception, while your proposal would iterate over all the files in the directory and would call Util.isSnapshotFile() / Util.isLogFile() for each of the files inside FilenameFilter to prepare the filtered File[]. So using FilenameFilter would be a bit slower, but yes, it might need less lines in code, also at the price of obscuring the purpose of the code (i.e. hasSnapshotFiles / hasLogFiles boolean variables tell what the problem exactly is, while if (snapshotFiles.length > 0) { throw new Exception(...) } would not). However, if we prefer using Java library classes over standard coding patterns even in cases when it does not fit the purpose entirely, then FilenameFilter can be the winner.', 'commenter': 'Unknown'}, {'comment': 'I prefer writing (and later reading) less code than more. You could be right about the performance impact, but at least `listFiles(FilenameFilter)` creates File objects for the matching files only, not for all of them.', 'commenter': 'anmolnar'}, {'comment': 'Changed implementation to use FilenameFilter.', 'commenter': 'Unknown'}]"
450,src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -136,13 +136,51 @@ public FileTxnSnapLog(File dataDir, File snapDir) throws IOException {
             throw new DatadirException(""Cannot write to snap directory "" + this.snapDir);
         }
 
+        // check content of transaction log and snapshot dirs if they are two different directories
+        if(!this.dataDir.getPath().equals(this.snapDir.getPath())){
+            checkLogDir();
+            checkSnapDir();
+        }
+
         txnLog = new FileTxnLog(this.dataDir);
         snapLog = new FileSnap(this.snapDir);
 
         autoCreateDB = Boolean.parseBoolean(System.getProperty(ZOOKEEPER_DB_AUTOCREATE,
                 ZOOKEEPER_DB_AUTOCREATE_DEFAULT));
     }
 
+    private void checkLogDir() throws LogdirContentCheckException {
+        File[] files = this.dataDir.listFiles();
+        if(files != null) {
+            boolean hasSnapshotFiles = false;
+            for (File file : files) {
+                if(Util.isSnapshotFile(file)){
+                    hasSnapshotFiles = true;
+                    break;
+                }
+            }
+            if (hasSnapshotFiles) {
+                throw new LogdirContentCheckException(""Log directory has snapshot files. Check if dataLogDir and dataDir configuration is correct."");
+            }
+        }
+    }
+
+    private void checkSnapDir() throws SnapdirContentCheckException {
+        File[] files = this.snapDir.listFiles();","[{'comment': 'Same here. Get files with fileNameFilter and if it returns non-empty array, throw exception.', 'commenter': 'anmolnar'}, {'comment': 'Please see my comments above.', 'commenter': 'Unknown'}]"
450,src/java/main/org/apache/zookeeper/server/persistence/Util.java,"@@ -83,7 +86,7 @@ public static URI makeFileLoggerURL(File dataDir, File dataLogDir,String convPol
      * @return file name
      */
     public static String makeLogName(long zxid) {
-        return ""log."" + Long.toHexString(zxid);
+        return LOG_FILE_PREFIX + ""."" + Long.toHexString(zxid);","[{'comment': 'I wonder if LOG_FILE_PREFIX included the dot, would be better for the validation.', 'commenter': 'anmolnar'}, {'comment': 'I deliberately excluded the dot from LOG_FILE_PREFIX and SNAP_FILE_PREFIX after I checked that in FileTxnLog and FileSnap classes the prefix argument (like ""log"", ""snapshot"") in method calls is passed without the dot. I wanted to avoid confusion.', 'commenter': 'Unknown'}, {'comment': 'Okay.', 'commenter': 'anmolnar'}]"
450,src/java/main/org/apache/zookeeper/server/persistence/Util.java,"@@ -294,5 +297,25 @@ public int compare(File o1, File o2) {
         Collections.sort(filelist, new DataDirFileComparator(prefix, ascending));
         return filelist;
     }
+
+    /**
+     * Returns true if file is a log file.
+     *
+     * @param file
+     * @return
+     */
+    public static boolean isLogFile(File file) {
+        return file.getName().startsWith(LOG_FILE_PREFIX);","[{'comment': 'It might be safer to check here with the dot (""."") included in the prefix.', 'commenter': 'anmolnar'}, {'comment': ""I agree that it might be safer to check with the dot. I'll add this change."", 'commenter': 'Unknown'}, {'comment': 'This is done.', 'commenter': 'Unknown'}]"
450,src/java/main/org/apache/zookeeper/server/persistence/Util.java,"@@ -294,5 +297,25 @@ public int compare(File o1, File o2) {
         Collections.sort(filelist, new DataDirFileComparator(prefix, ascending));
         return filelist;
     }
+
+    /**
+     * Returns true if file is a log file.
+     *
+     * @param file
+     * @return
+     */
+    public static boolean isLogFile(File file) {
+        return file.getName().startsWith(LOG_FILE_PREFIX);
+    }
+
+    /**
+     * Returns true if file is a snapshot file.
+     *
+     * @param file
+     * @return
+     */
+    public static boolean isSnapshotFile(File file) {
+        return file.getName().startsWith(SNAP_FILE_PREFIX);","[{'comment': 'Same here with the dot.', 'commenter': 'anmolnar'}, {'comment': ""Ok, I'll include the dot in the check."", 'commenter': 'Unknown'}, {'comment': 'Done.', 'commenter': 'Unknown'}]"
450,src/java/test/org/apache/zookeeper/server/persistence/FileTxnSnapLogTest.java,"@@ -159,4 +159,222 @@ public void onTxnLoaded(TxnHeader hdr, Record rec) {
             }
         }
     }
+
+    @Test
+    public void testDirCheckWithCorrectFiles() throws IOException {
+        File tmpDir = ClientBase.createEmptyTestDir();
+        File logDir = new File(tmpDir, ""logdir"");
+        File snapDir = new File(tmpDir, ""snapdir"");
+        File logVersionDir = new File(logDir, FileTxnSnapLog.version +  FileTxnSnapLog.VERSION);
+        File snapVersionDir = new File(snapDir, FileTxnSnapLog.version +  FileTxnSnapLog.VERSION);
+
+        if (!logVersionDir.exists()) {","[{'comment': 'This is always true.', 'commenter': 'anmolnar'}, {'comment': ""I've removed this."", 'commenter': 'Unknown'}]"
450,src/java/test/org/apache/zookeeper/server/persistence/FileTxnSnapLogTest.java,"@@ -159,4 +159,222 @@ public void onTxnLoaded(TxnHeader hdr, Record rec) {
             }
         }
     }
+
+    @Test
+    public void testDirCheckWithCorrectFiles() throws IOException {
+        File tmpDir = ClientBase.createEmptyTestDir();
+        File logDir = new File(tmpDir, ""logdir"");
+        File snapDir = new File(tmpDir, ""snapdir"");
+        File logVersionDir = new File(logDir, FileTxnSnapLog.version +  FileTxnSnapLog.VERSION);
+        File snapVersionDir = new File(snapDir, FileTxnSnapLog.version +  FileTxnSnapLog.VERSION);
+
+        if (!logVersionDir.exists()) {
+            logVersionDir.mkdirs();
+        }
+        if (!snapVersionDir.exists()) {","[{'comment': 'This is always true.', 'commenter': 'anmolnar'}, {'comment': ""I've removed this, too."", 'commenter': 'Unknown'}]"
450,src/java/test/org/apache/zookeeper/server/persistence/FileTxnSnapLogTest.java,"@@ -159,4 +159,222 @@ public void onTxnLoaded(TxnHeader hdr, Record rec) {
             }
         }
     }
+
+    @Test
+    public void testDirCheckWithCorrectFiles() throws IOException {
+        File tmpDir = ClientBase.createEmptyTestDir();
+        File logDir = new File(tmpDir, ""logdir"");
+        File snapDir = new File(tmpDir, ""snapdir"");
+        File logVersionDir = new File(logDir, FileTxnSnapLog.version +  FileTxnSnapLog.VERSION);
+        File snapVersionDir = new File(snapDir, FileTxnSnapLog.version +  FileTxnSnapLog.VERSION);
+
+        if (!logVersionDir.exists()) {
+            logVersionDir.mkdirs();
+        }
+        if (!snapVersionDir.exists()) {
+            snapVersionDir.mkdirs();
+        }
+
+        Assert.assertTrue(logVersionDir.exists());
+        Assert.assertTrue(snapVersionDir.exists());","[{'comment': 'These assert will never fail. mkdirs() throws exception if the directory cannot be created.', 'commenter': 'anmolnar'}, {'comment': 'Ok, removed.', 'commenter': 'Unknown'}]"
450,src/java/test/org/apache/zookeeper/server/persistence/FileTxnSnapLogTest.java,"@@ -159,4 +159,222 @@ public void onTxnLoaded(TxnHeader hdr, Record rec) {
             }
         }
     }
+
+    @Test
+    public void testDirCheckWithCorrectFiles() throws IOException {
+        File tmpDir = ClientBase.createEmptyTestDir();
+        File logDir = new File(tmpDir, ""logdir"");
+        File snapDir = new File(tmpDir, ""snapdir"");
+        File logVersionDir = new File(logDir, FileTxnSnapLog.version +  FileTxnSnapLog.VERSION);
+        File snapVersionDir = new File(snapDir, FileTxnSnapLog.version +  FileTxnSnapLog.VERSION);
+
+        if (!logVersionDir.exists()) {
+            logVersionDir.mkdirs();
+        }
+        if (!snapVersionDir.exists()) {
+            snapVersionDir.mkdirs();
+        }
+
+        Assert.assertTrue(logVersionDir.exists());
+        Assert.assertTrue(snapVersionDir.exists());
+
+        // transaction log files in log dir - correct
+        File logFile1 = new File(logVersionDir.getPath() +File.separator + Util.makeLogName(1L));
+        logFile1.createNewFile();
+        File logFile2 = new File(logVersionDir.getPath() +File.separator + Util.makeLogName(2L));
+        logFile2.createNewFile();
+
+        // snapshot files in snap dir - correct
+        File snapFile1 = new File(snapVersionDir.getPath() +File.separator + Util.makeSnapshotName(1L));
+        snapFile1.createNewFile();
+        File snapFile2 = new File(snapVersionDir.getPath() +File.separator + Util.makeSnapshotName(2L));
+        snapFile2.createNewFile();
+
+        Assert.assertTrue(logFile1.exists());
+        Assert.assertTrue(logFile2.exists());
+        Assert.assertTrue(snapFile1.exists());
+        Assert.assertTrue(snapFile2.exists());","[{'comment': 'Again, I believe these checks are redundant. createNewFile() will always successfully create the file or throws exception.', 'commenter': 'anmolnar'}, {'comment': 'Ok, removed.', 'commenter': 'Unknown'}]"
450,src/java/test/org/apache/zookeeper/server/persistence/FileTxnSnapLogTest.java,"@@ -159,4 +159,222 @@ public void onTxnLoaded(TxnHeader hdr, Record rec) {
             }
         }
     }
+
+    @Test
+    public void testDirCheckWithCorrectFiles() throws IOException {
+        File tmpDir = ClientBase.createEmptyTestDir();
+        File logDir = new File(tmpDir, ""logdir"");
+        File snapDir = new File(tmpDir, ""snapdir"");
+        File logVersionDir = new File(logDir, FileTxnSnapLog.version +  FileTxnSnapLog.VERSION);
+        File snapVersionDir = new File(snapDir, FileTxnSnapLog.version +  FileTxnSnapLog.VERSION);
+
+        if (!logVersionDir.exists()) {
+            logVersionDir.mkdirs();
+        }
+        if (!snapVersionDir.exists()) {
+            snapVersionDir.mkdirs();
+        }
+
+        Assert.assertTrue(logVersionDir.exists());
+        Assert.assertTrue(snapVersionDir.exists());
+
+        // transaction log files in log dir - correct
+        File logFile1 = new File(logVersionDir.getPath() +File.separator + Util.makeLogName(1L));
+        logFile1.createNewFile();
+        File logFile2 = new File(logVersionDir.getPath() +File.separator + Util.makeLogName(2L));
+        logFile2.createNewFile();
+
+        // snapshot files in snap dir - correct
+        File snapFile1 = new File(snapVersionDir.getPath() +File.separator + Util.makeSnapshotName(1L));
+        snapFile1.createNewFile();
+        File snapFile2 = new File(snapVersionDir.getPath() +File.separator + Util.makeSnapshotName(2L));
+        snapFile2.createNewFile();
+
+        Assert.assertTrue(logFile1.exists());
+        Assert.assertTrue(logFile2.exists());
+        Assert.assertTrue(snapFile1.exists());
+        Assert.assertTrue(snapFile2.exists());
+
+        String priorAutocreateDirValue = System.getProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE);
+        System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, ""false"");
+        FileTxnSnapLog fileTxnSnapLog;
+        try {
+            fileTxnSnapLog = new FileTxnSnapLog(logDir, snapDir);
+        } catch (FileTxnSnapLog.LogdirContentCheckException e) {
+            Assert.fail(""Should not throw LogdirContentCheckException."");
+        } catch (FileTxnSnapLog.SnapdirContentCheckException e) {","[{'comment': 'These 2 catches can be grouped by catching all Exceptions.', 'commenter': 'anmolnar'}]"
450,src/java/test/org/apache/zookeeper/server/persistence/FileTxnSnapLogTest.java,"@@ -159,4 +159,222 @@ public void onTxnLoaded(TxnHeader hdr, Record rec) {
             }
         }
     }
+
+    @Test
+    public void testDirCheckWithCorrectFiles() throws IOException {
+        File tmpDir = ClientBase.createEmptyTestDir();
+        File logDir = new File(tmpDir, ""logdir"");
+        File snapDir = new File(tmpDir, ""snapdir"");
+        File logVersionDir = new File(logDir, FileTxnSnapLog.version +  FileTxnSnapLog.VERSION);
+        File snapVersionDir = new File(snapDir, FileTxnSnapLog.version +  FileTxnSnapLog.VERSION);
+
+        if (!logVersionDir.exists()) {
+            logVersionDir.mkdirs();
+        }
+        if (!snapVersionDir.exists()) {
+            snapVersionDir.mkdirs();
+        }
+
+        Assert.assertTrue(logVersionDir.exists());
+        Assert.assertTrue(snapVersionDir.exists());
+
+        // transaction log files in log dir - correct
+        File logFile1 = new File(logVersionDir.getPath() +File.separator + Util.makeLogName(1L));
+        logFile1.createNewFile();
+        File logFile2 = new File(logVersionDir.getPath() +File.separator + Util.makeLogName(2L));
+        logFile2.createNewFile();
+
+        // snapshot files in snap dir - correct
+        File snapFile1 = new File(snapVersionDir.getPath() +File.separator + Util.makeSnapshotName(1L));
+        snapFile1.createNewFile();
+        File snapFile2 = new File(snapVersionDir.getPath() +File.separator + Util.makeSnapshotName(2L));
+        snapFile2.createNewFile();
+
+        Assert.assertTrue(logFile1.exists());
+        Assert.assertTrue(logFile2.exists());
+        Assert.assertTrue(snapFile1.exists());
+        Assert.assertTrue(snapFile2.exists());
+
+        String priorAutocreateDirValue = System.getProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE);
+        System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, ""false"");
+        FileTxnSnapLog fileTxnSnapLog;
+        try {
+            fileTxnSnapLog = new FileTxnSnapLog(logDir, snapDir);
+        } catch (FileTxnSnapLog.LogdirContentCheckException e) {
+            Assert.fail(""Should not throw LogdirContentCheckException."");
+        } catch (FileTxnSnapLog.SnapdirContentCheckException e) {
+            Assert.fail(""Should not throw SnapdirContentCheckException."");
+        } finally {
+            if (priorAutocreateDirValue == null) {
+                System.clearProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE);
+            } else {
+                System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, priorAutocreateDirValue);
+            }","[{'comment': ""Setting 'zookeeper.datadir.autocreate' doesn't make any difference here, so it doesn't need to be maintained.\r\nIn addition to that please add clean-up logic to your tests. (e.g. recursively remove temp directories with all their contents)"", 'commenter': 'anmolnar'}]"
450,src/java/test/org/apache/zookeeper/server/persistence/FileTxnSnapLogTest.java,"@@ -159,4 +159,222 @@ public void onTxnLoaded(TxnHeader hdr, Record rec) {
             }
         }
     }
+
+    @Test
+    public void testDirCheckWithCorrectFiles() throws IOException {
+        File tmpDir = ClientBase.createEmptyTestDir();
+        File logDir = new File(tmpDir, ""logdir"");
+        File snapDir = new File(tmpDir, ""snapdir"");
+        File logVersionDir = new File(logDir, FileTxnSnapLog.version +  FileTxnSnapLog.VERSION);
+        File snapVersionDir = new File(snapDir, FileTxnSnapLog.version +  FileTxnSnapLog.VERSION);
+
+        if (!logVersionDir.exists()) {
+            logVersionDir.mkdirs();
+        }
+        if (!snapVersionDir.exists()) {
+            snapVersionDir.mkdirs();
+        }
+
+        Assert.assertTrue(logVersionDir.exists());
+        Assert.assertTrue(snapVersionDir.exists());
+
+        // transaction log files in log dir - correct
+        File logFile1 = new File(logVersionDir.getPath() +File.separator + Util.makeLogName(1L));
+        logFile1.createNewFile();
+        File logFile2 = new File(logVersionDir.getPath() +File.separator + Util.makeLogName(2L));
+        logFile2.createNewFile();
+
+        // snapshot files in snap dir - correct
+        File snapFile1 = new File(snapVersionDir.getPath() +File.separator + Util.makeSnapshotName(1L));
+        snapFile1.createNewFile();
+        File snapFile2 = new File(snapVersionDir.getPath() +File.separator + Util.makeSnapshotName(2L));
+        snapFile2.createNewFile();
+
+        Assert.assertTrue(logFile1.exists());
+        Assert.assertTrue(logFile2.exists());
+        Assert.assertTrue(snapFile1.exists());
+        Assert.assertTrue(snapFile2.exists());
+
+        String priorAutocreateDirValue = System.getProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE);
+        System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, ""false"");
+        FileTxnSnapLog fileTxnSnapLog;
+        try {
+            fileTxnSnapLog = new FileTxnSnapLog(logDir, snapDir);
+        } catch (FileTxnSnapLog.LogdirContentCheckException e) {
+            Assert.fail(""Should not throw LogdirContentCheckException."");
+        } catch (FileTxnSnapLog.SnapdirContentCheckException e) {
+            Assert.fail(""Should not throw SnapdirContentCheckException."");
+        } finally {
+            if (priorAutocreateDirValue == null) {
+                System.clearProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE);
+            } else {
+                System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, priorAutocreateDirValue);
+            }
+        }
+    }
+
+    @Test
+    public void testDirCheckWithSameLogAndSnapDirs() throws IOException {","[{'comment': ""I don't repeat my previous comments, all of them applies to the rest of test cases."", 'commenter': 'anmolnar'}]"
450,src/java/main/org/apache/zookeeper/server/persistence/Util.java,"@@ -50,6 +50,9 @@
     private static final String SNAP_DIR=""snapDir"";
     private static final String LOG_DIR=""logDir"";
     private static final String DB_FORMAT_CONV=""dbFormatConversion"";
+
+    private static final String LOG_FILE_PREFIX = ""log"";","[{'comment': 'Can we use these field when actually creating the log and snapshot files?', 'commenter': 'afine'}]"
450,src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -136,13 +136,51 @@ public FileTxnSnapLog(File dataDir, File snapDir) throws IOException {
             throw new DatadirException(""Cannot write to snap directory "" + this.snapDir);
         }
 
+        // check content of transaction log and snapshot dirs if they are two different directories","[{'comment': 'Could we add a reference to the discussion that explains why this whole check is needed in the comments and/or the exception that the user sees?', 'commenter': 'afine'}]"
450,src/java/test/org/apache/zookeeper/server/persistence/FileTxnSnapLogTest.java,"@@ -159,4 +159,222 @@ public void onTxnLoaded(TxnHeader hdr, Record rec) {
             }
         }
     }
+
+    @Test","[{'comment': ""there is a lot of code duplication in these tests, i'm wondering if they can be cleaned up."", 'commenter': 'afine'}, {'comment': ""@afine I've improved/shortened the test code"", 'commenter': 'Unknown'}]"
451,src/java/test/org/apache/zookeeper/client/StaticHostProviderTest.java,"@@ -117,8 +117,32 @@ public void testTwoInvalidHostAddresses() {
         list.add(new InetSocketAddress(""a"", 2181));
         list.add(new InetSocketAddress(""b"", 2181));
         new StaticHostProvider(list);
+	}
+
+    @Test
+    public void testReResolving() {
+        byte size = 1;
+        ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);
+
+        // Test a hostname that resolves to multiple addresses","[{'comment': ""Common domain names like facebook.com, google.com or apache.org don't use round-robin DNS anymore for some reason, so they don't resolve to multiple addresses. As a consequence this test doesn't validate the branch related to multiple addresses anymore unfortunately.\r\n\r\nNot sure how to address that, PowerMock would be the best to mock static `getAllByName()` method, but that would involve introducing a new test dependency."", 'commenter': 'anmolnar'}]"
451,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -25,6 +25,8 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
+import java.lang.reflect.InvocationTargetException;","[{'comment': 'i think these imports are unused, and there are some others elsewhere in the code', 'commenter': 'afine'}, {'comment': 'Good catch, thanks.', 'commenter': 'anmolnar'}]"
451,src/java/test/org/apache/zookeeper/client/StaticHostProviderTest.java,"@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-package org.apache.zookeeper.test;
+package org.apache.zookeeper.client;","[{'comment': ""this doesn't look right"", 'commenter': 'afine'}, {'comment': ""It was moved to client package, because it uses package-private methods of StaticHostProvider. I moved back to 'test' package and change the affected methods to public."", 'commenter': 'anmolnar'}]"
451,src/java/test/org/apache/zookeeper/test/ReadOnlyModeTest.java,"@@ -239,13 +243,13 @@ public void testSessionEstablishment() throws Exception {
     public void testSeekForRwServer() throws Exception {
 
         // setup the logger to capture all logs
-        Layout layout = Logger.getRootLogger().getAppender(""CONSOLE"")
+        Layout layout = org.apache.log4j.Logger.getRootLogger().getAppender(""CONSOLE"")","[{'comment': 'why is this necessary?', 'commenter': 'afine'}, {'comment': ""I few lines above there're org.apache.log4j references which conflicts with the 'Logger' class, hence it needs to be explicitly referenced."", 'commenter': 'anmolnar'}, {'comment': 'not going to push too hard on this, but I think you can just use log4j everywhere like in `QuorumPeerMainTest`', 'commenter': 'afine'}, {'comment': ""slf4j's string formatter feature is being used in these tests. I wouldn't refactor them to be honest."", 'commenter': 'anmolnar'}]"
451,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -57,29 +62,12 @@
      */
     public StaticHostProvider(Collection<InetSocketAddress> serverAddresses) {
         for (InetSocketAddress address : serverAddresses) {
-            try {
-                InetAddress ia = address.getAddress();
-                InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :
-                        address.getHostName());
-                for (InetAddress resolvedAddress : resolvedAddresses) {
-                    // If hostName is null but the address is not, we can tell that
-                    // the hostName is an literal IP address. Then we can set the host string as the hostname
-                    // safely to avoid reverse DNS lookup.
-                    // As far as i know, the only way to check if the hostName is null is use toString().
-                    // Both the two implementations of InetAddress are final class, so we can trust the return value of
-                    // the toString() method.
-                    if (resolvedAddress.toString().startsWith(""/"")
-                            && resolvedAddress.getAddress() != null) {
-                        this.serverAddresses.add(
-                                new InetSocketAddress(InetAddress.getByAddress(
-                                        address.getHostName(),
-                                        resolvedAddress.getAddress()),
-                                        address.getPort()));
-                    } else {
-                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
-                    }
-                }
-            } catch (UnknownHostException e) {
+			try {","[{'comment': 'something is wrong with the indentation here', 'commenter': 'afine'}, {'comment': 'Fixing.', 'commenter': 'anmolnar'}]"
451,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -91,15 +79,106 @@ public StaticHostProvider(Collection<InetSocketAddress> serverAddresses) {
         Collections.shuffle(this.serverAddresses);
     }
 
+    /**
+     * Evaluate to a hostname if one is available and otherwise it returns the
+     * string representation of the IP address.
+     *
+     * In Java 7, we have a method getHostString, but earlier versions do not support it.
+     * This method is to provide a replacement for InetSocketAddress.getHostString().
+     *
+     * @param addr
+     * @return Hostname string of address parameter
+     */
+    private String getHostString(InetSocketAddress addr) {
+        String hostString = """";
+
+        if (addr == null) {
+            return hostString;
+        }
+        if (!addr.isUnresolved()) {
+            InetAddress ia = addr.getAddress();
+
+            // If the string starts with '/', then it has no hostname
+            // and we want to avoid the reverse lookup, so we return
+            // the string representation of the address.
+            if (ia.toString().startsWith(""/"")) {
+                hostString = ia.getHostAddress();
+            } else {
+                hostString = addr.getHostName();
+            }
+        } else {
+            // According to the Java 6 documentation, if the hostname is
+            // unresolved, then the string before the colon is the hostname.
+            String addrString = addr.toString();
+            hostString = addrString.substring(0, addrString.lastIndexOf(':'));
+        }
+
+        return hostString;
+    }
+
     public int size() {
         return serverAddresses.size();
     }
 
+    // Counts the number of addresses added and removed during
+    // the last call to next. Used mainly for test purposes.
+    // See StasticHostProviderTest.
+    private int nextAdded = 0;
+    private int nextRemoved = 0;
+
+    int getNextAdded() {
+        return nextAdded;
+    }
+
+    int getNextRemoved() {
+        return nextRemoved;
+    }
+
     public InetSocketAddress next(long spinDelay) {
-        ++currentIndex;
-        if (currentIndex == serverAddresses.size()) {
-            currentIndex = 0;
+        // Handle possible connection error by re-resolving hostname if possible
+        if (!connectedSinceNext) {","[{'comment': 'would you mind explaining exactly under which conditions we reresolve the hostname and under which conditions we try the next one in the host list? My reading is that this reresolves everything if the client fails to connect to two hosts in a row. Is this the desired behavior?\r\n\r\nAnd do we always reresolve all serverAddresses?', 'commenter': 'afine'}, {'comment': ""It should try to re-resolve whenever the client is unable to connect to a server (connectedSinceNext == false). \r\n\r\n@fpj gives a good explanation in the original Jira:\r\nhttps://issues.apache.org/jira/browse/ZOOKEEPER-2184?focusedCommentId=15873730&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-15873730\r\n\r\n> I haven't had much time to work on this issue, but here is my current assessment.\r\n\r\n> This issue seemed easy to fix at first, but it is fairly fundamental with respect to how we resolve host names. Currently, we resolve host names when we start a client and never resolve it again. This is the cause of the problem reported in the issue because in the scenario described, the zookeeper container is re-started and changes addresses, which prevents the client from connecting to the zookeeper server.\r\n\r\n> The proposed patch here tries to re-resolve the hostname every time the client fails to connect to the resolved address. It kind of works, but it makes StaticHostProvider a bit messy because the expectation with the current wiring is that we won't have to resolve again.\r\n\r\n> The ideal situation for the problematic scenario is that we resolve the host name every time we try to connect to a server, but that would be a fairly fundamental change to how we resolve addresses in ZooKeeper.\r\n\r\n> I was also looking at the C client and it might get a bit messy too there because I don't think we currently keep the association between the host name and the resolved address, so we don't really know what to resolve again. It might be possible to do it via the canonical name in getaddrinfo, but I'm not sure how that works with windows.\r\n\r\n> One specific proposal to avoid having clients never finding a server ever again without deep changes to the current wiring is to resolve again everything in the case the client tries all and none succeeds. That would be a fairly straightforward change to both Java and C client, but it would not resolve addresses again in the case the a strict subset has changed addresses and at least one server is reachable."", 'commenter': 'anmolnar'}]"
451,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -6,9 +6,9 @@
  * to you under the Apache License, Version 2.0 (the
  * ""License""); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>","[{'comment': 'was this accidental?', 'commenter': 'afine'}, {'comment': 'Yes it was.', 'commenter': 'anmolnar'}]"
451,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -58,48 +61,122 @@
     public StaticHostProvider(Collection<InetSocketAddress> serverAddresses) {
         for (InetSocketAddress address : serverAddresses) {
             try {
-                InetAddress ia = address.getAddress();
-                InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :
-                        address.getHostName());
+                InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(address));
                 for (InetAddress resolvedAddress : resolvedAddresses) {
-                    // If hostName is null but the address is not, we can tell that
-                    // the hostName is an literal IP address. Then we can set the host string as the hostname
-                    // safely to avoid reverse DNS lookup.
-                    // As far as i know, the only way to check if the hostName is null is use toString().
-                    // Both the two implementations of InetAddress are final class, so we can trust the return value of
-                    // the toString() method.
-                    if (resolvedAddress.toString().startsWith(""/"")
-                            && resolvedAddress.getAddress() != null) {
-                        this.serverAddresses.add(
-                                new InetSocketAddress(InetAddress.getByAddress(
-                                        address.getHostName(),
-                                        resolvedAddress.getAddress()),
-                                        address.getPort()));
-                    } else {
-                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
-                    }
+                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));
                 }
             } catch (UnknownHostException e) {
                 LOG.error(""Unable to connect to server: {}"", address, e);
             }
         }
-        
+
         if (this.serverAddresses.isEmpty()) {
             throw new IllegalArgumentException(
                     ""A HostProvider may not be empty!"");
         }
         Collections.shuffle(this.serverAddresses);
     }
 
+    /**
+     * Evaluate to a hostname if one is available and otherwise it returns the
+     * string representation of the IP address.
+     *
+     * In Java 7, we have a method getHostString, but earlier versions do not support it.
+     * This method is to provide a replacement for InetSocketAddress.getHostString().
+     *
+     * @param addr
+     * @return Hostname string of address parameter
+     */
+    private String getHostString(InetSocketAddress addr) {
+        String hostString = """";
+
+        if (addr == null) {
+            return hostString;
+        }
+        if (!addr.isUnresolved()) {
+            InetAddress ia = addr.getAddress();
+
+            // If the string starts with '/', then it has no hostname
+            // and we want to avoid the reverse lookup, so we return
+            // the string representation of the address.
+            if (ia.toString().startsWith(""/"")) {
+                hostString = ia.getHostAddress();
+            } else {
+                hostString = addr.getHostName();
+            }
+        } else {
+            // According to the Java 6 documentation, if the hostname is
+            // unresolved, then the string before the colon is the hostname.
+            String addrString = addr.toString();
+            hostString = addrString.substring(0, addrString.lastIndexOf(':'));
+        }
+
+        return hostString;
+    }
+
     public int size() {
         return serverAddresses.size();
     }
 
+    // Counts the number of addresses added and removed during
+    // the last call to next. Used mainly for test purposes.
+    // See StasticHostProviderTest.
+    private int nextAdded = 0;
+    private int nextRemoved = 0;
+
+    public int getNextAdded() {
+        return nextAdded;
+    }
+
+    public int getNextRemoved() {
+        return nextRemoved;
+    }
+
     public InetSocketAddress next(long spinDelay) {
-        ++currentIndex;
-        if (currentIndex == serverAddresses.size()) {
-            currentIndex = 0;
+        // Handle possible connection error by re-resolving hostname if possible
+        if (!connectedSinceNext) {
+            InetSocketAddress curAddr = serverAddresses.get(currentIndex);
+            String curHostString = getHostString(curAddr);
+            if (!curHostString.equals(curAddr.getAddress().getHostAddress())) {
+                LOG.info(""Resolving again hostname: {}"", getHostString(curAddr));
+                try {
+                    int thePort = curAddr.getPort();
+                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(curHostString);
+                    nextAdded = 0;
+                    nextRemoved = 0;
+                    if (resolvedAddresses.length == 1) {","[{'comment': 'what happens when a host that resolves to multiple addresses changes to resolving to just one?', 'commenter': 'afine'}, {'comment': ""That's actually a very good point. I'm looking into that you suggested below (using a Map instead of Array) which will probably solve this issue too."", 'commenter': 'anmolnar'}, {'comment': 'It might be easier to just remove the special case of `resolvedAddresses.length == 1` and let the other part iterate over the list and remove the affected elements.', 'commenter': 'anmolnar'}]"
451,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -58,48 +61,122 @@
     public StaticHostProvider(Collection<InetSocketAddress> serverAddresses) {
         for (InetSocketAddress address : serverAddresses) {
             try {
-                InetAddress ia = address.getAddress();
-                InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :
-                        address.getHostName());
+                InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(address));
                 for (InetAddress resolvedAddress : resolvedAddresses) {
-                    // If hostName is null but the address is not, we can tell that
-                    // the hostName is an literal IP address. Then we can set the host string as the hostname
-                    // safely to avoid reverse DNS lookup.
-                    // As far as i know, the only way to check if the hostName is null is use toString().
-                    // Both the two implementations of InetAddress are final class, so we can trust the return value of
-                    // the toString() method.
-                    if (resolvedAddress.toString().startsWith(""/"")
-                            && resolvedAddress.getAddress() != null) {
-                        this.serverAddresses.add(
-                                new InetSocketAddress(InetAddress.getByAddress(
-                                        address.getHostName(),
-                                        resolvedAddress.getAddress()),
-                                        address.getPort()));
-                    } else {
-                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
-                    }
+                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));
                 }
             } catch (UnknownHostException e) {
                 LOG.error(""Unable to connect to server: {}"", address, e);
             }
         }
-        
+
         if (this.serverAddresses.isEmpty()) {
             throw new IllegalArgumentException(
                     ""A HostProvider may not be empty!"");
         }
         Collections.shuffle(this.serverAddresses);
     }
 
+    /**
+     * Evaluate to a hostname if one is available and otherwise it returns the
+     * string representation of the IP address.
+     *
+     * In Java 7, we have a method getHostString, but earlier versions do not support it.
+     * This method is to provide a replacement for InetSocketAddress.getHostString().
+     *
+     * @param addr
+     * @return Hostname string of address parameter
+     */
+    private String getHostString(InetSocketAddress addr) {
+        String hostString = """";
+
+        if (addr == null) {
+            return hostString;
+        }
+        if (!addr.isUnresolved()) {
+            InetAddress ia = addr.getAddress();
+
+            // If the string starts with '/', then it has no hostname
+            // and we want to avoid the reverse lookup, so we return
+            // the string representation of the address.
+            if (ia.toString().startsWith(""/"")) {
+                hostString = ia.getHostAddress();
+            } else {
+                hostString = addr.getHostName();
+            }
+        } else {
+            // According to the Java 6 documentation, if the hostname is
+            // unresolved, then the string before the colon is the hostname.
+            String addrString = addr.toString();
+            hostString = addrString.substring(0, addrString.lastIndexOf(':'));
+        }
+
+        return hostString;
+    }
+
     public int size() {
         return serverAddresses.size();
     }
 
+    // Counts the number of addresses added and removed during
+    // the last call to next. Used mainly for test purposes.
+    // See StasticHostProviderTest.
+    private int nextAdded = 0;
+    private int nextRemoved = 0;
+
+    public int getNextAdded() {
+        return nextAdded;
+    }
+
+    public int getNextRemoved() {
+        return nextRemoved;
+    }
+
     public InetSocketAddress next(long spinDelay) {
-        ++currentIndex;
-        if (currentIndex == serverAddresses.size()) {
-            currentIndex = 0;
+        // Handle possible connection error by re-resolving hostname if possible
+        if (!connectedSinceNext) {
+            InetSocketAddress curAddr = serverAddresses.get(currentIndex);
+            String curHostString = getHostString(curAddr);
+            if (!curHostString.equals(curAddr.getAddress().getHostAddress())) {
+                LOG.info(""Resolving again hostname: {}"", getHostString(curAddr));
+                try {
+                    int thePort = curAddr.getPort();
+                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(curHostString);
+                    nextAdded = 0;
+                    nextRemoved = 0;
+                    if (resolvedAddresses.length == 1) {
+                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses[0], thePort));
+                        nextAdded = nextRemoved = 1;
+                        LOG.debug(""Newly resolved address: {}"", resolvedAddresses[0]);
+                    } else {
+                        int i = 0;
+                        while (i < serverAddresses.size()) {
+                            if (getHostString(serverAddresses.get(i)).equals(curHostString) &&","[{'comment': 'as i mentioned in https://github.com/apache/zookeeper/pull/150/files#r98543324 this all gets a little complicated? What do you think about using a map to trap all these associations?', 'commenter': 'afine'}, {'comment': 'It seems that this change makes things a little bit even more complicated, because `next()` method needs to have a list of IP addresses to iterate on. Maintenance is easier with a Map, but I need to find a way to use it as a list.', 'commenter': 'anmolnar'}, {'comment': 'Not sure I understand this point. I believe there are implementations of HashMap that provide predictable ordering of the keys, so you should still be able to use next. Let me know if I am misunderstanding you here. ', 'commenter': 'afine'}, {'comment': 'How to shuffle the elements?', 'commenter': 'anmolnar'}, {'comment': 'You could put the `keySet` in a list and shuffle?', 'commenter': 'afine'}, {'comment': 'The key is the hoststring which is like `issues.apache.org` and could have multiple InetAddresses which are the values of the key in the map. If I shuffle only the keys, I can iterate on only the keys and not sure how to choose from the addresses.', 'commenter': 'anmolnar'}]"
451,src/java/test/org/apache/zookeeper/test/StaticHostProviderTest.java,"@@ -117,8 +116,32 @@ public void testTwoInvalidHostAddresses() {
         list.add(new InetSocketAddress(""a"", 2181));
         list.add(new InetSocketAddress(""b"", 2181));
         new StaticHostProvider(list);
+	}
+
+    @Test
+    public void testReResolving() {
+        byte size = 1;
+        ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);
+
+        // Test a hostname that resolves to multiple addresses
+        list.add(InetSocketAddress.createUnresolved(""www.apache.org"", 1234));","[{'comment': ""I'm wondering if it's possible to mock this out? It would be great if our unit tests were not dependent on some other infrastructure."", 'commenter': 'afine'}, {'comment': ""Good point I spent hours finding a way for it. Unfortunately static members can't be mocked with Mockito. We should use PowerMock for it (as described here https://blog.codecentric.de/en/2016/03/junit-testing-using-mockito-powermock/), but that'd be a new dependency not sure if it's acceptable here."", 'commenter': 'anmolnar'}, {'comment': 'Yeah, this is annoying. Although, another possibility would be to put the dns calls in a method and then subclass `StaticHostProvider` for the tests and overriding this method to return what you want. ', 'commenter': 'afine'}, {'comment': ""Makes sense, I'm working on it."", 'commenter': 'anmolnar'}, {'comment': 'This is done.', 'commenter': 'anmolnar'}]"
451,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -18,6 +18,10 @@
 
 package org.apache.zookeeper.client;
 
+import org.apache.yetus.audience.InterfaceAudience;","[{'comment': 'nit: move this back', 'commenter': 'afine'}]"
453,src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java,"@@ -758,6 +760,11 @@ public boolean syncFollower(long peerLastZxid, ZKDatabase db, Leader leader) {
                 currentZxid = maxCommittedLog;
                 needOpPacket = false;
                 needSnap = false;
+            } else if (peerLastEpoch != lastProcessedEpoch && !db.isInCommittedLog(peerLastZxid)) {
+                //Be sure we do a snap, because if the epochs are not the same we don't know what
+                // could have happened in between and it may take a TRUNC + UPDATES to get them in SYNC
+                LOG.debug(""Will send SNAP to peer sid: {} epochs are too our of sync local 0x{} remote 0x{}"",","[{'comment': 'I think there is a typo here: ""our of sync""', 'commenter': 'Unknown'}]"
453,src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java,"@@ -758,6 +760,11 @@ public boolean syncFollower(long peerLastZxid, ZKDatabase db, Leader leader) {
                 currentZxid = maxCommittedLog;
                 needOpPacket = false;
                 needSnap = false;
+            } else if (peerLastEpoch != lastProcessedEpoch && !db.isInCommittedLog(peerLastZxid)) {","[{'comment': 'Could you please add a description to the comments above (to ""Here are the cases that we want to handle"") what this else if case is doing?', 'commenter': 'Unknown'}]"
453,src/java/test/org/apache/zookeeper/server/quorum/LearnerHandlerTest.java,"@@ -462,6 +469,8 @@ public void testNewEpochZxid() throws Exception {
 
         // Peer has zxid of epoch 1
         peerZxid = getZxid(1, 0);
+        //We are on a different epoch so we don't know 1, 0 is in our log or not.
+        // So we need to do a full SNAP","[{'comment': ""I think this comment has been added by mistake. You added (1,0) to the log above, hence syncFollower() returns false which means we don't need to do full SNAP."", 'commenter': 'anmolnar'}]"
453,src/java/test/org/apache/zookeeper/server/quorum/LearnerHandlerTest.java,"@@ -498,31 +507,20 @@ public void testNewEpochZxidWithTxnlogOnly() throws Exception {
 
         // Peer has zxid of epoch 3
         peerZxid = getZxid(3, 0);
-        assertFalse(learnerHandler.syncFollower(peerZxid, db, leader));
-        // We send DIFF to (6,0) and forward any packet starting at (4,1)
-        assertOpType(Leader.DIFF, getZxid(6, 0), getZxid(4, 1));
-        // DIFF + 1 proposals + 1 commit
-        assertEquals(3, learnerHandler.getQueuedPackets().size());
-        queuedPacketMatches(new long[] { getZxid(4, 1)});
+        //There is no 3, 0 proposal in the committed log so sync
+        assertTrue(learnerHandler.syncFollower(peerZxid, db, leader));","[{'comment': ""It seems to me that this test checking the same thing 3 times in a row.\r\nDo you think it's necessary to do so?"", 'commenter': 'anmolnar'}]"
453,src/java/main/org/apache/zookeeper/server/ZKDatabase.java,"@@ -233,14 +233,32 @@ public long getDataTreeLastProcessedZxid() {
      * @throws IOException
      */
     public long loadDataBase() throws IOException {
-        PlayBackListener listener=new PlayBackListener(){
+        PlayBackListener listener = new PlayBackListener(){
             public void onTxnLoaded(TxnHeader hdr,Record txn){
                 Request r = new Request(0, hdr.getCxid(),hdr.getType(), hdr, txn, hdr.getZxid());
                 addCommittedProposal(r);
             }
         };
 
-        long zxid = snapLog.restore(dataTree,sessionsWithTimeouts,listener);
+        long zxid = snapLog.restore(dataTree, sessionsWithTimeouts, listener);
+        initialized = true;
+        return zxid;
+    }
+
+    /**
+     * Fast forward the database adding transactions from the committed log into memory.
+     * @return the last valid zxid.
+     * @throws IOException
+     */
+    public long fastForwardDataBase() throws IOException {
+        PlayBackListener listener = new PlayBackListener(){","[{'comment': ""I think it'd be nice to extract the common logic of these two methods into a separate one."", 'commenter': 'anmolnar'}, {'comment': 'Will do', 'commenter': 'revans2'}]"
453,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -435,7 +435,7 @@ private void waitForOne(ZooKeeper zk, States state) throws InterruptedException
         int iterations = ClientBase.CONNECTION_TIMEOUT / 500;
         while (zk.getState() != state) {
             if (iterations-- == 0) {
-                throw new RuntimeException(""Waiting too long"");
+                throw new RuntimeException(""Waiting too long "" + zk.getState() + "" != "" + state);","[{'comment': ""nit: let's minimize unrelated test changes and whitespace changes"", 'commenter': 'afine'}, {'comment': 'Although I agree with you in general, I think this one here is a good addition to test output.', 'commenter': 'anmolnar'}, {'comment': '@anmolnar  and @afine I put this in for my own debugging and I forgot to remove it.  If you want me to I am happy to either remove it or file a separate JIRA and put it up as a separate pull request, or just leave it.  Either way is fine with me.', 'commenter': 'revans2'}, {'comment': 'Since @anmolnar thinks it is valuable, I think it is fine for it to be left in. ', 'commenter': 'afine'}]"
453,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -888,4 +888,127 @@ public void testWithOnlyMinSessionTimeout() throws Exception {
                 maxSessionTimeOut, quorumPeer.getMaxSessionTimeout());
     }
 
+    @Test
+    public void testTxnAheadSnapInRetainDB() throws Exception {","[{'comment': 'nit: I don\'t think we use the terminology ""RetainDB"" anywhere else. Perhaps we can get rid of ""retain""?', 'commenter': 'afine'}, {'comment': 'done', 'commenter': 'revans2'}]"
453,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -888,4 +888,127 @@ public void testWithOnlyMinSessionTimeout() throws Exception {
                 maxSessionTimeOut, quorumPeer.getMaxSessionTimeout());
     }
 
+    @Test
+    public void testTxnAheadSnapInRetainDB() throws Exception {
+        // 1. start up server and wait for leader election to finish
+        ClientBase.setupTestEnv();
+        final int SERVER_COUNT = 3;
+        final int clientPorts[] = new int[SERVER_COUNT];
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            clientPorts[i] = PortAssignment.unique();
+            sb.append(""server."" + i + ""=127.0.0.1:"" + PortAssignment.unique() + "":"" + PortAssignment.unique() + "";"" + clientPorts[i] + ""\n"");
+        }
+        String quorumCfgSection = sb.toString();
+
+        MainThread mt[] = new MainThread[SERVER_COUNT];
+        ZooKeeper zk[] = new ZooKeeper[SERVER_COUNT];
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection);
+            mt[i].start();
+            zk[i] = new ZooKeeper(""127.0.0.1:"" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);
+        }
+
+        waitForAll(zk, States.CONNECTED);
+
+        // we need to shutdown and start back up to make sure that the create session isn't the first transaction since
+        // that is rather innocuous.
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i].shutdown();
+        }
+
+        waitForAll(zk, States.CONNECTING);
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i].start();
+            // Recreate a client session since the previous session was not persisted.
+            zk[i] = new ZooKeeper(""127.0.0.1:"" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);
+        }
+
+        waitForAll(zk, States.CONNECTED);
+
+        // 2. kill all followers
+        int leader = -1;
+        Map<Long, Proposal> outstanding = null;
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (mt[i].main.quorumPeer.leader != null) {
+                leader = i;
+                outstanding = mt[leader].main.quorumPeer.leader.outstandingProposals;
+                // increase the tick time to delay the leader going to looking
+                mt[leader].main.quorumPeer.tickTime = 10000;
+            }
+        }
+        LOG.warn(""LEADER {}"", leader);
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                mt[i].shutdown();
+            }
+        }
+
+        // 3. start up the followers to form a new quorum
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                mt[i].start();
+            }
+        }
+
+        // 4. wait one of the follower to be the leader
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                // Recreate a client session since the previous session was not persisted.
+                zk[i] = new ZooKeeper(""127.0.0.1:"" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);
+                waitForOne(zk[i], States.CONNECTED);
+            }
+        }
+
+        // 5. send a create request to leader and make sure it's synced to disk,
+        //    which means it acked from itself
+        try {
+            zk[leader].create(""/zk"" + leader, ""zk"".getBytes(), Ids.OPEN_ACL_UNSAFE,
+                CreateMode.PERSISTENT);
+            Assert.fail(""create /zk"" + leader + "" should have failed"");
+        } catch (KeeperException e) {
+        }
+
+        // just make sure that we actually did get it in process at the
+        // leader
+        Assert.assertTrue(outstanding.size() == 1);
+        Proposal p = (Proposal) outstanding.values().iterator().next();
+        Assert.assertTrue(p.request.getHdr().getType() == OpCode.create);
+
+        // make sure it has a chance to write it to disk
+        Thread.sleep(1000);
+        p.qvAcksetPairs.get(0).getAckset().contains(leader);
+
+        // 6. wait the leader to quit due to no enough followers
+        Thread.sleep(4000);
+        //waitForOne(zk[leader], States.CONNECTING);","[{'comment': 'remove this', 'commenter': 'afine'}, {'comment': 'done', 'commenter': 'revans2'}]"
453,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -888,4 +888,127 @@ public void testWithOnlyMinSessionTimeout() throws Exception {
                 maxSessionTimeOut, quorumPeer.getMaxSessionTimeout());
     }
 
+    @Test
+    public void testTxnAheadSnapInRetainDB() throws Exception {
+        // 1. start up server and wait for leader election to finish
+        ClientBase.setupTestEnv();
+        final int SERVER_COUNT = 3;
+        final int clientPorts[] = new int[SERVER_COUNT];
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            clientPorts[i] = PortAssignment.unique();
+            sb.append(""server."" + i + ""=127.0.0.1:"" + PortAssignment.unique() + "":"" + PortAssignment.unique() + "";"" + clientPorts[i] + ""\n"");
+        }
+        String quorumCfgSection = sb.toString();
+
+        MainThread mt[] = new MainThread[SERVER_COUNT];
+        ZooKeeper zk[] = new ZooKeeper[SERVER_COUNT];
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection);","[{'comment': ""is there any reason we can't use the existing test infra to clean this up a little"", 'commenter': 'afine'}, {'comment': '+1\r\nAs mentioned testElectionFraud() is a good example for that.', 'commenter': 'anmolnar'}, {'comment': 'I am not super familiar with the test infrastructure.  If you have a suggestion I would love it, otherwise I will look around and see what I can come up with.', 'commenter': 'revans2'}, {'comment': 'Use `LaunchServers(numServers, tickTime)` method in this class.\r\nIt gives you a collection of `MainThread` and `ZooKeeper` objects properly initialized.\r\nTest `tearDown()` will care about destroying it. ', 'commenter': 'anmolnar'}]"
453,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -888,4 +888,127 @@ public void testWithOnlyMinSessionTimeout() throws Exception {
                 maxSessionTimeOut, quorumPeer.getMaxSessionTimeout());
     }
 
+    @Test
+    public void testTxnAheadSnapInRetainDB() throws Exception {
+        // 1. start up server and wait for leader election to finish
+        ClientBase.setupTestEnv();
+        final int SERVER_COUNT = 3;
+        final int clientPorts[] = new int[SERVER_COUNT];
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            clientPorts[i] = PortAssignment.unique();
+            sb.append(""server."" + i + ""=127.0.0.1:"" + PortAssignment.unique() + "":"" + PortAssignment.unique() + "";"" + clientPorts[i] + ""\n"");
+        }
+        String quorumCfgSection = sb.toString();
+
+        MainThread mt[] = new MainThread[SERVER_COUNT];
+        ZooKeeper zk[] = new ZooKeeper[SERVER_COUNT];
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection);
+            mt[i].start();
+            zk[i] = new ZooKeeper(""127.0.0.1:"" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);
+        }
+
+        waitForAll(zk, States.CONNECTED);
+
+        // we need to shutdown and start back up to make sure that the create session isn't the first transaction since
+        // that is rather innocuous.
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i].shutdown();
+        }
+
+        waitForAll(zk, States.CONNECTING);
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i].start();
+            // Recreate a client session since the previous session was not persisted.
+            zk[i] = new ZooKeeper(""127.0.0.1:"" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);
+        }
+
+        waitForAll(zk, States.CONNECTED);
+
+        // 2. kill all followers
+        int leader = -1;
+        Map<Long, Proposal> outstanding = null;
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (mt[i].main.quorumPeer.leader != null) {
+                leader = i;
+                outstanding = mt[leader].main.quorumPeer.leader.outstandingProposals;
+                // increase the tick time to delay the leader going to looking
+                mt[leader].main.quorumPeer.tickTime = 10000;
+            }
+        }
+        LOG.warn(""LEADER {}"", leader);
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                mt[i].shutdown();
+            }
+        }
+
+        // 3. start up the followers to form a new quorum
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                mt[i].start();
+            }
+        }
+
+        // 4. wait one of the follower to be the leader
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                // Recreate a client session since the previous session was not persisted.
+                zk[i] = new ZooKeeper(""127.0.0.1:"" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);
+                waitForOne(zk[i], States.CONNECTED);
+            }
+        }
+
+        // 5. send a create request to leader and make sure it's synced to disk,
+        //    which means it acked from itself
+        try {
+            zk[leader].create(""/zk"" + leader, ""zk"".getBytes(), Ids.OPEN_ACL_UNSAFE,
+                CreateMode.PERSISTENT);
+            Assert.fail(""create /zk"" + leader + "" should have failed"");
+        } catch (KeeperException e) {
+        }
+
+        // just make sure that we actually did get it in process at the
+        // leader
+        Assert.assertTrue(outstanding.size() == 1);
+        Proposal p = (Proposal) outstanding.values().iterator().next();","[{'comment': 'Do we need this cast?', 'commenter': 'afine'}, {'comment': 'removed the cast', 'commenter': 'revans2'}]"
453,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -888,4 +888,127 @@ public void testWithOnlyMinSessionTimeout() throws Exception {
                 maxSessionTimeOut, quorumPeer.getMaxSessionTimeout());
     }
 
+    @Test
+    public void testTxnAheadSnapInRetainDB() throws Exception {
+        // 1. start up server and wait for leader election to finish
+        ClientBase.setupTestEnv();
+        final int SERVER_COUNT = 3;
+        final int clientPorts[] = new int[SERVER_COUNT];
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            clientPorts[i] = PortAssignment.unique();
+            sb.append(""server."" + i + ""=127.0.0.1:"" + PortAssignment.unique() + "":"" + PortAssignment.unique() + "";"" + clientPorts[i] + ""\n"");
+        }
+        String quorumCfgSection = sb.toString();
+
+        MainThread mt[] = new MainThread[SERVER_COUNT];
+        ZooKeeper zk[] = new ZooKeeper[SERVER_COUNT];
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection);
+            mt[i].start();
+            zk[i] = new ZooKeeper(""127.0.0.1:"" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);
+        }
+
+        waitForAll(zk, States.CONNECTED);
+
+        // we need to shutdown and start back up to make sure that the create session isn't the first transaction since
+        // that is rather innocuous.
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i].shutdown();
+        }
+
+        waitForAll(zk, States.CONNECTING);
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i].start();
+            // Recreate a client session since the previous session was not persisted.
+            zk[i] = new ZooKeeper(""127.0.0.1:"" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);
+        }
+
+        waitForAll(zk, States.CONNECTED);
+
+        // 2. kill all followers
+        int leader = -1;
+        Map<Long, Proposal> outstanding = null;
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (mt[i].main.quorumPeer.leader != null) {
+                leader = i;
+                outstanding = mt[leader].main.quorumPeer.leader.outstandingProposals;
+                // increase the tick time to delay the leader going to looking
+                mt[leader].main.quorumPeer.tickTime = 10000;
+            }
+        }
+        LOG.warn(""LEADER {}"", leader);
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                mt[i].shutdown();
+            }
+        }
+
+        // 3. start up the followers to form a new quorum
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                mt[i].start();
+            }
+        }
+
+        // 4. wait one of the follower to be the leader
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                // Recreate a client session since the previous session was not persisted.
+                zk[i] = new ZooKeeper(""127.0.0.1:"" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);
+                waitForOne(zk[i], States.CONNECTED);
+            }
+        }
+
+        // 5. send a create request to leader and make sure it's synced to disk,
+        //    which means it acked from itself
+        try {
+            zk[leader].create(""/zk"" + leader, ""zk"".getBytes(), Ids.OPEN_ACL_UNSAFE,
+                CreateMode.PERSISTENT);
+            Assert.fail(""create /zk"" + leader + "" should have failed"");
+        } catch (KeeperException e) {
+        }
+
+        // just make sure that we actually did get it in process at the
+        // leader
+        Assert.assertTrue(outstanding.size() == 1);
+        Proposal p = (Proposal) outstanding.values().iterator().next();
+        Assert.assertTrue(p.request.getHdr().getType() == OpCode.create);
+
+        // make sure it has a chance to write it to disk
+        Thread.sleep(1000);","[{'comment': 'There is a lot of `Thread.sleep()` going on and I would like to find a way to minimize that. Apache infra can occasionally be quite slow (it can starve threads) and tests with many `Thread.sleep()`s in them have historically been quite flaky.\r\n\r\nSo, to the extent that it is possible. I would like to minimize occurrences of `Thread.sleep()`, or at least those outside the context of retry logic.\r\n\r\nSo perhaps, we can throw `p.qvAcksetPairs.get(0).getAckset().contains(leader);` in a loop waiting one second between iterations.\r\n\r\nw.r.t. step 6, we can wait for the leader to enter the looking state.\r\n\r\nWhat do you think?\r\n\r\n\r\n\r\n', 'commenter': 'afine'}, {'comment': 'I will see if I can make it work.  I agree I would love to kill as many of the sleeps as possible.', 'commenter': 'revans2'}, {'comment': ""I was able to do what you said and drop the 1 second sleep, but the sleep at step 6 I am going to need something else because the leader is only in the looking state for 2 ms.  Leader election happens way too fast for us to be able to catch that by polling.  \r\n\r\nIf I remove the 4 second sleep it does not trigger the error case, I don't completely know why.  I'll spend some time looking at it, but if you have any suggestions I would appreciate it."", 'commenter': 'revans2'}, {'comment': '@revans2 take a look at `testElectionFraud`, specifically: https://github.com/apache/zookeeper/blob/master/src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java#L383 and https://github.com/apache/zookeeper/blob/master/src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java#L397\r\n\r\nYou can manually start and stop leader election, I think that may solve this problem. ', 'commenter': 'afine'}]"
453,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -465,6 +470,37 @@ private void waitForAll(ZooKeeper[] zks, States state) throws InterruptedExcepti
     private static class Servers {
         MainThread mt[];
         ZooKeeper zk[];
+        int[] clientPorts;
+
+        public void shutDownAllServers() throws InterruptedException {
+            for (MainThread t: mt) {
+                t.shutdown();
+            }
+        }
+
+        public void restartAllServersAndClients(Watcher watcher) throws IOException {
+            for (MainThread t : mt) {
+                if (!t.isAlive()) {
+                    t.start();
+                }
+            }
+            for (int i = 0; i < zk.length; i++) {
+                restartClient(i, watcher);
+            }
+        }
+
+        public void restartClient(int i, Watcher watcher) throws IOException {","[{'comment': ""annoying nitpick: let's use a better argument name than `i`"", 'commenter': 'afine'}]"
453,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -465,6 +470,37 @@ private void waitForAll(ZooKeeper[] zks, States state) throws InterruptedExcepti
     private static class Servers {
         MainThread mt[];
         ZooKeeper zk[];
+        int[] clientPorts;
+
+        public void shutDownAllServers() throws InterruptedException {
+            for (MainThread t: mt) {
+                t.shutdown();
+            }
+        }
+
+        public void restartAllServersAndClients(Watcher watcher) throws IOException {
+            for (MainThread t : mt) {
+                if (!t.isAlive()) {
+                    t.start();
+                }
+            }
+            for (int i = 0; i < zk.length; i++) {
+                restartClient(i, watcher);
+            }
+        }
+
+        public void restartClient(int i, Watcher watcher) throws IOException {
+            zk[i] = new ZooKeeper(""127.0.0.1:"" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, watcher);
+        }
+
+        public int findLeader() {","[{'comment': 'there are other places in this test class that benefit from this refactoring. Would you mind cleaning that up?', 'commenter': 'afine'}]"
453,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -888,4 +923,103 @@ public void testWithOnlyMinSessionTimeout() throws Exception {
                 maxSessionTimeOut, quorumPeer.getMaxSessionTimeout());
     }
 
+    @Test
+    public void testFailedTxnAsPartOfQuorumLoss() throws Exception {
+        // 1. start up server and wait for leader election to finish
+        ClientBase.setupTestEnv();
+        final int SERVER_COUNT = 3;
+        servers = LaunchServers(SERVER_COUNT);
+
+        waitForAll(servers, States.CONNECTED);
+
+        // we need to shutdown and start back up to make sure that the create session isn't the first transaction since
+        // that is rather innocuous.
+        servers.shutDownAllServers();
+        waitForAll(servers, States.CONNECTING);
+        servers.restartAllServersAndClients(this);
+        waitForAll(servers, States.CONNECTED);
+
+        // 2. kill all followers
+        int leader = servers.findLeader();
+        Map<Long, Proposal> outstanding =  servers.mt[leader].main.quorumPeer.leader.outstandingProposals;
+        // increase the tick time to delay the leader going to looking
+        servers.mt[leader].main.quorumPeer.tickTime = 10000;
+        LOG.warn(""LEADER {}"", leader);
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                servers.mt[i].shutdown();
+            }
+        }
+
+        // 3. start up the followers to form a new quorum
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                servers.mt[i].start();
+            }
+        }
+
+        // 4. wait one of the follower to be the new leader
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                // Recreate a client session since the previous session was not persisted.
+                servers.restartClient(i, this);
+                waitForOne(servers.zk[i], States.CONNECTED);
+            }
+        }
+
+        // 5. send a create request to old leader and make sure it's synced to disk,
+        //    which means it acked from itself
+        try {
+            servers.zk[leader].create(""/zk"" + leader, ""zk"".getBytes(), Ids.OPEN_ACL_UNSAFE,
+                CreateMode.PERSISTENT);
+            Assert.fail(""create /zk"" + leader + "" should have failed"");
+        } catch (KeeperException e) {
+        }
+
+        // just make sure that we actually did get it in process at the
+        // leader
+        Assert.assertEquals(1, outstanding.size());
+        Proposal p = outstanding.values().iterator().next();
+        Assert.assertEquals(OpCode.create, p.request.getHdr().getType());
+
+        // make sure it has a chance to write it to disk
+        int sleepTime = 0;
+        Long longLeader = new Long(leader);
+        while (!p.qvAcksetPairs.get(0).getAckset().contains(longLeader)) {
+            if (sleepTime > 2000) {
+                Assert.fail(""Transaction not synced to disk within 1 second "" + p.qvAcksetPairs.get(0).getAckset()
+                    + "" expected "" + leader);
+            }
+            Thread.sleep(100);
+            sleepTime += 100;
+        }
+
+        // 6. wait for the leader to quit due to not enough followers and come back up as a part of the new quorum
+        sleepTime = 0;
+        Follower f = servers.mt[leader].main.quorumPeer.follower;
+        while (f == null || !f.isRunning()) {
+            if (sleepTime > 10_000) {","[{'comment': 'nitpick: can we reuse the ticktime here to make the relationship more obvious?', 'commenter': 'afine'}]"
453,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -888,4 +923,103 @@ public void testWithOnlyMinSessionTimeout() throws Exception {
                 maxSessionTimeOut, quorumPeer.getMaxSessionTimeout());
     }
 
+    @Test
+    public void testFailedTxnAsPartOfQuorumLoss() throws Exception {
+        // 1. start up server and wait for leader election to finish
+        ClientBase.setupTestEnv();
+        final int SERVER_COUNT = 3;
+        servers = LaunchServers(SERVER_COUNT);
+
+        waitForAll(servers, States.CONNECTED);
+
+        // we need to shutdown and start back up to make sure that the create session isn't the first transaction since
+        // that is rather innocuous.
+        servers.shutDownAllServers();
+        waitForAll(servers, States.CONNECTING);
+        servers.restartAllServersAndClients(this);
+        waitForAll(servers, States.CONNECTED);
+
+        // 2. kill all followers
+        int leader = servers.findLeader();
+        Map<Long, Proposal> outstanding =  servers.mt[leader].main.quorumPeer.leader.outstandingProposals;
+        // increase the tick time to delay the leader going to looking
+        servers.mt[leader].main.quorumPeer.tickTime = 10000;
+        LOG.warn(""LEADER {}"", leader);
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                servers.mt[i].shutdown();
+            }
+        }
+
+        // 3. start up the followers to form a new quorum
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                servers.mt[i].start();
+            }
+        }
+
+        // 4. wait one of the follower to be the new leader
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            if (i != leader) {
+                // Recreate a client session since the previous session was not persisted.
+                servers.restartClient(i, this);
+                waitForOne(servers.zk[i], States.CONNECTED);
+            }
+        }
+
+        // 5. send a create request to old leader and make sure it's synced to disk,
+        //    which means it acked from itself
+        try {
+            servers.zk[leader].create(""/zk"" + leader, ""zk"".getBytes(), Ids.OPEN_ACL_UNSAFE,
+                CreateMode.PERSISTENT);
+            Assert.fail(""create /zk"" + leader + "" should have failed"");
+        } catch (KeeperException e) {
+        }
+
+        // just make sure that we actually did get it in process at the
+        // leader
+        Assert.assertEquals(1, outstanding.size());
+        Proposal p = outstanding.values().iterator().next();
+        Assert.assertEquals(OpCode.create, p.request.getHdr().getType());
+
+        // make sure it has a chance to write it to disk
+        int sleepTime = 0;
+        Long longLeader = new Long(leader);
+        while (!p.qvAcksetPairs.get(0).getAckset().contains(longLeader)) {
+            if (sleepTime > 2000) {
+                Assert.fail(""Transaction not synced to disk within 1 second "" + p.qvAcksetPairs.get(0).getAckset()
+                    + "" expected "" + leader);
+            }
+            Thread.sleep(100);
+            sleepTime += 100;
+        }
+
+        // 6. wait for the leader to quit due to not enough followers and come back up as a part of the new quorum
+        sleepTime = 0;
+        Follower f = servers.mt[leader].main.quorumPeer.follower;
+        while (f == null || !f.isRunning()) {
+            if (sleepTime > 10_000) {
+                Assert.fail(""Took too long for old leader to time out "" + servers.mt[leader].main.quorumPeer.getPeerState());
+            }
+            Thread.sleep(100);
+            sleepTime += 100;
+            f = servers.mt[leader].main.quorumPeer.follower;
+        }
+        servers.mt[leader].shutdown();","[{'comment': 'why do we need this?', 'commenter': 'afine'}, {'comment': ""It is a lot of very specific steps that make the data inconsistency show up.  This is needed to force the transaction log to be replayed which has an edit in it that wasn't considered as a part of leader election."", 'commenter': 'revans2'}]"
458,src/java/test/org/apache/zookeeper/test/ClientBase.java,"@@ -368,22 +368,37 @@ static void verifyThreadTerminated(Thread thread, long millis)
         }
     }
 
+    public static File createEmptyTestDir() throws IOException {
+        return createTmpDir(BASETEST, false);
+    }
 
     public static File createTmpDir() throws IOException {
-        return createTmpDir(BASETEST);
+        return createTmpDir(BASETEST, true);
     }
 
-    static File createTmpDir(File parentDir) throws IOException {
+    static File createTmpDir(File parentDir, boolean createInitFile) throws IOException {
         File tmpFile = File.createTempFile(""test"", "".junit"", parentDir);
         // don't delete tmpFile - this ensures we don't attempt to create
         // a tmpDir with a duplicate name
         File tmpDir = new File(tmpFile + "".dir"");
         Assert.assertFalse(tmpDir.exists()); // never true if tmpfile does it's job
         Assert.assertTrue(tmpDir.mkdirs());
 
+        // todo not every tmp directory needs this file","[{'comment': 'why is this todo here?', 'commenter': 'afine'}, {'comment': 'Unfortunately this todo comment is in the master branch from where I backported these changes in ClientBase. ', 'commenter': 'Unknown'}]"
459,src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java,"@@ -51,19 +51,22 @@
 public class FileSnap implements SnapShot {
     File snapDir;
     private volatile boolean close = false;
-    private static final int VERSION=2;
-    private static final long dbId=-1;
+    private static final int VERSION = 2;","[{'comment': 'Please revert this', 'commenter': 'afine'}]"
459,src/java/test/org/apache/zookeeper/test/ClientBase.java,"@@ -351,20 +351,37 @@ static void verifyThreadTerminated(Thread thread, long millis)
         }
     }
 
+    public static File createEmptyTestDir() throws IOException {
+        return createTmpDir(BASETEST, false);
+    }
 
     public static File createTmpDir() throws IOException {
-        return createTmpDir(BASETEST);
+        return createTmpDir(BASETEST, true);
     }
-    static File createTmpDir(File parentDir) throws IOException {
+
+    static File createTmpDir(File parentDir, boolean createInitFile) throws IOException {
         File tmpFile = File.createTempFile(""test"", "".junit"", parentDir);
         // don't delete tmpFile - this ensures we don't attempt to create
         // a tmpDir with a duplicate name
         File tmpDir = new File(tmpFile + "".dir"");
         Assert.assertFalse(tmpDir.exists()); // never true if tmpfile does it's job
         Assert.assertTrue(tmpDir.mkdirs());
 
+        // todo not every tmp directory needs this file","[{'comment': 'do we need this todo?', 'commenter': 'afine'}, {'comment': 'Unfortunately this todo comment is in the master branch from where I backported these changes in ClientBase.', 'commenter': 'Unknown'}]"
469,build.xml,"@@ -1861,4 +1861,18 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
        <delete dir=""${build.dir.eclipse}"" />
      </target>
 
+    <target name=""print_compile_classpath"">","[{'comment': 'nit: I think most of our other ant targets use ""-"" instead of ""_"" between words.', 'commenter': 'afine'}, {'comment': 'True, my intention with the \\""\\_\\"" was to indicate that these targets are purely utility targets i.e. it does not make too much sense to run them individually, unlike clean, compile, test-core-java etc. targets. If you don\'t like this idea, I can replace the \\""\\_\\""-s with ""-""-s if you wish.', 'commenter': 'Unknown'}, {'comment': ""let's replace them for the sake of consistency"", 'commenter': 'afine'}, {'comment': '@afine ok, I\'ve replaced ""_"" with ""-"" in the new ant target names.', 'commenter': 'Unknown'}]"
469,build.xml,"@@ -1861,4 +1861,18 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
        <delete dir=""${build.dir.eclipse}"" />
      </target>
 
+    <target name=""print_compile_classpath"">
+        <pathconvert pathsep=""${line.separator}|   |-- "" property=""echo.compile.classpath"" refid=""java.classpath""/>","[{'comment': 'I found a ""one-liner"" for this here: http://ant.apache.org/manual/using.html#pathshortcut\r\n\r\nFor example:\r\n```xml\r\n<echo>${toString:java.classpath}</echo>\r\n```\r\n\r\nWhat do you think?', 'commenter': 'afine'}, {'comment': 'The difference between the two is that the one I used prints the paths in a pretty printed way, while the ""one-liner"" prints all paths continuously which is hard to read.', 'commenter': 'Unknown'}, {'comment': 'fine with me', 'commenter': 'afine'}]"
474,src/java/test/org/apache/zookeeper/server/NIOServerCnxnTest.java,"@@ -103,4 +105,22 @@ public void testValidSelectionKey() throws Exception {
             zk.close();
         }
     }
+
+    @Test(timeout = 30000)
+    public void testServerCnxnGetAuthInfoWithCopy() throws Exception {
+        final ZooKeeper zk = createZKClient(hostPort, 3000);
+        try {
+            Iterable<ServerCnxn> connections = serverFactory.getConnections();
+            for (ServerCnxn serverCnxn : connections) {
+            	List<Id> authInfo = serverCnxn.getAuthInfo();
+            	Id id = new Id(""testscheme"", ""test"");
+				serverCnxn.addAuthInfo(id);
+				Assert.assertTrue(!authInfo.contains(id));","[{'comment': ""nit: let's use assertFalse"", 'commenter': 'afine'}]"
474,src/java/test/org/apache/zookeeper/server/ServerCnxnTest.java,"@@ -0,0 +1,129 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.nio.ByteBuffer;
+import java.util.List;
+
+import org.apache.jute.Record;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.data.Id;
+import org.apache.zookeeper.proto.ReplyHeader;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class ServerCnxnTest extends ZKTestCase {
+
+    /**
+     * Test getting a copy of authinfo to avoid parallel modification impact
+     */
+    @Test
+    public void testServerCnxnGetAuthInfoWithCopy() throws Exception {
+            MockServerCnxn serverCnxn = new MockServerCnxn();
+                List<Id> authInfo = serverCnxn.getAuthInfo();","[{'comment': 'nit: please fix this indentation', 'commenter': 'afine'}]"
474,src/java/test/org/apache/zookeeper/server/ServerCnxnTest.java,"@@ -0,0 +1,130 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.nio.ByteBuffer;
+import java.util.List;
+
+import org.apache.jute.Record;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.data.Id;
+import org.apache.zookeeper.proto.ReplyHeader;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class ServerCnxnTest extends ZKTestCase {
+
+    /**
+     * Test getting a copy of authinfo to avoid parallel modification impact
+     */
+    @Test
+    public void testServerCnxnGetAuthInfoWithCopy() throws Exception {
+        MockServerCnxn serverCnxn = new MockServerCnxn();
+        List<Id> authInfo = serverCnxn.getAuthInfo();
+        Id id = new Id(""testscheme"", ""test"");
+        serverCnxn.addAuthInfo(id);
+        Assert.assertFalse(authInfo.contains(id));
+        Assert.assertTrue(serverCnxn.getAuthInfo().contains(id));
+    }
+    
+    /**
+     * Mock extension of ServerCnxn dummy to test for
+     * AuthInfo behavior (ZOOKEEPER-2977).
+     */
+    private static class MockServerCnxn extends ServerCnxn {","[{'comment': ""@sumitagrawl Can't you just use mockito to get the desired behaviour?"", 'commenter': 'anmolnar'}, {'comment': 'Followed similar test case as MockNIOServerCnxn.java & NIOServerCnxnTest.java as present in same package, so should change this to use Mockito?', 'commenter': 'sumitagrawl'}, {'comment': ""Up to you. \r\n\r\nBut, it's generally better to keep the scope of this patch for changes strictly related to the Jira and create separate one for other refactorings.\r\n\r\nI'm happy to commit both, but you need to do the paperwork.\r\n\r\nI don't mind having different approaches for the same goal, I'm only against following habits which we can do better."", 'commenter': 'anmolnar'}, {'comment': 'Ok, will change to Mockito.\r\nPlease share some details related to the paper work to be done.', 'commenter': 'sumitagrawl'}, {'comment': 'Cool, thanks @sumitagrawl \r\nSorry I was trying to kinda joking with ""paperwork"": you only need to create separate Jira and pull request for the refactoring. ;)', 'commenter': 'anmolnar'}]"
476,src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,"@@ -1064,7 +1065,12 @@ else if (self.getCurrentAndNextConfigVoters().contains(n.sid)) {
                         break;
                     }
                 } else {
-                    LOG.warn(""Ignoring notification from non-cluster member "" + n.sid);
+                    if (!self.getCurrentAndNextConfigVoters().contains(n.leader)) {
+                        LOG.warn(""Ignoring notification for non-cluster member sid {} from sid {}"", n.leader, n.sid);
+                    }
+                    if (!self.getCurrentAndNextConfigVoters().contains(n.sid)) {
+                        LOG.warn(""Ignoring notification from non-cluster member sid {}"", n.sid);","[{'comment': 'lets log which member was voted for', 'commenter': 'afine'}, {'comment': 'nit: lets say ""quorum"" instead of ""cluster""', 'commenter': 'afine'}]"
476,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -1012,4 +1012,113 @@ public void testFailedTxnAsPartOfQuorumLoss() throws Exception {
             Assert.assertNull(""server "" + i + "" should not have /zk"" + leader, servers.zk[i].exists(""/zk"" + leader, false));
         }
     }
+
+    /**
+     * Verify that a node without the leader in its view will not attempt to connect to the leader.
+     */
+    @Test
+    public void testLeaderOutOfView() throws Exception {
+        ClientBase.setupTestEnv();
+
+        Layout layout = new PatternLayout(""%d{ISO8601} [,yid:%X{myid}] - %5p [%t:%C{1}@%L] - %m%n"");","[{'comment': 'It would be great if we did not specify the pattern as a literal. Take a look at some of the other tests and see if the way they get the patternlayout could apply here (`testElectionFraud` for example).', 'commenter': 'afine'}]"
476,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -1012,4 +1012,113 @@ public void testFailedTxnAsPartOfQuorumLoss() throws Exception {
             Assert.assertNull(""server "" + i + "" should not have /zk"" + leader, servers.zk[i].exists(""/zk"" + leader, false));
         }
     }
+
+    /**
+     * Verify that a node without the leader in its view will not attempt to connect to the leader.
+     */
+    @Test
+    public void testLeaderOutOfView() throws Exception {
+        ClientBase.setupTestEnv();
+
+        Layout layout = new PatternLayout(""%d{ISO8601} [,yid:%X{myid}] - %5p [%t:%C{1}@%L] - %m%n"");
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        WriterAppender appender = new WriterAppender(layout, os);
+        appender.setThreshold(Level.DEBUG);
+        Logger qlogger = Logger.getLogger(""org.apache.zookeeper.server.quorum"");
+        qlogger.addAppender(appender);
+
+        try {
+            final int CLIENT_PORT_QP1 = PortAssignment.unique();
+            final int CLIENT_PORT_QP2 = PortAssignment.unique();
+            final int CLIENT_PORT_QP3 = PortAssignment.unique();
+
+            String quorumCfgIncomplete = getUniquePortCfgForId(1) + ""\n"" + getUniquePortCfgForId(2);
+            String quorumCfgComplete = quorumCfgIncomplete + ""\n"" + getUniquePortCfgForId(3);
+
+            // Node 1 is started without the leader (3) in its config view
+            MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgIncomplete);
+            MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgComplete);
+            MainThread q3 = new MainThread(3, CLIENT_PORT_QP3, quorumCfgComplete);
+
+            // Node 1 must be started first, before quorum is formed, to trigger the attempted invalid connection to 3
+            q1.start();
+            QuorumPeer quorumPeer1 = waitForQuorumPeer(q1, CONNECTION_TIMEOUT);
+            Assert.assertTrue(quorumPeer1.getPeerState() == QuorumPeer.ServerState.LOOKING);
+
+            // Node 3 started second to avoid 1 and 2 forming a quorum before 3 starts up
+            q3.start();
+            QuorumPeer quorumPeer3 = waitForQuorumPeer(q3, CONNECTION_TIMEOUT);
+            Assert.assertTrue(quorumPeer3.getPeerState() == QuorumPeer.ServerState.LOOKING);
+
+            // Node 2 started last, kicks off leader election
+            q2.start();
+
+            // Nodes 2 and 3 now form quorum and fully start. 1 attempts to vote for 3, fails, returns to LOOKING state
+            Assert.assertTrue(""waiting for server 2 to start"",
+                    ClientBase.waitForServerUp(""127.0.0.1:"" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));
+            Assert.assertTrue(""waiting for server 3 to start"",
+                    ClientBase.waitForServerUp(""127.0.0.1:"" + CLIENT_PORT_QP3, CONNECTION_TIMEOUT));
+
+            Assert.assertTrue(q1.getQuorumPeer().getPeerState() == QuorumPeer.ServerState.LOOKING);
+            Assert.assertTrue(q2.getQuorumPeer().getPeerState() == QuorumPeer.ServerState.FOLLOWING);
+            Assert.assertTrue(q3.getQuorumPeer().getPeerState() == QuorumPeer.ServerState.LEADING);
+
+            q1.shutdown();
+            q2.shutdown();
+            q3.shutdown();
+
+            Assert.assertTrue(""waiting for server 1 down"",
+                    ClientBase.waitForServerDown(""127.0.0.1:"" + CLIENT_PORT_QP1,
+                            ClientBase.CONNECTION_TIMEOUT));
+            Assert.assertTrue(""waiting for server 2 down"",
+                    ClientBase.waitForServerDown(""127.0.0.1:"" + CLIENT_PORT_QP2,
+                            ClientBase.CONNECTION_TIMEOUT));
+            Assert.assertTrue(""waiting for server 3 down"",
+                    ClientBase.waitForServerDown(""127.0.0.1:"" + CLIENT_PORT_QP3,
+                            ClientBase.CONNECTION_TIMEOUT));
+
+        } finally {
+            qlogger.removeAppender(appender);
+        }
+
+        // Verify that Node 1 never threw an exception
+        LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));
+        String line;
+        boolean found = false;
+        Pattern p = Pattern.compile("".*java.lang.NullPointerException.*"");
+        while ((line = r.readLine()) != null) {
+            found = p.matcher(line).matches();
+            if (found) {
+                break;
+            }
+        }
+
+        Assert.assertFalse(""Node should not attempt connection to out of view leader"", found);
+    }
+
+    private String getUniquePortCfgForId(int id) {
+        return String.format(""server.%d=127.0.0.1:%d:%d"", id, PortAssignment.unique(), PortAssignment.unique());
+    }
+
+    private QuorumPeer waitForQuorumPeer(MainThread mainThread, int timeout) {
+        long start = Time.currentElapsedTime();
+        while (true) {
+            QuorumPeer quorumPeer = mainThread.getQuorumPeer();
+            if (quorumPeer != null) {
+                return quorumPeer;
+            }
+
+            if (Time.currentElapsedTime() > start + timeout) {
+                LOG.error(""Timed out while waiting for QuorumPeer"");
+                break;
+            }
+
+            try {
+                Thread.sleep(250);
+            } catch (InterruptedException e) {
+                // ignore
+            }
+        }
+        throw new NullPointerException();","[{'comment': 'Can we use a better exception?', 'commenter': 'afine'}]"
476,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -1012,4 +1012,113 @@ public void testFailedTxnAsPartOfQuorumLoss() throws Exception {
             Assert.assertNull(""server "" + i + "" should not have /zk"" + leader, servers.zk[i].exists(""/zk"" + leader, false));
         }
     }
+
+    /**
+     * Verify that a node without the leader in its view will not attempt to connect to the leader.
+     */
+    @Test
+    public void testLeaderOutOfView() throws Exception {
+        ClientBase.setupTestEnv();
+
+        Layout layout = new PatternLayout(""%d{ISO8601} [,yid:%X{myid}] - %5p [%t:%C{1}@%L] - %m%n"");
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        WriterAppender appender = new WriterAppender(layout, os);
+        appender.setThreshold(Level.DEBUG);
+        Logger qlogger = Logger.getLogger(""org.apache.zookeeper.server.quorum"");
+        qlogger.addAppender(appender);
+
+        try {
+            final int CLIENT_PORT_QP1 = PortAssignment.unique();
+            final int CLIENT_PORT_QP2 = PortAssignment.unique();
+            final int CLIENT_PORT_QP3 = PortAssignment.unique();
+
+            String quorumCfgIncomplete = getUniquePortCfgForId(1) + ""\n"" + getUniquePortCfgForId(2);
+            String quorumCfgComplete = quorumCfgIncomplete + ""\n"" + getUniquePortCfgForId(3);
+
+            // Node 1 is started without the leader (3) in its config view
+            MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgIncomplete);
+            MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgComplete);
+            MainThread q3 = new MainThread(3, CLIENT_PORT_QP3, quorumCfgComplete);
+
+            // Node 1 must be started first, before quorum is formed, to trigger the attempted invalid connection to 3
+            q1.start();
+            QuorumPeer quorumPeer1 = waitForQuorumPeer(q1, CONNECTION_TIMEOUT);
+            Assert.assertTrue(quorumPeer1.getPeerState() == QuorumPeer.ServerState.LOOKING);
+
+            // Node 3 started second to avoid 1 and 2 forming a quorum before 3 starts up
+            q3.start();
+            QuorumPeer quorumPeer3 = waitForQuorumPeer(q3, CONNECTION_TIMEOUT);
+            Assert.assertTrue(quorumPeer3.getPeerState() == QuorumPeer.ServerState.LOOKING);
+
+            // Node 2 started last, kicks off leader election
+            q2.start();
+
+            // Nodes 2 and 3 now form quorum and fully start. 1 attempts to vote for 3, fails, returns to LOOKING state
+            Assert.assertTrue(""waiting for server 2 to start"",
+                    ClientBase.waitForServerUp(""127.0.0.1:"" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));
+            Assert.assertTrue(""waiting for server 3 to start"",
+                    ClientBase.waitForServerUp(""127.0.0.1:"" + CLIENT_PORT_QP3, CONNECTION_TIMEOUT));
+
+            Assert.assertTrue(q1.getQuorumPeer().getPeerState() == QuorumPeer.ServerState.LOOKING);
+            Assert.assertTrue(q2.getQuorumPeer().getPeerState() == QuorumPeer.ServerState.FOLLOWING);
+            Assert.assertTrue(q3.getQuorumPeer().getPeerState() == QuorumPeer.ServerState.LEADING);
+
+            q1.shutdown();
+            q2.shutdown();
+            q3.shutdown();
+
+            Assert.assertTrue(""waiting for server 1 down"",
+                    ClientBase.waitForServerDown(""127.0.0.1:"" + CLIENT_PORT_QP1,
+                            ClientBase.CONNECTION_TIMEOUT));
+            Assert.assertTrue(""waiting for server 2 down"",
+                    ClientBase.waitForServerDown(""127.0.0.1:"" + CLIENT_PORT_QP2,
+                            ClientBase.CONNECTION_TIMEOUT));
+            Assert.assertTrue(""waiting for server 3 down"",
+                    ClientBase.waitForServerDown(""127.0.0.1:"" + CLIENT_PORT_QP3,
+                            ClientBase.CONNECTION_TIMEOUT));
+
+        } finally {
+            qlogger.removeAppender(appender);
+        }
+
+        // Verify that Node 1 never threw an exception
+        LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));
+        String line;
+        boolean found = false;
+        Pattern p = Pattern.compile("".*java.lang.NullPointerException.*"");
+        while ((line = r.readLine()) != null) {
+            found = p.matcher(line).matches();
+            if (found) {
+                break;
+            }
+        }
+
+        Assert.assertFalse(""Node should not attempt connection to out of view leader"", found);
+    }
+
+    private String getUniquePortCfgForId(int id) {
+        return String.format(""server.%d=127.0.0.1:%d:%d"", id, PortAssignment.unique(), PortAssignment.unique());
+    }
+
+    private QuorumPeer waitForQuorumPeer(MainThread mainThread, int timeout) {","[{'comment': 'I believe this has the potential to be flaky since we can return `quorumPeer` before the thread actually starts. We should ensure that the thread started.', 'commenter': 'afine'}]"
476,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -1012,4 +1012,113 @@ public void testFailedTxnAsPartOfQuorumLoss() throws Exception {
             Assert.assertNull(""server "" + i + "" should not have /zk"" + leader, servers.zk[i].exists(""/zk"" + leader, false));
         }
     }
+
+    /**
+     * Verify that a node without the leader in its view will not attempt to connect to the leader.
+     */
+    @Test
+    public void testLeaderOutOfView() throws Exception {
+        ClientBase.setupTestEnv();
+
+        Layout layout = new PatternLayout(""%d{ISO8601} [,yid:%X{myid}] - %5p [%t:%C{1}@%L] - %m%n"");
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        WriterAppender appender = new WriterAppender(layout, os);
+        appender.setThreshold(Level.DEBUG);
+        Logger qlogger = Logger.getLogger(""org.apache.zookeeper.server.quorum"");
+        qlogger.addAppender(appender);
+
+        try {
+            final int CLIENT_PORT_QP1 = PortAssignment.unique();
+            final int CLIENT_PORT_QP2 = PortAssignment.unique();
+            final int CLIENT_PORT_QP3 = PortAssignment.unique();
+
+            String quorumCfgIncomplete = getUniquePortCfgForId(1) + ""\n"" + getUniquePortCfgForId(2);
+            String quorumCfgComplete = quorumCfgIncomplete + ""\n"" + getUniquePortCfgForId(3);
+
+            // Node 1 is started without the leader (3) in its config view
+            MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgIncomplete);
+            MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgComplete);
+            MainThread q3 = new MainThread(3, CLIENT_PORT_QP3, quorumCfgComplete);
+
+            // Node 1 must be started first, before quorum is formed, to trigger the attempted invalid connection to 3
+            q1.start();
+            QuorumPeer quorumPeer1 = waitForQuorumPeer(q1, CONNECTION_TIMEOUT);
+            Assert.assertTrue(quorumPeer1.getPeerState() == QuorumPeer.ServerState.LOOKING);
+
+            // Node 3 started second to avoid 1 and 2 forming a quorum before 3 starts up
+            q3.start();
+            QuorumPeer quorumPeer3 = waitForQuorumPeer(q3, CONNECTION_TIMEOUT);
+            Assert.assertTrue(quorumPeer3.getPeerState() == QuorumPeer.ServerState.LOOKING);
+
+            // Node 2 started last, kicks off leader election
+            q2.start();
+
+            // Nodes 2 and 3 now form quorum and fully start. 1 attempts to vote for 3, fails, returns to LOOKING state
+            Assert.assertTrue(""waiting for server 2 to start"",
+                    ClientBase.waitForServerUp(""127.0.0.1:"" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));
+            Assert.assertTrue(""waiting for server 3 to start"",
+                    ClientBase.waitForServerUp(""127.0.0.1:"" + CLIENT_PORT_QP3, CONNECTION_TIMEOUT));
+
+            Assert.assertTrue(q1.getQuorumPeer().getPeerState() == QuorumPeer.ServerState.LOOKING);
+            Assert.assertTrue(q2.getQuorumPeer().getPeerState() == QuorumPeer.ServerState.FOLLOWING);
+            Assert.assertTrue(q3.getQuorumPeer().getPeerState() == QuorumPeer.ServerState.LEADING);
+
+            q1.shutdown();","[{'comment': 'is there a way we can use the existing tearDown code. So we make sure we never leave any servers running even if an assertion fails?', 'commenter': 'afine'}]"
476,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -1012,4 +1012,113 @@ public void testFailedTxnAsPartOfQuorumLoss() throws Exception {
             Assert.assertNull(""server "" + i + "" should not have /zk"" + leader, servers.zk[i].exists(""/zk"" + leader, false));
         }
     }
+
+    /**
+     * Verify that a node without the leader in its view will not attempt to connect to the leader.
+     */
+    @Test
+    public void testLeaderOutOfView() throws Exception {
+        ClientBase.setupTestEnv();
+
+        Layout layout = new PatternLayout(""%d{ISO8601} [,yid:%X{myid}] - %5p [%t:%C{1}@%L] - %m%n"");
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        WriterAppender appender = new WriterAppender(layout, os);
+        appender.setThreshold(Level.DEBUG);
+        Logger qlogger = Logger.getLogger(""org.apache.zookeeper.server.quorum"");
+        qlogger.addAppender(appender);
+
+        try {
+            final int CLIENT_PORT_QP1 = PortAssignment.unique();
+            final int CLIENT_PORT_QP2 = PortAssignment.unique();
+            final int CLIENT_PORT_QP3 = PortAssignment.unique();
+
+            String quorumCfgIncomplete = getUniquePortCfgForId(1) + ""\n"" + getUniquePortCfgForId(2);
+            String quorumCfgComplete = quorumCfgIncomplete + ""\n"" + getUniquePortCfgForId(3);
+
+            // Node 1 is started without the leader (3) in its config view
+            MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgIncomplete);
+            MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgComplete);
+            MainThread q3 = new MainThread(3, CLIENT_PORT_QP3, quorumCfgComplete);
+
+            // Node 1 must be started first, before quorum is formed, to trigger the attempted invalid connection to 3
+            q1.start();
+            QuorumPeer quorumPeer1 = waitForQuorumPeer(q1, CONNECTION_TIMEOUT);
+            Assert.assertTrue(quorumPeer1.getPeerState() == QuorumPeer.ServerState.LOOKING);
+
+            // Node 3 started second to avoid 1 and 2 forming a quorum before 3 starts up
+            q3.start();
+            QuorumPeer quorumPeer3 = waitForQuorumPeer(q3, CONNECTION_TIMEOUT);
+            Assert.assertTrue(quorumPeer3.getPeerState() == QuorumPeer.ServerState.LOOKING);
+
+            // Node 2 started last, kicks off leader election
+            q2.start();
+
+            // Nodes 2 and 3 now form quorum and fully start. 1 attempts to vote for 3, fails, returns to LOOKING state
+            Assert.assertTrue(""waiting for server 2 to start"",
+                    ClientBase.waitForServerUp(""127.0.0.1:"" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));
+            Assert.assertTrue(""waiting for server 3 to start"",
+                    ClientBase.waitForServerUp(""127.0.0.1:"" + CLIENT_PORT_QP3, CONNECTION_TIMEOUT));
+
+            Assert.assertTrue(q1.getQuorumPeer().getPeerState() == QuorumPeer.ServerState.LOOKING);
+            Assert.assertTrue(q2.getQuorumPeer().getPeerState() == QuorumPeer.ServerState.FOLLOWING);
+            Assert.assertTrue(q3.getQuorumPeer().getPeerState() == QuorumPeer.ServerState.LEADING);
+
+            q1.shutdown();
+            q2.shutdown();
+            q3.shutdown();
+
+            Assert.assertTrue(""waiting for server 1 down"",
+                    ClientBase.waitForServerDown(""127.0.0.1:"" + CLIENT_PORT_QP1,
+                            ClientBase.CONNECTION_TIMEOUT));
+            Assert.assertTrue(""waiting for server 2 down"",
+                    ClientBase.waitForServerDown(""127.0.0.1:"" + CLIENT_PORT_QP2,
+                            ClientBase.CONNECTION_TIMEOUT));
+            Assert.assertTrue(""waiting for server 3 down"",
+                    ClientBase.waitForServerDown(""127.0.0.1:"" + CLIENT_PORT_QP3,
+                            ClientBase.CONNECTION_TIMEOUT));
+
+        } finally {
+            qlogger.removeAppender(appender);
+        }
+
+        // Verify that Node 1 never threw an exception
+        LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));
+        String line;
+        boolean found = false;
+        Pattern p = Pattern.compile("".*java.lang.NullPointerException.*"");","[{'comment': 'It would be great to have a more direct way of expressing that this member never enters the following state. Can we check the logs for `FOLLOWING` like in `testElectionFraud`?', 'commenter': 'afine'}]"
476,src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java,"@@ -927,10 +927,11 @@ public Vote lookForLeader() throws InterruptedException {
                             tmpTimeOut : maxNotificationInterval);
                     LOG.info(""Notification time out: "" + notTimeout);
                 } 
-                else if (self.getCurrentAndNextConfigVoters().contains(n.sid)) {
+                else if (self.getCurrentAndNextConfigVoters().contains(n.sid) &&","[{'comment': ""As this PR modifies this line and add similar ones, wouldn't be the case of creating a private method with a meaningful name like below?\r\n```\r\nprivate boolean configVotersContains(long sid) {\r\n    return self.getCurrentAndNextConfigVoters().contains(sid);\r\n}\r\n```\r\n\r\nThis makes this line and the lines below more readable, imho."", 'commenter': 'eribeiro'}, {'comment': 'There are five uses of `getCurrentAndNextConfigVoters().contains` in the class, seems reasonable to make it a method.', 'commenter': 'enixon'}]"
489,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -222,15 +222,15 @@ static public InitialMessage parse(Long protocolVersion, DataInputStream din)
                         num_read, remaining, sid);
             }
 
-            // FIXME: IPv6 is not supported. Using something like Guava's HostAndPort
-            //        parser would be good.
             String addr = new String(b);
-            String[] host_port = addr.split("":"");
-
-            if (host_port.length != 2) {
-                throw new InitialMessageException(""Badly formed address: %s"", addr);
+            int pos = addr.lastIndexOf("":"");
+           
+            if (pos == -1 || pos + 1  == (addr.length() )) {","[{'comment': 'I think the better way to do this is updating the initiateConnection function to pass in IPv6 literal address ""[%s]:%s"", and here we can use QuorumPeer.splitWithLeadingHostname to check and get IPv6 host and port.', 'commenter': 'lvfangmin'}, {'comment': '1. ""I think the better way to do this is updating the initiateConnection function to pass in IPv6 literal address ""[%s]:%s"" -----pardon me.I don\'t get your idea.\r\n2.""here we can use QuorumPeer.splitWithLeadingHostname to check and get IPv6 host and port.""-----IMHO,we should have a common class in the org.apache.zookeeper.server.util package which just like (HostAndPort#getHostAndPortFromBracketedHost)[https://github.com/google/guava/blob/master/guava/src/com/google/common/net/HostAndPort.java] does,then QuorumPeer.splitWithLeadingHostname , QuorumCnxManager.InitialMessage.parse and others can reuse it.', 'commenter': 'maoling'}, {'comment': ""@maoling I was suggesting to change the ip address format passed in from din to be [xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx]:xxxx instead of the one without '[]', and reuse the splitWithLeadingHostname code."", 'commenter': 'lvfangmin'}]"
492,src/java/main/org/apache/zookeeper/server/ContainerManager.java,"@@ -116,8 +116,8 @@ public void checkContainers()
             Request request = new Request(null, 0, 0,
                     ZooDefs.OpCode.deleteContainer, path, null);
             try {
-                LOG.info(""Attempting to delete candidate container: %s"",
-                        containerPath);
+                LOG.info(String.format(""Attempting to delete candidate container: %s"",","[{'comment': 'As this a log message you could use \r\n`LOG.info(""Attempting to delete candidate container: {}"", container Path);`', 'commenter': 'eribeiro'}, {'comment': 'to use the same logging style as the other code.\r\n\r\n                LOG.error(String.format(""Could not delete container: %s"" ,\r\n                        containerPath), e);', 'commenter': 'sel-fish'}, {'comment': '+1 for @eribeiro \r\nWe already use that form at various places in the codebase, so feel free to use the better one. Existing String.formats should be refactored in the long term, but that probably will happen in small refactorings like this.', 'commenter': 'anmolnar'}]"
495,src/java/main/org/apache/zookeeper/server/ReferenceCountedACLCache.java,"@@ -109,16 +109,18 @@ public synchronized void deserialize(InputArchive ia) throws IOException {
             }
             List<ACL> aclList = new ArrayList<ACL>();
             Index j = ia.startVector(""acls"");
-            while (!j.done()) {
-                ACL acl = new ACL();
-                acl.deserialize(ia, ""acl"");
-                aclList.add(acl);
-                j.incr();
+            if (j != null) {","[{'comment': '- can we have a more elegant way to process this NPE ?\r\n- BTW. incorrect commit message.   `git commit --amend -m ""your new message""` to modify it', 'commenter': 'maoling'}, {'comment': 'just as @anmolnar  review, we should throw exception if j == null, so add code just like \r\n\r\nif (j == null){\r\n    throw Exception(error_message);\r\n}\r\n@maoling can this change be elegant? \r\n', 'commenter': 'lujiefsi'}]"
495,src/java/main/org/apache/zookeeper/server/ReferenceCountedACLCache.java,"@@ -109,16 +109,18 @@ public synchronized void deserialize(InputArchive ia) throws IOException {
             }
             List<ACL> aclList = new ArrayList<ACL>();
             Index j = ia.startVector(""acls"");
-            while (!j.done()) {
-                ACL acl = new ACL();
-                acl.deserialize(ia, ""acl"");
-                aclList.add(acl);
-                j.incr();
+            if (j != null) {
+                while (!j.done()) {
+                    ACL acl = new ACL();
+                    acl.deserialize(ia, ""acl"");
+                    aclList.add(acl);
+                    j.incr();
+                }
+                longKeyMap.put(val, aclList);","[{'comment': 'Can we move code at line 119~123 out of null-checker, because it may cause endless loop due to i > 0 may always hold', 'commenter': 'lujiefsi'}, {'comment': '+1 \r\nOnly the inner while-loop uses the `j` variable, so nothing else should be inside the check.', 'commenter': 'anmolnar'}]"
495,src/java/main/org/apache/zookeeper/server/ReferenceCountedACLCache.java,"@@ -109,6 +109,10 @@ public synchronized void deserialize(InputArchive ia) throws IOException {
             }
             List<ACL> aclList = new ArrayList<ACL>();
             Index j = ia.startVector(""acls"");
+            if (j == null) {
+                LOG.error(""ERROR: incorrent format of InputArchive"" + ia);","[{'comment': 'You don\'t need an ERROR in the text here or on the next line. It\'s already LOG\'d as an error. Same for the next line - it\'s a RTE.\r\n\r\nAlso you need a space  ""... of InputArchive"" -> "".... of InputArchive "" (notice space at the end. Otw the text of ia is just appended w/o the space. Also notice that ia doesn\'t have a toString, so I\'m not sure how helpful that is.... it\'s fine to leave I guess.', 'commenter': 'phunt'}]"
500,src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java,"@@ -245,6 +245,180 @@ public void testLastAcceptedEpoch() throws Exception {
             recursiveDelete(tmpDir);
         }
     }
+
+    @Test
+    public void testGetEpochToProposeWithObserver() throws Exception {
+        File tmpDir = File.createTempFile(""test"", ""dir"", testData);","[{'comment': 'Have you considered using ClientBase.createEmptyTestDir() instead?', 'commenter': 'anmolnar'}, {'comment': 'Refactored', 'commenter': 'lavacat'}]"
500,src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java,"@@ -245,6 +245,180 @@ public void testLastAcceptedEpoch() throws Exception {
             recursiveDelete(tmpDir);
         }
     }
+
+    @Test
+    public void testGetEpochToProposeWithObserver() throws Exception {
+        File tmpDir = File.createTempFile(""test"", ""dir"", testData);
+        tmpDir.delete();
+        tmpDir.mkdir();
+        Leader leader = null;
+        try {
+            QuorumPeer peer = createQuorumPeer(tmpDir);
+            long participantId = 1;
+            long observerId = peer.quorumPeers.size();
+            peer.quorumPeers.put(observerId, new QuorumServer(observerId, ""0.0.0.0"", 33225,","[{'comment': 'I think to be consistent with `createQuorumPeer()` method this should be something like:\r\n```\r\npeers.put(observerId, new QuorumServer(observerId, new InetSocketAddress(""127.0.0.1"", PortAssignment.unique()), \r\n               new InetSocketAddress(""127.0.0.1"", PortAssignment.unique()),\r\n               new InetSocketAddress(""127.0.0.1"", PortAssignment.unique()),\r\n               QuorumPeer.LearnerType.OBSERVER));\r\n```\r\n', 'commenter': 'anmolnar'}, {'comment': 'Do you mean using PortAssignment.unique() and ""127.0.0.1""? Changed it.', 'commenter': 'lavacat'}]"
500,src/java/test/org/apache/zookeeper/server/quorum/ZabUtils.java,"@@ -0,0 +1,140 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.server.ServerCnxn;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.apache.zookeeper.server.ZKDatabase;
+import org.apache.zookeeper.server.ZooKeeperServer;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.net.InetSocketAddress;
+import java.util.HashMap;
+
+public class ZabUtils {
+    public static final int SYNC_LIMIT = 2;
+","[{'comment': 'If this is a helper class that doesn\'t require instantiation then create a private constructor: this makes it ""final"" and prevents instantiation.', 'commenter': 'eribeiro'}]"
500,src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java,"@@ -161,8 +127,8 @@ public void testLeaderInConnectingFollowers() throws Exception {
         tmpDir.mkdir();
         Leader leader = null;
         try {
-            QuorumPeer peer = createQuorumPeer(tmpDir);
-            leader = createLeader(tmpDir, peer);
+            QuorumPeer peer = ZabUtils.createQuorumPeer(tmpDir);","[{'comment': '`import static org.apache.zookeeper.server.quorum. ZabUtil.*` then you can simplify method invocation by using `createQuorumPeer(tmpDir);` instead of `ZabUtils.createQuorumPeer(tmpDir);`', 'commenter': 'eribeiro'}, {'comment': ""Agreed, but please don't use asterisk (*) import. We avoid wildcard imports in Zk project."", 'commenter': 'anmolnar'}, {'comment': 'Yup, you right. Sorry about that. :)', 'commenter': 'edwardoliveira'}]"
500,src/java/main/org/apache/zookeeper/server/quorum/Leader.java,"@@ -900,9 +902,10 @@ public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws Interrupt
             return epoch;
         }
     }
-
-    private HashSet<Long> electingFollowers = new HashSet<Long>();
-    private boolean electionFinished = false;
+    // VisibleForTesting
+    protected HashSet<Long> electingFollowers = new HashSet<Long>();","[{'comment': '`protected Set<Long> electingFollowers = new HashSet<>()`', 'commenter': 'eribeiro'}, {'comment': ""Can't use Set, because QuorumVerifier uses HashSet param. \r\nQuorumVerifier.containsQuorum(HashSet<Long> set);\r\n\r\nI can refactor it all, but then I'll need to touch QuorumVerifier.java, QuorumMaj.java and QuorumHierarchical.java"", 'commenter': 'lavacat'}, {'comment': 'updated', 'commenter': 'lavacat'}]"
500,src/java/main/org/apache/zookeeper/server/quorum/Leader.java,"@@ -868,8 +868,8 @@ synchronized public long startForwarding(LearnerHandler handler,
                 
         return lastProposed;
     }
-
-    private HashSet<Long> connectingFollowers = new HashSet<Long>();
+    // VisibleForTesting
+    protected HashSet<Long> connectingFollowers = new HashSet<Long>();","[{'comment': '`protected Set<Long> connectingFollowers = new HashSet<>();`\r\n\r\nThis kind of change is more important since we are making the field more visible.\r\n\r\n', 'commenter': 'eribeiro'}]"
500,src/java/test/org/apache/zookeeper/server/quorum/ZabUtils.java,"@@ -0,0 +1,140 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.server.ServerCnxn;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.apache.zookeeper.server.ZKDatabase;
+import org.apache.zookeeper.server.ZooKeeperServer;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.net.InetSocketAddress;
+import java.util.HashMap;
+
+public class ZabUtils {
+    public static final int SYNC_LIMIT = 2;
+
+    public static QuorumPeer createQuorumPeer(File tmpDir) throws IOException{
+        QuorumPeer peer = new QuorumPeer();
+        peer.syncLimit = 2;
+        peer.initLimit = 2;
+        peer.tickTime = 2000;
+        peer.quorumPeers = new HashMap<Long, QuorumPeer.QuorumServer>();
+        peer.quorumPeers.put(0L, new QuorumPeer.QuorumServer(0, ""127.0.0.1"", PortAssignment.unique(), 0, null));
+        peer.quorumPeers.put(1L, new QuorumPeer.QuorumServer(1, ""127.0.0.1"", PortAssignment.unique(), 0, null));
+        peer.quorumPeers.put(2L, new QuorumPeer.QuorumServer(2, ""127.0.0.1"", PortAssignment.unique(), 0, null));
+        peer.setQuorumVerifier(new QuorumMaj(peer.quorumPeers.size()));
+        peer.setCnxnFactory(new NullServerCnxnFactory());
+        File version2 = new File(tmpDir, ""version-2"");
+        version2.mkdir();
+        FileOutputStream fos;
+        fos = new FileOutputStream(new File(version2, ""currentEpoch""));","[{'comment': 'Could join lines 52 and 53.', 'commenter': 'eribeiro'}]"
500,src/java/test/org/apache/zookeeper/server/quorum/ZabUtils.java,"@@ -0,0 +1,140 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.server.ServerCnxn;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.apache.zookeeper.server.ZKDatabase;
+import org.apache.zookeeper.server.ZooKeeperServer;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.net.InetSocketAddress;
+import java.util.HashMap;
+
+public class ZabUtils {
+    public static final int SYNC_LIMIT = 2;
+
+    public static QuorumPeer createQuorumPeer(File tmpDir) throws IOException{
+        QuorumPeer peer = new QuorumPeer();
+        peer.syncLimit = 2;
+        peer.initLimit = 2;
+        peer.tickTime = 2000;
+        peer.quorumPeers = new HashMap<Long, QuorumPeer.QuorumServer>();
+        peer.quorumPeers.put(0L, new QuorumPeer.QuorumServer(0, ""127.0.0.1"", PortAssignment.unique(), 0, null));
+        peer.quorumPeers.put(1L, new QuorumPeer.QuorumServer(1, ""127.0.0.1"", PortAssignment.unique(), 0, null));
+        peer.quorumPeers.put(2L, new QuorumPeer.QuorumServer(2, ""127.0.0.1"", PortAssignment.unique(), 0, null));
+        peer.setQuorumVerifier(new QuorumMaj(peer.quorumPeers.size()));
+        peer.setCnxnFactory(new NullServerCnxnFactory());
+        File version2 = new File(tmpDir, ""version-2"");
+        version2.mkdir();
+        FileOutputStream fos;
+        fos = new FileOutputStream(new File(version2, ""currentEpoch""));
+        fos.write(""0\n"".getBytes());
+        fos.close();
+        fos = new FileOutputStream(new File(version2, ""acceptedEpoch""));
+        fos.write(""0\n"".getBytes());
+        fos.close();
+        return peer;
+    }
+
+    public static Leader createLeader(File tmpDir, QuorumPeer peer)
+            throws IOException, NoSuchFieldException, IllegalAccessException{
+        LeaderZooKeeperServer zk = prepareLeader(tmpDir, peer);
+        return new Leader(peer, zk);
+    }
+
+    public static MockLeader createMockLeader(File tmpDir, QuorumPeer peer)
+            throws IOException, NoSuchFieldException, IllegalAccessException{
+        LeaderZooKeeperServer zk = prepareLeader(tmpDir, peer);
+        return new MockLeader(peer, zk);
+    }
+
+    private static LeaderZooKeeperServer prepareLeader(File tmpDir, QuorumPeer peer)
+            throws IOException, NoSuchFieldException, IllegalAccessException {
+        FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);
+        peer.setTxnFactory(logFactory);
+        Field addrField = peer.getClass().getDeclaredField(""myQuorumAddr"");
+        addrField.setAccessible(true);
+        addrField.set(peer, new InetSocketAddress(PortAssignment.unique()));
+        ZKDatabase zkDb = new ZKDatabase(logFactory);
+        return new LeaderZooKeeperServer(logFactory, peer, new ZooKeeperServer.BasicDataTreeBuilder(), zkDb);
+    }
+
+    private static final class NullServerCnxnFactory extends ServerCnxnFactory {
+        public void startup(ZooKeeperServer zkServer) throws IOException,
+                InterruptedException {
+        }
+        public void start() {
+        }
+        public void shutdown() {
+        }
+        public void setMaxClientCnxnsPerHost(int max) {
+        }
+        public void join() throws InterruptedException {
+        }
+        public int getMaxClientCnxnsPerHost() {
+            return 0;
+        }
+        public int getLocalPort() {
+            return 0;
+        }
+        public InetSocketAddress getLocalAddress() {
+            return null;
+        }
+        public Iterable<ServerCnxn> getConnections() {
+            return null;
+        }
+        public void configure(InetSocketAddress addr, int maxClientCnxns)
+                throws IOException {
+        }
+        public void closeSession(long sessionId) {
+        }
+        public void closeAll() {
+        }
+        @Override
+        public int getNumAliveConnections() {
+            return 0;
+        }
+    }
+
+    static final class MockLeader extends Leader {","[{'comment': '`private` ?', 'commenter': 'eribeiro'}, {'comment': ""Can't make it private, this class is still used in Zab1_0Test"", 'commenter': 'lavacat'}]"
500,src/java/main/org/apache/zookeeper/server/quorum/Leader.java,"@@ -916,7 +919,9 @@ public void waitForEpochAck(long id, StateSummary ss) throws IOException, Interr
                                                     + leaderStateSummary.getLastZxid()
                                                     + "" (last zxid)"");
                 }
-                electingFollowers.add(id);
+                if (self.getVotingView().containsKey(id)) {","[{'comment': 'I would suggest to encapsulate the `self.getVotingView().containsKey(id)` into a private method as below, if nothing else, for the sake of readability\r\n\r\n```\r\nprivate boolean isParticipant(long sid) {\r\n   return self.getVotingView().containsKey(id);\r\n}\r\n```', 'commenter': 'eribeiro'}]"
501,src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -146,6 +149,16 @@ public FileTxnLog(File logDir) {
         this.logDir = logDir;
     }
 
+    /**
+     * constructor for FileTxnLog. Take the directory
+     * where the txnlogs are stored
+     * @param logDir the directory where the txnlogs are stored","[{'comment': 'Description for `serverStats` param is missing.', 'commenter': 'anmolnar'}]"
501,src/java/main/org/apache/zookeeper/server/ServerStats.java,"@@ -32,6 +32,7 @@
     private long minLatency = Long.MAX_VALUE;
     private long totalLatency = 0;
     private long count = 0;
+    private long fsyncThresholdExceedCount = 0L;","[{'comment': 'What do you think about using `AtomicLong` instead of synchronising every access?', 'commenter': 'anmolnar'}, {'comment': 'Which would also remove the overhead imposed by synchronised. Thanks for the tip, i will make the changes!', 'commenter': 'nkalmar'}]"
501,src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -30,10 +30,8 @@
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.KeeperException.Code;
 import org.apache.zookeeper.ZooDefs.OpCode;
-import org.apache.zookeeper.server.DataTree;
+import org.apache.zookeeper.server.*;","[{'comment': 'We prefer to explicitly inform the imports instead of using wildcards.', 'commenter': 'edwardoliveira'}]"
501,src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -55,6 +53,7 @@
     private final File snapDir;
     private TxnLog txnLog;
     private SnapShot snapLog;
+    private ServerStats serverStats;","[{'comment': '`final`?', 'commenter': 'edwardoliveira'}, {'comment': 'Maybe I am missing something pretty obvious here, but it seems that `serverStats` is passed to `FileTxnLog`, but there is no place in this class where it passes `serverStats` to `FileTxnLog`. ', 'commenter': 'edwardoliveira'}, {'comment': ""No, you're not missing anything, I messed up the refactor before the commit. I've written more unit tests so this will not go unnoticed next time. Will commit soon.\r\n\r\nThanks!"", 'commenter': 'nkalmar'}]"
501,docs/zookeeperAdmin.html,"@@ -2213,6 +2213,7 @@ <h4>The Four Letter Words</h4>
               zk_min_latency  0
               zk_packets_received 70
               zk_packets_sent 69
+              zk_num_alive_connections	1","[{'comment': 'Please remove doc/{html,pdf} files from PRs - these files are regenerated during commit time by the committer. (and are a pain to manage wrt the PR merge tool)', 'commenter': 'phunt'}]"
501,src/java/test/org/apache/zookeeper/test/FourLetterWordsTest.java,"@@ -167,6 +167,8 @@ public void testValidateStatOutput() throws Exception {
         line = in.readLine();
         Assert.assertTrue(Pattern.matches(""^Mode: .*$"", line));
         line = in.readLine();
+        Assert.assertTrue(Pattern.matches(""^Fsync threshold exceeded: \\d+$"", line));","[{'comment': ""any chance we can add this to the very end of the output? We weren't very clear on order and in some cases existing monitoring may be expecting the original order. Appending helps wrt b/w compat."", 'commenter': 'phunt'}, {'comment': 'Well, it can be achieved, but needs some extra functions in ServerStats:\r\n-toStringWithoutFsync() (name is not final :) )\r\n\r\nBecause StatCommand first calls serverStats.toString(), and in serverStats, new Fsync command is already at the end. But in the commandRun() in StatCommand, the Node count is appended after the whole serverStats.toString() call.\r\n\r\nLike this:\r\n            pw.print(serverStats.toString());\r\n            pw.print(""Node count: "");\r\n            pw.println(zkServer.getZKDatabase().getNodeCount());\r\n\r\nBut then every future stat added to ServerStats has to manually add the print to StatCommand.\r\n\r\nIs this OK with you @phunt ?', 'commenter': 'nkalmar'}, {'comment': ""That's pretty ugly, esp. if there are changes in the future.\r\n\r\nHere's another idea instead: given the Monitor command is available since 3.4.0 and handles (documented) such changes correctly perhaps we should just add this to monitor and not add it to stat. If a user wants the additional information they can use mntr instead.\r\n\r\nWhat do you think @nkalmar ?\r\n\r\nThe other benefit is that it will integrate into 3.4 more easily - i.e. fully b/w compat w/o any worries."", 'commenter': 'phunt'}, {'comment': ""Yes, it would have been an ugly solution, that's why I didn't go ahead with it.\r\nOkay, sounds good to me, I will make the changes.\r\n\r\nThanks!"", 'commenter': 'nkalmar'}]"
501,src/contrib/monitoring/check_zookeeper.py,"@@ -256,6 +261,36 @@ def _parse_stat(self, data):
                 result['zk_znode_count'] = int(m.group(1))
                 continue
 
+            m = re.match('Watch count: (\d+)', line)
+            if m is not None:
+                result['zk_watch_count'] = int(m.group(1))
+                continue
+
+            m = re.match('Ephemerals count: (\d+)', line)
+            if m is not None:
+                result['zk_ephemerals_count'] = int(m.group(1))
+                continue
+
+            m = re.match('Approximate data size: (\d+)', line)
+            if m is not None:
+                result['zk_approximate_data_size'] = int(m.group(1))
+                continue
+
+            m = re.match('Open file descriptor count: (\d+)', line)
+            if m is not None:
+                result['zk_open_file_descriptor_count'] = int(m.group(1))
+                continue
+
+            m = re.match('Max file descriptor count: (\d+)', line)
+            if m is not None:
+                result['zk_max_file_descriptor_count'] = int(m.group(1))
+                continue
+
+            m = re.match('Fsync threshold exceeded: (\d+)', line)","[{'comment': ""You might need to check the supporting scripts - I don't believe this is output any longer, right?"", 'commenter': 'phunt'}, {'comment': 'Yes, thats for stat command, thanks. I changed it and tested the py scripts, looks good now.', 'commenter': 'nkalmar'}]"
501,src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -311,6 +325,9 @@ public synchronized void commit() throws IOException {
 
                 syncElapsedMS = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startSyncNS);
                 if (syncElapsedMS > fsyncWarningThresholdMS) {
+                    if(serverStats != null) {
+                        serverStats.incrementFsyncThresholdExceedCount();
+                    }","[{'comment': ""@nkalmar I wonder if we could add an 'else' branch here with a `LOG.warn()` message indicating that something had gone wrong and Zk was unable to track fsync warnings. What do you think?"", 'commenter': 'anmolnar'}, {'comment': ""We could, sure. This nullcheck is just an extra fail safe measurement. It should be never null actually, so if it is, that's definitely some error. (If it would be possible, serverStats would come from constructor actually)."", 'commenter': 'nkalmar'}]"
520,build.xml,"@@ -23,6 +23,8 @@ xmlns:artifact=""antlib:org.apache.maven.artifact.ant""
 xmlns:maven=""antlib:org.apache.maven.artifact.ant""
 xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle"">
 
+    <property name=""clover.version"" value=""4.2.1"" />","[{'comment': 'The ""Dependency versions"" section is around line 207 in build.xml. Would you please move the clover version there for consistency?\r\n\r\nYou might also need to move the entire section here, because of some chicken-egg problem mentioned in the original patch.', 'commenter': 'anmolnar'}]"
523,src/java/test/org/apache/zookeeper/server/quorum/StandaloneDisabledTest.java,"@@ -179,6 +180,8 @@ private void startServer(int id, String config) throws Exception {
         zkHandles[id] = ClientBase.createZKClient(""127.0.0.1:"" + clientPorts[id]);
         zkAdminHandles[id] = new ZooKeeperAdmin(""127.0.0.1:"" + clientPorts[id], CONNECTION_TIMEOUT, this);
         zkAdminHandles[id].addAuthInfo(""digest"", ""super:test"".getBytes());
+        LOG.info(String.format(""Started server id %d with config:\n%s\nStat output:\n%s"",
+                id, config, FourLetterWordMain.send4LetterWord(""127.0.0.1"", clientPorts[id], ""stat"")));","[{'comment': ""Can you separate out the 4lw call onto it's own line?"", 'commenter': 'phunt'}]"
524,build.xml,"@@ -55,8 +55,8 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
     <property name=""jackson-mapper-asl.version"" value=""1.9.11""/>
     <property name=""dependency-check-ant.version"" value=""2.1.0""/>
 
-    <property name=""commons-io.version"" value=""2.4""/>
-    <property name=""kerby.version"" value=""1.0.0-RC2""/>
+    <property name=""commons-io.version"" value=""2.5""/>","[{'comment': '2.6 is available - why not update to that?', 'commenter': 'phunt'}, {'comment': 'It is the only requirement for Kerby. Will update to 2.6', 'commenter': 'eolivelli'}]"
524,build.xml,"@@ -55,8 +55,8 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
     <property name=""jackson-mapper-asl.version"" value=""1.9.11""/>
     <property name=""dependency-check-ant.version"" value=""2.1.0""/>
 
-    <property name=""commons-io.version"" value=""2.4""/>
-    <property name=""kerby.version"" value=""1.0.0-RC2""/>
+    <property name=""commons-io.version"" value=""2.5""/>
+    <property name=""kerby.version"" value=""1.0.0""/>","[{'comment': '1.1.0 is available - why not update to that?', 'commenter': 'phunt'}, {'comment': 'Because it is not available for all submodules of Kerby, it would make the patch more complex.\r\n', 'commenter': 'eolivelli'}, {'comment': 'I will try again to update to 1.1.0', 'commenter': 'eolivelli'}, {'comment': 'Changing to 1.1.0 worked for me - it compiled and the tests ran. Is there something else?\r\n\r\nI did try 1.1.1 but that had the issue you mentioned.', 'commenter': 'phunt'}]"
529,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -1260,10 +1260,8 @@ public void run() {
                 cleanup();
             }
             clientCnxnSocket.close();
-            if (state.isAlive()) {
-                eventThread.queueEvent(new WatchedEvent(Event.EventType.None,
-                        Event.KeeperState.Disconnected, null));
-            }
+            eventThread.queueEvent(new WatchedEvent(Event.EventType.None,
+                        Event.KeeperState.Closed, null));","[{'comment': ""I'd expect the client to always receive a Disconnected state before receiving a Closed state and it looks like that constraint is not enforced. "", 'commenter': 'enixon'}, {'comment': 'Good catch - in the previous version of this patch the terminal event re-used the disconnected state for closing (hence removing the if check. Now that we have a Closed event the Disconnected event should still be sent if the client is connected at the time of the close.', 'commenter': 'timothyjward'}]"
529,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -1438,6 +1436,11 @@ public void disconnect() {
         }
 
         sendThread.close();
+        try {
+            sendThread.join();
+        } catch (InterruptedException ex) {
+            LOG.warn(""Got interrupted while waiting for the sender thread to close"", ex);
+        }
         eventThread.queueEventOfDeath();","[{'comment': 'Any gains/problems with moving the queueEventOfDeath above the join()?', 'commenter': 'enixon'}, {'comment': ""If the `queueEventOfDeath` call moves above the `join` call then some events can be missed. \r\n\r\nSpecifically closing the connection's eventOfDeath can be processed before completing the send of the session disconnection message triggered in disconnect. \r\n\r\nI tried moving the queueEventOfDeath above the join, but then some of the core tests began failing intermittently. This was remedied by moving the eventOfDeath back after the completion of the send thread."", 'commenter': 'timothyjward'}, {'comment': 'Sounds good to me - thanks for running the experiment!', 'commenter': 'enixon'}]"
529,src/java/main/org/apache/zookeeper/Watcher.java,"@@ -84,7 +84,14 @@
              * client connection (the session) is no longer valid. You must
              * create a new client connection (instantiate a new ZooKeeper
              * instance) if you with to access the ensemble. */
-            Expired (-112);
+            Expired (-112),
+            
+            /** 
+             * The client has been closed. This state is never generated by
+             * the server, but is generated locally when a client calls
+             * {@link ZooKeeper#close()} or {@link ZooKeeper#close(int)}
+             */
+            Closed (-2);","[{'comment': 'Nit - make the enum value 7?', 'commenter': 'enixon'}, {'comment': ""My understanding was that a negative value would be preferred for an event which didn't originate from the server, but I don't mind changing it."", 'commenter': 'timothyjward'}]"
529,src/java/test/org/apache/zookeeper/test/WatcherTest.java,"@@ -140,6 +142,55 @@ public void processResult(int rc, String path, Object ctx) {
             }
         }
     }
+    
+    @Test
+    public void testWatcherDisconnectOnClose() 
+        throws IOException, InterruptedException, KeeperException 
+    {
+        ZooKeeper zk = null;
+        try {
+            final BlockingQueue<WatchedEvent> queue = new LinkedBlockingQueue<>();
+            
+            MyWatcher connWatcher = new MyWatcher();
+            
+            Watcher watcher = new Watcher(){
+                @Override
+                public void process(WatchedEvent event) {
+                    try {
+                        queue.put(event);
+                    } catch (InterruptedException e) {
+                        // Oh well, never mind
+                    }
+                }
+                
+            };
+            
+            zk = createClient(connWatcher, hostPort);
+    
+            StatCallback scb = new StatCallback() {
+                public void processResult(int rc, String path, Object ctx,
+                        Stat stat) {
+                    // don't do anything
+                }
+            };
+            
+            // Register a watch on the node
+            zk.exists(""/missing"", watcher, scb, null);
+            
+            // Close the client without changing the node
+            zk.close();
+            
+            
+            WatchedEvent event = queue.poll(10, TimeUnit.SECONDS);
+            Assert.assertEquals(Event.EventType.None, event.getType());","[{'comment': ""When your patch isn't applied, the watcher won't receive any event and timeout occurs. Resulting in `event == null` and test will get NullReferenceException. Would you please assert for null ref and also add some meaningful messages to the assert statements which indicate what exactly went wrong and what should be the expected behaviour."", 'commenter': 'anmolnar'}, {'comment': ""I've pushed updated assertions containing more human readable text. "", 'commenter': 'timothyjward'}]"
530,src/java/main/org/apache/zookeeper/ZooKeeper.java,"@@ -1218,6 +1294,79 @@ public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,
                 canBeReadOnly, createDefaultHostProvider(connectString));
     }
 
+    /**
+     * To create a ZooKeeper client object, the application needs to pass a
+     * connection string containing a comma separated list of host:port pairs,
+     * each corresponding to a ZooKeeper server.
+     * <p>
+     * Session establishment is asynchronous. This constructor will initiate
+     * connection to the server and return immediately - potentially (usually)
+     * before the session is fully established. The watcher argument specifies
+     * the watcher that will be notified of any changes in state. This
+     * notification can come at any point before or after the constructor call
+     * has returned.
+     * <p>
+     * The instantiated ZooKeeper client object will pick an arbitrary server
+     * from the connectString and attempt to connect to it. If establishment of
+     * the connection fails, another server in the connect string will be tried
+     * (the order is non-deterministic, as we random shuffle the list), until a
+     * connection is established. The client will continue attempts until the
+     * session is explicitly closed (or the session is expired by the server).
+     * <p>
+     * Added in 3.2.0: An optional ""chroot"" suffix may also be appended to the
+     * connection string. This will run the client commands while interpreting
+     * all paths relative to this root (similar to the unix chroot command).
+     * <p>
+     * Use {@link #getSessionId} and {@link #getSessionPasswd} on an established
+     * client connection, these values must be passed as sessionId and
+     * sessionPasswd respectively if reconnecting. Otherwise, if not
+     * reconnecting, use the other constructor which does not require these
+     * parameters.
+     * <p>
+     * This constructor uses a StaticHostProvider; there is another one  
+     * to enable custom behaviour.
+     *
+     * @param connectString
+     *            comma separated host:port pairs, each corresponding to a zk
+     *            server. e.g. ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002""
+     *            If the optional chroot suffix is used the example would look
+     *            like: ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a""
+     *            where the client would be rooted at ""/app/a"" and all paths
+     *            would be relative to this root - ie getting/setting/etc...
+     *            ""/foo/bar"" would result in operations being run on
+     *            ""/app/a/foo/bar"" (from the server perspective).
+     * @param sessionTimeout
+     *            session timeout in milliseconds
+     * @param watcher
+     *            a watcher object which will be notified of state changes, may
+     *            also be notified for node events
+     * @param sessionId
+     *            specific session id to use if reconnecting
+     * @param sessionPasswd
+     *            password for this session
+     * @param canBeReadOnly
+     *            (added in 3.4) whether the created client is allowed to go to
+     *            read-only mode in case of partitioning. Read-only mode
+     *            basically means that if the client can't find any majority
+     *            servers but there's partitioned server it could reach, it
+     *            connects to one in read-only mode, i.e. read requests are
+     *            allowed while write requests are not. It continues seeking for
+     *            majority in the background.
+     * @param conf
+     *            (added in 3.5.2) passing this conf object gives each client the flexibility of
+     *            configuring properties differently compared to other instances
+     * @throws IOException in cases of network failure
+     * @throws IllegalArgumentException if an invalid chroot path is specified
+     */
+    public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,
+    		long sessionId, byte[] sessionPasswd, boolean canBeReadOnly, ZKClientConfig conf)
+    				throws IOException {
+    	this(connectString, sessionTimeout, watcher, sessionId, sessionPasswd,
+    			canBeReadOnly, createDefaultHostProvider(connectString));
+    }
+    
+    
+
     // default hostprovider
     private static HostProvider createDefaultHostProvider(String connectString) {
         return new StaticHostProvider(","[{'comment': '@timothyjward  +l,LGTM\r\nneed a Unit Test,some inspirations can be found at the [old-patch](https://issues.apache.org/jira/secure/attachment/12822755/ZOOKEEPER-2474-01.patch) which  may be better to add `newZKClient.close()  ` in the last line', 'commenter': 'maoling'}]"
533,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -222,15 +222,15 @@ static public InitialMessage parse(Long protocolVersion, DataInputStream din)
                         num_read, remaining, sid);
             }
 
-            // FIXME: IPv6 is not supported. Using something like Guava's HostAndPort
-            //        parser would be good.
             String addr = new String(b);
-            String[] host_port = addr.split("":"");
-
-            if (host_port.length != 2) {
-                throw new InitialMessageException(""Badly formed address: %s"", addr);
+            int pos = addr.lastIndexOf("":"");
+           ","[{'comment': ""- look at this [SO](https://stackoverflow.com/questions/2345063/java-common-way-to-validate-and-convert-hostport-to-inetsocketaddress),I'm afraid something like `[2001:db8:85a3::8a2e:370:7334]:80` will fail\r\n- I will test this patch in the real IPv6 production ENV in case of something I miss.\r\n"", 'commenter': 'maoling'}]"
534,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -73,15 +80,27 @@
      *             if serverAddresses is empty or resolves to an empty list
      */
     public StaticHostProvider(Collection<InetSocketAddress> serverAddresses) {
-       sourceOfRandomness = new Random(System.currentTimeMillis() ^ this.hashCode());
+        init(serverAddresses,","[{'comment': 'Nit: Call StaticHostProvider(Collection<InetSocketAddress> serverAddresses, Resolver resolver).\r\n\r\nPlease change the other two constructor as well.', 'commenter': 'lvfangmin'}, {'comment': 'Sorry @lvfangmin , I might be missing the point here. Shall I change the signature to use non-generic Collection?', 'commenter': 'anmolnar'}, {'comment': 'I think what @lvfangmin meant is instead of duplicating the code inside three constructors, only keep one concrete parameterized constructor implementation and let the other two invoke that one (with different parameters.).', 'commenter': 'hanm'}, {'comment': 'What @hanm said, instead of call init, call this.', 'commenter': 'lvfangmin'}, {'comment': 'Tried that. Cannot call the other constructor, because `this` is referenced.', 'commenter': 'anmolnar'}, {'comment': ""Yeah, I think referencing this before the object is constructed is prohibited. I think we can probably get around it but it looks like not worth the extra effort (I don't know a simple of way of doing it without dropping using the this.hashCode). \r\nSo I am ok with the current form of having all ctors invoking init method.\r\n"", 'commenter': 'hanm'}]"
534,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -314,7 +340,7 @@ public InetSocketAddress next(long spinDelay) {
                 addr = nextHostInReconfigMode();
                 if (addr != null) {
                 	currentIndex = serverAddresses.indexOf(addr);
-                	return addr;                
+                	return resolve(addr);","[{'comment': ""Can you do some test to find out performance/latency of resolving an addr? If it's costly, maybe we should cache the resolved one instead of resolve it every time."", 'commenter': 'lvfangmin'}, {'comment': ""I disagree. We should not do any caching in our codebase, because there're multiple levels of caching already present in DNS infrastructure, like JVM caching, os-level caching, DNS servers caching, etc. `resolve()` will eventually become a no-op if any of these caches find a hit."", 'commenter': 'anmolnar'}, {'comment': 'I know there is DNS caching, not aware that we have JVM or os caching for this, if we tested this is trivial, I totally agree we should keep this simple.', 'commenter': 'lvfangmin'}, {'comment': ""IMHO JVM caching is overkill too. It's not application's responsibility to deal with DNS re-resolution, because it shouldn't happen in failure scenarios only. On the flipside to avoid DNS server flooding some caching in the app would be reasonable and JVM is a standard way of doing that."", 'commenter': 'anmolnar'}]"
534,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -96,36 +115,46 @@ public StaticHostProvider(Collection<InetSocketAddress> serverAddresses) {
      */
     public StaticHostProvider(Collection<InetSocketAddress> serverAddresses,
         long randomnessSeed) {
-        sourceOfRandomness = new Random(randomnessSeed);
+        init(serverAddresses, randomnessSeed, new Resolver() {
+            @Override
+            public InetAddress[] getAllByName(String name) throws UnknownHostException {
+                return InetAddress.getAllByName(name);
+            }
+        });
+    }
 
-        this.serverAddresses = resolveAndShuffle(serverAddresses);
-        if (this.serverAddresses.isEmpty()) {
+    private void init(Collection<InetSocketAddress> serverAddresses, long randomnessSeed, Resolver resolver) {
+        this.sourceOfRandomness = new Random(randomnessSeed);
+        this.resolver = resolver;
+        if (serverAddresses.isEmpty()) {
             throw new IllegalArgumentException(
                     ""A HostProvider may not be empty!"");
-        }       
+        }
+        this.serverAddresses = shuffle(serverAddresses);
         currentIndex = -1;
-        lastIndex = -1;              
+        lastIndex = -1;
     }
 
-    private List<InetSocketAddress> resolveAndShuffle(Collection<InetSocketAddress> serverAddresses) {
-        List<InetSocketAddress> tmpList = new ArrayList<InetSocketAddress>(serverAddresses.size());       
-        for (InetSocketAddress address : serverAddresses) {
-            try {
-                InetAddress ia = address.getAddress();
-                String addr = (ia != null) ? ia.getHostAddress() : address.getHostString();
-                InetAddress resolvedAddresses[] = InetAddress.getAllByName(addr);
-                for (InetAddress resolvedAddress : resolvedAddresses) {
-                    InetAddress taddr = InetAddress.getByAddress(address.getHostString(), resolvedAddress.getAddress());
-                    tmpList.add(new InetSocketAddress(taddr, address.getPort()));
-                }
-            } catch (UnknownHostException ex) {
-                LOG.warn(""No IP address found for server: {}"", address, ex);
+    private InetSocketAddress resolve(InetSocketAddress address) {
+        try {
+            String curHostString = address.getHostString();
+            List<InetAddress> resolvedAddresses = new ArrayList<>(Arrays.asList(this.resolver.getAllByName(curHostString)));
+            if (resolvedAddresses.isEmpty()) {
+                return address;
             }
+            Collections.shuffle(resolvedAddresses);
+            return new InetSocketAddress(resolvedAddresses.get(0), address.getPort());
+        } catch (UnknownHostException e) {","[{'comment': 'Should log the exception here. Does the caller handle the unknown address correctly?', 'commenter': 'lvfangmin'}, {'comment': ""That's correct. The caller will end up getting UnknownHostException when trying to open the socket to the unresolvable address:\r\n```\r\n2018-06-04 12:31:26,022 [myid:huhuuhujkdshgfjksgd.com:2181] - WARN  [main-SendThread(huhuuhujkdshgfjksgd.com:2181):ClientCnxn$SendThread@1237] - Session 0x0 for server huhuuhujkdshgfjksgd.com:2181, unexpected error, closing socket connection and attempting reconnect\r\njava.nio.channels.UnresolvedAddressException\r\n\tat sun.nio.ch.Net.checkAddress(Net.java:101)\r\n\tat sun.nio.ch.SocketChannelImpl.connect(SocketChannelImpl.java:622)\r\n\tat org.apache.zookeeper.ClientCnxnSocketNIO.registerAndConnect(ClientCnxnSocketNIO.java:275)\r\n\tat org.apache.zookeeper.ClientCnxnSocketNIO.connect(ClientCnxnSocketNIO.java:285)\r\n\tat org.apache.zookeeper.ClientCnxn$SendThread.startConnect(ClientCnxn.java:1091)\r\n\tat org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1133)\r\n```\r\n\r\nThe reason for doing this way is to avoid API change of `next()`.\r\n\r\nLogging makes sense, I added an error log entry to make it clear."", 'commenter': 'anmolnar'}]"
534,src/java/main/org/apache/zookeeper/client/StaticHostProvider.java,"@@ -149,15 +185,12 @@ public StaticHostProvider(Collection<InetSocketAddress> serverAddresses,
      * @param currentHost the host to which this client is currently connected
      * @return true if changing connections is necessary for load-balancing, false otherwise  
      */
-
-
     @Override
     public synchronized boolean updateServerList(
             Collection<InetSocketAddress> serverAddresses,
             InetSocketAddress currentHost) {
-        // Resolve server addresses and shuffle them
-        List<InetSocketAddress> resolvedList = resolveAndShuffle(serverAddresses);
-        if (resolvedList.isEmpty()) {
+        List<InetSocketAddress> shuffledList = shuffle(serverAddresses);","[{'comment': ""I am not sure why we change the `resolveAndShuffle` to `shuffle` here, they are semantically different (one tries to resolve address, the other does not and only does shuffle.). The `serverAddresses` passed in this method is unresolved address, and we need it resolved because we rely on the resolved addresses to compare the old / new server list (in the context of probability rebalancing clients for dynamic reconfiguration). \r\n\r\nWithout resolving I think the client rebalance logic will be broken. A side note that all tests still passed probably indicate we don't have a 100% coverage for the logic in our tests. "", 'commenter': 'hanm'}, {'comment': ""After this change, the old / new server list both contains unresolved address, so it's comparable, but it's meaningless to compare addr.getAddress because it will return null when it's unresolved. "", 'commenter': 'lvfangmin'}, {'comment': ""`resolveAndShuffle` has been split into two methods: `resolve` and `shuffle`, because we have to do it separately. Github shows the diff as original has been renamed and new one has been created.\r\n\r\nI'll double check the rebalance functionality to make sure it's working properly and will also check related unit tests. I think what @lvfangmin is saying makes sense."", 'commenter': 'anmolnar'}, {'comment': ""Comparison works for unresolved addresses too, because of the last if condition here:\r\n```java\r\nif (addr.getPort() == myServer.getPort()\r\n    && ((addr.getAddress() != null\r\n    && myServer.getAddress() != null && addr\r\n    .getAddress().equals(myServer.getAddress())) || addr\r\n    .getHostString().equals(myServer.getHostString()))) {\r\n```\r\nAs long as `getHostString()` works for unresolved addresses, we're fine. However, exactly the same functionality has already been implemented in the `InetSocketAddress.equals()` method, so  I refactored this part to use it."", 'commenter': 'anmolnar'}, {'comment': "">> However, exactly the same functionality has already been implemented in the InetSocketAddress.equals() method\r\n\r\nI am wondering if this is the case or not. I just did a random peek at https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/java/net/InetSocketAddress.java#L300, looks like if we compare an unresolved address with a resolved address, the equals will return false - but the code you pasted will return true if getHostString works for both resolved and unresolved address... could you double check this behavior?\r\n\r\nAlso, is it possible to add a test case to cover the case where the second parameter of updateServerList is a resolved address? The existing test cases only cover the case where the second parameter (myServer) is unresolved. In practice I think the method updateServerList is called by ZooKeeper's updateServerList method with second parameter as a resolved address (the remote server where current client connected to.). \r\n\r\n\r\n"", 'commenter': 'hanm'}, {'comment': ""@hanm Good catch, that makes perfect sense. The implementation is slightly different.\r\n\r\nI added 4 new test cases to cover the different combinations of the 2nd and 3rd parameter. Some of them could be redundant (as you said tests present already), but I've already opened a Jira to clean-up this test file, so it should be okay. Test scenarios:\r\n\r\n**Given:** list of servers contains 1 element, client is connected (currentHost (myServer) != null), trying to replace server list with the same address (replaceHost).\r\n\r\n**New impl**\r\n1. `currentHost` resolved, `replaceHost` unresolved => client should disconnect,\r\n2. `currentHost` resolved, `replaceHost` resolved => client should **not** disconnect,\r\n3. `currentHost` unresolved, `replaceHost` unresolved => client should disconnect,\r\n4. `currentHost` unresolved, `replaceHost` resolved => client should disconnect\r\n\r\n**Old impl**\r\n1. `currentHost` resolved, `replaceHost` unresolved => client should **not** disconnect,\r\n2. `currentHost` resolved, `replaceHost` resolved => client should **not** disconnect,\r\n3. `currentHost` unresolved, `replaceHost` unresolved => client should disconnect,\r\n4. `currentHost` unresolved, `replaceHost` resolved => client should **not** disconnect\r\n\r\nBasically the difference is in the case when comparing resolved address with unresolved. The built-in implementation treats them as different address, hence forcing the client to disconnect which makes slightly more sense to me.\r\n\r\nAnyway I'm happy to revert the change if you think this is not acceptable."", 'commenter': 'anmolnar'}, {'comment': ""Thanks for quick update, @anmolnar ! \r\n\r\n>> The built-in implementation treats them as different address\r\n\r\nThat's what I am not sure about. If an unresolved address and a resolved address actually maps same address (after unresolved address gets resolved), should both be treated as same address (old behavior, via getHostString), instead of different address? \r\n\r\nWhat I am thinking is to instead of using equal - use the old verbose code which will work (so far) for all combinations of comparing resolved and unresolved address. What do you think about this?"", 'commenter': 'hanm'}, {'comment': ""My only concern is with the first case: IP address might have changed of the host, so client should disconnect and trigger a re-resolution.\r\n\r\nAnyway. No issue has been reported with the logic we're talking about, so let's just leave it out from this patch. Reverted."", 'commenter': 'anmolnar'}]"
542,src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -686,6 +686,8 @@ public void configure(InetSocketAddress addr, int maxcc, boolean secure) throws
         LOG.info(""binding to port "" + addr);
         ss.socket().bind(addr);
         ss.configureBlocking(false);
+        int port = ss.socket().getLocalPort();
+        LOG.info(""bound to port "" + port);","[{'comment': 'Just a nitpick: why create a variable for the port?', 'commenter': 'nkalmar'}]"
544,src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -165,9 +168,13 @@ public void removeCnxn(NIOServerCnxn cnxn) {
             }
 
             synchronized (ipMap) {
-                Set<NIOServerCnxn> s =
-                        ipMap.get(cnxn.getSocketAddress());
-                s.remove(cnxn);
+                InetAddress addr = cnxn.getSocketAddress();
+            	if (addr != null) {","[{'comment': 'coding style issue: need one more space before the if statement so it aligns with previous statement. Other than this, patch looks good.', 'commenter': 'hanm'}, {'comment': 'tabs led the bad coding style, I have removed it.', 'commenter': 'lujiefsi'}]"
544,src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -129,11 +129,14 @@ public int getLocalPort(){
         return ss.socket().getLocalPort();
     }
 
-    private void addCnxn(NIOServerCnxn cnxn) {
+    private void addCnxn(NIOServerCnxn cnxn) throws IOException {
         synchronized (cnxns) {
             cnxns.add(cnxn);
             synchronized (ipMap){
-                InetAddress addr = cnxn.sock.socket().getInetAddress();
+                InetAddress addr = cnxn.getSocketAddress();
+                if (addr == null) {
+                	throw new IOException(""Socket of "" + cnxn + "" has been closed"");","[{'comment': 'nit: keep indent.', 'commenter': 'lvfangmin'}]"
546,src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java,"@@ -25,7 +25,7 @@
  */
 public class LocalPeerBean extends ServerBean implements LocalPeerMXBean {
     private final QuorumPeer peer;
-    
+","[{'comment': 'unrelated, creates noise in patch', 'commenter': 'ivankelly'}]"
546,src/java/test/org/apache/zookeeper/test/HierarchicalQuorumTest.java,"@@ -227,37 +227,73 @@ void startServers(boolean withObservers) throws Exception {
             LOG.info(hp + "" is accepting client connections"");
         }
 
+        final int numberOfPeers = 5;
+
         // interesting to see what's there...
         JMXEnv.dump();
         // make sure we have these 5 servers listed
         Set<String> ensureNames = new LinkedHashSet<String>();
-        for (int i = 1; i <= 5; i++) {
+        for (int i = 1; i <= numberOfPeers; i++) {
             ensureNames.add(""InMemoryDataTree"");
         }
-        for (int i = 1; i <= 5; i++) {
+        for (int i = 1; i <= numberOfPeers; i++) {
             ensureNames.add(""name0=ReplicatedServer_id"" + i
                  + "",name1=replica."" + i + "",name2="");
         }
-        for (int i = 1; i <= 5; i++) {
-            for (int j = 1; j <= 5; j++) {
+        for (int i = 1; i <= numberOfPeers; i++) {
+            for (int j = 1; j <= numberOfPeers; j++) {
                 ensureNames.add(""name0=ReplicatedServer_id"" + i
                      + "",name1=replica."" + j);
             }
         }
-        for (int i = 1; i <= 5; i++) {
+        for (int i = 1; i <= numberOfPeers; i++) {
             ensureNames.add(""name0=ReplicatedServer_id"" + i);
         }
         JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));
-
-        for (int i = 1; i <= 5; i++) {
+        int countLeadersUsingLocalPeerBean = 0;
+        for (int i = 1; i <= numberOfPeers; i++) {
+            // LocalPeerBean
             String bean = CommonNames.DOMAIN + "":name0=ReplicatedServer_id"" + i
                     + "",name1=replica."" + i;
             JMXEnv.ensureBeanAttribute(bean, ""ConfigVersion"");
             JMXEnv.ensureBeanAttribute(bean, ""LearnerType"");
             JMXEnv.ensureBeanAttribute(bean, ""ClientAddress"");
             JMXEnv.ensureBeanAttribute(bean, ""ElectionAddress"");
             JMXEnv.ensureBeanAttribute(bean, ""QuorumSystemInfo"");
+            boolean leader = (boolean) JMXEnv.ensureBeanAttribute(bean, ""Leader"");
+            if (leader) {
+                countLeadersUsingLocalPeerBean++;
+            }
         }
+        Assert.assertEquals(1, countLeadersUsingLocalPeerBean);
+
+
+        int countLeadersUseRemotePeerBean = 0;","[{'comment': 'Would be good to test that the jmx is correctly updated if the leader changes.', 'commenter': 'ivankelly'}, {'comment': ""That's would be useful.\r\nI need to bounce the leader, this will slow down the suite.\r\nDo you have another way to change the leader in tests?"", 'commenter': 'eolivelli'}]"
546,src/java/test/org/apache/zookeeper/test/HierarchicalQuorumTest.java,"@@ -226,38 +226,71 @@ void startServers(boolean withObservers) throws Exception {
                                     CONNECTION_TIMEOUT));
             LOG.info(hp + "" is accepting client connections"");
         }
-
+        final int numberOfPeers = 5;
         // interesting to see what's there...
         JMXEnv.dump();
         // make sure we have these 5 servers listed
         Set<String> ensureNames = new LinkedHashSet<String>();
-        for (int i = 1; i <= 5; i++) {
+        for (int i = 1; i <= numberOfPeers; i++) {
             ensureNames.add(""InMemoryDataTree"");
         }
-        for (int i = 1; i <= 5; i++) {
+        for (int i = 1; i <= numberOfPeers; i++) {
             ensureNames.add(""name0=ReplicatedServer_id"" + i
                  + "",name1=replica."" + i + "",name2="");
         }
-        for (int i = 1; i <= 5; i++) {
-            for (int j = 1; j <= 5; j++) {
+        for (int i = 1; i <= numberOfPeers; i++) {
+            for (int j = 1; j <= numberOfPeers; j++) {
                 ensureNames.add(""name0=ReplicatedServer_id"" + i
                      + "",name1=replica."" + j);
             }
         }
-        for (int i = 1; i <= 5; i++) {
+        for (int i = 1; i <= numberOfPeers; i++) {
             ensureNames.add(""name0=ReplicatedServer_id"" + i);
         }
         JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));
-
-        for (int i = 1; i <= 5; i++) {
+        int countLeadersUsingLocalPeerBean = 0;
+        for (int i = 1; i <= numberOfPeers; i++) {
+            // LocalPeerBean
             String bean = CommonNames.DOMAIN + "":name0=ReplicatedServer_id"" + i
                     + "",name1=replica."" + i;
             JMXEnv.ensureBeanAttribute(bean, ""ConfigVersion"");
             JMXEnv.ensureBeanAttribute(bean, ""LearnerType"");
             JMXEnv.ensureBeanAttribute(bean, ""ClientAddress"");
             JMXEnv.ensureBeanAttribute(bean, ""ElectionAddress"");
             JMXEnv.ensureBeanAttribute(bean, ""QuorumSystemInfo"");
+            boolean leader = (boolean) JMXEnv.ensureBeanAttribute(bean, ""Leader"");
+            if (leader) {
+                countLeadersUsingLocalPeerBean++;
+            }
+        }
+        Assert.assertEquals(1, countLeadersUsingLocalPeerBean);
+
+
+        int countLeadersUseRemotePeerBean = 0;","[{'comment': 'This whole test could use a refactor (most unit test could), but if we touch a unit test, we could keep good practices in mind. This could go to a seperate function. (But this is not a showstopper for me, just my two cents. )', 'commenter': 'nkalmar'}]"
546,src/java/test/org/apache/zookeeper/server/quorum/RemotePeerBeanTest.java,"@@ -36,7 +36,7 @@ public void testGetClientAddressShouldReturnEmptyStringWhenClientAddressIsNull()
         InetSocketAddress peerCommunicationAddress = null;
         // Here peerCommunicationAddress is null, also clientAddr is null
         QuorumServer peer = new QuorumServer(1, peerCommunicationAddress);
-        RemotePeerBean remotePeerBean = new RemotePeerBean(peer);
+        RemotePeerBean remotePeerBean = new RemotePeerBean(null /*QuorumPeer*/, peer);","[{'comment': 'Do you think that comment could be useful? Modern IDEs like intellij give hints about null arguments and the comment seems to be redundant to me.', 'commenter': 'anmolnar'}, {'comment': ""Not everyone uses an IDE, and code review happens on github which doesn't give hints about this stuff."", 'commenter': 'ivankelly'}, {'comment': '@ivankelly  @anmolnar I will be happy to follow the guidelines on ZK codebase, just tell me', 'commenter': 'eolivelli'}]"
546,src/java/test/org/apache/zookeeper/test/HierarchicalQuorumTest.java,"@@ -226,38 +227,108 @@ void startServers(boolean withObservers) throws Exception {
                                     CONNECTION_TIMEOUT));
             LOG.info(hp + "" is accepting client connections"");
         }
+        LOG.info(""initial status "" + s1.getCurrentVote() + "","" + s2.getCurrentVote() + "","" + s3.getCurrentVote());","[{'comment': 'I think this is not right approach for testing this. The patch is about adding a new field to a JMX bean to expose a new attribute of ZooKeeper. This test is part of `ClientHammerTest`: completely different things. For example, if the new functionality got broken and JMX value is not exposed correctly, we\'ll see that `ClientHammerTest` is failing which is terribly misleading.\r\n\r\nPlease revert changes to this file and add more unit tests to `RemotePeerBeenTest`, because that is essentially what you\'ve changed in this patch and you want to validate. I\'d do something like this in a new test:\r\n\r\n```java\r\n...\r\nQuorumPeer peerMock = mock(QuorumPeer.class);\r\nRemotePeerBean remotePeerBean = new RemotePeerBean(peerMock, new QuorumServer(5, ...));\r\nwhen(peerMock.isLeader(peerId)).return(true);\r\nassertThat(""Remote peer bean should expose isLeader() property of remote peer"", remotePeerBean.isLeader(5), isTrue());\r\n...\r\n```\r\n\r\nHaven\'t tested the code, sorry if it\'s not working out of the box, but hopefully give you an idea.', 'commenter': 'anmolnar'}]"
546,src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -2069,4 +2073,9 @@ public QuorumCnxManager createCnxnManager() {
                 this.quorumCnxnThreadsSize,
                 this.isQuorumSaslAuthEnabled());
     }
+
+    boolean isLeader(long id) {
+        Vote vote = getCurrentVote();
+        return vote != null && id == vote.getId();","[{'comment': 'You could use `state` property to check if the peer is the leader:\r\n```java\r\nreturn state == ServerState.LEADING;\r\n```\r\nWhat do you think?', 'commenter': 'anmolnar'}, {'comment': 'I think it would be good to add unit test to verify this logic too.', 'commenter': 'anmolnar'}, {'comment': ""@anmolnar\r\nDo I have to check in the current view?\r\nIs this about temporary leader election phase? I don't know the code very well\r\n\r\n can you please give an hint about this new test?\r\n\r\nDo I have to simply test the check I am adding? Like a basic unit test with mockito?"", 'commenter': 'eolivelli'}, {'comment': 'Should I rename the method to isLeaderForJmx or something similar?\r\nI would like to make it clear that this method is only for external monitoring', 'commenter': 'eolivelli'}, {'comment': 'I\'d second the request to sidestep the election logic for this method if possible as it makes the method harder to reason about. \r\n\r\nIt would be nice if the method implied the server was currently performing active leader actions and the current way also covers a server preparing for or nominating itself to be leader (or at least it looks like it). For example, with this code on a 5 server ensemble with one server dead, if one server switches its vote midway through an election epoch then you could be displaying two ""leaders"" by vote but this is not the same as a two leader splitbrain scenario.', 'commenter': 'enixon'}, {'comment': ""@enixon sorry,  to me it is not clear if you are saying that current method is okay or that I should change it according to @anmolnar idea.\r\n\r\nFor LocalPeerBean it may have sense to also check local election state, but for RemotePeerBean I can't see the meaning.\r\n\r\nAlternatively we could return 'false' in case that local peer is performing leader election.\r\n\r\nI think we should keep the logic simple"", 'commenter': 'eolivelli'}, {'comment': '@eolivelli I missed the purpose of this method and had assumed that it was strictly concerned with determining whether the local peer was a leader or not. In order to capture the your purpose with the method, I would have to write something much more convoluted:\r\n\r\n`    boolean isLeader(long id) {\r\n        long leaderId = -1;\r\n        ZooKeeperServer server = getActiveServer();\r\n        if (server instanceof LeaderZooKeeperServer) {\r\n            leaderId = myid;\r\n        } else if (server instanceof FollowerZooKeeperServer) {\r\n            leaderId = ((FollowerZooKeeperServer)server).getFollower().findLeader().id;\r\n        } else if (server instanceof ObserverZooKeeperServer) {\r\n            leaderId = ((ObserverZooKeeperServer)server).getObserver().findLeader().id;\r\n        }\r\n        return leaderId == id;\r\n    }`\r\n\r\nYour solution is much cleaner.', 'commenter': 'enixon'}]"
546,src/java/test/org/apache/zookeeper/server/quorum/LocalPeerBeanTest.java,"@@ -79,4 +80,27 @@ public void testClientAddress() throws Exception {
         cnxnFactory.shutdown();
     }
 
+    @Test
+    @SuppressWarnings(""unchecked"")
+    public void testIsLeader() throws Exception {","[{'comment': '- This is a `QuorumPeer` test, move it to `QuorumPeerTest` class please.\r\n- These are actually 3 tests together, split them into 3 methods please.', 'commenter': 'anmolnar'}]"
548,src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java,"@@ -86,7 +86,7 @@ public static String send4LetterWord(String host, int port, String cmd, boolean
             throws IOException, SSLContextException {
         LOG.info(""connecting to {} {}"", host, port);
         Socket sock;
-        InetSocketAddress hostaddress= host != null ? new InetSocketAddress(host, port) :
+        InetSocketAddress hostaddress = host != null ? new InetSocketAddress(host, port) :","[{'comment': ""it seems that this PR includes some code formats and typos which isn't related."", 'commenter': 'maoling'}, {'comment': ""Agreed, it's not ideal, but size of the patch makes it easy to deal with I would say."", 'commenter': 'anmolnar'}, {'comment': ""@mjeelanimsft generally, this is due to the auto-format in the editor, but I think we should remove this change from this diff, given we haven't changed other logic except this one."", 'commenter': 'lvfangmin'}]"
548,src/java/main/org/apache/zookeeper/server/util/ConfigUtils.java,"@@ -60,4 +60,25 @@ static public String getClientConfigStr(String configData) {
         }
         return version + "" "" + sb.toString();
     }
+
+    public static String[] splitServerConfig(String s)
+        throws ConfigException
+    {
+        /* Does it start with an IPv6 literal? */","[{'comment': ""good method.this annotation's answer is sure(grin)\r\n\r\n\r\n\r\n"", 'commenter': 'maoling'}, {'comment': 'remove this line annotation and give this method detailed javadoc', 'commenter': 'maoling'}]"
548,src/java/test/org/apache/zookeeper/common/NetUtilsTest.java,"@@ -0,0 +1,46 @@
+package apache.zookeeper.common;","[{'comment': '???', 'commenter': 'maoling'}, {'comment': '@mjeelanimsft i think this is why the tests are failing. can you fix this package name? (good catch @maoling !)', 'commenter': 'breed'}, {'comment': 'Thanks @maoling @breed - working on fixing this', 'commenter': 'mjeelanimsft'}]"
548,src/java/test/org/apache/zookeeper/common/NetUtilsTest.java,"@@ -0,0 +1,46 @@
+package apache.zookeeper.common;
+
+import org.apache.zookeeper.common.NetUtils;
+import org.apache.zookeeper.ZKTestCase;
+import org.hamcrest.core.AnyOf;
+import org.hamcrest.core.IsEqual;
+import org.junit.Assert;
+import org.junit.Test;
+import java.net.InetSocketAddress;
+
+public class NetUtilsTest extends ZKTestCase {
+
+    private Integer port = 1234;
+    private String v4addr = ""127.0.0.1"";
+    private String v6addr = ""[0:0:0:0:0:0:0:1]"";
+    private String v4local = v4addr + "":"" + port.toString();
+    private String v6local = v6addr + "":"" + port.toString();
+
+    @Test
+    public void testformatInetAddrGoodIpv4() {","[{'comment': 'Typo: capital `F`', 'commenter': 'anmolnar'}]"
548,src/java/test/org/apache/zookeeper/common/NetUtilsTest.java,"@@ -0,0 +1,46 @@
+package apache.zookeeper.common;
+
+import org.apache.zookeeper.common.NetUtils;
+import org.apache.zookeeper.ZKTestCase;
+import org.hamcrest.core.AnyOf;
+import org.hamcrest.core.IsEqual;
+import org.junit.Assert;
+import org.junit.Test;
+import java.net.InetSocketAddress;
+
+public class NetUtilsTest extends ZKTestCase {
+
+    private Integer port = 1234;
+    private String v4addr = ""127.0.0.1"";
+    private String v6addr = ""[0:0:0:0:0:0:0:1]"";
+    private String v4local = v4addr + "":"" + port.toString();
+    private String v6local = v6addr + "":"" + port.toString();
+
+    @Test
+    public void testformatInetAddrGoodIpv4() {
+        InetSocketAddress isa = new InetSocketAddress(v4addr, port);
+        Assert.assertEquals(""127.0.0.1:1234"", NetUtils.formatInetAddr(isa));
+    }
+
+    @Test
+    public void testFormatInetAddrGoodIpv6() {","[{'comment': ""I think it'd be great to add more IPv6 formatting tests other than the localhost case."", 'commenter': 'anmolnar'}, {'comment': ""Thanks @anmolnar - I'll add the additional tests"", 'commenter': 'mjeelanimsft'}]"
548,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -225,17 +229,25 @@ static public InitialMessage parse(Long protocolVersion, DataInputStream din)
             // FIXME: IPv6 is not supported. Using something like Guava's HostAndPort
             //        parser would be good.
             String addr = new String(b);
-            String[] host_port = addr.split("":"");
+            String[] host_port;
+            try {
+                host_port = ConfigUtils.splitServerConfig(addr);
+            } catch (ConfigException e) {
+                throw new InitialMessageException(""Badly formed address: %s"", addr);
+            }
 
             if (host_port.length != 2) {
                 throw new InitialMessageException(""Badly formed address: %s"", addr);
             }
+            //String[] host_port = addr.split("":"");","[{'comment': 'Remove this line.', 'commenter': 'lvfangmin'}]"
548,src/java/test/org/apache/zookeeper/server/quorum/ReconfigFailureCasesTest.java,"@@ -58,10 +58,10 @@ public void tearDown() throws Exception {
     }
 
     /*
-     * Tests that an incremental reconfig fails if the current config is hiearchical.
+     * Tests that an incremental reconfig fails if the current config is hierarchical.","[{'comment': 'Please remove this unrelated change as well.', 'commenter': 'lvfangmin'}]"
548,src/java/test/org/apache/zookeeper/server/util/ConfigUtilsTest.java,"@@ -29,4 +30,21 @@ public void testSplitServerConfig() throws ConfigException {
         String[] nsa = ConfigUtils.splitServerConfig(""[2001:db8:85a3:8d3:1319:8a2e:370:7348]:443"");
         assertEquals(nsa.length, 2, 0);","[{'comment': 'Assert the actual host and port?', 'commenter': 'maoling'}]"
548,src/java/main/org/apache/zookeeper/server/util/ConfigUtils.java,"@@ -61,10 +61,16 @@ static public String getClientConfigStr(String configData) {
         return version + "" "" + sb.toString();
     }
 
+    /**
+     * Splits server config to server and port
+     * with support for IPv6 literals
+     * @return String[] first element being the
+     *  IP address and the next being the port
+     * @param s server config, server:port
+     */
     public static String[] splitServerConfig(String s)
         throws ConfigException","[{'comment': '`splitServerConfig` is somewhat general. `getHostAndPort` is better?', 'commenter': 'maoling'}, {'comment': ""Sure, I like that better too - I've renamed this"", 'commenter': 'mjeelanimsft'}]"
548,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -226,17 +230,25 @@ static public InitialMessage parse(Long protocolVersion, DataInputStream din)
             // FIXME: IPv6 is not supported. Using something like Guava's HostAndPort
             //        parser would be good.","[{'comment': 'remove this ?', 'commenter': 'maoling'}]"
548,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -857,15 +869,15 @@ public void run() {
                         self.recreateSocketAddresses(self.getId());
                         addr = self.getElectionAddress();
                     }
-                    LOG.info(""My election bind port: "" + addr.toString());
+                    LOG.info(""My election bind port: "" + formatInetAddr(addr));
                     setName(addr.toString());","[{'comment': 'using  `toString` can still distinguish ipv4 from ipv6 by looking at the ip style although without `[] ` \r\nif `formatInetAddr(addr)` is really needed, can you make sure all the places which log `InetSocketAddress` are covered?', 'commenter': 'maoling'}, {'comment': ""Good point - I'll remove formatInetAddr(addr) from the log"", 'commenter': 'mjeelanimsft'}]"
561,src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -754,7 +754,7 @@ public void finishSessionInit(ServerCnxn cnxn, boolean valid) {
             cnxn.sendBuffer(bb);
 
             if (valid) {
-                LOG.info(""Established session 0x""
+                LOG.debug(""Established session 0x""","[{'comment': 'This sounds pretty useful INFO level log. If we turn it into DEBUG level, are there any other equivalent INFO level logging where we can derive the session establishment details? If not, probably better to leave this as INFO?', 'commenter': 'hanm'}, {'comment': ""I'd leave this one as INFO too."", 'commenter': 'anmolnar'}, {'comment': 'i think this should go to debug. if you have thousands of clients that are reconnecting after a leader change the log fills with these. if you are really interested in this line you can add a log4j config that will show it. but this really creates a lot of noise in the log.', 'commenter': 'breed'}, {'comment': ""The attributes of an established connection don't appear in other INFO logs but remain accessible through jmx and through ServerCnxn::dumpConnectionInfo via 'cons'.\r\n\r\nI'd agree with Ben that this is makes parsing the logs hard when the number of client connections is high and that it's better to isolate it via log level so it can be turned off in that scenario or turned on (via debug) if needed for low client-supporting ensembles."", 'commenter': 'enixon'}]"
561,src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1047,14 +1047,19 @@ public void processConnectRequest(ServerCnxn cnxn, ByteBuffer incomingBuffer) th
         cnxn.disableRecv();
         long sessionId = connReq.getSessionId();
         if (sessionId == 0) {
-            LOG.info(""Client attempting to establish new session at ""
-                    + cnxn.getRemoteSocketAddress());
-            createSession(cnxn, passwd, sessionTimeout);
+            long id = createSession(cnxn, passwd, sessionTimeout);
+            LOG.info(""Client attempting to establish new session: session = 0x""","[{'comment': 'I like these ones. Would you please use the message formatter of the logging lib? e.g. `""... {}... {}"", a,b`', 'commenter': 'anmolnar'}, {'comment': ""shouldn't this also be debug like the other session messages?"", 'commenter': 'breed'}]"
561,src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -817,10 +817,12 @@ protected void pRequest(Request request) throws RequestProcessorException {
                             type = OpCode.error;
                             txn = new ErrorTxn(e.code().intValue());
 
-                            LOG.info(""Got user-level KeeperException when processing ""
-                                    + request.toString() + "" aborting remaining multi ops.""
-                                    + "" Error Path:"" + e.getPath()
-                                    + "" Error:"" + e.getMessage());
+                            if (e.code().intValue() > Code.APIERROR.intValue()) {","[{'comment': ""Does this mean that we don't want to log system errors at all?\r\nOr I might be missing something here."", 'commenter': 'anmolnar'}, {'comment': 'Additionally refactoring this one to use message formatter would be nice.', 'commenter': 'anmolnar'}, {'comment': ""this one really seems like a debug level to me. the issue is that the client request tried to do something create a node that already exists. these are very normal cases that the client is probably expecting (in the case of leader election, for example). we shouldn't be logging this kind of expected behavior for common operations as INFO"", 'commenter': 'breed'}, {'comment': ""I get the point - things will break when they are running at scale :) . I don't have strong opinion holding this as INFO. wondering how others think about this (I mentioned it's info as this log was my good friend before when I debugged some issues...).\r\n\r\nBTW for similar use case (large scale of clients) - it looks like all client side related log should be silenced on server side. basically server side just keep server specific loggings on by default (which hopefully does not change regardless of the scale of clients). So all client cnx / session related logs need be silenced..."", 'commenter': 'hanm'}, {'comment': ""Exactly.\r\n\r\nI'll fix up the format of this log line and the others as well."", 'commenter': 'enixon'}]"
561,src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -878,10 +880,13 @@ protected void pRequest(Request request) throws RequestProcessorException {
                 request.getHdr().setType(OpCode.error);
                 request.setTxn(new ErrorTxn(e.code().intValue()));
             }
-            LOG.info(""Got user-level KeeperException when processing ""
-                    + request.toString()
-                    + "" Error Path:"" + e.getPath()
-                    + "" Error:"" + e.getMessage());
+
+            if (e.code().intValue() > Code.APIERROR.intValue()) {","[{'comment': 'Same here.', 'commenter': 'anmolnar'}, {'comment': 'i feel the same as above here.', 'commenter': 'breed'}]"
561,src/java/main/org/apache/zookeeper/jmx/MBeanRegistry.java,"@@ -124,9 +124,7 @@ private void unregister(String path,ZKMBeanInfo bean) throws JMException  {
             return;
         if (!bean.isHidden()) {
             final ObjectName objName = makeObjectName(path, bean);
-            if (LOG.isInfoEnabled()) {
-                LOG.info(""Unregister MBean [{}]"", objName);
-            }
+            LOG.debug(""Unregister MBean [{}]"", objName);","[{'comment': ""any idea why this was in an if clause before. i don't think it was needed, but just checking."", 'commenter': 'breed'}, {'comment': 'this sounds an optimization as with the if clause presence, if the log is not enabled the objName is not copied which might help if copying objName is expensive. sounds not a very big deal (and i noticed we have two inconsistent logging style in code base, with or without this if clause, might worth a clean up).', 'commenter': 'hanm'}, {'comment': 'Right. And this where using log4j message formatter comes important: if one use `string.format()` instead and not putting it inside an if block, the string will be formatted every time no matter if the log level is enabled.', 'commenter': 'anmolnar'}]"
561,src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1047,14 +1047,19 @@ public void processConnectRequest(ServerCnxn cnxn, ByteBuffer incomingBuffer) th
         cnxn.disableRecv();
         long sessionId = connReq.getSessionId();
         if (sessionId == 0) {
-            LOG.info(""Client attempting to establish new session at ""
-                    + cnxn.getRemoteSocketAddress());
-            createSession(cnxn, passwd, sessionTimeout);
+            long id = createSession(cnxn, passwd, sessionTimeout);
+            LOG.info(""Client attempting to establish new session: session = 0x""
+                    + Long.toHexString(id)
+                    + "", zxid = 0x"" + Long.toHexString(connReq.getLastZxidSeen())
+                    + "", timeout = "" + connReq.getTimeOut()
+                    + "", address = "" + cnxn.getRemoteSocketAddress());
         } else {
             long clientSessionId = connReq.getSessionId();
-            LOG.info(""Client attempting to renew session 0x""
+            LOG.info(""Client attempting to renew session: session = 0x""","[{'comment': 'i feel this should be debug as well.', 'commenter': 'breed'}]"
562,src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -905,6 +908,12 @@ public void run() {
                         + ""I won't be able to participate in leader ""
                         + ""election any longer: ""
                         + self.getElectionAddress());
+                if (exitException instanceof BindException) {
+                    // After leaving listener thread, the host cannot join the
+                    // quorum anymore, this is a severe error that we cannot
+                    // recover from, so we need to exit
+                    System.exit(14);","[{'comment': 'how did we pick 14?', 'commenter': 'breed'}, {'comment': 'I picked an exit code which is not being used in anywhere else, so it can identify why it exited.', 'commenter': 'lvfangmin'}, {'comment': ""It would be great to track these exit codes at a common place somewhere. Would you mind creating constant fields for them?\r\nIf there're too many, we might want to create a separate Jira for the refactoring.\r\nDocumenting them would also be very helpful. It seems like we don't list them in the docs yet, so that might also be part of the new Jira."", 'commenter': 'anmolnar'}]"
567,src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -110,6 +124,18 @@
         if ((fsyncWarningThreshold = Long.getLong(""zookeeper.fsync.warningthresholdms"")) == null)
             fsyncWarningThreshold = Long.getLong(""fsync.warningthresholdms"", 1000);
         fsyncWarningThresholdMS = fsyncWarningThreshold;
+
+        Long logSize = Long.getLong(LOG_SIZE_LIMIT, -1);
+        if (logSize > 0) {
+            // Convert to bytes
+            logSize = logSize * 1024;
+            if (logSize <= preAllocSize) {
+                LOG.error(""Ignoring invalid txn log size limit (lesser than preAllocSize)"");","[{'comment': 'language: ""less than ...""', 'commenter': 'anmolnar'}, {'comment': 'Removed this line, it was due to the incorrect merge (the feature was developed against older Zookeeper version)', 'commenter': 'suyogmapara'}]"
567,src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -102,6 +102,20 @@
     /** Maximum time we allow for elapsed fsync before WARNing */
     private final static long fsyncWarningThresholdMS;
 
+    /**
+     * This parameter limit the size of each txnlog to a given limit (KB).
+     * It does not affect how often the system will take a snapshot
+     * [zookeeper.snapCount]
+     *
+     * The feature is disabled by default (-1)
+     */
+    public static final String LOG_SIZE_LIMIT = ""zookeeper.txnlogSizeLimit"";","[{'comment': 'I think it would be nice to indicate the unit in the name of the setting. e.g. `txnlogSizeLimitInKb`', 'commenter': 'anmolnar'}]"
567,src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -110,6 +124,18 @@
         if ((fsyncWarningThreshold = Long.getLong(""zookeeper.fsync.warningthresholdms"")) == null)
             fsyncWarningThreshold = Long.getLong(""fsync.warningthresholdms"", 1000);
         fsyncWarningThresholdMS = fsyncWarningThreshold;
+
+        Long logSize = Long.getLong(LOG_SIZE_LIMIT, -1);
+        if (logSize > 0) {
+            // Convert to bytes
+            logSize = logSize * 1024;
+            if (logSize <= preAllocSize) {
+                LOG.error(""Ignoring invalid txn log size limit (lesser than preAllocSize)"");
+            } else {
+                LOG.info(LOG_SIZE_LIMIT + ""="" + logSize);","[{'comment': 'Please indicate the unit in the message (you converted the value to bytes) and use log4j message formatter.', 'commenter': 'anmolnar'}, {'comment': 'Flipped the order of the two lines.', 'commenter': 'suyogmapara'}]"
567,src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -347,6 +397,13 @@ public synchronized void commit() throws IOException {
         while (streamsToFlush.size() > 1) {
             streamsToFlush.removeFirst().close();
         }
+
+        // Roll the log file if we exceed the size limit
+        long logSize = getCurrentLogSize();
+        if ((logSizeLimit > 0) && (logSize > logSizeLimit)) {","[{'comment': 'Redundant inner brackets.', 'commenter': 'anmolnar'}]"
567,src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -347,6 +397,13 @@ public synchronized void commit() throws IOException {
         while (streamsToFlush.size() > 1) {
             streamsToFlush.removeFirst().close();
         }
+
+        // Roll the log file if we exceed the size limit
+        long logSize = getCurrentLogSize();
+        if ((logSizeLimit > 0) && (logSize > logSizeLimit)) {
+            LOG.debug(""Log size limit reached: "" + logSize);","[{'comment': 'Use message formatter.', 'commenter': 'anmolnar'}]"
567,src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -347,6 +397,13 @@ public synchronized void commit() throws IOException {
         while (streamsToFlush.size() > 1) {
             streamsToFlush.removeFirst().close();
         }
+
+        // Roll the log file if we exceed the size limit
+        long logSize = getCurrentLogSize();","[{'comment': ""Please change the order of the if conditions. You probably don't want to calculate the current log file size if the feature is disabled. Probably not a big deal performance-wise, but I think it's cleaner code."", 'commenter': 'anmolnar'}]"
567,src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -109,7 +109,7 @@
      *
      * The feature is disabled by default (-1)
      */
-    public static final String LOG_SIZE_LIMIT = ""zookeeper.txnlogSizeLimit"";
+    public static final String LOG_SIZE_LIMIT = ""zookeeper.txnlogSizeLimitInKb"";","[{'comment': 'private?', 'commenter': 'maoling'}]"
567,src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -127,14 +127,11 @@
 
         Long logSize = Long.getLong(LOG_SIZE_LIMIT, -1);
         if (logSize > 0) {
+            LOG.info(""{} = {}"", LOG_SIZE_LIMIT, logSize);
+","[{'comment': '{} value is {} Bytes', 'commenter': 'maoling'}, {'comment': 'I renamed the property as per the other comment, I think now the log is readable as is. Please let me know if you think otherwise.', 'commenter': 'suyogmapara'}, {'comment': 'add a unit: kb in the log is better?', 'commenter': 'maoling'}]"
567,src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -102,6 +102,20 @@
     /** Maximum time we allow for elapsed fsync before WARNing */
     private final static long fsyncWarningThresholdMS;
 
+    /**
+     * This parameter limit the size of each txnlog to a given limit (KB).
+     * It does not affect how often the system will take a snapshot
+     * [zookeeper.snapCount]
+     *
+     * The feature is disabled by default (-1)
+     */
+    public static final String LOG_SIZE_LIMIT = ""zookeeper.txnlogSizeLimit"";
+
+    /**
+     * The actual txnlog size limit in bytes.
+     */
+    public static long logSizeLimit = -1;
+","[{'comment': 'private? txnLogSizeLimit is better?', 'commenter': 'maoling'}, {'comment': 'good points @maoling ! is there a reason these two variables should be public? it would be nice to make the variable have a similar name to the property.', 'commenter': 'breed'}]"
567,src/java/test/org/apache/zookeeper/test/TxnLogSizeLimitTest.java,"@@ -0,0 +1,173 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import java.io.File;
+import java.util.HashSet;
+import java.util.Random;
+
+import org.apache.log4j.Logger;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.proto.CreateRequest;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.apache.zookeeper.server.ZKDatabase;
+import org.apache.zookeeper.server.ZooKeeperServer;
+import org.apache.zookeeper.server.persistence.FileTxnLog;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.txn.TxnHeader;
+import org.junit.Assert;
+import org.junit.Test;
+
+/**
+ * Test loading committed proposal from txnlog. Learner uses these proposals to
+ * catch-up with leader
+ */
+public class TxnLogSizeLimitTest extends ZKTestCase implements Watcher {
+    private static final Logger LOG = Logger","[{'comment': 'the unit tests in the `TxnLogSizeLimitTest` can be moved to `FileTxnLogTest`?', 'commenter': 'maoling'}]"
567,src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -102,6 +102,21 @@
     /** Maximum time we allow for elapsed fsync before WARNing */
     private final static long fsyncWarningThresholdMS;
 
+    /**
+     * This parameter limit the size of each txnlog to a given limit (KB).
+     * It does not affect how often the system will take a snapshot [zookeeper.snapCount]
+     * We roll the txnlog when either of the two limits are reached.
+     * Also since we only roll the logs at transaction boundaries, actual file size can exceed
+     * this limit by the maximum size of a serialized transaction.
+     * The feature is disabled by default (-1)
+     */
+    public static final String LOG_SIZE_LIMIT = ""zookeeper.txnlogSizeLimitInKb"";","[{'comment': ""shouldn't it be txnLogSizeLimitInKb?"", 'commenter': 'breed'}, {'comment': 'we should also add this property to the doc.', 'commenter': 'breed'}, {'comment': 'Thanks @breed, are you referring to https://github.com/apache/zookeeper/blob/master/docs/zookeeperAdmin.html?', 'commenter': 'suyogmapara'}, {'comment': 'Yes. This new feature should be documented in zookeeperAdmin. Are you planning to address docs here or in separate patch?', 'commenter': 'anmolnar'}, {'comment': 'I mean `zookeeperAdmin.xml`.\r\nHtml and pdf files are generated from xml.', 'commenter': 'anmolnar'}, {'comment': 'Thanks @anmolnar I will update the patch soon with documentation.', 'commenter': 'suyogmapara'}]"
567,zookeeper-docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -840,6 +840,26 @@ server.3=zoo3:2888:3888</programlisting>
             </listitem>
           </varlistentry>
 
+          <varlistentry>
+            <term>txnLogSizeLimitInKb</term>
+
+            <listitem>
+              <para>(Java system property: <emphasis
+              role=""bold"">zookeeper.txnLogSizeLimitInKb</emphasis>)</para>
+
+              <para>Zookeeper transaction log file can also be controlled more
+              directly using txnLogSizeLimitInKb. Larger txn logs can lead to
+              slower follower syncs when sync is done using transaction log.
+              This is because leader has to scan through the appropriate log
+              file on disk to find the transaction to start sync from.
+              This feature is turned off by this default and snapCount is the","[{'comment': '> This is because leader has to scan through the appropriate log file on disk to find the transaction to start sync from.\r\n\r\n\r\nCould you plz explain it for me? when this happens?\r\n\r\nBTW:only change zookeeperAdmin.xml is ok,let html,pdf go', 'commenter': 'maoling'}, {'comment': ""I think it's okay to update HTML and PDF too. As long as they're part of the repo, we should keep them up-to-date."", 'commenter': 'anmolnar'}]"
567,src/java/test/org/apache/zookeeper/server/persistence/FileTxnLogTest.java,"@@ -17,9 +17,13 @@
  */
 package org.apache.zookeeper.server.persistence;
 
-import org.apache.zookeeper.ZKTestCase;
-import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.*;
+import org.apache.zookeeper.data.Stat;","[{'comment': 'import *  ?', 'commenter': 'maoling'}, {'comment': 'Hi @maoling do you have any more comments or I should proceed with PR. Basically I am waiting on your review :)', 'commenter': 'suyogmapara'}]"
580,src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -271,7 +271,7 @@ private boolean checkFourLetterWord(final Channel channel,
         String cmd = FourLetterCommands.getCommandString(len);
 
         channel.setInterestOps(0).awaitUninterruptibly();
-        packetReceived();
+        packetReceived(4);","[{'comment': ""I am not sure what's the intention of this change.."", 'commenter': 'hanm'}, {'comment': '`packetReceived()` now takes in the packet-size as an argument to update the packets received metric. The total packet size consists of packet header (4 bytes) + packet size. For ""four letter words"", there is no packet size -- just the 4-byte packet header.', 'commenter': 'jtuple'}]"
580,src/java/main/org/apache/zookeeper/server/ServerMetrics.java,"@@ -0,0 +1,103 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.zookeeper.server.metric.AvgMinMaxCounter;
+import org.apache.zookeeper.server.metric.Metric;
+import org.apache.zookeeper.server.metric.SimpleCounter;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+public enum ServerMetrics {
+    /**
+     * Txnlog fsync time
+     */
+    FSYNC_TIME(new AvgMinMaxCounter(""fsynctime"")),
+
+    /**
+     * Snapshot writing time
+     */
+    SNAPSHOT_TIME(new AvgMinMaxCounter(""snapshottime"")),
+
+    /**
+     * Db init time (snapshot loading + txnlog replay)
+     */
+    DB_INIT_TIME(new AvgMinMaxCounter(""dbinittime"")),
+
+    /**
+     * Stats for read request. The timing start from when the server see the
+     * request until it leave final request processor.
+     */
+    READ_LATENCY(new AvgMinMaxCounter(""readlatency"")),
+
+    /**
+     * Stats for request that need quorum voting. Timing is the same as read
+     * request. We only keep track of stats for request that originated from
+     * this machine only.
+     */
+    UPDATE_LATENCY(new AvgMinMaxCounter(""updatelatency"")),
+
+    /**
+     * Stats for all quorum request. The timing start from when the leader
+     * see the request until it reach the learner.
+     */
+    PROPAGATION_LATENCY(new AvgMinMaxCounter(""propagation_latency"")),
+
+    FOLLOWER_SYNC_TIME(new AvgMinMaxCounter(""follower_sync_time"")),
+    ELECTION_TIME(new AvgMinMaxCounter(""election_time"")),","[{'comment': 'Should election_time be recorded as a gauge instead of a counter? Similar for other times (fsync, init, etc)', 'commenter': 'hanm'}, {'comment': 'If by gauge you\'re referring to a metric that only reports a single value, I don\'t think that\'s a good fit for these metrics. If you\'re querying metrics from Zookeeper every minute or so, you\'d miss all but the last election that occurred in that interval. With an avg/min/max counter, we can query periodically and have statistics that summarize all elections that occurred in that interval. Same logic applies to fsync, init, etc.\r\n\r\nTracking individual event times is probably better left for the ""push metrics to external system"" approach that\'s orthogonal to this pull request.\r\n\r\nHowever, if we wanted to provide statistics + bounded history internally, we could consider adding an extended version of say `AvgMinMaxCounter` that also keeps a fixed number of values around that could be queried, dropping the oldest or doing some sort of reservoir sampling.\r\n\r\nDefinitely something we can do in the future. If we do, it\'s unclear if we\'d want to wire that up to `/metrics` admin command though vs exposing through a different means.', 'commenter': 'jtuple'}]"
580,src/java/main/org/apache/zookeeper/server/ServerStats.java,"@@ -33,17 +34,17 @@
 public class ServerStats {
     private static final Logger LOG = LoggerFactory.getLogger(ServerStats.class);
 
-    private long packetsSent;
-    private long packetsReceived;
-    private long maxLatency;
-    private long minLatency = Long.MAX_VALUE;
-    private long totalLatency = 0;
-    private long count = 0;
+    private final AtomicLong packetsSent = new AtomicLong();","[{'comment': 'Why are these 3 not part of `ServerMetrics`?\r\nIs that a future step of the migration?', 'commenter': 'anmolnar'}, {'comment': ""It's being counted in requestLatency."", 'commenter': 'lvfangmin'}, {'comment': 'I\'m not sure if I see what you mean by ""being counted""?\r\nI\'ve thought that these three metrics should be part of ServerMetrics as:\r\n- packetsSent and packetsReceived as SimpleCounter,\r\n- requestLatency as AvgMinMaxCounter\r\n\r\nand should be referred as ServerMetrics.PACKETS_SENT, etc. like the rest.\r\nPlease let me know if didn\'t get it right.', 'commenter': 'anmolnar'}, {'comment': 'When making this change, we kept all existing metrics ""as-is"" and only added new metrics to `ServerMetrics`. The packet sent/receive and request_latency are both examples of metrics existing prior to this pull-request which are directly exposed in both in the `/metrics` admin command (where `ServerMetrics` metrics also report) as well as the `mntr` four letter command (where `ServerMetrics` metrics do not report).\r\n\r\nThe only changes to these existing metrics in this pull-request was converting some of them to `AtomicLong` for minor performance wins.\r\n\r\nI\'m happy to move both of these metrics to `ServerMetrics` if we want. I\'m not sure if the names will 100% match the current values though. We\'d also need to decide if we\'re happy losing these metrics in `mntr` or if I should port the existing `mntr` reporting logic to still query these from `ServerMetrics`.\r\n\r\nThis is also an open question for all other pre-existing metrics in `ServerStats`.', 'commenter': 'jtuple'}, {'comment': ""Since `ServerMetrics` is a superset of `ServerStats` in terms of scope, we probably want to keep `ServerStats` as is and ultimately deprecate it in favor of `ServerMetrics`. I don't think there is a need to duplicate metrics in two places, which would be both a burden to maintain and a potential source of confusion.\r\n\r\nRegarding reporting to `mntr`, we decided deprecate 4lw last year due to the limitation of its design, in particular around security, in favor of admin server endpoints  (`/metrics` in this case), so I don't there is a need to report newly added metrics to `mntr`. This also encourages users to migrate away from 4lw to admin end points.\r\n\r\nOverall the state in current patch w.r.t this looks good to me.\r\n"", 'commenter': 'hanm'}]"
580,src/java/main/org/apache/zookeeper/server/ServerStats.java,"@@ -127,36 +129,45 @@ public String toString(){
         sb.append(""Mode: "" + getServerState() + ""\n"");
         return sb.toString();
     }
-    // mutators
-    synchronized void updateLatency(long requestCreateTime) {
-        long latency = Time.currentElapsedTime() - requestCreateTime;
-        totalLatency += latency;
-        count++;
-        if (latency < minLatency) {
-            minLatency = latency;
+
+    /**
+     * Update request statistic. This should only be called from a request
+     * that originated from that machine.
+     */
+    public void updateLatency(Request request, long currentTime) {","[{'comment': 'Why do you need to pass `currentTime` here?\r\nFor testing?', 'commenter': 'anmolnar'}, {'comment': ""Agree, we don't have to pass in the currentTime here, no test is calling this function."", 'commenter': 'lvfangmin'}, {'comment': '@jtuple Please remove `currentTime` from here.', 'commenter': 'anmolnar'}, {'comment': 'This is used for testing in both `ServerStatsTest.testLatencyMetrics()` and `ServerStatsTest.testReset()`.', 'commenter': 'jtuple'}]"
580,src/java/main/org/apache/zookeeper/server/quorum/Follower.java,"@@ -86,7 +89,13 @@ void followLeader() throws InterruptedException {
                             + "" is less than our accepted epoch "" + ZxidUtils.zxidToString(self.getAcceptedEpoch()));
                     throw new IOException(""Error: Epoch of leader is lower"");
                 }
-                syncWithLeader(newEpochZxid);                
+                long startTime = Time.currentElapsedTime();
+                try {
+                    syncWithLeader(newEpochZxid);
+                } finally {
+                    long syncTime = Time.currentElapsedTime() - startTime;
+                    ServerMetrics.FOLLOWER_SYNC_TIME.add(syncTime);","[{'comment': 'This will execute regardless of `syncWithLeader` succeeded or not. Should we only collect `syncTime` for the syncs that were successful? ', 'commenter': 'hanm'}]"
580,src/java/test/org/apache/zookeeper/server/ServerMetricsTest.java,"@@ -0,0 +1,91 @@
+package org.apache.zookeeper.server;","[{'comment': 'Please add Apache License Header to this file. Missing of the header causes release audit warnings like [this](https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/2181/artifact/patchprocess/patchReleaseAuditProblems.txt)', 'commenter': 'hanm'}]"
584,src/java/main/org/apache/zookeeper/server/DataTree.java,"@@ -478,7 +478,10 @@ public void createNode(final String path, byte data[], List<ACL> acl,
                 HashSet<String> list = ephemerals.get(ephemeralOwner);
                 if (list == null) {
                     list = new HashSet<String>();
-                    ephemerals.put(ephemeralOwner, list);
+                    HashSet<String> _list;","[{'comment': 'You can use `computeIfAbsent()` like this:\r\n```java\r\nHashSet<String> list = ephemerals.computeIfAbsent(ephemeralOwner, k -> new HashSet<String>());\r\n```', 'commenter': 'anmolnar'}, {'comment': ""we need synchronization to prevent znode changes while the znode is being snapshot to disk, but for request processing there is only a single thread that does mutations and mutations don't happen while read requests are being processed."", 'commenter': 'breed'}]"
584,src/java/main/org/apache/zookeeper/server/DataTree.java,"@@ -478,7 +478,10 @@ public void createNode(final String path, byte data[], List<ACL> acl,
                 HashSet<String> list = ephemerals.get(ephemeralOwner);
                 if (list == null) {
                     list = new HashSet<String>();
-                    ephemerals.put(ephemeralOwner, list);
+                    HashSet<String> _list;
+                    if ((_list = ephemerals.putIfAbsent(ephemeralOwner, list)) != null) {
+                        list = _list;
+                    }
                 }
                 synchronized (list) {","[{'comment': 'Even if when `createNode` is called by multi-thread.this fix is also not thread-safe.\r\nStep1:One thread has acquired the `list` lock and enters into L487,add a element into  `list`\r\nStep2:But at the same time just after Step1, another thread enters into L483,the reference of `list` is pointed to the old `_list` object. It will cause thread-unsafe\r\nBTW: **Breaking Bad** is the best U.S.TV series', 'commenter': 'maoling'}, {'comment': ""I'm not sure about that.\r\n\r\nephemerals.putIfAbsent() is thread safe: it guarantees that newly created instance will be added to the HashMap only if the key is associated with a null value. Otherwise you will get the instance already present in the HashMap.\r\nEither case `list` will point to the one and only instance present in the hashmap.\r\n\r\nIn your example when Step2 enters L483 it will get back the instance which was created and added to the HashMap by Step1 before it acquired the `list` lock. And that instance cannot be replaced in the HashMap with this code.\r\n\r\nAfter all `synchronized (list)` only guards access to the List, HashMap is guarded by putIfAbsent().\r\nI still believe that `computeIfAbsent()` is more convenient and readable here."", 'commenter': 'anmolnar'}, {'comment': ""@anmolnar \r\nI will test it with that unit test , using a 'threadpool' and create 1000000 nodes to reproduce what I guess。\r\nI wish I was wrong,but if i'm right ,you need to watch Breaking Bad series (smirk).\r\n\r\n"", 'commenter': 'maoling'}]"
590,build.xml,"@@ -119,6 +119,7 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
     <property name=""test.java.classes"" value=""${test.java.build.dir}/classes""/>
     <property name=""test.src.dir"" value=""${src.dir}/java/test""/>
     <property name=""systest.src.dir"" value=""${src.dir}/java/systest""/>
+    <property name=""bench.src.dir"" value=""${src.dir}/java/bench""/>","[{'comment': 'I think this new dir should be added to classpath of `eclipse` task too.', 'commenter': 'anmolnar'}, {'comment': 'Will do.', 'commenter': 'lvfangmin'}]"
590,src/java/main/org/apache/zookeeper/server/watch/WatchManager.java,"@@ -46,15 +48,26 @@
     private final Map<Watcher, Set<String>> watch2Paths =
         new HashMap<Watcher, Set<String>>();
 
-    synchronized int size(){
+    @Override
+    public synchronized int size(){
         int result = 0;
         for(Set<Watcher> watches : watchTable.values()) {
             result += watches.size();
         }
         return result;
     }
 
-    synchronized void addWatch(String path, Watcher watcher) {
+    boolean isDeadWatcher(Watcher watcher) {","[{'comment': ""Looks like this patch is not just an improvement, but it also fixes the edge case of adding dead watchers.\r\nPreviously stale client connections haven't been checked while registering watchers.\r\nIs that correct?"", 'commenter': 'anmolnar'}, {'comment': 'Yes, this also fixed the dead watch leaking issue in Watch Manager which was found when I was building the new optimized watch manager.', 'commenter': 'lvfangmin'}, {'comment': 'Taking that into account and the jira fix version, this patch will definitely go into 3.5 as well.', 'commenter': 'anmolnar'}]"
590,src/java/main/org/apache/zookeeper/server/watch/WatchManagerOptimized.java,"@@ -0,0 +1,355 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.watch;
+
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.BitSet;
+import java.util.HashSet;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Random;
+import java.util.Set;
+import java.util.Iterator;
+import java.lang.Iterable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.Watcher.Event.EventType;
+import org.apache.zookeeper.Watcher.Event.KeeperState;
+import org.apache.zookeeper.server.ServerCnxn;
+import org.apache.zookeeper.server.util.BitMap;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Optimized in memory and time complexity, compared to WatchManager, both the
+ * memory consumption and time complexity improved a lot, but it cannot
+ * efficiently remove the watcher when the session or socket is closed, for
+ * majority usecase this is not a problem.
+ *
+ * Changed made compared to WatchManager:
+ *
+ * - Use HashSet and BitSet to store the watchers to find a balance between
+ *   memory usage and time complexity
+ * - Use ReadWriteLock instead of synchronized to reduce lock retention
+ * - Lazily clean up the closed watchers
+ */
+public class WatchManagerOptimized
+        implements IWatchManager, DeadWatcherListener {
+
+    private static final Logger LOG =
+            LoggerFactory.getLogger(WatchManagerOptimized.class);
+
+    private final ConcurrentHashMap<String, BitHashSet> pathWatches =
+            new ConcurrentHashMap<String, BitHashSet>();
+
+    // watcher to bit id mapping
+    private final BitMap<Watcher> watcherBitIdMap = new BitMap<Watcher>();
+
+    // used to lazily remove the dead watchers
+    private final WatcherCleaner watcherCleaner;
+
+    private final ReentrantReadWriteLock addRemovePathRWLock = new ReentrantReadWriteLock();
+
+    public WatchManagerOptimized() {
+        watcherCleaner = new WatcherCleaner(this);
+        watcherCleaner.start();
+    }
+
+    @Override
+    public boolean addWatch(String path, Watcher watcher) {
+        boolean result = false;
+        addRemovePathRWLock.readLock().lock();
+        try {
+            // avoid race condition of adding a on flying dead watcher
+            if (isDeadWatcher(watcher)) {
+                LOG.debug(""Ignoring addWatch with closed cnxn"");
+            } else {
+                Integer bit = watcherBitIdMap.add(watcher);
+                BitHashSet watchers = pathWatches.get(path);
+                if (watchers == null) {
+                    watchers = new BitHashSet();
+                    BitHashSet existingWatchers = pathWatches.putIfAbsent(path, watchers);
+                    if (existingWatchers != null) {
+                        watchers = existingWatchers;
+                    }
+                }
+                result = watchers.add(bit);
+            }
+        } finally {
+            addRemovePathRWLock.readLock().unlock();
+        }
+        return result;
+    }
+
+    @Override
+    public boolean containsWatcher(String path, Watcher watcher) {
+        BitHashSet watchers = pathWatches.get(path);
+        if (watchers == null || !watchers.contains(watcherBitIdMap.getBit(watcher))) {
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public boolean removeWatcher(String path, Watcher watcher) {
+        addRemovePathRWLock.writeLock().lock();","[{'comment': ""Looks like it's consistent with `BitMap` implementation, so it's probably intentional that you don't do the same DCL optimisation as in the `add` method.\r\n\r\nWhy don't you check whether the Watcher is on the path before you acquire the write lock?"", 'commenter': 'anmolnar'}, {'comment': ""Actually, this is based on the scenario optimization, like cache hit, when user send removeWatcher request, it's more likely the watcher is actually exist and haven't fired yet, so instead of multiple read lock and API call to check exist then switch to write lock, it's actually cheaper to only call write lock once."", 'commenter': 'lvfangmin'}]"
590,src/java/main/org/apache/zookeeper/server/watch/WatchManagerOptimized.java,"@@ -0,0 +1,355 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.watch;
+
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.BitSet;
+import java.util.HashSet;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Random;
+import java.util.Set;
+import java.util.Iterator;
+import java.lang.Iterable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.Watcher.Event.EventType;
+import org.apache.zookeeper.Watcher.Event.KeeperState;
+import org.apache.zookeeper.server.ServerCnxn;
+import org.apache.zookeeper.server.util.BitMap;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Optimized in memory and time complexity, compared to WatchManager, both the
+ * memory consumption and time complexity improved a lot, but it cannot
+ * efficiently remove the watcher when the session or socket is closed, for
+ * majority usecase this is not a problem.
+ *
+ * Changed made compared to WatchManager:
+ *
+ * - Use HashSet and BitSet to store the watchers to find a balance between
+ *   memory usage and time complexity
+ * - Use ReadWriteLock instead of synchronized to reduce lock retention
+ * - Lazily clean up the closed watchers
+ */
+public class WatchManagerOptimized
+        implements IWatchManager, DeadWatcherListener {
+
+    private static final Logger LOG =
+            LoggerFactory.getLogger(WatchManagerOptimized.class);
+
+    private final ConcurrentHashMap<String, BitHashSet> pathWatches =
+            new ConcurrentHashMap<String, BitHashSet>();
+
+    // watcher to bit id mapping
+    private final BitMap<Watcher> watcherBitIdMap = new BitMap<Watcher>();
+
+    // used to lazily remove the dead watchers
+    private final WatcherCleaner watcherCleaner;
+
+    private final ReentrantReadWriteLock addRemovePathRWLock = new ReentrantReadWriteLock();
+
+    public WatchManagerOptimized() {
+        watcherCleaner = new WatcherCleaner(this);
+        watcherCleaner.start();
+    }
+
+    @Override
+    public boolean addWatch(String path, Watcher watcher) {
+        boolean result = false;
+        addRemovePathRWLock.readLock().lock();
+        try {
+            // avoid race condition of adding a on flying dead watcher
+            if (isDeadWatcher(watcher)) {
+                LOG.debug(""Ignoring addWatch with closed cnxn"");
+            } else {
+                Integer bit = watcherBitIdMap.add(watcher);
+                BitHashSet watchers = pathWatches.get(path);
+                if (watchers == null) {
+                    watchers = new BitHashSet();
+                    BitHashSet existingWatchers = pathWatches.putIfAbsent(path, watchers);
+                    if (existingWatchers != null) {
+                        watchers = existingWatchers;
+                    }
+                }
+                result = watchers.add(bit);
+            }
+        } finally {
+            addRemovePathRWLock.readLock().unlock();
+        }
+        return result;
+    }
+
+    @Override
+    public boolean containsWatcher(String path, Watcher watcher) {
+        BitHashSet watchers = pathWatches.get(path);
+        if (watchers == null || !watchers.contains(watcherBitIdMap.getBit(watcher))) {
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public boolean removeWatcher(String path, Watcher watcher) {
+        addRemovePathRWLock.writeLock().lock();
+        try {
+            BitHashSet list = pathWatches.get(path);
+            if (list == null || !list.remove(watcherBitIdMap.getBit(watcher))) {
+                return false;
+            }
+            if (list.isEmpty()) {
+                pathWatches.remove(path);
+            }
+            return true;
+        } finally {
+            addRemovePathRWLock.writeLock().unlock();
+        }
+    }
+
+    @Override
+    public void removeWatcher(Watcher watcher) {
+        Integer watcherBit;
+        addRemovePathRWLock.writeLock().lock();","[{'comment': 'Do you need to acquire write lock here?', 'commenter': 'anmolnar'}, {'comment': ""I need the exclusive lock with addWatch, otherwise addWatch may still add a dead watch which won't be cleaned up in the WatchCleaner when it started to clean up. "", 'commenter': 'lvfangmin'}, {'comment': 'In which case you need to move `addDeadWatcher()` call inside the critical block.', 'commenter': 'anmolnar'}, {'comment': 'Missed this comment last time, what we need here is that, as long as we called addDeadWatcher, there will be no watches added related with this dead watcher. Code executed after line 136 means the watcher will be marked as stale, after we release this lock, any on flying addWatcher for this dead watcher will be rejected, so it guarantees when we call addDeadWatcher there will be no race condition between removing and adding watch.\r\n\r\nAnd I need to move addDeadWatcher out of the locking block, since the WatchCleaner might block on it to avoid OOM issue if the cleaner cannot catch up of cleaning the dead watchers.', 'commenter': 'lvfangmin'}, {'comment': 'Where do you mark the watcher as stale inside the critical block?\r\nIt only calls a getter on the `BitIdMap`, right?', 'commenter': 'anmolnar'}, {'comment': ""In the caller of removeWatcher, which is in NIOServerCnxn.close and NettyServerCnxn.close.\r\n\r\nWhen the cnxn is closed, it will set stale before call removeCnxn on zkServer, which calls this function sequentially, if we grabbed this lock, it means the cnxn has been marked as stale.\r\n\r\nWe can explicitly setStale here as well, but I don't think that's necessary."", 'commenter': 'lvfangmin'}]"
590,src/java/main/org/apache/zookeeper/server/watch/WatchManagerOptimized.java,"@@ -0,0 +1,355 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.watch;
+
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.BitSet;
+import java.util.HashSet;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Random;
+import java.util.Set;
+import java.util.Iterator;
+import java.lang.Iterable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.Watcher.Event.EventType;
+import org.apache.zookeeper.Watcher.Event.KeeperState;
+import org.apache.zookeeper.server.ServerCnxn;
+import org.apache.zookeeper.server.util.BitMap;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Optimized in memory and time complexity, compared to WatchManager, both the
+ * memory consumption and time complexity improved a lot, but it cannot
+ * efficiently remove the watcher when the session or socket is closed, for
+ * majority usecase this is not a problem.
+ *
+ * Changed made compared to WatchManager:
+ *
+ * - Use HashSet and BitSet to store the watchers to find a balance between
+ *   memory usage and time complexity
+ * - Use ReadWriteLock instead of synchronized to reduce lock retention
+ * - Lazily clean up the closed watchers
+ */
+public class WatchManagerOptimized
+        implements IWatchManager, DeadWatcherListener {
+
+    private static final Logger LOG =
+            LoggerFactory.getLogger(WatchManagerOptimized.class);
+
+    private final ConcurrentHashMap<String, BitHashSet> pathWatches =
+            new ConcurrentHashMap<String, BitHashSet>();
+
+    // watcher to bit id mapping
+    private final BitMap<Watcher> watcherBitIdMap = new BitMap<Watcher>();
+
+    // used to lazily remove the dead watchers
+    private final WatcherCleaner watcherCleaner;
+
+    private final ReentrantReadWriteLock addRemovePathRWLock = new ReentrantReadWriteLock();
+
+    public WatchManagerOptimized() {
+        watcherCleaner = new WatcherCleaner(this);
+        watcherCleaner.start();
+    }
+
+    @Override
+    public boolean addWatch(String path, Watcher watcher) {
+        boolean result = false;
+        addRemovePathRWLock.readLock().lock();
+        try {
+            // avoid race condition of adding a on flying dead watcher
+            if (isDeadWatcher(watcher)) {
+                LOG.debug(""Ignoring addWatch with closed cnxn"");
+            } else {
+                Integer bit = watcherBitIdMap.add(watcher);
+                BitHashSet watchers = pathWatches.get(path);
+                if (watchers == null) {
+                    watchers = new BitHashSet();
+                    BitHashSet existingWatchers = pathWatches.putIfAbsent(path, watchers);
+                    if (existingWatchers != null) {
+                        watchers = existingWatchers;
+                    }
+                }
+                result = watchers.add(bit);
+            }
+        } finally {
+            addRemovePathRWLock.readLock().unlock();
+        }
+        return result;
+    }
+
+    @Override
+    public boolean containsWatcher(String path, Watcher watcher) {
+        BitHashSet watchers = pathWatches.get(path);
+        if (watchers == null || !watchers.contains(watcherBitIdMap.getBit(watcher))) {
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public boolean removeWatcher(String path, Watcher watcher) {
+        addRemovePathRWLock.writeLock().lock();
+        try {
+            BitHashSet list = pathWatches.get(path);
+            if (list == null || !list.remove(watcherBitIdMap.getBit(watcher))) {
+                return false;
+            }
+            if (list.isEmpty()) {
+                pathWatches.remove(path);
+            }
+            return true;
+        } finally {
+            addRemovePathRWLock.writeLock().unlock();
+        }
+    }
+
+    @Override
+    public void removeWatcher(Watcher watcher) {
+        Integer watcherBit;
+        addRemovePathRWLock.writeLock().lock();
+        try {
+            // do nothing if the watcher is not tracked
+            watcherBit = watcherBitIdMap.getBit(watcher);
+            if (watcherBit == null) {
+                return;
+            }
+        } finally {
+            addRemovePathRWLock.writeLock().unlock();
+        }
+        watcherCleaner.addDeadWatcher(watcherBit);
+    }
+
+    /**
+     * Entry for WatcherCleaner to remove dead watchers
+     *
+     * @param deadWatchers the watchers need to be removed
+     */
+    @Override
+    public void processDeadWatchers(Set<Integer> deadWatchers) {","[{'comment': ""Don't you need to acquire read lock from `addRemovePathRWLock` here?\r\nBoth Maps are being modified here and I think there's a possibility for race with `addWatch()` method."", 'commenter': 'anmolnar'}, {'comment': ""All the watchers being processed here are guaranteed to be dead, addWatch will return before it's changing the pathWatches and watcherBitIdMap, that's why I don't need the lock here."", 'commenter': 'lvfangmin'}]"
590,src/java/main/org/apache/zookeeper/server/watch/WatchManagerOptimized.java,"@@ -0,0 +1,355 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.watch;
+
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.BitSet;
+import java.util.HashSet;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Random;
+import java.util.Set;
+import java.util.Iterator;
+import java.lang.Iterable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.Watcher.Event.EventType;
+import org.apache.zookeeper.Watcher.Event.KeeperState;
+import org.apache.zookeeper.server.ServerCnxn;
+import org.apache.zookeeper.server.util.BitMap;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Optimized in memory and time complexity, compared to WatchManager, both the
+ * memory consumption and time complexity improved a lot, but it cannot
+ * efficiently remove the watcher when the session or socket is closed, for
+ * majority usecase this is not a problem.
+ *
+ * Changed made compared to WatchManager:
+ *
+ * - Use HashSet and BitSet to store the watchers to find a balance between
+ *   memory usage and time complexity
+ * - Use ReadWriteLock instead of synchronized to reduce lock retention
+ * - Lazily clean up the closed watchers
+ */
+public class WatchManagerOptimized
+        implements IWatchManager, DeadWatcherListener {
+
+    private static final Logger LOG =
+            LoggerFactory.getLogger(WatchManagerOptimized.class);
+
+    private final ConcurrentHashMap<String, BitHashSet> pathWatches =
+            new ConcurrentHashMap<String, BitHashSet>();
+
+    // watcher to bit id mapping
+    private final BitMap<Watcher> watcherBitIdMap = new BitMap<Watcher>();
+
+    // used to lazily remove the dead watchers
+    private final WatcherCleaner watcherCleaner;
+
+    private final ReentrantReadWriteLock addRemovePathRWLock = new ReentrantReadWriteLock();
+
+    public WatchManagerOptimized() {
+        watcherCleaner = new WatcherCleaner(this);
+        watcherCleaner.start();
+    }
+
+    @Override
+    public boolean addWatch(String path, Watcher watcher) {
+        boolean result = false;
+        addRemovePathRWLock.readLock().lock();
+        try {
+            // avoid race condition of adding a on flying dead watcher
+            if (isDeadWatcher(watcher)) {
+                LOG.debug(""Ignoring addWatch with closed cnxn"");
+            } else {
+                Integer bit = watcherBitIdMap.add(watcher);
+                BitHashSet watchers = pathWatches.get(path);
+                if (watchers == null) {
+                    watchers = new BitHashSet();
+                    BitHashSet existingWatchers = pathWatches.putIfAbsent(path, watchers);
+                    if (existingWatchers != null) {
+                        watchers = existingWatchers;
+                    }
+                }
+                result = watchers.add(bit);
+            }
+        } finally {
+            addRemovePathRWLock.readLock().unlock();
+        }
+        return result;
+    }
+
+    @Override
+    public boolean containsWatcher(String path, Watcher watcher) {
+        BitHashSet watchers = pathWatches.get(path);
+        if (watchers == null || !watchers.contains(watcherBitIdMap.getBit(watcher))) {
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public boolean removeWatcher(String path, Watcher watcher) {
+        addRemovePathRWLock.writeLock().lock();
+        try {
+            BitHashSet list = pathWatches.get(path);
+            if (list == null || !list.remove(watcherBitIdMap.getBit(watcher))) {
+                return false;
+            }
+            if (list.isEmpty()) {
+                pathWatches.remove(path);
+            }
+            return true;
+        } finally {
+            addRemovePathRWLock.writeLock().unlock();
+        }
+    }
+
+    @Override
+    public void removeWatcher(Watcher watcher) {
+        Integer watcherBit;
+        addRemovePathRWLock.writeLock().lock();
+        try {
+            // do nothing if the watcher is not tracked
+            watcherBit = watcherBitIdMap.getBit(watcher);
+            if (watcherBit == null) {
+                return;
+            }
+        } finally {
+            addRemovePathRWLock.writeLock().unlock();
+        }
+        watcherCleaner.addDeadWatcher(watcherBit);
+    }
+
+    /**
+     * Entry for WatcherCleaner to remove dead watchers
+     *
+     * @param deadWatchers the watchers need to be removed
+     */
+    @Override
+    public void processDeadWatchers(Set<Integer> deadWatchers) {
+        BitSet bits = new BitSet();
+        for (int dw: deadWatchers) {
+            bits.set(dw);
+        }
+        // The value iterator will reflect the state when it was
+        // created, don't need to synchronize.
+        for (BitHashSet watchers: pathWatches.values()) {
+            watchers.remove(deadWatchers, bits);
+        }
+        // Better to remove the empty path from pathWatches, but it will add
+        // lot of lock contention and affect the throughput of addWatch,
+        // let's rely on the triggerWatch to delete it.
+        for (Integer wbit: deadWatchers) {
+            watcherBitIdMap.remove(wbit);
+        }
+    }
+
+    @Override
+    public WatcherOrBitSet triggerWatch(String path, EventType type) {
+        return triggerWatch(path, type, null);
+    }
+
+    @Override
+    public WatcherOrBitSet triggerWatch(
+            String path, EventType type, WatcherOrBitSet supress) {
+        WatchedEvent e = new WatchedEvent(type, KeeperState.SyncConnected, path);
+
+        BitHashSet watchers = remove(path);
+        if (watchers == null) {
+            return null;
+        }
+
+        int triggeredWatches = 0;
+
+        // Avoid race condition between dead watcher cleaner in","[{'comment': ""I'm not sure if this comment is right. I can't see `WatcherCleaner` anywhere synchronize on the path's BitHashSet. Please correct me if I'm wrong."", 'commenter': 'anmolnar'}, {'comment': ""Sorry, I got it now.\r\nBitHashSet's remove method is synchronized, so the cleaner implicitly gets a lock on that."", 'commenter': 'anmolnar'}]"
590,src/java/main/org/apache/zookeeper/server/watch/WatchManagerFactory.java,"@@ -0,0 +1,48 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.watch;
+
+import java.io.IOException;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class WatchManagerFactory {","[{'comment': 'A quick javadoc would be awesome here.', 'commenter': 'anmolnar'}]"
590,src/java/main/org/apache/zookeeper/server/watch/DeadWatcherListener.java,"@@ -0,0 +1,31 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.watch;
+
+import java.util.Set;
+
+public interface DeadWatcherListener {","[{'comment': 'Please add a few words javadoc here.', 'commenter': 'anmolnar'}]"
590,src/java/main/org/apache/zookeeper/server/util/BitMap.java,"@@ -0,0 +1,121 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.util.Map;
+import java.util.HashMap;
+import java.util.BitSet;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+public class BitMap<T> {","[{'comment': ""I think a short javadoc similar to BitHashSet's would useful here."", 'commenter': 'anmolnar'}]"
590,src/java/main/org/apache/zookeeper/server/watch/WatchManagerOptimized.java,"@@ -0,0 +1,355 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.watch;
+
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.BitSet;
+import java.util.HashSet;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Random;
+import java.util.Set;
+import java.util.Iterator;
+import java.lang.Iterable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.Watcher.Event.EventType;
+import org.apache.zookeeper.Watcher.Event.KeeperState;
+import org.apache.zookeeper.server.ServerCnxn;
+import org.apache.zookeeper.server.util.BitMap;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Optimized in memory and time complexity, compared to WatchManager, both the
+ * memory consumption and time complexity improved a lot, but it cannot
+ * efficiently remove the watcher when the session or socket is closed, for
+ * majority usecase this is not a problem.
+ *
+ * Changed made compared to WatchManager:
+ *
+ * - Use HashSet and BitSet to store the watchers to find a balance between
+ *   memory usage and time complexity
+ * - Use ReadWriteLock instead of synchronized to reduce lock retention
+ * - Lazily clean up the closed watchers
+ */
+public class WatchManagerOptimized
+        implements IWatchManager, DeadWatcherListener {
+
+    private static final Logger LOG =
+            LoggerFactory.getLogger(WatchManagerOptimized.class);
+
+    private final ConcurrentHashMap<String, BitHashSet> pathWatches =
+            new ConcurrentHashMap<String, BitHashSet>();
+
+    // watcher to bit id mapping
+    private final BitMap<Watcher> watcherBitIdMap = new BitMap<Watcher>();
+
+    // used to lazily remove the dead watchers
+    private final WatcherCleaner watcherCleaner;
+
+    private final ReentrantReadWriteLock addRemovePathRWLock = new ReentrantReadWriteLock();
+
+    public WatchManagerOptimized() {
+        watcherCleaner = new WatcherCleaner(this);
+        watcherCleaner.start();
+    }
+
+    @Override
+    public boolean addWatch(String path, Watcher watcher) {
+        boolean result = false;
+        addRemovePathRWLock.readLock().lock();
+        try {
+            // avoid race condition of adding a on flying dead watcher
+            if (isDeadWatcher(watcher)) {
+                LOG.debug(""Ignoring addWatch with closed cnxn"");
+            } else {
+                Integer bit = watcherBitIdMap.add(watcher);
+                BitHashSet watchers = pathWatches.get(path);
+                if (watchers == null) {
+                    watchers = new BitHashSet();
+                    BitHashSet existingWatchers = pathWatches.putIfAbsent(path, watchers);
+                    if (existingWatchers != null) {
+                        watchers = existingWatchers;
+                    }
+                }
+                result = watchers.add(bit);
+            }
+        } finally {
+            addRemovePathRWLock.readLock().unlock();
+        }
+        return result;
+    }
+
+    @Override
+    public boolean containsWatcher(String path, Watcher watcher) {
+        BitHashSet watchers = pathWatches.get(path);
+        if (watchers == null || !watchers.contains(watcherBitIdMap.getBit(watcher))) {
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public boolean removeWatcher(String path, Watcher watcher) {
+        addRemovePathRWLock.writeLock().lock();
+        try {
+            BitHashSet list = pathWatches.get(path);
+            if (list == null || !list.remove(watcherBitIdMap.getBit(watcher))) {
+                return false;
+            }
+            if (list.isEmpty()) {
+                pathWatches.remove(path);
+            }
+            return true;
+        } finally {
+            addRemovePathRWLock.writeLock().unlock();
+        }
+    }
+
+    @Override
+    public void removeWatcher(Watcher watcher) {
+        Integer watcherBit;
+        addRemovePathRWLock.writeLock().lock();
+        try {
+            // do nothing if the watcher is not tracked
+            watcherBit = watcherBitIdMap.getBit(watcher);
+            if (watcherBit == null) {
+                return;
+            }
+        } finally {
+            addRemovePathRWLock.writeLock().unlock();
+        }
+        watcherCleaner.addDeadWatcher(watcherBit);
+    }
+
+    /**
+     * Entry for WatcherCleaner to remove dead watchers
+     *
+     * @param deadWatchers the watchers need to be removed
+     */
+    @Override
+    public void processDeadWatchers(Set<Integer> deadWatchers) {
+        BitSet bits = new BitSet();
+        for (int dw: deadWatchers) {
+            bits.set(dw);
+        }
+        // The value iterator will reflect the state when it was
+        // created, don't need to synchronize.
+        for (BitHashSet watchers: pathWatches.values()) {
+            watchers.remove(deadWatchers, bits);
+        }
+        // Better to remove the empty path from pathWatches, but it will add
+        // lot of lock contention and affect the throughput of addWatch,
+        // let's rely on the triggerWatch to delete it.
+        for (Integer wbit: deadWatchers) {
+            watcherBitIdMap.remove(wbit);
+        }
+    }
+
+    @Override
+    public WatcherOrBitSet triggerWatch(String path, EventType type) {
+        return triggerWatch(path, type, null);
+    }
+
+    @Override
+    public WatcherOrBitSet triggerWatch(
+            String path, EventType type, WatcherOrBitSet supress) {
+        WatchedEvent e = new WatchedEvent(type, KeeperState.SyncConnected, path);
+
+        BitHashSet watchers = remove(path);
+        if (watchers == null) {
+            return null;
+        }
+
+        int triggeredWatches = 0;
+
+        // Avoid race condition between dead watcher cleaner in
+        // WatcherCleaner and iterating here
+        synchronized (watchers) {
+            for (Integer wBit : watchers) {
+                if (supress != null && supress.contains(wBit)) {
+                    continue;
+                }
+
+                Watcher w = watcherBitIdMap.get(wBit);
+
+                // skip dead watcher
+                if (w == null || isDeadWatcher(w)) {
+                    continue;
+                }
+
+                w.process(e);","[{'comment': ""Not the scope of this PR, but I've found it surprising that `process()` is not guarded by try-catch. A single watcher could prevent others from triggering by throwing an exception?"", 'commenter': 'anmolnar'}, {'comment': ""NIOServerCnxn.process will catch all Exceptions, but Netty implementation only catches IOException, I agree it's safer to catch exception."", 'commenter': 'lvfangmin'}]"
590,src/java/test/org/apache/zookeeper/server/DumbWatcher.java,"@@ -0,0 +1,96 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.nio.ByteBuffer;
+import java.security.cert.Certificate;
+
+import org.apache.jute.Record;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.proto.ReplyHeader;
+
+public class DumbWatcher extends ServerCnxn {","[{'comment': 'Please consider using mockito.', 'commenter': 'anmolnar'}, {'comment': ""I agree from unit test case mock object is easier to maintain than stub ones, but I also need this DumbWatcher in the micro benchmark, I'll put this class somewhere in the code, so the micro benchmark and unit test can share it."", 'commenter': 'lvfangmin'}]"
590,src/test/java/bench/org/apache/zookeeper/BenchMain.java,"@@ -0,0 +1,12 @@
+package org.apache.zookeeper;","[{'comment': 'This file is missing apache license header. This triggers a -1 in last jenkins build.', 'commenter': 'hanm'}]"
590,src/java/main/org/apache/zookeeper/server/watch/IWatchManager.java,"@@ -0,0 +1,144 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.watch;
+
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.Watcher.Event.EventType;
+import org.apache.zookeeper.server.ServerCnxn;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;","[{'comment': 'Remove all imports here except these three since rest of those were not used (my guess is this file was copied pasted?)\r\n`\r\nimport java.io.PrintWriter;\r\nimport org.apache.zookeeper.Watcher;\r\nimport org.apache.zookeeper.Watcher.Event.EventType;\r\n`', 'commenter': 'hanm'}]"
590,src/java/main/org/apache/zookeeper/server/watch/IWatchManager.java,"@@ -0,0 +1,144 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.watch;
+
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.Watcher.Event.EventType;
+import org.apache.zookeeper.server.ServerCnxn;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public interface IWatchManager {
+
+    /**
+     * Add watch to specific path.
+     *
+     * @param path znode path
+     * @param watcher watcher object reference
+     *
+     * @return true if the watcher added is not already present
+     */
+    public boolean addWatch(String path, Watcher watcher);
+
+    /**
+     * Checks the specified watcher exists for the given path","[{'comment': 'nit: missing full stop at end of sentence.', 'commenter': 'hanm'}]"
590,src/java/main/org/apache/zookeeper/server/watch/IWatchManager.java,"@@ -0,0 +1,144 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.watch;
+
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.Watcher.Event.EventType;
+import org.apache.zookeeper.server.ServerCnxn;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public interface IWatchManager {
+
+    /**
+     * Add watch to specific path.
+     *
+     * @param path znode path
+     * @param watcher watcher object reference
+     *
+     * @return true if the watcher added is not already present
+     */
+    public boolean addWatch(String path, Watcher watcher);
+
+    /**
+     * Checks the specified watcher exists for the given path
+     *
+     * @param path znode path
+     * @param watcher watcher object reference
+     *
+     * @return true if the watcher exists, false otherwise
+     */
+    public boolean containsWatcher(String path, Watcher watcher);
+
+    /**
+     * Removes the specified watcher for the given path","[{'comment': 'nit: missing full stop at end of sentence.', 'commenter': 'hanm'}]"
590,src/java/main/org/apache/zookeeper/server/watch/IWatchManager.java,"@@ -0,0 +1,144 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.watch;
+
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.Watcher.Event.EventType;
+import org.apache.zookeeper.server.ServerCnxn;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public interface IWatchManager {
+
+    /**
+     * Add watch to specific path.
+     *
+     * @param path znode path
+     * @param watcher watcher object reference
+     *
+     * @return true if the watcher added is not already present
+     */
+    public boolean addWatch(String path, Watcher watcher);
+
+    /**
+     * Checks the specified watcher exists for the given path
+     *
+     * @param path znode path
+     * @param watcher watcher object reference
+     *
+     * @return true if the watcher exists, false otherwise
+     */
+    public boolean containsWatcher(String path, Watcher watcher);
+
+    /**
+     * Removes the specified watcher for the given path
+     *
+     * @param path znode path
+     * @param watcher watcher object reference
+     *
+     * @return true if the watcher successfully removed, false otherwise
+     */
+    public boolean removeWatcher(String path, Watcher watcher);
+
+    /**
+     * The entry to remove the watcher when the cnxn is closed.
+     *
+     * @param watcher watcher object reference
+     */
+    public void removeWatcher(Watcher watcher);
+
+    /**
+     * Distribute the watch event for the given path.
+     *
+     * @param path znode path
+     * @param type the watch event type
+     *
+     * @return the watchers have been notified
+     */
+    public WatcherOrBitSet triggerWatch(String path, EventType type);
+
+    /**
+     * Distribute the watch event for the given path, but ignore those
+     * supressed ones.","[{'comment': 'spell check: `suppressed` instead of`supressed`', 'commenter': 'hanm'}]"
590,src/java/main/org/apache/zookeeper/server/watch/IWatchManager.java,"@@ -0,0 +1,144 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.watch;
+
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.Watcher.Event.EventType;
+import org.apache.zookeeper.server.ServerCnxn;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public interface IWatchManager {
+
+    /**
+     * Add watch to specific path.
+     *
+     * @param path znode path
+     * @param watcher watcher object reference
+     *
+     * @return true if the watcher added is not already present
+     */
+    public boolean addWatch(String path, Watcher watcher);
+
+    /**
+     * Checks the specified watcher exists for the given path
+     *
+     * @param path znode path
+     * @param watcher watcher object reference
+     *
+     * @return true if the watcher exists, false otherwise
+     */
+    public boolean containsWatcher(String path, Watcher watcher);
+
+    /**
+     * Removes the specified watcher for the given path
+     *
+     * @param path znode path
+     * @param watcher watcher object reference
+     *
+     * @return true if the watcher successfully removed, false otherwise
+     */
+    public boolean removeWatcher(String path, Watcher watcher);
+
+    /**
+     * The entry to remove the watcher when the cnxn is closed.
+     *
+     * @param watcher watcher object reference
+     */
+    public void removeWatcher(Watcher watcher);
+
+    /**
+     * Distribute the watch event for the given path.
+     *
+     * @param path znode path
+     * @param type the watch event type
+     *
+     * @return the watchers have been notified
+     */
+    public WatcherOrBitSet triggerWatch(String path, EventType type);
+
+    /**
+     * Distribute the watch event for the given path, but ignore those
+     * supressed ones.
+     *
+     * @param path znode path
+     * @param type the watch event type
+     * @param supress the supressed watcher set
+     *
+     * @return the watchers have been notified
+     */
+    public WatcherOrBitSet triggerWatch(
+            String path, EventType type, WatcherOrBitSet supress);","[{'comment': 'similar spelling issue for `supress`', 'commenter': 'hanm'}]"
593,src/java/main/org/apache/zookeeper/server/SocketUtil.java,"@@ -0,0 +1,63 @@
+package org.apache.zookeeper.server;
+
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketAddress;
+import java.net.SocketException;
+import java.io.IOException;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class SocketUtil {
+
+    private static final Logger LOG = LoggerFactory.getLogger(SocketUtil.class);
+
+    public static final String NETWORK_BUFFER_SIZE = ""zookeeper.NetworkBufferSize"";
+    protected static int networkBufferSize;","[{'comment': 'all the Java system property starts with lowercase,so `zookeeper.networkBufferSize`(same with the document) is better?', 'commenter': 'maoling'}, {'comment': 'Yes, I realized that, our internal code is using uppercase, but I agree we should change it to keep consistent.', 'commenter': 'lvfangmin'}]"
593,src/java/test/org/apache/zookeeper/server/SocketUtilTest.java,"@@ -0,0 +1,46 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.net.Socket;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class SocketUtilTest {
+
+    @Test
+    public void testSetSocketBufferSize() throws Exception {
+        Socket s = new Socket();
+        int initSendBufferSize = s.getSendBufferSize();
+        int initReceiveBufferSize = s.getReceiveBufferSize();
+
+        // check buffer size won't be changed without set NETWORK_BUFFER_SIZE
+        SocketUtil.setSocketBufferSize(""test"", s);
+        Assert.assertEquals(initSendBufferSize, s.getSendBufferSize());
+        Assert.assertEquals(initReceiveBufferSize, s.getReceiveBufferSize());
+
+        // set NETWORK_BUFFER_SIZE
+        int networkBufferSize = 1024 * 1024;
+        SocketUtil.setNetworkBufferSize(networkBufferSize);
+        SocketUtil.setSocketBufferSize(""test"", s);
+        Assert.assertEquals(networkBufferSize, s.getSendBufferSize());
+        Assert.assertEquals(networkBufferSize, s.getReceiveBufferSize());","[{'comment': '`testSetSocketBufferSize` has failed due to Line 43,I guess it will also fail due to Line 36(no test)', 'commenter': 'maoling'}, {'comment': ""It passed on my local test, I'll double check and fix if it's failing."", 'commenter': 'lvfangmin'}]"
593,src/java/main/org/apache/zookeeper/server/SocketUtil.java,"@@ -0,0 +1,63 @@
+package org.apache.zookeeper.server;
+
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketAddress;
+import java.net.SocketException;
+import java.io.IOException;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class SocketUtil {
+
+    private static final Logger LOG = LoggerFactory.getLogger(SocketUtil.class);
+
+    public static final String NETWORK_BUFFER_SIZE = ""zookeeper.NetworkBufferSize"";
+    protected static int networkBufferSize;
+
+
+    static {
+        networkBufferSize = Integer.getInteger(NETWORK_BUFFER_SIZE, -1);
+        LOG.info(""{} = {}"", NETWORK_BUFFER_SIZE, networkBufferSize);
+    }","[{'comment': 'add a unit: `byte` in the log is better?', 'commenter': 'maoling'}]"
593,src/java/main/org/apache/zookeeper/server/SocketUtil.java,"@@ -0,0 +1,63 @@
+package org.apache.zookeeper.server;","[{'comment': 'Please add Apache License Header - the Jenkins build will also fail if missing.', 'commenter': 'nkalmar'}, {'comment': 'Thanks, will do.', 'commenter': 'lvfangmin'}]"
593,zookeeper-docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -1641,6 +1641,24 @@ server.3=zoo3:2888:3888</programlisting>
                 Default is ""10000"".</para>
             </listitem>
           </varlistentry>
+
+          <varlistentry>
+            <term>networkBufferSize</term>
+
+            <listitem>
+              <para>(Java system property: zookeeper.<emphasis
+                      role=""bold"">networkBufferSize</emphasis>)</para>
+
+              <para><emphasis role=""bold"">New in 3.6.0:</emphasis>
+                Sets the socket send and receive buffer size between leader","[{'comment': ""nit: buffer size in bytes\r\n\r\nit probably should be obvious, but it's worth being extra clear.\r\n"", 'commenter': 'breed'}]"
593,src/java/main/org/apache/zookeeper/server/SocketUtil.java,"@@ -13,18 +31,18 @@
 ","[{'comment': 'some useless import?', 'commenter': 'maoling'}]"
593,src/java/test/org/apache/zookeeper/server/SocketUtilTest.java,"@@ -37,7 +37,7 @@ public void testSetSocketBufferSize() throws Exception {
         Assert.assertEquals(initReceiveBufferSize, s.getReceiveBufferSize());
 
         // set NETWORK_BUFFER_SIZE
-        int networkBufferSize = 1024 * 1024;
+        int networkBufferSize = 32 * 1024;
         SocketUtil.setNetworkBufferSize(networkBufferSize);
         SocketUtil.setSocketBufferSize(""test"", s);","[{'comment': 'Although it passed the test,but When do regression,it will also be a flaky(you can see it by hitting it again and again).\r\ncould you plz look at it?', 'commenter': 'maoling'}]"
605,src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -452,7 +452,7 @@ public void testElectionFraud() throws IOException, InterruptedException {
         Assert.assertTrue(""falseLeader never rejoins the quorum"", foundFollowing);
     }
 
-    private void waitForOne(ZooKeeper zk, States state) throws InterruptedException {","[{'comment': 'this are in the other change, so we are going to have to re-resolve depending on which one goes in.', 'commenter': 'breed'}, {'comment': ""@breed This is based on current master branch, we don't have dependency as far as I know, so it should be ready to go in. \r\n\r\n(sorry for the lately reply, just came back from vocation)"", 'commenter': 'lvfangmin'}]"
605,src/java/test/org/apache/zookeeper/server/quorum/FuzzySnapshotRelatedTest.java,"@@ -0,0 +1,254 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import javax.security.sasl.SaslException;
+
+import org.apache.jute.OutputArchive;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.ZooKeeper.States;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.server.DataNode;
+import org.apache.zookeeper.server.DataTree;
+import org.apache.zookeeper.server.ZKDatabase;
+import org.apache.zookeeper.server.ZooKeeperServer;
+import org.apache.zookeeper.test.ClientBase;
+
+import org.junit.Assert;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Test cases used to catch corner cases due to fuzzy snapshot.
+ */
+public class FuzzySnapshotRelatedTest extends QuorumPeerTestBase {
+
+    private static final Logger LOG = LoggerFactory.getLogger(FuzzySnapshotRelatedTest.class);
+
+    MainThread[] mt = null;
+    ZooKeeper[] zk = null;
+    int leaderId;
+    int followerA;
+
+    @Before
+    public void setup() throws Exception {","[{'comment': 'I see this initialization logic pretty much everywhere in unit tests. Do you think we can do some clever code sharing here with (for example) `QuorumPeerMainTest.java`? Private method `LaunchServers` does the same thing as far as I could see.', 'commenter': 'anmolnar'}, {'comment': 'The main difference is that I need to pass in Customized QuorumPeer to hook events in ZK, there might be something in common, like how we generate the connection string, we may do some refactor later, but I prefer to do that separately since we also need to touch other tests who may have similar logics.', 'commenter': 'lvfangmin'}]"
605,src/java/test/org/apache/zookeeper/server/quorum/FuzzySnapshotRelatedTest.java,"@@ -162,6 +167,98 @@ public void process(String path) {
                 new String(zk[followerA].getData(node2, null, null)));
     }
 
+    /**
+     * It's possibel during SNAP sync, the parent is serialized before the
+     * child get deleted during sending the snapshot over.
+     *
+     * In which case, we need to make sure the pzxid get correctly updated
+     * when applying the txns received.
+     */
+    @Test
+    public void testPZxidUpdatedDuringSnapSyncing() throws Exception {
+        LOG.info(""Enable force snapshot sync"");
+        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, ""true"");
+
+        final String parent = ""/testPZxidUpdatedWhenDeletingNonExistNode"";
+        final String child = parent + ""/child"";
+        createEmptyNode(zk[leaderId], parent);
+        createEmptyNode(zk[leaderId], child);
+
+        LOG.info(""shutdown follower {}"", followerA);
+        mt[followerA].shutdown();
+        QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);
+
+        LOG.info(""Set up ZKDatabase to catch the node serializing in DataTree"");
+        addSerializeListener(leaderId, parent, child);
+
+        LOG.info(""Restart follower A to trigger a SNAP sync with leader"");
+        mt[followerA].start();
+        QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);
+
+        LOG.info(""Check and make sure the pzxid of the parent is the same "" +
+                ""on leader and follower A"");
+        compareStat(parent, leaderId, followerA);
+    }
+
+    /**
+     * It's possible during taking fuzzy snapshot, the parent is serialized
+     * before the child get deleted in the fuzzy range.
+     *
+     * In which case, we need to make sure the pzxid get correctly updated
+     * when replaying the txns.
+     */
+    @Test
+    public void testPZxidUpdatedWhenLoadingSnapshot() throws Exception {
+
+        final String parent = ""/testPZxidUpdatedDuringTakingSnapshot"";
+        final String child = parent + ""/child"";
+        createEmptyNode(zk[followerA], parent);
+        createEmptyNode(zk[followerA], child);
+
+        LOG.info(""Set up ZKDatabase to catch the node serializing in DataTree"");
+        addSerializeListener(followerA, parent, child);
+
+        LOG.info(""Take snapshot on follower A"");
+        ZooKeeperServer zkServer = mt[followerA].main.quorumPeer.getActiveServer();
+        zkServer.takeSnapshot(true);
+
+        LOG.info(""Restarting follower A to load snapshot"");
+        mt[followerA].shutdown();
+        mt[followerA].start();
+        QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);
+
+        LOG.info(""Check and make sure the pzxid of the parent is the same "" +
+                ""on leader and follower A"");
+        compareStat(parent, leaderId, followerA);
+    }
+
+    private void addSerializeListener(int sid, String parent, String child) {
+        final ZooKeeper zkClient = zk[followerA];
+        CustomDataTree dt =
+                (CustomDataTree) mt[sid].main.quorumPeer.getZkDb().getDataTree();
+        dt.addListener(parent, new NodeSerializeListener() {
+            @Override
+            public void nodeSerialized(String path) {
+                try {
+                    zkClient.delete(child, -1);
+                    LOG.info(""Deleted the child node after the parent is serialized"");
+                } catch (Exception e) {
+                    LOG.error(""Error when deleting node {}"", e);
+                }
+            }
+        });
+    }
+
+    private void compareStat(String path, int sid, int compareWithSid) throws Exception{
+        Stat stat1 = new Stat();
+        zk[sid].getData(path, null, stat1);
+
+        Stat stat2 = new Stat();
+        zk[compareWithSid].getData(path, null, stat2);","[{'comment': '@lvfangmin we should add a try catch with retry here around `ConnectionLossException`. I noticed this when checking the flaky test dashboard. See one failure [example](https://builds.apache.org/job/ZooKeeper-trunk/198/testReport/junit/org.apache.zookeeper.server.quorum/FuzzySnapshotRelatedTest/testPZxidUpdatedWhenLoadingSnapshot/)', 'commenter': 'hanm'}, {'comment': 'something like this (we should make a utility out of this)\r\n\r\n`for (int j = 0; j < 30; j++) {\r\n            try {\r\n                zk[compareWithSid].getData(path, null, stat2);\r\n            } catch (KeeperException.ConnectionLossException e) {\r\n                if (j < 29) {\r\n                    Thread.sleep(1000);\r\n                } else {\r\n                    Assert.fail(""fail to get data ......"");\r\n                }\r\n            }\r\n        }\r\n`', 'commenter': 'hanm'}]"
613,zookeeper-docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -2273,7 +2273,7 @@ server.3=zoo3:2888:3888</programlisting>
           $ bin/zkTxnLogToolkit.sh
 
           usage: TxnLogToolkit [-dhrv] txn_log_file_name
-          -d,--dump      Dump mode. Dump all entries of the log file. (this is the default)
+          -d,--dump      Dump mode. Dump all entries of the log file with printing the content of a nodepath (default)","[{'comment': 'This change is documentation only. Please update the help message as well.', 'commenter': 'anmolnar'}]"
615,src/java/main/org/apache/zookeeper/server/util/LogChopper.java,"@@ -0,0 +1,152 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server.util;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.server.persistence.FileHeader;
+import org.apache.zookeeper.server.persistence.FileTxnLog;
+import org.apache.zookeeper.txn.TxnHeader;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.EOFException;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.zip.Adler32;
+import java.util.zip.Checksum;
+
+/**
+ * this class will chop the log at the specified zxid
+ */
+public class LogChopper {
+    public static void main(String args[]) {
+        if (args.length != 3) {
+            System.out.println(""Usage: LogChopper zxid_to_chop_to txn_log_to_chop chopped_filename"");
+            System.out.println(""    this program will read the txn_log_to_chop file and copy all the transactions"");
+            System.out.println(""    from it up to (and including) the given zxid into chopped_filename."");
+            System.exit(1);
+        }
+        long zxid = Long.decode(args[0]);
+        String txnLog = args[1];
+        String choppedLog = args[2];
+
+        int rc = 2;","[{'comment': 'We have recently added `ExitCode` enum, maybe use those for exit code?', 'commenter': 'hanm'}]"
615,src/java/main/org/apache/zookeeper/server/util/LogChopper.java,"@@ -0,0 +1,152 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server.util;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.server.persistence.FileHeader;
+import org.apache.zookeeper.server.persistence.FileTxnLog;
+import org.apache.zookeeper.txn.TxnHeader;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.EOFException;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.zip.Adler32;
+import java.util.zip.Checksum;
+
+/**
+ * this class will chop the log at the specified zxid
+ */
+public class LogChopper {
+    public static void main(String args[]) {
+        if (args.length != 3) {
+            System.out.println(""Usage: LogChopper zxid_to_chop_to txn_log_to_chop chopped_filename"");
+            System.out.println(""    this program will read the txn_log_to_chop file and copy all the transactions"");
+            System.out.println(""    from it up to (and including) the given zxid into chopped_filename."");
+            System.exit(1);
+        }
+        long zxid = Long.decode(args[0]);","[{'comment': 'Should we move this into the following try block so it can catch parse exception if the zxid passed is not valid (e.g. not a number)?', 'commenter': 'hanm'}]"
615,src/java/main/org/apache/zookeeper/server/util/LogChopper.java,"@@ -0,0 +1,152 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server.util;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.server.persistence.FileHeader;
+import org.apache.zookeeper.server.persistence.FileTxnLog;
+import org.apache.zookeeper.txn.TxnHeader;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.EOFException;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.zip.Adler32;
+import java.util.zip.Checksum;
+
+/**
+ * this class will chop the log at the specified zxid
+ */
+public class LogChopper {
+    public static void main(String args[]) {
+        if (args.length != 3) {
+            System.out.println(""Usage: LogChopper zxid_to_chop_to txn_log_to_chop chopped_filename"");
+            System.out.println(""    this program will read the txn_log_to_chop file and copy all the transactions"");
+            System.out.println(""    from it up to (and including) the given zxid into chopped_filename."");
+            System.exit(1);
+        }
+        long zxid = Long.decode(args[0]);
+        String txnLog = args[1];
+        String choppedLog = args[2];
+
+        int rc = 2;
+        try (
+            InputStream is = new BufferedInputStream(new FileInputStream(txnLog));
+            OutputStream os = new BufferedOutputStream(new FileOutputStream(choppedLog))
+        ) {
+            if (chop(is, os, zxid)) {
+                rc = 0;
+            }
+        } catch (Exception e) {
+            System.out.println(""Got exception: "" + e.getMessage());
+        }
+        System.exit(rc);
+    }
+
+    public static boolean chop(InputStream is, OutputStream os, long zxid) throws IOException {
+        BinaryInputArchive logStream = BinaryInputArchive.getArchive(is);
+        BinaryOutputArchive choppedStream = BinaryOutputArchive.getArchive(os);
+        FileHeader fhdr = new FileHeader();
+        fhdr.deserialize(logStream, ""fileheader"");
+
+        if (fhdr.getMagic() != FileTxnLog.TXNLOG_MAGIC) {
+            System.err.println(""Invalid magic number in txn log file"");
+            return false;
+        }
+        System.out.println(""ZooKeeper Transactional Log File with dbid ""
+                + fhdr.getDbid() + "" txnlog format version ""
+                + fhdr.getVersion());
+
+        fhdr.serialize(choppedStream, ""fileheader"");
+        int count = 0;
+        boolean hasZxid = false;
+        long previousZxid = -1;
+        while (true) {
+            long crcValue;
+            byte[] bytes;
+            try {
+                crcValue = logStream.readLong(""crcvalue"");
+
+                bytes = logStream.readBuffer(""txnEntry"");
+            } catch (EOFException e) {
+                System.out.println(""EOF reached after "" + count + "" txns."");
+                // returning false because nothing was chopped
+                return false;
+            }
+            if (bytes.length == 0) {
+                // Since we preallocate, we define EOF to be an
+                // empty transaction
+                System.out.println(""EOF reached after "" + count + "" txns."");
+                // returning false because nothing was chopped
+                return false;
+            }
+
+            Checksum crc = new Adler32();
+            crc.update(bytes, 0, bytes.length);
+            if (crcValue != crc.getValue()) {
+                throw new IOException(""CRC doesn't match "" + crcValue +
+                        "" vs "" + crc.getValue());
+            }
+            TxnHeader hdr = new TxnHeader();
+            Record txn = SerializeUtils.deserializeTxn(bytes, hdr);
+            if (logStream.readByte(""EOR"") != 'B') {
+                System.out.println(""Last transaction was partial."");
+                throw new EOFException(""Last transaction was partial."");
+            }
+
+            long txnZxid = hdr.getZxid();
+            if (txnZxid == zxid) {
+                hasZxid = true;
+            }
+
+            // logging the gap to make the inconsistency investigation easier
+            if (previousZxid != -1 && txnZxid != previousZxid + 1) {
+                long txnEpoch = ZxidUtils.getEpochFromZxid(txnZxid);
+                long txnCounter = ZxidUtils.getCounterFromZxid(txnZxid);
+                long previousEpoch = ZxidUtils.getEpochFromZxid(previousZxid);
+                if (txnEpoch == previousEpoch || txnCounter != 1) {
+                    System.out.println(
+                        String.format(""There is gap between %x and %x"",
+                                previousZxid, txnZxid));
+                }
+            }
+            previousZxid = txnZxid;
+
+            if (hdr.getZxid() > zxid) {","[{'comment': '`hdr.getZxid()` is previously assigned to `txnZxid`, so maybe use `txnZxid` here instead? \r\n\r\nAlso, would it be better to move this check before the gap detection logic to terminate earlier?', 'commenter': 'hanm'}, {'comment': ""I'd like to leave this check after the gap detection. This covers the one scenario where there is a gap in the log that the target zxid just happens to fall in. Otherwise the operator will only learn that the target is not in the log, not that/why the log is corrupt."", 'commenter': 'enixon'}]"
615,src/java/main/org/apache/zookeeper/server/util/LogChopper.java,"@@ -0,0 +1,152 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server.util;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.server.persistence.FileHeader;
+import org.apache.zookeeper.server.persistence.FileTxnLog;
+import org.apache.zookeeper.txn.TxnHeader;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.EOFException;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.zip.Adler32;
+import java.util.zip.Checksum;
+
+/**
+ * this class will chop the log at the specified zxid
+ */
+public class LogChopper {
+    public static void main(String args[]) {
+        if (args.length != 3) {
+            System.out.println(""Usage: LogChopper zxid_to_chop_to txn_log_to_chop chopped_filename"");
+            System.out.println(""    this program will read the txn_log_to_chop file and copy all the transactions"");
+            System.out.println(""    from it up to (and including) the given zxid into chopped_filename."");
+            System.exit(1);
+        }
+        long zxid = Long.decode(args[0]);
+        String txnLog = args[1];
+        String choppedLog = args[2];
+
+        int rc = 2;
+        try (
+            InputStream is = new BufferedInputStream(new FileInputStream(txnLog));
+            OutputStream os = new BufferedOutputStream(new FileOutputStream(choppedLog))
+        ) {
+            if (chop(is, os, zxid)) {
+                rc = 0;
+            }
+        } catch (Exception e) {
+            System.out.println(""Got exception: "" + e.getMessage());
+        }
+        System.exit(rc);
+    }
+
+    public static boolean chop(InputStream is, OutputStream os, long zxid) throws IOException {
+        BinaryInputArchive logStream = BinaryInputArchive.getArchive(is);
+        BinaryOutputArchive choppedStream = BinaryOutputArchive.getArchive(os);
+        FileHeader fhdr = new FileHeader();
+        fhdr.deserialize(logStream, ""fileheader"");
+
+        if (fhdr.getMagic() != FileTxnLog.TXNLOG_MAGIC) {
+            System.err.println(""Invalid magic number in txn log file"");
+            return false;
+        }
+        System.out.println(""ZooKeeper Transactional Log File with dbid ""
+                + fhdr.getDbid() + "" txnlog format version ""
+                + fhdr.getVersion());
+
+        fhdr.serialize(choppedStream, ""fileheader"");
+        int count = 0;
+        boolean hasZxid = false;
+        long previousZxid = -1;
+        while (true) {
+            long crcValue;
+            byte[] bytes;
+            try {
+                crcValue = logStream.readLong(""crcvalue"");
+
+                bytes = logStream.readBuffer(""txnEntry"");
+            } catch (EOFException e) {
+                System.out.println(""EOF reached after "" + count + "" txns."");
+                // returning false because nothing was chopped
+                return false;
+            }
+            if (bytes.length == 0) {
+                // Since we preallocate, we define EOF to be an
+                // empty transaction
+                System.out.println(""EOF reached after "" + count + "" txns."");
+                // returning false because nothing was chopped
+                return false;
+            }
+
+            Checksum crc = new Adler32();
+            crc.update(bytes, 0, bytes.length);
+            if (crcValue != crc.getValue()) {
+                throw new IOException(""CRC doesn't match "" + crcValue +
+                        "" vs "" + crc.getValue());
+            }
+            TxnHeader hdr = new TxnHeader();
+            Record txn = SerializeUtils.deserializeTxn(bytes, hdr);
+            if (logStream.readByte(""EOR"") != 'B') {
+                System.out.println(""Last transaction was partial."");
+                throw new EOFException(""Last transaction was partial."");
+            }
+
+            long txnZxid = hdr.getZxid();
+            if (txnZxid == zxid) {
+                hasZxid = true;
+            }
+
+            // logging the gap to make the inconsistency investigation easier
+            if (previousZxid != -1 && txnZxid != previousZxid + 1) {
+                long txnEpoch = ZxidUtils.getEpochFromZxid(txnZxid);
+                long txnCounter = ZxidUtils.getCounterFromZxid(txnZxid);
+                long previousEpoch = ZxidUtils.getEpochFromZxid(previousZxid);
+                if (txnEpoch == previousEpoch || txnCounter != 1) {","[{'comment': 'Would it be better if we print more targeted diagnostic information here for both conditions, instead of reuse a single error message? For example:\r\n* Log gap between txns of the same epoch.\r\n* Log gap of the new epoch (from 1 to txnCounter)\r\nMight make it more easier to debug log.', 'commenter': 'hanm'}]"
615,src/java/main/org/apache/zookeeper/server/util/LogChopper.java,"@@ -0,0 +1,152 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server.util;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.server.persistence.FileHeader;
+import org.apache.zookeeper.server.persistence.FileTxnLog;
+import org.apache.zookeeper.txn.TxnHeader;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.EOFException;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.zip.Adler32;
+import java.util.zip.Checksum;
+
+/**
+ * this class will chop the log at the specified zxid
+ */
+public class LogChopper {","[{'comment': 'This is public, so it needs to be annotated with interface annotation.\r\nSee https://github.com/apache/zookeeper/commit/0cb4011dac7ec28637426cafd98b4f8f299ef61d#diff-40373c146f7f620581c943009c8b796f', 'commenter': 'hanm'}]"
624,src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumMaj.java,"@@ -83,7 +83,7 @@ public QuorumMaj(Properties props) throws ConfigException {
             String key = entry.getKey().toString();
             String value = entry.getValue().toString();
 
-            if (key.startsWith(""server."")) {
+            if (key.startsWith(""server."") && !key.startsWith(""server.id"")) {","[{'comment': 'Maybe key.equals(server.id)', 'commenter': 'eolivelli'}]"
624,zookeeper-docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -265,18 +266,25 @@ server.3=zoo3:2888:3888</programlisting>
           role=""bold"">server.id=host:port:port</emphasis>. The parameters <emphasis
           role=""bold"">host</emphasis> and <emphasis
           role=""bold"">port</emphasis> are straightforward. You attribute the
-          server id to each machine by creating a file named
+          server id to each machine by setting <emphasis role=""bold"">server.id</emphasis>
+          to a unique integer for each zookeeper server.To keep backwards compatibility,
+          you can still creat a file named","[{'comment': ""nit - spelling 'create'"", 'commenter': 'enixon'}, {'comment': 'we should also talk about the importance of not changing the id since it becomes much easier with the configuration file option. we should have documented that anyway, but it becomes much more important with this change since the id is decoupled from the data.', 'commenter': 'breed'}]"
624,zookeeper-docs/src/documentation/content/xdocs/zookeeperAdmin.xml,"@@ -265,18 +266,25 @@ server.3=zoo3:2888:3888</programlisting>
           role=""bold"">server.id=host:port:port</emphasis>. The parameters <emphasis
           role=""bold"">host</emphasis> and <emphasis
           role=""bold"">port</emphasis> are straightforward. You attribute the
-          server id to each machine by creating a file named
+          server id to each machine by setting <emphasis role=""bold"">server.id</emphasis>
+          to a unique integer for each zookeeper server.To keep backwards compatibility,
+          you can still creat a file named
           <filename>myid</filename>, one for each server, which resides in
           that server's data directory, as specified by the configuration file
-          parameter <emphasis role=""bold"">dataDir</emphasis>.</para></listitem>
+          parameter <emphasis role=""bold"">dataDir</emphasis>.If the unique id is both set in the
+          server.id of zoo.cfg and myid file,the server.id has the priority","[{'comment': 'i think we should return an error in this case. this will make debugging problems that result from this situation hard.', 'commenter': 'breed'}]"
629,src/java/main/org/apache/zookeeper/server/ServerStats.java,"@@ -54,9 +57,10 @@ synchronized public long getMinLatency() {
         return minLatency == Long.MAX_VALUE ? 0 : minLatency;
     }
 
-    synchronized public long getAvgLatency() {
+    synchronized public double getAvgLatency() {
         if (count != 0) {
-            return totalLatency / count;
+            String avgLatency = df.format((double)totalLatency / count);
+            return Double.parseDouble(avgLatency);","[{'comment': ""Why don't you this way ?\r\nreturn totalLatency *1.0 / count\r\n\r\nUsing format/parse is costly and it can lead to unexpected results, expecially with floating point values"", 'commenter': 'eolivelli'}, {'comment': '@eolivelli totalLatency *1.0 / count will get e.g 0.7649024988323213 (too long),but I want to that the results tally up to four decimal places e.g 0.7649', 'commenter': 'maoling'}, {'comment': 'You should perform the division and the return a string fornatted with a max number of decimal digits.\r\n\r\nOr you can calculate the value as integer with some trick\r\nLike\r\nreturn ( totalLatency *100 / count) / 100.0', 'commenter': 'eolivelli'}]"
629,src/java/test/org/apache/zookeeper/server/ServerStatsTest.java,"@@ -61,7 +62,7 @@ public void testPacketsMetrics() {
         assertAllPacketsZero(serverStats);
 
     }
-
+    ","[{'comment': 'nit: remove tailing white space.', 'commenter': 'lvfangmin'}]"
629,src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java,"@@ -819,7 +819,7 @@ public void commandRun() {
             }
         }
 
-        private void print(String key, long number) {
+        private void print(String key, Object number) {","[{'comment': ""It's better to override print with double number, which will be more efficient, as we don't need to cast all the numbers to Object while printing the metrics."", 'commenter': 'lvfangmin'}]"
629,src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -599,7 +599,7 @@ public void commandRun() {
             }
         }
 
-        private void print(String key, long number) {
+        private void print(String key, Object number) {","[{'comment': 'Same here.', 'commenter': 'lvfangmin'}]"
629,src/java/main/org/apache/zookeeper/server/ServerStats.java,"@@ -35,7 +35,7 @@
     private long totalLatency = 0;
     private long count = 0;
     private AtomicLong fsyncThresholdExceedCount = new AtomicLong(0);
-
+    ","[{'comment': 'nit: remove tailing white space.', 'commenter': 'lvfangmin'}, {'comment': 'Sorry for mention this again, but I think removing the tailing white space will make the code cleaner.', 'commenter': 'lvfangmin'}, {'comment': ""@lvfangmin seems that it doesn't have any tailing space?Am I missing something?"", 'commenter': 'maoling'}]"
629,src/java/main/org/apache/zookeeper/server/ServerStats.java,"@@ -53,10 +53,11 @@ public ServerStats(Provider provider) {
     synchronized public long getMinLatency() {
         return minLatency == Long.MAX_VALUE ? 0 : minLatency;
     }
-
-    synchronized public long getAvgLatency() {
+    
+    synchronized public double getAvgLatency() {
         if (count != 0) {
-            return totalLatency / count;
+            //be account to four decimal places
+            return (totalLatency * 10000 / count) / 10000.0;","[{'comment': 'The findbugs is complaining about integral division result, should change it to:\r\n\r\n`return (totalLatency * 10000.0 / count) / 10000.0;`\r\n  ', 'commenter': 'lvfangmin'}, {'comment': '@lvfangmin I test it in my local and find no complain（findbugs version 3.0.1）\r\nwhere can I find the warnings?', 'commenter': 'maoling'}, {'comment': '@maoling here is the link: \r\n\r\nhttps://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/2198/artifact/build/test/findbugs/newPatchFindbugsWarnings.html', 'commenter': 'lvfangmin'}]"
629,src/java/main/org/apache/zookeeper/server/ServerStats.java,"@@ -53,10 +54,13 @@ public ServerStats(Provider provider) {
     synchronized public long getMinLatency() {
         return minLatency == Long.MAX_VALUE ? 0 : minLatency;
     }
-
-    synchronized public long getAvgLatency() {
+    
+    synchronized public double getAvgLatency() {
         if (count != 0) {
-            return totalLatency / count;
+            //be account to four decimal places
+            double avgLatency = totalLatency / (double)count;
+            BigDecimal bg = new BigDecimal(avgLatency);","[{'comment': ""This is accurate, but not sure how heavy it is and will it affect the performance or not. But I think we're not calling this a lot, so it should be fine."", 'commenter': 'lvfangmin'}, {'comment': '@lvfangmin \r\nthis method is only called in  CLI (e.g when exec mntr),so don not worry about the performance', 'commenter': 'maoling'}, {'comment': ""For us, we call mntr to export metrics to the reporting system, and it's being periodically called in other tools as well, but still it's not called that often (< 20/min), so should be fine."", 'commenter': 'lvfangmin'}]"
630,src/java/test/org/apache/zookeeper/ZKUtilTest.java,"@@ -0,0 +1,88 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assume.assumeTrue;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.UUID;
+
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class ZKUtilTest {
+    private static final File testData = new File(System.getProperty(""test.data.dir"", ""build/test/data""));
+
+    @BeforeClass
+    public static void init() {
+        testData.mkdirs();
+    }
+
+    @Test
+    public void testValidateFileInput() throws IOException {
+        File file = File.createTempFile(""test"", "".junit"", testData);
+        file.deleteOnExit();
+        String absolutePath = file.getAbsolutePath();
+        String error = ZKUtil.validateFileInput(absolutePath);
+        assertNull(error);
+    }
+
+    @Test
+    public void testValidateFileInputNotExist() {
+        String fileName = UUID.randomUUID().toString();
+        File file = new File(testData, fileName);
+        String absolutePath = file.getAbsolutePath();
+        String error = ZKUtil.validateFileInput(absolutePath);
+        assertNotNull(error);
+        String expectedMessage = ""File '"" + absolutePath + ""' does not exist."";
+        assertEquals(expectedMessage, error);
+    }
+
+    @Test
+    public void testValidateFileInputDirectory() throws Exception {
+        File file = File.createTempFile(""test"", "".junit"", testData);
+        file.deleteOnExit();
+        // delete file, as we need directory not file
+        file.delete();
+        file.mkdir();
+        String absolutePath = file.getAbsolutePath();
+        String error = ZKUtil.validateFileInput(absolutePath);
+        assertNotNull(error);
+        String expectedMessage = ""'"" + absolutePath + ""' is a direcory. it must be a file."";
+        assertEquals(expectedMessage, error);
+    }
+
+    @Test
+    public void testUnreadableFileInput() throws Exception {
+        //skip this test on Windows, coverage on Linux
+        assumeTrue(!org.apache.zookeeper.Shell.WINDOWS);
+        File file = File.createTempFile(""test"", "".junit"", testData);
+        file.setReadable(false, false);
+        file.deleteOnExit();","[{'comment': 'Why not an explicit delete ?', 'commenter': 'eolivelli'}, {'comment': '@eolivelli \r\nfile.deleteOnExit() will delete the file after JVM exit.it is equivalent to file.delete() at the end.\r\nso we should not worry about this.', 'commenter': 'maoling'}, {'comment': ""Personally I don't like  File#deleteOnExit because it is not clear when it will take effect, and it is clearer to have an explicit file.delete when the file is not needed anymore.\r\n\r\nIn this case, for this simple test, I have no strong objection.\r\n\r\nThe best solution would be to use JUnit TemporaryFolder Rule.\r\n\r\n"", 'commenter': 'eolivelli'}]"
647,src/java/main/org/apache/zookeeper/server/DataTree.java,"@@ -527,6 +527,24 @@ public void deleteNode(String path, long zxid)
         int lastSlash = path.lastIndexOf('/');
         String parentName = path.substring(0, lastSlash);
         String childName = path.substring(lastSlash + 1);
+
+        // The child might already be deleted during taking fuzzy snapshot,
+        // but we still need to update the pzxid here before throw exception
+        // for no such child
+        DataNode parent = nodes.get(parentName);
+        if (parent == null) {
+            throw new KeeperException.NoNodeException();
+        }
+        synchronized (parent) {
+            parent.removeChild(childName);
+            // Only update pzxid when the zxid is larger than the current pzxid,
+            // otherwise we might override higher pzxid set by a following create 
+            // Txn, which could cause the cversion and pzxid inconsistent
+            if (zxid > parent.stat.getPzxid()) {","[{'comment': ""Looks like this is the fix you're talking about and which will be fixed separately in 3.6. Is that correct?"", 'commenter': 'anmolnar'}, {'comment': ""This is a new bug I found recently, the previous change in ZOOKEEPER-3125 has a bug which could revert pzxid. Given it's a known issue in that Jira, I think it's reasonable to fix it in the same patch here before porting back to 3.5."", 'commenter': 'lvfangmin'}]"
647,src/java/test/org/apache/zookeeper/server/DataTreeTest.java,"@@ -153,6 +153,31 @@ public void testIncrementCversion() throws Exception {
                 (newCversion == prevCversion + 1 && newPzxid == prevPzxid + 1));
     }
 
+    @Test
+    public void testPzxidUpdatedWhenDeletingNonExistNode() throws Exception {","[{'comment': 'This new test is also part of the fix.', 'commenter': 'anmolnar'}]"
647,src/java/test/org/apache/zookeeper/server/quorum/FuzzySnapshotRelatedTest.java,"@@ -162,6 +167,98 @@ public void process(String path) {
                 new String(zk[followerA].getData(node2, null, null)));
     }
 
+    /**
+     * It's possibel during SNAP sync, the parent is serialized before the
+     * child get deleted during sending the snapshot over.
+     *
+     * In which case, we need to make sure the pzxid get correctly updated
+     * when applying the txns received.
+     */
+    @Test
+    public void testPZxidUpdatedDuringSnapSyncing() throws Exception {
+        LOG.info(""Enable force snapshot sync"");
+        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, ""true"");
+
+        final String parent = ""/testPZxidUpdatedWhenDeletingNonExistNode"";
+        final String child = parent + ""/child"";
+        createEmptyNode(zk[leaderId], parent);
+        createEmptyNode(zk[leaderId], child);
+
+        LOG.info(""shutdown follower {}"", followerA);
+        mt[followerA].shutdown();
+        QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);
+
+        LOG.info(""Set up ZKDatabase to catch the node serializing in DataTree"");
+        addSerializeListener(leaderId, parent, child);
+
+        LOG.info(""Restart follower A to trigger a SNAP sync with leader"");
+        mt[followerA].start();
+        QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);
+
+        LOG.info(""Check and make sure the pzxid of the parent is the same "" +
+                ""on leader and follower A"");
+        compareStat(parent, leaderId, followerA);
+    }
+
+    /**
+     * It's possible during taking fuzzy snapshot, the parent is serialized
+     * before the child get deleted in the fuzzy range.
+     *
+     * In which case, we need to make sure the pzxid get correctly updated
+     * when replaying the txns.
+     */
+    @Test
+    public void testPZxidUpdatedWhenLoadingSnapshot() throws Exception {
+
+        final String parent = ""/testPZxidUpdatedDuringTakingSnapshot"";
+        final String child = parent + ""/child"";
+        createEmptyNode(zk[followerA], parent);
+        createEmptyNode(zk[followerA], child);
+
+        LOG.info(""Set up ZKDatabase to catch the node serializing in DataTree"");
+        addSerializeListener(followerA, parent, child);
+
+        LOG.info(""Take snapshot on follower A"");
+        ZooKeeperServer zkServer = mt[followerA].main.quorumPeer.getActiveServer();
+        zkServer.takeSnapshot();
+
+        LOG.info(""Restarting follower A to load snapshot"");
+        mt[followerA].shutdown();
+        mt[followerA].start();
+        QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);
+
+        LOG.info(""Check and make sure the pzxid of the parent is the same "" +
+                ""on leader and follower A"");
+        compareStat(parent, leaderId, followerA);
+    }
+
+    private void addSerializeListener(int sid, String parent, String child) {
+        final ZooKeeper zkClient = zk[followerA];
+        CustomDataTree dt =
+                (CustomDataTree) mt[sid].main.quorumPeer.getZkDb().getDataTree();
+        dt.addListener(parent, new NodeSerializeListener() {
+            @Override
+            public void nodeSerialized(String path) {
+                try {
+                    zkClient.delete(child, -1);
+                    LOG.info(""Deleted the child node after the parent is serialized"");
+                } catch (Exception e) {
+                    LOG.error(""Error when deleting node {}"", e);
+                }
+            }
+        });
+    }
+
+    private void compareStat(String path, int sid, int compareWithSid) throws Exception {
+        Stat stat1 = new Stat();
+        zk[sid].getData(path, null, stat1);
+
+        Stat stat2 = new Stat();
+        zk[compareWithSid].getData(path, null, stat2);","[{'comment': ""@hanm mentioned a flaky test issue related to this part:\r\nhttps://github.com/apache/zookeeper/pull/605/files#r219628119\r\nI don't see answer in the original PR, how are you dealing with the problem?"", 'commenter': 'anmolnar'}, {'comment': ""I made a comment on that before sending this diff out, I was trying to hear the opinion before making the test change here. Seems we agreed on not using RetryRule, I'll improve this test class."", 'commenter': 'lvfangmin'}]"
648,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -990,6 +992,27 @@ private void sendPing() {
         private boolean saslLoginFailed = false;
 
         private void startConnect(InetSocketAddress addr) throws IOException {
+            boolean canonicalize = true;
+            try {
+                canonicalize = Boolean.parseBoolean(System.getProperty(ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, ""true""));
+            } catch (IllegalArgumentException ea) {
+                //ignored ...
+            }
+
+            if (canonicalize) {","[{'comment': 'You only want to do this if SASL client is enabled. Hence the name of the switch contains `sasl.client`. ', 'commenter': 'anmolnar'}]"
648,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -990,6 +992,27 @@ private void sendPing() {
         private boolean saslLoginFailed = false;
 
         private void startConnect(InetSocketAddress addr) throws IOException {
+            boolean canonicalize = true;
+            try {
+                canonicalize = Boolean.parseBoolean(System.getProperty(ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, ""true""));
+            } catch (IllegalArgumentException ea) {
+                //ignored ...
+            }
+
+            if (canonicalize) {
+                try {
+                    InetAddress ia = addr.getAddress();
+                    LOG.warn(""ia {}"", ia);","[{'comment': 'Debugging?', 'commenter': 'anmolnar'}]"
648,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -990,6 +992,27 @@ private void sendPing() {
         private boolean saslLoginFailed = false;
 
         private void startConnect(InetSocketAddress addr) throws IOException {
+            boolean canonicalize = true;
+            try {
+                canonicalize = Boolean.parseBoolean(System.getProperty(ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, ""true""));
+            } catch (IllegalArgumentException ea) {
+                //ignored ...
+            }
+
+            if (canonicalize) {
+                try {
+                    InetAddress ia = addr.getAddress();
+                    LOG.warn(""ia {}"", ia);
+                    if (ia == null) {
+                        ia = InetAddress.getByName(addr.getHostName());","[{'comment': 'If the original address is unresolved, you should throw exception immediately. That means HostProvider already tried to resolve the address, but failed. No point trying it again here.', 'commenter': 'anmolnar'}]"
648,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -990,6 +992,27 @@ private void sendPing() {
         private boolean saslLoginFailed = false;
 
         private void startConnect(InetSocketAddress addr) throws IOException {
+            boolean canonicalize = true;
+            try {
+                canonicalize = Boolean.parseBoolean(System.getProperty(ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, ""true""));
+            } catch (IllegalArgumentException ea) {
+                //ignored ...
+            }
+
+            if (canonicalize) {
+                try {
+                    InetAddress ia = addr.getAddress();
+                    LOG.warn(""ia {}"", ia);
+                    if (ia == null) {
+                        ia = InetAddress.getByName(addr.getHostName());
+                    }
+                    String host = (ia != null) ? ia.getCanonicalHostName() : addr.getHostName();
+                    addr = new InetSocketAddress(InetAddress.getByAddress(host, ia.getAddress()), addr.getPort());","[{'comment': 'I\'m thinking of how much value does it have to replace the address with the canonicalized version for the entire client. We might want to implement this strictly and only for `ZooKeeperSaslClient`.\r\n\r\nI\'d rather move this logic to the creation of `ZooKeeperSaslClient`. \r\n\r\nSomething like:\r\n```java\r\nzooKeeperSaslClient =  new ZooKeeperSaslClient(principalUserName + ""/"" + canonicalize ? addr.getAddress().getCanonicalHostName() : addr.getHostName());\r\n```', 'commenter': 'anmolnar'}, {'comment': 'I put it here because there is a possible race.  The entire reason we have the setup we do is so that we can change the nodes in the cluster without changing the config on the client side.  If the code that establishes the connection uses a different address from the code that creates the principal there is the possibility, because of the magic of DNS caching, that the connection would be made to a different box from the one the SASL client is expecting.  If that happens, and we have the default Client section in the jaas conf, it will not result in an error.  Instead the ZK client logs something about SASL failed and still connects but is not authorized to do anything.  If it failed and retried a different node I would be happy to move it, but it does not and that failure would not be transparent to the end user.', 'commenter': 'revans2'}, {'comment': 'But you said that we already have the IP address, which is what it is going to use, so never mind, it should be fine.', 'commenter': 'revans2'}]"
648,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -997,12 +999,31 @@ private void startConnect(InetSocketAddress addr) throws IOException {
             setName(getName().replaceAll(""\\(.*\\)"",
                     ""("" + addr.getHostName() + "":"" + addr.getPort() + "")""));
             if (ZooKeeperSaslClient.isEnabled()) {
+                String hostName = addr.getHostName();
+
+                boolean canonicalize = true;
+                try {
+                    canonicalize = Boolean.parseBoolean(System.getProperty(ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, ""true""));
+                } catch (IllegalArgumentException ea) {
+                    //ignored ...
+                }
+
+                if (canonicalize) {
+                    InetAddress ia = addr.getAddress();
+                    if (ia == null) {
+                        throw new IllegalArgumentException(""Connection address should have already been resolved by the HostProvider."");
+                    }
+                    //Update the actual address so we are
+                    hostName = ia.getCanonicalHostName();
+                    LOG.debug(""Canonicalized address to {}"", hostName);","[{'comment': 'Nit: if LOG.isDebugEnabled', 'commenter': 'eolivelli'}, {'comment': '+1', 'commenter': 'anmolnar'}]"
648,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -997,12 +999,31 @@ private void startConnect(InetSocketAddress addr) throws IOException {
             setName(getName().replaceAll(""\\(.*\\)"",
                     ""("" + addr.getHostName() + "":"" + addr.getPort() + "")""));
             if (ZooKeeperSaslClient.isEnabled()) {
+                String hostName = addr.getHostName();
+
+                boolean canonicalize = true;
+                try {
+                    canonicalize = Boolean.parseBoolean(System.getProperty(ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, ""true""));
+                } catch (IllegalArgumentException ea) {
+                    //ignored ...
+                }
+
+                if (canonicalize) {
+                    InetAddress ia = addr.getAddress();
+                    if (ia == null) {
+                        throw new IllegalArgumentException(""Connection address should have already been resolved by the HostProvider."");","[{'comment': ""Would you please change this to something like 'Unable to canonicalize address {}, because it's not resolveable'?"", 'commenter': 'anmolnar'}]"
648,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -997,12 +999,31 @@ private void startConnect(InetSocketAddress addr) throws IOException {
             setName(getName().replaceAll(""\\(.*\\)"",
                     ""("" + addr.getHostName() + "":"" + addr.getPort() + "")""));
             if (ZooKeeperSaslClient.isEnabled()) {
+                String hostName = addr.getHostName();
+
+                boolean canonicalize = true;
+                try {
+                    canonicalize = Boolean.parseBoolean(System.getProperty(ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, ""true""));
+                } catch (IllegalArgumentException ea) {
+                    //ignored ...
+                }
+
+                if (canonicalize) {
+                    InetAddress ia = addr.getAddress();
+                    if (ia == null) {
+                        throw new IllegalArgumentException(""Connection address should have already been resolved by the HostProvider."");
+                    }
+                    //Update the actual address so we are
+                    hostName = ia.getCanonicalHostName();","[{'comment': 'You might want to do the following:\r\n```java\r\nString canonicalHostName = ia.getCanonicalHostName();\r\nif (!canonicalHostName.equals(ia.getHostAddress())) {\r\n    hostName = canonicalHostName;\r\n}\r\n```\r\n\r\nIn order to avoid using literal IP address when security check fails.', 'commenter': 'anmolnar'}]"
650,src/java/main/org/apache/zookeeper/cli/SetAclCommand.java,"@@ -35,10 +37,11 @@
     {
         options.addOption(""s"", false, ""stats"");
         options.addOption(""v"", true, ""version"");
+        options.addOption(""R"", false, ""recursive"");
     }
 
     public SetAclCommand() {
-        super(""setAcl"", ""[-s] [-v version] path acl"");
+        super(""setAcl"", ""[-s] [-v version] [-R] path acl"");
     }","[{'comment': '[-R recursive] is better?', 'commenter': 'maoling'}, {'comment': ""Since we don't have it for [-s] either, I think it's more consistent to keep [-R]."", 'commenter': 'tamaashu'}, {'comment': '- Since there is no documentation about setAcl,so the more detailed, the better.\r\n- ""[-s stat] [-v version] [-R recursive] path acl""', 'commenter': 'maoling'}, {'comment': ""It is a parameter of option 'v', not description about what option 'v' is.\r\ne.g. setAcl -v 5 /path/a ****, means set acl to specific znode's 5th version. \r\n"", 'commenter': 'Reidddddd'}, {'comment': 'And thanks for the code pointer.', 'commenter': 'Reidddddd'}, {'comment': 'oops!I was wrong.', 'commenter': 'maoling'}]"
650,src/java/main/org/apache/zookeeper/cli/SetAclCommand.java,"@@ -69,9 +72,22 @@ public boolean exec() throws CliException {
             version = -1;
         }
         try {
-            Stat stat = zk.setACL(path, acl, version);
-            if (cl.hasOption(""s"")) {
-                new StatPrinter(out).print(stat);
+            if (cl.hasOption(""R"")) {
+                ZKUtil.visitSubTreeDFS(zk, path, false, new StringCallback() {
+                    @Override
+                    public void processResult(int rc, String path, Object ctx, String name) {","[{'comment': 'It’s better to avoid overriding the path variable here. ', 'commenter': 'lvfangmin'}]"
650,src/java/main/org/apache/zookeeper/cli/SetAclCommand.java,"@@ -69,9 +72,22 @@ public boolean exec() throws CliException {
             version = -1;
         }
         try {
-            Stat stat = zk.setACL(path, acl, version);
-            if (cl.hasOption(""s"")) {
-                new StatPrinter(out).print(stat);
+            if (cl.hasOption(""R"")) {
+                ZKUtil.visitSubTreeDFS(zk, path, false, new StringCallback() {
+                    @Override
+                    public void processResult(int rc, String path, Object ctx, String name) {
+                        try {
+                            zk.setACL(path, acl, version);
+                        } catch (KeeperException | InterruptedException e) {
+                            out.print(e.getMessage());
+                        }
+                    }
+                });
+            } else {
+                Stat stat = zk.setACL(path, acl, version);
+                if (cl.hasOption(""s"")) {","[{'comment': 'Does that mean -s and -R is exclusive with watch other? \r\n\r\nIf yes, maybe we should add it to the description, otherwise we should implement this in -R as well.', 'commenter': 'lvfangmin'}, {'comment': ""Unfortunately we don't have documentation for the CLI. It would be useful to start one either on wiki, in docs or implement a more detailed help page, but I don't want to overload this PR.\r\nWhat if we just add a more detailed javadoc to the class?"", 'commenter': 'anmolnar'}]"
650,src/java/test/org/apache/zookeeper/ZooKeeperTest.java,"@@ -566,4 +566,25 @@ public void testLsrNonexistantZnodeCommand() throws Exception {
             Assert.assertEquals(KeeperException.Code.NONODE, ((KeeperException)e.getCause()).code());
         }
     }
+
+    public void testSetAclRecursive() throws Exception {
+        final ZooKeeper zk = createClient();
+        final byte[] EMPTY = new byte[0];
+
+        zk.setData(""/"", EMPTY, -1);
+        zk.create(""/a"", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+        zk.create(""/a/b"", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+        zk.create(""/a/b/c"", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+        zk.create(""/a/d"", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+
+        ZooKeeperMain zkMain = new ZooKeeperMain(zk);
+        String setAclCommand = ""setAcl -R /a world:anyone:r"";
+        zkMain.cl.parseCommand(setAclCommand);
+        Assert.assertFalse(zkMain.processZKCmd(zkMain.cl));
+
+        Assert.assertEquals(zk.getACL(""/a"", new Stat()), Ids.READ_ACL_UNSAFE);","[{'comment': 'Parameter order should be the other way around, right?\r\nExpected value first, the actual second.\r\nA short description would also be useful.', 'commenter': 'anmolnar'}]"
650,src/java/test/org/apache/zookeeper/ZooKeeperTest.java,"@@ -566,4 +566,25 @@ public void testLsrNonexistantZnodeCommand() throws Exception {
             Assert.assertEquals(KeeperException.Code.NONODE, ((KeeperException)e.getCause()).code());
         }
     }
+
+    public void testSetAclRecursive() throws Exception {
+        final ZooKeeper zk = createClient();","[{'comment': '@Test?', 'commenter': 'maoling'}]"
650,src/java/main/org/apache/zookeeper/cli/SetAclCommand.java,"@@ -19,12 +19,17 @@
 
 import java.util.List;
 import org.apache.commons.cli.*;
+import org.apache.zookeeper.AsyncCallback.StringCallback;
 import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.ZKUtil;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
 
 /**
- * setAcl command for cli
+ * setAcl command for cli.
+ * Available options are s for printing znode's stats, v for set version of znode(s), R for
+ * recursive setting. User can combine v and R options together, but not s and R considering the
+ * number of znodes could be large.","[{'comment': 'Thanks for adding the description for this.', 'commenter': 'lvfangmin'}]"
652,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -1102,7 +1103,32 @@ private void startConnect(InetSocketAddress addr) throws IOException {
         private String getServerPrincipal(InetSocketAddress addr) {
             String principalUserName = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_USERNAME,
                     ZKClientConfig.ZK_SASL_CLIENT_USERNAME_DEFAULT);
-            String serverPrincipal = principalUserName + ""/"" + addr.getHostString();
+            String hostName = addr.getHostName();
+
+            boolean canonicalize = true;
+            try {
+                canonicalize = Boolean.parseBoolean(System.getProperty(ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME,","[{'comment': ""Isn't it clientConfig instead of System ?"", 'commenter': 'eolivelli'}, {'comment': 'Great point, missed that on the port.', 'commenter': 'revans2'}]"
652,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -793,7 +794,87 @@ public RWServerFoundException(String msg) {
             super(msg);
         }
     }
-    
+
+    static class MockableInetSocketAddress {
+        private final InetSocketAddress addr;
+
+        MockableInetSocketAddress(InetSocketAddress addr) {
+            this.addr = addr;
+        }
+
+        public String getHostName() {
+            return addr.getHostName();
+        }
+
+        public MockableInetAddress getAddress() {
+            InetAddress ia = addr.getAddress();
+            return ia == null ? null : new MockableInetAddress(ia);
+        }
+
+        @Override
+        public String toString() {
+            return addr.toString();
+        }
+    }
+
+    static class MockableInetAddress {
+        private final InetAddress ia;
+
+        MockableInetAddress(InetAddress ia) {
+            this.ia = ia;
+        }
+
+        public String getCanonicalHostName() {
+            return ia.getCanonicalHostName();
+        }
+
+        public String getHostAddress() {
+            return ia.getHostAddress();
+        }
+
+        @Override
+        public String toString() {
+            return ia.toString();
+        }
+    }
+    /**
+     * Get the name of the server principal for a SASL client.  This is visible for testing purposes.
+     * @param addr the address of the host.
+     * @param clientConfig the configuration for the client.
+     * @return the name of the principal.
+     */
+    static String getServerPrincipal(MockableInetSocketAddress addr, ZKClientConfig clientConfig) {
+        String principalUserName = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_USERNAME,
+            ZKClientConfig.ZK_SASL_CLIENT_USERNAME_DEFAULT);
+        String hostName = addr.getHostName();
+
+        boolean canonicalize = true;
+        try {
+            canonicalize = Boolean.parseBoolean(clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME,
+                ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME_DEFAULT));
+        } catch (IllegalArgumentException ea) {","[{'comment': 'Should we print the log when IllegalArgumentException throws? ', 'commenter': 'lvfangmin'}, {'comment': 'IllegalArgumentException is thrown when you pass an empty string to `getProperty()` which is not going to happen, because we use a constant value for that, but must be caught according to Java. ', 'commenter': 'anmolnar'}, {'comment': 'The IllegalArgumentException is coming from the `Boolean.parseBoolean`.  If it cannot understand the value as either true or false it will throw the exception and we end up with it being true, the default.  If you want a log I am happy to add it, because ""no"" will be interpreted as true, which might be confusing.', 'commenter': 'revans2'}, {'comment': ""I don't see any of these methods (parseBoolean() and getProperty()) throw IllegalArgumentException, so you don't need to catch here.\r\n\r\nIn your original PR, you used System.getProperty() which throws it:\r\nhttps://github.com/apache/zookeeper/pull/648/files#diff-ae38c175a23a47be52ae31ed1f1518a3R781\r\n\r\nBut this is master and we use ZKConfig here."", 'commenter': 'anmolnar'}, {'comment': '`Boolean.parseBoolean()` returns true if the string is ""true"" (ignore case) and false otherwise. No exception thrown.', 'commenter': 'anmolnar'}]"
652,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -793,7 +794,87 @@ public RWServerFoundException(String msg) {
             super(msg);
         }
     }
-    
+
+    static class MockableInetSocketAddress {","[{'comment': ""It's adding too much complexity to the code in order to test it, are we able to create the stub to extend the InetSocketAddress in the test case itself?"", 'commenter': 'lvfangmin'}, {'comment': ""I agree. Unfortunately methods of `InetSocketAddress` and `InetAddress` are final and cannot be mocked. There's a Mockito extension which could help, but it's quite recent and an opt-in feature:\r\nhttps://github.com/mockito/mockito/wiki/What's-new-in-Mockito-2#mock-the-unmockable-opt-in-mocking-of-final-classesmethods\r\n\r\nImplementing wrapper classes is good approach, but I wouldn't put them into `ClientCnxn.java`. I suggest creating a new file with wrapper classes (nit: renaming them to \\*Wrapper instead of Mockable\\* would be better) and also put `getServerPrincipal()` into this file as well. "", 'commenter': 'anmolnar'}]"
652,src/java/test/org/apache/zookeeper/ClientCanonicalizeTest.java,"@@ -0,0 +1,59 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper;
+
+import java.io.IOException;
+import org.apache.zookeeper.client.ZKClientConfig;
+import org.junit.Assert;
+import org.junit.Test;
+
+import static org.mockito.Mockito.*;","[{'comment': 'Please avoid using asterisk import.', 'commenter': 'anmolnar'}]"
652,src/java/test/org/apache/zookeeper/ClientCanonicalizeTest.java,"@@ -0,0 +1,59 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper;
+
+import java.io.IOException;
+import org.apache.zookeeper.client.ZKClientConfig;
+import org.junit.Assert;
+import org.junit.Test;
+
+import static org.mockito.Mockito.*;
+
+public class ClientCanonicalizeTest extends ZKTestCase {
+    @Test
+    public void testClientCanonicalization() throws IOException, InterruptedException {
+        ClientCnxn.MockableInetSocketAddress addr = mock(ClientCnxn.MockableInetSocketAddress.class);
+        ClientCnxn.MockableInetAddress ia = mock(ClientCnxn.MockableInetAddress.class);
+
+        when(addr.getHostName()).thenReturn(""zookeeper.apache.org"");
+        when(addr.getAddress()).thenReturn(ia);
+        when(ia.getCanonicalHostName()).thenReturn(""zk1.apache.org"");
+        when(ia.getHostAddress()).thenReturn(""127.0.0.1"");
+
+        ZKClientConfig conf = new ZKClientConfig();
+        String principal = ClientCnxn.getServerPrincipal(addr, conf);
+        Assert.assertEquals(""zookeeper/zk1.apache.org"", principal);","[{'comment': 'Please add some comment to the assert to describe the scenario when it fails.', 'commenter': 'anmolnar'}]"
652,src/java/test/org/apache/zookeeper/ClientCanonicalizeTest.java,"@@ -0,0 +1,59 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper;
+
+import java.io.IOException;
+import org.apache.zookeeper.client.ZKClientConfig;
+import org.junit.Assert;
+import org.junit.Test;
+
+import static org.mockito.Mockito.*;
+
+public class ClientCanonicalizeTest extends ZKTestCase {
+    @Test
+    public void testClientCanonicalization() throws IOException, InterruptedException {
+        ClientCnxn.MockableInetSocketAddress addr = mock(ClientCnxn.MockableInetSocketAddress.class);
+        ClientCnxn.MockableInetAddress ia = mock(ClientCnxn.MockableInetAddress.class);
+
+        when(addr.getHostName()).thenReturn(""zookeeper.apache.org"");
+        when(addr.getAddress()).thenReturn(ia);
+        when(ia.getCanonicalHostName()).thenReturn(""zk1.apache.org"");
+        when(ia.getHostAddress()).thenReturn(""127.0.0.1"");
+
+        ZKClientConfig conf = new ZKClientConfig();
+        String principal = ClientCnxn.getServerPrincipal(addr, conf);
+        Assert.assertEquals(""zookeeper/zk1.apache.org"", principal);
+    }
+
+    @Test
+    public void testClientNoCanonicalization() throws IOException, InterruptedException {
+        ClientCnxn.MockableInetSocketAddress addr = mock(ClientCnxn.MockableInetSocketAddress.class);
+        ClientCnxn.MockableInetAddress ia = mock(ClientCnxn.MockableInetAddress.class);
+
+        when(addr.getHostName()).thenReturn(""zookeeper.apache.org"");
+        when(addr.getAddress()).thenReturn(ia);
+        when(ia.getCanonicalHostName()).thenReturn(""zk1.apache.org"");
+        when(ia.getHostAddress()).thenReturn(""127.0.0.1"");
+
+        //when(addr.get)
+        ZKClientConfig conf = new ZKClientConfig();
+        conf.setProperty(ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, ""false"");
+        String principal = ClientCnxn.getServerPrincipal(addr, conf);
+        Assert.assertEquals(""zookeeper/zookeeper.apache.org"", principal);","[{'comment': 'Same here.', 'commenter': 'anmolnar'}]"
652,src/java/main/org/apache/zookeeper/ClientCnxn.java,"@@ -793,7 +794,87 @@ public RWServerFoundException(String msg) {
             super(msg);
         }
     }
-    
+
+    static class MockableInetSocketAddress {
+        private final InetSocketAddress addr;
+
+        MockableInetSocketAddress(InetSocketAddress addr) {
+            this.addr = addr;
+        }
+
+        public String getHostName() {
+            return addr.getHostName();
+        }
+
+        public MockableInetAddress getAddress() {
+            InetAddress ia = addr.getAddress();
+            return ia == null ? null : new MockableInetAddress(ia);
+        }
+
+        @Override
+        public String toString() {
+            return addr.toString();
+        }
+    }
+
+    static class MockableInetAddress {
+        private final InetAddress ia;
+
+        MockableInetAddress(InetAddress ia) {
+            this.ia = ia;
+        }
+
+        public String getCanonicalHostName() {
+            return ia.getCanonicalHostName();
+        }
+
+        public String getHostAddress() {
+            return ia.getHostAddress();
+        }
+
+        @Override
+        public String toString() {
+            return ia.toString();
+        }
+    }
+    /**
+     * Get the name of the server principal for a SASL client.  This is visible for testing purposes.
+     * @param addr the address of the host.
+     * @param clientConfig the configuration for the client.
+     * @return the name of the principal.
+     */
+    static String getServerPrincipal(MockableInetSocketAddress addr, ZKClientConfig clientConfig) {
+        String principalUserName = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_USERNAME,
+            ZKClientConfig.ZK_SASL_CLIENT_USERNAME_DEFAULT);
+        String hostName = addr.getHostName();
+
+        boolean canonicalize = true;
+        try {
+            canonicalize = Boolean.parseBoolean(clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME,
+                ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME_DEFAULT));
+        } catch (IllegalArgumentException ea) {
+            //ignored ...
+        }
+
+        if (canonicalize) {
+            MockableInetAddress ia = addr.getAddress();
+            if (ia == null) {
+                throw new IllegalArgumentException(""Unable to canonicalize address "" + addr + "" because it's not resolvable"");
+            }
+
+            String canonicalHostName = ia.getCanonicalHostName();
+            //avoid using literal IP address when security check fails
+            if (!canonicalHostName.equals(ia.getHostAddress())) {","[{'comment': 'Would you please add test to cover this code path: canonicalization is ON, but getCanonicalHostName() returns IP address.', 'commenter': 'anmolnar'}]"
654,src/java/main/org/apache/zookeeper/common/X509Util.java,"@@ -85,60 +85,73 @@ public static SSLContext createSSLContext() throws SSLContextException {
     }
 
     public static SSLContext createSSLContext(ZKConfig config) throws SSLContextException {
-        KeyManager[] keyManagers = null;
-        TrustManager[] trustManagers = null;
+        if (config.getProperty(ZKConfig.SSL_CLIENT_CONTEXT) != null) {
+            LOG.debug(""Loading SSLContext from property '"" + ZKConfig.SSL_CLIENT_CONTEXT + ""'"");
+            String sslClientContextClass = config.getProperty(ZKConfig.SSL_CLIENT_CONTEXT);
+            try {
+                Class<?> sslContextClass = Class.forName(sslClientContextClass);
+                ZKClientSSLContext sslContext = (ZKClientSSLContext) sslContextClass.newInstance();","[{'comment': 'newInstance is deprecated.\r\nCan we use getConstructor().newInstance() ?', 'commenter': 'eolivelli'}, {'comment': ""No problem - I've updated the PR."", 'commenter': 'arankin-irl'}]"
654,zookeeper-server/src/test/java/org/apache/zookeeper/common/ZKTestClientSSLContext.java,"@@ -0,0 +1,12 @@
+package org.apache.zookeeper.common;","[{'comment': 'Add apache header', 'commenter': 'nkalmar'}]"
654,zookeeper-server/src/main/java/org/apache/zookeeper/common/ZKClientSSLContext.java,"@@ -0,0 +1,18 @@
+package org.apache.zookeeper.common;","[{'comment': 'add Apache header', 'commenter': 'nkalmar'}]"
669,zookeeper-common/src/test/java/org/apache/zookeeper/common/TestByteBufAllocator.java,"@@ -0,0 +1,145 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.CompositeByteBuf;
+import io.netty.buffer.PooledByteBufAllocator;
+import io.netty.util.ResourceLeakDetector;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * This is a custom ByteBufAllocator that tracks outstanding allocations and
+ * crashes the program if any of them are leaked.
+ *
+ * Never use this class in production, it will cause your server to run out
+ * of memory! This is because it holds strong references to all allocated
+ * buffers and doesn't release them until checkForLeaks() is called at the
+ * end of a unit test.
+ *
+ * Note: the original code was copied from https://github.com/airlift/drift,
+ * with the permission and encouragement of airlift's author (dain). Airlift
+ * uses the same apache 2.0 license as Zookeeper so this should be ok.
+ *
+ * However, the code was modified to take advantage of Netty's built-in
+ * leak tracking and make a best effort to print details about buffer leaks.
+ */
+public class TestByteBufAllocator extends PooledByteBufAllocator {
+    private static AtomicReference<TestByteBufAllocator> INSTANCE =
+            new AtomicReference<>(null);
+
+    /**
+     * Get the singleton testing allocator.
+     * @return the singleton allocator, creating it if one does not exist.
+     */
+    public static TestByteBufAllocator getInstance() {
+        TestByteBufAllocator result = INSTANCE.get();
+        if (result == null) {
+            // Note: the leak detector level never gets reset after this,
+            // but that's probably ok since this is only used by test code.
+            ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.PARANOID);
+            INSTANCE.compareAndSet(null, new TestByteBufAllocator());
+            result = INSTANCE.get();
+        }
+        return result;
+    }
+
+    /**
+     * Destroys the singleton testing allocator and throws an error if any of the
+     * buffers allocated by it have been leaked. Attempts to print leak details to
+     * standard error before throwing, by using netty's built-in leak tracking.
+     * Note that this might not always work, since it only triggers when a buffer
+     * is garbage-collected and calling System.gc() does not guarantee that a buffer
+     * will actually be GC'ed.
+     *
+     * This should be called at the end of a unit test's tearDown() method.
+     */
+    public static void checkForLeaks() {
+        TestByteBufAllocator result = INSTANCE.getAndSet(null);
+        if (result != null) {
+            result.checkInstanceForLeaks();
+        }
+
+    }
+
+    private final List<ByteBuf> trackedBuffers = new ArrayList<>();
+
+    public TestByteBufAllocator()
+    {
+        super(false);
+    }
+
+    @Override
+    protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity)
+    {
+        return track(super.newHeapBuffer(initialCapacity, maxCapacity));
+    }
+
+    @Override
+    protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity)
+    {
+        return track(super.newDirectBuffer(initialCapacity, maxCapacity));
+    }
+
+    @Override
+    public CompositeByteBuf compositeHeapBuffer(int maxNumComponents)
+    {
+        return track(super.compositeHeapBuffer(maxNumComponents));
+    }
+
+    @Override
+    public CompositeByteBuf compositeDirectBuffer(int maxNumComponents)
+    {
+        return track(super.compositeDirectBuffer(maxNumComponents));
+    }
+
+    private synchronized CompositeByteBuf track(CompositeByteBuf byteBuf)
+    {
+        trackedBuffers.add(byteBuf);
+        return byteBuf;
+    }
+
+    private synchronized ByteBuf track(ByteBuf byteBuf)
+    {
+        trackedBuffers.add(byteBuf);
+        return byteBuf;
+    }
+
+    private void checkInstanceForLeaks()
+    {
+        long referencedBuffersCount = 0;
+        synchronized (this) {
+            referencedBuffersCount = trackedBuffers.stream()
+                    .filter(byteBuf -> byteBuf.refCnt() > 0)
+                    .count();
+            // Make tracked buffers eligible for GC
+            trackedBuffers.clear();
+        }
+        // Trigger a GC. This will hopefully (but not necessarily) print details
+        // about detected leaks to standard error before the error is thrown.
+        System.gc();","[{'comment': 'I think you want this inside of the if statement below, since it is only needed if there is a leak.', 'commenter': 'dain'}]"
669,zookeeper-common/src/main/java/org/apache/zookeeper/ClientCnxnSocketNetty.java,"@@ -68,18 +70,21 @@
 public class ClientCnxnSocketNetty extends ClientCnxnSocket {
     private static final Logger LOG = LoggerFactory.getLogger(ClientCnxnSocketNetty.class);
 
-    ChannelFactory channelFactory = new NioClientSocketChannelFactory(
-            Executors.newCachedThreadPool(), Executors.newCachedThreadPool());
-    Channel channel;
-    CountDownLatch firstConnect;
-    ChannelFuture connectFuture;
-    Lock connectLock = new ReentrantLock();
-    AtomicBoolean disconnected = new AtomicBoolean();
-    AtomicBoolean needSasl = new AtomicBoolean();
-    Semaphore waitSasl = new Semaphore(0);
+    private final EventLoopGroup eventLoopGroup;
+    private Channel channel;
+    private CountDownLatch firstConnect;
+    private ChannelFuture connectFuture;
+    private final Lock connectLock = new ReentrantLock();
+    private final AtomicBoolean disconnected = new AtomicBoolean();
+    private final AtomicBoolean needSasl = new AtomicBoolean();
+    private final Semaphore waitSasl = new Semaphore(0);
+
+    private static final AtomicReference<ByteBufAllocator> TEST_ALLOCATOR =
+            new AtomicReference<>(null);
 
     ClientCnxnSocketNetty(ZKClientConfig clientConfig) throws IOException {
         this.clientConfig = clientConfig;
+        eventLoopGroup = new NioEventLoopGroup(0, Executors.newCachedThreadPool());","[{'comment': ""Let's move to Epoll.\r\nIt can be a followup change (I can send of you don't have already it on your stack of changes)"", 'commenter': 'eolivelli'}, {'comment': ""I'd like to do it in a follow-up diff. I was thinking we default to NIO (since it works on all OSes), and have a config option to use Epoll instead."", 'commenter': 'ivmaykov'}, {'comment': 'In almost all of the projects I know using Netty you are trying to use EPoll ig available and then fallback to Nio.\r\nI will be happy to create a JIRA and send a diff once we get this merged', 'commenter': 'eolivelli'}]"
669,zookeeper-common/src/main/java/org/apache/zookeeper/ClientCnxnSocketNetty.java,"@@ -103,71 +108,95 @@
     boolean isConnected() {
         // Assuming that isConnected() is only used to initiate connection,
         // not used by some other connection status judgement.
-        return channel != null;
+        connectLock.lock();
+        try {
+            return connectFuture != null || channel != null;
+        } finally {
+            connectLock.unlock();
+        }
     }
 
     @Override
     void connect(InetSocketAddress addr) throws IOException {
         firstConnect = new CountDownLatch(1);
 
-        ClientBootstrap bootstrap = new ClientBootstrap(channelFactory);
-
-        bootstrap.setPipelineFactory(new ZKClientPipelineFactory(addr.getHostString(), addr.getPort()));
-        bootstrap.setOption(""soLinger"", -1);
-        bootstrap.setOption(""tcpNoDelay"", true);
-
-        connectFuture = bootstrap.connect(addr);
-        connectFuture.addListener(new ChannelFutureListener() {
-            @Override
-            public void operationComplete(ChannelFuture channelFuture) throws Exception {
-                // this lock guarantees that channel won't be assgined after cleanup().
-                connectLock.lock();
-                try {
-                    if (!channelFuture.isSuccess() || connectFuture == null) {
-                        LOG.info(""future isn't success, cause: {}"", channelFuture.getCause());
-                        return;
-                    }
-                    // setup channel, variables, connection, etc.
-                    channel = channelFuture.getChannel();
-
-                    disconnected.set(false);
-                    initialized = false;
-                    lenBuffer.clear();
-                    incomingBuffer = lenBuffer;
-
-                    sendThread.primeConnection();
-                    updateNow();
-                    updateLastSendAndHeard();
-
-                    if (sendThread.tunnelAuthInProgress()) {
-                        waitSasl.drainPermits();
-                        needSasl.set(true);
-                        sendPrimePacket();
-                    } else {
-                        needSasl.set(false);
-                    }
+        Bootstrap bootstrap = new Bootstrap();
+        bootstrap.group(Objects.requireNonNull(eventLoopGroup))
+                .channel(NioSocketChannel.class)
+                .handler(new ZKClientPipelineFactory(addr.getHostString(), addr.getPort()))
+                .option(ChannelOption.SO_LINGER, -1)
+                .option(ChannelOption.TCP_NODELAY, true);
+        ByteBufAllocator testAllocator = TEST_ALLOCATOR.get();
+        if (testAllocator != null) {
+            bootstrap.option(ChannelOption.ALLOCATOR, testAllocator);
+        }
+        bootstrap.validate();
+
+        connectLock.lock();
+        try {
+            connectFuture = bootstrap.connect(addr);
+            connectFuture.addListener(new ChannelFutureListener() {
+                @Override
+                public void operationComplete(ChannelFuture channelFuture) throws Exception {
+                    // this lock guarantees that channel won't be assigned after cleanup().
+                    connectLock.lock();
+                    try {
+                        if (!channelFuture.isSuccess()) {
+                            LOG.info(""future isn't success, cause:"", channelFuture.cause());
+                            return;
+                        } else if (connectFuture == null) {
+                            LOG.info(""connect attempt cancelled"");
+                            // If the connect attempt was cancelled but succeeded
+                            // anyway, make sure to close the channel, otherwise
+                            // we may leak a file descriptor.
+                            channelFuture.channel().close();","[{'comment': 'Can this turn into an NPE? As channel() may return null. ', 'commenter': 'eolivelli'}, {'comment': ""I don't think so, since this code can only trigger if the connect future is successful. If the future is not successful, the previous if branch will be taken."", 'commenter': 'ivmaykov'}, {'comment': ""That was my guess too. Let's keep it single. So okay to me"", 'commenter': 'eolivelli'}]"
669,zookeeper-common/src/main/java/org/apache/zookeeper/ClientCnxnSocketNetty.java,"@@ -184,7 +213,9 @@ void cleanup() {
 
     @Override
     void close() {
-        channelFactory.releaseExternalResources();
+        if (!eventLoopGroup.isShuttingDown()) {","[{'comment': 'Is this really needed?', 'commenter': 'eolivelli'}, {'comment': ""I'm not sure if calling `shutdownGracefully` more than once is allowed, which is why I added the check. It might not be necessary."", 'commenter': 'ivmaykov'}]"
669,zookeeper-common/src/main/java/org/apache/zookeeper/ClientCnxnSocketNetty.java,"@@ -267,7 +298,7 @@ private void sendPkt(Packet p) {
         p.createBB();
         updateLastSend();
         sentCount++;
-        channel.write(ChannelBuffers.wrappedBuffer(p.bb));
+        channel.writeAndFlush(Unpooled.wrappedBuffer(p.bb));","[{'comment': ""What about adding ', channel.voidPromise()' ?"", 'commenter': 'eolivelli'}, {'comment': 'Can you explain what the purpose of that would be? According to the documentation, voidPromise() returns a promise that will never be notified of success or failure.', 'commenter': 'ivmaykov'}, {'comment': ""See these very interesting slides \r\nhttp://normanmaurer.me/presentations/2014-facebook-eng-netty/slides.html#8.0\r\n\r\nIn this case you aren't adding listeners"", 'commenter': 'eolivelli'}, {'comment': ""Essentially you will save allocations if you don't need listeners"", 'commenter': 'eolivelli'}]"
669,zookeeper-common/src/main/java/org/apache/zookeeper/ClientCnxnSocketNetty.java,"@@ -439,13 +466,34 @@ public void messageReceived(ChannelHandlerContext ctx,
                 }
             }
             wakeupCnxn();
+            // Note: SimpleChannelInboundHandler releases the ByteBuf for us
+            // so we don't need to do it.
         }
 
         @Override
-        public void exceptionCaught(ChannelHandlerContext ctx,
-                                    ExceptionEvent e) throws Exception {
-            LOG.warn(""Exception caught: {}"", e, e.getCause());
+        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+            LOG.warn(""Exception caught"", cause);
             cleanup();
         }
     }
+
+    /**
+     * Sets the test ByteBufAllocator. This allocator will be used by all
+     * future instances of this class.
+     * It is not recommended to use this method outside of testing.
+     * @param allocator the ByteBufAllocator to use for all netty buffer
+     *                  allocations.
+     */
+    public static void setTestAllocator(ByteBufAllocator allocator) {
+        TEST_ALLOCATOR.set(allocator);","[{'comment': 'I think this is a security hole. We are in the client, so untrusted code may call this public method.\r\nWe should use mockito/powermock for this stuff.\r\nIs there are another way?', 'commenter': 'eolivelli'}, {'comment': ""Sure, but that would only affect that client and would have no effect on the server. All clients are untrusted by default since they run on a computer you don't own :)\r\n\r\nI can look into using a mocking framework instead if you feel strongly about it."", 'commenter': 'ivmaykov'}, {'comment': 'Yes in my case this is a hole because the client code runs in a potentially unsecure JVM when user code can call public methods', 'commenter': 'eolivelli'}]"
669,zookeeper-common/src/test/java/org/apache/zookeeper/common/TestByteBufAllocator.java,"@@ -0,0 +1,151 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.CompositeByteBuf;
+import io.netty.buffer.PooledByteBufAllocator;
+import io.netty.util.ResourceLeakDetector;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * This is a custom ByteBufAllocator that tracks outstanding allocations and
+ * crashes the program if any of them are leaked.
+ *
+ * Never use this class in production, it will cause your server to run out
+ * of memory! This is because it holds strong references to all allocated
+ * buffers and doesn't release them until checkForLeaks() is called at the
+ * end of a unit test.
+ *
+ * Note: the original code was copied from https://github.com/airlift/drift,
+ * with the permission and encouragement of airlift's author (dain). Airlift
+ * uses the same apache 2.0 license as Zookeeper so this should be ok.
+ *
+ * However, the code was modified to take advantage of Netty's built-in
+ * leak tracking and make a best effort to print details about buffer leaks.
+ */
+public class TestByteBufAllocator extends PooledByteBufAllocator {","[{'comment': ""This is interesting\r\n\r\nNetty has already built in support for this kind of stuff.I see that this class is smarter.\r\nIsn't running test with paranoid leak detection enough?"", 'commenter': 'eolivelli'}, {'comment': ""Paranoid leak detection will just print details about leaks, but the test will still pass and it takes a human to examine the test's stderr output to see that there was a problem. Using this allocator will make the test fail if there are buffer leaks."", 'commenter': 'ivmaykov'}, {'comment': 'Okay, very good', 'commenter': 'eolivelli'}]"
669,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -200,24 +186,13 @@ public void setSessionId(long sessionId) {
         this.sessionId = sessionId;
     }
 
-    @Override
-    public void enableRecv() {
-        if (throttled) {
-            throttled = false;
-            if (LOG.isDebugEnabled()) {
-                LOG.debug(""Sending unthrottle event "" + this);
-            }
-            channel.getPipeline().sendUpstream(new ResumeMessageEvent(channel));
-        }
-    }
-
     @Override
     public void sendBuffer(ByteBuffer sendBuffer) {
         if (sendBuffer == ServerCnxnFactory.closeConn) {
             close();
             return;
         }
-        channel.write(wrappedBuffer(sendBuffer));
+        channel.writeAndFlush(Unpooled.wrappedBuffer(sendBuffer));","[{'comment': 'Consider using voidPromise()', 'commenter': 'eolivelli'}, {'comment': ""As above, I'm not sure what that provides. I am still learning about netty so please excuse my ignorance :)"", 'commenter': 'ivmaykov'}]"
669,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -116,170 +115,94 @@ public void channelConnected(ChannelHandlerContext ctx,
 
             NettyServerCnxn cnxn = new NettyServerCnxn(channel,
                     zkServer, NettyServerCnxnFactory.this);
-            ctx.setAttachment(cnxn);
+            ctx.channel().attr(CONNECTION_ATTRIBUTE).set(cnxn);
 
             if (secure) {
-                SslHandler sslHandler = ctx.getPipeline().get(SslHandler.class);
-                ChannelFuture handshakeFuture = sslHandler.handshake();
+                SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);
+                Future<Channel> handshakeFuture = sslHandler.handshakeFuture();
                 handshakeFuture.addListener(new CertificateVerifier(sslHandler, cnxn));
             } else {
-                allChannels.add(ctx.getChannel());
+                allChannels.add(ctx.channel());
                 addCnxn(cnxn);
             }
         }
 
         @Override
-        public void channelDisconnected(ChannelHandlerContext ctx,
-                ChannelStateEvent e) throws Exception
-        {
-            if (LOG.isTraceEnabled()) {
-                LOG.trace(""Channel disconnected "" + e);
-            }
-            NettyServerCnxn cnxn = (NettyServerCnxn) ctx.getAttachment();
+        public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+            LOG.trace(""Channel inactive {}"", ctx.channel());","[{'comment': ' isTraceEnabled is missing here?', 'commenter': 'eolivelli'}, {'comment': ""LOG.trace() does an isTraceEnabled check internally. If constructing the additional parameters passed to the log method doesn't require any work (such as converting the contents of a buffer to a hex string), then the enclosing isTraceEnabled check is redundant."", 'commenter': 'ivmaykov'}, {'comment': ""It is better to add the 'if' because in general you will skip calling the logger method, with all what is comes with it: evaluating expressions for parameters, passing parameters for the method call, and calling the method.\r\nYou will trade a single cheap method call with a potential expense of resources and useless allocations.\r\nIMHO it is better to have this pattern consistently in the whole code"", 'commenter': 'eolivelli'}, {'comment': 'Do you want a similar check for LOG.debug() calls as well, or only LOG.trace()?', 'commenter': 'ivmaykov'}]"
669,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -116,170 +115,94 @@ public void channelConnected(ChannelHandlerContext ctx,
 
             NettyServerCnxn cnxn = new NettyServerCnxn(channel,
                     zkServer, NettyServerCnxnFactory.this);
-            ctx.setAttachment(cnxn);
+            ctx.channel().attr(CONNECTION_ATTRIBUTE).set(cnxn);
 
             if (secure) {
-                SslHandler sslHandler = ctx.getPipeline().get(SslHandler.class);
-                ChannelFuture handshakeFuture = sslHandler.handshake();
+                SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);
+                Future<Channel> handshakeFuture = sslHandler.handshakeFuture();
                 handshakeFuture.addListener(new CertificateVerifier(sslHandler, cnxn));
             } else {
-                allChannels.add(ctx.getChannel());
+                allChannels.add(ctx.channel());
                 addCnxn(cnxn);
             }
         }
 
         @Override
-        public void channelDisconnected(ChannelHandlerContext ctx,
-                ChannelStateEvent e) throws Exception
-        {
-            if (LOG.isTraceEnabled()) {
-                LOG.trace(""Channel disconnected "" + e);
-            }
-            NettyServerCnxn cnxn = (NettyServerCnxn) ctx.getAttachment();
+        public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+            LOG.trace(""Channel inactive {}"", ctx.channel());
+            allChannels.remove(ctx.channel());
+            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);
             if (cnxn != null) {
-                if (LOG.isTraceEnabled()) {
-                    LOG.trace(""Channel disconnect caused close "" + e);
-                }
+                LOG.trace(""Channel inactive caused close {}"", cnxn);
                 cnxn.close();
             }
         }
 
         @Override
-        public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
-            throws Exception
-        {
-            LOG.warn(""Exception caught "" + e, e.getCause());
-            NettyServerCnxn cnxn = (NettyServerCnxn) ctx.getAttachment();
+        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+            LOG.warn(""Exception caught"", cause);
+            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);
             if (cnxn != null) {
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug(""Closing "" + cnxn);
-                }
+                LOG.debug(""Closing {}"", cnxn);
                 cnxn.close();
             }
         }
 
         @Override
-        public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
-            throws Exception
-        {
-            if (LOG.isTraceEnabled()) {
-                LOG.trace(""message received called "" + e.getMessage());
-            }
+        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
             try {
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug(""New message "" + e.toString()
-                            + "" from "" + ctx.getChannel());
-                }
-                NettyServerCnxn cnxn = (NettyServerCnxn)ctx.getAttachment();
-                synchronized(cnxn) {
-                    processMessage(e, cnxn);
+                if (evt == NettyServerCnxn.AutoReadEvent.ENABLE) {
+                    LOG.debug(""Received AutoReadEvent.ENABLE"");
+                    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();
+                    // TODO(ilyam): Not sure if cnxn can be null here. It becomes null if channelInactive()
+                    // or exceptionCaught() trigger, but it's unclear to me if userEventTriggered() can run
+                    // after either of those. Check for null just to be safe ...
+                    if (cnxn != null) {
+                        cnxn.processQueuedBuffer();
+                    }
+                    ctx.channel().config().setAutoRead(true);
+                } else if (evt == NettyServerCnxn.AutoReadEvent.DISABLE) {
+                    LOG.debug(""Received AutoReadEvent.DISABLE"");
+                    ctx.channel().config().setAutoRead(false);
                 }
-            } catch(Exception ex) {
-                LOG.error(""Unexpected exception in receive"", ex);
-                throw ex;
+            } finally {
+                ReferenceCountUtil.release(evt);
             }
         }
 
-        private void processMessage(MessageEvent e, NettyServerCnxn cnxn) {
-            if (LOG.isDebugEnabled()) {
-                LOG.debug(Long.toHexString(cnxn.sessionId) + "" queuedBuffer: ""
-                        + cnxn.queuedBuffer);
-            }
-
-            if (e instanceof NettyServerCnxn.ResumeMessageEvent) {
-                LOG.debug(""Received ResumeMessageEvent"");
-                if (cnxn.queuedBuffer != null) {
-                    if (LOG.isTraceEnabled()) {
-                        LOG.trace(""processing queue ""
-                                + Long.toHexString(cnxn.sessionId)
-                                + "" queuedBuffer 0x""
-                                + ChannelBuffers.hexDump(cnxn.queuedBuffer));
-                    }
-                    cnxn.receiveMessage(cnxn.queuedBuffer);
-                    if (!cnxn.queuedBuffer.readable()) {
-                        LOG.debug(""Processed queue - no bytes remaining"");
-                        cnxn.queuedBuffer = null;
-                    } else {
-                        LOG.debug(""Processed queue - bytes remaining"");
-                    }
-                } else {
-                    LOG.debug(""queue empty"");
-                }
-                cnxn.channel.setReadable(true);
-            } else {
-                ChannelBuffer buf = (ChannelBuffer)e.getMessage();
-                if (LOG.isTraceEnabled()) {
-                    LOG.trace(Long.toHexString(cnxn.sessionId)
-                            + "" buf 0x""
-                            + ChannelBuffers.hexDump(buf));
-                }
-                
-                if (cnxn.throttled) {
-                    LOG.debug(""Received message while throttled"");
-                    // we are throttled, so we need to queue
-                    if (cnxn.queuedBuffer == null) {
-                        LOG.debug(""allocating queue"");
-                        cnxn.queuedBuffer = dynamicBuffer(buf.readableBytes());
-                    }
-                    cnxn.queuedBuffer.writeBytes(buf);
-                    if (LOG.isTraceEnabled()) {
-                        LOG.trace(Long.toHexString(cnxn.sessionId)
-                                + "" queuedBuffer 0x""
-                                + ChannelBuffers.hexDump(cnxn.queuedBuffer));
-                    }
-                } else {
-                    LOG.debug(""not throttled"");
-                    if (cnxn.queuedBuffer != null) {
-                        if (LOG.isTraceEnabled()) {
-                            LOG.trace(Long.toHexString(cnxn.sessionId)
-                                    + "" queuedBuffer 0x""
-                                    + ChannelBuffers.hexDump(cnxn.queuedBuffer));
-                        }
-                        cnxn.queuedBuffer.writeBytes(buf);
-                        if (LOG.isTraceEnabled()) {
-                            LOG.trace(Long.toHexString(cnxn.sessionId)
-                                    + "" queuedBuffer 0x""
-                                    + ChannelBuffers.hexDump(cnxn.queuedBuffer));
-                        }
-
-                        cnxn.receiveMessage(cnxn.queuedBuffer);
-                        if (!cnxn.queuedBuffer.readable()) {
-                            LOG.debug(""Processed queue - no bytes remaining"");
-                            cnxn.queuedBuffer = null;
-                        } else {
-                            LOG.debug(""Processed queue - bytes remaining"");
-                        }
+        @Override
+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+            try {
+                LOG.trace(""message received called {}"", msg);","[{'comment': 'isTraceEnabled?', 'commenter': 'eolivelli'}, {'comment': 'as above.', 'commenter': 'ivmaykov'}]"
669,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -335,29 +260,34 @@ public void operationComplete(ChannelFuture future)
     CnxnChannelHandler channelHandler = new CnxnChannelHandler();
 
     NettyServerCnxnFactory() {
-        bootstrap = new ServerBootstrap(
-                new NioServerSocketChannelFactory(
-                        Executors.newCachedThreadPool(),
-                        Executors.newCachedThreadPool()));
-        // parent channel
-        bootstrap.setOption(""reuseAddress"", true);
-        // child channels
-        bootstrap.setOption(""child.tcpNoDelay"", true);
-        /* set socket linger to off, so that socket close does not block */
-        bootstrap.setOption(""child.soLinger"", -1);
-        bootstrap.setPipelineFactory(new ChannelPipelineFactory() {
-            @Override
-            public ChannelPipeline getPipeline() throws Exception {
-                ChannelPipeline p = Channels.pipeline();
-                if (secure) {
-                    initSSL(p);
-                }
-                p.addLast(""servercnxnfactory"", channelHandler);
-
-                return p;
-            }
-        });
         x509Util = new ClientX509Util();
+
+        EventLoopGroup bossGroup = new NioEventLoopGroup(0, Executors.newCachedThreadPool());","[{'comment': 'Consider EPoll', 'commenter': 'eolivelli'}, {'comment': 'See comment above about making epoll optional based on a config option.', 'commenter': 'ivmaykov'}]"
669,ivy.xml,"@@ -59,9 +59,11 @@
     <dependency org=""org.apache.yetus"" name=""audience-annotations""
                 rev=""${audience-annotations.version}""/>
 
-    <dependency org=""io.netty"" name=""netty"" conf=""default"" rev=""${netty.version}"">
-      <artifact name=""netty"" type=""jar"" conf=""default""/>
-    </dependency>
+    <dependency org=""io.netty"" name=""netty-common"" conf=""default"" rev=""${netty.version}"" />","[{'comment': 'I forgot about this.\r\nI think it is better to use netty-all because it bundles all of the native artifacts.\r\nIn Bookkeeper for instance we have netty -all, but this is common practice in many other projects.', 'commenter': 'eolivelli'}]"
670,zookeeper-common/pom.xml,"@@ -0,0 +1,123 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<!--
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.zookeeper</groupId>
+    <artifactId>zookeeper</artifactId>
+    <version>2.6.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>zookeeper-common</artifactId>
+  <name>Apache ZooKeeper - Common</name>
+  <description>ZooKeeper common</description>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.zookeeper</groupId>
+      <artifactId>zookeeper-jute</artifactId>
+      <version>2.6.0-SNAPSHOT</version>","[{'comment': 'project.version?', 'commenter': 'eolivelli'}, {'comment': 'This is a strongly work in progress, and possibly it will never make it into the codebase. \r\nI created this PR to show that it is possibly not a good idea to seperate server and client java code :(', 'commenter': 'nkalmar'}]"
670,zookeeper-client/zookeeper-client-java/pom.xml,"@@ -0,0 +1,59 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<!--
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.zookeeper</groupId>
+    <artifactId>zookeeper</artifactId>
+    <version>2.6.0-SNAPSHOT</version>","[{'comment': '3.6.0?', 'commenter': 'eolivelli'}, {'comment': 'Yes, it was like this on the master pom... I will definitely fix it in a ""real"" PR.', 'commenter': 'nkalmar'}]"
670,zookeeper-jute/pom.xml,"@@ -0,0 +1,169 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<!--
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.zookeeper</groupId>
+    <artifactId>zookeeper</artifactId>
+    <version>2.6.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>zookeeper-jute</artifactId>
+  <name>Apache ZooKeeper - Jute</name>
+  <description>ZooKeeper jute</description>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.yetus</groupId>
+      <artifactId>audience-annotations</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>javacc-maven-plugin</artifactId>
+        <version>2.6</version>
+        <executions>
+          <execution>
+            <phase>generate-sources</phase>
+            <id>javacc</id>
+            <goals>
+              <goal>javacc</goal>
+            </goals>
+            <configuration>
+              <sourceDirectory>${project.basedir}/src/main/java/org/apache/jute/compiler/generated/</sourceDirectory>
+              <includes>
+                <include>rcc.jj</include>
+              </includes>
+              <lookAhead>2</lookAhead>
+              <isStatic>false</isStatic>
+              <outputDirectory>${project.build.directory}/classes/</outputDirectory>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
+      <!--plugin>
+        <artifactId>maven-antrun-plugin</artifactId>","[{'comment': 'This one?', 'commenter': 'eolivelli'}]"
670,zookeeper-server/pom.xml,"@@ -0,0 +1,67 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+<!--
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.zookeeper</groupId>
+    <artifactId>zookeeper</artifactId>
+    <version>2.6.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>zookeeper-server</artifactId>
+  <name>Apache ZooKeeper - Server</name>
+  <description>ZooKeeper server</description>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.zookeeper</groupId>
+      <artifactId>zookeeper-jute</artifactId>
+      <version>2.6.0-SNAPSHOT</version>","[{'comment': 'project.version', 'commenter': 'eolivelli'}]"
670,zookeeper-client/zookeeper-client-java/src/main/java/org/apache/zookeeper/client/ZKClientConfig.java,"@@ -23,7 +23,7 @@
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.zookeeper.ZooKeeper;
 import org.apache.zookeeper.common.ZKConfig;
-import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
+import org.apache.zookeeper.server.quorum.ConfigException;","[{'comment': 'This is breaking compatibility, we cannot port this into branch3.5 and it will make transition to 3.6 slower', 'commenter': 'eolivelli'}, {'comment': 'Yes, one of the main reasons (not just this particular instance) that it cannot be separated ""nicely"".\r\n\r\nzookeeper-common and zookeeper-client-java will probably merge back to zookeeper-server.', 'commenter': 'nkalmar'}]"
678,zookeeper-server/src/main/java/org/apache/zookeeper/util/PemReader.java,"@@ -0,0 +1,224 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.util;
+
+import javax.crypto.Cipher;
+import javax.crypto.EncryptedPrivateKeyInfo;
+import javax.crypto.SecretKey;
+import javax.crypto.SecretKeyFactory;
+import javax.crypto.spec.PBEKeySpec;
+import javax.security.auth.x500.X500Principal;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.security.GeneralSecurityException;
+import java.security.KeyFactory;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.PrivateKey;
+import java.security.PublicKey;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import java.security.spec.InvalidKeySpecException;
+import java.security.spec.PKCS8EncodedKeySpec;
+import java.security.spec.X509EncodedKeySpec;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import static java.util.Base64.getMimeDecoder;
+import static java.util.regex.Pattern.CASE_INSENSITIVE;
+import static javax.crypto.Cipher.DECRYPT_MODE;
+
+/**
+ * Note: this class is copied from io.airlift.security.pem.PemReader (see
+ * https://github.com/airlift/airlift/blob/master/security/src/main/java/io/airlift/security/pem/PemReader.java) with","[{'comment': 'We must update the NOTICE file', 'commenter': 'eolivelli'}, {'comment': ""You could be right, I'm not sure what's the implication of this. @hanm must be able to advise on this.\r\nBouncyCastle library also having some PEM reader logic, but not sure how useful it is here.\r\n"", 'commenter': 'anmolnar'}, {'comment': ""BouncyCastle is currently a test-only dependency (used for creating test certificates), so we can't use it in production code. It's a large library and I'd rather not take it on as a full dependency if the only thing we need from it is the PEM reader. I think it's fine to copy the code (license allows it and the author of airlift recommended it to me), will wait for guidance on NOTICE file update from @eolivelli."", 'commenter': 'ivmaykov'}, {'comment': 'For the NOTICE you can take a look to this example from Bookkeeper project\r\nhttps://github.com/apache/bookkeeper/blob/master/bookkeeper-dist/src/main/resources/NOTICE-server.bin.txt\r\n\r\nJust add a reference to Aircraft in the main NOTICE.txt', 'commenter': 'eolivelli'}, {'comment': 'i agree with @eolivelli , it should be enough to declare airlift in our notice file as a dependency.\r\nour notice file is here:\r\nhttps://github.com/apache/zookeeper/blob/master/zookeeper-server/src/main/resources/NOTICE.txt\r\n\r\nI vaguely remember we also copied some code from org.apache.httpcomponents for host verification to mitigate the perf regression of directly referencing the library as a dependency. Might worth to double check if we need patch notice file for that copy as well.', 'commenter': 'hanm'}, {'comment': ""@hanm I've updated the NOTICE.txt file in the latest version of the code, please let me know if that looks good. I think it doesn't hurt to keep the comments in PemReader.java - will make it easier to backport fixes from airlift's PemReader in the future.\r\n\r\nRE: httpcomponents. Yes, we did copy some httpcomponents code. I can put up a separate PR that adds a NOTICE.txt entry for that."", 'commenter': 'ivmaykov'}, {'comment': 'notice file lgtm, thanks', 'commenter': 'hanm'}]"
678,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -221,15 +279,45 @@ public SSLContext createSSLContext(ZKConfig config) throws SSLContextException {
         }
     }
 
-    public static X509KeyManager createKeyManager(String keyStoreLocation, String keyStorePassword)
+    /**
+     * Creates a key manager by loading the key store from the given file of the given type, optionally decrypting it
+     * using the given password.
+     * @param keyStoreLocation the location of the key store file.
+     * @param keyStorePassword optional password to decrypt the key store. If empty, assumes the key store is not
+     *                         encrypted.
+     * @param keyStoreType must be JKS, PEM, or null. If null, attempts to autodetect the key store type from the file
+     *                     extension (.jks / .pem).
+     * @return the key manager.
+     * @throws KeyManagerException if something goes wrong.
+     */
+    public static X509KeyManager createKeyManager(String keyStoreLocation, String keyStorePassword, StoreFileType keyStoreType)
             throws KeyManagerException {
         FileInputStream inputStream = null;
+        if (keyStorePassword == null) {
+            keyStorePassword = """";
+        }
         try {
             char[] keyStorePasswordChars = keyStorePassword.toCharArray();
             File keyStoreFile = new File(keyStoreLocation);
-            KeyStore ks = KeyStore.getInstance(""JKS"");
-            inputStream = new FileInputStream(keyStoreFile);
-            ks.load(inputStream, keyStorePasswordChars);
+            if (keyStoreType == null) {
+                keyStoreType = detectStoreFileTypeFromFileExtension(keyStoreFile);
+            }
+            KeyStore ks;
+            switch (keyStoreType) {","[{'comment': 'Using switch cases to employ different implementations for the same purpose is usually a code smell to me. What do you think of implementing an abstract class or an interface to gather all keystore reader implementations and create child classes for PEM and JKS?\r\n\r\nIn which case you can,\r\n1. pass only the interface KeystoreLoader here,\r\n2. avoid PemReader being implemented with all static methods,\r\n3. easily mock the impl in unit tests', 'commenter': 'anmolnar'}, {'comment': '@anmolnar \r\nIMHO in this specific case the switch can be acceptable.\r\nWith a fully generic solution maybe we should also add a generic way to detect the type from the filename or file contents (so that we can support new file types in the future without touching this code).\r\n\r\nAnyway any future proof implementation is always welcome ', 'commenter': 'eolivelli'}, {'comment': ""That factory logic is already implemented in `detectStoreFileTypeFromFileExtension()` and which (I believe) should go into a static factory method or factory class.\r\n\r\nAnother potential weakness of such switch-case implementations is what you mentioned in terms of adding new container types: one has to implement the new type in each of every switch case related to this type. In this case it's only 2 which I think already quite error-prone, but there could be others later."", 'commenter': 'anmolnar'}, {'comment': ""@anmolnar @eolivelli There are pros and cons to either approach. We only do the `switch (StoreFileType)` in two places, both of which are in the same file, which I feel is pretty well localized. If/when someone adds support for another key store type later (say, PKCS12), as long as they add decent tests in the same commit, I don't think there is much risk of forgetting to update one of the two switch statements. So, creating interfaces and implementing them in several classes kind of feels like over-engineering and will make it hard to see all the logic at once since it will be spread out across 7 files (assuming interface + 2 implementations for each of KeyStoreLoader / TrustStoreLoader) instead of 1 file.\r\n\r\nBut it would make mocking easier and adding more store types later would be potentially simplified, plus we could test the loaders in isolation, so I see pros and cons to both approaches. We could also land it like this in the interests of getting a working implementation out, and clean it up in a later PR. You guys let me know what you would prefer."", 'commenter': 'ivmaykov'}, {'comment': 'The fundamental problem with not following design patterns from day 0 is that people become reluctant to do things in the right way and eventually leads to classes like `X509Util.java`. Completely meaningless class which acts like a bin: people can add basically anything which fits in the ""Util"" naming (everything).\r\n\r\nI don\'t feel splitting the code across multiple classes / files is a con: does the compiler or the IDE have some problem with some extra files? I feel it much more readable though: reading a 100-line class with single responsibility is a lot easier than reading 1000-line Util class with a mess in it.\r\n\r\n""it would make mocking easier and adding more store types later would be potentially simplified, plus we could test the loaders in isolation"" - That\'s my point basically.\r\n\r\n""We could also land it like this in the interests of getting a working implementation out, and clean it up in a later PR."" - That\'s the source of all evil. :)', 'commenter': 'anmolnar'}, {'comment': ""Fair enough, I'll do some refactoring next week\r\n"", 'commenter': 'ivmaykov'}, {'comment': 'Thanks @ivmaykov .', 'commenter': 'anmolnar'}, {'comment': ""@anmolnar actually I'll wait for the rest of your review so I can get through all the initial changes in one pass."", 'commenter': 'ivmaykov'}]"
678,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -167,47 +222,50 @@ public SSLContext createSSLContext(ZKConfig config) throws SSLContextException {
         KeyManager[] keyManagers = null;
         TrustManager[] trustManagers = null;
 
-        String keyStoreLocationProp = config.getProperty(sslKeystoreLocationProperty);
-        String keyStorePasswordProp = config.getProperty(sslKeystorePasswdProperty);
+        String keyStoreLocationProp = config.getProperty(sslKeystoreLocationProperty, """");","[{'comment': 'Why do you need an empty string default value instead of checking for null?', 'commenter': 'anmolnar'}, {'comment': 'Since empty string is not a valid keystore type, I treat null value and empty string values equivalently. Doing it this way simplifies the check below (only need to check for empty string instead of checking both null and empty).', 'commenter': 'ivmaykov'}, {'comment': ""Sorry, I misread this comment. You are talking about the location, not the store type. But it's the same thing - null location and empty location can be treated the same way, so by defaulting to empty string here we don't need to check for 2 different options below. The previous code actually didn't check for empty location at all."", 'commenter': 'ivmaykov'}]"
678,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -79,12 +82,56 @@
             ""TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256""
     };
 
+    /**
+     * This enum represents the file type of a KeyStore or TrustStore. Currently, JKS (java keystore) and PEM types
+     * are supported.
+     */
+    public enum StoreFileType {
+        JKS("".jks""), PEM("".pem"");
+
+        private final String defaultFileExtension;
+
+        StoreFileType(String defaultFileExtension) {
+            this.defaultFileExtension = defaultFileExtension;
+        }
+
+        /**
+         * The property string that specifies that a key store or trust store should use this store file type.
+         */
+        public String getPropertyValue() {
+            return this.name();
+        }
+
+        /**
+         * The file extension that is associated with this file type.
+         */
+        public String getDefaultFileExtension() {
+            return defaultFileExtension;
+        }
+
+        /**
+         * Converts a property value to a StoreFileType enum. If the property value is not set or is empty, returns
+         * null.
+         * @param prop the property value.
+         * @return the StoreFileType.
+         * @throws IllegalArgumentException if the property value is not ""JKS"", ""PEM"", or empty/null.
+         */
+        public static StoreFileType fromPropertyValue(String prop) {
+            if (prop == null || prop.length() == 0) {
+                return null;
+            }
+            return StoreFileType.valueOf(prop.toUpperCase());
+        }
+    }
+
     private String sslProtocolProperty = getConfigPrefix() + ""protocol"";
     private String cipherSuitesProperty = getConfigPrefix() + ""ciphersuites"";
     private String sslKeystoreLocationProperty = getConfigPrefix() + ""keyStore.location"";
     private String sslKeystorePasswdProperty = getConfigPrefix() + ""keyStore.password"";
+    private String sslKeystoreTypeProperty = getConfigPrefix() + ""keyStore.type"";","[{'comment': 'Do we need the ability to override the keystore type that we otherwise detect from the file extension?', 'commenter': 'anmolnar'}, {'comment': 'I think it makes sense, if someone puts their JKS key in a file that they name ""foobar.key"" or something non-standard, we can still support it if they explicitly set the store type option. Most people will probably use the default file extensions and leave this option unset.', 'commenter': 'ivmaykov'}]"
678,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -167,47 +222,50 @@ public SSLContext createSSLContext(ZKConfig config) throws SSLContextException {
         KeyManager[] keyManagers = null;
         TrustManager[] trustManagers = null;
 
-        String keyStoreLocationProp = config.getProperty(sslKeystoreLocationProperty);
-        String keyStorePasswordProp = config.getProperty(sslKeystorePasswdProperty);
+        String keyStoreLocationProp = config.getProperty(sslKeystoreLocationProperty, """");
+        String keyStorePasswordProp = config.getProperty(sslKeystorePasswdProperty, """");
+        String keyStoreTypeProp = config.getProperty(sslKeystoreTypeProperty);
 
         // There are legal states in some use cases for null KeyManager or TrustManager.
-        // But if a user wanna specify one, location and password are required.
+        // But if a user wanna specify one, location is required. Password defaults to empty string if it is not
+        // specified by the user.
 
-        if (keyStoreLocationProp == null && keyStorePasswordProp == null) {
+        if (keyStoreLocationProp.isEmpty()) {
             LOG.warn(getSslKeystoreLocationProperty() + "" not specified"");
         } else {
-            if (keyStoreLocationProp == null) {
-                throw new SSLContextException(getSslKeystoreLocationProperty() + "" not specified"");
-            }
-            if (keyStorePasswordProp == null) {
-                throw new SSLContextException(getSslKeystorePasswdProperty() + "" not specified"");
-            }
             try {
+                StoreFileType keyStoreType = StoreFileType.fromPropertyValue(keyStoreTypeProp);
                 keyManagers = new KeyManager[]{
-                        createKeyManager(keyStoreLocationProp, keyStorePasswordProp)};
+                        createKeyManager(keyStoreLocationProp, keyStorePasswordProp, keyStoreType)};
             } catch (KeyManagerException keyManagerException) {
                 throw new SSLContextException(""Failed to create KeyManager"", keyManagerException);
+            } catch (IllegalArgumentException e) {
+                throw new SSLContextException(""Bad value for "" + sslKeystoreTypeProperty + "": "" + keyStoreTypeProp, e);
             }
         }
 
-        String trustStoreLocationProp = config.getProperty(sslTruststoreLocationProperty);
-        String trustStorePasswordProp = config.getProperty(sslTruststorePasswdProperty);
+        String trustStoreLocationProp = config.getProperty(sslTruststoreLocationProperty, """");","[{'comment': 'Same here. Previously it was checked against null value, why have you changed that?', 'commenter': 'anmolnar'}, {'comment': 'See above', 'commenter': 'ivmaykov'}]"
678,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -360,4 +476,26 @@ private void configureSSLServerSocket(SSLServerSocket sslServerSocket) {
         LOG.debug(""Using Java8-optimized cipher suites for Java version {}"", javaVersion);
         return DEFAULT_CIPHERS_JAVA8;
     }
+
+    /**
+     * Detects the type of KeyStore / TrustStore file from the file extension. If the file name ends with
+     * "".jks"", returns <code>StoreFileType.JKS</code>. If the file name ends with "".pem"", returns
+     * <code>StoreFileType.PEM</code>. Otherwise, throws an IOException.
+     * @param filename the filename of the key store or trust store file.
+     * @return a StoreFileType.
+     * @throws IOException if the filename does not end with "".jks"" or "".pem"".
+     */
+    public static StoreFileType detectStoreFileTypeFromFileExtension(File filename) throws IOException {","[{'comment': ""nit: this can be private\r\nnit: Apache Commons IO library has `FileNameUtils.getExtensions(String filename)` doing pretty much the same\r\n\r\nThis file type detection logic is good. Additionally, given that you're refactoring this to Factory pattern anyway, you could also do probing with the concrete implementations if file type cannot be detected from extension."", 'commenter': 'anmolnar'}, {'comment': 'How about I make it package-private and add a unit test?', 'commenter': 'ivmaykov'}]"
678,NOTICE.txt,"@@ -3,3 +3,9 @@ Copyright 2009-2014 The Apache Software Foundation
 
 This product includes software developed at
 The Apache Software Foundation (http://www.apache.org/).
+
+This product includes software components originally","[{'comment': 'Looks good.\r\nNit: Airlift with the uppercase A', 'commenter': 'eolivelli'}]"
678,zookeeper-server/src/main/java/org/apache/zookeeper/common/FileKeyStoreLoader.java,"@@ -0,0 +1,98 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import java.util.Objects;
+
+/**
+ * Base class for instances of {@link KeyStoreLoader} which load the key/trust
+ * stores from files on a filesystem.
+ */
+abstract class FileKeyStoreLoader implements KeyStoreLoader {
+    final String keyStorePath;
+    final String trustStorePath;
+    final String keyStorePassword;
+    final String trustStorePassword;
+
+    FileKeyStoreLoader(String keyStorePath,
+                       String trustStorePath,
+                       String keyStorePassword,
+                       String trustStorePassword) {
+        this.keyStorePath = keyStorePath;
+        this.trustStorePath = trustStorePath;
+        this.keyStorePassword = keyStorePassword;
+        this.trustStorePassword = trustStorePassword;
+    }
+
+    /**
+     * Base class for builder pattern used by subclasses.
+     * @param <T> the subtype of FileKeyStoreLoader created by the Builder.
+     */
+    static abstract class Builder<T extends FileKeyStoreLoader> {
+        String keyStorePath;
+        String trustStorePath;
+        String keyStorePassword;
+        String trustStorePassword;
+
+        Builder() {}
+
+        Builder<T> setKeyStorePath(String keyStorePath) {
+            this.keyStorePath = Objects.requireNonNull(keyStorePath);
+            return this;
+        }
+
+        Builder<T> setTrustStorePath(String trustStorePath) {
+            this.trustStorePath = Objects.requireNonNull(trustStorePath);
+            return this;
+        }
+
+        Builder<T> setKeyStorePassword(String keyStorePassword) {
+            this.keyStorePassword = Objects.requireNonNull(keyStorePassword);
+            return this;
+        }
+
+        Builder<T> setTrustStorePassword(String trustStorePassword) {
+            this.trustStorePassword = Objects.requireNonNull(trustStorePassword);
+            return this;
+        }
+
+        abstract T build();
+    }
+
+    /**
+     * Returns a {@link FileKeyStoreLoader.Builder} that can build a loader
+     * which loads keys and certs from files of the given
+     * {@link KeyStoreFileType}.
+     *
+     * @param type the file type to load keys/certs from.
+     * @return a new Builder.
+     */
+    static Builder<? extends FileKeyStoreLoader> getBuilderForKeyStoreFileType(","[{'comment': 'getBuilderForKeyStoreFileType is depending on loader implementation classes  .This may lead to the subclasses of this also depend on other loader implementation classes. How about moving this to something like BuilderProvider?It is better abstraction not to depend on concrete', 'commenter': 'tumativ'}]"
678,zookeeper-server/src/main/java/org/apache/zookeeper/common/JKSFileLoader.java,"@@ -0,0 +1,67 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+
+/**
+ * Implementation of {@link FileKeyStoreLoader} that loads from JKS files.
+ */
+class JKSFileLoader extends FileKeyStoreLoader {
+    private static final char[] EMPTY_CHAR_ARRAY = new char[0];
+
+    private JKSFileLoader(String keyStorePath,
+                          String trustStorePath,
+                          String keyStorePassword,
+                          String trustStorePassword) {
+        super(keyStorePath, trustStorePath, keyStorePassword, trustStorePassword);
+    }
+
+    @Override
+    public KeyStore loadKeyStore() throws IOException, GeneralSecurityException {
+        KeyStore ks = KeyStore.getInstance(""JKS"");","[{'comment': 'Can we declare global final variable for ""JKS""  and refer in code?', 'commenter': 'tumativ'}]"
678,zookeeper-server/src/main/java/org/apache/zookeeper/common/FileKeyStoreLoader.java,"@@ -0,0 +1,98 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import java.util.Objects;
+
+/**
+ * Base class for instances of {@link KeyStoreLoader} which load the key/trust
+ * stores from files on a filesystem.
+ */
+abstract class FileKeyStoreLoader implements KeyStoreLoader {
+    final String keyStorePath;
+    final String trustStorePath;
+    final String keyStorePassword;
+    final String trustStorePassword;
+
+    FileKeyStoreLoader(String keyStorePath,","[{'comment': 'How about changing the keyStorePath and trustStorePathto URL?So that it can be leveraged for other use cases?Let builder take file path and convert it to URL.', 'commenter': 'tumativ'}]"
678,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -221,27 +229,47 @@ public SSLContext createSSLContext(ZKConfig config) throws SSLContextException {
         }
     }
 
-    public static X509KeyManager createKeyManager(String keyStoreLocation, String keyStorePassword)
+    /**
+     * Creates a key manager by loading the key store from the given file of
+     * the given type, optionally decrypting it using the given password.
+     * @param keyStoreLocation the location of the key store file.
+     * @param keyStorePassword optional password to decrypt the key store. If
+     *                         empty, assumes the key store is not encrypted.
+     * @param keyStoreTypeProp must be JKS, PEM, or null. If null, attempts to
+     *                         autodetect the key store type from the file
+     *                         extension (.jks / .pem).
+     * @return the key manager.
+     * @throws KeyManagerException if something goes wrong.
+     */
+    public static X509KeyManager createKeyManager(
+            String keyStoreLocation,
+            String keyStorePassword,
+            String keyStoreTypeProp)
             throws KeyManagerException {
         FileInputStream inputStream = null;
+        if (keyStorePassword == null) {
+            keyStorePassword = """";
+        }
         try {
-            char[] keyStorePasswordChars = keyStorePassword.toCharArray();
-            File keyStoreFile = new File(keyStoreLocation);
-            KeyStore ks = KeyStore.getInstance(""JKS"");
-            inputStream = new FileInputStream(keyStoreFile);
-            ks.load(inputStream, keyStorePasswordChars);
+            KeyStoreFileType storeFileType =","[{'comment': 'IllegalArgumentException is possible here. I see it is not handled.', 'commenter': 'tumativ'}]"
678,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -254,23 +282,54 @@ public static X509KeyManager createKeyManager(String keyStoreLocation, String ke
         }
     }
 
-    public static X509TrustManager createTrustManager(String trustStoreLocation, String trustStorePassword,
-                                                      boolean crlEnabled, boolean ocspEnabled,
-                                                      final boolean serverHostnameVerificationEnabled,
-                                                      final boolean clientHostnameVerificationEnabled)
+    /**
+     * Creates a trust manager by loading the trust store from the given file
+     * of the given type, optionally decrypting it using the given password.
+     * @param trustStoreLocation the location of the trust store file.
+     * @param trustStorePassword optional password to decrypt the trust store
+     *                           (only applies to JKS trust stores). If empty,
+     *                           assumes the trust store is not encrypted.
+     * @param trustStoreTypeProp must be JKS, PEM, or null. If null, attempts
+     *                           to autodetect the trust store type from the
+     *                           file extension (.jks / .pem).
+     * @param crlEnabled enable CRL (certificate revocation list) checks.
+     * @param ocspEnabled enable OCSP (online certificate status protocol)
+     *                    checks.
+     * @param serverHostnameVerificationEnabled if true, verify hostnames of
+     *                                          remote servers that client
+     *                                          sockets created by this
+     *                                          X509Util connect to.
+     * @param clientHostnameVerificationEnabled if true, verify hostnames of
+     *                                          remote clients that server
+     *                                          sockets created by this
+     *                                          X509Util accept connections
+     *                                          from.
+     * @return the trust manager.
+     * @throws TrustManagerException if something goes wrong.
+     */
+    public static X509TrustManager createTrustManager(
+            String trustStoreLocation,
+            String trustStorePassword,
+            String trustStoreTypeProp,
+            boolean crlEnabled,
+            boolean ocspEnabled,
+            final boolean serverHostnameVerificationEnabled,
+            final boolean clientHostnameVerificationEnabled)
             throws TrustManagerException {
         FileInputStream inputStream = null;
+        if (trustStorePassword == null) {
+            trustStorePassword = """";
+        }
         try {
-            File trustStoreFile = new File(trustStoreLocation);
-            KeyStore ts = KeyStore.getInstance(""JKS"");
-            inputStream = new FileInputStream(trustStoreFile);
-            if (trustStorePassword != null) {
-                char[] trustStorePasswordChars = trustStorePassword.toCharArray();
-                ts.load(inputStream, trustStorePasswordChars);
-            } else {
-                ts.load(inputStream, null);
-            }
-
+            KeyStoreFileType storeFileType =","[{'comment': 'IllegalArgumentException is possible here. I see it not handled', 'commenter': 'tumativ'}]"
679,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -350,14 +389,22 @@ public static X509TrustManager createTrustManager(
     public SSLSocket createSSLSocket() throws X509Exception, IOException {
         SSLSocket sslSocket = (SSLSocket) getDefaultSSLContext().getSocketFactory().createSocket();
         configureSSLSocket(sslSocket);
-
+        sslSocket.setUseClientMode(true);
         return sslSocket;
     }
 
-    public SSLSocket createSSLSocket(Socket socket) throws X509Exception, IOException {
-        SSLSocket sslSocket = (SSLSocket) getDefaultSSLContext().getSocketFactory().createSocket(socket, null, socket.getPort(), true);
+    public SSLSocket createSSLSocket(Socket socket, byte[] pushbackBytes) throws X509Exception, IOException {
+        SSLSocket sslSocket;
+        if (pushbackBytes != null && pushbackBytes.length > 0) {
+            sslSocket = (SSLSocket) getDefaultSSLContext().getSocketFactory().createSocket(
+                    socket, new ByteArrayInputStream(pushbackBytes), true);
+        } else {
+            sslSocket = (SSLSocket) getDefaultSSLContext().getSocketFactory().createSocket(
+                    socket, null, socket.getPort(), true);
+        }
         configureSSLSocket(sslSocket);
-
+        sslSocket.setUseClientMode(false);","[{'comment': 'Just to double check what you changed here:\r\n- setting the client mode explicitly on both client/server side,\r\n- requesting client authentication in TLS mode: so without client authentication, quorum TLS cannot be established anymore', 'commenter': 'anmolnar'}, {'comment': 'Yes and yes. In #681 I make the client auth setting configurable.', 'commenter': 'ivmaykov'}]"
679,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/PrependableSocket.java,"@@ -18,32 +18,47 @@
 
 package org.apache.zookeeper.server.quorum;
 
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.SequenceInputStream;
+import java.io.PushbackInputStream;
 import java.net.Socket;
 import java.net.SocketImpl;
 
 public class PrependableSocket extends Socket {
 
-  private SequenceInputStream sequenceInputStream;
+  private PushbackInputStream pushbackInputStream;","[{'comment': 'Please explain again what exactly was the problem with `SequenceInputStream`?\r\nWhy did it return only the first 5 bytes after it had been prepended?', 'commenter': 'anmolnar'}, {'comment': ""I don't know why it worked like that, but that is what I observed in tests. It looks like SequenceInputStream does not join returned data across boundaries of the underlying streams when the first stream gets to EOF. I don't think this is desired behavior since it would cause the stream to return 5 bytes when more than 5 bytes are actually available."", 'commenter': 'ivmaykov'}, {'comment': ""But I suspect the second read() will read from the other stream of the Sequence. Which is okay, because client has to initiate another read call if it hasn't received everything it needed.\r\nAnyway I wouldn't say go back to that impl, just speculating. I believe handling the 2 streams seamlessly is desirable."", 'commenter': 'anmolnar'}, {'comment': 'Yes, SequenceInputStream likely still works in practice, but exposes the discontinuity between the underlying streams to the caller. Using PushbackInputStream hides it and I think is preferable.', 'commenter': 'ivmaykov'}]"
679,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/UnifiedServerSocketTest.java,"@@ -17,156 +17,644 @@
  */
 package org.apache.zookeeper.server.quorum;
 
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.net.ConnectException;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.net.SocketException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Random;
+
+import javax.net.ssl.HandshakeCompletedEvent;
+import javax.net.ssl.HandshakeCompletedListener;
+import javax.net.ssl.SSLSocket;
+
 import org.apache.zookeeper.PortAssignment;
 import org.apache.zookeeper.client.ZKClientConfig;
+import org.apache.zookeeper.common.BaseX509ParameterizedTestCase;
 import org.apache.zookeeper.common.ClientX509Util;
-import org.apache.zookeeper.common.Time;
+import org.apache.zookeeper.common.KeyStoreFileType;
+import org.apache.zookeeper.common.X509Exception;
+import org.apache.zookeeper.common.X509KeyType;
+import org.apache.zookeeper.common.X509TestContext;
 import org.apache.zookeeper.common.X509Util;
 import org.apache.zookeeper.server.ServerCnxnFactory;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
-import javax.net.ssl.HandshakeCompletedEvent;
-import javax.net.ssl.HandshakeCompletedListener;
-import javax.net.ssl.SSLSocket;
-import java.io.IOException;
-import java.net.ConnectException;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
+@RunWith(Parameterized.class)
+public class UnifiedServerSocketTest extends BaseX509ParameterizedTestCase {
 
-public class UnifiedServerSocketTest {
+    @Parameterized.Parameters
+    public static Collection<Object[]> params() {
+        ArrayList<Object[]> result = new ArrayList<>();
+        int paramIndex = 0;
+        for (X509KeyType caKeyType : X509KeyType.values()) {
+            for (X509KeyType certKeyType : X509KeyType.values()) {
+                for (Boolean hostnameVerification : new Boolean[] { true, false  }) {
+                    result.add(new Object[]{
+                            caKeyType,
+                            certKeyType,
+                            hostnameVerification,
+                            paramIndex++
+                    });
+                }
+            }
+        }
+        return result;
+    }
 
     private static final int MAX_RETRIES = 5;
     private static final int TIMEOUT = 1000;
+    private static final byte[] DATA_TO_CLIENT = ""hello client"".getBytes();
+    private static final byte[] DATA_FROM_CLIENT = ""hello server"".getBytes();
 
     private X509Util x509Util;
     private int port;
-    private volatile boolean handshakeCompleted;
+    private InetSocketAddress localServerAddress;
+    private final Object handshakeCompletedLock = new Object();
+    // access only inside synchronized(handshakeCompletedLock) { ... } blocks
+    private boolean handshakeCompleted = false;
+
+    public UnifiedServerSocketTest(
+            final X509KeyType caKeyType,
+            final X509KeyType certKeyType,
+            final Boolean hostnameVerification,
+            final Integer paramIndex) {
+        super(paramIndex, () -> {
+            try {
+                return X509TestContext.newBuilder()
+                    .setTempDir(tempDir)
+                    .setKeyStoreKeyType(certKeyType)
+                    .setTrustStoreKeyType(caKeyType)
+                    .setHostnameVerification(hostnameVerification)
+                    .build();
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        });
+    }
 
     @Before
     public void setUp() throws Exception {
-        handshakeCompleted = false;
-
         port = PortAssignment.unique();
+        localServerAddress = new InetSocketAddress(""localhost"", port);
 
-        String testDataPath = System.getProperty(""test.data.dir"", ""build/test/data"");
         System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, ""org.apache.zookeeper.server.NettyServerCnxnFactory"");
         System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, ""org.apache.zookeeper.ClientCnxnSocketNetty"");
         System.setProperty(ZKClientConfig.SECURE_CLIENT, ""true"");
 
         x509Util = new ClientX509Util();
 
-        System.setProperty(x509Util.getSslKeystoreLocationProperty(), testDataPath + ""/ssl/testKeyStore.jks"");
-        System.setProperty(x509Util.getSslKeystorePasswdProperty(), ""testpass"");
-        System.setProperty(x509Util.getSslTruststoreLocationProperty(), testDataPath + ""/ssl/testTrustStore.jks"");
-        System.setProperty(x509Util.getSslTruststorePasswdProperty(), ""testpass"");
-        System.setProperty(x509Util.getSslHostnameVerificationEnabledProperty(), ""false"");
+        x509TestContext.setSystemProperties(x509Util, KeyStoreFileType.JKS, KeyStoreFileType.JKS);
     }
 
-    @Test
-    public void testConnectWithSSL() throws Exception {
-        class ServerThread extends Thread {
-            public void run() {
-                try {
-                    Socket unifiedSocket = new UnifiedServerSocket(x509Util, port).accept();
-                    ((SSLSocket)unifiedSocket).getSession(); // block until handshake completes
-                } catch (IOException e) {
-                    e.printStackTrace();
+    private static void forceClose(java.io.Closeable s) {
+        if (s == null) {
+            return;
+        }
+        try {
+            s.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static final class UnifiedServerThread extends Thread {
+        private final byte[] dataToClient;
+        private List<byte[]> dataFromClients;
+        private List<Thread> workerThreads;","[{'comment': 'Use some `Executor` instead?', 'commenter': 'anmolnar'}, {'comment': ""I used explicit threads because that's what we do in Leader.java - create a dedicated Thread per connection. I wanted the threading in the test to be as close as possible to the real use case. I could change it to an Executor if you want, but don't see that much value in such a change."", 'commenter': 'ivmaykov'}, {'comment': ""Creating tests as close as possible to the original impl is nice, but you're still testing a different thing anyway. Executors are good for dealing with threads and I think they're preferred over manual thread creation if acceptable. There're various different kinds of them: you can control the thread creation behaviour, number of threads, etc. And I think it leads to more readable code. "", 'commenter': 'anmolnar'}, {'comment': 'Sure, will change it to an Executor', 'commenter': 'ivmaykov'}, {'comment': 'Done', 'commenter': 'ivmaykov'}]"
679,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/UnifiedServerSocketTest.java,"@@ -17,156 +17,644 @@
  */
 package org.apache.zookeeper.server.quorum;
 
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.net.ConnectException;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.net.SocketException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Random;
+
+import javax.net.ssl.HandshakeCompletedEvent;
+import javax.net.ssl.HandshakeCompletedListener;
+import javax.net.ssl.SSLSocket;
+
 import org.apache.zookeeper.PortAssignment;
 import org.apache.zookeeper.client.ZKClientConfig;
+import org.apache.zookeeper.common.BaseX509ParameterizedTestCase;
 import org.apache.zookeeper.common.ClientX509Util;
-import org.apache.zookeeper.common.Time;
+import org.apache.zookeeper.common.KeyStoreFileType;
+import org.apache.zookeeper.common.X509Exception;
+import org.apache.zookeeper.common.X509KeyType;
+import org.apache.zookeeper.common.X509TestContext;
 import org.apache.zookeeper.common.X509Util;
 import org.apache.zookeeper.server.ServerCnxnFactory;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
-import javax.net.ssl.HandshakeCompletedEvent;
-import javax.net.ssl.HandshakeCompletedListener;
-import javax.net.ssl.SSLSocket;
-import java.io.IOException;
-import java.net.ConnectException;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
+@RunWith(Parameterized.class)
+public class UnifiedServerSocketTest extends BaseX509ParameterizedTestCase {
 
-public class UnifiedServerSocketTest {
+    @Parameterized.Parameters
+    public static Collection<Object[]> params() {
+        ArrayList<Object[]> result = new ArrayList<>();
+        int paramIndex = 0;
+        for (X509KeyType caKeyType : X509KeyType.values()) {
+            for (X509KeyType certKeyType : X509KeyType.values()) {
+                for (Boolean hostnameVerification : new Boolean[] { true, false  }) {
+                    result.add(new Object[]{
+                            caKeyType,
+                            certKeyType,
+                            hostnameVerification,
+                            paramIndex++
+                    });
+                }
+            }
+        }
+        return result;
+    }
 
     private static final int MAX_RETRIES = 5;
     private static final int TIMEOUT = 1000;
+    private static final byte[] DATA_TO_CLIENT = ""hello client"".getBytes();
+    private static final byte[] DATA_FROM_CLIENT = ""hello server"".getBytes();
 
     private X509Util x509Util;
     private int port;
-    private volatile boolean handshakeCompleted;
+    private InetSocketAddress localServerAddress;
+    private final Object handshakeCompletedLock = new Object();
+    // access only inside synchronized(handshakeCompletedLock) { ... } blocks
+    private boolean handshakeCompleted = false;
+
+    public UnifiedServerSocketTest(
+            final X509KeyType caKeyType,
+            final X509KeyType certKeyType,
+            final Boolean hostnameVerification,
+            final Integer paramIndex) {
+        super(paramIndex, () -> {
+            try {
+                return X509TestContext.newBuilder()
+                    .setTempDir(tempDir)
+                    .setKeyStoreKeyType(certKeyType)
+                    .setTrustStoreKeyType(caKeyType)
+                    .setHostnameVerification(hostnameVerification)
+                    .build();
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        });
+    }
 
     @Before
     public void setUp() throws Exception {
-        handshakeCompleted = false;
-
         port = PortAssignment.unique();
+        localServerAddress = new InetSocketAddress(""localhost"", port);","[{'comment': 'Using `InetAddress.getLoopbackAddress()` ?', 'commenter': 'anmolnar'}, {'comment': 'Sure, I could do that if you prefer.', 'commenter': 'ivmaykov'}, {'comment': 'Thanks.', 'commenter': 'anmolnar'}, {'comment': 'Done', 'commenter': 'ivmaykov'}]"
679,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/UnifiedServerSocketTest.java,"@@ -17,156 +17,644 @@
  */
 package org.apache.zookeeper.server.quorum;
 
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.net.ConnectException;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.net.SocketException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Random;
+
+import javax.net.ssl.HandshakeCompletedEvent;
+import javax.net.ssl.HandshakeCompletedListener;
+import javax.net.ssl.SSLSocket;
+
 import org.apache.zookeeper.PortAssignment;
 import org.apache.zookeeper.client.ZKClientConfig;
+import org.apache.zookeeper.common.BaseX509ParameterizedTestCase;
 import org.apache.zookeeper.common.ClientX509Util;
-import org.apache.zookeeper.common.Time;
+import org.apache.zookeeper.common.KeyStoreFileType;
+import org.apache.zookeeper.common.X509Exception;
+import org.apache.zookeeper.common.X509KeyType;
+import org.apache.zookeeper.common.X509TestContext;
 import org.apache.zookeeper.common.X509Util;
 import org.apache.zookeeper.server.ServerCnxnFactory;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
-import javax.net.ssl.HandshakeCompletedEvent;
-import javax.net.ssl.HandshakeCompletedListener;
-import javax.net.ssl.SSLSocket;
-import java.io.IOException;
-import java.net.ConnectException;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
+@RunWith(Parameterized.class)
+public class UnifiedServerSocketTest extends BaseX509ParameterizedTestCase {
 
-public class UnifiedServerSocketTest {
+    @Parameterized.Parameters
+    public static Collection<Object[]> params() {
+        ArrayList<Object[]> result = new ArrayList<>();
+        int paramIndex = 0;
+        for (X509KeyType caKeyType : X509KeyType.values()) {
+            for (X509KeyType certKeyType : X509KeyType.values()) {
+                for (Boolean hostnameVerification : new Boolean[] { true, false  }) {
+                    result.add(new Object[]{
+                            caKeyType,
+                            certKeyType,
+                            hostnameVerification,
+                            paramIndex++
+                    });
+                }
+            }
+        }
+        return result;
+    }
 
     private static final int MAX_RETRIES = 5;
     private static final int TIMEOUT = 1000;
+    private static final byte[] DATA_TO_CLIENT = ""hello client"".getBytes();
+    private static final byte[] DATA_FROM_CLIENT = ""hello server"".getBytes();
 
     private X509Util x509Util;
     private int port;
-    private volatile boolean handshakeCompleted;
+    private InetSocketAddress localServerAddress;
+    private final Object handshakeCompletedLock = new Object();
+    // access only inside synchronized(handshakeCompletedLock) { ... } blocks
+    private boolean handshakeCompleted = false;
+
+    public UnifiedServerSocketTest(
+            final X509KeyType caKeyType,
+            final X509KeyType certKeyType,
+            final Boolean hostnameVerification,
+            final Integer paramIndex) {
+        super(paramIndex, () -> {
+            try {
+                return X509TestContext.newBuilder()
+                    .setTempDir(tempDir)
+                    .setKeyStoreKeyType(certKeyType)
+                    .setTrustStoreKeyType(caKeyType)
+                    .setHostnameVerification(hostnameVerification)
+                    .build();
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        });
+    }
 
     @Before
     public void setUp() throws Exception {
-        handshakeCompleted = false;
-
         port = PortAssignment.unique();
+        localServerAddress = new InetSocketAddress(""localhost"", port);
 
-        String testDataPath = System.getProperty(""test.data.dir"", ""build/test/data"");
         System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, ""org.apache.zookeeper.server.NettyServerCnxnFactory"");
         System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, ""org.apache.zookeeper.ClientCnxnSocketNetty"");
         System.setProperty(ZKClientConfig.SECURE_CLIENT, ""true"");
 
         x509Util = new ClientX509Util();
 
-        System.setProperty(x509Util.getSslKeystoreLocationProperty(), testDataPath + ""/ssl/testKeyStore.jks"");
-        System.setProperty(x509Util.getSslKeystorePasswdProperty(), ""testpass"");
-        System.setProperty(x509Util.getSslTruststoreLocationProperty(), testDataPath + ""/ssl/testTrustStore.jks"");
-        System.setProperty(x509Util.getSslTruststorePasswdProperty(), ""testpass"");
-        System.setProperty(x509Util.getSslHostnameVerificationEnabledProperty(), ""false"");
+        x509TestContext.setSystemProperties(x509Util, KeyStoreFileType.JKS, KeyStoreFileType.JKS);
     }
 
-    @Test
-    public void testConnectWithSSL() throws Exception {
-        class ServerThread extends Thread {
-            public void run() {
-                try {
-                    Socket unifiedSocket = new UnifiedServerSocket(x509Util, port).accept();
-                    ((SSLSocket)unifiedSocket).getSession(); // block until handshake completes
-                } catch (IOException e) {
-                    e.printStackTrace();
+    private static void forceClose(java.io.Closeable s) {
+        if (s == null) {
+            return;
+        }
+        try {
+            s.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static final class UnifiedServerThread extends Thread {
+        private final byte[] dataToClient;
+        private List<byte[]> dataFromClients;
+        private List<Thread> workerThreads;
+        private UnifiedServerSocket serverSocket;
+
+        UnifiedServerThread(X509Util x509Util,
+                            InetSocketAddress bindAddress,
+                            boolean allowInsecureConnection,
+                            byte[] dataToClient) throws IOException {
+            this.dataToClient = dataToClient;
+            dataFromClients = new ArrayList<>();
+            workerThreads = new ArrayList<>();
+            serverSocket = new UnifiedServerSocket(x509Util, allowInsecureConnection);
+            serverSocket.bind(bindAddress);
+        }
+
+        @Override
+        public void run() {
+            try {
+                Random rnd = new Random();
+                while (true) {
+                    final Socket unifiedSocket = serverSocket.accept();
+                    final boolean tcpNoDelay = rnd.nextBoolean();
+                    unifiedSocket.setTcpNoDelay(tcpNoDelay);
+                    unifiedSocket.setSoTimeout(TIMEOUT);
+                    final boolean keepAlive = rnd.nextBoolean();
+                    unifiedSocket.setKeepAlive(keepAlive);
+                    // Note: getting the input stream should not block the thread or trigger mode detection.
+                    BufferedInputStream bis = new BufferedInputStream(unifiedSocket.getInputStream());
+                    Thread t = new Thread(new Runnable() {
+                        @Override
+                        public void run() {
+                            try {
+                                byte[] buf = new byte[1024];
+                                int bytesRead = unifiedSocket.getInputStream().read(buf, 0, 1024);
+                                // Make sure the settings applied above before the socket was potentially upgraded to
+                                // TLS still apply.
+                                Assert.assertEquals(tcpNoDelay, unifiedSocket.getTcpNoDelay());
+                                Assert.assertEquals(TIMEOUT, unifiedSocket.getSoTimeout());
+                                Assert.assertEquals(keepAlive, unifiedSocket.getKeepAlive());
+                                if (bytesRead > 0) {
+                                    byte[] dataFromClient = new byte[bytesRead];
+                                    System.arraycopy(buf, 0, dataFromClient, 0, bytesRead);
+                                    synchronized (dataFromClients) {
+                                        dataFromClients.add(dataFromClient);
+                                    }
+                                }
+                                unifiedSocket.getOutputStream().write(dataToClient);
+                                unifiedSocket.getOutputStream().flush();
+                            } catch (IOException e) {
+                                e.printStackTrace();
+                                throw new RuntimeException(e);
+                            } finally {
+                                forceClose(unifiedSocket);
+                            }
+                        }
+                    });
+                    workerThreads.add(t);
+                    t.start();
                 }
+            } catch (IOException e) {
+                e.printStackTrace();
+                throw new RuntimeException(e);
+            } finally {
+                forceClose(serverSocket);
             }
         }
-        ServerThread serverThread = new ServerThread();
-        serverThread.start();
 
+        public void shutdown(long millis) throws InterruptedException {
+            forceClose(serverSocket); // this should break the run() loop
+            for (Thread t : workerThreads) {
+                t.join(millis);
+            }
+            this.join(millis);
+        }
+
+        synchronized byte[] getDataFromClient(int index) {
+            return dataFromClients.get(index);
+        }
+    }
+
+    private SSLSocket connectWithSSL() throws IOException, X509Exception, InterruptedException {
         SSLSocket sslSocket = null;
         int retries = 0;
         while (retries < MAX_RETRIES) {
             try {
                 sslSocket = x509Util.createSSLSocket();
+                sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {
+                    @Override
+                    public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent) {
+                        synchronized (handshakeCompletedLock) {
+                            handshakeCompleted = true;
+                            handshakeCompletedLock.notifyAll();
+                        }
+                    }
+                });
                 sslSocket.setSoTimeout(TIMEOUT);
-                sslSocket.connect(new InetSocketAddress(port), TIMEOUT);
+                sslSocket.connect(localServerAddress, TIMEOUT);
                 break;
             } catch (ConnectException connectException) {
                 connectException.printStackTrace();
+                forceClose(sslSocket);
+                sslSocket = null;
                 Thread.sleep(TIMEOUT);
             }
             retries++;
         }
 
-        sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {
-            @Override
-            public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent) {
-                completeHandshake();
+        Assert.assertNotNull(""Failed to connect to server with SSL"", sslSocket);
+        return sslSocket;
+    }
+
+    private Socket connectWithoutSSL() throws IOException, InterruptedException {
+        Socket socket = null;
+        int retries = 0;
+        while (retries < MAX_RETRIES) {
+            try {
+                socket = new Socket();
+                socket.setSoTimeout(TIMEOUT);
+                socket.connect(localServerAddress, TIMEOUT);
+                break;
+            } catch (ConnectException connectException) {
+                connectException.printStackTrace();
+                forceClose(socket);
+                socket = null;
+                Thread.sleep(TIMEOUT);
             }
-        });
-        sslSocket.startHandshake();
+            retries++;
+        }
+        Assert.assertNotNull(""Failed to connect to server without SSL"", socket);
+        return socket;
+    }
+
+    // In the tests below, a ""Strict"" server means a UnifiedServerSocket that
+    // does not allow plaintext connections (in other words, it's SSL-only).
+    // A ""Non Strict"" server means a UnifiedServerSocket that allows both
+    // plaintext and SSL incoming connections.
+
+    /**
+     * Attempting to connect to a SSL-or-plaintext server with SSL should work.
+     */
+    @Test
+    public void testConnectWithSSLToNonStrictServer() throws Exception {
+        UnifiedServerThread serverThread = new UnifiedServerThread(
+                x509Util, localServerAddress, true, DATA_TO_CLIENT);
+        serverThread.start();
 
-        serverThread.join(TIMEOUT);
+        Socket sslSocket = connectWithSSL();
+        sslSocket.getOutputStream().write(DATA_FROM_CLIENT);
+        sslSocket.getOutputStream().flush();
+        byte[] buf = new byte[DATA_TO_CLIENT.length];
+        int bytesRead = sslSocket.getInputStream().read(buf, 0, buf.length);
+        Assert.assertEquals(buf.length, bytesRead);
+        Assert.assertArrayEquals(DATA_TO_CLIENT, buf);
 
-        long start = Time.currentElapsedTime();
-        while (Time.currentElapsedTime() < start + TIMEOUT) {
-            if (handshakeCompleted) {
-                return;
+        serverThread.shutdown(TIMEOUT);
+        forceClose(sslSocket);
+
+        synchronized (handshakeCompletedLock) {
+            if (!handshakeCompleted) {
+                handshakeCompletedLock.wait(TIMEOUT);
             }
+            Assert.assertTrue(handshakeCompleted);
         }
+        Assert.assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));
+    }
+
+    /**
+     * Attempting to connect to a SSL-only server with SSL should work.
+     */
+    @Test
+    public void testConnectWithSSLToStrictServer() throws Exception {
+        UnifiedServerThread serverThread = new UnifiedServerThread(
+                x509Util, localServerAddress, false, DATA_TO_CLIENT);
+        serverThread.start();
+
+        Socket sslSocket = connectWithSSL();
+        sslSocket.getOutputStream().write(DATA_FROM_CLIENT);
+        sslSocket.getOutputStream().flush();
+        byte[] buf = new byte[DATA_TO_CLIENT.length];
+        int bytesRead = sslSocket.getInputStream().read(buf, 0, buf.length);
+        Assert.assertEquals(buf.length, bytesRead);
+        Assert.assertArrayEquals(DATA_TO_CLIENT, buf);
 
-        Assert.fail(""failed to complete handshake"");
+        serverThread.shutdown(TIMEOUT);
+        forceClose(sslSocket);
+
+        synchronized (handshakeCompletedLock) {
+            if (!handshakeCompleted) {
+                handshakeCompletedLock.wait(TIMEOUT);
+            }
+            Assert.assertTrue(handshakeCompleted);
+        }
+
+        Assert.assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));
     }
 
-    private void completeHandshake() {
-        handshakeCompleted = true;
+    /**
+     * Attempting to connect to a SSL-or-plaintext server without SSL should work.
+     */
+    @Test
+    public void testConnectWithoutSSLToNonStrictServer() throws Exception {
+        UnifiedServerThread serverThread = new UnifiedServerThread(
+                x509Util, localServerAddress, true, DATA_TO_CLIENT);
+        serverThread.start();
+
+        Socket socket = connectWithoutSSL();
+        socket.getOutputStream().write(DATA_FROM_CLIENT);
+        socket.getOutputStream().flush();
+        byte[] buf = new byte[DATA_TO_CLIENT.length];
+        int bytesRead = socket.getInputStream().read(buf, 0, buf.length);
+        Assert.assertEquals(buf.length, bytesRead);
+        Assert.assertArrayEquals(DATA_TO_CLIENT, buf);
+
+        serverThread.shutdown(TIMEOUT);
+        forceClose(socket);
+
+        Assert.assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));
     }
 
+    /**
+     * Attempting to connect to a SSL-or-plaintext server without SSL with a
+     * small initial data write should work. This makes sure that sending
+     * less than 5 bytes does not break the logic in the server's initial 5
+     * byte read.
+     */
     @Test
-    public void testConnectWithoutSSL() throws Exception {
-        final byte[] testData = ""hello there"".getBytes();
-        final String[] dataReadFromClient = {null};
+    public void testConnectWithoutSSLToNonStrictServerPartialWrite() throws Exception {
+        UnifiedServerThread serverThread = new UnifiedServerThread(
+                x509Util, localServerAddress, true, DATA_TO_CLIENT);
+        serverThread.start();
+
+        Socket socket = connectWithoutSSL();
+        // Write only 2 bytes of the message, wait a bit, then write the rest.
+        // This makes sure that writes smaller than 5 bytes don't break the plaintext mode on the server
+        // once it decides that the input doesn't look like a TLS handshake.
+        socket.getOutputStream().write(DATA_FROM_CLIENT, 0, 2);
+        socket.getOutputStream().flush();
+        Thread.sleep(TIMEOUT / 2);
+        socket.getOutputStream().write(DATA_FROM_CLIENT, 2, DATA_FROM_CLIENT.length - 2);
+        socket.getOutputStream().flush();
+        byte[] buf = new byte[DATA_TO_CLIENT.length];
+        int bytesRead = socket.getInputStream().read(buf, 0, buf.length);
+        Assert.assertEquals(buf.length, bytesRead);
+        Assert.assertArrayEquals(DATA_TO_CLIENT, buf);
+
+        serverThread.shutdown(TIMEOUT);
+        forceClose(socket);
 
-        class ServerThread extends Thread {
+        Assert.assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));
+    }
+
+    /**
+     * Attempting to connect to a SSL-only server without SSL should fail.
+     */
+    @Test
+    public void testConnectWithoutSSLToStrictServer() throws Exception {
+        UnifiedServerThread serverThread = new UnifiedServerThread(
+                x509Util, localServerAddress, false, DATA_TO_CLIENT);
+        serverThread.start();
+
+        Socket socket = connectWithoutSSL();
+        socket.getOutputStream().write(DATA_FROM_CLIENT);
+        socket.getOutputStream().flush();
+        byte[] buf = new byte[DATA_TO_CLIENT.length];
+        try {
+            socket.getInputStream().read(buf, 0, buf.length);
+        } catch (SocketException e) {
+            // We expect the other end to hang up the connection
+            return;
+        } finally {
+            serverThread.shutdown(TIMEOUT);
+            forceClose(socket);
+        }
+        Assert.fail(""Expected server to hang up the connection. Read from server succeeded unexpectedly."");
+    }
+
+    /**
+     * This test makes sure that UnifiedServerSocket used properly (a single thread accept()-ing connections and
+     * handing the resulting sockets to other threads for processing) is not vulnerable to a simple denial-of-service
+     * attack in which a client connects and never writes any bytes. This should not block the accepting thread, since
+     * the read to determine if the client is sending a TLS handshake or not happens in the processing thread.
+     *
+     * This version of the test uses a non-strict server socket (i.e. it accepts both TLS and plaintext connections).
+     */
+    @Test
+    public void testDenialOfServiceResistanceNonStrictServer() throws Exception {
+        UnifiedServerThread serverThread = new UnifiedServerThread(","[{'comment': 'In these DOS tests you\'re actually testing the `UnifiedServerThread` implementation which is a test-only thing. Does it make sense or am I missing something here?\r\n\r\nIn ""reality"" the accept thread is basically the `Leader` and the one which does TLS handshake is the `LearnerHandler`.', 'commenter': 'anmolnar'}, {'comment': 'This is true. I tried to make the threading behavior in this test as similar as possible to `Leader`. I don\'t think Leader should be involved in this unit test, but perhaps a similar ""denial of service resistance"" test case can be added to some quorum test. Do you know which unit test would be a good place for such a test case?', 'commenter': 'ivmaykov'}, {'comment': 'I would create new test class inherited from `QuorumPeerTestBase` dedicated to DOS tests, but I think this topic leads to another: stress testing ZooKeeper. I highly support the effort, but please remove them from this PR and create separate Jira for that.', 'commenter': 'anmolnar'}, {'comment': ""How about we keep the unit test that's focused strictly on UnifiedServerSocket in this PR, and I'll open a separate PR/Jira for adding a new unit test that tests `Leader`? There is some value in the existing tests, since they did catch issues with the original UnifiedServerSocket implementation."", 'commenter': 'ivmaykov'}, {'comment': '@ivmaykov That\'s pretty much the same as I suggested: keep all unit tests except the ones which contains the word ""dos"". Also please open a new jira about adding DOS tests.', 'commenter': 'anmolnar'}]"
680,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -546,4 +557,109 @@ public static StoreFileType detectStoreFileTypeFromFileExtension(File filename)
         }
         throw new IOException(""Unable to auto-detect store file type from file name: "" + filename);
     }
+
+    /**
+     * Enables automatic reloading of the trust store and key store files when they change on disk.
+     *
+     * @throws IOException if creating the FileChangeWatcher objects fails.
+     */
+    public void enableCertFileReloading() throws IOException {
+        ZKConfig config = new ZKConfig();
+        String keyStoreLocation = config.getProperty(sslKeystoreLocationProperty);
+        if (keyStoreLocation != null && !keyStoreLocation.isEmpty()) {
+            final Path filePath = Paths.get(keyStoreLocation).toAbsolutePath();
+            FileChangeWatcher newKeyStoreFileWatcher = new FileChangeWatcher(
+                    filePath.getParent(),
+                    new Consumer<WatchEvent<?>>() {
+                        @Override
+                        public void accept(WatchEvent<?> watchEvent) {
+                            handleWatchEvent(filePath, watchEvent);
+                        }
+                    });
+            // stop old watcher if there is one
+            if (keyStoreFileWatcher != null) {
+                keyStoreFileWatcher.stop();
+                keyStoreFileWatcher = newKeyStoreFileWatcher;","[{'comment': 'oops, this has a bug that I introduced while refactoring. Will fix.', 'commenter': 'ivmaykov'}]"
680,zookeeper-server/src/main/java/org/apache/zookeeper/common/FileChangeWatcher.java,"@@ -0,0 +1,180 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import com.sun.nio.file.SensitivityWatchEventModifier;
+import org.apache.zookeeper.server.ZooKeeperThread;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.nio.file.ClosedWatchServiceException;
+import java.nio.file.FileSystem;
+import java.nio.file.Path;
+import java.nio.file.StandardWatchEventKinds;
+import java.nio.file.WatchEvent;
+import java.nio.file.WatchKey;
+import java.nio.file.WatchService;
+import java.util.function.Consumer;
+
+/**
+ * Instances of this class can be used to watch a directory for file changes. When a file is added to, deleted from,
+ * or is modified in the given directory, the callback provided by the user will be called from a background thread.
+ * Some things to keep in mind:
+ * <ul>
+ * <li>The callback should be thread-safe.</li>
+ * <li>Changes that happen around the time the thread is started may be missed.</li>
+ * <li>There is a delay between a file changing and the callback firing.</li>
+ * <li>The watch is not recursive - changes to subdirectories will not trigger a callback.</li>
+ * </ul>
+ */
+public final class FileChangeWatcher {
+    private static final Logger LOG = LoggerFactory.getLogger(FileChangeWatcher.class);
+
+    private final WatcherThread watcherThread;
+
+    /**
+     * Creates a watcher that watches <code>dirPath</code> and invokes <code>callback</code> on changes.
+     *
+     * @param dirPath the directory to watch.
+     * @param callback the callback to invoke with events. <code>event.kind()</code> will return the type of event,
+     *                 and <code>event.context()</code> will return the filename relative to <code>dirPath</code>.
+     * @throws IOException if there is an error creating the WatchService.
+     */
+    public FileChangeWatcher(Path dirPath, Consumer<WatchEvent<?>> callback) throws IOException {
+        FileSystem fs = dirPath.getFileSystem();
+        WatchService watchService = fs.newWatchService();
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Registering with watch service: "" + dirPath);
+        }
+        dirPath.register(
+                watchService,
+                new WatchEvent.Kind<?>[]{
+                        StandardWatchEventKinds.ENTRY_CREATE,
+                        StandardWatchEventKinds.ENTRY_DELETE,
+                        StandardWatchEventKinds.ENTRY_MODIFY,
+                        StandardWatchEventKinds.OVERFLOW},
+                SensitivityWatchEventModifier.HIGH);
+        this.watcherThread = new WatcherThread(watchService, callback);
+        this.watcherThread.setDaemon(true);
+        this.watcherThread.start();","[{'comment': 'How about defining the life cycle for file watcher like start, stop etc.   and also define the state of the file watcher like starting, running, not started and stopping etc. The locking is not required if we define the states. The clients can leverage these states if there are any tasks depending on file watcher state', 'commenter': 'tumativ'}, {'comment': ""I think we might still need locking because there is a background thread that's polling the WatchService for events. And starting/stopping the watcher requires starting/stopping the background thread, so some synchronization between threads is needed. Do you still think it makes sense to define life cycle stages if we still need locking?"", 'commenter': 'ivmaykov'}, {'comment': 'Thanks for defining states. ', 'commenter': 'tumativ'}]"
680,zookeeper-server/src/main/java/org/apache/zookeeper/common/FileChangeWatcher.java,"@@ -0,0 +1,180 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import com.sun.nio.file.SensitivityWatchEventModifier;
+import org.apache.zookeeper.server.ZooKeeperThread;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.nio.file.ClosedWatchServiceException;
+import java.nio.file.FileSystem;
+import java.nio.file.Path;
+import java.nio.file.StandardWatchEventKinds;
+import java.nio.file.WatchEvent;
+import java.nio.file.WatchKey;
+import java.nio.file.WatchService;
+import java.util.function.Consumer;
+
+/**
+ * Instances of this class can be used to watch a directory for file changes. When a file is added to, deleted from,
+ * or is modified in the given directory, the callback provided by the user will be called from a background thread.
+ * Some things to keep in mind:
+ * <ul>
+ * <li>The callback should be thread-safe.</li>
+ * <li>Changes that happen around the time the thread is started may be missed.</li>
+ * <li>There is a delay between a file changing and the callback firing.</li>
+ * <li>The watch is not recursive - changes to subdirectories will not trigger a callback.</li>
+ * </ul>
+ */
+public final class FileChangeWatcher {
+    private static final Logger LOG = LoggerFactory.getLogger(FileChangeWatcher.class);
+
+    private final WatcherThread watcherThread;
+
+    /**
+     * Creates a watcher that watches <code>dirPath</code> and invokes <code>callback</code> on changes.
+     *
+     * @param dirPath the directory to watch.
+     * @param callback the callback to invoke with events. <code>event.kind()</code> will return the type of event,
+     *                 and <code>event.context()</code> will return the filename relative to <code>dirPath</code>.
+     * @throws IOException if there is an error creating the WatchService.
+     */
+    public FileChangeWatcher(Path dirPath, Consumer<WatchEvent<?>> callback) throws IOException {
+        FileSystem fs = dirPath.getFileSystem();
+        WatchService watchService = fs.newWatchService();
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Registering with watch service: "" + dirPath);
+        }
+        dirPath.register(
+                watchService,
+                new WatchEvent.Kind<?>[]{
+                        StandardWatchEventKinds.ENTRY_CREATE,
+                        StandardWatchEventKinds.ENTRY_DELETE,
+                        StandardWatchEventKinds.ENTRY_MODIFY,
+                        StandardWatchEventKinds.OVERFLOW},
+                SensitivityWatchEventModifier.HIGH);
+        this.watcherThread = new WatcherThread(watchService, callback);
+        this.watcherThread.setDaemon(true);
+        this.watcherThread.start();
+    }
+
+    /**
+     * Waits for the background thread to enter the main loop before returning. This method exists mostly to make
+     * the unit tests simpler, which is why it is package private.
+     *
+     * @throws InterruptedException if this thread is interrupted while waiting for the background thread to start.
+     */
+    void waitForBackgroundThreadToStart() throws InterruptedException {","[{'comment': 'not able to mock or manage the file watcher generally smell some design improvement.The same logic implemented in test case if we expose the states of file watcher, locking also not required if we expose the state of  file watcher.It is good to avoid adding code for testing purpose', 'commenter': 'tumativ'}, {'comment': ""I'll see what I can do about this."", 'commenter': 'ivmaykov'}]"
680,zookeeper-server/src/main/java/org/apache/zookeeper/common/FileChangeWatcher.java,"@@ -0,0 +1,180 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import com.sun.nio.file.SensitivityWatchEventModifier;
+import org.apache.zookeeper.server.ZooKeeperThread;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.nio.file.ClosedWatchServiceException;
+import java.nio.file.FileSystem;
+import java.nio.file.Path;
+import java.nio.file.StandardWatchEventKinds;
+import java.nio.file.WatchEvent;
+import java.nio.file.WatchKey;
+import java.nio.file.WatchService;
+import java.util.function.Consumer;
+
+/**
+ * Instances of this class can be used to watch a directory for file changes. When a file is added to, deleted from,
+ * or is modified in the given directory, the callback provided by the user will be called from a background thread.
+ * Some things to keep in mind:
+ * <ul>
+ * <li>The callback should be thread-safe.</li>
+ * <li>Changes that happen around the time the thread is started may be missed.</li>
+ * <li>There is a delay between a file changing and the callback firing.</li>
+ * <li>The watch is not recursive - changes to subdirectories will not trigger a callback.</li>
+ * </ul>
+ */
+public final class FileChangeWatcher {
+    private static final Logger LOG = LoggerFactory.getLogger(FileChangeWatcher.class);
+
+    private final WatcherThread watcherThread;
+
+    /**
+     * Creates a watcher that watches <code>dirPath</code> and invokes <code>callback</code> on changes.
+     *
+     * @param dirPath the directory to watch.
+     * @param callback the callback to invoke with events. <code>event.kind()</code> will return the type of event,
+     *                 and <code>event.context()</code> will return the filename relative to <code>dirPath</code>.
+     * @throws IOException if there is an error creating the WatchService.
+     */
+    public FileChangeWatcher(Path dirPath, Consumer<WatchEvent<?>> callback) throws IOException {
+        FileSystem fs = dirPath.getFileSystem();
+        WatchService watchService = fs.newWatchService();
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Registering with watch service: "" + dirPath);
+        }
+        dirPath.register(
+                watchService,
+                new WatchEvent.Kind<?>[]{
+                        StandardWatchEventKinds.ENTRY_CREATE,
+                        StandardWatchEventKinds.ENTRY_DELETE,
+                        StandardWatchEventKinds.ENTRY_MODIFY,
+                        StandardWatchEventKinds.OVERFLOW},
+                SensitivityWatchEventModifier.HIGH);
+        this.watcherThread = new WatcherThread(watchService, callback);
+        this.watcherThread.setDaemon(true);
+        this.watcherThread.start();
+    }
+
+    /**
+     * Waits for the background thread to enter the main loop before returning. This method exists mostly to make
+     * the unit tests simpler, which is why it is package private.
+     *
+     * @throws InterruptedException if this thread is interrupted while waiting for the background thread to start.
+     */
+    void waitForBackgroundThreadToStart() throws InterruptedException {
+        synchronized (watcherThread) {
+            while (!watcherThread.started) {
+                watcherThread.wait();
+            }
+        }
+    }
+
+    /**
+     * Tells the background thread to stop. Does not wait for it to exit.
+     */
+    public void stop() {
+        watcherThread.shouldStop = true;
+        watcherThread.interrupt();
+    }
+
+    /**
+     * Tells the background thread to stop and waits for it to exit. Only used by unit tests, which is why it is package
+     * private.
+     */
+    void stopAndJoinBackgroundThread() throws InterruptedException {","[{'comment': 'same like above comment', 'commenter': 'tumativ'}]"
680,zookeeper-server/src/main/java/org/apache/zookeeper/common/FileChangeWatcher.java,"@@ -0,0 +1,180 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import com.sun.nio.file.SensitivityWatchEventModifier;
+import org.apache.zookeeper.server.ZooKeeperThread;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.nio.file.ClosedWatchServiceException;
+import java.nio.file.FileSystem;
+import java.nio.file.Path;
+import java.nio.file.StandardWatchEventKinds;
+import java.nio.file.WatchEvent;
+import java.nio.file.WatchKey;
+import java.nio.file.WatchService;
+import java.util.function.Consumer;
+
+/**
+ * Instances of this class can be used to watch a directory for file changes. When a file is added to, deleted from,
+ * or is modified in the given directory, the callback provided by the user will be called from a background thread.
+ * Some things to keep in mind:
+ * <ul>
+ * <li>The callback should be thread-safe.</li>
+ * <li>Changes that happen around the time the thread is started may be missed.</li>
+ * <li>There is a delay between a file changing and the callback firing.</li>
+ * <li>The watch is not recursive - changes to subdirectories will not trigger a callback.</li>
+ * </ul>
+ */
+public final class FileChangeWatcher {
+    private static final Logger LOG = LoggerFactory.getLogger(FileChangeWatcher.class);
+
+    private final WatcherThread watcherThread;
+
+    /**
+     * Creates a watcher that watches <code>dirPath</code> and invokes <code>callback</code> on changes.
+     *
+     * @param dirPath the directory to watch.
+     * @param callback the callback to invoke with events. <code>event.kind()</code> will return the type of event,
+     *                 and <code>event.context()</code> will return the filename relative to <code>dirPath</code>.
+     * @throws IOException if there is an error creating the WatchService.
+     */
+    public FileChangeWatcher(Path dirPath, Consumer<WatchEvent<?>> callback) throws IOException {
+        FileSystem fs = dirPath.getFileSystem();
+        WatchService watchService = fs.newWatchService();
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Registering with watch service: "" + dirPath);
+        }
+        dirPath.register(
+                watchService,
+                new WatchEvent.Kind<?>[]{
+                        StandardWatchEventKinds.ENTRY_CREATE,
+                        StandardWatchEventKinds.ENTRY_DELETE,
+                        StandardWatchEventKinds.ENTRY_MODIFY,
+                        StandardWatchEventKinds.OVERFLOW},
+                SensitivityWatchEventModifier.HIGH);
+        this.watcherThread = new WatcherThread(watchService, callback);
+        this.watcherThread.setDaemon(true);
+        this.watcherThread.start();
+    }
+
+    /**
+     * Waits for the background thread to enter the main loop before returning. This method exists mostly to make
+     * the unit tests simpler, which is why it is package private.
+     *
+     * @throws InterruptedException if this thread is interrupted while waiting for the background thread to start.
+     */
+    void waitForBackgroundThreadToStart() throws InterruptedException {
+        synchronized (watcherThread) {
+            while (!watcherThread.started) {
+                watcherThread.wait();
+            }
+        }
+    }
+
+    /**
+     * Tells the background thread to stop. Does not wait for it to exit.
+     */
+    public void stop() {
+        watcherThread.shouldStop = true;
+        watcherThread.interrupt();
+    }
+
+    /**
+     * Tells the background thread to stop and waits for it to exit. Only used by unit tests, which is why it is package
+     * private.
+     */
+    void stopAndJoinBackgroundThread() throws InterruptedException {
+        stop();
+        watcherThread.join();
+    }
+
+    /**
+     * Inner class that implements the watcher thread logic.
+     */
+    private static class WatcherThread extends ZooKeeperThread {
+        private static final String THREAD_NAME = ""FileChangeWatcher"";
+
+        volatile boolean shouldStop;
+        volatile boolean started;
+        final WatchService watchService;
+        final Consumer<WatchEvent<?>> callback;
+
+        WatcherThread(WatchService watchService, Consumer<WatchEvent<?>> callback) {
+            super(THREAD_NAME);
+            this.shouldStop = this.started = false;
+            this.watchService = watchService;
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            LOG.info(getName() + "" thread started"");
+            synchronized (this) {","[{'comment': 'We can eliminate the locking if we expose the  states', 'commenter': 'tumativ'}, {'comment': ""I don't think we can, because we have to synchronize between the background thread that polls the watch service and main thread."", 'commenter': 'ivmaykov'}, {'comment': 'the setState is already synchronized. Can we move this logic to setState as it is more of state management?N o further locking is required here We can simply check the state after setState, proceed if the state is running', 'commenter': 'tumativ'}]"
680,zookeeper-server/src/main/java/org/apache/zookeeper/common/FileChangeWatcher.java,"@@ -0,0 +1,191 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import com.sun.nio.file.SensitivityWatchEventModifier;
+import org.apache.zookeeper.server.ZooKeeperThread;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.nio.file.ClosedWatchServiceException;
+import java.nio.file.FileSystem;
+import java.nio.file.Path;
+import java.nio.file.StandardWatchEventKinds;
+import java.nio.file.WatchEvent;
+import java.nio.file.WatchKey;
+import java.nio.file.WatchService;
+import java.util.function.Consumer;
+
+/**
+ * Instances of this class can be used to watch a directory for file changes. When a file is added to, deleted from,
+ * or is modified in the given directory, the callback provided by the user will be called from a background thread.
+ * Some things to keep in mind:
+ * <ul>
+ * <li>The callback should be thread-safe.</li>
+ * <li>Changes that happen around the time the thread is started may be missed.</li>
+ * <li>There is a delay between a file changing and the callback firing.</li>
+ * <li>The watch is not recursive - changes to subdirectories will not trigger a callback.</li>
+ * </ul>
+ */
+public final class FileChangeWatcher {
+    private static final Logger LOG = LoggerFactory.getLogger(FileChangeWatcher.class);
+
+    public enum State {
+        NEW,      // object created but start() not called yet
+        STARTING, // start() called but background thread has not entered main loop
+        RUNNING,  // background thread is running
+        STOPPING, // stop() called but background thread has not exited main loop
+        STOPPED   // stop() called and background thread has exited, or background thread crashed
+    }
+
+    private final WatcherThread watcherThread;
+    private State state; // protected by synchronized(this)
+
+    /**
+     * Creates a watcher that watches <code>dirPath</code> and invokes <code>callback</code> on changes.
+     *
+     * @param dirPath the directory to watch.
+     * @param callback the callback to invoke with events. <code>event.kind()</code> will return the type of event,
+     *                 and <code>event.context()</code> will return the filename relative to <code>dirPath</code>.
+     * @throws IOException if there is an error creating the WatchService.
+     */
+    public FileChangeWatcher(Path dirPath, Consumer<WatchEvent<?>> callback) throws IOException {
+        FileSystem fs = dirPath.getFileSystem();
+        WatchService watchService = fs.newWatchService();
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Registering with watch service: "" + dirPath);
+        }
+        dirPath.register(
+                watchService,
+                new WatchEvent.Kind<?>[]{
+                        StandardWatchEventKinds.ENTRY_CREATE,
+                        StandardWatchEventKinds.ENTRY_DELETE,
+                        StandardWatchEventKinds.ENTRY_MODIFY,
+                        StandardWatchEventKinds.OVERFLOW},
+                SensitivityWatchEventModifier.HIGH);
+        state = State.NEW;
+        this.watcherThread = new WatcherThread(watchService, callback);
+        this.watcherThread.setDaemon(true);
+    }
+
+    public synchronized State getState() {
+        return state;
+    }
+
+    private synchronized void setState(State newState) {
+        state = newState;
+        this.notifyAll();
+    }
+
+    /**
+     * Tells the background thread to start. Does not wait for it to be running.
+     * Calling this method more than once has no effect.
+     */
+    public synchronized void start() {
+        if (state != State.NEW) {
+            return;
+        }
+        setState(State.STARTING);
+        this.watcherThread.start();
+    }
+
+    /**
+     * Tells the background thread to stop. Does not wait for it to exit.
+     */
+    public synchronized void stop() {
+        if (state == State.STARTING || state == State.RUNNING) {
+            setState(State.STOPPING);
+            watcherThread.interrupt();
+        }
+    }
+
+    /**
+     * Inner class that implements the watcher thread logic.
+     */
+    private class WatcherThread extends ZooKeeperThread {
+        private static final String THREAD_NAME = ""FileChangeWatcher"";
+
+        final WatchService watchService;
+        final Consumer<WatchEvent<?>> callback;
+
+        WatcherThread(WatchService watchService, Consumer<WatchEvent<?>> callback) {
+            super(THREAD_NAME);
+            this.watchService = watchService;
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            try {
+                LOG.info(getName() + "" thread started"");
+                synchronized (FileChangeWatcher.this) {","[{'comment': 'the setState is already synchronized. Can we move this logic to setState as it is more  of state management?N o further locking is required here We can simply check the state after setState, proceed if the state is running', 'commenter': 'tumativ'}, {'comment': ""We have to check the state and modify it within one critical section. If I change the code to this:\r\n\r\n```\r\nif (FileChangeWatcher.this.getState() == FileChangeWatcher.State.STARTING) {\r\n  FileChangeWatcher.this.setState(FileChangeWatcher.State.RUNNING);\r\n}\r\n```\r\n\r\nthen there is a race between me checking the state and changing it. During this time, another thread could call `stop()` and change the state to `STOPPING`. Then I would overwrite `STOPPING` with `RUNNING` and suppress the `stop()` command.\r\n\r\nI should probably document this in a comment so it doesn't get refactored into incorrect code later by someone else."", 'commenter': 'ivmaykov'}, {'comment': 'My intention was, checking and state transition logic can be moved to setState as It is the entry point to change, state transition needs to be managed here.\r\n\r\nThe below can be moved to setState\r\n\r\nif (FileChangeWatcher.this.getState() == FileChangeWatcher.State.STARTING) {\r\n state = FileChangeWatcher.State.RUNNING;\r\n}\r\n\r\nwe can simply check state is RUNNING or not to proceed further in the run method. \r\n\r\n\r\n\r\n', 'commenter': 'tumativ'}, {'comment': 'I don\'t think that logic belongs in `setState()` since it\'s just a simple setter method. Are you proposing I add a new method that\'s something like ""compareAndSetState(State expected, State newState)""?', 'commenter': 'ivmaykov'}, {'comment': 'Yes.Kind of state matrix->(current state,new state)->derived state', 'commenter': 'tumativ'}, {'comment': 'Please see the latest version.', 'commenter': 'ivmaykov'}, {'comment': 'I see it. Thanks for the change.', 'commenter': 'tumativ'}]"
680,zookeeper-server/src/main/java/org/apache/zookeeper/common/FileChangeWatcher.java,"@@ -0,0 +1,191 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import com.sun.nio.file.SensitivityWatchEventModifier;
+import org.apache.zookeeper.server.ZooKeeperThread;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.nio.file.ClosedWatchServiceException;
+import java.nio.file.FileSystem;
+import java.nio.file.Path;
+import java.nio.file.StandardWatchEventKinds;
+import java.nio.file.WatchEvent;
+import java.nio.file.WatchKey;
+import java.nio.file.WatchService;
+import java.util.function.Consumer;
+
+/**
+ * Instances of this class can be used to watch a directory for file changes. When a file is added to, deleted from,
+ * or is modified in the given directory, the callback provided by the user will be called from a background thread.
+ * Some things to keep in mind:
+ * <ul>
+ * <li>The callback should be thread-safe.</li>
+ * <li>Changes that happen around the time the thread is started may be missed.</li>
+ * <li>There is a delay between a file changing and the callback firing.</li>
+ * <li>The watch is not recursive - changes to subdirectories will not trigger a callback.</li>
+ * </ul>
+ */
+public final class FileChangeWatcher {
+    private static final Logger LOG = LoggerFactory.getLogger(FileChangeWatcher.class);
+
+    public enum State {
+        NEW,      // object created but start() not called yet
+        STARTING, // start() called but background thread has not entered main loop
+        RUNNING,  // background thread is running
+        STOPPING, // stop() called but background thread has not exited main loop
+        STOPPED   // stop() called and background thread has exited, or background thread crashed
+    }
+
+    private final WatcherThread watcherThread;
+    private State state; // protected by synchronized(this)
+
+    /**
+     * Creates a watcher that watches <code>dirPath</code> and invokes <code>callback</code> on changes.
+     *
+     * @param dirPath the directory to watch.
+     * @param callback the callback to invoke with events. <code>event.kind()</code> will return the type of event,
+     *                 and <code>event.context()</code> will return the filename relative to <code>dirPath</code>.
+     * @throws IOException if there is an error creating the WatchService.
+     */
+    public FileChangeWatcher(Path dirPath, Consumer<WatchEvent<?>> callback) throws IOException {
+        FileSystem fs = dirPath.getFileSystem();
+        WatchService watchService = fs.newWatchService();
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Registering with watch service: "" + dirPath);
+        }
+        dirPath.register(
+                watchService,
+                new WatchEvent.Kind<?>[]{
+                        StandardWatchEventKinds.ENTRY_CREATE,
+                        StandardWatchEventKinds.ENTRY_DELETE,
+                        StandardWatchEventKinds.ENTRY_MODIFY,
+                        StandardWatchEventKinds.OVERFLOW},
+                SensitivityWatchEventModifier.HIGH);
+        state = State.NEW;
+        this.watcherThread = new WatcherThread(watchService, callback);
+        this.watcherThread.setDaemon(true);
+    }
+
+    public synchronized State getState() {","[{'comment': 'I see some improvement can be done here.Is it required to define method as synchronised. Can we use ReentrantReadWriteLock  and get read lock here? The readers  will not be  blocked if  there is no any write lock .It will be resulted in performance improvement.', 'commenter': 'tumativ'}, {'comment': ""Read/Write locks are slower than exclusive locks (i.e. in Facebook's folly C++ library the locking operations on a `SharedMutex` are about 40x slower than the locking operations on a regular `Mutex` if I remember correctly. I suspect the difference in performance is of a similar order between Java's object monitor lock and `ReentrantReadWriteLock`). So, I would not switch to a R/W lock unless profiling data shows lots of lock contention in read paths. We also can't use `wait()/notify()/notifyAll()` for synchronization in tests unless we use the object monitor lock."", 'commenter': 'ivmaykov'}, {'comment': 'And here is relevant a quote from _Java Concurrency in Practice_ by Brian Goetz et. al (page 286):\r\n\r\n> Read-write locks are a performance optimization designed to allow greater concurrency in certain situations. In practice, read-write locks can improve performance for frequently accessed read-mostly data structures on multiprocessor systems; under other conditions they perform slightly worse than exclusive locks due to their greater complexity. Whether they are an improvement in any given situation is best determined via profiling""', 'commenter': 'ivmaykov'}, {'comment': 'Thanks for the info. ReentrantReadWriteLock may not be relevant in this use case. It will give good results when there are more readers, example reading data from Caching layer etc..', 'commenter': 'tumativ'}, {'comment': ""I agree, there are use cases where a R/W lock is a great choice, but I don't think this is one of them."", 'commenter': 'ivmaykov'}]"
680,zookeeper-server/src/main/java/org/apache/zookeeper/common/FileChangeWatcher.java,"@@ -0,0 +1,191 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import com.sun.nio.file.SensitivityWatchEventModifier;
+import org.apache.zookeeper.server.ZooKeeperThread;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.nio.file.ClosedWatchServiceException;
+import java.nio.file.FileSystem;
+import java.nio.file.Path;
+import java.nio.file.StandardWatchEventKinds;
+import java.nio.file.WatchEvent;
+import java.nio.file.WatchKey;
+import java.nio.file.WatchService;
+import java.util.function.Consumer;
+
+/**
+ * Instances of this class can be used to watch a directory for file changes. When a file is added to, deleted from,
+ * or is modified in the given directory, the callback provided by the user will be called from a background thread.
+ * Some things to keep in mind:
+ * <ul>
+ * <li>The callback should be thread-safe.</li>
+ * <li>Changes that happen around the time the thread is started may be missed.</li>
+ * <li>There is a delay between a file changing and the callback firing.</li>
+ * <li>The watch is not recursive - changes to subdirectories will not trigger a callback.</li>
+ * </ul>
+ */
+public final class FileChangeWatcher {
+    private static final Logger LOG = LoggerFactory.getLogger(FileChangeWatcher.class);
+
+    public enum State {
+        NEW,      // object created but start() not called yet
+        STARTING, // start() called but background thread has not entered main loop
+        RUNNING,  // background thread is running
+        STOPPING, // stop() called but background thread has not exited main loop
+        STOPPED   // stop() called and background thread has exited, or background thread crashed
+    }
+
+    private final WatcherThread watcherThread;
+    private State state; // protected by synchronized(this)
+
+    /**
+     * Creates a watcher that watches <code>dirPath</code> and invokes <code>callback</code> on changes.
+     *
+     * @param dirPath the directory to watch.
+     * @param callback the callback to invoke with events. <code>event.kind()</code> will return the type of event,
+     *                 and <code>event.context()</code> will return the filename relative to <code>dirPath</code>.
+     * @throws IOException if there is an error creating the WatchService.
+     */
+    public FileChangeWatcher(Path dirPath, Consumer<WatchEvent<?>> callback) throws IOException {
+        FileSystem fs = dirPath.getFileSystem();
+        WatchService watchService = fs.newWatchService();
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Registering with watch service: "" + dirPath);
+        }
+        dirPath.register(
+                watchService,
+                new WatchEvent.Kind<?>[]{
+                        StandardWatchEventKinds.ENTRY_CREATE,
+                        StandardWatchEventKinds.ENTRY_DELETE,
+                        StandardWatchEventKinds.ENTRY_MODIFY,
+                        StandardWatchEventKinds.OVERFLOW},
+                SensitivityWatchEventModifier.HIGH);
+        state = State.NEW;
+        this.watcherThread = new WatcherThread(watchService, callback);
+        this.watcherThread.setDaemon(true);
+    }
+
+    public synchronized State getState() {
+        return state;
+    }
+
+    private synchronized void setState(State newState) {","[{'comment': 'I see some improvement can be done here.Is it required to define method as synchronised.Can we use ReentrantReadWriteLock  and get write lock here? It will be resulted in performance improvement', 'commenter': 'tumativ'}, {'comment': 'See above.', 'commenter': 'ivmaykov'}]"
680,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -446,4 +458,119 @@ private void configureSSLServerSocket(SSLServerSocket sslServerSocket) {
         LOG.debug(""Using Java8-optimized cipher suites for Java version {}"", javaVersion);
         return DEFAULT_CIPHERS_JAVA8;
     }
+
+    /**
+     * Enables automatic reloading of the trust store and key store files when they change on disk.
+     *
+     * @throws IOException if creating the FileChangeWatcher objects fails.
+     */
+    public void enableCertFileReloading() throws IOException {
+        LOG.info(""enabling cert file reloading"");
+        ZKConfig config = new ZKConfig();
+        String keyStoreLocation = config.getProperty(sslKeystoreLocationProperty);
+        if (keyStoreLocation != null && !keyStoreLocation.isEmpty()) {
+            final Path filePath = Paths.get(keyStoreLocation).toAbsolutePath();
+            Path parentPath = filePath.getParent();
+            if (parentPath == null) {
+                throw new IOException(
+                        ""Key store path does not have a parent: "" + filePath);
+            }
+            FileChangeWatcher newKeyStoreFileWatcher = new FileChangeWatcher(
+                    parentPath,
+                    watchEvent -> {
+                        handleWatchEvent(filePath, watchEvent);
+                    });
+            // stop old watcher if there is one
+            if (keyStoreFileWatcher != null) {
+                keyStoreFileWatcher.stop();
+            }
+            keyStoreFileWatcher = newKeyStoreFileWatcher;
+            keyStoreFileWatcher.start();
+        }
+        String trustStoreLocation = config.getProperty(sslTruststoreLocationProperty);
+        if (trustStoreLocation != null && !trustStoreLocation.isEmpty()) {
+            final Path filePath = Paths.get(trustStoreLocation).toAbsolutePath();
+            Path parentPath = filePath.getParent();
+            if (parentPath == null) {
+                throw new IOException(
+                        ""Trust store path does not have a parent: "" + filePath);
+            }
+            FileChangeWatcher newTrustStoreFileWatcher = new FileChangeWatcher(
+                    parentPath,
+                    watchEvent -> {
+                        handleWatchEvent(filePath, watchEvent);
+                    });
+            // stop old watcher if there is one
+            if (trustStoreFileWatcher != null) {
+                trustStoreFileWatcher.stop();
+            }
+            trustStoreFileWatcher = newTrustStoreFileWatcher;
+            trustStoreFileWatcher.start();
+        }
+    }
+
+    /**
+     * Disables automatic reloading of the trust store and key store files when they change on disk.
+     * Stops background threads and closes WatchService instances.
+     */
+    public void disableCertFileReloading() {","[{'comment': 'This method can be private.', 'commenter': 'anmolnar'}, {'comment': 'Will do.', 'commenter': 'ivmaykov'}]"
680,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -446,4 +458,119 @@ private void configureSSLServerSocket(SSLServerSocket sslServerSocket) {
         LOG.debug(""Using Java8-optimized cipher suites for Java version {}"", javaVersion);
         return DEFAULT_CIPHERS_JAVA8;
     }
+
+    /**
+     * Enables automatic reloading of the trust store and key store files when they change on disk.
+     *
+     * @throws IOException if creating the FileChangeWatcher objects fails.
+     */
+    public void enableCertFileReloading() throws IOException {
+        LOG.info(""enabling cert file reloading"");
+        ZKConfig config = new ZKConfig();
+        String keyStoreLocation = config.getProperty(sslKeystoreLocationProperty);
+        if (keyStoreLocation != null && !keyStoreLocation.isEmpty()) {
+            final Path filePath = Paths.get(keyStoreLocation).toAbsolutePath();
+            Path parentPath = filePath.getParent();
+            if (parentPath == null) {
+                throw new IOException(
+                        ""Key store path does not have a parent: "" + filePath);
+            }
+            FileChangeWatcher newKeyStoreFileWatcher = new FileChangeWatcher(
+                    parentPath,
+                    watchEvent -> {
+                        handleWatchEvent(filePath, watchEvent);
+                    });
+            // stop old watcher if there is one
+            if (keyStoreFileWatcher != null) {
+                keyStoreFileWatcher.stop();
+            }
+            keyStoreFileWatcher = newKeyStoreFileWatcher;
+            keyStoreFileWatcher.start();
+        }
+        String trustStoreLocation = config.getProperty(sslTruststoreLocationProperty);
+        if (trustStoreLocation != null && !trustStoreLocation.isEmpty()) {
+            final Path filePath = Paths.get(trustStoreLocation).toAbsolutePath();
+            Path parentPath = filePath.getParent();
+            if (parentPath == null) {
+                throw new IOException(
+                        ""Trust store path does not have a parent: "" + filePath);
+            }
+            FileChangeWatcher newTrustStoreFileWatcher = new FileChangeWatcher(
+                    parentPath,
+                    watchEvent -> {
+                        handleWatchEvent(filePath, watchEvent);
+                    });
+            // stop old watcher if there is one
+            if (trustStoreFileWatcher != null) {
+                trustStoreFileWatcher.stop();
+            }
+            trustStoreFileWatcher = newTrustStoreFileWatcher;
+            trustStoreFileWatcher.start();
+        }
+    }
+
+    /**
+     * Disables automatic reloading of the trust store and key store files when they change on disk.
+     * Stops background threads and closes WatchService instances.
+     */
+    public void disableCertFileReloading() {
+        if (keyStoreFileWatcher != null) {
+            keyStoreFileWatcher.stop();
+            keyStoreFileWatcher = null;
+        }
+        if (trustStoreFileWatcher != null) {
+            trustStoreFileWatcher.stop();
+            trustStoreFileWatcher = null;
+        }
+    }
+
+    // Finalizer guardian object, see Effective Java item 7
+    // TODO: finalize() is deprecated starting with Java 10. This needs to be
+    // replaced with an explicit shutdown call.
+    @SuppressWarnings(""unused"")
+    private final Object finalizerGuardian = new Object() {","[{'comment': ""Reading the referenced literature about this, I believe it should be better to avoid using finalizer like this. We might even be better avoid using finalizers entirely. There's no guarantee when finalizer gets executed, not even guarantee to be executed at all, it has a huge performance penalty, etc.\r\n\r\nWe should rather implement an explicit `close()` method with the `AutoClosable` interface and call it from QuorumPeer's shutdown() method."", 'commenter': 'anmolnar'}, {'comment': ""I'm worried about forgetting to call `close()` and leaking the background threads. X509Util is created in other places besides QuorumPeer. But I'll see what I can do about it, we only need to call close() if we called `enableCertFileReloading()` so it might be ok ..."", 'commenter': 'ivmaykov'}]"
680,zookeeper-server/src/main/java/org/apache/zookeeper/common/FileChangeWatcher.java,"@@ -0,0 +1,253 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import com.sun.nio.file.SensitivityWatchEventModifier;
+import org.apache.zookeeper.server.ZooKeeperThread;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.nio.file.ClosedWatchServiceException;
+import java.nio.file.FileSystem;
+import java.nio.file.Path;
+import java.nio.file.StandardWatchEventKinds;
+import java.nio.file.WatchEvent;
+import java.nio.file.WatchKey;
+import java.nio.file.WatchService;
+import java.util.function.Consumer;
+
+/**
+ * Instances of this class can be used to watch a directory for file changes. When a file is added to, deleted from,
+ * or is modified in the given directory, the callback provided by the user will be called from a background thread.
+ * Some things to keep in mind:
+ * <ul>
+ * <li>The callback should be thread-safe.</li>
+ * <li>Changes that happen around the time the thread is started may be missed.</li>
+ * <li>There is a delay between a file changing and the callback firing.</li>
+ * <li>The watch is not recursive - changes to subdirectories will not trigger a callback.</li>
+ * </ul>
+ */
+public final class FileChangeWatcher {","[{'comment': 'Maybe it doesn\'t make sense, but I\'m thinking of whether it would be better to make `FileChangeWatcher` class the thread itself instead using a ""wrapped"" Thread instance. In which case you might not need to forward the `stop()` call, but can call it directly.', 'commenter': 'anmolnar'}]"
680,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -446,4 +458,119 @@ private void configureSSLServerSocket(SSLServerSocket sslServerSocket) {
         LOG.debug(""Using Java8-optimized cipher suites for Java version {}"", javaVersion);
         return DEFAULT_CIPHERS_JAVA8;
     }
+
+    /**
+     * Enables automatic reloading of the trust store and key store files when they change on disk.
+     *
+     * @throws IOException if creating the FileChangeWatcher objects fails.
+     */
+    public void enableCertFileReloading() throws IOException {
+        LOG.info(""enabling cert file reloading"");
+        ZKConfig config = new ZKConfig();
+        String keyStoreLocation = config.getProperty(sslKeystoreLocationProperty);
+        if (keyStoreLocation != null && !keyStoreLocation.isEmpty()) {
+            final Path filePath = Paths.get(keyStoreLocation).toAbsolutePath();
+            Path parentPath = filePath.getParent();
+            if (parentPath == null) {
+                throw new IOException(
+                        ""Key store path does not have a parent: "" + filePath);
+            }
+            FileChangeWatcher newKeyStoreFileWatcher = new FileChangeWatcher(
+                    parentPath,
+                    watchEvent -> {
+                        handleWatchEvent(filePath, watchEvent);
+                    });
+            // stop old watcher if there is one
+            if (keyStoreFileWatcher != null) {
+                keyStoreFileWatcher.stop();
+            }
+            keyStoreFileWatcher = newKeyStoreFileWatcher;
+            keyStoreFileWatcher.start();
+        }
+        String trustStoreLocation = config.getProperty(sslTruststoreLocationProperty);
+        if (trustStoreLocation != null && !trustStoreLocation.isEmpty()) {","[{'comment': 'This logic is redundant and can be extracted in a separate method.', 'commenter': 'anmolnar'}]"
684,zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerCnxn.java,"@@ -68,29 +70,74 @@
 
     private volatile boolean stale = false;
 
+    final ZooKeeperServer zkServer;
+
+    public ServerCnxn(final ZooKeeperServer zkServer) {
+        this.zkServer = zkServer;
+    }
+
     abstract int getSessionTimeout();
 
     abstract void close();
 
+    public abstract void sendResponse(ReplyHeader h, Record r,
+            String tag, String cacheKey, Stat stat) throws IOException;
+
     public void sendResponse(ReplyHeader h, Record r, String tag) throws IOException {
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        // Make space for length
+        sendResponse(h, r, tag, null, null);
+    }
+
+    protected byte[] serializeRecord(Record record) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream(
+            ZooKeeperServer.intBufferStartingSizeBytes);
         BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);
-        try {
-            baos.write(fourBytes);
-            bos.writeRecord(h, ""header"");
-            if (r != null) {
-                bos.writeRecord(r, tag);
+        bos.writeRecord(record, null);
+        return baos.toByteArray();
+    }
+
+    protected ByteBuffer[] serialize(ReplyHeader h, Record r, String tag,
+            String cacheKey, Stat stat) throws IOException {
+        byte[] header = serializeRecord(h);
+        byte[] data = null;
+        if (r != null) {
+            ResponseCache cache = zkServer.getReadResponseCache();
+            if (cache != null && stat != null && cacheKey != null &&
+                    !cacheKey.endsWith(Quotas.statNode)) {
+                // Use cache to get serialized data.
+                //
+                // NB: Tag is ignored both during cache lookup and serialization,
+                // since is is not used in read responses, which are being cached.
+                data = cache.get(cacheKey, stat);
+                if (data == null) {
+                    // Cache miss, serialize the response and put it in cache.
+                    data = serializeRecord(r);","[{'comment': 'We may hit the race condition to serialize the same record multiple times, but we made a trade off, instead of having write lock every time, this might be more efficient.', 'commenter': 'lvfangmin'}, {'comment': ""`put()` aquires the write lock anyway, so in my opinion this will cause the response to be serialized twice and put into the cache twice (second overwrites first). I think it's fine."", 'commenter': 'anmolnar'}]"
684,zookeeper-server/src/test/java/org/apache/zookeeper/test/ResponseCacheTest.java,"@@ -0,0 +1,118 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import java.util.Map;
+
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.server.ServerStats;
+import org.apache.zookeeper.server.ServerMetrics;
+import org.apache.zookeeper.server.ZooKeeperServerMXBean;
+import org.junit.Assert;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.management.JMX;
+import javax.management.MBeanServerConnection;
+import javax.management.ObjectName;
+
+public class ResponseCacheTest extends ClientBase {
+    protected static final Logger LOG =
+            LoggerFactory.getLogger(ResponseCacheTest.class);
+
+    @Test
+    public void testResponseCache() throws Exception {
+        ObjectName bean = JMXEnv.getServerBean();
+        MBeanServerConnection mbsc = JMXEnv.conn();
+        ZooKeeperServerMXBean zkBean = JMX.newMBeanProxy(mbsc, bean, ZooKeeperServerMXBean.class);
+        ZooKeeper zk = createClient();
+
+        try {
+            performCacheTest(zk, zkBean, ""/cache"", true);
+            performCacheTest(zk, zkBean, ""/nocache"", false);
+        }
+        finally {
+            zk.close();
+        }
+    }
+
+    private void checkCacheStatus(long expectedHits, long expectedMisses) {
+        Map<String, Long> metrics = ServerMetrics.getAllValues();
+        Assert.assertEquals((Long) expectedHits, metrics.get(""response_packet_cache_hits""));
+        Assert.assertEquals((Long) expectedMisses, metrics.get(""response_packet_cache_misses""));
+    }
+
+    public void performCacheTest(ZooKeeper zk, ZooKeeperServerMXBean zkBean, String path, boolean useCache) throws Exception {
+        ServerMetrics.resetAll();
+        Stat writeStat = new Stat();
+        Stat readStat = new Stat();
+        byte[] readData = null;
+        int reads = 10;
+        long expectedHits = 0;
+        long expectedMisses = 0;
+
+        zkBean.setResponseCachingEnabled(useCache);","[{'comment': 'Brian, looks like we call ZooKeeperServer.setResponseCachingEnabled directly instead of introducing the JMX bean here, can you check if we can get rid of the JMX bean change in this diff?', 'commenter': 'lvfangmin'}]"
684,zookeeper-server/src/test/java/org/apache/zookeeper/test/ResponseCacheTest.java,"@@ -0,0 +1,118 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import java.util.Map;
+
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.server.ServerStats;","[{'comment': 'unused import?', 'commenter': 'hanm'}]"
684,zookeeper-server/src/main/java/org/apache/zookeeper/server/ResponseCache.java,"@@ -0,0 +1,84 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import org.apache.jute.Record;
+import org.apache.zookeeper.data.Stat;
+
+@SuppressWarnings(""serial"")
+public class ResponseCache {
+    private static final int DEFAULT_RESPONSE_CACHE_SIZE = 400;
+
+    private static class Entry {
+        public Stat stat;
+        public byte[] data;
+    }
+
+    private Map<String, Entry> cache = Collections.synchronizedMap(
+        new LRUCache<String, Entry>(getResponseCacheSize()));
+
+    public ResponseCache() {
+    }
+
+    public void put(String path, byte[] data, Stat stat) {
+        Entry entry = new Entry();
+        entry.data = data;
+        entry.stat = stat;
+        cache.put(path, entry);
+    }
+
+    public byte[] get(String key, Stat stat) {
+        Entry entry = cache.get(key);
+        if (entry == null) {
+            return null;
+        }
+        if (!stat.equals(entry.stat)) {
+            // The node has been modified, invalidate cache.
+            cache.remove(key);
+            return null;
+        } else {
+            return entry.data;
+        }
+    }
+
+    private static int getResponseCacheSize() {
+        String value = System.getProperty(""zookeeper.maxResponseCacheSize"");
+        return value == null ? DEFAULT_RESPONSE_CACHE_SIZE : Integer.parseInt(value);
+    }
+
+    public static boolean isEnabled() {
+        return getResponseCacheSize() != 0;
+    }
+
+    private static class LRUCache<K, V> extends LinkedHashMap<K, V> {","[{'comment': 'nice.', 'commenter': 'hanm'}, {'comment': 'Can we provide the  Eviction Policy like FIFO,LRU,LFU  etc to cache and behave accordingly?', 'commenter': 'tumativ'}, {'comment': ""We can extend that, but it's better to be done in a separate thread, feel free to open a new JIRA to follow up on this."", 'commenter': 'lvfangmin'}]"
684,zookeeper-server/src/main/java/org/apache/zookeeper/server/ResponseCache.java,"@@ -0,0 +1,84 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import org.apache.jute.Record;
+import org.apache.zookeeper.data.Stat;
+
+@SuppressWarnings(""serial"")
+public class ResponseCache {
+    private static final int DEFAULT_RESPONSE_CACHE_SIZE = 400;
+
+    private static class Entry {
+        public Stat stat;
+        public byte[] data;
+    }
+
+    private Map<String, Entry> cache = Collections.synchronizedMap(
+        new LRUCache<String, Entry>(getResponseCacheSize()));
+
+    public ResponseCache() {
+    }
+
+    public void put(String path, byte[] data, Stat stat) {
+        Entry entry = new Entry();
+        entry.data = data;
+        entry.stat = stat;
+        cache.put(path, entry);
+    }
+
+    public byte[] get(String key, Stat stat) {
+        Entry entry = cache.get(key);
+        if (entry == null) {
+            return null;
+        }
+        if (!stat.equals(entry.stat)) {
+            // The node has been modified, invalidate cache.
+            cache.remove(key);
+            return null;
+        } else {
+            return entry.data;
+        }
+    }
+
+    private static int getResponseCacheSize() {
+        String value = System.getProperty(""zookeeper.maxResponseCacheSize"");
+        return value == null ? DEFAULT_RESPONSE_CACHE_SIZE : Integer.parseInt(value);
+    }
+
+    public static boolean isEnabled() {
+        return getResponseCacheSize() != 0;
+    }
+
+    private static class LRUCache<K, V> extends LinkedHashMap<K, V> {
+        private int cacheSize;
+
+        public LRUCache(int cacheSize) {","[{'comment': ""This constructor will use insertion order, instead of access order. So for cache entries that's most recently queried it's possible these entries get ejected if they were inserted long time ago, when cache capacity is full. I am curious, what's the trade off you made to decide to use insertion order, instead of access order? \r\n\r\nOne improvement that could be made is in `ResponseCache.get`, when we have a cache hit, we always remove the entry and re-put the same entry, to keep the most recently queried order up to date."", 'commenter': 'hanm'}, {'comment': ""I agreed with @hanm and like the idea of removing and re-putting nodes, but doesn't look like it can be easily implemented."", 'commenter': 'anmolnar'}, {'comment': ""We haven't tested or considered the alternate eviction policies you outline and that LinkedHashMap allows. I see three reasonable paths here, @hanm  @anmolnar  @lvfangmin .\r\n\r\n- Merge this pr as it is (perhaps rename LRUCache to just Cache) and open a new JIRA to explore future paths.\r\n- I add another property that lets one toggle between insertion order and access order with the current implementation as the default.\r\n- Drop LinkedHashMap entirely and go with something like a guava Cache.\r\n\r\nMy preference is to merge something as close to the current implementation as possible so that others can start to enjoy the benefits of the ResponseCache and open a JIRA so the task of extending the cache functionality goes to someone enthusiastic about tackling new feature work. Thoughts?"", 'commenter': 'enixon'}]"
684,zookeeper-server/src/main/java/org/apache/zookeeper/server/ResponseCache.java,"@@ -0,0 +1,84 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import org.apache.jute.Record;
+import org.apache.zookeeper.data.Stat;
+
+@SuppressWarnings(""serial"")
+public class ResponseCache {
+    private static final int DEFAULT_RESPONSE_CACHE_SIZE = 400;","[{'comment': 'Do we randomly choose 400 as default? Any recommendations on how to choose a good default cache size :) ?', 'commenter': 'hanm'}, {'comment': 'Agreed. You might want to add some useful comment here.', 'commenter': 'anmolnar'}, {'comment': ""Yes, I think we randomly chose one, it depends on how much data you have, we'll update the doc for the best practice. Also there is metric to show the cache hit rate, if it's too low, maybe we need to raise the cache size."", 'commenter': 'lvfangmin'}]"
684,zookeeper-server/src/main/java/org/apache/zookeeper/server/ResponseCache.java,"@@ -0,0 +1,84 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import org.apache.jute.Record;
+import org.apache.zookeeper.data.Stat;
+
+@SuppressWarnings(""serial"")
+public class ResponseCache {
+    private static final int DEFAULT_RESPONSE_CACHE_SIZE = 400;
+
+    private static class Entry {
+        public Stat stat;
+        public byte[] data;
+    }
+
+    private Map<String, Entry> cache = Collections.synchronizedMap(
+        new LRUCache<String, Entry>(getResponseCacheSize()));
+
+    public ResponseCache() {
+    }
+
+    public void put(String path, byte[] data, Stat stat) {
+        Entry entry = new Entry();
+        entry.data = data;
+        entry.stat = stat;
+        cache.put(path, entry);
+    }
+
+    public byte[] get(String key, Stat stat) {
+        Entry entry = cache.get(key);
+        if (entry == null) {
+            return null;
+        }
+        if (!stat.equals(entry.stat)) {
+            // The node has been modified, invalidate cache.
+            cache.remove(key);
+            return null;
+        } else {
+            return entry.data;
+        }
+    }
+
+    private static int getResponseCacheSize() {
+        String value = System.getProperty(""zookeeper.maxResponseCacheSize"");","[{'comment': 'would be good to put this in document, but this can be done in a different jira if you like.', 'commenter': 'hanm'}, {'comment': 'I prefer to add documentation changes to this patch instead of creating a separate one.', 'commenter': 'anmolnar'}]"
684,zookeeper-server/src/main/java/org/apache/zookeeper/server/ResponseCache.java,"@@ -0,0 +1,84 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import org.apache.jute.Record;
+import org.apache.zookeeper.data.Stat;
+
+@SuppressWarnings(""serial"")
+public class ResponseCache {
+    private static final int DEFAULT_RESPONSE_CACHE_SIZE = 400;
+
+    private static class Entry {
+        public Stat stat;
+        public byte[] data;
+    }
+
+    private Map<String, Entry> cache = Collections.synchronizedMap(
+        new LRUCache<String, Entry>(getResponseCacheSize()));
+
+    public ResponseCache() {
+    }
+
+    public void put(String path, byte[] data, Stat stat) {
+        Entry entry = new Entry();
+        entry.data = data;
+        entry.stat = stat;
+        cache.put(path, entry);
+    }
+
+    public byte[] get(String key, Stat stat) {
+        Entry entry = cache.get(key);
+        if (entry == null) {
+            return null;
+        }
+        if (!stat.equals(entry.stat)) {","[{'comment': ""stat could change even the data stored in a znode does not, such creating / deleting children of a znode will change its stat's pzxid and the cversion... so we will have a cache miss in this case even the data (that we are interested in for `getData` response) does not. Is this expected? It seems more intuitive to get a cache hit in this case."", 'commenter': 'hanm'}, {'comment': 'Comparing `mzxid` instead?', 'commenter': 'anmolnar'}, {'comment': ""Currently, he stat is also part of the cached data, when it's changed we need to invalidate this as well.\r\n\r\nWe can separate the cache for data and stat, but we didn't see that's necessary for now, this is mainly for improving the serializing performance and GC effort with large znode data size."", 'commenter': 'lvfangmin'}]"
684,zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerMetrics.java,"@@ -67,7 +67,10 @@
     SNAP_COUNT(new SimpleCounter(""snap_count"")),
     COMMIT_COUNT(new SimpleCounter(""commit_count"")),
     CONNECTION_REQUEST_COUNT(new SimpleCounter(""connection_request_count"")),
-    BYTES_RECEIVED_COUNT(new SimpleCounter(""bytes_received_count""));
+    BYTES_RECEIVED_COUNT(new SimpleCounter(""bytes_received_count"")),
+
+    RESPONSE_PACKET_CACHE_HITS(new SimpleCounter(""response_packet_cache_hits"")),
+    RESPONSE_PACKET_CACHE_MISSING(new SimpleCounter(""response_packet_cache_misses""));","[{'comment': ""how well this cache works under different type of workloads, based on the stats here? (if it's ok to share)"", 'commenter': 'hanm'}]"
684,zookeeper-server/src/main/java/org/apache/zookeeper/server/DumbWatcher.java,"@@ -69,7 +69,7 @@ public void sendCloseSession() { }
     void setSessionId(long sessionId) { }
 
     @Override
-    void sendBuffer(ByteBuffer closeConn) { }
+    void sendBuffer(ByteBuffer... closeConn) { }","[{'comment': 'Why have you changed the serialization logic to use multiple buffers instead of a single one?', 'commenter': 'anmolnar'}, {'comment': ""In order to reduce the GC effort by re-using the cached serialized data, we need to break the single response packet into different part, the length buffer, the header buffer, and the data buffer, length and header will be built every time, but data buffer is reused, that's why we changed this to pass in a buffers list."", 'commenter': 'lvfangmin'}]"
684,zookeeper-server/src/main/java/org/apache/zookeeper/server/NIOServerCnxn.java,"@@ -151,12 +148,17 @@ void sendBufferSync(ByteBuffer bb) {
      * sendBuffer pushes a byte buffer onto the outgoing buffer queue for
      * asynchronous writes.
      */
-    public void sendBuffer(ByteBuffer bb) {
+    public void sendBuffer(ByteBuffer... buffers) {
         if (LOG.isTraceEnabled()) {
             LOG.trace(""Add a buffer to outgoingBuffers, sk "" + sk
                       + "" is valid: "" + sk.isValid());
         }
-        outgoingBuffers.add(bb);
+        synchronized (outgoingBuffers) {","[{'comment': ""This synchronization had to be added, because of the ability to send multiple byte buffers at once. What's the performance impact?"", 'commenter': 'anmolnar'}, {'comment': ""We have E2E perf regression detect for different use cases with different traffic, haven't seen any obvious perf impact there."", 'commenter': 'lvfangmin'}]"
684,zookeeper-server/src/main/java/org/apache/zookeeper/server/NIOServerCnxn.java,"@@ -235,10 +237,12 @@ void handleWrite(SelectionKey k) throws IOException, CloseRequestException {
                 if (bb == ServerCnxnFactory.closeConn) {
                     throw new CloseRequestException(""close requested"");
                 }
+                if (bb == packetSentinel) {","[{'comment': ""Seems like you're fixing a bug by introducing `packetSentinel`. Is that correct?"", 'commenter': 'anmolnar'}, {'comment': ""Since we separate the response into multiple pieces, length, header, data, we need a way to tell if it's the end of a response or not, and the sentinel is added for this purpose."", 'commenter': 'lvfangmin'}]"
684,zookeeper-server/src/main/java/org/apache/zookeeper/server/ResponseCache.java,"@@ -0,0 +1,84 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import org.apache.jute.Record;
+import org.apache.zookeeper.data.Stat;
+
+@SuppressWarnings(""serial"")
+public class ResponseCache {
+    private static final int DEFAULT_RESPONSE_CACHE_SIZE = 400;
+
+    private static class Entry {
+        public Stat stat;
+        public byte[] data;
+    }
+
+    private Map<String, Entry> cache = Collections.synchronizedMap(","[{'comment': 'Can LRUcache compose the LinkedHashMap rather extending? Can we use read-write locks for better synchronization? The read lock on reads will give better results rather locking on the map.', 'commenter': 'tumativ'}, {'comment': 'Would be good if DEFAULT_INITIAL_CAPACITY of cache also defined', 'commenter': 'tumativ'}, {'comment': ""The advice to use Collections::synchronizedMap is from the java docs for LinkedHashMap (https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html). I'm happier using this pattern for now than changing it up as we should not be building our own caching logic. \r\n\r\nOne alternative would be to use a guava cache."", 'commenter': 'enixon'}]"
684,zookeeper-server/src/main/java/org/apache/zookeeper/server/ResponseCache.java,"@@ -0,0 +1,84 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import org.apache.jute.Record;
+import org.apache.zookeeper.data.Stat;
+
+@SuppressWarnings(""serial"")
+public class ResponseCache {","[{'comment': 'How about updating the cache when watch event is triggered?', 'commenter': 'tumativ'}, {'comment': ""Since this is a read cache, it's better to invalidate it when the client read the changed data to avoid unnecessary update."", 'commenter': 'lvfangmin'}]"
690,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/SnapStream.java,"@@ -0,0 +1,336 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.persistence;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.RandomAccessFile;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import java.util.zip.Adler32;
+import java.util.zip.CheckedInputStream;
+import java.util.zip.CheckedOutputStream;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+
+import org.apache.jute.InputArchive;
+import org.apache.jute.OutputArchive;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.xerial.snappy.SnappyCodec;
+import org.xerial.snappy.SnappyInputStream;
+import org.xerial.snappy.SnappyOutputStream;
+
+/**
+ * Represent the Stream used in serialize and deserialize the Snapshot.
+ */
+public class SnapStream {
+
+    private static final Logger LOG = LoggerFactory.getLogger(SnapStream.class);
+
+    public static final String ZOOKEEPER_SHAPSHOT_STREAM_MODE =
+        ""zookeeper.snapshot.compression.method"";
+
+    private static StreamMode streamMode =
+        StreamMode.fromString(
+            System.getProperty(ZOOKEEPER_SHAPSHOT_STREAM_MODE,
+                  StreamMode.DEFAULT_MODE.getName()));
+
+    static {
+        LOG.info(ZOOKEEPER_SHAPSHOT_STREAM_MODE + ""="" + streamMode);
+    }
+
+    public static enum StreamMode {
+        GZIP(""gz""),
+        SNAPPY(""snappy""),
+        CHECKED("""");
+
+        public static final StreamMode DEFAULT_MODE = CHECKED;
+
+        private String name;
+
+        StreamMode(String name) {
+           this.name = name;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public String getFileExtension() {
+            return name.isEmpty() ? """" : ""."" + name;
+        }
+
+        public static StreamMode fromString(String name) {
+            for (StreamMode c : values()) {
+                if (c.getName().compareToIgnoreCase(name) == 0) {
+                    return c;
+                }
+            }
+            return DEFAULT_MODE;
+        }
+    }
+
+    /**
+     * Return the CheckedInputStream based on the extension of the fileName.
+     *
+     * @param fileName the file the InputStream read from
+     * @return the specific InputStream
+     * @throws IOException
+     */
+    public static CheckedInputStream getInputStream(File file) throws IOException {
+        FileInputStream fis = new FileInputStream(file);
+        InputStream is;
+        switch (getStreamMode(file.getName())) {
+            case GZIP:
+                is = new GZIPInputStream(fis);
+                break;
+            case SNAPPY:
+                is = new SnappyInputStream(fis);
+                break;
+            case CHECKED:
+            default:
+                is = new BufferedInputStream(fis);
+        }
+        return new CheckedInputStream(is, new Adler32());
+    }
+
+    /**
+     * Return the OutputStream based on predefined stream mode.
+     *
+     * @param fileName the file the OutputStream writes to
+     * @return the specific OutputStream
+     * @throws IOException
+     */
+    public static CheckedOutputStream getOutputStream(File file) throws IOException {
+        FileOutputStream fos = new FileOutputStream(file);
+        OutputStream os;
+        switch (streamMode) {
+            case GZIP:
+                os = new GZIPOutputStream(fos);
+                break;
+            case SNAPPY:
+                os = new SnappyOutputStream(fos);
+                break;
+            case CHECKED:
+            default:
+                os = new BufferedOutputStream(fos);
+        }
+        return new CheckedOutputStream(os, new Adler32());
+    }
+
+    /**
+     * Write specific seal to the OutputArchive and close the OutputStream.
+     * Currently, only CheckedOutputStream will write it's checkSum to the
+     * end of the stream.
+     *
+     */
+    public static void sealStream(CheckedOutputStream os, OutputArchive oa)
+            throws IOException {
+        long val = os.getChecksum().getValue();
+        oa.writeLong(val, ""val"");
+        oa.writeString(""/"", ""path"");
+    }
+
+    /**
+     * Verify the integrity of the seal, only CheckedInputStream will verify
+     * the checkSum of the content.
+     *
+     */
+    static void checkSealIntegrity(CheckedInputStream is, InputArchive ia)
+            throws IOException {
+        long checkSum = is.getChecksum().getValue();
+        long val = ia.readLong(""val"");
+        if (val != checkSum) {
+            throw new IOException(""CRC corruption"");
+        }
+    }
+
+    /**
+     * Verifies that the file is a valid snapshot. Snapshot may be invalid if
+     * it's incomplete as in a situation when the server dies while in the
+     * process of storing a snapshot. Any files that are improperly formated
+     * or corrupted are invalid. Any file that is not a snapshot is also an
+     * invalid snapshot.
+     *
+     * @param file file to verify
+     * @return true if the snapshot is valid
+     * @throws IOException
+     */
+    public static boolean isValidSnapshot(File file) throws IOException {
+        if (file == null || Util.getZxidFromName(file.getName(), FileSnap.SNAPSHOT_FILE_PREFIX) == -1) {
+            return false;
+        }
+
+        String fileName = file.getName();
+        if (Util.getZxidFromName(fileName, ""snapshot"") == -1) {
+            return false;
+        }
+
+        boolean isValid = false;
+        switch (getStreamMode(fileName)) {
+            case GZIP:
+                isValid = isValidGZipStream(file);
+                break;
+            case SNAPPY:
+                isValid = isValidSnappyStream(file);
+                break;
+            case CHECKED:
+            default:
+                isValid = isValidCheckedStream(file);
+        }
+        return isValid;
+    }
+
+    public static void setStreamMode(StreamMode mode) {
+        streamMode = mode;
+    }
+
+    public static StreamMode getStreamMode() {
+        return streamMode;
+    }
+
+    /**
+     * Detect the stream mode from file name extension
+     *
+     * @param fileName
+     * @return
+     */
+    public static StreamMode getStreamMode(String fileName) {
+        String[] splitSnapName = fileName.split(""\\."");
+
+        // Use file extension to detect format
+        if (splitSnapName.length > 1) {
+            String mode = splitSnapName[splitSnapName.length - 1];
+            return StreamMode.fromString(mode);
+        }
+
+        return StreamMode.CHECKED;
+    }
+
+    /**
+     * Certify the GZip stream integrity by checking the header
+     * for the GZip magic string
+     *
+     * @param f file to verify
+     * @return true if it has the correct GZip magic string
+     * @throws IOException
+     */
+    private static boolean isValidGZipStream(File f) throws IOException {
+        FileInputStream fis = null;
+        byte[] byteArray = new byte[2];
+
+        try {
+            fis = new FileInputStream(f);
+            fis.read(byteArray, 0, 2);","[{'comment': 'Findbugs reports this, as you ignore the result of read().\r\nPlease add it to findbugsExcludeFile.xml to ignore it (or you can use return value to check if the read was successful here, not necessary though).', 'commenter': 'nkalmar'}, {'comment': 'See https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/2623/artifact/build/test/findbugs/newPatchFindbugsWarnings.html ', 'commenter': 'nkalmar'}, {'comment': 'This is actually a bug to be fixed.\r\nYou can for instance use DataInputStream#readFully or use IOUtils if we have it on the classpath\r\n\r\nIs this case it is enough to fail if the result is != 2', 'commenter': 'eolivelli'}, {'comment': 'We can also use try-with-resources', 'commenter': 'eolivelli'}, {'comment': 'Fixed Findbugs warnings and changed to using try-with-resources!', 'commenter': 'yisong-yue'}]"
690,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/SnapStream.java,"@@ -0,0 +1,336 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.persistence;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.RandomAccessFile;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import java.util.zip.Adler32;
+import java.util.zip.CheckedInputStream;
+import java.util.zip.CheckedOutputStream;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+
+import org.apache.jute.InputArchive;
+import org.apache.jute.OutputArchive;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.xerial.snappy.SnappyCodec;
+import org.xerial.snappy.SnappyInputStream;
+import org.xerial.snappy.SnappyOutputStream;
+
+/**
+ * Represent the Stream used in serialize and deserialize the Snapshot.
+ */
+public class SnapStream {
+
+    private static final Logger LOG = LoggerFactory.getLogger(SnapStream.class);
+
+    public static final String ZOOKEEPER_SHAPSHOT_STREAM_MODE =
+        ""zookeeper.snapshot.compression.method"";
+
+    private static StreamMode streamMode =
+        StreamMode.fromString(
+            System.getProperty(ZOOKEEPER_SHAPSHOT_STREAM_MODE,
+                  StreamMode.DEFAULT_MODE.getName()));
+
+    static {
+        LOG.info(ZOOKEEPER_SHAPSHOT_STREAM_MODE + ""="" + streamMode);
+    }
+
+    public static enum StreamMode {
+        GZIP(""gz""),
+        SNAPPY(""snappy""),
+        CHECKED("""");
+
+        public static final StreamMode DEFAULT_MODE = CHECKED;
+
+        private String name;
+
+        StreamMode(String name) {
+           this.name = name;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public String getFileExtension() {
+            return name.isEmpty() ? """" : ""."" + name;
+        }
+
+        public static StreamMode fromString(String name) {
+            for (StreamMode c : values()) {
+                if (c.getName().compareToIgnoreCase(name) == 0) {
+                    return c;
+                }
+            }
+            return DEFAULT_MODE;
+        }
+    }
+
+    /**
+     * Return the CheckedInputStream based on the extension of the fileName.
+     *
+     * @param fileName the file the InputStream read from
+     * @return the specific InputStream
+     * @throws IOException
+     */
+    public static CheckedInputStream getInputStream(File file) throws IOException {
+        FileInputStream fis = new FileInputStream(file);
+        InputStream is;
+        switch (getStreamMode(file.getName())) {
+            case GZIP:
+                is = new GZIPInputStream(fis);
+                break;
+            case SNAPPY:
+                is = new SnappyInputStream(fis);
+                break;
+            case CHECKED:
+            default:
+                is = new BufferedInputStream(fis);
+        }
+        return new CheckedInputStream(is, new Adler32());
+    }
+
+    /**
+     * Return the OutputStream based on predefined stream mode.
+     *
+     * @param fileName the file the OutputStream writes to
+     * @return the specific OutputStream
+     * @throws IOException
+     */
+    public static CheckedOutputStream getOutputStream(File file) throws IOException {
+        FileOutputStream fos = new FileOutputStream(file);
+        OutputStream os;
+        switch (streamMode) {
+            case GZIP:
+                os = new GZIPOutputStream(fos);
+                break;
+            case SNAPPY:
+                os = new SnappyOutputStream(fos);
+                break;
+            case CHECKED:
+            default:
+                os = new BufferedOutputStream(fos);
+        }
+        return new CheckedOutputStream(os, new Adler32());
+    }
+
+    /**
+     * Write specific seal to the OutputArchive and close the OutputStream.
+     * Currently, only CheckedOutputStream will write it's checkSum to the
+     * end of the stream.
+     *
+     */
+    public static void sealStream(CheckedOutputStream os, OutputArchive oa)
+            throws IOException {
+        long val = os.getChecksum().getValue();
+        oa.writeLong(val, ""val"");
+        oa.writeString(""/"", ""path"");
+    }
+
+    /**
+     * Verify the integrity of the seal, only CheckedInputStream will verify
+     * the checkSum of the content.
+     *
+     */
+    static void checkSealIntegrity(CheckedInputStream is, InputArchive ia)
+            throws IOException {
+        long checkSum = is.getChecksum().getValue();
+        long val = ia.readLong(""val"");
+        if (val != checkSum) {
+            throw new IOException(""CRC corruption"");
+        }
+    }
+
+    /**
+     * Verifies that the file is a valid snapshot. Snapshot may be invalid if
+     * it's incomplete as in a situation when the server dies while in the
+     * process of storing a snapshot. Any files that are improperly formated
+     * or corrupted are invalid. Any file that is not a snapshot is also an
+     * invalid snapshot.
+     *
+     * @param file file to verify
+     * @return true if the snapshot is valid
+     * @throws IOException
+     */
+    public static boolean isValidSnapshot(File file) throws IOException {
+        if (file == null || Util.getZxidFromName(file.getName(), FileSnap.SNAPSHOT_FILE_PREFIX) == -1) {
+            return false;
+        }
+
+        String fileName = file.getName();
+        if (Util.getZxidFromName(fileName, ""snapshot"") == -1) {
+            return false;
+        }
+
+        boolean isValid = false;
+        switch (getStreamMode(fileName)) {
+            case GZIP:
+                isValid = isValidGZipStream(file);
+                break;
+            case SNAPPY:
+                isValid = isValidSnappyStream(file);
+                break;
+            case CHECKED:
+            default:
+                isValid = isValidCheckedStream(file);
+        }
+        return isValid;
+    }
+
+    public static void setStreamMode(StreamMode mode) {
+        streamMode = mode;
+    }
+
+    public static StreamMode getStreamMode() {
+        return streamMode;
+    }
+
+    /**
+     * Detect the stream mode from file name extension
+     *
+     * @param fileName
+     * @return
+     */
+    public static StreamMode getStreamMode(String fileName) {
+        String[] splitSnapName = fileName.split(""\\."");
+
+        // Use file extension to detect format
+        if (splitSnapName.length > 1) {
+            String mode = splitSnapName[splitSnapName.length - 1];
+            return StreamMode.fromString(mode);
+        }
+
+        return StreamMode.CHECKED;
+    }
+
+    /**
+     * Certify the GZip stream integrity by checking the header
+     * for the GZip magic string
+     *
+     * @param f file to verify
+     * @return true if it has the correct GZip magic string
+     * @throws IOException
+     */
+    private static boolean isValidGZipStream(File f) throws IOException {
+        FileInputStream fis = null;
+        byte[] byteArray = new byte[2];
+
+        try {
+            fis = new FileInputStream(f);
+            fis.read(byteArray, 0, 2);
+            ByteBuffer bb = ByteBuffer.wrap(byteArray);
+            byte[] magicHeader = new byte[2];
+            bb.get(magicHeader, 0, 2);
+            int magic = magicHeader[0] & 0xff | ((magicHeader[1] << 8) & 0xff00);
+            return magic == GZIPInputStream.GZIP_MAGIC;
+        } catch (FileNotFoundException e) {
+            LOG.error(""Unable to open file "" + f.getName() + "" : "", e);
+            return false;
+        } finally {
+            if (fis != null) {
+                fis.close();
+            }
+        }
+    }
+
+    /**
+     * Certify the Snappy stream integrity by checking the header
+     * for the Snappy magic string
+     *
+     * @param f file to verify
+     * @return true if it has the correct Snappy magic string
+     * @throws IOException
+     */
+    private static boolean isValidSnappyStream(File f) throws IOException {
+        FileInputStream fis = null;
+        byte[] byteArray = new byte[SnappyCodec.MAGIC_LEN];
+        try {
+            fis = new FileInputStream(f);
+            fis.read(byteArray, 0, SnappyCodec.MAGIC_LEN);","[{'comment': ""Again, findBugs doesn't like it. See above."", 'commenter': 'nkalmar'}]"
702,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/auth/QuorumAuth.java,"@@ -38,10 +38,10 @@
     public static final String QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE = ""zkquorum/localhost"";
 
     public static final String QUORUM_LEARNER_SASL_LOGIN_CONTEXT = ""quorum.auth.learner.saslLoginContext"";
-    public static final String QUORUM_LEARNER_SASL_LOGIN_CONTEXT_DFAULT_VALUE = ""QuorumLearner"";
+    public static final String QUORUM_LEARNER_SASL_LOGIN_CONTEXT_DEFAULT_VALUE = ""QuorumLearner"";","[{'comment': 'IMHO it is better not to change is constants, they are part of a public API', 'commenter': 'eolivelli'}]"
707,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -1556,32 +1573,50 @@ public String getNextDynamicConfigFilename() {
     }
     
     public void setLastSeenQuorumVerifier(QuorumVerifier qv, boolean writeToDisk){
-        synchronized (QV_LOCK) {
-            if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {
-                LOG.error(""setLastSeenQuorumVerifier called with stale config "" + qv.getVersion() +
-                        "". Current version: "" + quorumVerifier.getVersion());
+        // If qcm is non-null, we may call qcm.connectOne(), which will take the lock on qcm
+        // and then take QV_LOCK.  Take the locks in the same order to ensure that we don't
+        // deadlock against other callers of connectOne().  If qcmRef gets set in another
+        // thread while we're inside the synchronized block, that does no harm; if we didn't
+        // take a lock on qcm (because it was null when we sampled it), we won't call
+        // connectOne() on it.  (Use of an AtomicReference is enough to guarantee visibility
+        // of updates that provably happen in another thread before entering this method.)
+        QuorumCnxManager qcm = qcmRef.get();
+        Object outerLockObject = (qcm != null) ? qcm : QV_LOCK;","[{'comment': 'nest `synchronized` merits careful consideration?', 'commenter': 'maoling'}, {'comment': ""Yes; I'd like to get confirmation from @castuardo and his team that this fully solves the lock nesting problem.  But if you look at the flow of the code, I think you'll see that the only way _this_ code can take the lock on a {{QuorumCnxManager}} is via {{qcm.connectOne()}}.  Since Java locks are reentrant, we're safe ensuring that the nesting is always qcm -> QV_LOCK -> qcm -> QV_LOCK if qcm is non-null and QV_LOCK -> QV_LOCK if qcm is null."", 'commenter': 'mkedwards'}, {'comment': ""It does.  I'm fairly sure that this guarantees that the `QuorumCnxManager` lock can only be taken inside `QV_LOCK` if it's already held outside it.  Perhaps we can get confirmation from @castuardo and his team's Distributed System Model Checking tool?"", 'commenter': 'mkedwards'}]"
707,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -1566,32 +1585,50 @@ public String getNextDynamicConfigFilename() {
     }
     
     public void setLastSeenQuorumVerifier(QuorumVerifier qv, boolean writeToDisk){
-        synchronized (QV_LOCK) {
-            if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {
-                LOG.error(""setLastSeenQuorumVerifier called with stale config "" + qv.getVersion() +
-                        "". Current version: "" + quorumVerifier.getVersion());
+        // If qcm is non-null, we may call qcm.connectOne(), which will take the lock on qcm
+        // and then take QV_LOCK.  Take the locks in the same order to ensure that we don't
+        // deadlock against other callers of connectOne().  If qcmRef gets set in another
+        // thread while we're inside the synchronized block, that does no harm; if we didn't
+        // take a lock on qcm (because it was null when we sampled it), we won't call
+        // connectOne() on it.  (Use of an AtomicReference is enough to guarantee visibility
+        // of updates that provably happen in another thread before entering this method.)
+        QuorumCnxManager qcm = qcmRef.get();
+        Object outerLockObject = (qcm != null) ? qcm : QV_LOCK;
+        synchronized (outerLockObject) {
+            synchronized (QV_LOCK) {
+                if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {
+                    LOG.error(""setLastSeenQuorumVerifier called with stale config "" + qv.getVersion() +
+                            "". Current version: "" + quorumVerifier.getVersion());
+                }
+                // assuming that a version uniquely identifies a configuration, so if
+                // version is the same, nothing to do here.
+                if (lastSeenQuorumVerifier != null &&
+                        lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {
+                    return;
+                }
+                lastSeenQuorumVerifier = qv;
 
-            }
-            // assuming that a version uniquely identifies a configuration, so if
-            // version is the same, nothing to do here.
-            if (lastSeenQuorumVerifier != null &&
-                    lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {
-                return;
-            }
-            lastSeenQuorumVerifier = qv;
-            connectNewPeers();","[{'comment': 'Why have you refactored this? I think extracting the logic into private method makes the code more readable.', 'commenter': 'anmolnar'}, {'comment': ""The {{qcm}} that it references is now a local variable rather than an instance data member.  If you'd like, I could factor it back out, with {{qcm}} as an argument to the function."", 'commenter': 'mkedwards'}, {'comment': 'Got it. Please factor it back out with a parameter. Thanks!', 'commenter': 'anmolnar'}, {'comment': ""I had folded it back in so I could see the whole flow with the nested calls to `qcm.connectOne()`.  I'll factor it back out with `qcm` as a method parameter (it's important that the `AtomicReference` `qcmRef` not be sampled again inside the `synchronized` block, since we could race against another thread changing the election algorithm)."", 'commenter': 'mkedwards'}]"
707,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -755,39 +769,55 @@ public void recreateSocketAddresses(long id) {
         }
     }
 
-    public InetSocketAddress getQuorumAddress(){
-        synchronized (QV_LOCK) {
-            return myQuorumAddr;
+    InetSocketAddress getQuorumAddress(){","[{'comment': 'You might want to put the double-check-locking mechanism into a private getter of `myAddrs` to consolidate the logic in these 2 getters.', 'commenter': 'anmolnar'}, {'comment': 'Good suggestion.  Done.', 'commenter': 'mkedwards'}]"
707,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -121,6 +126,18 @@
      */
     private ZKDatabase zkDb;
 
+    public static class AddressTuple {","[{'comment': 'nit: final?', 'commenter': 'eolivelli'}, {'comment': 'Good idea.  Done.', 'commenter': 'mkedwards'}]"
707,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -108,7 +109,11 @@
     LocalPeerBean jmxLocalPeerBean;
     private Map<Long, RemotePeerBean> jmxRemotePeerBean;
     LeaderElectionBean jmxLeaderElectionBean;
-    private QuorumCnxManager qcm;
+
+    // The QuorumCnxManager is held through an AtomicReference to ensure cross-thread visibility
+    // of updates; see the implementation comment at setLastSeenQuorumVerifier().
+    private AtomicReference<QuorumCnxManager> qcmRef = new AtomicReference<>();","[{'comment': 'If we are not using Compare and set, why a volatile is not enough?', 'commenter': 'eolivelli'}, {'comment': ""I am hoping to reduce the need for synchronized blocks in follow-up changes.  For now, I added a simple use of getAndSet() to detect multiple calls to createElectionAlgorithm() and ensure that the QCM that's being dropped on the floor gets halted first."", 'commenter': 'mkedwards'}]"
711,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -864,6 +860,17 @@ public static int getSnapCount() {
         }
     }
 
+    public int getGlobalOutstandingLimit() {
+        String sc = System.getProperty(GLOBAL_OUTSTANDING_LIMIT);","[{'comment': ""are we reading the system property and parsing the value at every call of shouldThrottle ?\r\ncan't we cache the value ?"", 'commenter': 'eolivelli'}, {'comment': ""Yes, that's the case. This is just a dumb revert, please see #712 as another approach for the same issue."", 'commenter': 'anmolnar'}]"
722,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LeaderBean.java,"@@ -51,6 +51,15 @@ public String followerInfo() {
         return sb.toString();
     }
 
+    @Override
+    public String nonVotingFollowerInfo() {
+        StringBuilder sb = new StringBuilder();
+        for (LearnerHandler handler : leader.getNonVotingFollowers()) {
+            sb.append(handler.toString()).append(""\n"");","[{'comment': ""Wouldn't it be better to have a specific toStringForJMX method.\r\n\r\nIn the future people will change the toString method without thinking that they are changing the output of a public endpoint"", 'commenter': 'eolivelli'}, {'comment': ""That's a fair point, but I'd like to keep the same behavior in this patch as what we're doing now for the followInfo in this LeaderBean."", 'commenter': 'lvfangmin'}, {'comment': 'Ok I think we can live with it', 'commenter': 'eolivelli'}]"
726,zookeeper-jute/src/test/java/org/apache/jute/BinaryInputArchiveTest.java,"@@ -41,4 +42,136 @@ public void testReadStringCheckLength() {
                     e.getMessage().startsWith(BinaryInputArchive.UNREASONBLE_LENGTH));
         }
     }
+
+    public interface TestWriter {
+        void write(OutputArchive oa) throws IOException;
+    }
+
+    public interface TestReader {
+        void read(InputArchive ia) throws IOException;
+    }
+
+    void checkWriterAndReader(TestWriter writer, TestReader reader) {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);
+        try {
+            writer.write(oa);
+        } catch (IOException e) {
+            Assert.fail(""Should not throw IOException"");
+        }
+        InputStream is = new ByteArrayInputStream(baos.toByteArray());
+        BinaryInputArchive ia = BinaryInputArchive.getArchive(is);
+        try {
+            reader.read(ia);
+        } catch (IOException e) {
+            Assert.fail(""Should not throw IOException while reading back"");
+        }
+    }
+
+    @Test
+    public void testWriteInt() {
+        final int expected = 4;
+        final String tag = ""tag1"";
+        checkWriterAndReader(
+                new TestWriter() {","[{'comment': 'Can we use lambdas?', 'commenter': 'eolivelli'}, {'comment': 'fixed. let me know if this looks ok ! ', 'commenter': 'akkumar'}]"
726,zookeeper-jute/src/test/java/org/apache/jute/XmlInputArchiveTest.java,"@@ -0,0 +1,120 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jute;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.xml.sax.SAXException;
+
+import javax.xml.parsers.ParserConfigurationException;
+import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.io.IOException;
+
+public class XmlInputArchiveTest {
+
+    void checkWriterAndReader(TestWriter writer, TestReader reader) {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+
+        try {
+            XmlOutputArchive oa = XmlOutputArchive.getArchive(baos);
+            writer.write(oa);
+        } catch (IOException e) {
+            Assert.fail(""Should not throw IOException"");
+        }
+        InputStream is = new ByteArrayInputStream(baos.toByteArray());
+        try {
+            XmlInputArchive ia = XmlInputArchive.getArchive(is);
+            reader.read(ia);
+        } catch (ParserConfigurationException e) {
+            Assert.fail(""Should not throw ParserConfigurationException while reading back"");
+        } catch (SAXException e) {
+            Assert.fail(""Should not throw SAXException while reading back"");
+        }  catch (IOException e) {
+            Assert.fail(""Should not throw IOException while reading back"");
+        }
+    }
+
+    @Test
+    public void testWriteInt() {
+        final int expected = 4;
+        final String tag = ""tag1"";
+        checkWriterAndReader(
+                (oa) -> oa.writeInt(expected, tag),
+                (ia) -> {
+                    int actual = ia.readInt(tag);
+                    Assert.assertEquals(expected, actual);
+                }
+        );
+    }
+
+    @Test
+    public void testWriteBool() {
+        final boolean expected = false;
+        final String tag = ""tag1"";
+        checkWriterAndReader(
+                (oa) -> oa.writeBool(expected, tag),
+                (ia) -> {
+                    boolean actual = ia.readBool(tag);
+                    Assert.assertEquals(expected, actual);","[{'comment': 'Sorry, last nit: any reason for not using static imports?', 'commenter': 'eolivelli'}]"
726,zookeeper-jute/src/test/java/org/apache/jute/BinaryInputArchiveTest.java,"@@ -1,4 +1,4 @@
-/**
+/*","[{'comment': 'nit: /* -> /**', 'commenter': 'lvfangmin'}]"
726,zookeeper-jute/src/test/java/org/apache/jute/TestWriter.java,"@@ -0,0 +1,25 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jute;
+
+import java.io.IOException;
+
+public interface TestWriter {
+    void write(OutputArchive oa) throws IOException;
+","[{'comment': 'Remove the tailing empty line.', 'commenter': 'lvfangmin'}]"
726,zookeeper-jute/src/test/java/org/apache/jute/UtilsTest.java,"@@ -0,0 +1,96 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jute;
+
+import org.junit.Assert;
+import org.junit.Test;
+import java.io.IOException;
+
+
+public class UtilsTest {
+
+    void assertXMLString(String input) {
+        String xmlString = Utils.toXMLString(input);
+        String actual = Utils.fromXMLString(xmlString);
+        Assert.assertEquals(input, actual);
+    }
+
+    @Test
+    public void testXMLString() {
+        assertXMLString(""hello"");
+        assertXMLString("",}%""); // special characters
+    }
+
+    void assertXMLBuffer(byte[] input) {
+        String xmlString = Utils.toXMLBuffer(input);
+        try {
+            byte[] actual = Utils.fromXMLBuffer(xmlString);
+            Assert.assertArrayEquals (input, actual);
+        } catch (IOException ioex) {
+            Assert.fail(""Should not be throwing an IOException"");
+        }
+    }
+
+    @Test
+    public void testXMLBuffer() {
+        assertXMLBuffer(""hello"".getBytes());
+    }
+
+
+    void assertCSVString(String input) {
+        String csvString = Utils.toCSVString(input);
+        try {
+            String actual = Utils.fromCSVString(csvString);
+            Assert.assertEquals(input, actual);
+        } catch (IOException ioex) {
+            Assert.fail(""Should not be throwing an IOException"");
+        }
+    }
+
+    @Test
+    public void testCSVString() {
+        assertCSVString(""hello"");
+        assertCSVString("",}%"");        // special characters
+    }
+
+    @Test
+    public void testFromCSVString() {
+        try {
+            Utils.fromCSVString(""1""); // not starting with '
+            Assert.fail(""Should have thrown an IOException"");
+        } catch (IOException ioex) {
+
+        }
+    }
+
+    void assertCSVBuffer(byte[] input) {
+        String csvBuffer = Utils.toCSVBuffer(input);
+        try {
+            byte[] actual = Utils.fromCSVBuffer(csvBuffer);
+            Assert.assertArrayEquals(input, actual);
+        } catch (IOException ioex) {
+            Assert.fail(""Should not have thrown IOException during assertCSVBuffer"");
+        }
+    }
+
+    @Test
+    public void testCSVBuffer() {
+        assertCSVBuffer(""universe"".getBytes());
+    }
+","[{'comment': 'Remove the empty line.', 'commenter': 'lvfangmin'}]"
726,zookeeper-jute/src/test/java/org/apache/jute/XmlInputArchiveTest.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jute;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.junit.Assert.assertArrayEquals;
+
+import org.junit.Test;
+import org.xml.sax.SAXException;
+
+import javax.xml.parsers.ParserConfigurationException;
+import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+
+public class XmlInputArchiveTest {
+
+    private void checkWriterAndReader(TestWriter writer, TestReader reader) {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+
+        try {
+            XmlOutputArchive oa = XmlOutputArchive.getArchive(baos);
+            writer.write(oa);
+        } catch (IOException e) {
+            fail(""Should not throw IOException"");
+        }
+        InputStream is = new ByteArrayInputStream(baos.toByteArray());
+        try {
+            XmlInputArchive ia = XmlInputArchive.getArchive(is);
+            reader.read(ia);
+        } catch (ParserConfigurationException e) {
+            fail(""Should not throw ParserConfigurationException while reading back"");
+        } catch (SAXException e) {
+            fail(""Should not throw SAXException while reading back"");
+        }  catch (IOException e) {
+            fail(""Should not throw IOException while reading back"");
+        }
+    }
+
+    @Test
+    public void testWriteInt() {
+        final int expected = 4;
+        final String tag = ""tag1"";
+        checkWriterAndReader(
+                (oa) -> oa.writeInt(expected, tag),
+                (ia) -> {
+                    int actual = ia.readInt(tag);
+                    assertEquals(expected, actual);
+                }
+        );
+    }
+
+    @Test
+    public void testWriteBool() {
+        final boolean expected = false;
+        final String tag = ""tag1"";
+        checkWriterAndReader(
+                (oa) -> oa.writeBool(expected, tag),
+                (ia) -> {
+                    boolean actual = ia.readBool(tag);
+                    assertEquals(expected, actual);
+                }
+        );
+    }
+
+    @Test
+    public void testWriteString() {
+        final String expected = ""hello"";
+        final String tag = ""tag1"";
+        checkWriterAndReader(
+                (oa) -> oa.writeString(expected, tag),
+                (ia) -> {
+                    String actual = ia.readString(tag);
+                    assertEquals(expected, actual);
+                }
+        );
+    }
+
+    @Test
+    public void testWriteFloat() {
+        final float expected = 3.14159f;
+        final String tag = ""tag1"";
+        final float delta = 1e-10f;
+        checkWriterAndReader(
+                (oa) -> oa.writeFloat(expected, tag),
+                (ia) -> {
+                    float actual = ia.readFloat(tag);
+                    assertEquals(expected, actual, delta);
+                }
+        );
+    }
+
+    @Test
+    public void testWriteDouble() {
+        final double expected = 3.14159f;
+        final String tag = ""tag1"";
+        final float delta = 1e-20f;
+        checkWriterAndReader(
+                (oa) -> oa.writeDouble(expected, tag),
+                (ia) -> {
+                    double actual = ia.readDouble(tag);
+                    assertEquals(expected, actual, delta);
+                }
+        );
+    }
+
+    @Test
+    public void testBuffer() {
+        final byte[] expected = ""hello-world"".getBytes(StandardCharsets.UTF_8);
+        final String tag = ""tag1"";
+        checkWriterAndReader(
+                (oa) -> oa.writeBuffer(expected, tag),
+                (ia) -> {
+                    byte [] actual = ia.readBuffer(tag);
+                    assertArrayEquals(expected, actual);
+                }
+        );
+    }
+","[{'comment': 'Remove the empty tailing line.', 'commenter': 'lvfangmin'}, {'comment': 'Latest commit(s) should have this and others resolved. FYI. ', 'commenter': 'akkumar'}]"
728,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -90,6 +89,7 @@
     private String sslTruststoreLocationProperty = getConfigPrefix() + ""trustStore.location"";
     private String sslTruststorePasswdProperty = getConfigPrefix() + ""trustStore.password"";
     private String sslTruststoreTypeProperty = getConfigPrefix() + ""trustStore.type"";
+    private String sslClientContextProperty = getConfigPrefix() + ""client.context"";","[{'comment': 'nits:\r\n- not sure why ""client"" is in the name\r\n- let\'s call the property something like ""context.supplier.class""?', 'commenter': 'ivmaykov'}]"
728,zookeeper-server/src/main/java/org/apache/zookeeper/common/ZKClientSSLContext.java,"@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.common;
+
+import javax.net.ssl.SSLContext;
+
+/**
+ * An interface for providing a custom {@link SSLContext} object to {@link X509Util} using {@link X509Util#getSslClientContextProperty()}
+ */
+public interface ZKClientSSLContext {","[{'comment': ""I don't think we need a new interface for this. Can just use a `java.util.function.Supplier<SSLContext>`."", 'commenter': 'ivmaykov'}]"
728,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -220,6 +224,24 @@ public int getSslHandshakeTimeoutMillis() {
     }
 
     public SSLContext createSSLContext(ZKConfig config) throws SSLContextException {
+        if (config.getProperty(sslClientContextProperty) != null) {
+            LOG.debug(""Loading SSLContext from property '"" + sslClientContextProperty + ""'"");
+            String sslClientContextClass = config.getProperty(sslClientContextProperty);
+            try {
+                Class<?> sslContextClass = Class.forName(sslClientContextClass);
+                ZKClientSSLContext sslContext = (ZKClientSSLContext) sslContextClass.getConstructor().newInstance();","[{'comment': 'I would use `java.util.function.Supplier<SSLContext>` instead of your own `ZKClientSSLContext` type here', 'commenter': 'ivmaykov'}, {'comment': ""I'm not exactly sure what you mean here. Supplier is a functional interface, but we're initialising it from a property. Do you mean that users should implement the Supplier interface in the class that they pass in? That wouldn't really seem to match the intent of functional interfaces - which would generally be passed as a lambda expression or method reference."", 'commenter': 'arankin-irl'}, {'comment': ""Functional interfaces allow lambdas and method references but I don't think they are restricted to it. But anyway, I don't feel too strongly about it. I don't think `Client` should be in the class name (since this works for both `QuorumX509Util` and `ClientX509Util`) so if you stick with your own class, I would call the interface something like `SSLContextSupplier`."", 'commenter': 'ivmaykov'}, {'comment': ""I can use the Supplier interface - I just wanted to double check before updating the PR. Haven't really seen it implemented, but that's something that's a bit unique to this use-case. It is just an interface at the end of the day.\r\n\r\nRenaming the property is grand as well - the name made sense back before ClientX509Util for my specific use-case, but given the changes, renaming it makes more sense.\r\n\r\nJust checking - we get an unchecked cast warning when instantiating the supplier and casting it to Supplier<SSLContext> - should I leave that warning, or suppress that warning?\r\n\r\n*Edit:* Looks like SuppressWarnings is used elsewhere, so I'll go that route."", 'commenter': 'arankin-irl'}, {'comment': 'do you still get the warning if you do an explicit `instanceof` check first, and throw an exception if the check fails?', 'commenter': 'ivmaykov'}, {'comment': ""The problem is type-erasure - so we can verify that it's an instanceof Supplier, just not Supplier<SSLContext>. We'll get a ClassCastException either way though - which is already handled in the try/catch."", 'commenter': 'arankin-irl'}]"
728,zookeeper-server/src/test/java/org/apache/zookeeper/common/X509UtilTest.java,"@@ -389,6 +393,27 @@ public void testGetSslHandshakeDetectionTimeoutMillisProperty() {
         }
     }
 
+    @Test
+    public void testCreateSSLContext_invalidCustomSSLContextClass() {
+        ZKConfig zkConfig = new ZKConfig();
+        ClientX509Util clientX509Util = new ClientX509Util();
+        zkConfig.setProperty(clientX509Util.getSslClientContextProperty(), String.class.getCanonicalName());
+        try {
+            clientX509Util.createSSLContext(zkConfig);
+            fail(""SSLContextException expected."");","[{'comment': ""nit: can remove the try-catch and modify the annotation on the method to be `@Test(expected = X509Exception.SSLContextException.class)`. Though this approach does not check the message, I think it's probably ok - testing for specific error messages is fragile anyway. We should either not care about the message, or we should create a specific sublcass of SSLContextException for this case and check for that exception type."", 'commenter': 'ivmaykov'}, {'comment': '+1 Use `@Test(expected = ...)` expectation instead.', 'commenter': 'anmolnar'}, {'comment': ""Yep, I'll have that changed."", 'commenter': 'arankin-irl'}]"
728,zookeeper-server/src/test/java/org/apache/zookeeper/common/X509UtilTest.java,"@@ -389,6 +393,27 @@ public void testGetSslHandshakeDetectionTimeoutMillisProperty() {
         }
     }
 
+    @Test
+    public void testCreateSSLContext_invalidCustomSSLContextClass() {
+        ZKConfig zkConfig = new ZKConfig();
+        ClientX509Util clientX509Util = new ClientX509Util();
+        zkConfig.setProperty(clientX509Util.getSslClientContextProperty(), String.class.getCanonicalName());
+        try {
+            clientX509Util.createSSLContext(zkConfig);
+            fail(""SSLContextException expected."");
+        } catch (X509Exception.SSLContextException e) {
+            assertTrue(e.getMessage().contains(clientX509Util.getSslClientContextProperty()));
+        }
+    }
+    @Test
+    public void testCreateSSLContext_validCustomSSLContextClass() throws X509Exception.SSLContextException {
+        ZKConfig zkConfig = new ZKConfig();
+        ClientX509Util clientX509Util = new ClientX509Util();
+        zkConfig.setProperty(clientX509Util.getSslClientContextProperty(), ZKTestClientSSLContext.class.getCanonicalName());
+        final SSLContext sslContext = clientX509Util.createSSLContext(zkConfig);
+        assertNull(sslContext);
+    }
+","[{'comment': 'I would also add an inner class to this test that returns a non-null context (can be a singleton), and add a test case that exercises that code path.', 'commenter': 'ivmaykov'}]"
728,zookeeper-server/src/test/java/org/apache/zookeeper/common/ZKTestClientSSLContext.java,"@@ -0,0 +1,29 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.common;
+
+import javax.net.ssl.SSLContext;
+
+public class ZKTestClientSSLContext implements ZKClientSSLContext {","[{'comment': ""I think this can be an inner class in X509UtilTest since it's not used anywhere else"", 'commenter': 'ivmaykov'}, {'comment': 'Can do, though moving it to an inner class would require it to be static, and the property would have to be something like: \r\n\r\n`zkConfig.setProperty(clientX509Util.getSslContextSupplierClassProperty(), X509UtilTest.class.getCanonicalName() + ""$"" + TestContextSupplier.class.getSimpleName());`', 'commenter': 'arankin-irl'}, {'comment': ""Ok, if instantiating an inner class by reflection is awkward, don't worry about it and leave it as a standalone class."", 'commenter': 'ivmaykov'}, {'comment': 'Another nit then - can you make the class package-private? Principle of least privilege and all that (Not sure if a package-private class can be instantiated using reflection though).', 'commenter': 'ivmaykov'}, {'comment': ""There's an argument for both ways - I've a feeling that package-private might mess with reflection, but I'll test it out. The static inner class works fine, just the property looks a bit funny - but that isn't too important for the test case."", 'commenter': 'arankin-irl'}]"
728,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -238,18 +239,19 @@ public int getSslHandshakeTimeoutMillis() {
         return result;
     }
 
+    @SuppressWarnings(""unchecked"")
     public SSLContext createSSLContext(ZKConfig config) throws SSLContextException {
-        if (config.getProperty(sslClientContextProperty) != null) {
-            LOG.debug(""Loading SSLContext from property '"" + sslClientContextProperty + ""'"");
-            String sslClientContextClass = config.getProperty(sslClientContextProperty);
+        if (config.getProperty(sslContextSupplierClassProperty) != null) {
+            LOG.debug(""Loading SSLContext supplier from property '"" + sslContextSupplierClassProperty + ""'"");","[{'comment': 'nit: enclose this in a `if (LOG.isDebugEnabled()) { ... }`', 'commenter': 'ivmaykov'}, {'comment': 'Also for readability, consider using `{}` formatting to build the log message:\r\n\r\n`LOG.debug(""Loading SSLContext supplier from property \'{}\'},  sslContextSupplierClassProperty);`', 'commenter': 'ivmaykov'}, {'comment': 'Yep, no problem 👍 ', 'commenter': 'arankin-irl'}]"
728,zookeeper-server/src/main/java/org/apache/zookeeper/common/ZKConfig.java,"@@ -18,6 +18,12 @@
 
 package org.apache.zookeeper.common;
 
+import org.apache.zookeeper.Environment;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
+import org.apache.zookeeper.server.util.VerifyingFileFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;","[{'comment': 'nit: revert this import reorder', 'commenter': 'ivmaykov'}, {'comment': 'Will disable automatic organising of imports and revert the order 👍 ', 'commenter': 'arankin-irl'}]"
728,zookeeper-server/src/test/java/org/apache/zookeeper/common/X509UtilTest.java,"@@ -406,26 +407,30 @@ public void testGetSslHandshakeDetectionTimeoutMillisProperty() {
         }
     }
 
+    @Test(expected = X509Exception.SSLContextException.class)
+    public void testCreateSSLContext_invalidCustomSSLContextClass() throws Exception {
+        ZKConfig zkConfig = new ZKConfig();
+        ClientX509Util clientX509Util = new ClientX509Util();
+        zkConfig.setProperty(clientX509Util.getSslContextSupplierClassProperty(), String.class.getCanonicalName());
+        clientX509Util.createSSLContext(zkConfig);
+    }
+
     @Test
-    public void testCreateSSLContext_invalidCustomSSLContextClass() {
+    public void testCreateSSLContext_validNullCustomSSLContextClass() throws X509Exception.SSLContextException {
         ZKConfig zkConfig = new ZKConfig();
         ClientX509Util clientX509Util = new ClientX509Util();
-        zkConfig.setProperty(clientX509Util.getSslClientContextProperty(), String.class.getCanonicalName());
-        try {
-            clientX509Util.createSSLContext(zkConfig);
-            fail(""SSLContextException expected."");
-        } catch (X509Exception.SSLContextException e) {
-            assertTrue(e.getMessage().contains(clientX509Util.getSslClientContextProperty()));
-        }
+        zkConfig.setProperty(clientX509Util.getSslContextSupplierClassProperty(), X509UtilTest.class.getCanonicalName() + ""$"" + NullSslContextSupplier.class.getSimpleName());
+        final SSLContext sslContext = clientX509Util.createSSLContext(zkConfig);
+        assertNull(sslContext);
     }
 
     @Test
     public void testCreateSSLContext_validCustomSSLContextClass() throws X509Exception.SSLContextException {
         ZKConfig zkConfig = new ZKConfig();
         ClientX509Util clientX509Util = new ClientX509Util();
-        zkConfig.setProperty(clientX509Util.getSslClientContextProperty(), ZKTestClientSSLContext.class.getCanonicalName());
+        zkConfig.setProperty(clientX509Util.getSslContextSupplierClassProperty(), X509UtilTest.class.getCanonicalName() + ""$"" + SslContextSupplier.class.getSimpleName());
         final SSLContext sslContext = clientX509Util.createSSLContext(zkConfig);
-        assertNull(sslContext);
+        assertNotNull(sslContext);","[{'comment': 'nit: I think this can be `assertEquals(SSLContext.getDefault(), sslContext)`', 'commenter': 'ivmaykov'}, {'comment': ""Good point - getDefault() returns a singleton representing the default SSLContext, so it'll be the same object."", 'commenter': 'arankin-irl'}]"
728,zookeeper-server/src/test/java/org/apache/zookeeper/common/X509UtilTest.java,"@@ -513,4 +518,27 @@ private void setCustomCipherSuites() {
         x509Util.close(); // remember to close old instance before replacing it
         x509Util = new ClientX509Util();
     }
+
+    public static class NullSslContextSupplier implements Supplier<SSLContext> {
+
+        @Override
+        public SSLContext get() {
+            return null;
+        }
+
+    }
+
+    public static class SslContextSupplier implements Supplier<SSLContext> {
+
+        @Override
+        public SSLContext get() {
+            try {
+                return SSLContext.getDefault();
+            } catch (NoSuchAlgorithmException e) {
+                return null;","[{'comment': 'nit: `throw new RuntimeException(e);` so if this ever happens (unlikely), the error will be more obvious in the test', 'commenter': 'ivmaykov'}, {'comment': 'Will do :+1:', 'commenter': 'arankin-irl'}]"
728,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -238,18 +239,19 @@ public int getSslHandshakeTimeoutMillis() {
         return result;
     }
 
+    @SuppressWarnings(""unchecked"")
     public SSLContext createSSLContext(ZKConfig config) throws SSLContextException {
-        if (config.getProperty(sslClientContextProperty) != null) {
-            LOG.debug(""Loading SSLContext from property '"" + sslClientContextProperty + ""'"");
-            String sslClientContextClass = config.getProperty(sslClientContextProperty);
+        if (config.getProperty(sslContextSupplierClassProperty) != null) {
+            LOG.debug(""Loading SSLContext supplier from property '"" + sslContextSupplierClassProperty + ""'"");
+            String supplierContextClassName = config.getProperty(sslContextSupplierClassProperty);","[{'comment': ""super nit: get the property before the first `if` in this method and store in a local variable, so you don't call `config.getProperty()` multiple times?"", 'commenter': 'ivmaykov'}, {'comment': 'Yep, missed that :+1:', 'commenter': 'arankin-irl'}]"
728,zookeeper-server/src/test/java/org/apache/zookeeper/common/X509UtilTest.java,"@@ -406,26 +407,30 @@ public void testGetSslHandshakeDetectionTimeoutMillisProperty() {
         }
     }
 
+    @Test(expected = X509Exception.SSLContextException.class)
+    public void testCreateSSLContext_invalidCustomSSLContextClass() throws Exception {
+        ZKConfig zkConfig = new ZKConfig();
+        ClientX509Util clientX509Util = new ClientX509Util();
+        zkConfig.setProperty(clientX509Util.getSslContextSupplierClassProperty(), String.class.getCanonicalName());
+        clientX509Util.createSSLContext(zkConfig);
+    }
+
     @Test
-    public void testCreateSSLContext_invalidCustomSSLContextClass() {
+    public void testCreateSSLContext_validNullCustomSSLContextClass() throws X509Exception.SSLContextException {
         ZKConfig zkConfig = new ZKConfig();
         ClientX509Util clientX509Util = new ClientX509Util();
-        zkConfig.setProperty(clientX509Util.getSslClientContextProperty(), String.class.getCanonicalName());
-        try {
-            clientX509Util.createSSLContext(zkConfig);
-            fail(""SSLContextException expected."");
-        } catch (X509Exception.SSLContextException e) {
-            assertTrue(e.getMessage().contains(clientX509Util.getSslClientContextProperty()));
-        }
+        zkConfig.setProperty(clientX509Util.getSslContextSupplierClassProperty(), X509UtilTest.class.getCanonicalName() + ""$"" + NullSslContextSupplier.class.getSimpleName());","[{'comment': ""I think `NullSslContextSupplier.class.getName()` will return the full class name for the inner class so you don't need to manually concatenate."", 'commenter': 'ivmaykov'}, {'comment': 'Ah yes, `getName()` would work here :+1:', 'commenter': 'arankin-irl'}]"
730,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java,"@@ -740,6 +772,18 @@ void shutdown(String reason) {
         isShutdown = true;
     }
 
+    synchronized void closeSockets() {
+        if (serverSockets != null)
+            for (ServerSocket serverSocket : serverSockets) {
+                if (!serverSocket.isClosed())
+                    try {
+                        serverSocket.close();
+                    } catch (IOException e) {
+                        LOG.warn(""Ignoring unexpected exception during close"" + serverSocket, e);","[{'comment': 'Please use built-in message formatter:\r\n```\r\nLOG.warn(""Ignoring unexpected exception during close {}"", serverSocket, e);\r\n```', 'commenter': 'anmolnar'}]"
730,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Learner.java,"@@ -306,6 +279,82 @@ protected void connectToLeader(InetSocketAddress addr, String hostname)
         leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);
     }
 
+    class LeaderConnector implements Runnable {
+
+        private AtomicReference<Socket> socket;
+        private InetSocketAddress address;
+        private CountDownLatch latch;
+
+        LeaderConnector(InetSocketAddress address, AtomicReference<Socket> socket, CountDownLatch latch) {
+            this.address = address;
+            this.socket = socket;
+            this.latch = latch;
+        }
+
+        @Override
+        public void run() {
+            try {
+                Thread.currentThread().setName(""LeaderConnector-"" + address);
+                Socket sock = connectToLeader();
+
+                if(sock != null && sock.isConnected() && !socket.compareAndSet(null, sock))
+                    sock.close();","[{'comment': 'Please consider adding a short log message to indicate that you close a redundant connection to the leader.', 'commenter': 'anmolnar'}]"
730,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Learner.java,"@@ -249,54 +253,23 @@ protected void sockConnect(Socket sock, InetSocketAddress addr, int timeout)
      * @param addr - the address of the Peer to connect to.
      * @throws IOException - if the socket connection fails on the 5th attempt
      * <li>if there is an authentication failure while connecting to leader</li>
-     * @throws ConnectException
      * @throws InterruptedException
      */
-    protected void connectToLeader(InetSocketAddress addr, String hostname)
-            throws IOException, InterruptedException, X509Exception {
-        this.sock = createSocket();
+    protected void connectToLeader(MultipleAddresses addr, String hostname)
+            throws IOException, InterruptedException {
 
-        int initLimitTime = self.tickTime * self.initLimit;
-        int remainingInitLimitTime;
-        long startNanoTime = nanoTime();
+        List<InetSocketAddress> addresses = addr.getAllAddresses();
+        ExecutorService executor = Executors.newFixedThreadPool(addresses.size());
+        CountDownLatch latch = new CountDownLatch(addresses.size());
+        AtomicReference<Socket> socket = new AtomicReference<>(null);
+        addresses.stream().map(address -> new LeaderConnector(address, socket, latch)).forEach(executor::submit);
 
-        for (int tries = 0; tries < 5; tries++) {
-            try {
-                // recalculate the init limit time because retries sleep for 1000 milliseconds
-                remainingInitLimitTime = initLimitTime - (int)((nanoTime() - startNanoTime) / 1000000);
-                if (remainingInitLimitTime <= 0) {
-                    LOG.error(""initLimit exceeded on retries."");
-                    throw new IOException(""initLimit exceeded on retries."");
-                }
+        latch.await();
 
-                sockConnect(sock, addr, Math.min(self.tickTime * self.syncLimit, remainingInitLimitTime));
-                if (self.isSslQuorum())  {
-                    ((SSLSocket) sock).startHandshake();
-                }
-                sock.setTcpNoDelay(nodelay);
-                break;
-            } catch (IOException e) {
-                remainingInitLimitTime = initLimitTime - (int)((nanoTime() - startNanoTime) / 1000000);
-
-                if (remainingInitLimitTime <= 1000) {
-                    LOG.error(""Unexpected exception, initLimit exceeded. tries="" + tries +
-                             "", remaining init limit="" + remainingInitLimitTime +
-                             "", connecting to "" + addr,e);
-                    throw e;
-                } else if (tries >= 4) {
-                    LOG.error(""Unexpected exception, retries exceeded. tries="" + tries +
-                             "", remaining init limit="" + remainingInitLimitTime +
-                             "", connecting to "" + addr,e);
-                    throw e;
-                } else {
-                    LOG.warn(""Unexpected exception, tries="" + tries +
-                            "", remaining init limit="" + remainingInitLimitTime +
-                            "", connecting to "" + addr,e);
-                    this.sock = createSocket();
-                }
-            }
-            Thread.sleep(leaderConnectDelayDuringRetryMs);
-        }
+        if(socket.get() == null)","[{'comment': 'Code style: please use brackets', 'commenter': 'anmolnar'}]"
730,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/MultipleAddresses.java,"@@ -0,0 +1,187 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.NoRouteToHostException;
+import java.net.UnknownHostException;
+import java.util.*;","[{'comment': ""Please don't use wildcard imports."", 'commenter': 'anmolnar'}]"
730,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/MultipleAddresses.java,"@@ -0,0 +1,187 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.NoRouteToHostException;
+import java.net.UnknownHostException;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * This class allows to store several quorum and electing addresses.
+ *
+ * See ZOOKEEPER-3188 for a discussion of this feature.
+ */
+public class MultipleAddresses {
+
+    private Set<InetSocketAddress> addresses;
+    private int timeout;
+
+    public MultipleAddresses() {
+        addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        timeout = 100;
+    }
+
+    public MultipleAddresses(List<InetSocketAddress> addresses) {
+        this(addresses, 100);
+    }
+
+    public MultipleAddresses(InetSocketAddress address) {
+        this(address, 100);
+    }
+
+    public MultipleAddresses(List<InetSocketAddress> addresses, int timeout) {
+        this.addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        this.addresses.addAll(addresses);
+        this.timeout = timeout;
+    }
+
+    public MultipleAddresses(InetSocketAddress address,  int timeout) {
+        addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        addresses.add(address);
+        this.timeout = timeout;
+    }
+
+    public int getTimeout() {
+        return timeout;
+    }
+
+    public void setTimeout(int timeout) {
+        this.timeout = timeout;
+    }
+
+    public boolean isEmpty() {
+        return addresses.isEmpty();
+    }
+
+    /**
+     * Returns all addresses.
+     *
+     * @return list of all InetSocketAddress
+     */
+    public List<InetSocketAddress> getAllAddresses() {
+        return new LinkedList<>(addresses);","[{'comment': 'Use `unmodifiableSet()` instead?', 'commenter': 'anmolnar'}]"
730,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/MultipleAddresses.java,"@@ -0,0 +1,187 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.NoRouteToHostException;
+import java.net.UnknownHostException;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * This class allows to store several quorum and electing addresses.
+ *
+ * See ZOOKEEPER-3188 for a discussion of this feature.
+ */
+public class MultipleAddresses {
+
+    private Set<InetSocketAddress> addresses;
+    private int timeout;
+
+    public MultipleAddresses() {
+        addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        timeout = 100;
+    }
+
+    public MultipleAddresses(List<InetSocketAddress> addresses) {
+        this(addresses, 100);
+    }
+
+    public MultipleAddresses(InetSocketAddress address) {
+        this(address, 100);
+    }
+
+    public MultipleAddresses(List<InetSocketAddress> addresses, int timeout) {
+        this.addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        this.addresses.addAll(addresses);
+        this.timeout = timeout;
+    }
+
+    public MultipleAddresses(InetSocketAddress address,  int timeout) {
+        addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        addresses.add(address);
+        this.timeout = timeout;
+    }
+
+    public int getTimeout() {
+        return timeout;
+    }
+
+    public void setTimeout(int timeout) {
+        this.timeout = timeout;
+    }
+
+    public boolean isEmpty() {
+        return addresses.isEmpty();
+    }
+
+    /**
+     * Returns all addresses.
+     *
+     * @return list of all InetSocketAddress
+     */
+    public List<InetSocketAddress> getAllAddresses() {
+        return new LinkedList<>(addresses);
+    }
+
+    /**
+     * Returns wildcard addresses for all ports
+     *
+     * @return list of InetSocketAddress with wildcards for all ports
+     */
+    public List<InetSocketAddress> getWildcardAddresses() {
+       return addresses.stream().map(a -> new InetSocketAddress(a.getPort())).distinct().collect(Collectors.toList());
+    }
+
+    /**
+     * Returns all ports
+     *
+     * @return list of all ports
+     */
+    public List<Integer> getAllPorts() {
+        return addresses.stream().map(InetSocketAddress::getPort).distinct().collect(Collectors.toList());
+    }
+
+    public void addAddress(InetSocketAddress address) {
+        addresses.add(address);
+    }
+
+    /**
+     * Returns reachable address. If none is reachable than throws exception.
+     *
+     * @return address which is reachable.
+     * @throws NoRouteToHostException if none address is reachable
+     */
+    public InetSocketAddress getValidAddress() throws NoRouteToHostException {","[{'comment': 'I believe `getReachableAddress` would be more suitable for this method. Every checks within refers to reachability.', 'commenter': 'anmolnar'}]"
730,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -18,35 +18,18 @@
 
 package org.apache.zookeeper.server.quorum;
 
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.net.BindException;
-import java.net.InetSocketAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
+import java.io.*;","[{'comment': 'Please revert the refactoring of wildcard imports.', 'commenter': 'anmolnar'}]"
730,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -332,7 +315,13 @@ public void testInitiateConnection(long sid) throws Exception {
         LOG.debug(""Opening channel to server "" + sid);
         Socket sock = new Socket();
         setSockOpts(sock);
-        sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);
+        InetSocketAddress address;
+        try {","[{'comment': 'This logic is quite common across the board. It would be better located in a parent or helper class.\r\nFor example in the `MultipleAddresses` class something like `getReachableOrOne`.', 'commenter': 'anmolnar'}]"
730,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java,"@@ -393,70 +404,113 @@ public boolean isQuorumSynced(QuorumVerifier qv) {
     protected final Proposal newLeaderProposal = new Proposal();
 
     class LearnerCnxAcceptor extends ZooKeeperCriticalThread {
-        private volatile boolean stop = false;
+        private AtomicBoolean stop;
+        private AtomicBoolean fail;
 
         public LearnerCnxAcceptor() {
-            super(""LearnerCnxAcceptor-"" + ss.getLocalSocketAddress(), zk
+            super(""LearnerCnxAcceptor-"" +
+                    serverSockets.stream().map(ServerSocket::getLocalSocketAddress).map(Objects::toString)
+                            .collect(Collectors.joining("","")), zk
                     .getZooKeeperServerListener());
+            stop = new AtomicBoolean(false);
+            fail = new AtomicBoolean(false);
         }
 
         @Override
         public void run() {
-            try {
-                while (!stop) {
-                    Socket s = null;
-                    boolean error = false;
-                    try {
-                        s = ss.accept();
-
-                        // start with the initLimit, once the ack is processed
-                        // in LearnerHandler switch to the syncLimit
-                        s.setSoTimeout(self.tickTime * self.initLimit);
-                        s.setTcpNoDelay(nodelay);
-
-                        BufferedInputStream is = new BufferedInputStream(
-                                s.getInputStream());
-                        LearnerHandler fh = new LearnerHandler(s, is, Leader.this);
-                        fh.start();
-                    } catch (SocketException e) {
-                        error = true;
-                        if (stop) {
-                            LOG.info(""exception while shutting down acceptor: ""
-                                    + e);
-
-                            // When Leader.shutdown() calls ss.close(),
-                            // the call to accept throws an exception.
-                            // We catch and set stop to true.
-                            stop = true;
-                        } else {
-                            throw e;
-                        }
-                    } catch (SaslException e){
-                        LOG.error(""Exception while connecting to quorum learner"", e);
-                        error = true;
-                    } catch (Exception e) {
-                        error = true;
+            if (!stop.get() && serverSockets != null) {
+                ExecutorService executor = Executors.newFixedThreadPool(serverSockets.size());
+                CountDownLatch latch = new CountDownLatch(serverSockets.size());
+
+                serverSockets.forEach(serverSocket ->
+                        executor.submit(new LearnerCnxAcceptorHandler(serverSocket, latch)));
+
+                try {
+                    latch.await();
+                } catch (InterruptedException ie) {
+                    LOG.error(""Interrupted while sleeping. "" +
+                            ""Ignoring exception"", ie);
+                } finally {
+                    closeSockets();
+                }
+            }
+        }
+
+        public void halt() {
+            stop.set(true);
+            closeSockets();
+        }
+
+        class LearnerCnxAcceptorHandler implements Runnable {
+            private ServerSocket serverSocket;
+            private CountDownLatch latch;
+
+            LearnerCnxAcceptorHandler(ServerSocket serverSocket, CountDownLatch latch) {
+                this.serverSocket = serverSocket;
+                this.latch = latch;
+            }
+
+            @Override
+            public void run() {
+                try {
+                    Thread.currentThread().setName(""LearnerCnxAcceptorHandler-"" + serverSocket.getLocalSocketAddress());
+
+                    while (!stop.get()) {
+                        acceptConnections();
+                    }
+                } catch (Exception e) {
+                    LOG.warn(""Exception while accepting follower"", e);
+                    if (!fail.get()) {","[{'comment': ""You'll want this to be `fail.getAndSet(true)` in order to get the benefits."", 'commenter': 'enixon'}, {'comment': 'agree, fixed', 'commenter': 'dmitriyHavrilovich'}]"
730,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Learner.java,"@@ -306,6 +280,81 @@ protected void connectToLeader(InetSocketAddress addr, String hostname)
         leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);
     }
 
+    class LeaderConnector implements Runnable {
+
+        private AtomicReference<Socket> socket;
+        private InetSocketAddress address;
+        private CountDownLatch latch;
+
+        LeaderConnector(InetSocketAddress address, AtomicReference<Socket> socket, CountDownLatch latch) {
+            this.address = address;
+            this.socket = socket;
+            this.latch = latch;
+        }
+
+        @Override
+        public void run() {
+            try {
+                Thread.currentThread().setName(""LeaderConnector-"" + address);
+                Socket sock = connectToLeader();
+
+                if (sock != null && sock.isConnected() && !socket.compareAndSet(null, sock)) {
+                    LOG.info(""Connection to the leader is already established, close the redundant connection"");
+                    sock.close();
+                }
+
+            } catch (Exception e) {
+                LOG.error(""Failed connect to {}"", address, e);
+            } finally {
+                latch.countDown();
+            }
+        }
+
+        private Socket connectToLeader() throws IOException, X509Exception, InterruptedException {
+            Socket sock = createSocket();
+
+            int initLimitTime = self.tickTime * self.initLimit;
+            int remainingInitLimitTime;
+            long startNanoTime = nanoTime();
+
+            for (int tries = 0; tries < 5 && socket.get() == null; tries++) {","[{'comment': 'Does it make sense to change the retry logic as well so as to not spend more time trying to talk to a single LearnerMaster?', 'commenter': 'enixon'}, {'comment': ""The current design in which all retries are hidden in the connection logic was specifically intended to make multipath networking transparent to the higher level retry logic. The rationale was that this would substantially reduce the probability of introducing bugs into commonly used logic (i.e. connect / reconnect) to optimize a rarely used capability (reconnect in the presence of redundant network options).\r\n\r\nWe felt that the benefit (very small, applicable rarely) was enormously outweighed by the risk (small, commonly used).\r\n\r\nI don't see any reason to rethink that. Do you have something in mind?"", 'commenter': 'tdunning'}]"
735,ivy.xml,"@@ -90,8 +90,8 @@
                 rev=""${apache-rat-tasks.version}"" conf=""releaseaudit->default"">
         <exclude org=""commons-collections"" module=""commons-collections""/>
     </dependency>
-    <dependency org=""commons-lang"" name=""commons-lang"" ","[{'comment': 'This seems unrelated', 'commenter': 'eolivelli'}, {'comment': 'It appears the commons-lang library is not included for all the targets in the ivy settings [https://github.com/apache/zookeeper/blob/master/ivy.xml#L93]. So I have to update the conf with `default` to make the code compile. Also the apache commons-lang (`org.apache.commons.lang`) is not used anywhere in the source. So this might not have been a issue before.', 'commenter': 'dineshappavoo'}]"
735,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -2665,6 +2668,68 @@ public void getChildren(String path, boolean watch, Children2Callback cb,
         getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);
     }
 
+    /**
+     * Synchronously gets all the ephemeral nodes  created by this session.
+     *
+     * @since 3.5.0","[{'comment': 'This should go to 3.6.0.\r\n3.5 branch is almost close', 'commenter': 'eolivelli'}, {'comment': 'Updated with 3.6.0', 'commenter': 'dineshappavoo'}]"
735,src/java/test/org/apache/zookeeper/test/GetEphemeralsTest.java,"@@ -0,0 +1,234 @@
+/**","[{'comment': 'this file should be moved over to zookeeper-server :)', 'commenter': 'enixon'}, {'comment': 'Good catch:). We will have to rebase the package restructure change in our internal version. ', 'commenter': 'dineshappavoo'}]"
735,zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -434,6 +439,25 @@ public void processRequest(Request request) {
                 }
                 break;
             }
+            case OpCode.getEphemerals: {
+                lastOp = ""GETE"";
+                GetEphemeralsRequest getEphemerals = new GetEphemeralsRequest();
+                ByteBufferInputStream.byteBuffer2Record(request.request, getEphemerals);
+                String prefixPath = getEphemerals.getPrefixPath();
+                Set<String> allEphems = zks.getZKDatabase().dataTree.getEphemerals(request.sessionId);","[{'comment': 'nit - can you use zks.getZKDatabase().getDataTree() instead of directly accessing the underlying member?', 'commenter': 'enixon'}, {'comment': 'Updated. Thanks!', 'commenter': 'dineshappavoo'}]"
742,zookeeper-server/src/main/java/org/apache/zookeeper/server/EphemeralType.java,"@@ -212,7 +212,8 @@ public static void validateServerId(long serverId) {
      */
     public static void validateTTL(CreateMode mode, long ttl) {
         if (mode.isTTL()) {
-            TTL.toEphemeralOwner(ttl);
+            // nothing to do in 3.5 was:
+            // TTL.toEphemeralOwner(ttl);","[{'comment': 'We could remove the if-else, but than we would have to be extra careful with backporting. So, works for me!', 'commenter': 'nkalmar'}, {'comment': '@eolivelli How is this code change related to this patch?', 'commenter': 'anmolnar'}]"
742,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/BitMap.java,"@@ -60,7 +60,7 @@ public Integer add(T value) {
             if (bit > -1) {
                 freedBitSet.clear(bit);
             } else {
-                bit = nextBit++;
+                bit = nextBit;","[{'comment': ""nothing will increase nextBit then. Are you sure this is good?\r\nOnly WatchManagerOptimized.addWatch() uses it, and it should be unique id for every watch, so looks good... I'm not sure why this nextBit++ was here in the first place...\r\nDoes findbugs have some issue with this?"", 'commenter': 'nkalmar'}, {'comment': 'It is a dead local store error', 'commenter': 'eolivelli'}, {'comment': 'actualy this is not a ""dead local store"", because ""nextBit"" is a field.\r\ntests are failing.\r\nI will try to understand why spotbugs is concerned, eventually I will add a SuppressWarnings', 'commenter': 'eolivelli'}]"
742,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/ObserverMaster.java,"@@ -463,7 +463,10 @@ synchronized public void start() throws IOException {
     public void run() {
         while (listenerRunning) {
             try {
-                Socket s = ss.accept();
+                Socket s;
+                synchronized(this) {","[{'comment': 'this is bad and tests are failing.\r\nI will take another approach', 'commenter': 'eolivelli'}]"
742,excludeFindBugsFilter.xml,"@@ -0,0 +1,14 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+
+<FindBugsFilter>","[{'comment': 'Naming is a little bit confusing I think. Given that this is a config file of `spotBugs`, shouldn\'t we call it `spotBugsFilter.xml` instead?\r\nThough the XML tag name has remained ""FindBugs"", so I\'m not sure.', 'commenter': 'anmolnar'}, {'comment': ""@anmolnar  this name is very common, as many project migrated from findbugs.\r\nI can change, no problem. But I don't feel strong about it."", 'commenter': 'eolivelli'}, {'comment': ""Leave it, I'm fine with that."", 'commenter': 'anmolnar'}]"
742,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -18,6 +18,7 @@
 
 package org.apache.zookeeper;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;","[{'comment': ""Do we have to migrate to this annotation-based approach of defining filters?\r\nCan't we just re-use the existing findBugs filter file?"", 'commenter': 'anmolnar'}, {'comment': ""@anmolnar personally I like to use annotation because when you read the java file you see the problems.\r\nAnd I am usually using the configuration file for coarse grained  control, like when there is some kind of check you don't want to consider at all or in many files"", 'commenter': 'eolivelli'}, {'comment': ""I'm willing to accept it, but it makes the patch slightly bigger and I feel like we need some additional support from the community in this case. At least one more approval from a committer."", 'commenter': 'anmolnar'}]"
742,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -180,7 +180,7 @@ public static void setPreallocSize(long size) {
      * @param serverStats used to update fsyncThresholdExceedCount
      */
     @Override
-    public void setServerStats(ServerStats serverStats) {
+    public synchronized void setServerStats(ServerStats serverStats) {","[{'comment': ""I'm not sure if we need to synchronize here, but it shouldn't be part of this patch."", 'commenter': 'anmolnar'}, {'comment': 'This is spotbugs error:\r\n`[ERROR] Inconsistent synchronization of org.apache.zookeeper.server.persistence.FileTxnLog.serverStats; locked 66% of time [org.apache.zookeeper.server.persistence.FileTxnLog, org.apache.zookeeper.server.persistence.FileTxnLog, org.apache.zookeeper.server.persistence.FileTxnLog] Unsynchronized access at FileTxnLog.java:[line 184]Synchronized access at FileTxnLog.java:[line 381]Synchronized access at FileTxnLog.java:[line 382] IS2_INCONSISTENT_SYNC\r\n`\r\n\r\nI think this change is safe', 'commenter': 'eolivelli'}, {'comment': ""Ok, let's keep it then. Looks safe to me too."", 'commenter': 'anmolnar'}]"
747,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java,"@@ -68,7 +68,34 @@
      * the system up again after long partitions. Currently 60 seconds.
      */
 
-    final static int maxNotificationInterval = 60000;
+    private static int maxNotificationInterval = 60000;
+
+    /**
+     * Lower bound for notification check. The observer don't need to use
+     * the same lower bound as participant members
+     */
+    private static int minNotificationInterval = finalizeWait;
+
+    /**
+     * Minimum notification interval, default is equal to finalizeWait
+     */
+    public static final String MIN_NOTIFICATION_INTERVAL =
+            ""zookeeper.fastleader.minNotificationInterval"";
+
+    /**
+     * Maximum notification interval, default is 60s
+     */
+    public static final String MAX_NOTIFICATION_INTERVAL =
+            ""zookeeper.fastleader.maxNotificationInterval"";
+
+    static {
+        minNotificationInterval = Integer.getInteger(MIN_NOTIFICATION_INTERVAL,
+                minNotificationInterval);","[{'comment': 'Please use the {} logging format.', 'commenter': 'lvfangmin'}]"
753,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxnSocketNetty.java,"@@ -18,47 +18,45 @@
 
 package org.apache.zookeeper;
 
+import io.netty.bootstrap.Bootstrap;","[{'comment': 'nit: this import order is different from the one on master branch.', 'commenter': 'ivmaykov'}, {'comment': 'Done.', 'commenter': 'anmolnar'}]"
753,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -89,41 +86,43 @@ public void close() {
         closingChannel = true;
         
         if (LOG.isDebugEnabled()) {
-            LOG.debug(""close called for sessionid:0x""
-                    + Long.toHexString(sessionId));
+            LOG.debug(""close called for sessionid:0x{}"",
+                    Long.toHexString(sessionId));
         }
 
         // ZOOKEEPER-2743:
         // Always unregister connection upon close to prevent
         // connection bean leak under certain race conditions.
         factory.unregisterConnection(this);
 
-        synchronized(factory.cnxns){
-            // if this is not in cnxns then it's already closed
-            if (!factory.cnxns.remove(this)) {
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug(""cnxns size:"" + factory.cnxns.size());
-                }
-                return;
-            }
+        // if this is not in cnxns then it's already closed
+        if (!factory.cnxns.remove(this)) {
             if (LOG.isDebugEnabled()) {
-                LOG.debug(""close in progress for sessionid:0x""
-                        + Long.toHexString(sessionId));
-            }
-
-            synchronized (factory.ipMap) {
-                Set<NettyServerCnxn> s =
-                    factory.ipMap.get(((InetSocketAddress)channel
-                            .getRemoteAddress()).getAddress());
-                s.remove(this);
+                LOG.debug(""cnxns size:{}"", factory.cnxns.size());
             }
+            return;
+        }
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""close in progress for sessionid:0x{}"",
+                    Long.toHexString(sessionId));
         }
 
+        factory.removeCnxnFromIpMap(
+                this,
+                ((InetSocketAddress)channel.remoteAddress()).getAddress());
+","[{'comment': 'the master branch calls `zkServer.removeCnxn(this);` here, and so does `NIOServerCnxn.close()` on the 3.5 branch. So I think you need to add the following code here:\r\n\r\n```\r\nif (zkServer != null) {\r\n  zkServer.removeCnxn(this);\r\n}\r\n```\r\n', 'commenter': 'ivmaykov'}, {'comment': ""That's part of a different patch. @lvfangmin added it with https://github.com/apache/zookeeper/commit/95557a30edbdfdf4479a1cb142e0d82a4ba6061d\r\nBecause we decided not to backport that patch, I haven't added it."", 'commenter': 'anmolnar'}, {'comment': ""Leaking watchers when Netty implementation is used seems like a bad idea though. Why don't we want to backport it? Won't this cause a memory leak and eventually cause the server to OOM? Or is there some other mechanism that will clean up the leaked watchers?"", 'commenter': 'ivmaykov'}, {'comment': ""Hm. Fine by me. I'll backport it in a separate patch."", 'commenter': 'anmolnar'}]"
753,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -411,19 +494,44 @@ public void receiveMessage(ChannelBuffer message) {
         }
     }
 
+    /**
+     * An event that triggers a change in the channel's ""Auto Read"" setting.
+     * Used for throttling. By using an enum we can treat the two values as
+     * singletons and compare with ==.
+     */
+    enum AutoReadEvent {
+        DISABLE,
+        ENABLE
+    }
+
     @Override
     public void disableRecv() {
-        disableRecvNoWait().awaitUninterruptibly();
+        if (throttled.compareAndSet(false, true)) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug(""Throttling - disabling recv {}"", this);
+            }
+            channel.pipeline().fireUserEventTriggered(AutoReadEvent.DISABLE);
+        }
     }
-    
-    private ChannelFuture disableRecvNoWait() {
-        throttled = true;
-        if (LOG.isDebugEnabled()) {
-            LOG.debug(""Throttling - disabling recv "" + this);
+
+    /**
+     * Note that the netty implementation ignores the <code>waitDisableRecv</code>","[{'comment': 'This comment is for the master branch, where there is a single `disableRecv(bool waitDisableRecv)` method. A more appropriate comment for 3.5 which has 2 methods might be something like:\r\n\r\n""Note that both disableRecv() and disableRecvNoWait() are asynchronous in the netty implementation.""\r\n\r\nAnd put that comment on the `disableRecv()` method instead.', 'commenter': 'ivmaykov'}, {'comment': 'Done.', 'commenter': 'anmolnar'}]"
753,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -61,215 +26,184 @@
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
-import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
 
-import static org.jboss.netty.buffer.ChannelBuffers.dynamicBuffer;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
+
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelDuplexHandler;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.ChannelPromise;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.group.ChannelGroup;
+import io.netty.channel.group.ChannelGroupFuture;
+import io.netty.channel.group.DefaultChannelGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.util.AttributeKey;
+import io.netty.util.ReferenceCountUtil;
+import io.netty.util.concurrent.DefaultEventExecutor;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.common.ClientX509Util;
+import org.apache.zookeeper.common.NettyUtils;
+import org.apache.zookeeper.common.X509Exception;
+import org.apache.zookeeper.common.X509Exception.SSLContextException;
+import org.apache.zookeeper.server.auth.ProviderRegistry;
+import org.apache.zookeeper.server.auth.X509AuthenticationProvider;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class NettyServerCnxnFactory extends ServerCnxnFactory {
     private static final Logger LOG = LoggerFactory.getLogger(NettyServerCnxnFactory.class);
 
-    ServerBootstrap bootstrap;
-    Channel parentChannel;
-    ChannelGroup allChannels = new DefaultChannelGroup(""zkServerCnxns"");
-    HashMap<InetAddress, Set<NettyServerCnxn>> ipMap =
-        new HashMap<InetAddress, Set<NettyServerCnxn>>( );
-    InetSocketAddress localAddress;
-    int maxClientCnxns = 60;
-    ClientX509Util x509Util;
+    private final ServerBootstrap bootstrap;
+    private Channel parentChannel;
+    private final ChannelGroup allChannels =
+            new DefaultChannelGroup(""zkServerCnxns"", new DefaultEventExecutor());
+    // Access to ipMap or to any Set contained in the map needs to be
+    // protected with synchronized (ipMap) { ... }
+    private final Map<InetAddress, Set<NettyServerCnxn>> ipMap = new HashMap<>();
+    private InetSocketAddress localAddress;
+    private int maxClientCnxns = 60;
+    private final ClientX509Util x509Util;
+
+    private static final AttributeKey<NettyServerCnxn> CONNECTION_ATTRIBUTE =
+            AttributeKey.valueOf(""NettyServerCnxn"");
+
+    private static final AtomicReference<ByteBufAllocator> TEST_ALLOCATOR =
+            new AtomicReference<>(null);
 
     /**
-     * This is an inner class since we need to extend SimpleChannelHandler, but
+     * This is an inner class since we need to extend ChannelDuplexHandler, but
      * NettyServerCnxnFactory already extends ServerCnxnFactory. By making it inner
      * this class gets access to the member variables and methods.
      */
     @Sharable
-    class CnxnChannelHandler extends SimpleChannelHandler {
+    class CnxnChannelHandler extends ChannelDuplexHandler {
 
         @Override
-        public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e)
-            throws Exception
-        {
+        public void channelActive(ChannelHandlerContext ctx) throws Exception {
             if (LOG.isTraceEnabled()) {
-                LOG.trace(""Channel closed "" + e);
+                LOG.trace(""Channel active {}"", ctx.channel());
             }
-            allChannels.remove(ctx.getChannel());
-        }
 
-        @Override
-        public void channelConnected(ChannelHandlerContext ctx,
-                ChannelStateEvent e) throws Exception
-        {
-            if (LOG.isTraceEnabled()) {
-                LOG.trace(""Channel connected "" + e);
-            }
-
-            NettyServerCnxn cnxn = new NettyServerCnxn(ctx.getChannel(),
+            NettyServerCnxn cnxn = new NettyServerCnxn(ctx.channel(),
                     zkServer, NettyServerCnxnFactory.this);
-            ctx.setAttachment(cnxn);
+            ctx.channel().attr(CONNECTION_ATTRIBUTE).set(cnxn);
 
             if (secure) {
-                SslHandler sslHandler = ctx.getPipeline().get(SslHandler.class);
-                ChannelFuture handshakeFuture = sslHandler.handshake();
+                SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);
+                Future<Channel> handshakeFuture = sslHandler.handshakeFuture();
                 handshakeFuture.addListener(new CertificateVerifier(sslHandler, cnxn));
             } else {
-                allChannels.add(ctx.getChannel());
+                allChannels.add(ctx.channel());
                 addCnxn(cnxn);
             }
         }
 
         @Override
-        public void channelDisconnected(ChannelHandlerContext ctx,
-                ChannelStateEvent e) throws Exception
-        {
+        public void channelInactive(ChannelHandlerContext ctx) throws Exception {
             if (LOG.isTraceEnabled()) {
-                LOG.trace(""Channel disconnected "" + e);
+                LOG.trace(""Channel inactive {}"", ctx.channel());
             }
-            NettyServerCnxn cnxn = (NettyServerCnxn) ctx.getAttachment();
+            allChannels.remove(ctx.channel());
+            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);
             if (cnxn != null) {
                 if (LOG.isTraceEnabled()) {
-                    LOG.trace(""Channel disconnect caused close "" + e);
+                    LOG.trace(""Channel inactive caused close {}"", cnxn);
                 }
                 cnxn.close();
             }
         }
 
         @Override
-        public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
-            throws Exception
-        {
-            LOG.warn(""Exception caught "" + e, e.getCause());
-            NettyServerCnxn cnxn = (NettyServerCnxn) ctx.getAttachment();
+        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+            LOG.warn(""Exception caught"", cause);
+            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);
             if (cnxn != null) {
                 if (LOG.isDebugEnabled()) {
-                    LOG.debug(""Closing "" + cnxn);
+                    LOG.debug(""Closing {}"", cnxn);
                 }
                 cnxn.close();
             }
         }
 
         @Override
-        public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
-            throws Exception
-        {
-            if (LOG.isTraceEnabled()) {
-                LOG.trace(""message received called "" + e.getMessage());
-            }
+        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
             try {
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug(""New message "" + e.toString()
-                            + "" from "" + ctx.getChannel());
-                }
-                NettyServerCnxn cnxn = (NettyServerCnxn)ctx.getAttachment();
-                synchronized(cnxn) {
-                    processMessage(e, cnxn);
+                if (evt == NettyServerCnxn.AutoReadEvent.ENABLE) {
+                    LOG.debug(""Received AutoReadEvent.ENABLE"");
+                    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();
+                    // TODO(ilyam): Not sure if cnxn can be null here. It becomes null if channelInactive()","[{'comment': 'heh, my FB username is ""ilyam"" but github is ""ivmaykov"" ... do you mind changing it in this TODO comment?', 'commenter': 'ivmaykov'}, {'comment': 'Done.', 'commenter': 'anmolnar'}]"
753,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -303,19 +277,126 @@ private boolean checkFourLetterWord(final Channel channel,
         }
     }
 
-    public void receiveMessage(ChannelBuffer message) {
+    /**
+     * Process incoming message. This should only be called from the event
+     * loop thread.
+     * @param buf the message bytes to process.
+     */
+    void processMessage(ByteBuf buf) {
+        assert channel.eventLoop().inEventLoop();","[{'comment': 'nit: in our internal fork, we changed these asserts to if-throws (I forgot to upstream this change, will do it on master branch shortly). I don\'t think it matters that much since they\'ve never fired. Anyway, what do you think about replacing this assert with:\r\n\r\n```\r\n        if (!channel.eventLoop().inEventLoop()) {\r\n            throw new IllegalStateException(\r\n                    ""processMessage() called from non-EventLoop thread"");\r\n        }\r\n```', 'commenter': 'ivmaykov'}, {'comment': 'I suggest to stay in-sync with master now until that patch is not accepted. After that we can backport and release it easily.', 'commenter': 'anmolnar'}]"
753,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -303,19 +277,126 @@ private boolean checkFourLetterWord(final Channel channel,
         }
     }
 
-    public void receiveMessage(ChannelBuffer message) {
+    /**
+     * Process incoming message. This should only be called from the event
+     * loop thread.
+     * @param buf the message bytes to process.
+     */
+    void processMessage(ByteBuf buf) {
+        assert channel.eventLoop().inEventLoop();
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""0x{} queuedBuffer: {}"",
+                    Long.toHexString(sessionId),
+                    queuedBuffer);
+        }
+
+        if (LOG.isTraceEnabled()) {
+            LOG.trace(""0x{} buf {}"",
+                    Long.toHexString(sessionId),
+                    ByteBufUtil.hexDump(buf));
+        }
+
+        if (throttled.get()) {
+            LOG.debug(""Received message while throttled"");
+            // we are throttled, so we need to queue
+            if (queuedBuffer == null) {
+                LOG.debug(""allocating queue"");
+                queuedBuffer = channel.alloc().buffer(buf.readableBytes());
+            }
+            queuedBuffer.writeBytes(buf);
+            if (LOG.isTraceEnabled()) {
+                LOG.trace(""0x{} queuedBuffer {}"",
+                        Long.toHexString(sessionId),
+                        ByteBufUtil.hexDump(queuedBuffer));
+            }
+        } else {
+            LOG.debug(""not throttled"");
+            if (queuedBuffer != null) {
+                queuedBuffer.writeBytes(buf);
+                processQueuedBuffer();
+            } else {
+                receiveMessage(buf);
+                // Have to check !closingChannel, because an error in
+                // receiveMessage() could have led to close() being called.
+                if (!closingChannel && buf.isReadable()) {
+                    if (LOG.isTraceEnabled()) {
+                        LOG.trace(""Before copy {}"", buf);
+                    }
+                    if (queuedBuffer == null) {
+                        queuedBuffer = channel.alloc().buffer(buf.readableBytes());
+                    }
+                    queuedBuffer.writeBytes(buf);
+                    if (LOG.isTraceEnabled()) {
+                        LOG.trace(""Copy is {}"", queuedBuffer);
+                        LOG.trace(""0x{} queuedBuffer {}"",
+                                Long.toHexString(sessionId),
+                                ByteBufUtil.hexDump(queuedBuffer));
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Try to process previously queued message. This should only be called
+     * from the event loop thread.
+     */
+    void processQueuedBuffer() {
+        assert channel.eventLoop().inEventLoop();","[{'comment': '```\r\n        if (!channel.eventLoop().inEventLoop()) {\r\n            throw new IllegalStateException(\r\n                    ""processQueuedBuffer() called from non-EventLoop thread"");\r\n        }\r\n```', 'commenter': 'ivmaykov'}, {'comment': 'Same here.', 'commenter': 'anmolnar'}]"
753,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -303,19 +277,126 @@ private boolean checkFourLetterWord(final Channel channel,
         }
     }
 
-    public void receiveMessage(ChannelBuffer message) {
+    /**
+     * Process incoming message. This should only be called from the event
+     * loop thread.
+     * @param buf the message bytes to process.
+     */
+    void processMessage(ByteBuf buf) {
+        assert channel.eventLoop().inEventLoop();
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""0x{} queuedBuffer: {}"",
+                    Long.toHexString(sessionId),
+                    queuedBuffer);
+        }
+
+        if (LOG.isTraceEnabled()) {
+            LOG.trace(""0x{} buf {}"",
+                    Long.toHexString(sessionId),
+                    ByteBufUtil.hexDump(buf));
+        }
+
+        if (throttled.get()) {
+            LOG.debug(""Received message while throttled"");
+            // we are throttled, so we need to queue
+            if (queuedBuffer == null) {
+                LOG.debug(""allocating queue"");
+                queuedBuffer = channel.alloc().buffer(buf.readableBytes());
+            }
+            queuedBuffer.writeBytes(buf);
+            if (LOG.isTraceEnabled()) {
+                LOG.trace(""0x{} queuedBuffer {}"",
+                        Long.toHexString(sessionId),
+                        ByteBufUtil.hexDump(queuedBuffer));
+            }
+        } else {
+            LOG.debug(""not throttled"");
+            if (queuedBuffer != null) {
+                queuedBuffer.writeBytes(buf);
+                processQueuedBuffer();
+            } else {
+                receiveMessage(buf);
+                // Have to check !closingChannel, because an error in
+                // receiveMessage() could have led to close() being called.
+                if (!closingChannel && buf.isReadable()) {
+                    if (LOG.isTraceEnabled()) {
+                        LOG.trace(""Before copy {}"", buf);
+                    }
+                    if (queuedBuffer == null) {
+                        queuedBuffer = channel.alloc().buffer(buf.readableBytes());
+                    }
+                    queuedBuffer.writeBytes(buf);
+                    if (LOG.isTraceEnabled()) {
+                        LOG.trace(""Copy is {}"", queuedBuffer);
+                        LOG.trace(""0x{} queuedBuffer {}"",
+                                Long.toHexString(sessionId),
+                                ByteBufUtil.hexDump(queuedBuffer));
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Try to process previously queued message. This should only be called
+     * from the event loop thread.
+     */
+    void processQueuedBuffer() {
+        assert channel.eventLoop().inEventLoop();
+        if (queuedBuffer != null) {
+            if (LOG.isTraceEnabled()) {
+                LOG.trace(""processing queue 0x{} queuedBuffer {}"",
+                        Long.toHexString(sessionId),
+                        ByteBufUtil.hexDump(queuedBuffer));
+            }
+            receiveMessage(queuedBuffer);
+            if (closingChannel) {
+                // close() could have been called if receiveMessage() failed
+                LOG.debug(""Processed queue - channel closed, dropping remaining bytes"");
+            } else if (!queuedBuffer.isReadable()) {
+                LOG.debug(""Processed queue - no bytes remaining"");
+                releaseQueuedBuffer();
+            } else {
+                LOG.debug(""Processed queue - bytes remaining"");
+            }
+        } else {
+            LOG.debug(""queue empty"");
+        }
+    }
+
+    /**
+     * Clean up queued buffer once it's no longer needed. This should only be
+     * called from the event loop thread.
+     */
+    private void releaseQueuedBuffer() {
+        assert channel.eventLoop().inEventLoop();","[{'comment': '```\r\n        if (!channel.eventLoop().inEventLoop()) {\r\n            throw new IllegalStateException(\r\n                    ""releaseQueuedBuffer() called from non-EventLoop thread"");\r\n        }\r\n```', 'commenter': 'ivmaykov'}, {'comment': 'Same.', 'commenter': 'anmolnar'}]"
753,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -303,19 +277,126 @@ private boolean checkFourLetterWord(final Channel channel,
         }
     }
 
-    public void receiveMessage(ChannelBuffer message) {
+    /**
+     * Process incoming message. This should only be called from the event
+     * loop thread.
+     * @param buf the message bytes to process.
+     */
+    void processMessage(ByteBuf buf) {
+        assert channel.eventLoop().inEventLoop();
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""0x{} queuedBuffer: {}"",
+                    Long.toHexString(sessionId),
+                    queuedBuffer);
+        }
+
+        if (LOG.isTraceEnabled()) {
+            LOG.trace(""0x{} buf {}"",
+                    Long.toHexString(sessionId),
+                    ByteBufUtil.hexDump(buf));
+        }
+
+        if (throttled.get()) {
+            LOG.debug(""Received message while throttled"");
+            // we are throttled, so we need to queue
+            if (queuedBuffer == null) {
+                LOG.debug(""allocating queue"");
+                queuedBuffer = channel.alloc().buffer(buf.readableBytes());
+            }
+            queuedBuffer.writeBytes(buf);
+            if (LOG.isTraceEnabled()) {
+                LOG.trace(""0x{} queuedBuffer {}"",
+                        Long.toHexString(sessionId),
+                        ByteBufUtil.hexDump(queuedBuffer));
+            }
+        } else {
+            LOG.debug(""not throttled"");
+            if (queuedBuffer != null) {
+                queuedBuffer.writeBytes(buf);
+                processQueuedBuffer();
+            } else {
+                receiveMessage(buf);
+                // Have to check !closingChannel, because an error in
+                // receiveMessage() could have led to close() being called.
+                if (!closingChannel && buf.isReadable()) {
+                    if (LOG.isTraceEnabled()) {
+                        LOG.trace(""Before copy {}"", buf);
+                    }
+                    if (queuedBuffer == null) {
+                        queuedBuffer = channel.alloc().buffer(buf.readableBytes());
+                    }
+                    queuedBuffer.writeBytes(buf);
+                    if (LOG.isTraceEnabled()) {
+                        LOG.trace(""Copy is {}"", queuedBuffer);
+                        LOG.trace(""0x{} queuedBuffer {}"",
+                                Long.toHexString(sessionId),
+                                ByteBufUtil.hexDump(queuedBuffer));
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Try to process previously queued message. This should only be called
+     * from the event loop thread.
+     */
+    void processQueuedBuffer() {
+        assert channel.eventLoop().inEventLoop();
+        if (queuedBuffer != null) {
+            if (LOG.isTraceEnabled()) {
+                LOG.trace(""processing queue 0x{} queuedBuffer {}"",
+                        Long.toHexString(sessionId),
+                        ByteBufUtil.hexDump(queuedBuffer));
+            }
+            receiveMessage(queuedBuffer);
+            if (closingChannel) {
+                // close() could have been called if receiveMessage() failed
+                LOG.debug(""Processed queue - channel closed, dropping remaining bytes"");
+            } else if (!queuedBuffer.isReadable()) {
+                LOG.debug(""Processed queue - no bytes remaining"");
+                releaseQueuedBuffer();
+            } else {
+                LOG.debug(""Processed queue - bytes remaining"");
+            }
+        } else {
+            LOG.debug(""queue empty"");
+        }
+    }
+
+    /**
+     * Clean up queued buffer once it's no longer needed. This should only be
+     * called from the event loop thread.
+     */
+    private void releaseQueuedBuffer() {
+        assert channel.eventLoop().inEventLoop();
+        if (queuedBuffer != null) {
+            ReferenceCountUtil.release(queuedBuffer);
+            queuedBuffer = null;
+        }
+    }
+
+    /**
+     * Receive a message, which can come from the queued buffer or from a new
+     * buffer coming in over the channel. This should only be called from the
+     * event loop thread.
+     * @param message the message bytes to process.
+     */
+    private void receiveMessage(ByteBuf message) {
+        assert channel.eventLoop().inEventLoop();","[{'comment': '```\r\n        if (!channel.eventLoop().inEventLoop()) {\r\n            throw new IllegalStateException(\r\n                    ""receiveMessage() called from non-EventLoop thread"");\r\n        }\r\n```', 'commenter': 'ivmaykov'}, {'comment': 'And... the same.', 'commenter': 'anmolnar'}]"
753,build.xml,"@@ -36,7 +36,7 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
 
     <property name=""audience-annotations.version"" value=""0.5.0"" />
 
-    <property name=""netty.version"" value=""3.10.6.Final""/>
+    <property name=""netty.version"" value=""4.1.29.Final""/>","[{'comment': 'A few netty releases have happened since this code was written, consider using `4.1.33.Final` instead. It passes tests on my machine.', 'commenter': 'ivmaykov'}, {'comment': 'I think that the upgrade is needed, but not as part of this commit.\r\nIt an be a separate change (remember to change the pom.xml file !!!)', 'commenter': 'eolivelli'}, {'comment': ""Sure, let's do it in a separate PR"", 'commenter': 'ivmaykov'}]"
753,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -61,215 +26,184 @@
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
-import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
 
-import static org.jboss.netty.buffer.ChannelBuffers.dynamicBuffer;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
+
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelDuplexHandler;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.ChannelPromise;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.group.ChannelGroup;
+import io.netty.channel.group.ChannelGroupFuture;
+import io.netty.channel.group.DefaultChannelGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.util.AttributeKey;
+import io.netty.util.ReferenceCountUtil;
+import io.netty.util.concurrent.DefaultEventExecutor;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.common.ClientX509Util;
+import org.apache.zookeeper.common.NettyUtils;
+import org.apache.zookeeper.common.X509Exception;
+import org.apache.zookeeper.common.X509Exception.SSLContextException;
+import org.apache.zookeeper.server.auth.ProviderRegistry;
+import org.apache.zookeeper.server.auth.X509AuthenticationProvider;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class NettyServerCnxnFactory extends ServerCnxnFactory {
     private static final Logger LOG = LoggerFactory.getLogger(NettyServerCnxnFactory.class);
 
-    ServerBootstrap bootstrap;
-    Channel parentChannel;
-    ChannelGroup allChannels = new DefaultChannelGroup(""zkServerCnxns"");
-    HashMap<InetAddress, Set<NettyServerCnxn>> ipMap =
-        new HashMap<InetAddress, Set<NettyServerCnxn>>( );
-    InetSocketAddress localAddress;
-    int maxClientCnxns = 60;
-    ClientX509Util x509Util;
+    private final ServerBootstrap bootstrap;
+    private Channel parentChannel;
+    private final ChannelGroup allChannels =
+            new DefaultChannelGroup(""zkServerCnxns"", new DefaultEventExecutor());
+    // Access to ipMap or to any Set contained in the map needs to be
+    // protected with synchronized (ipMap) { ... }
+    private final Map<InetAddress, Set<NettyServerCnxn>> ipMap = new HashMap<>();
+    private InetSocketAddress localAddress;
+    private int maxClientCnxns = 60;
+    private final ClientX509Util x509Util;
+
+    private static final AttributeKey<NettyServerCnxn> CONNECTION_ATTRIBUTE =
+            AttributeKey.valueOf(""NettyServerCnxn"");
+
+    private static final AtomicReference<ByteBufAllocator> TEST_ALLOCATOR =
+            new AtomicReference<>(null);
 
     /**
-     * This is an inner class since we need to extend SimpleChannelHandler, but
+     * This is an inner class since we need to extend ChannelDuplexHandler, but
      * NettyServerCnxnFactory already extends ServerCnxnFactory. By making it inner
      * this class gets access to the member variables and methods.
      */
     @Sharable
-    class CnxnChannelHandler extends SimpleChannelHandler {
+    class CnxnChannelHandler extends ChannelDuplexHandler {
 
         @Override
-        public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e)
-            throws Exception
-        {
+        public void channelActive(ChannelHandlerContext ctx) throws Exception {
             if (LOG.isTraceEnabled()) {
-                LOG.trace(""Channel closed "" + e);
+                LOG.trace(""Channel active {}"", ctx.channel());
             }
-            allChannels.remove(ctx.getChannel());
-        }
 
-        @Override
-        public void channelConnected(ChannelHandlerContext ctx,
-                ChannelStateEvent e) throws Exception
-        {
-            if (LOG.isTraceEnabled()) {
-                LOG.trace(""Channel connected "" + e);
-            }
-
-            NettyServerCnxn cnxn = new NettyServerCnxn(ctx.getChannel(),
+            NettyServerCnxn cnxn = new NettyServerCnxn(ctx.channel(),
                     zkServer, NettyServerCnxnFactory.this);
-            ctx.setAttachment(cnxn);
+            ctx.channel().attr(CONNECTION_ATTRIBUTE).set(cnxn);
 
             if (secure) {
-                SslHandler sslHandler = ctx.getPipeline().get(SslHandler.class);
-                ChannelFuture handshakeFuture = sslHandler.handshake();
+                SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);
+                Future<Channel> handshakeFuture = sslHandler.handshakeFuture();
                 handshakeFuture.addListener(new CertificateVerifier(sslHandler, cnxn));
             } else {
-                allChannels.add(ctx.getChannel());
+                allChannels.add(ctx.channel());
                 addCnxn(cnxn);
             }
         }
 
         @Override
-        public void channelDisconnected(ChannelHandlerContext ctx,
-                ChannelStateEvent e) throws Exception
-        {
+        public void channelInactive(ChannelHandlerContext ctx) throws Exception {
             if (LOG.isTraceEnabled()) {
-                LOG.trace(""Channel disconnected "" + e);
+                LOG.trace(""Channel inactive {}"", ctx.channel());
             }
-            NettyServerCnxn cnxn = (NettyServerCnxn) ctx.getAttachment();
+            allChannels.remove(ctx.channel());
+            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);
             if (cnxn != null) {
                 if (LOG.isTraceEnabled()) {
-                    LOG.trace(""Channel disconnect caused close "" + e);
+                    LOG.trace(""Channel inactive caused close {}"", cnxn);
                 }
                 cnxn.close();
             }
         }
 
         @Override
-        public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
-            throws Exception
-        {
-            LOG.warn(""Exception caught "" + e, e.getCause());
-            NettyServerCnxn cnxn = (NettyServerCnxn) ctx.getAttachment();
+        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+            LOG.warn(""Exception caught"", cause);
+            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);
             if (cnxn != null) {
                 if (LOG.isDebugEnabled()) {
-                    LOG.debug(""Closing "" + cnxn);
+                    LOG.debug(""Closing {}"", cnxn);
                 }
                 cnxn.close();
             }
         }
 
         @Override
-        public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
-            throws Exception
-        {
-            if (LOG.isTraceEnabled()) {
-                LOG.trace(""message received called "" + e.getMessage());
-            }
+        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
             try {
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug(""New message "" + e.toString()
-                            + "" from "" + ctx.getChannel());
-                }
-                NettyServerCnxn cnxn = (NettyServerCnxn)ctx.getAttachment();
-                synchronized(cnxn) {
-                    processMessage(e, cnxn);
+                if (evt == NettyServerCnxn.AutoReadEvent.ENABLE) {
+                    LOG.debug(""Received AutoReadEvent.ENABLE"");
+                    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();
+                    // TODO(ilyam): Not sure if cnxn can be null here. It becomes null if channelInactive()
+                    // or exceptionCaught() trigger, but it's unclear to me if userEventTriggered() can run
+                    // after either of those. Check for null just to be safe ...
+                    if (cnxn != null) {
+                        cnxn.processQueuedBuffer();
+                    }
+                    ctx.channel().config().setAutoRead(true);
+                } else if (evt == NettyServerCnxn.AutoReadEvent.DISABLE) {
+                    LOG.debug(""Received AutoReadEvent.DISABLE"");
+                    ctx.channel().config().setAutoRead(false);
                 }
-            } catch(Exception ex) {
-                LOG.error(""Unexpected exception in receive"", ex);
-                throw ex;
+            } finally {
+                ReferenceCountUtil.release(evt);
             }
         }
 
-        private void processMessage(MessageEvent e, NettyServerCnxn cnxn) {
-            if (LOG.isDebugEnabled()) {
-                LOG.debug(Long.toHexString(cnxn.sessionId) + "" queuedBuffer: ""
-                        + cnxn.queuedBuffer);
-            }
-
-            if (e instanceof NettyServerCnxn.ResumeMessageEvent) {
-                LOG.debug(""Received ResumeMessageEvent"");
-                if (cnxn.queuedBuffer != null) {
-                    if (LOG.isTraceEnabled()) {
-                        LOG.trace(""processing queue ""
-                                + Long.toHexString(cnxn.sessionId)
-                                + "" queuedBuffer 0x""
-                                + ChannelBuffers.hexDump(cnxn.queuedBuffer));
-                    }
-                    cnxn.receiveMessage(cnxn.queuedBuffer);
-                    if (!cnxn.queuedBuffer.readable()) {
-                        LOG.debug(""Processed queue - no bytes remaining"");
-                        cnxn.queuedBuffer = null;
-                    } else {
-                        LOG.debug(""Processed queue - bytes remaining"");
-                    }
-                } else {
-                    LOG.debug(""queue empty"");
-                }
-                cnxn.channel.setReadable(true);
-            } else {
-                ChannelBuffer buf = (ChannelBuffer)e.getMessage();
+        @Override
+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+            try {
                 if (LOG.isTraceEnabled()) {
-                    LOG.trace(Long.toHexString(cnxn.sessionId)
-                            + "" buf 0x""
-                            + ChannelBuffers.hexDump(buf));
+                    LOG.trace(""message received called {}"", msg);
                 }
-                
-                if (cnxn.throttled) {
-                    LOG.debug(""Received message while throttled"");
-                    // we are throttled, so we need to queue
-                    if (cnxn.queuedBuffer == null) {
-                        LOG.debug(""allocating queue"");
-                        cnxn.queuedBuffer = dynamicBuffer(buf.readableBytes());
-                    }
-                    cnxn.queuedBuffer.writeBytes(buf);
-                    if (LOG.isTraceEnabled()) {
-                        LOG.trace(Long.toHexString(cnxn.sessionId)
-                                + "" queuedBuffer 0x""
-                                + ChannelBuffers.hexDump(cnxn.queuedBuffer));
+                try {
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug(""New message {} from {}"", msg, ctx.channel());
                     }
-                } else {
-                    LOG.debug(""not throttled"");
-                    if (cnxn.queuedBuffer != null) {
-                        if (LOG.isTraceEnabled()) {
-                            LOG.trace(Long.toHexString(cnxn.sessionId)
-                                    + "" queuedBuffer 0x""
-                                    + ChannelBuffers.hexDump(cnxn.queuedBuffer));
-                        }
-                        cnxn.queuedBuffer.writeBytes(buf);
-                        if (LOG.isTraceEnabled()) {
-                            LOG.trace(Long.toHexString(cnxn.sessionId)
-                                    + "" queuedBuffer 0x""
-                                    + ChannelBuffers.hexDump(cnxn.queuedBuffer));
-                        }
-
-                        cnxn.receiveMessage(cnxn.queuedBuffer);
-                        if (!cnxn.queuedBuffer.readable()) {
-                            LOG.debug(""Processed queue - no bytes remaining"");
-                            cnxn.queuedBuffer = null;
-                        } else {
-                            LOG.debug(""Processed queue - bytes remaining"");
-                        }
+                    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();
+                    if (cnxn == null) {
+                        LOG.error(""channelRead() on a closed or closing NettyServerCnxn"");
                     } else {
-                        cnxn.receiveMessage(buf);
-                        if (buf.readable()) {
-                            if (LOG.isTraceEnabled()) {
-                                LOG.trace(""Before copy "" + buf);
-                            }
-                            cnxn.queuedBuffer = dynamicBuffer(buf.readableBytes()); 
-                            cnxn.queuedBuffer.writeBytes(buf);
-                            if (LOG.isTraceEnabled()) {
-                                LOG.trace(""Copy is "" + cnxn.queuedBuffer);
-                                LOG.trace(Long.toHexString(cnxn.sessionId)
-                                        + "" queuedBuffer 0x""
-                                        + ChannelBuffers.hexDump(cnxn.queuedBuffer));
-                            }
-                        }
+                        cnxn.processMessage((ByteBuf) msg);
                     }
+                } catch (Exception ex) {
+                    LOG.error(""Unexpected exception in receive"", ex);
+                    throw ex;
                 }
+            } finally {
+                ReferenceCountUtil.release(msg);
             }
         }
 
         @Override
-        public void writeComplete(ChannelHandlerContext ctx,
-                WriteCompletionEvent e) throws Exception
-        {
+        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
             if (LOG.isTraceEnabled()) {
-                LOG.trace(""write complete "" + e);
+                promise.addListener((future) -> {
+                    LOG.trace(""write {}"",
+                            future.isSuccess() ? ""complete"" : ""failed"");
+                });
             }
+            super.write(ctx, msg, promise);
         }
 
-        private final class CertificateVerifier
-                implements ChannelFutureListener {
+        private final class CertificateVerifier implements GenericFutureListener<Future<Channel>> {","[{'comment': ""I found some issues with this code which I fixed internally but haven't upstreamed the fixes to master yet. So, as-is client TLS might not always work on 3.5. There are some cases where it doesn't work - I think specifically, anonymous TLS is not possible because line 226 assumes that the client always has certificates, which is not true for anonymous clients. Nothing to do as part of this PR, but I will look into upstreaming my fixes."", 'commenter': 'ivmaykov'}, {'comment': 'Big thanks for that! Looking forward to committing it.', 'commenter': 'anmolnar'}]"
753,zookeeper-server/pom.xml,"@@ -69,7 +69,7 @@
     </dependency>
     <dependency>
       <groupId>io.netty</groupId>
-      <artifactId>netty</artifactId>
+      <artifactId>netty-all</artifactId>","[{'comment': 'nit: you may want to consider only depending on the ""sub-artefacts"" you need. Like `netty-transport`, `netty-buffer` etc.', 'commenter': 'normanmaurer'}]"
753,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxnSocketNetty.java,"@@ -185,7 +218,9 @@ void cleanup() {
 
     @Override
     void close() {
-        channelFactory.releaseExternalResources();
+        if (!eventLoopGroup.isShuttingDown()) {","[{'comment': 'nit: there is no need for this... calling `shutdownGraceFully()` multiple times is just fine', 'commenter': 'normanmaurer'}]"
753,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxnSocketNetty.java,"@@ -262,18 +298,46 @@ private void addBack(Packet head) {
         }
     }
 
-    private void sendPkt(Packet p) {
+    /**
+     * Sends a packet to the remote peer and flushes the channel.
+     * @param p packet to send.
+     * @return a ChannelFuture that will complete when the write operation
+     *         succeeds or fails.
+     */
+    private ChannelFuture sendPktAndFlush(Packet p) {
+        return sendPkt(p, true);
+    }
+
+    /**
+     * Sends a packet to the remote peer but does not flush() the channel.
+     * @param p packet to send.
+     * @return a ChannelFuture that will complete when the write operation
+     *         succeeds or fails.
+     */
+    private ChannelFuture sendPktOnly(Packet p) {
+        return sendPkt(p, false);
+    }
+
+    private ChannelFuture sendPkt(Packet p, boolean doFlush) {
         // Assuming the packet will be sent out successfully. Because if it fails,
         // the channel will close and clean up queues.
         p.createBB();
         updateLastSend();
-        sentCount++;
-        channel.write(ChannelBuffers.wrappedBuffer(p.bb));
+        ChannelFuture result = channel.write(Unpooled.wrappedBuffer(p.bb));
+        result.addListener(f -> {
+            if (f.isSuccess()) {
+                sentCount.getAndIncrement();
+            }
+        });
+        if (doFlush) {
+            channel.flush();
+        }","[{'comment': 'nit: it is cheaper to call `channel.writeAndFlush(...)` compared to call `channel.write(...)` and `channel.flush()` so you may consider to refactor the code.', 'commenter': 'normanmaurer'}]"
753,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -43,36 +46,30 @@
 import org.apache.zookeeper.server.command.FourLetterCommands;
 import org.apache.zookeeper.server.command.NopCommand;
 import org.apache.zookeeper.server.command.SetTraceMaskCommand;
-import org.jboss.netty.buffer.ChannelBuffer;
-import org.jboss.netty.buffer.ChannelBuffers;
-import org.jboss.netty.channel.Channel;
-import org.jboss.netty.channel.ChannelFuture;
-import org.jboss.netty.channel.ChannelFutureListener;
-import org.jboss.netty.channel.MessageEvent;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 public class NettyServerCnxn extends ServerCnxn {
     private static final Logger LOG = LoggerFactory.getLogger(NettyServerCnxn.class);
-    Channel channel;
-    ChannelBuffer queuedBuffer;
-    volatile boolean throttled;
-    ByteBuffer bb;
-    ByteBuffer bbLen = ByteBuffer.allocate(4);
-    long sessionId;
-    int sessionTimeout;
-    AtomicLong outstandingCount = new AtomicLong();
-    Certificate[] clientChain;
-    volatile boolean closingChannel;
+    private final Channel channel;
+    private ByteBuf queuedBuffer;
+    private final AtomicBoolean throttled = new AtomicBoolean(false);
+    private ByteBuffer bb;
+    private final ByteBuffer bbLen = ByteBuffer.allocate(4);","[{'comment': 'nit: did you consider making this a direct buffer to reduce memory copies ?', 'commenter': 'normanmaurer'}]"
753,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -303,19 +277,126 @@ private boolean checkFourLetterWord(final Channel channel,
         }
     }
 
-    public void receiveMessage(ChannelBuffer message) {
+    /**
+     * Process incoming message. This should only be called from the event
+     * loop thread.
+     * @param buf the message bytes to process.
+     */
+    void processMessage(ByteBuf buf) {
+        assert channel.eventLoop().inEventLoop();
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""0x{} queuedBuffer: {}"",
+                    Long.toHexString(sessionId),
+                    queuedBuffer);
+        }
+
+        if (LOG.isTraceEnabled()) {
+            LOG.trace(""0x{} buf {}"",
+                    Long.toHexString(sessionId),
+                    ByteBufUtil.hexDump(buf));
+        }
+
+        if (throttled.get()) {
+            LOG.debug(""Received message while throttled"");
+            // we are throttled, so we need to queue
+            if (queuedBuffer == null) {
+                LOG.debug(""allocating queue"");
+                queuedBuffer = channel.alloc().buffer(buf.readableBytes());","[{'comment': 'Are you sure `readableBytes()` is a good choice here ? I think I would allocate a bit more to reduce the risk of the need to expand directly on the next call. ', 'commenter': 'normanmaurer'}, {'comment': 'Also depending on what you do you may want to consider using `CompositeByteBuf`.', 'commenter': 'normanmaurer'}]"
753,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -303,19 +277,126 @@ private boolean checkFourLetterWord(final Channel channel,
         }
     }
 
-    public void receiveMessage(ChannelBuffer message) {
+    /**
+     * Process incoming message. This should only be called from the event
+     * loop thread.
+     * @param buf the message bytes to process.
+     */
+    void processMessage(ByteBuf buf) {","[{'comment': 'Did not check in detail but you may want to add a comment to tell that the caller still is responsible for releasing the `buf` or if this is not the case you need to ensure you call `buf.release()`', 'commenter': 'normanmaurer'}]"
761,zookeeper-server/src/test/java/org/apache/zookeeper/test/ServerDuplicateTest.java,"@@ -0,0 +1,76 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.server.quorum.QuorumPeer;
+import org.junit.Test;
+
+import java.net.InetSocketAddress;
+
+public class ServerDuplicateTest extends ZKTestCase {
+/**
+ * You don't necessarily write an integration test like this via Reconfig functionality.","[{'comment': 'I think you added my comment by mistake. :)', 'commenter': 'anmolnar'}]"
761,zookeeper-server/src/test/java/org/apache/zookeeper/test/ServerDuplicateTest.java,"@@ -0,0 +1,76 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.server.quorum.QuorumPeer;
+import org.junit.Test;
+
+import java.net.InetSocketAddress;
+
+public class ServerDuplicateTest extends ZKTestCase {","[{'comment': 'These are unit tests of `QuorumServer` class. Please move them to `QuorumServerTest.java` file.', 'commenter': 'anmolnar'}]"
764,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/CommitProcessor.java,"@@ -18,8 +18,12 @@
 
 package org.apache.zookeeper.server.quorum;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import java.util.ArrayList;
 import java.util.LinkedList;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.LinkedBlockingQueue;","[{'comment': ""Why import these 4? I don't see this used in the class, but I might be missing something."", 'commenter': 'nkalmar'}, {'comment': 'I had conflicts, maybe they are present on master. Will remove', 'commenter': 'eolivelli'}, {'comment': '@nkalmar done', 'commenter': 'eolivelli'}]"
764,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -152,10 +152,10 @@ public static void setPreallocSize(long size) {
      * Setter for ServerStats to monitor fsync threshold exceed
      * @param serverStats used to update fsyncThresholdExceedCount
      */
-     @Override
-     public void setServerStats(ServerStats serverStats) {
-         this.serverStats = serverStats;
-     }
+    @Override
+    public synchronized void setServerStats(ServerStats serverStats) {","[{'comment': '@anmolnar this one can stay, it is innocuous', 'commenter': 'eolivelli'}]"
769,zookeeper-server/src/test/java/org/apache/zookeeper/server/BlueThrottleTest.java,"@@ -0,0 +1,132 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server;
+
+import org.apache.zookeeper.ZKTestCase;
+import org.junit.Assert;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class BlueThrottleTest extends ZKTestCase {
+    private static final Logger LOG = LoggerFactory.getLogger(BlueThrottleTest.class);
+
+    @Test
+    public void testThrottleDisabled() {
+        BlueThrottle throttler = new BlueThrottle();
+        Assert.assertTrue(""Throttle should be disabled by default"", throttler.checkLimit(1));
+    }
+
+    @Test
+    public void testThrottleWithoutRefill() {
+        BlueThrottle throttler = new BlueThrottle();
+        throttler.setMaxTokens(1);
+        throttler.setFillTime(2000);
+        Assert.assertTrue(""First request should be allowed"", throttler.checkLimit(1));
+        Assert.assertFalse(""Second request should be denied"", throttler.checkLimit(1));
+    }
+
+    @Test
+    public void testThrottleWithRefill() throws InterruptedException {
+        BlueThrottle throttler = new BlueThrottle();
+        throttler.setMaxTokens(1);
+        throttler.setFillTime(500);
+        Assert.assertTrue(""First request should be allowed"", throttler.checkLimit(1));
+        Assert.assertFalse(""Second request should be denied"", throttler.checkLimit(1));
+
+        //wait for the bucket to be refilled
+        Thread.sleep(750);
+        Assert.assertTrue(""Third request should be allowed since we've got a new token"", throttler.checkLimit(1));
+    }
+
+    @Test
+    public void testThrottleWithoutRandomDropping() throws InterruptedException {
+        int maxTokens = 10;
+        BlueThrottle throttler = new BlueThrottle();
+        throttler.setMaxTokens(maxTokens);
+        throttler.setFillCount(maxTokens);
+        throttler.setFillTime(1000);
+
+        for (int i=0;i<maxTokens;i++) {
+            throttler.checkLimit(1);
+        }
+        Assert.assertEquals(""All tokens should be used up by now"", throttler.getMaxTokens(), throttler.getDeficit());
+
+        Thread.sleep(110);
+        throttler.checkLimit(1);
+        Assert.assertFalse(""Dropping probability should still be zero"", throttler.getDropChance()>0);
+
+        //allow bucket to be refilled
+        Thread.sleep(1500);
+
+        for (int i=0;i<maxTokens;i++) {
+            Assert.assertTrue(""The first "" + maxTokens + "" requests should be allowed"", throttler.checkLimit(1));
+        }
+
+        for (int i=0;i<maxTokens;i++) {
+            Assert.assertFalse(""The latter "" + maxTokens + "" requests should be denied"", throttler.checkLimit(1));
+        }
+    }
+
+    @Test
+    public void testThrottleWithRandomDropping() throws InterruptedException {
+        int maxTokens = 10;
+        BlueThrottle throttler = new BlueThrottle();
+        throttler.setMaxTokens(maxTokens);
+        throttler.setFillCount(maxTokens);
+        throttler.setFillTime(1000);
+        throttler.setFreezeTime(100);
+        throttler.setDropIncrease(0.5);
+
+        for (int i=0;i<maxTokens;i++)
+            throttler.checkLimit(1);
+        Assert.assertEquals(""All tokens should be used up by now"", throttler.getMaxTokens(), throttler.getDeficit());
+
+        Thread.sleep(110);","[{'comment': 'Have you tried to run this tests multiple times? 100x or 1000x ... ?\r\nTests with `Thread.sleep` are usually a smell of flaky tests, especially in Apache infra.', 'commenter': 'anmolnar'}, {'comment': ""I just ran the test 1000 times and it failed once.  Yeah, the test is flaky. But I don't think it is because of the sleep. The fillTime and the freezeTime in the test are set to some unrealistic numbers so the test can tolerate some inaccuracy in timing.  The test failed because the random number generator for random dropping gave 10 numbers less than 0.5 in a row, an event of of probability EXP(0.5, 10). I'm going to use a mock random generator, which I think is good enough for this unit test. "", 'commenter': 'jhuan31'}]"
769,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -196,14 +199,50 @@ public ZooKeeperServer(FileTxnSnapLog txnLogFactory, int tickTime,
         setMinSessionTimeout(minSessionTimeout);
         setMaxSessionTimeout(maxSessionTimeout);
         listener = new ZooKeeperServerListenerImpl(this);
+
         readResponseCache = new ResponseCache();
+
+        connThrottle = new BlueThrottle();","[{'comment': ""This configuration setting block could be a little bit neater by following the existing pattern in this class: create static constants for the configuration option name and the default value.\r\n\r\nThe existing config setting `intBufferStartingSizeBytes` is set via static constructor which is not convenient here, but you could overload the constructor of `BlueThrottle` to override the default settings. In which case you don't need these setters at all."", 'commenter': 'anmolnar'}, {'comment': ""Agree. Those setter invocations in the constructor look ugly. Moved them out. But we still need the setters for the JMX interface. And since we are keeping setters, I'd prefer to use them in the unit tests instead of using a constructor with a long list of parameters, i.e, I prefer to explicitly set the refill time to 100 instead of setting the third parameter of the constructor to 100. "", 'commenter': 'jhuan31'}]"
769,zookeeper-server/src/test/java/org/apache/zookeeper/server/BlueThrottleTest.java,"@@ -0,0 +1,161 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server;
+
+import org.apache.zookeeper.ZKTestCase;
+import org.junit.Assert;
+import org.junit.Rule;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Random;
+
+public class BlueThrottleTest extends ZKTestCase {
+    private static final Logger LOG = LoggerFactory.getLogger(BlueThrottleTest.class);
+
+    class MockRandom extends Random {
+        int flag = 0;
+        BlueThrottle throttle;
+
+        public MockRandom(BlueThrottle bt) {
+            this.throttle = bt;
+        }
+
+        @Override
+        public double nextDouble() {
+            if (throttle.getDropChance() > 0) {
+                flag = 1 - flag;
+                return flag;
+            } else {
+                return 1;
+            }
+        }
+    }
+
+    class BlueThrottleWithMockRandom extends BlueThrottle {
+        public BlueThrottleWithMockRandom() {
+            super();
+            this.rng = new MockRandom(this);","[{'comment': 'You could have another overloaded constructor to inject custom random generator.', 'commenter': 'anmolnar'}, {'comment': 'done.', 'commenter': 'jhuan31'}]"
769,zookeeper-server/src/main/java/org/apache/zookeeper/server/BlueThrottle.java,"@@ -0,0 +1,268 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.util.Random;
+
+import org.apache.zookeeper.common.Time;
+
+/**
+ * Implements a token-bucket based rate limiting mechanism with optional
+ * probabilistic dropping inspired by the BLUE queue management algorithm [1].
+ *
+ * The throttle provides the {@link #checkLimit(int)} method which provides
+ * a binary yes/no decision.
+ *
+ * The core token bucket algorithm starts with an initial set of tokens based
+ * on the <code>maxTokens</code> setting. Tokens are dispensed each
+ * {@link #checkLimit(int)} call, which fails if there are not enough tokens to
+ * satisfy a given request.
+ *
+ * The token bucket refills over time, providing <code>fillCount</code> tokens
+ * every <code>fillTime</code> milliseconds, capping at <code>maxTokens</code>.
+ *
+ * This design allows the throttle to allow short bursts to pass, while still
+ * capping the total number of requests per time interval.
+ *
+ * One issue with a pure token bucket approach for something like request or
+ * connection throttling is that the wall clock arrival time of requests affects
+ * the probability of a request being allowed to pass or not. Under constant
+ * load this can lead to request starvation for requests that constantly arrive
+ * later than the majority.
+ *
+ * In an attempt to combat this, this throttle can also provide probabilistic
+ * dropping. This is enabled anytime <code>freezeTime</code> is set to a value
+ * other than <code>-1</code>.
+ *
+ * The probabilistic algorithm starts with an initial drop probability of 0, and
+ * adjusts this probability roughly every <code>freezeTime</code> milliseconds.
+ * The first request after <code>freezeTime</code>, the algorithm checks the
+ * token bucket. If the token bucket is empty, the drop probability is increased
+ * by <code>dropIncrease</code> up to a maximum of <code>1</code>. Otherwise, if
+ * the bucket has a token deficit less than <code>decreasePoint * maxTokens</code>,
+ * the probability is decreased by <code>dropDecrease</code>.
+ *
+ * Given a call to {@link #checkLimit(int)}, requests are first dropped randomly
+ * based on the current drop probability, and only surviving requests are then
+ * checked against the token bucket.
+ *
+ * When under constant load, the probabilistic algorithm will adapt to a drop
+ * frequency that should keep requests within the token limit. When load drops,
+ * the drop probability will decrease, eventually returning to zero if possible.
+ *
+ * [1] ""BLUE: A New Class of Active Queue Management Algorithms""
+ **/
+
+public class BlueThrottle {
+    private int maxTokens;
+    private int fillTime;
+    private int fillCount;
+    private int tokens;
+    private long lastTime;
+
+    private int freezeTime;
+    private long lastFreeze;
+    private double dropIncrease;
+    private double dropDecrease;
+    private double decreasePoint;
+    private double drop;
+
+    Random rng;
+
+    public static final String CONNECTION_THROTTLE_TOKENS = ""zookeeper.connection_throttle_tokens"";
+    public static final int DEFAULT_CONNECTION_THROTTLE_TOKENS;
+
+    public static final String CONNECTION_THROTTLE_FILL_TIME = ""zookeeper.connection_throttle_fill_time"";
+    public static final int DEFAULT_CONNECTION_THROTTLE_FILL_TIME;
+
+    public static final String CONNECTION_THROTTLE_FILL_COUNT = ""zookeeper.connection_throttle_fill_count"";
+    public static final int DEFAULT_CONNECTION_THROTTLE_FILL_COUNT;
+
+    public static final String CONNECTION_THROTTLE_FREEZE_TIME = ""zookeeper.connection_throttle_freeze_time"";
+    public static final int DEFAULT_CONNECTION_THROTTLE_FREEZE_TIME;
+
+    public static final String CONNECTION_THROTTLE_DROP_INCREASE = ""zookeeper.connection_throttle_drop_increase"";
+    public static final double DEFAULT_CONNECTION_THROTTLE_DROP_INCREASE;
+
+    public static final String CONNECTION_THROTTLE_DROP_DECREASE = ""zookeeper.connection_throttle_drop_decrease"";
+    public static final double DEFAULT_CONNECTION_THROTTLE_DROP_DECREASE;
+
+    public static final String CONNECTION_THROTTLE_DECREASE_RATIO = ""zookeeper.connection_throttle_decrease_ratio"";
+    public static final double DEFAULT_CONNECTION_THROTTLE_DECREASE_RATIO;
+
+
+    static {
+        DEFAULT_CONNECTION_THROTTLE_TOKENS = Integer.getInteger(CONNECTION_THROTTLE_TOKENS, 0);
+        DEFAULT_CONNECTION_THROTTLE_FILL_TIME = Integer.getInteger(CONNECTION_THROTTLE_FILL_TIME, 1);
+        DEFAULT_CONNECTION_THROTTLE_FILL_COUNT = Integer.getInteger(CONNECTION_THROTTLE_FILL_COUNT, 1);
+
+        DEFAULT_CONNECTION_THROTTLE_FREEZE_TIME = Integer.getInteger(CONNECTION_THROTTLE_FREEZE_TIME, -1);
+        DEFAULT_CONNECTION_THROTTLE_DROP_INCREASE = getDoubleProp(CONNECTION_THROTTLE_DROP_INCREASE, 0.02);
+        DEFAULT_CONNECTION_THROTTLE_DROP_DECREASE = getDoubleProp(CONNECTION_THROTTLE_DROP_DECREASE, 0.002);
+        DEFAULT_CONNECTION_THROTTLE_DECREASE_RATIO = getDoubleProp(CONNECTION_THROTTLE_DECREASE_RATIO, 0);
+    }
+
+    /* Varation of Integer.getInteger for real number properties */
+    private static double getDoubleProp(String name, double def) {
+        String val = System.getProperty(name);
+        if(val != null) {
+            return Double.parseDouble(val);
+        }
+        else {
+            return def;
+        }
+    }
+
+
+    public BlueThrottle() {
+        // Disable throttling by default (maxTokens = 0)
+        this.maxTokens = DEFAULT_CONNECTION_THROTTLE_TOKENS;
+        this.fillTime  = DEFAULT_CONNECTION_THROTTLE_FILL_TIME;
+        this.fillCount = DEFAULT_CONNECTION_THROTTLE_FILL_COUNT;
+        this.tokens = maxTokens;
+        this.lastTime = Time.currentElapsedTime();
+
+        // Disable BLUE throttling by default (freezeTime = -1)
+        this.freezeTime = DEFAULT_CONNECTION_THROTTLE_FREEZE_TIME;
+        this.lastFreeze = Time.currentElapsedTime();
+        this.dropIncrease = DEFAULT_CONNECTION_THROTTLE_DROP_INCREASE;
+        this.dropDecrease = DEFAULT_CONNECTION_THROTTLE_DROP_DECREASE;
+        this.decreasePoint = DEFAULT_CONNECTION_THROTTLE_DECREASE_RATIO;
+        this.drop = 0;
+
+        this.rng = new Random();
+    }
+
+    public synchronized void setMaxTokens(int max) {
+        int deficit = maxTokens - tokens;
+        maxTokens = max;
+        tokens = max - deficit;
+    }
+
+    public synchronized void setFillTime(int time) {
+        fillTime = time;
+    }
+
+    public synchronized void setFillCount(int count) {
+        fillCount = count;
+    }
+
+    public synchronized void setFreezeTime(int time) {
+        freezeTime = time;
+    }
+
+    public synchronized void setDropIncrease(double increase) {
+        dropIncrease = increase;
+    }
+
+    public synchronized void setDropDecrease(double decrease) {
+        dropDecrease = decrease;
+    }
+
+    public synchronized void setDecreasePoint(double ratio) {
+        decreasePoint = ratio;
+    }
+
+    public synchronized int getMaxTokens() {
+        return maxTokens;
+    }
+
+    public synchronized int getFillTime() {
+        return fillTime;
+    }
+
+    public synchronized int getFillCount() {
+        return fillCount;
+    }
+
+    public synchronized int getFreezeTime() {
+        return freezeTime;
+    }
+
+    public synchronized double getDropIncrease() {
+        return dropIncrease;
+    }
+
+    public synchronized double getDropDecrease() {
+        return dropDecrease;
+    }
+
+    public synchronized double getDecreasePoint() {
+        return decreasePoint;
+    }
+
+    public synchronized double getDropChance() {
+        return drop;
+    }
+
+    public synchronized int getDeficit() {
+        return maxTokens - tokens;
+    }
+
+    public synchronized boolean checkLimit(int need) {
+        // A maxTokens setting of zero disables throttling
+        if (maxTokens == 0)
+            return true;
+
+        long now = Time.currentElapsedTime();
+        long diff = now - lastTime;
+
+        if (diff > fillTime) {
+            int refill = (int)(diff * fillCount / fillTime);
+            tokens = Math.min(tokens + refill, maxTokens);
+            lastTime = now;
+        }
+
+        // A freeze time of -1 disables BLUE randomized throttling
+        if(freezeTime != -1) {
+            if(!checkBlue(now)) {
+                return false;
+            }
+        }
+
+        if (tokens < need) {
+            return false;
+        }
+
+        tokens -= need;
+        return true;
+    }
+
+    public synchronized boolean checkBlue(long now) {","[{'comment': 'IMO,  method `checkBlue ` should have a access level of `private` since it is only called inside this class.', 'commenter': 'sonymoon'}]"
770,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -873,6 +873,10 @@ public int getGlobalOutstandingLimit() {
         return limit;
     }
 
+    public static long getSnapSize() {
+        return Long.getLong(""zookeeper.snapSize"", 4294967296L); // 4GB by default","[{'comment': ""We should document this (probably in zookeeperAdmin.md).\r\n\r\nMaybe by default should be off with a special value like -1L? For backward compatibility reasons, but it doesn't really break anything... maybe just wait for a binding vote on this :)"", 'commenter': 'nkalmar'}, {'comment': ""Excellent point! I've extended the documentation to describe the new property. Let's leave it on by default and let the community decide if they want to modify that value."", 'commenter': 'enixon'}]"
770,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -625,16 +625,28 @@ property, when available, is noted below.
     reaches a runtime generated random value in the \[snapCount/2+1, snapCount]
     range.The default snapCount is 100,000.
 
+* *snapSize* :","[{'comment': 'I think name of this property should be consistent with `txnLogSizeLimitInKb`, because its purpose is similar.\r\nWhat do you think about `snapSizeLimitInKb`?', 'commenter': 'anmolnar'}, {'comment': ""Sounds good to me, I don't think we need to operate on the granularity of individual bytes here save in testing."", 'commenter': 'enixon'}]"
770,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -919,8 +919,9 @@ public int getGlobalOutstandingLimit() {
         return limit;
     }
 
-    public static long getSnapSize() {
-        return Long.getLong(""zookeeper.snapSize"", 4294967296L); // 4GB by default
+    public static long getSnapSizeInBytes() {
+        long size = Long.getLong(""zookeeper.snapSizeLimitInKb"", 4194304L); // 4GB by default
+        return size > 0 ? size * 1024 : size; // Convert to bytes","[{'comment': ""I don't think you need this check. Just return `size * 1024` ?"", 'commenter': 'anmolnar'}]"
776,src/assembly/jar.xml,"@@ -0,0 +1,65 @@
+<assembly xmlns=""http://maven.apache.org/ASSEMBLY/2.0.0""
+          xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+          xsi:schemaLocation=""http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd"">
+
+  <id>jar</id>","[{'comment': 'Why do we need this file?\r\nWe are splitting the project in sub modules, it is better to have one jar per module.\r\n\r\nI guess you are trying to reproduce the ant based build but it is not necessary to me.\r\n\r\nMaven has already its clear way of distributing the artifacts.\r\n\r\nOr maybe I am missing some part of the story', 'commenter': 'eolivelli'}, {'comment': 'Yes, that was the goal. Originally, we said we will reproduce ant build as much as possible. It has this fatjar in it.\r\n\r\nI will do some revision on this PR.', 'commenter': 'nkalmar'}]"
784,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -451,6 +458,9 @@ public void shutdown() {
     
     @Override
     public void start() {
+        if (listenBacklog > 0) {","[{'comment': ""It doesn't make any difference, but it would nice for this condition to be consistent with the NIO implementation.\r\ne.g. `listenBacklog != -1` or something similar"", 'commenter': 'anmolnar'}]"
784,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -997,6 +1006,15 @@ public void setMaxSessionTimeout(int max) {
         LOG.info(""maxSessionTimeout set to {}"", this.maxSessionTimeout);
     }
 
+    public int getClientPortListenBacklog() {
+        return listenBacklog;
+    }
+
+    public void setClientPortListenBacklog(int backlog) {
+        LOG.info(""clientPortListenBacklog set to "" + backlog);","[{'comment': 'nit: I would do the action first, than the log the fact it happened.', 'commenter': 'anmolnar'}]"
784,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServerConf.java,"@@ -60,6 +60,12 @@
      * The key in the map returned by {@link #toMap()} for the server ID.
      */
     public static final String KEY_SERVER_ID = ""server_id"";
+    /**
+     * The key in the map returned by {@link #toMap()} for the server socket
+     * listen backlog.
+     */
+    public static final String KEY_CLIENT_PORT_LISTEN_BACKLOG","[{'comment': 'How is this class related to `ServerConfig`?\r\nLooks like we have 2 different classes for the same purpose.', 'commenter': 'anmolnar'}, {'comment': ""To be honest, I really don't get it either :). I was really confused what the intention was in configuration object layering. For real installations, we seem to start from a QuorumPeerConf, but then pass this into ZooKeeperServer? Is QPC meant for quorums whereas ZKC would be relevant for just a single-server instance? Need to do more digging.."", 'commenter': 'joshelser'}, {'comment': ""Thanks for looking into. Not a big deal though, as long as your patch works properly, I don't want you to refactor the config layer here."", 'commenter': 'anmolnar'}]"
787,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -1510,6 +1511,11 @@ public void close() throws IOException {
      * the server. Thus, getXid() must be public.
      */
     synchronized public int getXid() {
+        // xid values of -4, -2, and -1 are special, see SendThread.readResponse","[{'comment': 'What about introducing constants for these special values ? (and replace in readResponse)\r\n', 'commenter': 'eolivelli'}, {'comment': 'Where do protocol level constants like that usually get put?', 'commenter': 'athanatos'}, {'comment': 'Also, that seems a bit intrusive for a patch I want to backport since it would also touch the server side.  I suppose I could add it as an additional commit and only backport the actual fix?', 'commenter': 'athanatos'}, {'comment': ""I am thinking about having constants only _locally_ to this file, this way it will be easier to understand the code and the patch wouldn't be so intrusive.\r\nIn the (hopefully near) future we will separate client size code from server side code so introducing new shared constants would be overkilling.\r\n\r\nI don't fell strong about having such constants, it is only a thought/suggestion.\r\n\r\ncc @anmolnar @lvfangmin @hanm "", 'commenter': 'eolivelli'}, {'comment': ""I'm inclined to keep the patch minimal since grepping for those identifiers wouldn't tell you where those packets get sent.  Also, the numerical values are useful to see here.  I don't feel strongly about it though."", 'commenter': 'athanatos'}, {'comment': ""no problem from my side, let's keep the patch simple"", 'commenter': 'eolivelli'}]"
787,zookeeper-server/src/test/java/org/apache/zookeeper/TestableZooKeeper.java,"@@ -35,6 +36,39 @@ public TestableZooKeeper(String host, int sessionTimeout,
             Watcher watcher) throws IOException {
         super(host, sessionTimeout, watcher);
     }
+
+    class TestableClientCnxn extends ClientCnxn {
+        TestableClientCnxn(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper,
+            ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket, boolean canBeReadOnly)
+                throws IOException {
+            super(chrootPath, hostProvider, sessionTimeout, zooKeeper, watcher,
+                clientCnxnSocket, 0, new byte[16], canBeReadOnly);
+        }
+
+        void setXid(int newXid) {
+            xid = newXid;
+        }
+
+        int checkXid() {
+            return xid;
+        }
+    }
+
+    protected ClientCnxn createConnection(String chrootPath,","[{'comment': 'what about overriding this method only in your new testcase?', 'commenter': 'eolivelli'}, {'comment': ""I figured that the xid manipulation methods might be generally useful.  Also, createClient test helper method explicitly creates a TestableZooKeeper, so I'd have to create another version of that, I think.  Doesn't seem worthwhile."", 'commenter': 'athanatos'}]"
787,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -1510,6 +1511,11 @@ public void close() throws IOException {
      * the server. Thus, getXid() must be public.
      */
     synchronized public int getXid() {
+        // xid values of -4, -2, and -1 are special, see SendThread.readResponse
+        // Skip from -5 to 1.","[{'comment': 'why are we allowing negative numbers at all? shouldn\'t we check for ""about to rollover"" prior to the increment and then reset to 1? It seems to me that that would be a whole lot easier to grok.', 'commenter': 'phunt'}, {'comment': ""A reasonable point.  Nothing I could find directly compares cxid values or will otherwise notice the MAX to MIN wrap, so I chose to use the full range.  I'll switch it."", 'commenter': 'athanatos'}, {'comment': 'Sounds good, thanks. Essentially negative cxid are essentially ""reserved"" this way.', 'commenter': 'phunt'}]"
787,zookeeper-server/src/test/java/org/apache/zookeeper/test/ClientTest.java,"@@ -868,4 +870,37 @@ public void testTryWithResources() throws Exception {
 
         Assert.assertFalse(zooKeeper.getState().isAlive());
     }
+
+    @Test
+    public void testCXidRollover() throws Exception {
+        TestableZooKeeper zk = null;
+        try {
+            zk = createClient();
+            zk.setXid(Integer.MAX_VALUE - 10);
+
+            zk.create(""/testnode"", """".getBytes(), Ids.OPEN_ACL_UNSAFE,
+                CreateMode.PERSISTENT);
+            for (int i = 0; i < 20; ++i) {
+                final CountDownLatch latch = new CountDownLatch(1);
+                final AtomicInteger rc = new AtomicInteger(0);
+                zk.setData(""/testnode"", """".getBytes(), -1,
+                    new AsyncCallback.StatCallback() {
+                        @Override
+                        public void processResult(int retcode, String path, Object ctx, Stat stat) {
+                            rc.set(retcode);
+                            latch.countDown();
+                        }
+                    }, null);
+                Assert.assertTrue(""setData should complete within 5s"",
+                    latch.await(5, TimeUnit.SECONDS));","[{'comment': ""this is generally an anti-pattern in the tests and leads to flakey tests. e.g. we can see on some test environments that are oversubscribed. I'd suggest something very large, e.g. 30 seconds or just using the session timeout."", 'commenter': 'phunt'}]"
789,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -364,57 +368,16 @@ public void updateCount(String lastPrefix, int diff) {
             return;
         }
         synchronized (node) {
+            // todo nixon?","[{'comment': 'Is this line to be removed?', 'commenter': 'eolivelli'}, {'comment': 'Good catch! I forgot to remove my ""read this"" marker.', 'commenter': 'enixon'}]"
795,build.xml,"@@ -973,8 +973,9 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle"">
       <chmod perm=""ugo+x"" type=""file"" parallel=""false"">
         <fileset dir=""${dist.dir}/bin""/>
         <fileset dir=""${dist.dir}/sbin""/>
-        <fileset dir=""${dist.dir}/src/zookeeper-contrib/"">
-          <include name=""*/bin/*"" />
+        <fileset dir=""${dist.dir}/contrib/"">
+          <include name=""**/*.sh"" />
+          <include name=""**/*.py"" />","[{'comment': ""Why not keeping 'bin' explicitly?"", 'commenter': 'eolivelli'}, {'comment': 'There is no ""bin"" folder anymore.', 'commenter': 'gzsombor'}]"
796,zookeeper-server/src/main/java/org/apache/zookeeper/server/watch/WatcherCleaner.java,"@@ -106,6 +107,7 @@ public void addDeadWatcher(int watcherBit) {
                 synchronized(processingCompletedEvent) {
                     processingCompletedEvent.wait(100);
                 }
+                ServerMetrics.ADD_DEAD_WATCHER_STALL_TIME.add(100);","[{'comment': 'Is 100 right?\r\nAre we supposing that the above *wait* always timeouts?\r\nIs It worth to track the exact time?', 'commenter': 'eolivelli'}, {'comment': ""Good catch @eolivelli . Accuracy of this metric is <100ms now, which we can improve by measuring the exact time elapsed. I'm not sure either if it's worth the extra logic."", 'commenter': 'anmolnar'}, {'comment': ""@anmolnar \r\n\r\n>  I'm not sure either if it's worth the extra logic\r\n\r\nme too"", 'commenter': 'eolivelli'}, {'comment': '@jhuan31 what do you think ?', 'commenter': 'eolivelli'}, {'comment': 'Nice catch, I think we should measure the exact time used when waiting for the signal, @jhuan31 can you help update this.', 'commenter': 'lvfangmin'}, {'comment': 'Sorry about the late response. I will fix it. Thank you @eolivelli  @anmolnar  @lvfangmin ', 'commenter': 'jhuan31'}]"
796,zookeeper-server/src/test/java/org/apache/zookeeper/server/watch/WatcherCleanerTest.java,"@@ -147,7 +147,7 @@ public void testDeadWatcherMetrics() {
 
         Map<String, Object> values = ServerMetrics.getAllValues();
 
-        Assert.assertEquals(""Adding dead watcher should be stalled twice"", 200L, values.get(""add_dead_watcher_stall_time""));
+        Assert.assertTrue(""Adding dead watcher should be stalled twice"", (Long)values.get(""add_dead_watcher_stall_time"") > 0L);","[{'comment': 'I believe you can use `greaterThan` matcher here.', 'commenter': 'anmolnar'}]"
800,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/CommitProcessorMetricsTest.java,"@@ -0,0 +1,483 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.server.*;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.nio.ByteBuffer;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.hamcrest.Matchers.*;
+
+public class CommitProcessorMetricsTest extends ZKTestCase {
+    protected static final Logger LOG =
+            LoggerFactory.getLogger(CommitProcessorMetricsTest.class);
+    CommitProcessor commitProcessor;
+    DummyFinalProcessor finalProcessor;
+
+    CountDownLatch requestScheduled = null;
+    CountDownLatch requestSeen = null;
+    CountDownLatch commitSeen = null;
+    CountDownLatch poolEmpytied = null;
+
+    @Before
+    public void setup() {
+        LOG.info(""setup"");
+        ServerMetrics.resetAll();
+    }
+
+    public void setupProcessors(int commitWorkers, int finalProcTime ) {
+        finalProcessor = new DummyFinalProcessor(finalProcTime);
+        commitProcessor = new TestCommitProcessor(finalProcessor, commitWorkers);
+        commitProcessor.start();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        LOG.info(""tearDown starting"");
+
+        commitProcessor.shutdown();
+        commitProcessor.join();
+    }
+
+    private class TestCommitProcessor extends CommitProcessor {
+        int numWorkerThreads;
+
+        public TestCommitProcessor(RequestProcessor finalProcessor, int numWorkerThreads) {
+            super(finalProcessor, ""1"", true, null);
+            this.numWorkerThreads = numWorkerThreads;
+        }
+
+        @Override
+        public void start() {
+            super.workerPool = new TestWorkerService(numWorkerThreads);
+            super.start();
+            // the sleep is needed to make sure that the thread is in the wait status
+            // and it won't start to process a request before the required countdown latch
+            // is set","[{'comment': 'Do you mean the `WorkerService`?\r\nWhy not add another latch to join the threads here?', 'commenter': 'anmolnar'}, {'comment': ""Sorry about the confusing comments. What I meant is that I want to enforce the order of things:\r\nprocessor thread gets into WAITING -> test thread sets requestProcessed latch -> test thread puts a request into the queue (which wakes up the processor thread in the WAITING state) and waits for the requestProcessed latch -> the processor thread wakes up and removes the request from the queue and processes it and opens the requestProcessed latch -> the test thread continues onto the next request\r\n\r\nIf the processor thread is not in the WAITING state when the (first) request is put in the queue, it would miss the wakeup signal and wouldn't process the request or open the latch and the test thread waiting on the latch would be stuck.\r\n\r\nI've changed the code. It still uses a sleep, but in a loop, and the exit condition is that the thread gets in WAITING. That should make the tests flaky-proof."", 'commenter': 'jhuan31'}]"
800,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/CommitProcessorMetricsTest.java,"@@ -0,0 +1,483 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.server.*;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.nio.ByteBuffer;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.hamcrest.Matchers.*;
+
+public class CommitProcessorMetricsTest extends ZKTestCase {
+    protected static final Logger LOG =
+            LoggerFactory.getLogger(CommitProcessorMetricsTest.class);
+    CommitProcessor commitProcessor;
+    DummyFinalProcessor finalProcessor;
+
+    CountDownLatch requestScheduled = null;
+    CountDownLatch requestSeen = null;
+    CountDownLatch commitSeen = null;
+    CountDownLatch poolEmpytied = null;
+
+    @Before
+    public void setup() {
+        LOG.info(""setup"");
+        ServerMetrics.resetAll();
+    }
+
+    public void setupProcessors(int commitWorkers, int finalProcTime ) {
+        finalProcessor = new DummyFinalProcessor(finalProcTime);
+        commitProcessor = new TestCommitProcessor(finalProcessor, commitWorkers);
+        commitProcessor.start();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        LOG.info(""tearDown starting"");
+
+        commitProcessor.shutdown();
+        commitProcessor.join();
+    }
+
+    private class TestCommitProcessor extends CommitProcessor {
+        int numWorkerThreads;
+
+        public TestCommitProcessor(RequestProcessor finalProcessor, int numWorkerThreads) {
+            super(finalProcessor, ""1"", true, null);
+            this.numWorkerThreads = numWorkerThreads;
+        }
+
+        @Override
+        public void start() {
+            super.workerPool = new TestWorkerService(numWorkerThreads);
+            super.start();
+            // the sleep is needed to make sure that the thread is in the wait status
+            // and it won't start to process a request before the required countdown latch
+            // is set
+            try {
+                Thread.sleep(50);
+            } catch (Exception e){
+
+            }
+            LOG.info(""numWorkerThreads in Test is {}"", numWorkerThreads);
+        }
+
+        @Override
+        protected void endOfIteration() {
+            if (requestSeen != null) {
+                requestSeen.countDown();
+            }
+        }
+
+        @Override
+        protected void waitForEmptyPool() throws InterruptedException {
+            if (commitSeen != null) {
+                commitSeen.countDown();
+            }
+            super.waitForEmptyPool();
+            if (poolEmpytied != null) {
+                poolEmpytied.countDown();
+            }
+        }
+    }
+
+    private class TestWorkerService extends WorkerService {
+        public TestWorkerService(int numWorkerThreads) {
+            super(""CommitProcWork"", numWorkerThreads, true);
+        }
+
+        @Override
+        public void schedule(WorkRequest workRequest, long id) {
+            super.schedule(workRequest, id);
+            if (requestScheduled != null) {
+                requestScheduled.countDown();
+            }
+        }
+    }
+
+    private class DummyFinalProcessor implements RequestProcessor {
+        int processTime;
+        public DummyFinalProcessor(int processTime) {
+            this.processTime = processTime;
+        }
+
+        @Override
+        public void processRequest(Request request) {
+            if (processTime > 0) {
+                try {
+                    if (commitSeen != null) {
+                        commitSeen.await(5, TimeUnit.SECONDS);
+                    }
+                    Thread.sleep(processTime);
+                } catch (Exception e) {
+
+                }
+            }
+        }
+
+        @Override
+        public void shutdown(){
+        }
+    }
+
+    private void checkMetrics(String metricName, long min, long max, double avg, long cnt, long sum) {
+        Map<String, Object> values = ServerMetrics.getAllValues();
+
+        Assert.assertEquals(""expected min is "" + min, min, values.get(""min_"" + metricName));
+        Assert.assertEquals(""expected max is: "" + max, max, values.get(""max_"" + metricName));
+        Assert.assertEquals(""expected avg is: "" + avg, avg, (Double)values.get(""avg_"" + metricName), 0.001);
+        Assert.assertEquals(""expected cnt is: "" + cnt, cnt, values.get(""cnt_"" + metricName));
+        Assert.assertEquals(""expected sum is: "" + sum, sum, values.get(""sum_"" + metricName));
+    }
+
+    private void checkTimeMetric(long actual, long lBoundrary, long hBoundrary) {
+        Assert.assertThat(actual, greaterThanOrEqualTo(lBoundrary));
+        Assert.assertThat(actual, lessThanOrEqualTo(hBoundrary));
+    }
+
+    private Request createReadRequest(long sessionId, int xid) {
+        return new Request(null, sessionId, xid, ZooDefs.OpCode.getData,
+                ByteBuffer.wrap(new byte[10]), null);
+    }
+
+    private Request createWriteRequest(long sessionId, int xid) {
+        return new Request(null, sessionId, xid, ZooDefs.OpCode.setData,
+                ByteBuffer.wrap(new byte[10]), null);
+    }
+
+    private void processRequestWithWait(Request request) throws Exception {
+        requestSeen = new CountDownLatch(1);
+        commitProcessor.processRequest(request);
+        requestSeen.await(5, TimeUnit.SECONDS);
+    }
+
+    private void commitWithWait(Request request) throws Exception {
+        requestSeen = new CountDownLatch(1);
+        commitProcessor.commit(request);
+        requestSeen.await(5, TimeUnit.SECONDS);
+    }
+
+    @Test
+    public void testRequestsInSessionQueue() throws Exception {
+        setupProcessors(0, 0);
+
+        Request req1 = createWriteRequest(1l, 1);
+        processRequestWithWait(req1);
+
+        checkMetrics(""requests_in_session_queue"", 1L, 1L, 1D, 1L, 1L);
+
+        //these two read requests will be stuck in the session queue because there is write in front of them
+        processRequestWithWait(createReadRequest(1L, 2));
+        processRequestWithWait(createReadRequest(1L,3));
+
+        checkMetrics(""requests_in_session_queue"", 1L, 3L, 2D, 3L, 6);
+
+        commitWithWait(req1);
+
+        checkMetrics(""requests_in_session_queue"", 1L, 3L, 2.25D, 4L, 9);
+    }
+
+    @Test
+    public void testWriteFinalProcTime() throws Exception {
+        setupProcessors(0, 1000);
+
+        Request req1 = createWriteRequest(1l, 2);
+        processRequestWithWait(req1);
+
+        //no request sent to next processor yet
+        Map<String, Object> values = ServerMetrics.getAllValues();
+        Assert.assertEquals(0L, values.get(""cnt_write_final_proc_time_ms""));
+
+        commitWithWait(req1);
+
+        values = ServerMetrics.getAllValues();
+        Assert.assertEquals(1L, values.get(""cnt_write_final_proc_time_ms""));
+        checkTimeMetric((long)values.get(""max_write_final_proc_time_ms""), 1000L, 2000L);
+    }
+
+    @Test
+    public void testReadFinalProcTime() throws Exception {
+        setupProcessors(0, 1000);
+
+        processRequestWithWait(createReadRequest(1L, 1));
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+        Assert.assertEquals(1L, values.get(""cnt_read_final_proc_time_ms""));
+        checkTimeMetric((long)values.get(""max_read_final_proc_time_ms""), 1000L, 2000L);
+    }
+
+    @Test
+    public void testCommitProcessTime() throws Exception {
+        setupProcessors(0, 0);
+        processRequestWithWait(createReadRequest(1L, 1));
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+        Assert.assertEquals(1L, values.get(""cnt_commit_process_time""));
+        checkTimeMetric((long)values.get(""max_commit_process_time""), 0L, 1000L);
+    }
+
+    @Test
+    public void testServerWriteCommittedTime() throws Exception {
+        setupProcessors(0, 0);
+        //a commit w/o pending request is a write from other servers
+        commitWithWait(createWriteRequest(1L, 1));
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+        Assert.assertEquals(1L, values.get(""cnt_server_write_committed_time_ms""));
+        checkTimeMetric((long)values.get(""max_server_write_committed_time_ms""), 0L, 1000L);
+    }
+
+    @Test
+    public void testLocalWriteCommittedTime() throws Exception {
+        setupProcessors(0, 0);
+        Request req1 = createWriteRequest(1l, 2);
+        processRequestWithWait(req1);
+        commitWithWait(req1);
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+
+        Assert.assertEquals(1L, values.get(""cnt_local_write_committed_time_ms""));
+        checkTimeMetric((long)values.get(""max_local_write_committed_time_ms""), 0l, 1000l);
+
+        Request req2 = createWriteRequest(1l, 2);
+        processRequestWithWait(req2);
+        //the second write will be stuck in the session queue for at least one second
+        //but the LOCAL_WRITE_COMMITTED_TIME is from when the commit is received
+        Thread.sleep(1000);","[{'comment': 'This is going to lead to flaky test. If you cannot join threads properly here, I suggest to rather remove this validation.', 'commenter': 'anmolnar'}, {'comment': ""En... I don't think this particular sleep will lead to flaky test. The purpose of this sleep is not to wait for some other thread to finish something. It just delays the recording of metrics so I can check that the processing time is about 1 second instead of 0."", 'commenter': 'jhuan31'}]"
800,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/CommitProcessorMetricsTest.java,"@@ -0,0 +1,483 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.server.*;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.nio.ByteBuffer;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.hamcrest.Matchers.*;
+
+public class CommitProcessorMetricsTest extends ZKTestCase {
+    protected static final Logger LOG =
+            LoggerFactory.getLogger(CommitProcessorMetricsTest.class);
+    CommitProcessor commitProcessor;
+    DummyFinalProcessor finalProcessor;
+
+    CountDownLatch requestScheduled = null;
+    CountDownLatch requestSeen = null;
+    CountDownLatch commitSeen = null;
+    CountDownLatch poolEmpytied = null;
+
+    @Before
+    public void setup() {
+        LOG.info(""setup"");
+        ServerMetrics.resetAll();
+    }
+
+    public void setupProcessors(int commitWorkers, int finalProcTime ) {
+        finalProcessor = new DummyFinalProcessor(finalProcTime);
+        commitProcessor = new TestCommitProcessor(finalProcessor, commitWorkers);
+        commitProcessor.start();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        LOG.info(""tearDown starting"");
+
+        commitProcessor.shutdown();
+        commitProcessor.join();
+    }
+
+    private class TestCommitProcessor extends CommitProcessor {
+        int numWorkerThreads;
+
+        public TestCommitProcessor(RequestProcessor finalProcessor, int numWorkerThreads) {
+            super(finalProcessor, ""1"", true, null);
+            this.numWorkerThreads = numWorkerThreads;
+        }
+
+        @Override
+        public void start() {
+            super.workerPool = new TestWorkerService(numWorkerThreads);
+            super.start();
+            // the sleep is needed to make sure that the thread is in the wait status
+            // and it won't start to process a request before the required countdown latch
+            // is set
+            try {
+                Thread.sleep(50);
+            } catch (Exception e){
+
+            }
+            LOG.info(""numWorkerThreads in Test is {}"", numWorkerThreads);
+        }
+
+        @Override
+        protected void endOfIteration() {
+            if (requestSeen != null) {
+                requestSeen.countDown();
+            }
+        }
+
+        @Override
+        protected void waitForEmptyPool() throws InterruptedException {
+            if (commitSeen != null) {
+                commitSeen.countDown();
+            }
+            super.waitForEmptyPool();
+            if (poolEmpytied != null) {
+                poolEmpytied.countDown();
+            }
+        }
+    }
+
+    private class TestWorkerService extends WorkerService {
+        public TestWorkerService(int numWorkerThreads) {
+            super(""CommitProcWork"", numWorkerThreads, true);
+        }
+
+        @Override
+        public void schedule(WorkRequest workRequest, long id) {
+            super.schedule(workRequest, id);
+            if (requestScheduled != null) {
+                requestScheduled.countDown();
+            }
+        }
+    }
+
+    private class DummyFinalProcessor implements RequestProcessor {
+        int processTime;
+        public DummyFinalProcessor(int processTime) {
+            this.processTime = processTime;
+        }
+
+        @Override
+        public void processRequest(Request request) {
+            if (processTime > 0) {
+                try {
+                    if (commitSeen != null) {
+                        commitSeen.await(5, TimeUnit.SECONDS);
+                    }
+                    Thread.sleep(processTime);
+                } catch (Exception e) {
+
+                }
+            }
+        }
+
+        @Override
+        public void shutdown(){
+        }
+    }
+
+    private void checkMetrics(String metricName, long min, long max, double avg, long cnt, long sum) {
+        Map<String, Object> values = ServerMetrics.getAllValues();
+
+        Assert.assertEquals(""expected min is "" + min, min, values.get(""min_"" + metricName));
+        Assert.assertEquals(""expected max is: "" + max, max, values.get(""max_"" + metricName));
+        Assert.assertEquals(""expected avg is: "" + avg, avg, (Double)values.get(""avg_"" + metricName), 0.001);
+        Assert.assertEquals(""expected cnt is: "" + cnt, cnt, values.get(""cnt_"" + metricName));
+        Assert.assertEquals(""expected sum is: "" + sum, sum, values.get(""sum_"" + metricName));
+    }
+
+    private void checkTimeMetric(long actual, long lBoundrary, long hBoundrary) {
+        Assert.assertThat(actual, greaterThanOrEqualTo(lBoundrary));
+        Assert.assertThat(actual, lessThanOrEqualTo(hBoundrary));
+    }
+
+    private Request createReadRequest(long sessionId, int xid) {
+        return new Request(null, sessionId, xid, ZooDefs.OpCode.getData,
+                ByteBuffer.wrap(new byte[10]), null);
+    }
+
+    private Request createWriteRequest(long sessionId, int xid) {
+        return new Request(null, sessionId, xid, ZooDefs.OpCode.setData,
+                ByteBuffer.wrap(new byte[10]), null);
+    }
+
+    private void processRequestWithWait(Request request) throws Exception {
+        requestSeen = new CountDownLatch(1);
+        commitProcessor.processRequest(request);
+        requestSeen.await(5, TimeUnit.SECONDS);
+    }
+
+    private void commitWithWait(Request request) throws Exception {
+        requestSeen = new CountDownLatch(1);
+        commitProcessor.commit(request);
+        requestSeen.await(5, TimeUnit.SECONDS);
+    }
+
+    @Test
+    public void testRequestsInSessionQueue() throws Exception {
+        setupProcessors(0, 0);
+
+        Request req1 = createWriteRequest(1l, 1);
+        processRequestWithWait(req1);
+
+        checkMetrics(""requests_in_session_queue"", 1L, 1L, 1D, 1L, 1L);
+
+        //these two read requests will be stuck in the session queue because there is write in front of them
+        processRequestWithWait(createReadRequest(1L, 2));
+        processRequestWithWait(createReadRequest(1L,3));
+
+        checkMetrics(""requests_in_session_queue"", 1L, 3L, 2D, 3L, 6);
+
+        commitWithWait(req1);
+
+        checkMetrics(""requests_in_session_queue"", 1L, 3L, 2.25D, 4L, 9);
+    }
+
+    @Test
+    public void testWriteFinalProcTime() throws Exception {
+        setupProcessors(0, 1000);
+
+        Request req1 = createWriteRequest(1l, 2);
+        processRequestWithWait(req1);
+
+        //no request sent to next processor yet
+        Map<String, Object> values = ServerMetrics.getAllValues();
+        Assert.assertEquals(0L, values.get(""cnt_write_final_proc_time_ms""));
+
+        commitWithWait(req1);
+
+        values = ServerMetrics.getAllValues();
+        Assert.assertEquals(1L, values.get(""cnt_write_final_proc_time_ms""));
+        checkTimeMetric((long)values.get(""max_write_final_proc_time_ms""), 1000L, 2000L);
+    }
+
+    @Test
+    public void testReadFinalProcTime() throws Exception {
+        setupProcessors(0, 1000);
+
+        processRequestWithWait(createReadRequest(1L, 1));
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+        Assert.assertEquals(1L, values.get(""cnt_read_final_proc_time_ms""));
+        checkTimeMetric((long)values.get(""max_read_final_proc_time_ms""), 1000L, 2000L);
+    }
+
+    @Test
+    public void testCommitProcessTime() throws Exception {
+        setupProcessors(0, 0);
+        processRequestWithWait(createReadRequest(1L, 1));
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+        Assert.assertEquals(1L, values.get(""cnt_commit_process_time""));
+        checkTimeMetric((long)values.get(""max_commit_process_time""), 0L, 1000L);
+    }
+
+    @Test
+    public void testServerWriteCommittedTime() throws Exception {
+        setupProcessors(0, 0);
+        //a commit w/o pending request is a write from other servers
+        commitWithWait(createWriteRequest(1L, 1));
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+        Assert.assertEquals(1L, values.get(""cnt_server_write_committed_time_ms""));
+        checkTimeMetric((long)values.get(""max_server_write_committed_time_ms""), 0L, 1000L);
+    }
+
+    @Test
+    public void testLocalWriteCommittedTime() throws Exception {
+        setupProcessors(0, 0);
+        Request req1 = createWriteRequest(1l, 2);
+        processRequestWithWait(req1);
+        commitWithWait(req1);
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+
+        Assert.assertEquals(1L, values.get(""cnt_local_write_committed_time_ms""));
+        checkTimeMetric((long)values.get(""max_local_write_committed_time_ms""), 0l, 1000l);
+
+        Request req2 = createWriteRequest(1l, 2);
+        processRequestWithWait(req2);
+        //the second write will be stuck in the session queue for at least one second
+        //but the LOCAL_WRITE_COMMITTED_TIME is from when the commit is received
+        Thread.sleep(1000);
+
+        commitWithWait(req2);
+
+        values = ServerMetrics.getAllValues();
+        Assert.assertEquals(2L, values.get(""cnt_local_write_committed_time_ms""));
+        checkTimeMetric((long)values.get(""max_local_write_committed_time_ms""), 0L, 1000L);
+    }
+
+
+    @Test
+    public void testWriteCommitProcTime() throws Exception {
+        setupProcessors(0, 0);
+        Request req1 = createWriteRequest(1l, 2);
+        processRequestWithWait(req1);
+        commitWithWait(req1);
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+
+        Assert.assertEquals(1L, values.get(""cnt_write_commitproc_time_ms""));
+        checkTimeMetric((long)values.get(""max_write_commitproc_time_ms""), 0l, 1000l);
+
+        Request req2 = createWriteRequest(1l, 2);
+        processRequestWithWait(req2);
+        //the second write will be stuck in the session queue for at least one second
+        Thread.sleep(1000);","[{'comment': 'Same here.', 'commenter': 'anmolnar'}, {'comment': 'same as above', 'commenter': 'jhuan31'}]"
800,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/CommitProcessorMetricsTest.java,"@@ -0,0 +1,483 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.server.*;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.nio.ByteBuffer;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.hamcrest.Matchers.*;
+
+public class CommitProcessorMetricsTest extends ZKTestCase {
+    protected static final Logger LOG =
+            LoggerFactory.getLogger(CommitProcessorMetricsTest.class);
+    CommitProcessor commitProcessor;
+    DummyFinalProcessor finalProcessor;
+
+    CountDownLatch requestScheduled = null;
+    CountDownLatch requestSeen = null;
+    CountDownLatch commitSeen = null;
+    CountDownLatch poolEmpytied = null;
+
+    @Before
+    public void setup() {
+        LOG.info(""setup"");
+        ServerMetrics.resetAll();
+    }
+
+    public void setupProcessors(int commitWorkers, int finalProcTime ) {
+        finalProcessor = new DummyFinalProcessor(finalProcTime);
+        commitProcessor = new TestCommitProcessor(finalProcessor, commitWorkers);
+        commitProcessor.start();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        LOG.info(""tearDown starting"");
+
+        commitProcessor.shutdown();
+        commitProcessor.join();
+    }
+
+    private class TestCommitProcessor extends CommitProcessor {
+        int numWorkerThreads;
+
+        public TestCommitProcessor(RequestProcessor finalProcessor, int numWorkerThreads) {
+            super(finalProcessor, ""1"", true, null);
+            this.numWorkerThreads = numWorkerThreads;
+        }
+
+        @Override
+        public void start() {
+            super.workerPool = new TestWorkerService(numWorkerThreads);
+            super.start();
+            // the sleep is needed to make sure that the thread is in the wait status
+            // and it won't start to process a request before the required countdown latch
+            // is set
+            try {
+                Thread.sleep(50);
+            } catch (Exception e){
+
+            }
+            LOG.info(""numWorkerThreads in Test is {}"", numWorkerThreads);
+        }
+
+        @Override
+        protected void endOfIteration() {
+            if (requestSeen != null) {
+                requestSeen.countDown();
+            }
+        }
+
+        @Override
+        protected void waitForEmptyPool() throws InterruptedException {
+            if (commitSeen != null) {
+                commitSeen.countDown();
+            }
+            super.waitForEmptyPool();
+            if (poolEmpytied != null) {
+                poolEmpytied.countDown();
+            }
+        }
+    }
+
+    private class TestWorkerService extends WorkerService {
+        public TestWorkerService(int numWorkerThreads) {
+            super(""CommitProcWork"", numWorkerThreads, true);
+        }
+
+        @Override
+        public void schedule(WorkRequest workRequest, long id) {
+            super.schedule(workRequest, id);
+            if (requestScheduled != null) {
+                requestScheduled.countDown();
+            }
+        }
+    }
+
+    private class DummyFinalProcessor implements RequestProcessor {
+        int processTime;
+        public DummyFinalProcessor(int processTime) {
+            this.processTime = processTime;
+        }
+
+        @Override
+        public void processRequest(Request request) {
+            if (processTime > 0) {
+                try {
+                    if (commitSeen != null) {
+                        commitSeen.await(5, TimeUnit.SECONDS);
+                    }
+                    Thread.sleep(processTime);
+                } catch (Exception e) {
+
+                }
+            }
+        }
+
+        @Override
+        public void shutdown(){
+        }
+    }
+
+    private void checkMetrics(String metricName, long min, long max, double avg, long cnt, long sum) {
+        Map<String, Object> values = ServerMetrics.getAllValues();
+
+        Assert.assertEquals(""expected min is "" + min, min, values.get(""min_"" + metricName));
+        Assert.assertEquals(""expected max is: "" + max, max, values.get(""max_"" + metricName));
+        Assert.assertEquals(""expected avg is: "" + avg, avg, (Double)values.get(""avg_"" + metricName), 0.001);
+        Assert.assertEquals(""expected cnt is: "" + cnt, cnt, values.get(""cnt_"" + metricName));
+        Assert.assertEquals(""expected sum is: "" + sum, sum, values.get(""sum_"" + metricName));
+    }
+
+    private void checkTimeMetric(long actual, long lBoundrary, long hBoundrary) {
+        Assert.assertThat(actual, greaterThanOrEqualTo(lBoundrary));
+        Assert.assertThat(actual, lessThanOrEqualTo(hBoundrary));
+    }
+
+    private Request createReadRequest(long sessionId, int xid) {
+        return new Request(null, sessionId, xid, ZooDefs.OpCode.getData,
+                ByteBuffer.wrap(new byte[10]), null);
+    }
+
+    private Request createWriteRequest(long sessionId, int xid) {
+        return new Request(null, sessionId, xid, ZooDefs.OpCode.setData,
+                ByteBuffer.wrap(new byte[10]), null);
+    }
+
+    private void processRequestWithWait(Request request) throws Exception {
+        requestSeen = new CountDownLatch(1);
+        commitProcessor.processRequest(request);
+        requestSeen.await(5, TimeUnit.SECONDS);
+    }
+
+    private void commitWithWait(Request request) throws Exception {
+        requestSeen = new CountDownLatch(1);
+        commitProcessor.commit(request);
+        requestSeen.await(5, TimeUnit.SECONDS);
+    }
+
+    @Test
+    public void testRequestsInSessionQueue() throws Exception {
+        setupProcessors(0, 0);
+
+        Request req1 = createWriteRequest(1l, 1);
+        processRequestWithWait(req1);
+
+        checkMetrics(""requests_in_session_queue"", 1L, 1L, 1D, 1L, 1L);
+
+        //these two read requests will be stuck in the session queue because there is write in front of them
+        processRequestWithWait(createReadRequest(1L, 2));
+        processRequestWithWait(createReadRequest(1L,3));
+
+        checkMetrics(""requests_in_session_queue"", 1L, 3L, 2D, 3L, 6);
+
+        commitWithWait(req1);
+
+        checkMetrics(""requests_in_session_queue"", 1L, 3L, 2.25D, 4L, 9);
+    }
+
+    @Test
+    public void testWriteFinalProcTime() throws Exception {
+        setupProcessors(0, 1000);
+
+        Request req1 = createWriteRequest(1l, 2);
+        processRequestWithWait(req1);
+
+        //no request sent to next processor yet
+        Map<String, Object> values = ServerMetrics.getAllValues();
+        Assert.assertEquals(0L, values.get(""cnt_write_final_proc_time_ms""));
+
+        commitWithWait(req1);
+
+        values = ServerMetrics.getAllValues();
+        Assert.assertEquals(1L, values.get(""cnt_write_final_proc_time_ms""));
+        checkTimeMetric((long)values.get(""max_write_final_proc_time_ms""), 1000L, 2000L);
+    }
+
+    @Test
+    public void testReadFinalProcTime() throws Exception {
+        setupProcessors(0, 1000);
+
+        processRequestWithWait(createReadRequest(1L, 1));
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+        Assert.assertEquals(1L, values.get(""cnt_read_final_proc_time_ms""));
+        checkTimeMetric((long)values.get(""max_read_final_proc_time_ms""), 1000L, 2000L);
+    }
+
+    @Test
+    public void testCommitProcessTime() throws Exception {
+        setupProcessors(0, 0);
+        processRequestWithWait(createReadRequest(1L, 1));
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+        Assert.assertEquals(1L, values.get(""cnt_commit_process_time""));
+        checkTimeMetric((long)values.get(""max_commit_process_time""), 0L, 1000L);
+    }
+
+    @Test
+    public void testServerWriteCommittedTime() throws Exception {
+        setupProcessors(0, 0);
+        //a commit w/o pending request is a write from other servers
+        commitWithWait(createWriteRequest(1L, 1));
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+        Assert.assertEquals(1L, values.get(""cnt_server_write_committed_time_ms""));
+        checkTimeMetric((long)values.get(""max_server_write_committed_time_ms""), 0L, 1000L);
+    }
+
+    @Test
+    public void testLocalWriteCommittedTime() throws Exception {
+        setupProcessors(0, 0);
+        Request req1 = createWriteRequest(1l, 2);
+        processRequestWithWait(req1);
+        commitWithWait(req1);
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+
+        Assert.assertEquals(1L, values.get(""cnt_local_write_committed_time_ms""));
+        checkTimeMetric((long)values.get(""max_local_write_committed_time_ms""), 0l, 1000l);
+
+        Request req2 = createWriteRequest(1l, 2);
+        processRequestWithWait(req2);
+        //the second write will be stuck in the session queue for at least one second
+        //but the LOCAL_WRITE_COMMITTED_TIME is from when the commit is received
+        Thread.sleep(1000);
+
+        commitWithWait(req2);
+
+        values = ServerMetrics.getAllValues();
+        Assert.assertEquals(2L, values.get(""cnt_local_write_committed_time_ms""));
+        checkTimeMetric((long)values.get(""max_local_write_committed_time_ms""), 0L, 1000L);
+    }
+
+
+    @Test
+    public void testWriteCommitProcTime() throws Exception {
+        setupProcessors(0, 0);
+        Request req1 = createWriteRequest(1l, 2);
+        processRequestWithWait(req1);
+        commitWithWait(req1);
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+
+        Assert.assertEquals(1L, values.get(""cnt_write_commitproc_time_ms""));
+        checkTimeMetric((long)values.get(""max_write_commitproc_time_ms""), 0l, 1000l);
+
+        Request req2 = createWriteRequest(1l, 2);
+        processRequestWithWait(req2);
+        //the second write will be stuck in the session queue for at least one second
+        Thread.sleep(1000);
+
+        commitWithWait(req2);
+
+        values = ServerMetrics.getAllValues();
+        Assert.assertEquals(2L, values.get(""cnt_write_commitproc_time_ms""));
+        checkTimeMetric((long)values.get(""max_write_commitproc_time_ms""), 1000L, 2000L);
+    }
+
+
+    @Test
+    public void testReadCommitProcTime() throws Exception {
+        setupProcessors(0, 0);
+        processRequestWithWait(createReadRequest(1l, 1));
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+
+        Assert.assertEquals(1L, values.get(""cnt_read_commitproc_time_ms""));
+        checkTimeMetric((long)values.get(""max_read_commitproc_time_ms""), 0l, 1000l);
+
+        Request req1 = createWriteRequest(1l, 2);
+        processRequestWithWait(req1);
+        processRequestWithWait(createReadRequest(1l, 3));
+        //the second read will be stuck in the session queue for at least one second
+        Thread.sleep(1000);","[{'comment': 'and here.', 'commenter': 'anmolnar'}, {'comment': 'same as above', 'commenter': 'jhuan31'}]"
801,bin/.gitattributes,"@@ -0,0 +1 @@
+*.sh eol=lf","[{'comment': 'I think we should not have `lf` here, but `auto`.\r\nWe still support windows to build ZooKeeper, we should be able to edit shell files there too.', 'commenter': 'tamaashu'}, {'comment': ""I don't think that's the issue here, but when I rechecked today, the line endings in the archive seem to match the respective OS's conventions. Probably the issue is gone, nobody else complained anyway."", 'commenter': 'ArneBachmann'}]"
809,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxnSocketNetty.java,"@@ -82,7 +84,7 @@
 
     ClientCnxnSocketNetty(ZKClientConfig clientConfig) throws IOException {
         this.clientConfig = clientConfig;
-        eventLoopGroup = NettyUtils.newNioOrEpollEventLoopGroup();
+        eventLoopGroup = NettyUtils.newNioOrEpollEventLoopGroup(1 /* nThreads */);","[{'comment': 'What about adding a comment and explain the reason of this magic number?', 'commenter': 'eolivelli'}, {'comment': 'Also I wonder if you maybe want to allow configure this... Seems like there is a config object passed around anyway. ', 'commenter': 'normanmaurer'}, {'comment': ""@normanmaurer I think it's overkill, the client only has 1 socket so why would we need more than 1 thread?"", 'commenter': 'ivmaykov'}, {'comment': 'Ah ok ... i thought you may create multiple connections', 'commenter': 'normanmaurer'}, {'comment': 'Each connection would have its own `ClientCnxnSocketNetty` instance.', 'commenter': 'ivmaykov'}, {'comment': 'got it... You could consider sharing the `EventLoopGroup` between those if this is feasible. But again this is just an optimisation and I am not sure if this is easily archiveable ', 'commenter': 'normanmaurer'}, {'comment': 'Probably not worth the trouble. I suspect that by far the common case in a client is connecting to a single ZK ensemble (per client process), so this optimization would not buy us much and would introduce additional complexity.', 'commenter': 'ivmaykov'}, {'comment': '@ivmaykov yeah sounds like this not justify the complexity', 'commenter': 'normanmaurer'}]"
809,zookeeper-server/src/main/java/org/apache/zookeeper/common/NettyUtils.java,"@@ -73,4 +103,53 @@ public static EventLoopGroup newNioOrEpollEventLoopGroup() {
             return NioServerSocketChannel.class;
         }
     }
+
+    private static final int DEFAULT_INET_ADDRESS_COUNT = 1;","[{'comment': 'Nit: move constants to the beginning of the class?', 'commenter': 'eolivelli'}]"
809,zookeeper-server/src/main/java/org/apache/zookeeper/common/NettyUtils.java,"@@ -73,4 +103,53 @@ public static EventLoopGroup newNioOrEpollEventLoopGroup() {
             return NioServerSocketChannel.class;
         }
     }
+
+    private static final int DEFAULT_INET_ADDRESS_COUNT = 1;
+
+    /**
+     * Attempts to detect and return the number of local network addresses that could be
+     * used by a client to reach this server. This means we exclude the following address types:
+     * <ul>
+     *     <li>Multicast addresses. Zookeeper server sockets use TCP, thus cannot bind to a multicast address.</li>
+     *     <li>Link-local addresses. Routers don't forward traffic sent to a link-local address, so
+     *     any realistic server deployment would not have clients using these.</li>
+     *     <li>Loopback addresses. These are typically only used for testing.</li>
+     * </ul>
+     * Any remaining addresses are counted, and the total count is returned. This number is
+     * used to configure the number of threads for the ""boss"" event loop group, to make sure we have
+     * enough threads for each address in case the server is configured to listen on
+     * all available addresses.
+     * If listing the network interfaces fails, this method will return 1.
+     *
+     * @return the number of client-reachable local network addresses found, or
+     * 1 if listing the network interfaces fails.
+     */
+    public static int getClientReachableLocalInetAddressCount() {
+        try {
+            Set<InetAddress> validInetAddresses = new HashSet<>();
+            Enumeration<NetworkInterface> allNetworkInterfaces = NetworkInterface.getNetworkInterfaces();
+            for (NetworkInterface networkInterface : Collections.list(allNetworkInterfaces)) {
+                for (InetAddress inetAddress : Collections.list(networkInterface.getInetAddresses())) {
+                    if (inetAddress.isLinkLocalAddress()) {
+                        continue;
+                    }
+                    if (inetAddress.isMulticastAddress()) {
+                        continue;","[{'comment': ""If debug...log 'Ignoring inetAddress because...'"", 'commenter': 'eolivelli'}]"
809,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -203,13 +203,15 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
             }
         }
 
+        // Use a single listener instance to reduce GC
+        private final GenericFutureListener<Future<Void>> onWriteCompletedListener = (f) -> {
+            LOG.trace(""write {}"", f.isSuccess() ? ""complete"" : ""failed"");","[{'comment': 'if log.isTraceEnabled...', 'commenter': 'eolivelli'}]"
818,zookeeper-contrib/zookeeper-contrib-zooinspector/build.xml,"@@ -125,22 +125,18 @@
 
 	<target name=""package"" depends=""jar, zookeeperbuildcontrib.package"" unless=""skip.contrib"">
 
-		<copy file=""${basedir}/build.xml"" todir=""${dist.dir}/contrib/${name}"" />
+		<copy file=""${basedir}/build.xml"" todir=""${dist.dir}/zookeeper-contrib/zookeeper-contrib-${name}"" />
 
-		<mkdir dir=""${dist.dir}/contrib/${name}/src"" />
-		<copy todir=""${dist.dir}/contrib/${name}/src"">
+		<mkdir dir=""${dist.dir}/zookeeper-contrib/zookeeper-contrib-${name}/src"" />
+		<copy todir=""${dist.dir}/zookeeper-contrib/zookeeper-contrib-${name}/src"">
 			<fileset dir=""${basedir}/src"" />
 		</copy>
-		<mkdir dir=""${dist.dir}/contrib/${name}/licences"" />
-		<copy todir=""${dist.dir}/contrib/${name}/licences"">
+		<mkdir dir=""${dist.dir}/zookeeper-contrib/zookeeper-contrib-${name}/licences"" />
+		<copy todir=""${dist.dir}/zookeeper-contrib/zookeeper-contrib-${name}/licences"">
 			<fileset dir=""${basedir}/licences"" />
 		</copy>
-		<mkdir dir=""${dist.dir}/contrib/${name}/icons"" />
-		<copy todir=""${dist.dir}/contrib/${name}/icons"">
-			<fileset dir=""${basedir}/src/main/resources/icons"" />
-		</copy>
-		<mkdir dir=""${dist.dir}/contrib/${name}/config"" />
-		<copy todir=""${dist.dir}/contrib/${name}/config"">
+		<mkdir dir=""${dist.dir}/zookeeper-contrib/zookeeper-contrib-${name}/config"" />
+		<copy todir=""${dist.dir}/zookeeper-contrib/zookeeper-contrib-${name}/config"">
 			<fileset dir=""${basedir}/src/main/resources"">
 				<include name=""defaultConnectionSettings.cfg"" />
 				<include name=""defaultNodeViewers.cfg"" />","[{'comment': 'Please modify the 2 copy tasks at the bottom of this file:\r\n<copy todir=""${dist.dir}/contrib/${name}/lib"">\r\nShould be:\r\n${dist.dir}/zookeeper-contrib/zookeeper-contrib-${name}/lib', 'commenter': 'nkalmar'}]"
819,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -192,14 +192,16 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
             }
         }
 
-        @Override
-        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+        // Use a single listener instance to reduce GC
+        private final GenericFutureListener<Future<Void>> onWriteCompletedListener = (f) -> {
             if (LOG.isTraceEnabled()) {
-                promise.addListener((future) -> {
-                    LOG.trace(""write {}"",
-                            future.isSuccess() ? ""complete"" : ""failed"");
-                });
+                LOG.trace(""write {}"", f.isSuccess() ? ""complete"" : ""failed"");
             }
+        };
+
+        @Override
+        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+            promise.addListener(onWriteCompletedListener);","[{'comment': 'What about this:\r\n```\r\nif (LOG.isTraceEnabled()) {\r\n   promise.addListener(onWriteCompletedListener);\r\n}\r\n```', 'commenter': 'eolivelli'}, {'comment': 'I had this code originally and @eolivelli asked me to change it to do the `if (LOG.isTraceEnabled())` check inside the listener. I guess I can do both. Will fix this backport and will open a new PR against master.', 'commenter': 'ivmaykov'}, {'comment': '@ivmaykov  I am really sorry. \r\nNow I remember it should have been the first time we discussed about adding isTraceEnabled.\r\n\r\nthank you very much', 'commenter': 'eolivelli'}, {'comment': ""@eolivelli let's merge this PR as-is. I've created a new PR to fix the issue, which should apply cleanly to both master and branch-3.5 once this PR lands on branch-3.5: #820"", 'commenter': 'ivmaykov'}]"
819,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -192,14 +192,16 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
             }
         }
 
-        @Override
-        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+        // Use a single listener instance to reduce GC
+        private final GenericFutureListener<Future<Void>> onWriteCompletedListener = (f) -> {","[{'comment': 'maybe we should call this ""writeCompletedTracer"" or something like that', 'commenter': 'eolivelli'}]"
821,build.xml,"@@ -1010,7 +1013,6 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
           <include name=""zookeeper-server/**""/>
           <include name=""zookeeper-it/**""/>
         </fileset>
-        <fileset file=""${java.server.resources.dir}/pom.template""/>","[{'comment': ""this is for the bin-package target, you'll also need a new copy task here."", 'commenter': 'nkalmar'}, {'comment': 'Fixed.', 'commenter': 'anmolnar'}]"
823,zookeeper-server/src/main/java/org/apache/zookeeper/cli/SyncCommand.java,"@@ -55,14 +57,18 @@ public CliCommand parse(String[] cmdArgs) throws CliParseException {
     @Override
     public boolean exec() throws CliException {
         String path = args[1];
+        CountDownLatch latch = new CountDownLatch(1);
+        final int[] resultCode = new int[1];
         try {
             zk.sync(path, new AsyncCallback.VoidCallback() {
-
                 public void processResult(int rc, String path, Object ctx) {
-                    out.println(""Sync returned "" + rc);
+                    resultCode[0] = rc;
+                    latch.countDown();
                 }
             }, null);
-        } catch (IllegalArgumentException ex) {
+            latch.await();","[{'comment': ""Wouldn't it be safer to wait for some reasonable amount of time (30s) rather than waiting indefinitely?"", 'commenter': 'anmolnar'}, {'comment': 'Maybe it can be a parameter with a default of 30secs', 'commenter': 'eolivelli'}]"
823,zookeeper-server/src/main/java/org/apache/zookeeper/cli/SyncCommand.java,"@@ -55,14 +57,18 @@ public CliCommand parse(String[] cmdArgs) throws CliParseException {
     @Override
     public boolean exec() throws CliException {
         String path = args[1];
+        CountDownLatch latch = new CountDownLatch(1);
+        final int[] resultCode = new int[1];
         try {
             zk.sync(path, new AsyncCallback.VoidCallback() {
-
                 public void processResult(int rc, String path, Object ctx) {
-                    out.println(""Sync returned "" + rc);
+                    resultCode[0] = rc;
+                    latch.countDown();
                 }
             }, null);
-        } catch (IllegalArgumentException ex) {
+            latch.await();
+            out.println(""Sync returned "" + resultCode[0]);
+        } catch (IllegalArgumentException | InterruptedException ex) {","[{'comment': 'Do you need to catch `InterruptedException` here?', 'commenter': 'anmolnar'}, {'comment': '`latch.await` needs this, my sweet IDEA help me do it.', 'commenter': 'maoling'}, {'comment': ""I don't think it's handled properly here. You basically swallowing and hiding it inside a `MalformedPathException` which is wrong."", 'commenter': 'anmolnar'}]"
823,zookeeper-server/src/main/java/org/apache/zookeeper/cli/SyncCommand.java,"@@ -55,14 +57,18 @@ public CliCommand parse(String[] cmdArgs) throws CliParseException {
     @Override
     public boolean exec() throws CliException {
         String path = args[1];
+        CountDownLatch latch = new CountDownLatch(1);","[{'comment': 'What about a more modern CompletableFuture?', 'commenter': 'eolivelli'}, {'comment': ""Thanks for mentioning this good option:`CompletableFuture`,but for issue,IMO,we don't need to kill a chicken with the sword：D"", 'commenter': 'maoling'}, {'comment': ""`CompletableFuture` has specifically been designed for scenarios like this. As far as I'm concerned. Let me check."", 'commenter': 'anmolnar'}, {'comment': 'How about this?\r\n\r\n```java\r\n    @Override\r\n    public boolean exec() throws CliException {\r\n        String path = args[1];\r\n        CompletableFuture<Integer> cf = new CompletableFuture<>();\r\n\r\n        try {\r\n            zk.sync(path, new AsyncCallback.VoidCallback() {\r\n                public void processResult(int rc, String path, Object ctx) {\r\n                    cf.complete(rc);\r\n                }\r\n            }, null);\r\n\r\n            try {\r\n                int resultCode = cf.get(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\r\n                out.println(""Sync returned "" + resultCode);\r\n            } catch (TimeoutException ex) {\r\n                out.println(""Sync is timeout within "" +  CONNECTION_TIMEOUT + "" ms"");\r\n            }\r\n        } catch (IllegalArgumentException | InterruptedException | ExecutionException ex) {\r\n            throw new MalformedPathException(ex.getMessage());\r\n        }\r\n\r\n        return false;\r\n    }\r\n```', 'commenter': 'anmolnar'}, {'comment': ""@anmolnar  Great work. you are so sweet!  it's very elegant especially when we want to transfer the result value.\r\nCc:Thanks @eolivelli  for mentioning this good option:`CompletableFuture` again."", 'commenter': 'maoling'}]"
823,zookeeper-server/src/main/java/org/apache/zookeeper/cli/SyncCommand.java,"@@ -55,14 +57,18 @@ public CliCommand parse(String[] cmdArgs) throws CliParseException {
     @Override
     public boolean exec() throws CliException {
         String path = args[1];
+        CountDownLatch latch = new CountDownLatch(1);
+        final int[] resultCode = new int[1];","[{'comment': ""Why is an array necessary here? Wouldn't a plain integer be sufficient?"", 'commenter': 'phunt'}, {'comment': 'when use a plain integer, a anonymous Inner Class needs it to be modified with `final `,then we cannot assignment and transfer the result outside.', 'commenter': 'maoling'}]"
823,zookeeper-server/src/main/java/org/apache/zookeeper/cli/SyncCommand.java,"@@ -30,6 +35,7 @@
 
     private static Options options = new Options();
     private String[] args;
+    public static final int CONNECTION_TIMEOUT = 30000;//30s","[{'comment': ""What about 'SYNC_TIMEOUT' ?\r\nIt is not used for 'comnection'"", 'commenter': 'eolivelli'}, {'comment': '+1', 'commenter': 'maoling'}, {'comment': 'Please use TimeUnit so that it is self documenting.\r\n\r\nhttps://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TimeUnit.html\r\n\r\n`TimeUnit.SECONDS.toMillis(30L)`', 'commenter': 'belugabehr'}]"
823,zookeeper-server/src/main/java/org/apache/zookeeper/cli/SyncCommand.java,"@@ -55,18 +61,27 @@ public CliCommand parse(String[] cmdArgs) throws CliParseException {
     @Override
     public boolean exec() throws CliException {
         String path = args[1];
+        CompletableFuture<Integer> cf = new CompletableFuture<>();
+
         try {
             zk.sync(path, new AsyncCallback.VoidCallback() {
-
                 public void processResult(int rc, String path, Object ctx) {
-                    out.println(""Sync returned "" + rc);
+                    cf.complete(rc);
                 }
             }, null);
+
+            try {
+                int resultCode = cf.get(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);
+                out.println(""Sync returned "" + resultCode);
+            } catch (TimeoutException ex) {
+                out.println(""Sync is timeout within "" +  CONNECTION_TIMEOUT + "" ms"");","[{'comment': 'Should we throw an error?\r\nThe command may not have succeeded', 'commenter': 'eolivelli'}, {'comment': '@eolivelli  pardon me.I may not get your idea clearly.\r\nDo you mean that throwing this `TimeoutException`?', 'commenter': 'maoling'}, {'comment': '@maoling yes', 'commenter': 'eolivelli'}, {'comment': ""Does this code need it's own 'try' block?  Can this catch be moved to the outer 'try' statement?"", 'commenter': 'belugabehr'}]"
823,zookeeper-server/src/main/java/org/apache/zookeeper/cli/SyncCommand.java,"@@ -55,18 +61,27 @@ public CliCommand parse(String[] cmdArgs) throws CliParseException {
     @Override
     public boolean exec() throws CliException {
         String path = args[1];
+        CompletableFuture<Integer> cf = new CompletableFuture<>();
+
         try {
             zk.sync(path, new AsyncCallback.VoidCallback() {
-
                 public void processResult(int rc, String path, Object ctx) {
-                    out.println(""Sync returned "" + rc);
+                    cf.complete(rc);
                 }
             }, null);
+
+            try {
+                int resultCode = cf.get(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);
+                out.println(""Sync returned "" + resultCode);
+            } catch (TimeoutException ex) {
+                out.println(""Sync is timeout within "" +  CONNECTION_TIMEOUT + "" ms"");
+            }
         } catch (IllegalArgumentException ex) {
             throw new MalformedPathException(ex.getMessage());
+        } catch (InterruptedException | ExecutionException ex) {","[{'comment': ""About catching `InterruptedException`: http://www.javapractices.com/topic/TopicAction.do?Id=251\r\nWe don't do anywhere else in our code which maybe not a good practice.\r\nWhat do you think @BELUGABEHR ?"", 'commenter': 'anmolnar'}, {'comment': ""I thought about it.\r\nIn this specific case we don't care. The CLI will exit."", 'commenter': 'eolivelli'}, {'comment': 'I follow an example from this:\r\nhttps://github.com/apache/zookeeper/blob/master/zookeeper-server/src/main/java/org/apache/zookeeper/cli/SetQuotaCommand.java#L82', 'commenter': 'maoling'}, {'comment': 'Got it. Makes sense.', 'commenter': 'anmolnar'}, {'comment': ""When you catch the Interrupted exception, it clears the Thread's state.  I would separate the catch into two blocks and be sure to reinstate the flag to 'interrupted' so that any other code will also quickly exit.\r\n\r\n```\r\n} catch (InterruptedException ie) {\r\n    Thread.currentThread().interrupt();\r\n   throw new CliWrapperException(ie);\r\n}\r\n```"", 'commenter': 'belugabehr'}, {'comment': 'Yes but in this case it is not really needed.\r\nWe can add it but not so important', 'commenter': 'eolivelli'}, {'comment': 'I think it\'s always best to do it the ""right"" way... it will insulate the code from changes later when it may become needed.', 'commenter': 'belugabehr'}, {'comment': ""It's missing from everywhere else in the code unfortunately.\r\nThere's no harm adding it here anyway."", 'commenter': 'anmolnar'}, {'comment': 'Yep, better to add.\r\nBetter to file a JIRA for fixing it every where', 'commenter': 'eolivelli'}]"
825,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -1140,17 +1140,94 @@ public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,
     public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,
             long sessionId, byte[] sessionPasswd, boolean canBeReadOnly,
             HostProvider aHostProvider) throws IOException {
-        LOG.info(""Initiating client connection, connectString="" + connectString
-                + "" sessionTimeout="" + sessionTimeout
-                + "" watcher="" + watcher
-                + "" sessionId="" + Long.toHexString(sessionId)
-                + "" sessionPasswd=""
-                + (sessionPasswd == null ? ""<null>"" : ""<hidden>""));
+    	this(connectString, sessionTimeout, watcher, sessionId, sessionPasswd,
+    			canBeReadOnly, aHostProvider, null);
+    }
+
+    /**
+     * To create a ZooKeeper client object, the application needs to pass a
+     * connection string containing a comma separated list of host:port pairs,
+     * each corresponding to a ZooKeeper server.
+     * <p>
+     * Session establishment is asynchronous. This constructor will initiate
+     * connection to the server and return immediately - potentially (usually)
+     * before the session is fully established. The watcher argument specifies
+     * the watcher that will be notified of any changes in state. This
+     * notification can come at any point before or after the constructor call
+     * has returned.
+     * <p>
+     * The instantiated ZooKeeper client object will pick an arbitrary server
+     * from the connectString and attempt to connect to it. If establishment of
+     * the connection fails, another server in the connect string will be tried
+     * (the order is non-deterministic, as we random shuffle the list), until a
+     * connection is established. The client will continue attempts until the
+     * session is explicitly closed (or the session is expired by the server).
+     * <p>
+     * Added in 3.2.0: An optional ""chroot"" suffix may also be appended to the
+     * connection string. This will run the client commands while interpreting
+     * all paths relative to this root (similar to the unix chroot command).
+     * <p>
+     * Use {@link #getSessionId} and {@link #getSessionPasswd} on an established
+     * client connection, these values must be passed as sessionId and
+     * sessionPasswd respectively if reconnecting. Otherwise, if not
+     * reconnecting, use the other constructor which does not require these
+     * parameters.
+     * <p>
+     * For backward compatibility, there is another version
+     * {@link #ZooKeeper(String, int, Watcher, long, byte[], boolean)} which uses
+     * default {@link StaticHostProvider}
+     *
+     * @param connectString
+     *            comma separated host:port pairs, each corresponding to a zk
+     *            server. e.g. ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002""
+     *            If the optional chroot suffix is used the example would look
+     *            like: ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a""
+     *            where the client would be rooted at ""/app/a"" and all paths
+     *            would be relative to this root - ie getting/setting/etc...
+     *            ""/foo/bar"" would result in operations being run on
+     *            ""/app/a/foo/bar"" (from the server perspective).
+     * @param sessionTimeout
+     *            session timeout in milliseconds
+     * @param watcher
+     *            a watcher object which will be notified of state changes, may
+     *            also be notified for node events
+     * @param sessionId
+     *            specific session id to use if reconnecting
+     * @param sessionPasswd
+     *            password for this session
+     * @param canBeReadOnly
+     *            (added in 3.4) whether the created client is allowed to go to
+     *            read-only mode in case of partitioning. Read-only mode
+     *            basically means that if the client can't find any majority
+     *            servers but there's partitioned server it could reach, it
+     *            connects to one in read-only mode, i.e. read requests are
+     *            allowed while write requests are not. It continues seeking for
+     *            majority in the background.
+     * @param aHostProvider
+     *            use this as HostProvider to enable custom behaviour.
+     * @param clientConfig
+     *            (added in 3.5.2) passing this conf object gives each client the flexibility of","[{'comment': 'nit: 3.5.2, is should be 3.5.3\r\n\r\nwe could also add a @since 3.5.3 javadoc tag', 'commenter': 'eolivelli'}, {'comment': '> nit:3.5.2, is should be 3.5.3\r\n\r\nLook around the code in the `zookeeper.java`,all the info shows that the clientConfig was added in 3.5.2 ?\r\n>   we could also add a @SInCE 3.5.3 javadoc tag\r\n\r\nAgreed!', 'commenter': 'maoling'}]"
828,zookeeper-assembly/pom.xml,"@@ -0,0 +1,105 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+  <!--
+  /**
+   * Licensed to the Apache Software Foundation (ASF) under one
+   * or more contributor license agreements.  See the NOTICE file
+   * distributed with this work for additional information
+   * regarding copyright ownership.  The ASF licenses this file
+   * to you under the Apache License, Version 2.0 (the
+   * ""License""); you may not use this file except in compliance
+   * with the License.  You may obtain a copy of the License at
+   *
+   *     http://www.apache.org/licenses/LICENSE-2.0
+   *
+   * Unless required by applicable law or agreed to in writing, software
+   * distributed under the License is distributed on an ""AS IS"" BASIS,
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   */
+  -->
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.zookeeper</groupId>
+    <artifactId>zookeeper</artifactId>
+    <version>3.6.0-SNAPSHOT</version>
+    <relativePath>..</relativePath>
+  </parent>
+
+  <groupId>org.apache.zookeeper</groupId>
+  <artifactId>zookeeper-assembly</artifactId>
+  <packaging>pom</packaging>
+  <name>Apache ZooKeeper - Assembly</name>
+  <description>ZooKeeper Assembly</description>
+
+  <properties>
+    <rw.file.permission>0644</rw.file.permission>
+    <rwx.file.permission>0755</rwx.file.permission>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.zookeeper</groupId>
+      <artifactId>zookeeper-docs</artifactId>
+      <version>3.6.0-SNAPSHOT</version>","[{'comment': '${project.version} ?', 'commenter': 'eolivelli'}]"
828,zookeeper-assembly/pom.xml,"@@ -0,0 +1,105 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+  <!--
+  /**
+   * Licensed to the Apache Software Foundation (ASF) under one
+   * or more contributor license agreements.  See the NOTICE file
+   * distributed with this work for additional information
+   * regarding copyright ownership.  The ASF licenses this file
+   * to you under the Apache License, Version 2.0 (the
+   * ""License""); you may not use this file except in compliance
+   * with the License.  You may obtain a copy of the License at
+   *
+   *     http://www.apache.org/licenses/LICENSE-2.0
+   *
+   * Unless required by applicable law or agreed to in writing, software
+   * distributed under the License is distributed on an ""AS IS"" BASIS,
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   */
+  -->
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.zookeeper</groupId>
+    <artifactId>zookeeper</artifactId>
+    <version>3.6.0-SNAPSHOT</version>
+    <relativePath>..</relativePath>
+  </parent>
+
+  <groupId>org.apache.zookeeper</groupId>
+  <artifactId>zookeeper-assembly</artifactId>
+  <packaging>pom</packaging>
+  <name>Apache ZooKeeper - Assembly</name>
+  <description>ZooKeeper Assembly</description>
+
+  <properties>
+    <rw.file.permission>0644</rw.file.permission>
+    <rwx.file.permission>0755</rwx.file.permission>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.zookeeper</groupId>
+      <artifactId>zookeeper-docs</artifactId>
+      <version>3.6.0-SNAPSHOT</version>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.zookeeper</groupId>
+      <artifactId>zookeeper-jute</artifactId>
+      <version>3.6.0-SNAPSHOT</version>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.zookeeper</groupId>
+      <artifactId>zookeeper-server</artifactId>
+      <version>3.6.0-SNAPSHOT</version>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.zookeeper</groupId>
+      <artifactId>zookeeper-client</artifactId>
+      <version>3.6.0-SNAPSHOT</version>
+      <type>pom</type>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.zookeeper</groupId>
+      <artifactId>zookeeper-recipes</artifactId>
+      <version>3.6.0-SNAPSHOT</version>
+      <type>pom</type>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>make-assembly</id>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+            <configuration>
+              <descriptors>
+                <descriptor>${project.basedir}/src/main/assembly/source-package.xml</descriptor>
+                <descriptor>${project.basedir}/src/main/assembly/bin-package.xml</descriptor>
+              </descriptors>
+              <finalName>zookeeper-${project.version}</finalName>
+              <tarLongFileMode>gnu</tarLongFileMode>","[{'comment': ""Usually I am using 'posix' (in my company we have very long user ids)"", 'commenter': 'eolivelli'}]"
828,zookeeper-assembly/src/main/assembly/bin-package.xml,"@@ -0,0 +1,129 @@
+<assembly xmlns=""http://maven.apache.org/ASSEMBLY/2.0.0""
+          xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+          xsi:schemaLocation=""http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd"">
+<!--
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+  <id>bin-package</id>
+  <formats>
+    <format>tar.gz</format>
+    <format>zip</format>
+  </formats>
+  <includeBaseDirectory>false</includeBaseDirectory>
+  <componentDescriptors>
+    <componentDescriptor>src/main/assembly/components.xml</componentDescriptor>
+  </componentDescriptors>
+
+  <moduleSets>
+    <!-- ZooKeeper jars (excluding pom projects) including 3rd party dependencies -->
+    <moduleSet>
+      <useAllReactorProjects>true</useAllReactorProjects>
+      <includes>
+        <include>org.apache.zookeeper:zookeeper-server</include>
+        <include>org.apache.zookeeper:zookeeper-recipes-election</include>
+        <include>org.apache.zookeeper:zookeeper-recipes-lock</include>
+        <include>org.apache.zookeeper:zookeeper-recipes-queue</include>
+      </includes>
+
+      <binaries>
+        <outputDirectory>lib</outputDirectory>
+        <unpack>false</unpack>
+        <dependencySets>
+          <dependencySet>
+            <excludes>
+              <exclude>org.apache.zookeeper:zookeeper-recipes</exclude>
+              <exclude>org.apache.zookeeper:zookeeper-client</exclude>
+              <exclude>org.apache.zookeeper:zookeeper-docs</exclude>
+            </excludes>
+          </dependencySet>
+        </dependencySets>
+      </binaries>
+    </moduleSet>
+  </moduleSets>
+
+  <fileSets>
+    <fileSet>
+      <!-- ZooKeeper generated documents -->
+      <directory>${project.basedir}/../zookeeper-docs/target/html</directory>
+      <outputDirectory>docs</outputDirectory>
+      <fileMode>${rw.file.permission}</fileMode>
+      <directoryMode>${rwx.file.permission}</directoryMode>
+    </fileSet>
+    <fileSet>
+      <!-- License files for 3rd party libs -->
+      <directory>${project.basedir}/../zookeeper-server/src/main/resources/lib</directory>
+      <includes>
+        <include>*.txt</include>
+      </includes>
+      <outputDirectory>lib</outputDirectory>
+      <fileMode>${rw.file.permission}</fileMode>
+    </fileSet>
+
+    <!-- Add source jars ""manually"", as the :source classiffier doesn't work in moduleSets -->","[{'comment': 'Do you have a link to a JIRA on the maven-assembly-plugin  ?\r\nhttps://issues.apache.org/jira/projects/MASSEMBLY', 'commenter': 'eolivelli'}, {'comment': 'I will create one, thanks!\r\nedit: MASSEMBLY-906', 'commenter': 'nkalmar'}]"
828,zookeeper-assembly/src/main/assembly/source-package.xml,"@@ -0,0 +1,121 @@
+<assembly xmlns=""http://maven.apache.org/ASSEMBLY/2.0.0""
+          xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+          xsi:schemaLocation=""http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd"">
+<!--
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+  <id>source-package</id>
+  <formats>
+    <format>tar.gz</format>
+    <format>zip</format>","[{'comment': ""Do we need 'zip' ?"", 'commenter': 'eolivelli'}, {'comment': 'Good question! \r\nDo we? :)\r\nping @anmolnar ', 'commenter': 'nkalmar'}, {'comment': 'No!', 'commenter': 'anmolnar'}]"
828,pom.xml,"@@ -660,26 +666,20 @@
         </executions>
       </plugin>
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
+        <groupId>net.nicoulaj.maven.plugins</groupId>","[{'comment': ""Is it the case that maven plugin(s) don't support this functionality? Perhaps a short comment here would help future folks. I'm not familiar with this plugin (net. nicoulaj) and as such a short basis for why would help. thx."", 'commenter': 'phunt'}, {'comment': ""I will add some comments, thanks for bringing attention to this.\r\nChecksum generation was moved to deploy plugin: https://issues.apache.org/jira/browse/MINSTALL-143\r\nDeploy plugin will only generate checksum for artifacts moved to repository. The generated tarballs will not be moved to the repository.\r\n\r\nI did not find a way to do this from the standard maven plugins. Every article / question / forum I found suggested to use Nicoulaj's plugin. "", 'commenter': 'nkalmar'}, {'comment': 'sgtm. thanks!', 'commenter': 'phunt'}, {'comment': '""silently giggling to myself""?? :)', 'commenter': 'anmolnar'}]"
833,zookeeper-docs/src/main/resources/markdown/ZookeeperCLI.md,"@@ -0,0 +1,120 @@
+<!--
+Copyright 2002-2004 The Apache Software Foundation","[{'comment': 'nit - update to current year.', 'commenter': 'phunt'}]"
833,zookeeper-docs/src/main/resources/markdown/ZookeeperCLI.md,"@@ -0,0 +1,120 @@
+<!--
+Copyright 2002-2004 The Apache Software Foundation
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+//-->
+
+# Zookeeper-cli: the Zookeeper command line interface","[{'comment': 'ZooKeeper is ""ZooKeeper"" typically, not ""Zookeeper"" (search/replace all)', 'commenter': 'phunt'}]"
833,zookeeper-docs/src/main/resources/markdown/ZookeeperCLI.md,"@@ -0,0 +1,120 @@
+<!--
+Copyright 2002-2004 The Apache Software Foundation
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+//-->
+
+# Zookeeper-cli: the Zookeeper command line interface
+
+## Preparations
+enter into the zookeeper-cli","[{'comment': 'Capitalize the beginning of the sentence - ""E""', 'commenter': 'phunt'}]"
833,zookeeper-docs/src/main/resources/markdown/zookeeperCLI.md,"@@ -0,0 +1,542 @@
+<!--
+Copyright 2002-2019 The Apache Software Foundation
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+//-->
+
+# ZooKeeper-cli: the ZooKeeper command line interface
+
+## Pre-requisites
+Enter into the ZooKeeper-cli
+
+```bash
+# connect to the localhost with the default port:2181
+bin/zkCli.sh
+# connect to the remote host with timeout:3s
+bin/zkCli.sh -timeout 3000 -server remoteIP:2181
+```
+## help
+Showing helps about ZooKeeper commands
+
+```bash
+[zkshell: 1] help
+# a sample one
+[zkshell: 2] h
+ZooKeeper -server host:port cmd args
+	addauth scheme auth
+	close
+	config [-c] [-w] [-s]
+	connect host:port
+	create [-s] [-e] [-c] [-t ttl] path [data] [acl]
+	delete [-v version] path
+	deleteall path
+	delquota [-n|-b] path
+	get [-s] [-w] path
+	getAcl [-s] path
+	getAllChildrenNumber path
+	getEphemerals path
+	history
+	listquota path
+	ls [-s] [-w] [-R] path
+	ls2 path [watch]
+	printwatches on|off
+	quit
+	reconfig [-s] [-v version] [[-file path] | [-members serverID=host:port1:port2;port3[,...]*]] | [-add serverId=host:port1:port2;port3[,...]]* [-remove serverId[,...]*]
+	redo cmdno
+	removewatches path [-c|-d|-a] [-l]
+	rmr path
+	set [-s] [-v version] path data
+	setAcl [-s] [-v version] [-R] path acl
+	setquota -n|-b val path
+	stat [-w] path
+	sync path
+```
+
+## addauth
+Add a authorized user for ACL
+
+```bash
+[zkshell: 9] getAcl /acl_digest_test
+    Authentication is not valid : /acl_digest_test
+[zkshell: 10] addauth digest user1:12345
+[zkshell: 11] getAcl /acl_digest_test
+    'digest,'user1:+owfoSBn/am19roBPzR1/MfCblE=
+    : cdrwa
+# add a super user
+# Notice:set zookeeper.DigestAuthenticationProvider
+# e.g. zookeeper.DigestAuthenticationProvider.superDigest=zookeeper:qW/HnTfCSoQpB5G8LgkwT3IbiFc=
+[zkshell: 12] addauth digest zookeeper:admin
+```
+
+## close
+Close this client/session.
+
+```bash
+[zkshell: 0] close
+	2019-03-09 06:42:22,178 [myid:] - INFO  [main-EventThread:ClientCnxn$EventThread@528] - EventThread shut down for session: 0x10007ab7c550006
+	2019-03-09 06:42:22,179 [myid:] - INFO  [main:ZooKeeper@1346] - Session: 0x10007ab7c550006 closed
+```
+
+## config
+Showing the config of quorum membership
+
+```bash
+[zkshell: 17] config
+	server.1=[2001:db8:1:0:0:242:ac11:2]:2888:3888:participant
+	server.2=[2001:db8:1:0:0:242:ac11:2]:12888:13888:participant
+	server.3=[2001:db8:1:0:0:242:ac11:2]:22888:23888:participant
+	version=0
+```
+## connect
+Connect a ZooKeeper server.
+
+```bash
+[zkshell: 4] connect
+	2019-03-09 06:43:33,179 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@986] - Socket connection established, initiating session, client: /127.0.0.1:35144, server: localhost/127.0.0.1:2181
+	2019-03-09 06:43:33,189 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@1421] - Session establishment complete on server localhost/127.0.0.1:2181, sessionid = 0x10007ab7c550007, negotiated timeout = 30000
+	connect ""localhost:2181,localhost:2182,localhost:2183""
+
+# connect a remote server
+[zkshell: 5] connect remoteIP:2181
+```
+## create
+Create a znode.
+
+```bash
+# create a persistent_node
+[zkshell: 7] create /persistent_node
+	Created /persistent_node
+
+# create a ephemeral node
+[zkshell: 8] create -e /ephemeral_node mydata
+	Created /ephemeral_node
+
+# create the persistent-sequential node
+[zkshell: 9] create -s /persistent_sequential_node mydata
+	Created /persistent_sequential_node0000000176
+
+# create the ephemeral-sequential_node
+[zkshell: 10] create -s -e /ephemeral_sequential_node mydata
+	Created /ephemeral_sequential_node0000000174
+
+# create a node with the schema
+[zkshell: 11] create /zk-node-create-schema mydata digest:user1:+owfoSBn/am19roBPzR1/MfCblE=:crwad
+	Created /zk-node-create-schema
+[zkshell: 12] addauth digest user1:12345
+[zkshell: 13] getAcl /zk-node-create-schema
+	'digest,'user1:+owfoSBn/am19roBPzR1/MfCblE=
+	: cdrwa
+
+# create the container node.When the last child of a container is deleted,the container becomes to be deleted
+[zkshell: 14] create -c /container_node mydata
+	Created /container_node
+[zkshell: 15] create -c /container_node/child_1 mydata
+	Created /container_node/child_1
+[zkshell: 16] create -c /container_node/child_2 mydata
+	Created /container_node/child_2
+[zkshell: 17] delete /container_node/child_1
+[zkshell: 18] delete /container_node/child_2
+[zkshell: 19] get /container_node
+	org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode for /container_node
+
+# create the ttl node.
+# set zookeeper.extendedTypesEnabled=true
+# Otherwise:KeeperErrorCode = Unimplemented for /ttl_node
+[zkshell: 20] create -t 3000 /ttl_node mydata
+	Created /ttl_node
+# after 3s later
+[zkshell: 21] get /ttl_node
+	org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode for /ttl_node
+```
+## delete
+Delete a node with a specific path
+
+```bash
+[zkshell: 2] delete /config/topics/test
+[zkshell: 3] ls /config/topics/test
+	Node does not exist: /config/topics/test
+```
+
+## deleteall
+Delete all nodes under a specific path
+
+```bash
+zkshell: 1] ls /config
+	[changes, clients, topics]
+[zkshell: 2] deleteall /config
+[zkshell: 3] ls /config
+	Node does not exist: /config
+```
+
+## delquota
+Delete the quota under a path
+
+```bash
+[zkshell: 1] delquota /quota_test
+[zkshell: 2] listquota /quota_test
+	absolute path is /zookeeper/quota/quota_test/zookeeper_limits
+	quota for /quota_test does not exist.
+```
+## get
+Get the data of the specific path
+
+```bash
+[zkshell: 10] get /latest_producer_id_block
+	{""version"":1,""broker"":0,""block_start"":""0"",""block_end"":""999""}
+
+# -s to show the stat
+[zkshell: 11] get -s /latest_producer_id_block
+	{""version"":1,""broker"":0,""block_start"":""0"",""block_end"":""999""}
+	cZxid = 0x90000009a
+	ctime = Sat Jul 28 08:14:09 UTC 2018
+	mZxid = 0x9000000a2
+	mtime = Sat Jul 28 08:14:12 UTC 2018
+	pZxid = 0x90000009a
+	cversion = 0
+	dataVersion = 1
+	aclVersion = 0
+	ephemeralOwner = 0x0
+	dataLength = 60
+	numChildren = 0
+
+# -w to set a watch on the data change, Notice: turn on the printwatches
+[zkshell: 12] get -w /latest_producer_id_block
+	{""version"":1,""broker"":0,""block_start"":""0"",""block_end"":""999""}
+[zkshell: 13] set /latest_producer_id_block mydata
+	WATCHER::
+	WatchedEvent state:SyncConnected type:NodeDataChanged path:/latest_producer_id_block
+```
+
+## getAcl
+Get the ACL permission of one path
+
+```bash
+[zkshell: 4] create /acl_test mydata ip:127.0.0.1:crwda
+	Created /acl_test
+[zkshell: 5] getAcl /acl_test
+	'ip,'127.0.0.1
+	: cdrwa
+	[zkshell: 6] getAcl /testwatch
+	'world,'anyone
+	: cdrwa
+```
+## getAllChildrenNumber
+Get all numbers of children nodes under a specific path
+
+```bash
+[zkshell: 1] getAllChildrenNumber /
+	73779
+[zkshell: 2] getAllChildrenNumber /ZooKeeper
+	2
+[zkshell: 3] getAllChildrenNumber /ZooKeeper/quota
+	0
+```
+## getEphemerals
+Get all the ephemeral nodes created by this session
+
+```bash
+[zkshell: 1] create -e /test-get-ephemerals ""ephemeral node""
+	Created /test-get-ephemerals
+[zkshell: 2] getEphemerals
+	[/test-get-ephemerals]
+[zkshell: 3] getEphemerals /
+	[/test-get-ephemerals]
+[zkshell: 4] create -e /test-get-ephemerals-1 ""ephemeral node""
+	Created /test-get-ephemerals-1
+[zkshell: 5] getEphemerals /test-get-ephemerals
+	test-get-ephemerals     test-get-ephemerals-1
+[zkshell: 6] getEphemerals /test-get-ephemerals
+	[/test-get-ephemerals-1, /test-get-ephemerals]
+[zkshell: 7] getEphemerals /test-get-ephemerals-1
+	[/test-get-ephemerals-1]
+```
+
+## history
+Showing the history about the recent 11 commands that you have executed
+
+```bash
+[zkshell: 7] history
+	0 - close
+	1 - close
+	2 - ls /
+	3 - ls /
+	4 - connect
+	5 - ls /
+	6 - ll
+	7 - history
+```
+
+## listquota
+Listing the quota of one path
+
+```bash
+[zkshell: 1] listquota /quota_test
+	absolute path is /zookeeper/quota/quota_test/zookeeper_limits
+	Output quota for /quota_test count=2,bytes=-1
+	Output stat for /quota_test count=4,bytes=0
+```
+
+## ls
+Listing the child nodes of one path
+
+```bash
+[zkshell: 36] ls /quota_test
+	[child_1, child_2, child_3]
+
+# -s to show the stat
+[zkshell: 37] ls -s /quota_test
+	[child_1, child_2, child_3]
+	cZxid = 0x110000002d
+	ctime = Thu Mar 07 11:19:07 UTC 2019
+	mZxid = 0x110000002d
+	mtime = Thu Mar 07 11:19:07 UTC 2019
+	pZxid = 0x1100000033
+	cversion = 3
+	dataVersion = 0
+	aclVersion = 0
+	ephemeralOwner = 0x0
+	dataLength = 0
+	numChildren = 3
+
+# -R to show the child nodes recursely
+[zkshell: 38] ls -R /quota_test
+	/quota_test
+	/quota_test/child_1
+	/quota_test/child_2
+	/quota_test/child_3
+
+# -w to set a watch on the child change,Notice: turn on the printwatches
+[zkshell: 39] ls -w /brokers
+	[ids, seqid, topics]
+[zkshell: 40] delete /brokers/ids
+	WATCHER::
+	WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/brokers
+```
+
+## ls2","[{'comment': 'What about creating a JIRA for the removal?', 'commenter': 'eolivelli'}, {'comment': 'Yep.I have created a ticket:[ZOOKEEPER-3411](https://issues.apache.org/jira/browse/ZOOKEEPER-3411) to do this.', 'commenter': 'maoling'}]"
833,zookeeper-docs/src/main/resources/markdown/zookeeperCLI.md,"@@ -0,0 +1,542 @@
+<!--
+Copyright 2002-2019 The Apache Software Foundation
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+//-->
+
+# ZooKeeper-cli: the ZooKeeper command line interface
+
+## Pre-requisites
+Enter into the ZooKeeper-cli
+
+```bash
+# connect to the localhost with the default port:2181
+bin/zkCli.sh
+# connect to the remote host with timeout:3s
+bin/zkCli.sh -timeout 3000 -server remoteIP:2181
+```
+## help
+Showing helps about ZooKeeper commands
+
+```bash
+[zkshell: 1] help
+# a sample one
+[zkshell: 2] h
+ZooKeeper -server host:port cmd args
+	addauth scheme auth
+	close
+	config [-c] [-w] [-s]
+	connect host:port
+	create [-s] [-e] [-c] [-t ttl] path [data] [acl]
+	delete [-v version] path
+	deleteall path
+	delquota [-n|-b] path
+	get [-s] [-w] path
+	getAcl [-s] path
+	getAllChildrenNumber path
+	getEphemerals path
+	history
+	listquota path
+	ls [-s] [-w] [-R] path
+	ls2 path [watch]
+	printwatches on|off
+	quit
+	reconfig [-s] [-v version] [[-file path] | [-members serverID=host:port1:port2;port3[,...]*]] | [-add serverId=host:port1:port2;port3[,...]]* [-remove serverId[,...]*]
+	redo cmdno
+	removewatches path [-c|-d|-a] [-l]
+	rmr path
+	set [-s] [-v version] path data
+	setAcl [-s] [-v version] [-R] path acl
+	setquota -n|-b val path
+	stat [-w] path
+	sync path
+```
+
+## addauth
+Add a authorized user for ACL
+
+```bash
+[zkshell: 9] getAcl /acl_digest_test
+    Authentication is not valid : /acl_digest_test
+[zkshell: 10] addauth digest user1:12345
+[zkshell: 11] getAcl /acl_digest_test
+    'digest,'user1:+owfoSBn/am19roBPzR1/MfCblE=
+    : cdrwa
+# add a super user
+# Notice:set zookeeper.DigestAuthenticationProvider
+# e.g. zookeeper.DigestAuthenticationProvider.superDigest=zookeeper:qW/HnTfCSoQpB5G8LgkwT3IbiFc=
+[zkshell: 12] addauth digest zookeeper:admin
+```
+
+## close
+Close this client/session.
+
+```bash
+[zkshell: 0] close
+	2019-03-09 06:42:22,178 [myid:] - INFO  [main-EventThread:ClientCnxn$EventThread@528] - EventThread shut down for session: 0x10007ab7c550006
+	2019-03-09 06:42:22,179 [myid:] - INFO  [main:ZooKeeper@1346] - Session: 0x10007ab7c550006 closed
+```
+
+## config
+Showing the config of quorum membership
+
+```bash
+[zkshell: 17] config
+	server.1=[2001:db8:1:0:0:242:ac11:2]:2888:3888:participant
+	server.2=[2001:db8:1:0:0:242:ac11:2]:12888:13888:participant
+	server.3=[2001:db8:1:0:0:242:ac11:2]:22888:23888:participant
+	version=0
+```
+## connect
+Connect a ZooKeeper server.
+
+```bash
+[zkshell: 4] connect
+	2019-03-09 06:43:33,179 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@986] - Socket connection established, initiating session, client: /127.0.0.1:35144, server: localhost/127.0.0.1:2181
+	2019-03-09 06:43:33,189 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@1421] - Session establishment complete on server localhost/127.0.0.1:2181, sessionid = 0x10007ab7c550007, negotiated timeout = 30000
+	connect ""localhost:2181,localhost:2182,localhost:2183""
+
+# connect a remote server
+[zkshell: 5] connect remoteIP:2181
+```
+## create
+Create a znode.
+
+```bash
+# create a persistent_node
+[zkshell: 7] create /persistent_node
+	Created /persistent_node
+
+# create a ephemeral node
+[zkshell: 8] create -e /ephemeral_node mydata
+	Created /ephemeral_node
+
+# create the persistent-sequential node
+[zkshell: 9] create -s /persistent_sequential_node mydata
+	Created /persistent_sequential_node0000000176
+
+# create the ephemeral-sequential_node
+[zkshell: 10] create -s -e /ephemeral_sequential_node mydata
+	Created /ephemeral_sequential_node0000000174
+
+# create a node with the schema
+[zkshell: 11] create /zk-node-create-schema mydata digest:user1:+owfoSBn/am19roBPzR1/MfCblE=:crwad
+	Created /zk-node-create-schema
+[zkshell: 12] addauth digest user1:12345
+[zkshell: 13] getAcl /zk-node-create-schema
+	'digest,'user1:+owfoSBn/am19roBPzR1/MfCblE=
+	: cdrwa
+
+# create the container node.When the last child of a container is deleted,the container becomes to be deleted
+[zkshell: 14] create -c /container_node mydata
+	Created /container_node
+[zkshell: 15] create -c /container_node/child_1 mydata
+	Created /container_node/child_1
+[zkshell: 16] create -c /container_node/child_2 mydata
+	Created /container_node/child_2
+[zkshell: 17] delete /container_node/child_1
+[zkshell: 18] delete /container_node/child_2
+[zkshell: 19] get /container_node
+	org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode for /container_node
+
+# create the ttl node.
+# set zookeeper.extendedTypesEnabled=true
+# Otherwise:KeeperErrorCode = Unimplemented for /ttl_node
+[zkshell: 20] create -t 3000 /ttl_node mydata
+	Created /ttl_node
+# after 3s later
+[zkshell: 21] get /ttl_node
+	org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode for /ttl_node
+```
+## delete
+Delete a node with a specific path
+
+```bash
+[zkshell: 2] delete /config/topics/test
+[zkshell: 3] ls /config/topics/test
+	Node does not exist: /config/topics/test
+```
+
+## deleteall
+Delete all nodes under a specific path
+
+```bash
+zkshell: 1] ls /config
+	[changes, clients, topics]
+[zkshell: 2] deleteall /config
+[zkshell: 3] ls /config
+	Node does not exist: /config
+```
+
+## delquota
+Delete the quota under a path
+
+```bash
+[zkshell: 1] delquota /quota_test
+[zkshell: 2] listquota /quota_test
+	absolute path is /zookeeper/quota/quota_test/zookeeper_limits
+	quota for /quota_test does not exist.
+```
+## get
+Get the data of the specific path
+
+```bash
+[zkshell: 10] get /latest_producer_id_block
+	{""version"":1,""broker"":0,""block_start"":""0"",""block_end"":""999""}
+
+# -s to show the stat
+[zkshell: 11] get -s /latest_producer_id_block
+	{""version"":1,""broker"":0,""block_start"":""0"",""block_end"":""999""}
+	cZxid = 0x90000009a
+	ctime = Sat Jul 28 08:14:09 UTC 2018
+	mZxid = 0x9000000a2
+	mtime = Sat Jul 28 08:14:12 UTC 2018
+	pZxid = 0x90000009a
+	cversion = 0
+	dataVersion = 1
+	aclVersion = 0
+	ephemeralOwner = 0x0
+	dataLength = 60
+	numChildren = 0
+
+# -w to set a watch on the data change, Notice: turn on the printwatches
+[zkshell: 12] get -w /latest_producer_id_block
+	{""version"":1,""broker"":0,""block_start"":""0"",""block_end"":""999""}
+[zkshell: 13] set /latest_producer_id_block mydata
+	WATCHER::
+	WatchedEvent state:SyncConnected type:NodeDataChanged path:/latest_producer_id_block
+```
+
+## getAcl
+Get the ACL permission of one path
+
+```bash
+[zkshell: 4] create /acl_test mydata ip:127.0.0.1:crwda
+	Created /acl_test
+[zkshell: 5] getAcl /acl_test
+	'ip,'127.0.0.1
+	: cdrwa
+	[zkshell: 6] getAcl /testwatch
+	'world,'anyone
+	: cdrwa
+```
+## getAllChildrenNumber
+Get all numbers of children nodes under a specific path
+
+```bash
+[zkshell: 1] getAllChildrenNumber /
+	73779
+[zkshell: 2] getAllChildrenNumber /ZooKeeper
+	2
+[zkshell: 3] getAllChildrenNumber /ZooKeeper/quota
+	0
+```
+## getEphemerals
+Get all the ephemeral nodes created by this session
+
+```bash
+[zkshell: 1] create -e /test-get-ephemerals ""ephemeral node""
+	Created /test-get-ephemerals
+[zkshell: 2] getEphemerals
+	[/test-get-ephemerals]
+[zkshell: 3] getEphemerals /
+	[/test-get-ephemerals]
+[zkshell: 4] create -e /test-get-ephemerals-1 ""ephemeral node""
+	Created /test-get-ephemerals-1
+[zkshell: 5] getEphemerals /test-get-ephemerals
+	test-get-ephemerals     test-get-ephemerals-1
+[zkshell: 6] getEphemerals /test-get-ephemerals
+	[/test-get-ephemerals-1, /test-get-ephemerals]
+[zkshell: 7] getEphemerals /test-get-ephemerals-1
+	[/test-get-ephemerals-1]
+```
+
+## history
+Showing the history about the recent 11 commands that you have executed
+
+```bash
+[zkshell: 7] history
+	0 - close
+	1 - close
+	2 - ls /
+	3 - ls /
+	4 - connect
+	5 - ls /
+	6 - ll
+	7 - history
+```
+
+## listquota
+Listing the quota of one path
+
+```bash
+[zkshell: 1] listquota /quota_test
+	absolute path is /zookeeper/quota/quota_test/zookeeper_limits
+	Output quota for /quota_test count=2,bytes=-1
+	Output stat for /quota_test count=4,bytes=0
+```
+
+## ls
+Listing the child nodes of one path
+
+```bash
+[zkshell: 36] ls /quota_test
+	[child_1, child_2, child_3]
+
+# -s to show the stat
+[zkshell: 37] ls -s /quota_test
+	[child_1, child_2, child_3]
+	cZxid = 0x110000002d
+	ctime = Thu Mar 07 11:19:07 UTC 2019
+	mZxid = 0x110000002d
+	mtime = Thu Mar 07 11:19:07 UTC 2019
+	pZxid = 0x1100000033
+	cversion = 3
+	dataVersion = 0
+	aclVersion = 0
+	ephemeralOwner = 0x0
+	dataLength = 0
+	numChildren = 3
+
+# -R to show the child nodes recursely
+[zkshell: 38] ls -R /quota_test
+	/quota_test
+	/quota_test/child_1
+	/quota_test/child_2
+	/quota_test/child_3
+
+# -w to set a watch on the child change,Notice: turn on the printwatches
+[zkshell: 39] ls -w /brokers
+	[ids, seqid, topics]
+[zkshell: 40] delete /brokers/ids
+	WATCHER::
+	WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/brokers
+```
+
+## ls2
+
+'ls2' has been deprecated. Please use 'ls [-s] path' instead.
+
+```bash
+[zkshell: 7] ls2 /
+	'ls2' has been deprecated. Please use 'ls [-s] path' instead.
+```
+
+## printwatches
+A switch to turn on/off whether printing watches or not.
+
+```bash
+[zkshell: 0] printwatches
+	printwatches is on
+[zkshell: 1] printwatches off
+[zkshell: 2] printwatches
+	printwatches is off
+[zkshell: 3] printwatches on
+[zkshell: 4] printwatches
+	printwatches is on
+```
+
+## quit
+Quit the CLI windows.
+
+```bash
+[zkshell: 1] quit
+```
+
+## reconfig
+Change the membership of the ensemble during the runtime.
+
+Before using this cli,read the details in the [Dynamic Reconfiguration](zookeeperReconfig.html) about the reconfig feature,especially the ""Security"" part.
+
+Pre-requisites:
+
+1. set reconfigEnabled=true in the zoo.cfg
+
+2. add a super user or skipAcl,otherwise will get “Authentication is not valid”. e.g. addauth digest zookeeper:admin
+
+```bash
+# Change follower 2 to an observer and change its port from 2182 to 12182
+# Add observer 5 to the ensemble
+# Remove Observer 4 from the ensemble
+[zkshell: 1] reconfig --add 2=localhost:2781:2786:observer;12182 --add 5=localhost:2781:2786:observer;2185 -remove 4
+	Committed new configuration:
+	server.1=localhost:2780:2785:participant;0.0.0.0:2181
+	server.2=localhost:2781:2786:observer;0.0.0.0:12182
+	server.3=localhost:2782:2787:participant;0.0.0.0:2183
+	server.5=localhost:2784:2789:observer;0.0.0.0:2185
+	version=1c00000002
+
+# -members to appoint the membership
+[zkshell: 2] reconfig -members server.1=localhost:2780:2785:participant;0.0.0.0:2181,server.2=localhost:2781:2786:observer;0.0.0.0:12182,server.3=localhost:2782:2787:participant;0.0.0.0:12183
+	Committed new configuration:
+	server.1=localhost:2780:2785:participant;0.0.0.0:2181
+	server.2=localhost:2781:2786:observer;0.0.0.0:12182
+	server.3=localhost:2782:2787:participant;0.0.0.0:12183
+	version=f9fe0000000c
+
+# Change the current config to the one in the myNewConfig.txt
+# But only if current config version is 2100000010
+[zkshell: 3] reconfig -file /data/software/zookeeper/zookeeper-test/conf/myNewConfig.txt -v 2100000010
+	Committed new configuration:
+	server.1=localhost:2780:2785:participant;0.0.0.0:2181
+	server.2=localhost:2781:2786:observer;0.0.0.0:12182
+	server.3=localhost:2782:2787:participant;0.0.0.0:2183
+	server.5=localhost:2784:2789:observer;0.0.0.0:2185
+	version=220000000c
+```
+
+## redo
+Redo the cmd with the index from history.
+
+```bash
+[zkshell: 4] history
+	0 - ls /
+	1 - get /consumers
+	2 - get /hbase
+	3 - ls  /hbase
+	4 - history
+[zkshell: 5] redo 3
+	[backup-masters, draining, flush-table-proc, hbaseid, master-maintenance, meta-region-server, namespace, online-snapshot, replication, rs, running, splitWAL, switch, table, table-lock]
+```
+
+## removewatches
+Remove the watches under a node.
+
+```bash
+[zkshell: 1] get -w /brokers
+	null
+[zkshell: 2] removewatches /brokers
+	WATCHER::
+	WatchedEvent state:SyncConnected type:DataWatchRemoved path:/brokers
+
+```
+
+## rmr
+The command 'rmr' has been deprecated. Please use 'deleteall' instead.","[{'comment': 'Same here', 'commenter': 'eolivelli'}]"
833,zookeeper-docs/src/main/resources/markdown/zookeeperCLI.md,"@@ -0,0 +1,551 @@
+<!--
+Copyright 2002-2019 The Apache Software Foundation
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+//-->
+
+# ZooKeeper-cli: the ZooKeeper command line interface
+
+## Pre-requisites
+Enter into the ZooKeeper-cli
+
+```bash
+# connect to the localhost with the default port:2181
+bin/zkCli.sh
+# connect to the remote host with timeout:3s
+bin/zkCli.sh -timeout 3000 -server remoteIP:2181
+```
+## help
+Showing helps about ZooKeeper commands
+
+```bash
+[zkshell: 1] help
+# a sample one
+[zkshell: 2] h
+ZooKeeper -server host:port cmd args
+	addauth scheme auth
+	close
+	config [-c] [-w] [-s]
+	connect host:port
+	create [-s] [-e] [-c] [-t ttl] path [data] [acl]
+	delete [-v version] path
+	deleteall path
+	delquota [-n|-b] path
+	get [-s] [-w] path
+	getAcl [-s] path
+	getAllChildrenNumber path
+	getEphemerals path
+	history
+	listquota path
+	ls [-s] [-w] [-R] path
+	ls2 path [watch]
+	printwatches on|off
+	quit
+	reconfig [-s] [-v version] [[-file path] | [-members serverID=host:port1:port2;port3[,...]*]] | [-add serverId=host:port1:port2;port3[,...]]* [-remove serverId[,...]*]
+	redo cmdno
+	removewatches path [-c|-d|-a] [-l]
+	rmr path
+	set [-s] [-v version] path data
+	setAcl [-s] [-v version] [-R] path acl
+	setquota -n|-b val path","[{'comment': 'Should we also add [] around -n|-b to make it consistent?', 'commenter': 'lvfangmin'}, {'comment': '- `[-n]`  means this option is optional，`-n|-b` means` -n `or `-b` we must choose one of them.\r\n- Look at the discussion in the [ZOOKEEPER-3299 ](https://github.com/apache/zookeeper/pull/864)', 'commenter': 'maoling'}]"
839,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -946,7 +947,7 @@ public ProcessTxnResult processTxn(TxnHeader header, Record txn, boolean isSubTx
                                                  : Code.OK.intValue();
 
                             subtxn.setType(OpCode.error);
-                            record = new ErrorTxn(ec);
+                            record = new ErrorTxn(ec, """");","[{'comment': ""You don't need to use the overloaded constructor if path is empty."", 'commenter': 'anmolnar'}, {'comment': 'jute only provides constructors below, no `ErrorTxn(int)`\r\n\r\n```java\r\n  public ErrorTxn() {\r\n  }\r\n  public ErrorTxn(\r\n        int err,\r\n        String path) {\r\n    this.err=err;\r\n    this.path=path;\r\n  }\r\n```', 'commenter': 'tisonkun'}, {'comment': ""You're right. Sorry I mixed it with `ErrorResult`."", 'commenter': 'anmolnar'}, {'comment': 'A question here maybe. Should we use `""""` or `null` to stand for ""no meaningful path""? Now I prefer the later since it explicitly represent ""non value here"".', 'commenter': 'tisonkun'}]"
839,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -795,7 +795,7 @@ protected void pRequest(Request request) throws RequestProcessorException {
                      */
                     if (ke != null) {
                         type = OpCode.error;
-                        txn = new ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue());
+                        txn = new ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue(), """");","[{'comment': 'Same here.', 'commenter': 'anmolnar'}]"
839,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -898,7 +898,7 @@ protected void pRequest(Request request) throws RequestProcessorException {
             LOG.error(""Dumping request buffer: 0x"" + sb.toString());
             if (request.getHdr() != null) {
                 request.getHdr().setType(OpCode.error);
-                request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue()));
+                request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue(), """"));","[{'comment': 'And here.', 'commenter': 'anmolnar'}]"
839,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/Zab1_0Test.java,"@@ -1250,7 +1250,7 @@ public void testInitialAcceptedCurrent() throws Exception {
             long zxid = ZxidUtils.makeZxid(3, 3);
             logFactory.append(new Request(1, 1, ZooDefs.OpCode.error,
                     new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.error),
-                    new ErrorTxn(1), zxid));
+                    new ErrorTxn(1, """"), zxid));","[{'comment': '...and here too.', 'commenter': 'anmolnar'}]"
839,zookeeper-server/src/test/java/org/apache/zookeeper/test/MultiTransactionTest.java,"@@ -154,8 +154,17 @@ public void processResult(int rc, String path, Object ctx,
                 zk.multi(ops);
                 Assert.fail(""Shouldn't have validated in ZooKeeper client!"");
             } catch (KeeperException e) {
-                Assert.assertEquals(""Wrong exception"", expectedErr, e.code()
-                        .name());
+                String[] codeAndPath = expectedErr.split(""@"");
+                if (codeAndPath.length < 1 || codeAndPath.length > 2) {
+                    Assert.fail(""Invalid exceptedErr="" + expectedErr);
+                }
+                Assert.assertEquals(""Wrong exception"", codeAndPath[0],","[{'comment': ""You shouldn't check for string match if you can access the actual type. Please use `assertThat(..., instanceOf(...))` or `assertThat(..., isA(...))`."", 'commenter': 'anmolnar'}, {'comment': 'Addressed comment', 'commenter': 'tisonkun'}]"
839,zookeeper-server/src/test/java/org/apache/zookeeper/test/MultiTransactionTest.java,"@@ -154,8 +154,17 @@ public void processResult(int rc, String path, Object ctx,
                 zk.multi(ops);
                 Assert.fail(""Shouldn't have validated in ZooKeeper client!"");
             } catch (KeeperException e) {
-                Assert.assertEquals(""Wrong exception"", expectedErr, e.code()
-                        .name());
+                String[] codeAndPath = expectedErr.split(""@"");
+                if (codeAndPath.length < 1 || codeAndPath.length > 2) {
+                    Assert.fail(""Invalid exceptedErr="" + expectedErr);
+                }
+                Assert.assertEquals(""Wrong exception"", codeAndPath[0],
+                        e.code().name());
+
+                if (codeAndPath.length == 2) {
+                    Assert.assertEquals(""Wrong exception"", codeAndPath[1],","[{'comment': 'Please add more details to the error message: e.g. path is wrong.', 'commenter': 'anmolnar'}, {'comment': 'Addressed comment', 'commenter': 'tisonkun'}]"
839,zookeeper-server/src/main/java/org/apache/zookeeper/CreateMode.java,"@@ -135,7 +135,7 @@ public static CreateMode fromFlag(int flag) throws KeeperException {
         default:
             String errMsg = ""Received an invalid flag value: "" + flag + "" to convert to a CreateMode"";
             LOG.error(errMsg);
-            throw new KeeperException.BadArgumentsException(errMsg);
+            throw new KeeperException.BadArgumentsException();","[{'comment': 'good catchm this is not a ""path"".\r\nI wonder if we can somehow preserve the ""message""\r\nI see that KeeperException has a bad way of dealing with the ""exception message"".\r\nMaybe we should clean up it.\r\nIs is so bad to keep errMsg here ? and clean up this stuff in a separate commit ?', 'commenter': 'eolivelli'}, {'comment': ""Fair enough. ZOOKEEPER-3520.\r\n\r\nIt is good to contrast with how we do in async version of `multi`. It's interesting."", 'commenter': 'tisonkun'}]"
839,zookeeper-server/src/main/java/org/apache/zookeeper/OpResult.java,"@@ -282,33 +283,42 @@ public int hashCode() {
      */
     public static class ErrorResult extends OpResult {
 
-        private int err;
+        private final int err;
+        private final String path;
 
         public ErrorResult(int err) {
+            this(err, null);
+        }
+
+        public ErrorResult(int err, String path) {
             super(ZooDefs.OpCode.error);
             this.err = err;
+            this.path = path;
         }
 
         public int getErr() {
             return err;
         }
 
+        public String getPath() {
+            return path;
+        }
+
         @Override
         public boolean equals(Object o) {
             if (this == o) {
                 return true;
             }
-            if (!(o instanceof ErrorResult)) {
+            if (o == null || getClass() != o.getClass()) {","[{'comment': 'why are you changing this line ?', 'commenter': 'eolivelli'}, {'comment': 'Update field and thus re-generate `equal` and `hashCode`. Fine to revert it.', 'commenter': 'tisonkun'}]"
839,zookeeper-jute/src/main/java/org/apache/jute/compiler/JCompType.java,"@@ -54,7 +54,7 @@ String genJavaCompareTo(String fname) {
     }
 
     String genJavaEquals(String fname, String peer) {
-        return ""    ret = "" + fname + "".equals("" + peer + "");\n"";
+        return ""    ret = java.util.Objects.equals("" + fname + "", "" + peer + "");\n"";","[{'comment': 'FYI [ZOOKEEPER-3521](https://issues.apache.org/jira/browse/ZOOKEEPER-3521). I don\'t think we are supposed to use `""""` or `""<null>""` or any other placeholder in `ErrorTxn#path` but just fix ZOOKEEPER-3521.', 'commenter': 'tisonkun'}, {'comment': 'Unless we state that jute generated s will never contain a null field. Then we can think of `""<null>""` or `""<unknown>""` or sth. else.', 'commenter': 'tisonkun'}]"
839,zookeeper-server/src/test/java/org/apache/zookeeper/test/MultiOperationTest.java,"@@ -621,7 +654,7 @@ public void testOpResultEquals() {
 
         opEquals(new DeleteResult(), new DeleteResult(), null);
 
-        opEquals(new ErrorResult(1), new ErrorResult(1), new ErrorResult(2));
+        opEquals(new ErrorResult(1, ""/foo""), new ErrorResult(1, ""/foo""), new ErrorResult(1, ""/bar""));","[{'comment': 'I intend to add a new verification, but it happens we already have \r\n\r\n```java\r\nopEquals(new ErrorResult(1), new ErrorResult(1), new ErrorResult(2));\r\n```\r\n\r\nlines above, so I add a new one and delete the duplicate one. It is not a modification.', 'commenter': 'tisonkun'}]"
850,zookeeper-server/src/main/java/org/apache/zookeeper/server/SyncRequestProcessor.java,"@@ -175,9 +182,14 @@ private void flush(LinkedList<Request> toFlush)
         if (toFlush.isEmpty())
             return;
 
+        LOG.info(""flush size {}"", toFlush.size());","[{'comment': 'Do we need this at info level? Is it useful?\r\nOnly asking', 'commenter': 'eolivelli'}, {'comment': 'removed', 'commenter': 'jhuan31'}]"
850,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/SyncRequestProcessorMetricTest.java,"@@ -0,0 +1,82 @@
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.server.*;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.nio.ByteBuffer;
+import java.util.Map;
+
+import static org.hamcrest.number.OrderingComparison.greaterThan;
+import static org.hamcrest.number.OrderingComparison.greaterThanOrEqualTo;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+public class SyncRequestProcessorMetricTest {
+    ZooKeeperServer zks;
+
+
+    @Before
+    public void setup() throws Exception {
+        ZKDatabase db = mock(ZKDatabase.class);
+        when(db.append(any(Request.class))).thenReturn(true);
+        doAnswer(invocation->{
+            Thread.sleep(100);
+            return null;
+        }).when(db).commit();
+        zks = mock(ZooKeeperServer.class);
+        when(zks.getZKDatabase()).thenReturn(db);
+    }
+
+    @After","[{'comment': 'Can we drop this empty method?', 'commenter': 'eolivelli'}, {'comment': 'removed', 'commenter': 'jhuan31'}]"
850,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/SyncRequestProcessorMetricTest.java,"@@ -0,0 +1,82 @@
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.server.*;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.nio.ByteBuffer;
+import java.util.Map;
+
+import static org.hamcrest.number.OrderingComparison.greaterThan;
+import static org.hamcrest.number.OrderingComparison.greaterThanOrEqualTo;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+public class SyncRequestProcessorMetricTest {
+    ZooKeeperServer zks;
+
+
+    @Before
+    public void setup() throws Exception {
+        ZKDatabase db = mock(ZKDatabase.class);
+        when(db.append(any(Request.class))).thenReturn(true);
+        doAnswer(invocation->{
+            Thread.sleep(100);
+            return null;
+        }).when(db).commit();
+        zks = mock(ZooKeeperServer.class);
+        when(zks.getZKDatabase()).thenReturn(db);
+    }
+
+    @After
+    public void tearDown() {
+
+    }
+
+    private Request createRquest(long sessionId, int xid) {
+        return new Request(null, sessionId, xid, ZooDefs.OpCode.setData,
+                ByteBuffer.wrap(new byte[10]), null);
+    }
+
+    @Test
+    public void testSyncProcessorMetrics() {
+        SyncRequestProcessor syncProcessor = new SyncRequestProcessor(zks, null);
+        for (int i=0; i<500; i++) {
+            syncProcessor.processRequest(createRquest(1, i));
+        }
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+        Assert.assertEquals(500L, values.get(""sync_processor_request_queued""));
+
+        syncProcessor.start();
+
+        try {
+            Thread.sleep(500);
+        } catch (Exception e){","[{'comment': 'Why?\r\nIf you get an IE the test will fail, not a big deal', 'commenter': 'eolivelli'}, {'comment': 'modified', 'commenter': 'jhuan31'}]"
850,zookeeper-server/src/main/java/org/apache/zookeeper/server/SyncRequestProcessor.java,"@@ -117,49 +119,41 @@ public void run() {
                 if (si == requestOfDeath) {
                     break;
                 }
-                if (si != null) {
-                    // track the number of records written to the log
-                    if (zks.getZKDatabase().append(si)) {
-                        logCount++;
-                        if (logCount > (snapCount / 2 + randRoll)) {
-                            randRoll = r.nextInt(snapCount/2);
-                            // roll the log
-                            zks.getZKDatabase().rollLog();
-                            // take a snapshot
-                            if (snapInProcess != null && snapInProcess.isAlive()) {
-                                LOG.warn(""Too busy to snap, skipping"");
-                            } else {
-                                snapInProcess = new ZooKeeperThread(""Snapshot Thread"") {
-                                        public void run() {
-                                            try {
-                                                zks.takeSnapshot();
-                                            } catch(Exception e) {
-                                                LOG.warn(""Unexpected exception"", e);
-                                            }
+                long startProcessTime = Time.currentElapsedTime();
+                ServerMetrics.SYNC_PROCESSOR_REAL_QUEUE_TIME.add(
+                        startProcessTime - si.syncQueueStartTime);
+                // track the number of records written to the log
+                if (zks.getZKDatabase().append(si)) {
+                    logCount++;
+                    if (logCount > (snapCount / 2 + randRoll)) {
+                        randRoll = r.nextInt(snapCount/2);
+                        // roll the log
+                        zks.getZKDatabase().rollLog();
+                        // take a snapshot
+                        if (snapInProcess != null && snapInProcess.isAlive()) {
+                            LOG.warn(""Too busy to snap, skipping"");
+                        } else {
+                            snapInProcess = new ZooKeeperThread(""Snapshot Thread"") {
+                                    public void run() {
+                                        try {
+                                            zks.takeSnapshot();
+                                        } catch(Exception e) {
+                                            LOG.warn(""Unexpected exception"", e);
                                         }
-                                    };
-                                snapInProcess.start();
-                            }
-                            logCount = 0;
+                                    }
+                                };
+                            snapInProcess.start();
                         }
-                    } else if (toFlush.isEmpty()) {","[{'comment': ""This is the legacy code which won't be used now, we can get rid of it, but it's better to keep each PR simple with a single purpose, which will make the code review and the future reference easier.\r\n\r\nIf spotbugs complains things which not caused by the change here, we should leave it as is, and fix it in another PR."", 'commenter': 'lvfangmin'}, {'comment': 'PR 853', 'commenter': 'jhuan31'}]"
850,zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerMetrics.java,"@@ -74,6 +74,16 @@
     CONNECTION_TOKEN_DEFICIT(new AvgMinMaxCounter(""connection_token_deficit"")),
     CONNECTION_REJECTED(new SimpleCounter(""connection_rejected"")),
 
+    SYNC_PROCESSOR_QUEUE_TIME(new AvgMinMaxPercentileCounter(""sync_processor_queue_time_ms"")),
+    SYNC_PROCESSOR_QUEUE_SIZE(new AvgMinMaxCounter(""sync_processor_queue_size"")),
+    SYNC_PROCESSOR_QUEUED(new SimpleCounter(""sync_processor_request_queued"")),
+    SYNC_PROCESSOR_REAL_QUEUE_TIME(new AvgMinMaxPercentileCounter(""sync_processor_real_queue_time_ms"")),","[{'comment': ""Let's remove this one, and change SYNC_PROCESSOR_QUEUE_TIME to track the real queue time."", 'commenter': 'lvfangmin'}, {'comment': 'done', 'commenter': 'jhuan31'}]"
850,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/SyncRequestProcessorMetricTest.java,"@@ -0,0 +1,90 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.metrics.MetricsUtils;
+import org.apache.zookeeper.server.*;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.nio.ByteBuffer;
+import java.util.Map;
+
+import static org.hamcrest.number.OrderingComparison.greaterThan;
+import static org.hamcrest.number.OrderingComparison.greaterThanOrEqualTo;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+public class SyncRequestProcessorMetricTest {
+    ZooKeeperServer zks;
+
+    @Before
+    public void setup() throws Exception {
+        ZKDatabase db = mock(ZKDatabase.class);
+        when(db.append(any(Request.class))).thenReturn(true);
+        doAnswer(invocation->{
+            Thread.sleep(100);
+            return null;
+        }).when(db).commit();
+        zks = mock(ZooKeeperServer.class);
+        when(zks.getZKDatabase()).thenReturn(db);
+    }
+
+    private Request createRquest(long sessionId, int xid) {
+        return new Request(null, sessionId, xid, ZooDefs.OpCode.setData,
+                ByteBuffer.wrap(new byte[10]), null);
+    }
+
+    @Test
+    public void testSyncProcessorMetrics() throws  Exception{
+        SyncRequestProcessor syncProcessor = new SyncRequestProcessor(zks, null);
+        for (int i=0; i<500; i++) {
+            syncProcessor.processRequest(createRquest(1, i));
+        }
+
+        Map<String, Object> values = MetricsUtils.currentServerMetrics();
+        Assert.assertEquals(500L, values.get(""sync_processor_request_queued""));
+
+        syncProcessor.start();
+
+
+        Thread.sleep(500);","[{'comment': 'Sign of a flaky maybe?', 'commenter': 'anmolnar'}, {'comment': 'Changed to use a countDown latch. Thanks!', 'commenter': 'jhuan31'}]"
850,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/SyncRequestProcessorMetricTest.java,"@@ -0,0 +1,102 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.metrics.MetricsUtils;
+import org.apache.zookeeper.server.*;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.nio.ByteBuffer;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.hamcrest.number.OrderingComparison.greaterThan;
+import static org.hamcrest.number.OrderingComparison.greaterThanOrEqualTo;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+public class SyncRequestProcessorMetricTest {
+    ZooKeeperServer zks;
+    RequestProcessor nextProcessor;
+    CountDownLatch allRequestsFlushed;
+
+    @Before
+    public void setup() throws Exception {
+        ZKDatabase db = mock(ZKDatabase.class);
+        when(db.append(any(Request.class))).thenReturn(true);
+        doAnswer(invocation->{
+            Thread.sleep(100);
+            return null;
+        }).when(db).commit();
+        zks = mock(ZooKeeperServer.class);
+        when(zks.getZKDatabase()).thenReturn(db);
+
+        nextProcessor = mock(RequestProcessor.class);
+        doAnswer(invocationOnMock -> {
+            allRequestsFlushed.countDown();
+            return null;
+        }).when(nextProcessor).processRequest(any(Request.class));
+    }
+
+    private Request createRquest(long sessionId, int xid) {
+        return new Request(null, sessionId, xid, ZooDefs.OpCode.setData,
+                ByteBuffer.wrap(new byte[10]), null);
+    }
+
+    @Test
+    public void testSyncProcessorMetrics() throws  Exception{
+        SyncRequestProcessor syncProcessor = new SyncRequestProcessor(zks, nextProcessor);
+        for (int i=0; i<500; i++) {
+            syncProcessor.processRequest(createRquest(1, i));
+        }
+
+        Map<String, Object> values = MetricsUtils.currentServerMetrics();
+        Assert.assertEquals(500L, values.get(""sync_processor_request_queued""));
+
+        allRequestsFlushed = new CountDownLatch(500);
+        syncProcessor.start();","[{'comment': 'Very last nit: we are not closing/stopping it. \r\nSo we will leak a few test resources.\r\n', 'commenter': 'eolivelli'}]"
850,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/SyncRequestProcessorMetricTest.java,"@@ -0,0 +1,102 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.metrics.MetricsUtils;
+import org.apache.zookeeper.server.*;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.nio.ByteBuffer;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.hamcrest.number.OrderingComparison.greaterThan;
+import static org.hamcrest.number.OrderingComparison.greaterThanOrEqualTo;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+public class SyncRequestProcessorMetricTest {
+    ZooKeeperServer zks;
+    RequestProcessor nextProcessor;
+    CountDownLatch allRequestsFlushed;
+
+    @Before
+    public void setup() throws Exception {
+        ZKDatabase db = mock(ZKDatabase.class);
+        when(db.append(any(Request.class))).thenReturn(true);
+        doAnswer(invocation->{
+            Thread.sleep(100);
+            return null;
+        }).when(db).commit();
+        zks = mock(ZooKeeperServer.class);
+        when(zks.getZKDatabase()).thenReturn(db);
+
+        nextProcessor = mock(RequestProcessor.class);
+        doAnswer(invocationOnMock -> {
+            allRequestsFlushed.countDown();
+            return null;
+        }).when(nextProcessor).processRequest(any(Request.class));
+    }
+
+    private Request createRquest(long sessionId, int xid) {
+        return new Request(null, sessionId, xid, ZooDefs.OpCode.setData,
+                ByteBuffer.wrap(new byte[10]), null);
+    }
+
+    @Test
+    public void testSyncProcessorMetrics() throws  Exception{
+        SyncRequestProcessor syncProcessor = new SyncRequestProcessor(zks, nextProcessor);
+        for (int i=0; i<500; i++) {
+            syncProcessor.processRequest(createRquest(1, i));
+        }
+
+        Map<String, Object> values = MetricsUtils.currentServerMetrics();
+        Assert.assertEquals(500L, values.get(""sync_processor_request_queued""));
+
+        allRequestsFlushed = new CountDownLatch(500);
+        syncProcessor.start();
+
+        allRequestsFlushed.await(500, TimeUnit.MILLISECONDS);","[{'comment': 'We can use a greater timeout, in order to deal with temporary overloaded test machines.\r\nI suggest 5000', 'commenter': 'eolivelli'}]"
851,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -145,6 +145,10 @@
     private ZooKeeperServerShutdownHandler zkShutdownHandler;
     private volatile int createSessionTrackerServerId = 1;
 
+    private static volatile long flushDelay = Long.getLong(""zookeeper.flushDelay"", 0);","[{'comment': 'Can we have these variables as instance variables?', 'commenter': 'eolivelli'}, {'comment': ""Them being static is in support of the values being alterable via jmx. Without this, the admin is stuck resetting the values every time a new ZooKeeperServer is instantiated. \r\n\r\nIn my mind, it's a question of how to support this style of setting: via static variables close to the code that uses them or via non-static mutable config (such as QuorumPeerConfig)."", 'commenter': 'enixon'}, {'comment': ""It's better to log those env settings."", 'commenter': 'lvfangmin'}]"
851,zookeeper-server/src/main/java/org/apache/zookeeper/server/SyncRequestProcessor.java,"@@ -95,6 +98,28 @@ public static int getSnapCount() {
         return snapCount;
     }
 
+    private long getRemainingDelay() {
+        long flushDelay = zks.getFlushDelay();
+        long duration = Time.currentElapsedTime() - lastFlushTime;
+        if (duration < flushDelay) {
+            return flushDelay - duration;
+        }
+        return 0;
+    }
+
+    /* If both flushDelay and maxMaxBatchSize are set (> 0), flush","[{'comment': 'nit: /* -> /**', 'commenter': 'lvfangmin'}]"
851,zookeeper-server/src/main/java/org/apache/zookeeper/server/SyncRequestProcessor.java,"@@ -139,9 +163,12 @@ public void run() {
             // we do this in an attempt to ensure that not all of the servers
             // in the ensemble take a snapshot at the same time
             resetSnapshotStats();
+            lastFlushTime = Time.currentElapsedTime();
             while (true) {
-                Request si = queuedRequests.poll();
+                long pollTime = Math.min(zks.getMaxWriteQueuePollTime(), getRemainingDelay());
+                Request si = queuedRequests.poll(pollTime, TimeUnit.MILLISECONDS);","[{'comment': 'Could this `LinkedBlockingQueue.poll` lead to a fair amount of spinning when a non-zero `pollTime` is specified? In my use case in the order of ten thousand transactions/sec I have seen CPU usage explode from 3-5% to 30-40%, sending my adjoining ClickHouse cluster to its knees. I should add that total fsync time did improve 😄 ', 'commenter': 'larry-cdn77'}]"
853,zookeeper-server/src/main/java/org/apache/zookeeper/server/SyncRequestProcessor.java,"@@ -117,48 +117,35 @@ public void run() {
                 if (si == requestOfDeath) {
                     break;
                 }
-                if (si != null) {
-                    // track the number of records written to the log
-                    if (zks.getZKDatabase().append(si)) {
-                        logCount++;
-                        if (logCount > (snapCount / 2 + randRoll)) {
-                            randRoll = r.nextInt(snapCount/2);
-                            // roll the log
-                            zks.getZKDatabase().rollLog();
-                            // take a snapshot
-                            if (snapInProcess != null && snapInProcess.isAlive()) {
-                                LOG.warn(""Too busy to snap, skipping"");
-                            } else {
-                                snapInProcess = new ZooKeeperThread(""Snapshot Thread"") {
-                                        public void run() {
-                                            try {
-                                                zks.takeSnapshot();
-                                            } catch(Exception e) {
-                                                LOG.warn(""Unexpected exception"", e);
-                                            }
+
+                // track the number of records written to the log
+                if (zks.getZKDatabase().append(si)) {
+                    logCount++;
+                    if (logCount > (snapCount / 2 + randRoll)) {
+                        randRoll = r.nextInt(snapCount/2);
+                        // roll the log
+                        zks.getZKDatabase().rollLog();
+                        // take a snapshot
+                        if (snapInProcess != null && snapInProcess.isAlive()) {
+                            LOG.warn(""Too busy to snap, skipping"");
+                        } else {
+                            snapInProcess = new ZooKeeperThread(""Snapshot Thread"") {
+                                    public void run() {
+                                        try {
+                                            zks.takeSnapshot();
+                                        } catch(Exception e) {
+                                            LOG.warn(""Unexpected exception"", e);
                                         }
-                                    };
-                                snapInProcess.start();
-                            }
-                            logCount = 0;
-                        }
-                    } else if (toFlush.isEmpty()) {
-                        // optimization for read heavy workloads","[{'comment': 'Seems that the branch described as an ""optimization"", introduced with https://issues.apache.org/jira/browse/ZOOKEEPER-568  is not really executed.\r\nThis patch is dropping that branch, this is fine, as it is never executed.\r\n\r\nI wonder if we could resume somehow the reasoning behind ZOOKEEPER-568, for the future I mean\r\n\r\ncc @breed @phunt ', 'commenter': 'eolivelli'}]"
855,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -157,8 +160,8 @@ public void run() {
 
     private ChangeRecord getRecordForPath(String path) throws KeeperException.NoNodeException {
         ChangeRecord lastChange = null;
-        synchronized (zks.outstandingChanges) {
-            lastChange = zks.outstandingChangesForPath.get(path);
+        synchronized (zks.getOutstandingChanges()) {","[{'comment': 'Can you call the getter outside the synchronized block and then. Use the reference to the returned object?\r\nIt will be clearer that we are accessing the same object', 'commenter': 'eolivelli'}, {'comment': ""I wasn't feeling comfortable doing this either. Even calling the getter outside is not satisfying because this object is being used in many places. How about we add the field in PrepRequestProcessor and make it final and initialize it in the constructor?"", 'commenter': 'jhuan31'}, {'comment': 'Okay', 'commenter': 'eolivelli'}]"
855,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -183,10 +186,12 @@ private ChangeRecord getOutstandingChange(String path) {
         }
     }
 
-    private void addChangeRecord(ChangeRecord c) {
-        synchronized (zks.outstandingChanges) {
-            zks.outstandingChanges.add(c);
-            zks.outstandingChangesForPath.put(c.path, c);
+    protected void addChangeRecord(ChangeRecord c) {
+        LOG.info(""addChangeRecord called"");","[{'comment': 'Is this a debug to drop?', 'commenter': 'eolivelli'}, {'comment': 'yes. will do.', 'commenter': 'jhuan31'}]"
855,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -588,10 +593,11 @@ protected void pRequest2Txn(int type, long zxid, Request request,
                 // queues up this operation without being the session owner.
                 // this request is the last of the session so it should be ok
                 //zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+                long startTime =  Time.currentElapsedTime();
                 Set<String> es = zks.getZKDatabase()
                         .getEphemerals(request.sessionId);
-                synchronized (zks.outstandingChanges) {
-                    for (ChangeRecord c : zks.outstandingChanges) {
+                synchronized (zks.getOutstandingChanges()) {
+                    for (ChangeRecord c : zks.getOutstandingChanges()) {","[{'comment': 'Same as above', 'commenter': 'eolivelli'}]"
855,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -902,6 +909,7 @@ protected void pRequest(Request request) throws RequestProcessorException {
             }
         }
         request.zxid = zks.getZxid();
+        ServerMetrics.PREP_PROCESSOR_QUEUE_TIME.add(Time.currentElapsedTime() - request.prepQueueStartTime);","[{'comment': 'What happens if prepQueueStartTime stay the default value -1 ?', 'commenter': 'eolivelli'}, {'comment': ""A request that has got here must have gone through processRequest(), which records prepQueueStartTime(). Can't think of a scenario that it stays -1. "", 'commenter': 'jhuan31'}]"
855,zookeeper-server/src/main/java/org/apache/zookeeper/server/Request.java,"@@ -78,6 +78,8 @@ public Request(long sessionId, int xid, int type, TxnHeader hdr, Record txn, lon
 
     public final long createTime = Time.currentElapsedTime();
 
+    public long prepQueueStartTime= -1;","[{'comment': 'Is -1 meaningful?', 'commenter': 'eolivelli'}, {'comment': 'no :)', 'commenter': 'jhuan31'}]"
855,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -231,6 +231,14 @@ public ZooKeeperServer(FileTxnSnapLog txnLogFactory, int tickTime)
         this(txnLogFactory, tickTime, -1, -1, -1, new ZKDatabase(txnLogFactory));
     }
 
+    public Deque<ChangeRecord> getOutstandingChanges() {
+        return outstandingChanges;","[{'comment': 'Can we make this field private as we are encapsulating it?', 'commenter': 'eolivelli'}, {'comment': ""I've changed the unit test so it doesn't need the getter anymore. So this field stays as is. Alos reverted the code to access the field directly (which is not nice) instead of calling the getter"", 'commenter': 'jhuan31'}]"
855,zookeeper-server/src/test/java/org/apache/zookeeper/server/PrepRequestProcessorMetricsTest.java,"@@ -0,0 +1,175 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import jline.internal.Log;
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.data.StatPersisted;
+import org.apache.zookeeper.proto.DeleteRequest;
+import org.apache.zookeeper.proto.SetDataRequest;
+import org.apache.zookeeper.server.ZooKeeperServer.ChangeRecord;
+import org.apache.zookeeper.test.ClientBase;
+import org.apache.zookeeper.test.QuorumUtil;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.nio.ByteBuffer;
+import java.util.*;
+
+import static org.hamcrest.number.OrderingComparison.greaterThan;
+import static org.hamcrest.number.OrderingComparison.greaterThanOrEqualTo;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+public class PrepRequestProcessorMetricsTest extends ZKTestCase {
+    private static final Logger LOG = LoggerFactory.getLogger(PrepRequestProcessorMetricsTest.class);
+
+    ZooKeeperServer zks;
+    RequestProcessor nextProcessor;
+    boolean oldSkipAcl;
+
+
+    @Before
+    public void setup() throws Exception {
+        oldSkipAcl = PrepRequestProcessor.skipACL;
+
+        zks = spy(new ZooKeeperServer());
+        zks.sessionTracker = mock(SessionTracker.class);
+
+        ZKDatabase db = mock(ZKDatabase.class);
+        when(zks.getZKDatabase()).thenReturn(db);
+
+        DataNode node = new DataNode(new byte[1], null, mock(StatPersisted.class));
+        when(db.getNode(anyString())).thenReturn(node);
+
+        Set<String> ephemerals = new HashSet<>();
+        ephemerals.add(""/crystalmountain"");
+        ephemerals.add(""/stevenspass"");
+        when(db.getEphemerals(anyLong())).thenReturn(ephemerals);
+
+        nextProcessor = mock(RequestProcessor.class);
+
+        ServerMetrics.resetAll();
+    }
+
+    @After
+    public void teardown() {
+        PrepRequestProcessor.skipACL = oldSkipAcl;
+    }
+
+    private Request createRequest(Record record, int opCode) throws IOException {
+        // encoding
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
+        record.serialize(boa, ""request"");
+        baos.close();
+        return new Request(null, 1l, 0, opCode, ByteBuffer.wrap(baos.toByteArray()), null);
+    }
+
+    private Request createRequest(String path, int opCode) throws IOException {
+        Record record;
+        switch (opCode) {
+            case ZooDefs.OpCode.setData:
+                record = new SetDataRequest(path, new byte[0], -1);
+                break;
+            case ZooDefs.OpCode.delete:
+                record = new DeleteRequest(path, -1);
+                break;
+            default:
+                record = new DeleteRequest(path, -1);
+                break;
+        }
+
+        return createRequest(record, opCode);
+    }
+
+    private Request createRequest(long sessionId, int opCode) {
+        return new Request(null, sessionId, 0, opCode, null, null);
+    }
+
+    @Test
+    public void testPrepRequestProcessorMetrics() throws Exception {
+        PrepRequestProcessor prepRequestProcessor = new PrepRequestProcessor(zks, nextProcessor);
+        PrepRequestProcessor.skipACL = true;
+
+        //setData will generate one change
+        prepRequestProcessor.processRequest(createRequest(""/foo"", ZooDefs.OpCode.setData));
+        //delete will generate two changes, one for itself, one for its parent
+        prepRequestProcessor.processRequest(createRequest(""/foo/bar"", ZooDefs.OpCode.delete));
+        //mocking two ephemeral nodes exists for this session so two changes
+        prepRequestProcessor.processRequest(createRequest(2, ZooDefs.OpCode.closeSession));
+
+        Map<String, Object> values = ServerMetrics.getAllValues();
+        Assert.assertEquals(3L, values.get(""prep_processor_request_queued""));
+
+        prepRequestProcessor.start();
+
+        Thread.sleep(500);","[{'comment': 'Mentioned lots of times before that sleeping in unit tests is not a good practice. (not in production code either)\r\nPlease try to sync with latches or rather drop the tests instead of introducing new flakies.', 'commenter': 'anmolnar'}, {'comment': 'fixed', 'commenter': 'jhuan31'}]"
858,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java,"@@ -101,6 +101,14 @@ public String toString() {
 
     private final LearnerSnapshotThrottler learnerSnapshotThrottler;
 
+    // log ack latency if zxid is a multiple of ackLoggingFrequency. If <=0, disable logging.
+    protected static final String ACK_LOGGING_FREQUENCY = ""zookeeper.leader.ackLoggingFrequency"";
+    private static final int ackLoggingFrequency;
+    static {
+        ackLoggingFrequency = Integer.getInteger(ACK_LOGGING_FREQUENCY, 1000);","[{'comment': 'not for this patch\r\n@anmolnar  @phunt we should introduce a common facility to get system properties and log them', 'commenter': 'eolivelli'}, {'comment': ""Can't agree more! "", 'commenter': 'jhuan31'}, {'comment': '`ZKConfig`?', 'commenter': 'anmolnar'}]"
858,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/LeaderMetricsTest.java,"@@ -0,0 +1,82 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.*;
+import org.apache.zookeeper.server.ServerMetrics;
+import org.apache.zookeeper.test.ClientBase;
+import org.apache.zookeeper.test.QuorumUtil;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+
+import static org.hamcrest.number.OrderingComparison.greaterThan;
+import static org.hamcrest.number.OrderingComparison.greaterThanOrEqualTo;
+
+public class LeaderMetricsTest extends ZKTestCase {
+    CountDownLatch createdLatch;
+
+    private class MyWatcher implements Watcher {
+        @Override
+        public void process(WatchedEvent e){
+            createdLatch.countDown();
+        }
+    }
+
+    @Test
+    public void testLeaderMetrics() throws Exception {
+        // set the logging frequency to one so we log the ack latency for every ack
+        System.setProperty(Leader.ACK_LOGGING_FREQUENCY, ""1"");","[{'comment': ""This won't work if Leader class has already been initialized.\r\nIt is better to make the variable accessible and change the value"", 'commenter': 'eolivelli'}, {'comment': 'changed', 'commenter': 'jhuan31'}]"
858,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/LeaderMetricsTest.java,"@@ -0,0 +1,85 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.*;
+import org.apache.zookeeper.server.ServerMetrics;
+import org.apache.zookeeper.test.ClientBase;
+import org.apache.zookeeper.test.QuorumUtil;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+
+import static org.hamcrest.number.OrderingComparison.greaterThan;
+import static org.hamcrest.number.OrderingComparison.greaterThanOrEqualTo;
+
+public class LeaderMetricsTest extends ZKTestCase {
+    CountDownLatch createdLatch;
+
+    private class MyWatcher implements Watcher {
+        @Override
+        public void process(WatchedEvent e){
+            createdLatch.countDown();
+        }
+    }
+    
+    @Test
+    public void testLeaderMetrics() throws Exception {
+        // set the logging frequency to one so we log the ack latency for every ack
+        Leader.setAckLoggingFrequency(1);","[{'comment': 'Last nit:\r\nWe have to restore the initial value in a finally block, otherwise this test will affect all of the other tests executed after it', 'commenter': 'eolivelli'}, {'comment': 'yeap. fixed', 'commenter': 'jhuan31'}]"
859,zookeeper-server/src/test/java/org/apache/zookeeper/server/persistence/FileTxnSnapLogMetricsTest.java,"@@ -0,0 +1,52 @@
+package org.apache.zookeeper.server.persistence;
+
+import org.apache.zookeeper.*;
+import org.apache.zookeeper.server.ServerMetrics;
+import org.apache.zookeeper.server.SyncRequestProcessor;
+import org.apache.zookeeper.test.ClientBase;
+import org.apache.zookeeper.test.QuorumUtil;
+import org.junit.Assert;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Map;
+
+import static org.hamcrest.number.OrderingComparison.greaterThan;
+import static org.hamcrest.number.OrderingComparison.greaterThanOrEqualTo;
+
+public class FileTxnSnapLogMetricsTest extends ZKTestCase {
+
+    @Test
+    public void testFileTxnSnapLogMetrics() throws Exception {
+        SyncRequestProcessor.setSnapCount(100);
+
+        QuorumUtil util = new QuorumUtil(1);
+        util.startAll();
+
+        byte[] data = new byte[500];
+        // make sure a snapshot is taken and some txns are not in a snapshot
+        ZooKeeper zk = ClientBase.createZKClient(util.getConnString());
+        for (int i=0; i<150; i++){
+            zk.create(""/path"" + i, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+        }
+
+        Thread.sleep(500);","[{'comment': ""why do we need this sleep ?\r\nThis would be a flaky test in the future,\r\ncan't we wait for a condition ?"", 'commenter': 'eolivelli'}, {'comment': 'fixed', 'commenter': 'jhuan31'}]"
859,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -30,11 +30,9 @@
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.KeeperException.Code;
 import org.apache.zookeeper.ZooDefs.OpCode;
-import org.apache.zookeeper.server.DataTree;
+import org.apache.zookeeper.common.Time;
+import org.apache.zookeeper.server.*;","[{'comment': ""Please don't use wildcard imports."", 'commenter': 'anmolnar'}, {'comment': 'fixed. It was auto-corrected by IntelliJ :(', 'commenter': 'jhuan31'}]"
859,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -280,6 +283,7 @@ public long fastForwardFromEdits(DataTree dt, Map<Long, Integer> sessions,
                 }
                 try {
                     processTransaction(hdr,dt,sessions, itr.getTxn());
+                    txnLoaded ++;","[{'comment': 'Extra whitespace in the command.', 'commenter': 'anmolnar'}, {'comment': 'removed', 'commenter': 'jhuan31'}]"
859,zookeeper-server/src/test/java/org/apache/zookeeper/server/persistence/FileTxnSnapLogMetricsTest.java,"@@ -0,0 +1,87 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.persistence;
+
+import org.apache.zookeeper.*;","[{'comment': 'Same here.', 'commenter': 'anmolnar'}, {'comment': 'fixed', 'commenter': 'jhuan31'}]"
859,zookeeper-server/src/test/java/org/apache/zookeeper/test/QuorumUtil.java,"@@ -29,6 +29,7 @@
 import java.util.Map;
 import java.util.Set;
 
+import jline.internal.Log;","[{'comment': 'I think this was left in by mistake?', 'commenter': 'anmolnar'}, {'comment': 'removed.', 'commenter': 'jhuan31'}]"
862,zookeeper-server/src/test/java/org/apache/zookeeper/server/ZooKeeperCriticalThreadMetricsTest.java,"@@ -0,0 +1,88 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.data.StatPersisted;
+import org.apache.zookeeper.proto.DeleteRequest;
+import org.apache.zookeeper.proto.SetDataRequest;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.*;
+
+public class ZooKeeperCriticalThreadMetricsTest extends ZKTestCase {
+
+    private class MyRequestProcessor implements RequestProcessor {
+        @Override
+        public void processRequest(Request request) throws RequestProcessorException {
+            // use this dummy request processor to trigger a unrecoverable ex
+            throw new RequestProcessorException(""test"", new Exception());
+        }
+
+        @Override
+        public void shutdown() {
+        }
+    }
+
+    private Request createRquest(long sessionId, int xid) {
+        return new Request(null, sessionId, xid, ZooDefs.OpCode.setData,
+                ByteBuffer.wrap(new byte[10]), null);
+    }
+
+    @Test
+    public void testUnrecoverableErrorCount() throws Exception{
+        ServerMetrics.resetAll();
+
+        PrepRequestProcessor processor =new PrepRequestProcessor(new ZooKeeperServer(), new MyRequestProcessor());
+        processor.start();
+
+        processor.processRequest(createRquest(1L, 1));
+        Thread.sleep(200);","[{'comment': 'Is this sleep needed?', 'commenter': 'eolivelli'}, {'comment': 'Need some sort of wait coz the request is added in the test thread and processed in the requestProcessor thread. Was being lazy since sleep is simple :) Changed to wait on a condition. ', 'commenter': 'jhuan31'}, {'comment': 'Thanks. We try to avoid Thread.sleeps in unit tests, because they just make our already unstable testing environment more fragile.', 'commenter': 'anmolnar'}]"
863,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -839,12 +839,17 @@ private void resetConnectionThreadCount() {
      */
     public class Listener extends ZooKeeperThread {
 
+        private final int portBindMaxRetry;
         volatile ServerSocket ss = null;
 
         public Listener() {
             // During startup of thread, thread name will be overridden to
             // specific election address
             super(""ListenerThread"");
+
+            // maximum retry count while trying to bind to election port
+            // see ZOOKEEPER-3320 for more details
+            portBindMaxRetry = Integer.getInteger(""zookeeper.electionPortBindRetry"", 3);","[{'comment': ""I'd recommend adding an info log that says what this property is set to when it reads and some validation in place to make sure the property is not negative.\r\n\r\nOverall change seems reasonable - let's see what the others think."", 'commenter': 'enixon'}, {'comment': 'Add logs and validation', 'commenter': 'Lagrang'}]"
863,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -853,12 +852,30 @@ private void resetConnectionThreadCount() {
      */
     public class Listener extends ZooKeeperThread {","[{'comment': ""Shouldn't listener extend ZKCriticalThread? I think this might have gotten lost in the rebase process?"", 'commenter': 'nkalmar'}, {'comment': 'I reverted this change, because master branch has code which covers my error case. Current code calls System.exit() if(!shutdown and last_exception is SocketException). ', 'commenter': 'Lagrang'}, {'comment': 'Ok, thanks.', 'commenter': 'nkalmar'}]"
863,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/CnxManagerTest.java,"@@ -290,6 +290,35 @@ public void testCnxManagerSpinLock() throws Exception {
         Assert.assertFalse(cnxManager.listener.isAlive());
     }
 
+    /**
+     * Test for bug described in {@link https://issues.apache.org/jira/browse/ZOOKEEPER-3320}.
+     * Test create peer with address which contains unresolvable DNS name,
+     * leader election listener thread should stop after N errors.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testCnxManagerListenerThreadConfigurableRetry() throws Exception {
+        final Map<Long,QuorumServer> unresolvablePeers = new HashMap<>();
+        final long myid = 1L;
+        unresolvablePeers.put(myid, new QuorumServer(myid, ""unresolvable-domain.org:2182:2183;2181""));
+        final QuorumPeer peer = new QuorumPeer(unresolvablePeers,
+                                               ClientBase.createTmpDir(),
+                                               ClientBase.createTmpDir(),
+                                               2181, 3, myid, 1000, 2, 2);","[{'comment': 'There is no constructor like this on master. You also need to add a ServerCnxnFactory.', 'commenter': 'nkalmar'}, {'comment': 'Fixed', 'commenter': 'Lagrang'}]"
865,conf/zoo_sample.cfg,"@@ -1,28 +1,29 @@
 # The number of milliseconds of each tick
 tickTime=2000
-# The number of ticks that the initial 
+# The number of ticks that the initial
 # synchronization phase can take
 initLimit=10
-# The number of ticks that can pass between 
+# The number of ticks that can pass between
 # sending a request and getting an acknowledgement
 syncLimit=5
 # the directory where the snapshot is stored.
-# do not use /tmp for storage, /tmp here is just 
-# example sakes.
-dataDir=/tmp/zookeeper
+# do not use /tmp for storage!!!.
+dataDir=/var/lib/zookeeper/data","[{'comment': 'I am not sure this is so safe.\r\n\r\nThis is just an example file and it is only for dev/testing purpose.\r\n\r\nTherefore it is not sure that an user/developer  is able to write into that directory', 'commenter': 'eolivelli'}, {'comment': 'Oh, I know. But some people use this config for their production environment. \r\nIs is awful ? Yes!  Maybe this config no good as example, but is good for operations engineer who are supported production system after `newbie DevOps` engineers. Maybe you have ideas on this?', 'commenter': 'kshvakov'}, {'comment': 'Look at an example from [kafka](https://github.com/apache/kafka/blob/trunk/config/server.properties#L60) which also use the `/tmp` as the default dir to store the logs', 'commenter': 'maoling'}, {'comment': ""@maoling I know it, it's look like \r\n![time bomb](https://i.imgur.com/EL1RN4A.gif)\r\n* I had 2 production installation whith `log.dirs=/tmp/kafka-logs` in last year.   "", 'commenter': 'kshvakov'}, {'comment': '![image](https://user-images.githubusercontent.com/11016631/54836486-4173f280-4cff-11e9-9360-c68aba7b893e.png)\r\n', 'commenter': 'maoling'}]"
869,zookeeper-server/src/main/java/org/apache/zookeeper/server/SyncRequestProcessor.java,"@@ -102,103 +108,95 @@ public void run() {
 
             // we do this in an attempt to ensure that not all of the servers
             // in the ensemble take a snapshot at the same time
-            int randRoll = r.nextInt(snapCount/2);
+            int randRoll = ThreadLocalRandom.current().nextInt(snapCount / 2, snapCount);
             while (true) {
-                Request si = null;
-                if (toFlush.isEmpty()) {
+                Request si = queuedRequests.poll();
+                if (si == null) {
+                    flush();
                     si = queuedRequests.take();
-                } else {
-                    si = queuedRequests.poll();
-                    if (si == null) {
-                        flush(toFlush);
-                        continue;
-                    }
                 }
-                if (si == requestOfDeath) {
+
+                if (si == REQUEST_OF_DEATH) {
                     break;
                 }
-                if (si != null) {
-                    // track the number of records written to the log
-                    if (zks.getZKDatabase().append(si)) {
-                        logCount++;
-                        if (logCount > (snapCount / 2 + randRoll)) {
-                            randRoll = r.nextInt(snapCount/2);
-                            // roll the log
-                            zks.getZKDatabase().rollLog();
-                            // take a snapshot
-                            if (snapInProcess != null && snapInProcess.isAlive()) {
-                                LOG.warn(""Too busy to snap, skipping"");
-                            } else {
-                                snapInProcess = new ZooKeeperThread(""Snapshot Thread"") {
-                                        public void run() {
-                                            try {
-                                                zks.takeSnapshot();
-                                            } catch(Exception e) {
-                                                LOG.warn(""Unexpected exception"", e);
-                                            }
-                                        }
-                                    };
-                                snapInProcess.start();
-                            }
-                            logCount = 0;
-                        }
-                    } else if (toFlush.isEmpty()) {
-                        // optimization for read heavy workloads
-                        // iff this is a read, and there are no pending
-                        // flushes (writes), then just pass this to the next
-                        // processor
-                        if (nextProcessor != null) {
-                            nextProcessor.processRequest(si);
-                            if (nextProcessor instanceof Flushable) {
-                                ((Flushable)nextProcessor).flush();
-                            }
+
+                // track the number of records written to the log
+                if (zks.getZKDatabase().append(si)) {
+                    logCount++;
+                    if (logCount >= randRoll) {
+                        randRoll = ThreadLocalRandom.current().nextInt(snapCount / 2, snapCount);
+                        // roll the log
+                        zks.getZKDatabase().rollLog();
+                        // take a snapshot
+                        if (!snapThreadMutex.tryAcquire()) {
+                            LOG.warn(""Too busy to snap, skipping"");
+                        } else {
+                            new ZooKeeperThread(""Snapshot Thread"") {
+                                public void run() {
+                                    try {
+                                        zks.takeSnapshot();
+                                    } catch (Exception e) {
+                                        LOG.warn(""Unexpected exception"", e);
+                                    } finally {
+                                      snapThreadMutex.release();
+                                    }
+                                }
+                            }.start();
                         }
-                        continue;
+                        logCount = 0;
                     }
-                    toFlush.add(si);
-                    if (toFlush.size() > 1000) {
-                        flush(toFlush);
+                } else if (toFlush.isEmpty()) {
+                    // optimization for read heavy workloads
+                    // iff this is a read, and there are no pending
+                    // flushes (writes), then just pass this to the next
+                    // processor
+                    if (nextProcessor != null) {
+                        nextProcessor.processRequest(si);
+                        if (nextProcessor instanceof Flushable) {
+                            ((Flushable)nextProcessor).flush();
+                        }
                     }
+                    continue;
+                }
+                toFlush.add(si);
+                if (toFlush.size() == FLUSH_SIZE) {
+                    flush();
                 }
             }
         } catch (Throwable t) {
             handleException(this.getName(), t);
-        } finally{
-            running = false;
         }
         LOG.info(""SyncRequestProcessor exited!"");
     }
 
-    private void flush(LinkedList<Request> toFlush)
-        throws IOException, RequestProcessorException
-    {
-        if (toFlush.isEmpty())
+    private void flush()
+        throws IOException, RequestProcessorException {
+        if (this.toFlush.isEmpty()) {
             return;
+        }
 
         zks.getZKDatabase().commit();
-        while (!toFlush.isEmpty()) {
-            Request i = toFlush.remove();
-            if (nextProcessor != null) {
-                nextProcessor.processRequest(i);
+        if (this.nextProcessor == null) {
+          this.toFlush.clear();","[{'comment': 'nit: using 4 space indent ', 'commenter': 'lvfangmin'}]"
869,zookeeper-server/src/main/java/org/apache/zookeeper/server/SyncRequestProcessor.java,"@@ -102,103 +108,95 @@ public void run() {
 
             // we do this in an attempt to ensure that not all of the servers
             // in the ensemble take a snapshot at the same time
-            int randRoll = r.nextInt(snapCount/2);
+            int randRoll = ThreadLocalRandom.current().nextInt(snapCount / 2, snapCount);","[{'comment': ""I remember we changed to use Random from thread local once since it's approximately giving the same randomize after JDK 8 if I remember correctly."", 'commenter': 'lvfangmin'}, {'comment': '> j.u.Random continues to be an embarrassment, and replacing uses with ThreadLocalRandom wherever we can is progress.\r\n\r\nSo says the Java dev team.\r\nhttps://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8218282\r\n\r\n> When applicable, use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention.\r\n\r\n>This class also provides additional commonly used bounded random generation methods.\r\n\r\nhttps://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadLocalRandom.html', 'commenter': 'belugabehr'}]"
869,zookeeper-server/src/main/java/org/apache/zookeeper/server/SyncRequestProcessor.java,"@@ -46,36 +50,38 @@
  */
 public class SyncRequestProcessor extends ZooKeeperCriticalThread implements
         RequestProcessor {
+
     private static final Logger LOG = LoggerFactory.getLogger(SyncRequestProcessor.class);
+
+    /** The number of log entries to log before starting a snapshot */
+    private static int snapCount = ZooKeeperServer.getSnapCount();
+
+    private static final Request REQUEST_OF_DEATH = Request.requestOfDeath;
+
+    private final static int FLUSH_SIZE = 1000;
+
     private final ZooKeeperServer zks;
-    private final LinkedBlockingQueue<Request> queuedRequests =
+
+    private final BlockingQueue<Request> queuedRequests =
         new LinkedBlockingQueue<Request>();
+
     private final RequestProcessor nextProcessor;
 
-    private Thread snapInProcess = null;
-    volatile private boolean running;
+    private final Semaphore snapThreadMutex = new Semaphore(1);
 
     /**
      * Transactions that have been written and are waiting to be flushed to
      * disk. Basically this is the list of SyncItems whose callbacks will be
      * invoked after flush returns successfully.
      */
-    private final LinkedList<Request> toFlush = new LinkedList<Request>();
-    private final Random r = new Random();
-    /**
-     * The number of log entries to log before starting a snapshot
-     */
-    private static int snapCount = ZooKeeperServer.getSnapCount();
-
-    private final Request requestOfDeath = Request.requestOfDeath;
+    private final Queue<Request> toFlush = new ArrayDeque<>(FLUSH_SIZE);","[{'comment': ""Can you give  some detail why we changed from LinkedList to Queue? I believe there is something you've thought to be useful, which is not quite clear to the reviewer."", 'commenter': 'lvfangmin'}, {'comment': ""> This class is likely to be faster than Stack when used as a stack, and faster than LinkedList when used as a queue.\r\n\r\nhttps://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html\r\n\r\nAnd it will definitely win out here since the max size is known.  Think about it... every time an item is inserted into the LinkedList, a new Node needs to be instantiated and then the links need to be updated in the data structure.  With the array-based implementation, at initialization, it is created with an internal buffer of size 1000.  Any items added to the Queue are simply dropped into the next available bucket in the array.  There is no instantiations or any other interactions with the JDK memory manager.  Also, when iterating over the queue, all of the links in the LinkedList must be walked.  In the array-based implementation, it's a simple array iteration in memory that is all local (where as LinkedList nodes can be all over the place).  Finally, when removing items, the LinkedList links must again be updated and the LinkedList node must be cleaned up by the garbage collection.  ArrayDeque simply removes the item by setting its bucket in the array to 'null'."", 'commenter': 'belugabehr'}]"
877,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/BufferStats.java,"@@ -40,50 +41,50 @@
     private int maxBufferSize = INIT_VALUE;
 
     /**
-     * Size of the last buffer usage.
+     * Updates statistics by setting the last buffer usage size.
+     *
+     * @param value The last buffer size; must be equal to or greater than 0
      */
-    public synchronized int getLastBufferSize() {
-        return lastBufferSize;
+    public synchronized void setLastBufferSize(final int value) {
+        this.lastBufferSize = value;
+        this.minBufferSize = minBufferSize < 0 ? value : Math.min(minBufferSize, value);","[{'comment': 'This logic is based on the assumption that `INIT_VALUE` is negative. A bit fragile.', 'commenter': 'anmolnar'}]"
877,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/BufferStats.java,"@@ -40,50 +41,50 @@
     private int maxBufferSize = INIT_VALUE;
 
     /**
-     * Size of the last buffer usage.
+     * Updates statistics by setting the last buffer usage size.
+     *
+     * @param value The last buffer size; must be equal to or greater than 0
      */
-    public synchronized int getLastBufferSize() {
-        return lastBufferSize;
+    public synchronized void setLastBufferSize(final int value) {
+        this.lastBufferSize = value;
+        this.minBufferSize = minBufferSize < 0 ? value : Math.min(minBufferSize, value);
+        this.maxBufferSize = Math.max(maxBufferSize, value);
     }
 
     /**
-     * Updates statistics by setting the last buffer usage size.
+     * Size of the last buffer usage.
      */
-    public synchronized void setLastBufferSize(int value) {
-        lastBufferSize = value;
-        if (minBufferSize == INIT_VALUE || value < minBufferSize) {
-            minBufferSize = value;
-        }
-        if (value > maxBufferSize) {
-            maxBufferSize = value;
-        }
+    public synchronized int getLastBufferSize() {
+        return this.lastBufferSize;
     }
 
     /**
      * Size of the smallest buffer usage.
      */
     public synchronized int getMinBufferSize() {
-        return minBufferSize;
+        return this.minBufferSize;","[{'comment': 'Redundant `this` modifiers.', 'commenter': 'anmolnar'}]"
877,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/BufferStats.java,"@@ -40,50 +41,50 @@
     private int maxBufferSize = INIT_VALUE;
 
     /**
-     * Size of the last buffer usage.
+     * Updates statistics by setting the last buffer usage size.
+     *
+     * @param value The last buffer size; must be equal to or greater than 0
      */
-    public synchronized int getLastBufferSize() {
-        return lastBufferSize;
+    public synchronized void setLastBufferSize(final int value) {
+        this.lastBufferSize = value;
+        this.minBufferSize = minBufferSize < 0 ? value : Math.min(minBufferSize, value);
+        this.maxBufferSize = Math.max(maxBufferSize, value);
     }
 
     /**
-     * Updates statistics by setting the last buffer usage size.
+     * Size of the last buffer usage.
      */
-    public synchronized void setLastBufferSize(int value) {
-        lastBufferSize = value;
-        if (minBufferSize == INIT_VALUE || value < minBufferSize) {
-            minBufferSize = value;
-        }
-        if (value > maxBufferSize) {
-            maxBufferSize = value;
-        }
+    public synchronized int getLastBufferSize() {
+        return this.lastBufferSize;
     }
 
     /**
      * Size of the smallest buffer usage.
      */
     public synchronized int getMinBufferSize() {
-        return minBufferSize;
+        return this.minBufferSize;
     }
 
     /**
      * Size of the largest buffer usage.
      */
     public synchronized int getMaxBufferSize() {
-        return maxBufferSize;
+        return this.maxBufferSize;
     }
 
     /**
      * Reset statistics.
      */
     public synchronized void reset() {
-        lastBufferSize = INIT_VALUE;
-        minBufferSize = INIT_VALUE;
-        maxBufferSize = INIT_VALUE;
+        this.lastBufferSize = INIT_VALUE;
+        this.minBufferSize = INIT_VALUE;
+        this.maxBufferSize = INIT_VALUE;
     }
 
     @Override
     public synchronized String toString() {
-        return String.format(""%d/%d/%d"", lastBufferSize, minBufferSize, maxBufferSize);
+    return new StringBuilder(40).append(this.lastBufferSize).append('/')","[{'comment': 'Is this a performance critical section?\r\nIf not, `String.format` is more readable, I would rather stick to that.', 'commenter': 'anmolnar'}]"
880,zookeeper-server/src/main/java/org/apache/zookeeper/util/CircularBlockingQueue.java,"@@ -0,0 +1,246 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.util;
+
+import java.util.ArrayDeque;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Objects;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.ReentrantLock;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A bounded blocking queue backed by an array. This queue orders elements FIFO
+ * (first-in-first-out). The head of the queue is that element that has been on
+ * the queue the longest time. The tail of the queue is that element that has
+ * been on the queue the shortest time. New elements are inserted at the tail of
+ * the queue, and the queue retrieval operations obtain elements at the head of
+ * the queue. If the queue is full, the head of the queue (the oldest element)
+ * will be removed to make room for the newest element.
+ */
+public class CircularBlockingQueue<E> implements BlockingQueue<E> {
+
+  private static final Logger LOG = LoggerFactory.getLogger(CircularBlockingQueue.class);
+
+  /** Main lock guarding all access */
+  private final ReentrantLock lock;","[{'comment': 'Why `ReentrantLock` instead of synchronise?\r\nThe performance gain is not significant.', 'commenter': 'anmolnar'}, {'comment': 'Because of `Condition`?', 'commenter': 'anmolnar'}, {'comment': 'Yes... and because that is how JDK does it.\r\n\r\nhttps://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/java/util/concurrent/ArrayBlockingQueue.java#L104', 'commenter': 'belugabehr'}]"
880,zookeeper-server/src/main/java/org/apache/zookeeper/util/CircularBlockingQueue.java,"@@ -0,0 +1,246 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.util;
+
+import java.util.ArrayDeque;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Objects;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.ReentrantLock;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A bounded blocking queue backed by an array. This queue orders elements FIFO
+ * (first-in-first-out). The head of the queue is that element that has been on
+ * the queue the longest time. The tail of the queue is that element that has
+ * been on the queue the shortest time. New elements are inserted at the tail of
+ * the queue, and the queue retrieval operations obtain elements at the head of
+ * the queue. If the queue is full, the head of the queue (the oldest element)
+ * will be removed to make room for the newest element.
+ */
+public class CircularBlockingQueue<E> implements BlockingQueue<E> {
+
+  private static final Logger LOG = LoggerFactory.getLogger(CircularBlockingQueue.class);
+
+  /** Main lock guarding all access */
+  private final ReentrantLock lock;
+
+  /** Condition for waiting takes */
+  private final Condition notEmpty;
+
+  /** The array-backed queue */
+  private final ArrayDeque<E> queue;
+
+  private final int maxSize;
+
+  public CircularBlockingQueue(int queueSize) {
+    this.queue = new ArrayDeque<>(queueSize);
+    this.maxSize = queueSize;
+
+    this.lock =  new ReentrantLock();
+    this.notEmpty = this.lock.newCondition();
+  }
+
+  /**
+   * This method differs from {@link BlockingQueue#offer(Object)} in that it
+   * will remove the oldest queued element (the element at the front of the
+   * queue) in order to make room for any new elements if the queue is full.
+   *
+   * @param e the element to add
+   * @return true since it will make room for any new elements if required
+   */
+  @Override
+  public boolean offer(E e) {
+      Objects.requireNonNull(e);
+      final ReentrantLock lock = this.lock;
+      lock.lock();
+      try {
+          if (this.queue.size() == this.maxSize) {
+              final E discard = this.queue.remove();
+              LOG.debug(""Queue if full. Discarding oldest element: {}"", discard);","[{'comment': 'It would be nice if we could have a metric counting the number of discarded items.', 'commenter': 'anmolnar'}, {'comment': 'OK.  Added!', 'commenter': 'belugabehr'}]"
880,zookeeper-server/src/test/java/org/apache/zookeeper/server/util/TestCircularBlockingQueue.java,"@@ -0,0 +1,70 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+
+import org.apache.zookeeper.util.CircularBlockingQueue;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class TestCircularBlockingQueue {
+
+  @Test
+  public void testCircularBlockingQueue() throws InterruptedException {
+    final BlockingQueue<Integer> testQueue = new CircularBlockingQueue<>(2);
+    testQueue.offer(1);
+    testQueue.offer(2);
+    testQueue.offer(3);
+
+    Assert.assertEquals(2, testQueue.size());
+
+    Assert.assertEquals(2, testQueue.take().intValue());
+    Assert.assertEquals(3, testQueue.take().intValue());
+
+    Assert.assertEquals(0, testQueue.size());
+    Assert.assertEquals(true, testQueue.isEmpty());
+  }
+
+  @Test(timeout = 10000L)
+  public void testCircularBlockingQueueTakeBlock()
+      throws InterruptedException, ExecutionException {
+
+    final BlockingQueue<Integer> testQueue = new CircularBlockingQueue<>(2);
+
+    ExecutorService executor = Executors.newSingleThreadExecutor();
+
+    Future<Integer> testTake = executor.submit(() -> {
+      return testQueue.take();
+    });
+
+    // Allow the other thread to get into position; waiting for item to be inserted
+    Thread.sleep(2000L);","[{'comment': 'Please use a `Latch` (or some other method) to synchronise with the worker.', 'commenter': 'anmolnar'}, {'comment': 'OK. Added!', 'commenter': 'belugabehr'}]"
880,zookeeper-server/src/main/java/org/apache/zookeeper/util/CircularBlockingQueue.java,"@@ -0,0 +1,246 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.util;
+
+import java.util.ArrayDeque;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Objects;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.ReentrantLock;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A bounded blocking queue backed by an array. This queue orders elements FIFO
+ * (first-in-first-out). The head of the queue is that element that has been on
+ * the queue the longest time. The tail of the queue is that element that has
+ * been on the queue the shortest time. New elements are inserted at the tail of
+ * the queue, and the queue retrieval operations obtain elements at the head of
+ * the queue. If the queue is full, the head of the queue (the oldest element)
+ * will be removed to make room for the newest element.
+ */
+public class CircularBlockingQueue<E> implements BlockingQueue<E> {
+
+  private static final Logger LOG = LoggerFactory.getLogger(CircularBlockingQueue.class);
+
+  /** Main lock guarding all access */
+  private final ReentrantLock lock;
+
+  /** Condition for waiting takes */
+  private final Condition notEmpty;
+
+  /** The array-backed queue */
+  private final ArrayDeque<E> queue;
+
+  private final int maxSize;
+
+  public CircularBlockingQueue(int queueSize) {
+    this.queue = new ArrayDeque<>(queueSize);
+    this.maxSize = queueSize;
+
+    this.lock =  new ReentrantLock();
+    this.notEmpty = this.lock.newCondition();
+  }
+
+  /**
+   * This method differs from {@link BlockingQueue#offer(Object)} in that it
+   * will remove the oldest queued element (the element at the front of the
+   * queue) in order to make room for any new elements if the queue is full.
+   *
+   * @param e the element to add
+   * @return true since it will make room for any new elements if required
+   */
+  @Override
+  public boolean offer(E e) {","[{'comment': ""This method will never fail (never return false) or I'm missing something here."", 'commenter': 'anmolnar'}, {'comment': '...but you need to match with the interface. Makes sense.\r\nYou might not want to check in the caller though.', 'commenter': 'anmolnar'}, {'comment': ""I'm checking in the caller just so that if someone changes this down the road, it will break.  Also,... a plugin is complaining about ignoring the return value so I had to do something with it."", 'commenter': 'belugabehr'}]"
880,zookeeper-server/src/test/java/org/apache/zookeeper/util/TestCircularBlockingQueue.java,"@@ -0,0 +1,72 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.util;
+
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class TestCircularBlockingQueue {
+
+  @Test
+  public void testCircularBlockingQueue() throws InterruptedException {
+    final CircularBlockingQueue<Integer> testQueue =
+        new CircularBlockingQueue<>(2);
+
+    testQueue.offer(1);
+    testQueue.offer(2);
+    testQueue.offer(3);
+
+    Assert.assertEquals(2, testQueue.size());
+
+    Assert.assertEquals(2, testQueue.take().intValue());
+    Assert.assertEquals(3, testQueue.take().intValue());
+
+    Assert.assertEquals(1L, testQueue.getDroppedCount());
+    Assert.assertEquals(0, testQueue.size());
+    Assert.assertEquals(true, testQueue.isEmpty());
+  }
+
+  @Test(timeout = 10000L)
+  public void testCircularBlockingQueueTakeBlock()
+      throws InterruptedException, ExecutionException {
+
+    final CircularBlockingQueue<Integer> testQueue = new CircularBlockingQueue<>(2);
+
+    ExecutorService executor = Executors.newSingleThreadExecutor();","[{'comment': 'Please shutdown the executor (in a finally block)', 'commenter': 'eolivelli'}]"
880,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -1318,8 +1274,9 @@ public void addToRecvQueue(Message msg) {
      *
      * {@link ArrayBlockingQueue#poll(long, java.util.concurrent.TimeUnit)}","[{'comment': 'nit - change `ArrayBlockingQueue` to `BlockingQueue` in doc', 'commenter': 'enixon'}]"
882,zookeeper-server/src/test/java/org/apache/zookeeper/common/AtomicFileWritingIdiomTest.java,"@@ -348,12 +350,12 @@ private String getContent(File file, String encoding) throws IOException {
     }
 
     private String getContent(File file) throws IOException {
-        return getContent(file, ""ASCII"");
+        return getContent(file, StandardCharsets.US_ASCII);","[{'comment': 'Do we use ASCII anywhere else?', 'commenter': 'enixon'}, {'comment': ""For this test class, it's consistent in that it expects Ascii on line 356/358.  Ascii fits perfectly fine into UTF-8 so this test is not invalid and probably doesn't add any value to change it because the data being used in this test is not outside the ASCII range."", 'commenter': 'belugabehr'}]"
882,zookeeper-recipes/zookeeper-recipes-queue/src/test/java/org/apache/zookeeper/recipes/queue/DistributedQueueTest.java,"@@ -27,243 +28,260 @@
 import org.junit.Test;
 
 /**
- * Tests for {@link DistributedQueue}.
+ * DistributedQueueTest test.
  */
 public class DistributedQueueTest extends ClientBase {
 
-    @After
-    public void tearDown() throws Exception {
-        super.tearDown();
+  @After
+  public void tearDown() throws Exception {
+    super.tearDown();
+  }
+
+  @Test
+  public void testOffer1() throws Exception {
+    String dir = ""/testOffer1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer1() throws Exception {
-        String dir = ""/testOffer1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testOffer2() throws Exception {
+    String dir = ""/testOffer2"";
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer2() throws Exception {
-        String dir = ""/testOffer2"";
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[1].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[1].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testTake1() throws Exception {
+    String dir = ""/testTake1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testTake1() throws Exception {
-        String dir = ""/testTake1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].take();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].take();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testRemove1() throws Exception {
+    String dir = ""/testRemove1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testRemove1() throws Exception {
-        String dir = ""/testRemove1"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        try {
-            queueHandles[0].remove();
-        } catch (NoSuchElementException e) {
-            return;
-        }
-
-        Assert.fail();
+    try {
+      queueHandles[0].remove();
+    } catch (NoSuchElementException e) {
+      return;
+    }
+    Assert.assertTrue(false);","[{'comment': ""Not sure why this was changed, but it should be changed back:\r\n\r\n```suggestion\r\n    Assert.fail();\r\n```\r\n\r\n(or even better, use assertThrows instead, but that's outside the scope of this changeset)"", 'commenter': 'ctubbsii'}, {'comment': ""@ctubbsii Thanks for the review.  I'm not sure how these changes came to be. I don't think I changed them manually and instead came from something I did merging this relatively old branch into master branch.  I am working on taking into account some of your feedback now and these types of changes were reverted when I tried to rebase on master again.  Thanks."", 'commenter': 'belugabehr'}]"
882,zookeeper-recipes/zookeeper-recipes-queue/src/test/java/org/apache/zookeeper/recipes/queue/DistributedQueueTest.java,"@@ -27,243 +28,260 @@
 import org.junit.Test;
 
 /**
- * Tests for {@link DistributedQueue}.
+ * DistributedQueueTest test.
  */
 public class DistributedQueueTest extends ClientBase {
 
-    @After
-    public void tearDown() throws Exception {
-        super.tearDown();
+  @After
+  public void tearDown() throws Exception {
+    super.tearDown();
+  }
+
+  @Test
+  public void testOffer1() throws Exception {
+    String dir = ""/testOffer1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer1() throws Exception {
-        String dir = ""/testOffer1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testOffer2() throws Exception {
+    String dir = ""/testOffer2"";
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer2() throws Exception {
-        String dir = ""/testOffer2"";
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[1].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[1].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testTake1() throws Exception {
+    String dir = ""/testTake1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testTake1() throws Exception {
-        String dir = ""/testTake1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].take();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].take();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testRemove1() throws Exception {
+    String dir = ""/testRemove1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testRemove1() throws Exception {
-        String dir = ""/testRemove1"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        try {
-            queueHandles[0].remove();
-        } catch (NoSuchElementException e) {
-            return;
-        }
-
-        Assert.fail();
+    try {
+      queueHandles[0].remove();
+    } catch (NoSuchElementException e) {
+      return;
+    }
+    Assert.assertTrue(false);
+  }
+
+  public void createNremoveMtest(String dir, int n, int m) throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMtest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        for (int i = 0; i < n; i++) {
-            String offerString = testString + i;
-            queueHandles[0].offer(offerString.getBytes());
-        }
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
+    }
 
-        byte[] data = null;
-        for (int i = 0; i < m; i++) {
-            data = queueHandles[1].remove();
-        }
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
+    }
+    Assert.assertEquals(new String(data, UTF_8), testString + (m - 1));
+  }
+
+  @Test
+  public void testRemove2() throws Exception {
+    createNremoveMtest(""/testRemove2"", 10, 2);
+  }
+
+  @Test
+  public void testRemove3() throws Exception {
+    createNremoveMtest(""/testRemove3"", 1000, 1000);
+  }
+
+  public void createNremoveMelementTest(String dir, int n, int m)
+      throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
+    }
 
-        Assert.assertNotNull(data);
-        Assert.assertEquals(new String(data), testString + (m - 1));
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
     }
 
-    @Test
-    public void testRemove2() throws Exception {
-        createNremoveMtest(""/testRemove2"", 10, 2);
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();","[{'comment': ""I think this creates an unused variable. You could remove the assignment, as it was before, or you can do something with it in a new Assert statement. A simple thing is just assert that it's not null."", 'commenter': 'ctubbsii'}]"
882,zookeeper-recipes/zookeeper-recipes-queue/src/test/java/org/apache/zookeeper/recipes/queue/DistributedQueueTest.java,"@@ -27,243 +28,260 @@
 import org.junit.Test;
 
 /**
- * Tests for {@link DistributedQueue}.
+ * DistributedQueueTest test.
  */
 public class DistributedQueueTest extends ClientBase {
 
-    @After
-    public void tearDown() throws Exception {
-        super.tearDown();
+  @After
+  public void tearDown() throws Exception {
+    super.tearDown();
+  }
+
+  @Test
+  public void testOffer1() throws Exception {
+    String dir = ""/testOffer1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer1() throws Exception {
-        String dir = ""/testOffer1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testOffer2() throws Exception {
+    String dir = ""/testOffer2"";
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer2() throws Exception {
-        String dir = ""/testOffer2"";
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[1].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[1].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testTake1() throws Exception {
+    String dir = ""/testTake1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testTake1() throws Exception {
-        String dir = ""/testTake1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].take();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].take();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testRemove1() throws Exception {
+    String dir = ""/testRemove1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testRemove1() throws Exception {
-        String dir = ""/testRemove1"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        try {
-            queueHandles[0].remove();
-        } catch (NoSuchElementException e) {
-            return;
-        }
-
-        Assert.fail();
+    try {
+      queueHandles[0].remove();
+    } catch (NoSuchElementException e) {
+      return;
+    }
+    Assert.assertTrue(false);
+  }
+
+  public void createNremoveMtest(String dir, int n, int m) throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMtest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        for (int i = 0; i < n; i++) {
-            String offerString = testString + i;
-            queueHandles[0].offer(offerString.getBytes());
-        }
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
+    }
 
-        byte[] data = null;
-        for (int i = 0; i < m; i++) {
-            data = queueHandles[1].remove();
-        }
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
+    }
+    Assert.assertEquals(new String(data, UTF_8), testString + (m - 1));
+  }
+
+  @Test
+  public void testRemove2() throws Exception {
+    createNremoveMtest(""/testRemove2"", 10, 2);
+  }
+
+  @Test
+  public void testRemove3() throws Exception {
+    createNremoveMtest(""/testRemove3"", 1000, 1000);
+  }
+
+  public void createNremoveMelementTest(String dir, int n, int m)
+      throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
+    }
 
-        Assert.assertNotNull(data);
-        Assert.assertEquals(new String(data), testString + (m - 1));
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
     }
 
-    @Test
-    public void testRemove2() throws Exception {
-        createNremoveMtest(""/testRemove2"", 10, 2);
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
     }
-    @Test
-    public void testRemove3() throws Exception {
-        createNremoveMtest(""/testRemove3"", 1000, 1000);
+    Assert.assertEquals(new String(queueHandles[1].element(), UTF_8),
+        testString + m);
+  }
+
+  @Test
+  public void testElement1() throws Exception {
+    createNremoveMelementTest(""/testElement1"", 1, 0);
+  }
+
+  @Test
+  public void testElement2() throws Exception {
+    createNremoveMelementTest(""/testElement2"", 10, 2);
+  }
+
+  @Test
+  public void testElement3() throws Exception {
+    createNremoveMelementTest(""/testElement3"", 1000, 500);
+  }
+
+  @Test
+  public void testElement4() throws Exception {
+    createNremoveMelementTest(""/testElement4"", 1000, 1000 - 1);
+  }
+
+  @Test
+  public void testTakeWait1() throws Exception {
+    String dir = ""/testTakeWait1"";
+    final String testString = ""Hello World"";
+    final int numClients = 1;
+    final ZooKeeper[] clients = new ZooKeeper[numClients];
+    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMelementTest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
+    final byte[] takeResult[] = new byte[1][];
+    Thread takeThread = new Thread() {
+      public void run() {","[{'comment': 'Why convert lambda to an inner class? This seems like a regression.', 'commenter': 'ctubbsii'}]"
882,zookeeper-recipes/zookeeper-recipes-queue/src/test/java/org/apache/zookeeper/recipes/queue/DistributedQueueTest.java,"@@ -27,243 +28,260 @@
 import org.junit.Test;
 
 /**
- * Tests for {@link DistributedQueue}.
+ * DistributedQueueTest test.
  */
 public class DistributedQueueTest extends ClientBase {
 
-    @After
-    public void tearDown() throws Exception {
-        super.tearDown();
+  @After
+  public void tearDown() throws Exception {
+    super.tearDown();
+  }
+
+  @Test
+  public void testOffer1() throws Exception {
+    String dir = ""/testOffer1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer1() throws Exception {
-        String dir = ""/testOffer1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testOffer2() throws Exception {
+    String dir = ""/testOffer2"";
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer2() throws Exception {
-        String dir = ""/testOffer2"";
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[1].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[1].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testTake1() throws Exception {
+    String dir = ""/testTake1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testTake1() throws Exception {
-        String dir = ""/testTake1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].take();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].take();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testRemove1() throws Exception {
+    String dir = ""/testRemove1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testRemove1() throws Exception {
-        String dir = ""/testRemove1"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        try {
-            queueHandles[0].remove();
-        } catch (NoSuchElementException e) {
-            return;
-        }
-
-        Assert.fail();
+    try {
+      queueHandles[0].remove();
+    } catch (NoSuchElementException e) {
+      return;
+    }
+    Assert.assertTrue(false);
+  }
+
+  public void createNremoveMtest(String dir, int n, int m) throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMtest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        for (int i = 0; i < n; i++) {
-            String offerString = testString + i;
-            queueHandles[0].offer(offerString.getBytes());
-        }
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
+    }
 
-        byte[] data = null;
-        for (int i = 0; i < m; i++) {
-            data = queueHandles[1].remove();
-        }
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
+    }
+    Assert.assertEquals(new String(data, UTF_8), testString + (m - 1));
+  }
+
+  @Test
+  public void testRemove2() throws Exception {
+    createNremoveMtest(""/testRemove2"", 10, 2);
+  }
+
+  @Test
+  public void testRemove3() throws Exception {
+    createNremoveMtest(""/testRemove3"", 1000, 1000);
+  }
+
+  public void createNremoveMelementTest(String dir, int n, int m)
+      throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
+    }
 
-        Assert.assertNotNull(data);
-        Assert.assertEquals(new String(data), testString + (m - 1));
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
     }
 
-    @Test
-    public void testRemove2() throws Exception {
-        createNremoveMtest(""/testRemove2"", 10, 2);
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
     }
-    @Test
-    public void testRemove3() throws Exception {
-        createNremoveMtest(""/testRemove3"", 1000, 1000);
+    Assert.assertEquals(new String(queueHandles[1].element(), UTF_8),
+        testString + m);
+  }
+
+  @Test
+  public void testElement1() throws Exception {
+    createNremoveMelementTest(""/testElement1"", 1, 0);
+  }
+
+  @Test
+  public void testElement2() throws Exception {
+    createNremoveMelementTest(""/testElement2"", 10, 2);
+  }
+
+  @Test
+  public void testElement3() throws Exception {
+    createNremoveMelementTest(""/testElement3"", 1000, 500);
+  }
+
+  @Test
+  public void testElement4() throws Exception {
+    createNremoveMelementTest(""/testElement4"", 1000, 1000 - 1);
+  }
+
+  @Test
+  public void testTakeWait1() throws Exception {
+    String dir = ""/testTakeWait1"";
+    final String testString = ""Hello World"";
+    final int numClients = 1;
+    final ZooKeeper[] clients = new ZooKeeper[numClients];
+    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMelementTest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
+    final byte[] takeResult[] = new byte[1][];
+    Thread takeThread = new Thread() {
+      public void run() {
+        try {
+          takeResult[0] = queueHandles[0].take();
+        } catch (KeeperException e) {
 
-        for (int i = 0; i < n; i++) {
-            String offerString = testString + i;
-            queueHandles[0].offer(offerString.getBytes());
-        }
+        } catch (InterruptedException e) {","[{'comment': 'Why separate out these exceptions instead of keeping the original multi-catch? This seems like a regression.', 'commenter': 'ctubbsii'}]"
882,zookeeper-recipes/zookeeper-recipes-queue/src/test/java/org/apache/zookeeper/recipes/queue/DistributedQueueTest.java,"@@ -27,243 +28,260 @@
 import org.junit.Test;
 
 /**
- * Tests for {@link DistributedQueue}.
+ * DistributedQueueTest test.
  */
 public class DistributedQueueTest extends ClientBase {
 
-    @After
-    public void tearDown() throws Exception {
-        super.tearDown();
+  @After
+  public void tearDown() throws Exception {
+    super.tearDown();
+  }
+
+  @Test
+  public void testOffer1() throws Exception {
+    String dir = ""/testOffer1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer1() throws Exception {
-        String dir = ""/testOffer1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testOffer2() throws Exception {
+    String dir = ""/testOffer2"";
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer2() throws Exception {
-        String dir = ""/testOffer2"";
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[1].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[1].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testTake1() throws Exception {
+    String dir = ""/testTake1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testTake1() throws Exception {
-        String dir = ""/testTake1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].take();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].take();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testRemove1() throws Exception {
+    String dir = ""/testRemove1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testRemove1() throws Exception {
-        String dir = ""/testRemove1"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        try {
-            queueHandles[0].remove();
-        } catch (NoSuchElementException e) {
-            return;
-        }
-
-        Assert.fail();
+    try {
+      queueHandles[0].remove();
+    } catch (NoSuchElementException e) {
+      return;
+    }
+    Assert.assertTrue(false);
+  }
+
+  public void createNremoveMtest(String dir, int n, int m) throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMtest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        for (int i = 0; i < n; i++) {
-            String offerString = testString + i;
-            queueHandles[0].offer(offerString.getBytes());
-        }
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
+    }
 
-        byte[] data = null;
-        for (int i = 0; i < m; i++) {
-            data = queueHandles[1].remove();
-        }
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
+    }
+    Assert.assertEquals(new String(data, UTF_8), testString + (m - 1));
+  }
+
+  @Test
+  public void testRemove2() throws Exception {
+    createNremoveMtest(""/testRemove2"", 10, 2);
+  }
+
+  @Test
+  public void testRemove3() throws Exception {
+    createNremoveMtest(""/testRemove3"", 1000, 1000);
+  }
+
+  public void createNremoveMelementTest(String dir, int n, int m)
+      throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
+    }
 
-        Assert.assertNotNull(data);
-        Assert.assertEquals(new String(data), testString + (m - 1));
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
     }
 
-    @Test
-    public void testRemove2() throws Exception {
-        createNremoveMtest(""/testRemove2"", 10, 2);
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
     }
-    @Test
-    public void testRemove3() throws Exception {
-        createNremoveMtest(""/testRemove3"", 1000, 1000);
+    Assert.assertEquals(new String(queueHandles[1].element(), UTF_8),
+        testString + m);
+  }
+
+  @Test
+  public void testElement1() throws Exception {
+    createNremoveMelementTest(""/testElement1"", 1, 0);
+  }
+
+  @Test
+  public void testElement2() throws Exception {
+    createNremoveMelementTest(""/testElement2"", 10, 2);
+  }
+
+  @Test
+  public void testElement3() throws Exception {
+    createNremoveMelementTest(""/testElement3"", 1000, 500);
+  }
+
+  @Test
+  public void testElement4() throws Exception {
+    createNremoveMelementTest(""/testElement4"", 1000, 1000 - 1);
+  }
+
+  @Test
+  public void testTakeWait1() throws Exception {
+    String dir = ""/testTakeWait1"";
+    final String testString = ""Hello World"";
+    final int numClients = 1;
+    final ZooKeeper[] clients = new ZooKeeper[numClients];
+    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMelementTest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
+    final byte[] takeResult[] = new byte[1][];
+    Thread takeThread = new Thread() {
+      public void run() {
+        try {
+          takeResult[0] = queueHandles[0].take();
+        } catch (KeeperException e) {
 
-        for (int i = 0; i < n; i++) {
-            String offerString = testString + i;
-            queueHandles[0].offer(offerString.getBytes());
-        }
+        } catch (InterruptedException e) {
 
-        for (int i = 0; i < m; i++) {
-            queueHandles[1].remove();
         }
-        Assert.assertEquals(new String(queueHandles[1].element()), testString + m);
-    }
+      }
+    };
+    takeThread.start();
 
-    @Test
-    public void testElement1() throws Exception {
-        createNremoveMelementTest(""/testElement1"", 1, 0);
-    }
+    Thread.sleep(1000);
+    Thread offerThread = new Thread() {
+      public void run() {
+        try {
+          queueHandles[0].offer(testString.getBytes(UTF_8));
+        } catch (KeeperException e) {
 
-    @Test
-    public void testElement2() throws Exception {
-        createNremoveMelementTest(""/testElement2"", 10, 2);
-    }
+        } catch (InterruptedException e) {
 
-    @Test
-    public void testElement3() throws Exception {
-        createNremoveMelementTest(""/testElement3"", 1000, 500);
+        }
+      }
+    };","[{'comment': 'Same comments about keeping lambda and multi-catch', 'commenter': 'ctubbsii'}]"
882,zookeeper-recipes/zookeeper-recipes-queue/src/test/java/org/apache/zookeeper/recipes/queue/DistributedQueueTest.java,"@@ -27,243 +28,260 @@
 import org.junit.Test;
 
 /**
- * Tests for {@link DistributedQueue}.
+ * DistributedQueueTest test.
  */
 public class DistributedQueueTest extends ClientBase {
 
-    @After
-    public void tearDown() throws Exception {
-        super.tearDown();
+  @After
+  public void tearDown() throws Exception {
+    super.tearDown();
+  }
+
+  @Test
+  public void testOffer1() throws Exception {
+    String dir = ""/testOffer1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer1() throws Exception {
-        String dir = ""/testOffer1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testOffer2() throws Exception {
+    String dir = ""/testOffer2"";
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer2() throws Exception {
-        String dir = ""/testOffer2"";
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[1].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[1].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testTake1() throws Exception {
+    String dir = ""/testTake1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testTake1() throws Exception {
-        String dir = ""/testTake1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].take();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].take();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testRemove1() throws Exception {
+    String dir = ""/testRemove1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testRemove1() throws Exception {
-        String dir = ""/testRemove1"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        try {
-            queueHandles[0].remove();
-        } catch (NoSuchElementException e) {
-            return;
-        }
-
-        Assert.fail();
+    try {
+      queueHandles[0].remove();
+    } catch (NoSuchElementException e) {
+      return;
+    }
+    Assert.assertTrue(false);
+  }
+
+  public void createNremoveMtest(String dir, int n, int m) throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMtest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        for (int i = 0; i < n; i++) {
-            String offerString = testString + i;
-            queueHandles[0].offer(offerString.getBytes());
-        }
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
+    }
 
-        byte[] data = null;
-        for (int i = 0; i < m; i++) {
-            data = queueHandles[1].remove();
-        }
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
+    }
+    Assert.assertEquals(new String(data, UTF_8), testString + (m - 1));
+  }
+
+  @Test
+  public void testRemove2() throws Exception {
+    createNremoveMtest(""/testRemove2"", 10, 2);
+  }
+
+  @Test
+  public void testRemove3() throws Exception {
+    createNremoveMtest(""/testRemove3"", 1000, 1000);
+  }
+
+  public void createNremoveMelementTest(String dir, int n, int m)
+      throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
+    }
 
-        Assert.assertNotNull(data);
-        Assert.assertEquals(new String(data), testString + (m - 1));
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
     }
 
-    @Test
-    public void testRemove2() throws Exception {
-        createNremoveMtest(""/testRemove2"", 10, 2);
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
     }
-    @Test
-    public void testRemove3() throws Exception {
-        createNremoveMtest(""/testRemove3"", 1000, 1000);
+    Assert.assertEquals(new String(queueHandles[1].element(), UTF_8),
+        testString + m);
+  }
+
+  @Test
+  public void testElement1() throws Exception {
+    createNremoveMelementTest(""/testElement1"", 1, 0);
+  }
+
+  @Test
+  public void testElement2() throws Exception {
+    createNremoveMelementTest(""/testElement2"", 10, 2);
+  }
+
+  @Test
+  public void testElement3() throws Exception {
+    createNremoveMelementTest(""/testElement3"", 1000, 500);
+  }
+
+  @Test
+  public void testElement4() throws Exception {
+    createNremoveMelementTest(""/testElement4"", 1000, 1000 - 1);
+  }
+
+  @Test
+  public void testTakeWait1() throws Exception {
+    String dir = ""/testTakeWait1"";
+    final String testString = ""Hello World"";
+    final int numClients = 1;
+    final ZooKeeper[] clients = new ZooKeeper[numClients];
+    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMelementTest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
+    final byte[] takeResult[] = new byte[1][];
+    Thread takeThread = new Thread() {
+      public void run() {
+        try {
+          takeResult[0] = queueHandles[0].take();
+        } catch (KeeperException e) {
 
-        for (int i = 0; i < n; i++) {
-            String offerString = testString + i;
-            queueHandles[0].offer(offerString.getBytes());
-        }
+        } catch (InterruptedException e) {
 
-        for (int i = 0; i < m; i++) {
-            queueHandles[1].remove();
         }
-        Assert.assertEquals(new String(queueHandles[1].element()), testString + m);
-    }
+      }
+    };
+    takeThread.start();
 
-    @Test
-    public void testElement1() throws Exception {
-        createNremoveMelementTest(""/testElement1"", 1, 0);
-    }
+    Thread.sleep(1000);
+    Thread offerThread = new Thread() {
+      public void run() {
+        try {
+          queueHandles[0].offer(testString.getBytes(UTF_8));
+        } catch (KeeperException e) {
 
-    @Test
-    public void testElement2() throws Exception {
-        createNremoveMelementTest(""/testElement2"", 10, 2);
-    }
+        } catch (InterruptedException e) {
 
-    @Test
-    public void testElement3() throws Exception {
-        createNremoveMelementTest(""/testElement3"", 1000, 500);
+        }
+      }
+    };
+    offerThread.start();
+    offerThread.join();
+
+    takeThread.join();
+
+    Assert.assertTrue(takeResult[0] != null);","[{'comment': 'assertNotNull is better. This should go back to the way it was.', 'commenter': 'ctubbsii'}]"
882,zookeeper-recipes/zookeeper-recipes-queue/src/test/java/org/apache/zookeeper/recipes/queue/DistributedQueueTest.java,"@@ -27,243 +28,260 @@
 import org.junit.Test;
 
 /**
- * Tests for {@link DistributedQueue}.
+ * DistributedQueueTest test.
  */
 public class DistributedQueueTest extends ClientBase {
 
-    @After
-    public void tearDown() throws Exception {
-        super.tearDown();
+  @After
+  public void tearDown() throws Exception {
+    super.tearDown();
+  }
+
+  @Test
+  public void testOffer1() throws Exception {
+    String dir = ""/testOffer1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer1() throws Exception {
-        String dir = ""/testOffer1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testOffer2() throws Exception {
+    String dir = ""/testOffer2"";
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer2() throws Exception {
-        String dir = ""/testOffer2"";
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[1].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[1].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testTake1() throws Exception {
+    String dir = ""/testTake1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testTake1() throws Exception {
-        String dir = ""/testTake1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].take();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].take();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testRemove1() throws Exception {
+    String dir = ""/testRemove1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testRemove1() throws Exception {
-        String dir = ""/testRemove1"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        try {
-            queueHandles[0].remove();
-        } catch (NoSuchElementException e) {
-            return;
-        }
-
-        Assert.fail();
+    try {
+      queueHandles[0].remove();
+    } catch (NoSuchElementException e) {
+      return;
+    }
+    Assert.assertTrue(false);
+  }
+
+  public void createNremoveMtest(String dir, int n, int m) throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMtest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        for (int i = 0; i < n; i++) {
-            String offerString = testString + i;
-            queueHandles[0].offer(offerString.getBytes());
-        }
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
+    }
 
-        byte[] data = null;
-        for (int i = 0; i < m; i++) {
-            data = queueHandles[1].remove();
-        }
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
+    }
+    Assert.assertEquals(new String(data, UTF_8), testString + (m - 1));
+  }
+
+  @Test
+  public void testRemove2() throws Exception {
+    createNremoveMtest(""/testRemove2"", 10, 2);
+  }
+
+  @Test
+  public void testRemove3() throws Exception {
+    createNremoveMtest(""/testRemove3"", 1000, 1000);
+  }
+
+  public void createNremoveMelementTest(String dir, int n, int m)
+      throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
+    }
 
-        Assert.assertNotNull(data);
-        Assert.assertEquals(new String(data), testString + (m - 1));
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
     }
 
-    @Test
-    public void testRemove2() throws Exception {
-        createNremoveMtest(""/testRemove2"", 10, 2);
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
     }
-    @Test
-    public void testRemove3() throws Exception {
-        createNremoveMtest(""/testRemove3"", 1000, 1000);
+    Assert.assertEquals(new String(queueHandles[1].element(), UTF_8),
+        testString + m);
+  }
+
+  @Test
+  public void testElement1() throws Exception {
+    createNremoveMelementTest(""/testElement1"", 1, 0);
+  }
+
+  @Test
+  public void testElement2() throws Exception {
+    createNremoveMelementTest(""/testElement2"", 10, 2);
+  }
+
+  @Test
+  public void testElement3() throws Exception {
+    createNremoveMelementTest(""/testElement3"", 1000, 500);
+  }
+
+  @Test
+  public void testElement4() throws Exception {
+    createNremoveMelementTest(""/testElement4"", 1000, 1000 - 1);
+  }
+
+  @Test
+  public void testTakeWait1() throws Exception {
+    String dir = ""/testTakeWait1"";
+    final String testString = ""Hello World"";
+    final int numClients = 1;
+    final ZooKeeper[] clients = new ZooKeeper[numClients];
+    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMelementTest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
+    final byte[] takeResult[] = new byte[1][];
+    Thread takeThread = new Thread() {
+      public void run() {
+        try {
+          takeResult[0] = queueHandles[0].take();
+        } catch (KeeperException e) {
 
-        for (int i = 0; i < n; i++) {
-            String offerString = testString + i;
-            queueHandles[0].offer(offerString.getBytes());
-        }
+        } catch (InterruptedException e) {
 
-        for (int i = 0; i < m; i++) {
-            queueHandles[1].remove();
         }
-        Assert.assertEquals(new String(queueHandles[1].element()), testString + m);
-    }
+      }
+    };
+    takeThread.start();
 
-    @Test
-    public void testElement1() throws Exception {
-        createNremoveMelementTest(""/testElement1"", 1, 0);
-    }
+    Thread.sleep(1000);
+    Thread offerThread = new Thread() {
+      public void run() {
+        try {
+          queueHandles[0].offer(testString.getBytes(UTF_8));
+        } catch (KeeperException e) {
 
-    @Test
-    public void testElement2() throws Exception {
-        createNremoveMelementTest(""/testElement2"", 10, 2);
-    }
+        } catch (InterruptedException e) {
 
-    @Test
-    public void testElement3() throws Exception {
-        createNremoveMelementTest(""/testElement3"", 1000, 500);
+        }
+      }
+    };
+    offerThread.start();
+    offerThread.join();
+
+    takeThread.join();
+
+    Assert.assertTrue(takeResult[0] != null);
+    Assert.assertEquals(new String(takeResult[0], UTF_8), testString);
+  }
+
+  @Test
+  public void testTakeWait2() throws Exception {
+    String dir = ""/testTakeWait2"";
+    final String testString = ""Hello World"";
+    final int numClients = 1;
+    final ZooKeeper[] clients = new ZooKeeper[numClients];
+    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
+    int numAttempts = 2;
+    for (int i = 0; i < numAttempts; i++) {
+      final byte[] takeResult[] = new byte[1][];","[{'comment': 'The type of the variable is `byte[][]`, so this should go back to the way it was.', 'commenter': 'ctubbsii'}]"
882,zookeeper-recipes/zookeeper-recipes-queue/src/test/java/org/apache/zookeeper/recipes/queue/DistributedQueueTest.java,"@@ -27,243 +28,260 @@
 import org.junit.Test;
 
 /**
- * Tests for {@link DistributedQueue}.
+ * DistributedQueueTest test.
  */
 public class DistributedQueueTest extends ClientBase {
 
-    @After
-    public void tearDown() throws Exception {
-        super.tearDown();
+  @After
+  public void tearDown() throws Exception {
+    super.tearDown();
+  }
+
+  @Test
+  public void testOffer1() throws Exception {
+    String dir = ""/testOffer1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer1() throws Exception {
-        String dir = ""/testOffer1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testOffer2() throws Exception {
+    String dir = ""/testOffer2"";
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer2() throws Exception {
-        String dir = ""/testOffer2"";
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[1].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[1].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testTake1() throws Exception {
+    String dir = ""/testTake1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testTake1() throws Exception {
-        String dir = ""/testTake1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].take();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].take();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testRemove1() throws Exception {
+    String dir = ""/testRemove1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testRemove1() throws Exception {
-        String dir = ""/testRemove1"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        try {
-            queueHandles[0].remove();
-        } catch (NoSuchElementException e) {
-            return;
-        }
-
-        Assert.fail();
+    try {
+      queueHandles[0].remove();
+    } catch (NoSuchElementException e) {
+      return;
+    }
+    Assert.assertTrue(false);
+  }
+
+  public void createNremoveMtest(String dir, int n, int m) throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMtest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        for (int i = 0; i < n; i++) {
-            String offerString = testString + i;
-            queueHandles[0].offer(offerString.getBytes());
-        }
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
+    }
 
-        byte[] data = null;
-        for (int i = 0; i < m; i++) {
-            data = queueHandles[1].remove();
-        }
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
+    }
+    Assert.assertEquals(new String(data, UTF_8), testString + (m - 1));
+  }
+
+  @Test
+  public void testRemove2() throws Exception {
+    createNremoveMtest(""/testRemove2"", 10, 2);
+  }
+
+  @Test
+  public void testRemove3() throws Exception {
+    createNremoveMtest(""/testRemove3"", 1000, 1000);
+  }
+
+  public void createNremoveMelementTest(String dir, int n, int m)
+      throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
+    }
 
-        Assert.assertNotNull(data);
-        Assert.assertEquals(new String(data), testString + (m - 1));
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
     }
 
-    @Test
-    public void testRemove2() throws Exception {
-        createNremoveMtest(""/testRemove2"", 10, 2);
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
     }
-    @Test
-    public void testRemove3() throws Exception {
-        createNremoveMtest(""/testRemove3"", 1000, 1000);
+    Assert.assertEquals(new String(queueHandles[1].element(), UTF_8),
+        testString + m);
+  }
+
+  @Test
+  public void testElement1() throws Exception {
+    createNremoveMelementTest(""/testElement1"", 1, 0);
+  }
+
+  @Test
+  public void testElement2() throws Exception {
+    createNremoveMelementTest(""/testElement2"", 10, 2);
+  }
+
+  @Test
+  public void testElement3() throws Exception {
+    createNremoveMelementTest(""/testElement3"", 1000, 500);
+  }
+
+  @Test
+  public void testElement4() throws Exception {
+    createNremoveMelementTest(""/testElement4"", 1000, 1000 - 1);
+  }
+
+  @Test
+  public void testTakeWait1() throws Exception {
+    String dir = ""/testTakeWait1"";
+    final String testString = ""Hello World"";
+    final int numClients = 1;
+    final ZooKeeper[] clients = new ZooKeeper[numClients];
+    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMelementTest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
+    final byte[] takeResult[] = new byte[1][];
+    Thread takeThread = new Thread() {
+      public void run() {
+        try {
+          takeResult[0] = queueHandles[0].take();
+        } catch (KeeperException e) {
 
-        for (int i = 0; i < n; i++) {
-            String offerString = testString + i;
-            queueHandles[0].offer(offerString.getBytes());
-        }
+        } catch (InterruptedException e) {
 
-        for (int i = 0; i < m; i++) {
-            queueHandles[1].remove();
         }
-        Assert.assertEquals(new String(queueHandles[1].element()), testString + m);
-    }
+      }
+    };
+    takeThread.start();
 
-    @Test
-    public void testElement1() throws Exception {
-        createNremoveMelementTest(""/testElement1"", 1, 0);
-    }
+    Thread.sleep(1000);
+    Thread offerThread = new Thread() {
+      public void run() {
+        try {
+          queueHandles[0].offer(testString.getBytes(UTF_8));
+        } catch (KeeperException e) {
 
-    @Test
-    public void testElement2() throws Exception {
-        createNremoveMelementTest(""/testElement2"", 10, 2);
-    }
+        } catch (InterruptedException e) {
 
-    @Test
-    public void testElement3() throws Exception {
-        createNremoveMelementTest(""/testElement3"", 1000, 500);
+        }
+      }
+    };
+    offerThread.start();
+    offerThread.join();
+
+    takeThread.join();
+
+    Assert.assertTrue(takeResult[0] != null);
+    Assert.assertEquals(new String(takeResult[0], UTF_8), testString);
+  }
+
+  @Test
+  public void testTakeWait2() throws Exception {
+    String dir = ""/testTakeWait2"";
+    final String testString = ""Hello World"";
+    final int numClients = 1;
+    final ZooKeeper[] clients = new ZooKeeper[numClients];
+    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
+    int numAttempts = 2;
+    for (int i = 0; i < numAttempts; i++) {
+      final byte[] takeResult[] = new byte[1][];
+      final String threadTestString = testString + i;
+      Thread takeThread = new Thread() {
+        public void run() {
+          try {
+            takeResult[0] = queueHandles[0].take();
+          } catch (KeeperException e) {
+
+          } catch (InterruptedException e) {
+
+          }
+        }
+      };","[{'comment': ""Another conversion of lambda/multi-catch to the old style code that should go back to the way it was. There's more below. I'll stop calling them out, but they should be changed back everywhere."", 'commenter': 'ctubbsii'}]"
882,zookeeper-recipes/zookeeper-recipes-queue/src/test/java/org/apache/zookeeper/recipes/queue/DistributedQueueTest.java,"@@ -27,243 +28,260 @@
 import org.junit.Test;
 
 /**
- * Tests for {@link DistributedQueue}.
+ * DistributedQueueTest test.
  */
 public class DistributedQueueTest extends ClientBase {
 
-    @After
-    public void tearDown() throws Exception {
-        super.tearDown();
+  @After
+  public void tearDown() throws Exception {
+    super.tearDown();
+  }
+
+  @Test
+  public void testOffer1() throws Exception {
+    String dir = ""/testOffer1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer1() throws Exception {
-        String dir = ""/testOffer1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testOffer2() throws Exception {
+    String dir = ""/testOffer2"";
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testOffer2() throws Exception {
-        String dir = ""/testOffer2"";
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[1].remove();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[1].remove();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testTake1() throws Exception {
+    String dir = ""/testTake1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testTake1() throws Exception {
-        String dir = ""/testTake1"";
-        String testString = ""Hello World"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        queueHandles[0].offer(testString.getBytes());
-
-        byte[] dequeuedBytes = queueHandles[0].take();
-        Assert.assertEquals(new String(dequeuedBytes), testString);
+    queueHandles[0].offer(testString.getBytes(UTF_8));
+
+    byte[] dequeuedBytes = queueHandles[0].take();
+    Assert.assertEquals(new String(dequeuedBytes, UTF_8), testString);
+  }
+
+  @Test
+  public void testRemove1() throws Exception {
+    String dir = ""/testRemove1"";
+    String testString = ""Hello World"";
+    final int numClients = 1;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    @Test
-    public void testRemove1() throws Exception {
-        String dir = ""/testRemove1"";
-        final int numClients = 1;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        try {
-            queueHandles[0].remove();
-        } catch (NoSuchElementException e) {
-            return;
-        }
-
-        Assert.fail();
+    try {
+      queueHandles[0].remove();
+    } catch (NoSuchElementException e) {
+      return;
+    }
+    Assert.assertTrue(false);
+  }
+
+  public void createNremoveMtest(String dir, int n, int m) throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMtest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-
-        for (int i = 0; i < n; i++) {
-            String offerString = testString + i;
-            queueHandles[0].offer(offerString.getBytes());
-        }
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
+    }
 
-        byte[] data = null;
-        for (int i = 0; i < m; i++) {
-            data = queueHandles[1].remove();
-        }
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
+    }
+    Assert.assertEquals(new String(data, UTF_8), testString + (m - 1));
+  }
+
+  @Test
+  public void testRemove2() throws Exception {
+    createNremoveMtest(""/testRemove2"", 10, 2);
+  }
+
+  @Test
+  public void testRemove3() throws Exception {
+    createNremoveMtest(""/testRemove3"", 1000, 1000);
+  }
+
+  public void createNremoveMelementTest(String dir, int n, int m)
+      throws Exception {
+    String testString = ""Hello World"";
+    final int numClients = 2;
+    ZooKeeper[] clients = new ZooKeeper[numClients];
+    DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
+    }
 
-        Assert.assertNotNull(data);
-        Assert.assertEquals(new String(data), testString + (m - 1));
+    for (int i = 0; i < n; i++) {
+      String offerString = testString + i;
+      queueHandles[0].offer(offerString.getBytes(UTF_8));
     }
 
-    @Test
-    public void testRemove2() throws Exception {
-        createNremoveMtest(""/testRemove2"", 10, 2);
+    byte[] data = null;
+    for (int i = 0; i < m; i++) {
+      data = queueHandles[1].remove();
     }
-    @Test
-    public void testRemove3() throws Exception {
-        createNremoveMtest(""/testRemove3"", 1000, 1000);
+    Assert.assertEquals(new String(queueHandles[1].element(), UTF_8),
+        testString + m);
+  }
+
+  @Test
+  public void testElement1() throws Exception {
+    createNremoveMelementTest(""/testElement1"", 1, 0);
+  }
+
+  @Test
+  public void testElement2() throws Exception {
+    createNremoveMelementTest(""/testElement2"", 10, 2);
+  }
+
+  @Test
+  public void testElement3() throws Exception {
+    createNremoveMelementTest(""/testElement3"", 1000, 500);
+  }
+
+  @Test
+  public void testElement4() throws Exception {
+    createNremoveMelementTest(""/testElement4"", 1000, 1000 - 1);
+  }
+
+  @Test
+  public void testTakeWait1() throws Exception {
+    String dir = ""/testTakeWait1"";
+    final String testString = ""Hello World"";
+    final int numClients = 1;
+    final ZooKeeper[] clients = new ZooKeeper[numClients];
+    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
 
-    public void createNremoveMelementTest(String dir, int n, int m) throws Exception {
-        String testString = ""Hello World"";
-        final int numClients = 2;
-        ZooKeeper[] clients = new ZooKeeper[numClients];
-        DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
+    final byte[] takeResult[] = new byte[1][];
+    Thread takeThread = new Thread() {
+      public void run() {
+        try {
+          takeResult[0] = queueHandles[0].take();
+        } catch (KeeperException e) {
 
-        for (int i = 0; i < n; i++) {
-            String offerString = testString + i;
-            queueHandles[0].offer(offerString.getBytes());
-        }
+        } catch (InterruptedException e) {
 
-        for (int i = 0; i < m; i++) {
-            queueHandles[1].remove();
         }
-        Assert.assertEquals(new String(queueHandles[1].element()), testString + m);
-    }
+      }
+    };
+    takeThread.start();
 
-    @Test
-    public void testElement1() throws Exception {
-        createNremoveMelementTest(""/testElement1"", 1, 0);
-    }
+    Thread.sleep(1000);
+    Thread offerThread = new Thread() {
+      public void run() {
+        try {
+          queueHandles[0].offer(testString.getBytes(UTF_8));
+        } catch (KeeperException e) {
 
-    @Test
-    public void testElement2() throws Exception {
-        createNremoveMelementTest(""/testElement2"", 10, 2);
-    }
+        } catch (InterruptedException e) {
 
-    @Test
-    public void testElement3() throws Exception {
-        createNremoveMelementTest(""/testElement3"", 1000, 500);
+        }
+      }
+    };
+    offerThread.start();
+    offerThread.join();
+
+    takeThread.join();
+
+    Assert.assertTrue(takeResult[0] != null);
+    Assert.assertEquals(new String(takeResult[0], UTF_8), testString);
+  }
+
+  @Test
+  public void testTakeWait2() throws Exception {
+    String dir = ""/testTakeWait2"";
+    final String testString = ""Hello World"";
+    final int numClients = 1;
+    final ZooKeeper[] clients = new ZooKeeper[numClients];
+    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];
+    for (int i = 0; i < clients.length; i++) {
+      clients[i] = createClient();
+      queueHandles[i] = new DistributedQueue(clients[i], dir, null);
     }
+    int numAttempts = 2;
+    for (int i = 0; i < numAttempts; i++) {
+      final byte[] takeResult[] = new byte[1][];
+      final String threadTestString = testString + i;
+      Thread takeThread = new Thread() {
+        public void run() {
+          try {
+            takeResult[0] = queueHandles[0].take();
+          } catch (KeeperException e) {
+
+          } catch (InterruptedException e) {
+
+          }
+        }
+      };
+      takeThread.start();
 
-    @Test
-    public void testElement4() throws Exception {
-        createNremoveMelementTest(""/testElement4"", 1000, 1000 - 1);
-    }
+      Thread.sleep(1000);
+      Thread offerThread = new Thread() {
+        public void run() {
+          try {
+            queueHandles[0].offer(threadTestString.getBytes(UTF_8));
+          } catch (KeeperException e) {
+
+          } catch (InterruptedException e) {
 
-    @Test
-    public void testTakeWait1() throws Exception {
-        String dir = ""/testTakeWait1"";
-        final String testString = ""Hello World"";
-        final int numClients = 1;
-        final ZooKeeper[] clients = new ZooKeeper[numClients];
-        final DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
+          }
         }
+      };
+      offerThread.start();
+      offerThread.join();
 
-        final byte[][] takeResult = new byte[1][];
-        Thread takeThread = new Thread(() -> {
-            try {
-                takeResult[0] = queueHandles[0].take();
-            } catch (KeeperException | InterruptedException ignore) {
-                // no op
-            }
-        });
-        takeThread.start();
-
-        Thread.sleep(1000);
-        Thread offerThread = new Thread(() -> {
-            try {
-                queueHandles[0].offer(testString.getBytes());
-            } catch (KeeperException | InterruptedException ignore) {
-                // no op
-            }
-        });
-        offerThread.start();
-        offerThread.join();
-
-        takeThread.join();
-
-        Assert.assertNotNull(takeResult[0]);
-        Assert.assertEquals(new String(takeResult[0]), testString);
-    }
+      takeThread.join();
 
-    @Test
-    public void testTakeWait2() throws Exception {
-        String dir = ""/testTakeWait2"";
-        final String testString = ""Hello World"";
-        final int numClients = 1;
-        final ZooKeeper[] clients = new ZooKeeper[numClients];
-        final DistributedQueue[] queueHandles = new DistributedQueue[numClients];
-        for (int i = 0; i < clients.length; i++) {
-            clients[i] = createClient();
-            queueHandles[i] = new DistributedQueue(clients[i], dir, null);
-        }
-        int numAttempts = 2;
-        for (int i = 0; i < numAttempts; i++) {
-            final byte[][] takeResult = new byte[1][];
-            final String threadTestString = testString + i;
-            Thread takeThread = new Thread(() -> {
-                try {
-                    takeResult[0] = queueHandles[0].take();
-                } catch (KeeperException | InterruptedException ignore) {
-                    // no op
-                }
-            });
-            takeThread.start();
-
-            Thread.sleep(1000);
-            Thread offerThread = new Thread(() -> {
-                try {
-                    queueHandles[0].offer(threadTestString.getBytes());
-                } catch (KeeperException | InterruptedException ignore) {
-                    // no op
-                }
-            });
-            offerThread.start();
-            offerThread.join();
-
-            takeThread.join();
-
-            Assert.assertNotNull(takeResult[0]);
-            Assert.assertEquals(new String(takeResult[0]), threadTestString);
-        }
+      Assert.assertTrue(takeResult[0] != null);","[{'comment': 'should go back to assertNotNull', 'commenter': 'ctubbsii'}]"
882,zookeeper-server/src/main/java/org/apache/zookeeper/ServerAdminClient.java,"@@ -52,7 +53,7 @@ public static void ruok(String host, int port) {
             byte[] resBytes = new byte[4];
 
             int rc = is.read(resBytes);
-            String retv = new String(resBytes);
+            String retv = new String(resBytes, StandardCharsets.UTF_8);","[{'comment': 'These would be great to use static imports for the `UTF_8`, as was done in some of the other classes.', 'commenter': 'ctubbsii'}]"
882,zookeeper-server/src/main/java/org/apache/zookeeper/cli/ReconfigCommand.java,"@@ -152,7 +153,7 @@ public boolean exec() throws CliException {
             }
 
             byte[] curConfig = ((ZooKeeperAdmin) zk).reconfigure(joining, leaving, members, version, stat);
-            out.println(""Committed new configuration:\n"" + new String(curConfig));
+            out.println(""Committed new configuration:\n"" + new String(curConfig, StandardCharsets.UTF_8));","[{'comment': 'This should probably just be two `println` statements instead of appending a newline and using string concatenation.', 'commenter': 'ctubbsii'}]"
888,zookeeper-server/src/test/java/org/apache/zookeeper/server/DataTreeTest.java,"@@ -222,7 +222,7 @@ public void testPathTrieClearOnDeserialize() throws Exception {
         PathTrie pTrie = (PathTrie)pfield.get(dserTree);
 
         //Check that the node path is removed from pTrie
-        Assert.assertEquals(""/bug is still in pTrie"", """", pTrie.findMaxPrefix(""/bug""));
+        Assert.assertEquals(""/bug is still in pTrie"", ""/"", pTrie.findMaxPrefix(""/bug""));","[{'comment': 'The root node is always a prefix.  This change puts this method in line with the rest of the code base which all makes this assertion.', 'commenter': 'belugabehr'}]"
888,zookeeper-server/src/main/java/org/apache/zookeeper/common/PathTrie.java,"@@ -40,254 +46,275 @@
  *      (bc)
  *   cf/
  *   (cf)
- */    
+ */
 public class PathTrie {
-    /**
-     * the logger for this class
-     */
+
+    /** Logger for this class */
     private static final Logger LOG = LoggerFactory.getLogger(PathTrie.class);
-    
-    /**
-     * the root node of PathTrie
-     */
-    private final TrieNode rootNode ;
-    
+
+    /** Root node of PathTrie */
+    private final TrieNode rootNode;
+
+    private final ReadWriteLock lock = new ReentrantReadWriteLock(true);
+
+    private final Lock readLock = lock.readLock();
+
+    private final Lock writeLock = lock.writeLock();
+
     static class TrieNode {
-        boolean property = false;
+        final String value;
         final Map<String, TrieNode> children;
-        TrieNode parent = null;
+        boolean property;
+        TrieNode parent;
+
         /**
-         * create a trienode with parent
-         * as parameter
-         * @param parent the parent of this trienode
+         * Create a trie node with parent as parameter.
+         *
+         * @param parent the parent of this node
+         * @param value the value stored in this node
          */
-        private TrieNode(TrieNode parent) {
-            children = new HashMap<String, TrieNode>();
+        private TrieNode(TrieNode parent, String value) {
+            this.value = value;
             this.parent = parent;
+            this.property = false;
+            this.children = new HashMap<>(4);
         }
-        
+
         /**
-         * get the parent of this node
+         * Get the parent of this node.
+         *
          * @return the parent node
          */
         TrieNode getParent() {
             return this.parent;
         }
-        
+
         /**
-         * set the parent of this node
+         * set the parent of this node.
+         *
          * @param parent the parent to set to
          */
         void setParent(TrieNode parent) {
             this.parent = parent;
         }
-        
+
         /**
-         * a property that is set 
-         * for a node - making it 
-         * special.
+         * A property that is set for a node - making it special.
          */
         void setProperty(boolean prop) {
             this.property = prop;
         }
-        
-        /** the property of this
-         * node 
-         * @return the property for this
-         * node
+
+        /**
+         * The property of this node.
+         *
+         * @return the property for this node
          */
-        boolean getProperty() {
+        boolean hasProperty() {
             return this.property;
         }
+
+        /**
+         * The value stored in this node.
+         *
+         * @return the value stored in this node
+         */
+        public String getValue() {
+          return this.value;
+        }
+
         /**
-         * add a child to the existing node
+         * Add a child to the existing node.
+         *
          * @param childName the string name of the child
          * @param node the node that is the child
          */
         void addChild(String childName, TrieNode node) {
-            synchronized(children) {
-                if (children.containsKey(childName)) {
-                    return;
-                }
-                children.put(childName, node);
-            }
+            this.children.putIfAbsent(childName, node);
         }
-     
+
         /**
-         * delete child from this node
-         * @param childName the string name of the child to 
-         * be deleted
+         * Delete child from this node.
+         *
+         * @param childName the name of the child to be deleted
          */
         void deleteChild(String childName) {
-            synchronized(children) {
-                if (!children.containsKey(childName)) {
-                    return;
-                }
-                TrieNode childNode = children.get(childName);
-                // this is the only child node.
-                if (childNode.getChildren().length == 1) { 
+            this.children.computeIfPresent(childName, (key, childNode) -> {
+                // Node no longer has an external property associated
+                childNode.setProperty(false);
+
+                // Delete it if it has no children (is a leaf node)
+                if (childNode.isLeafNode()) {
                     childNode.setParent(null);
-                    children.remove(childName);
+                    return null;
                 }
-                else {
-                    // their are more child nodes
-                    // so just reset property.
-                    childNode.setProperty(false);
-                }
-            }
+
+                return childNode;
+            });
         }
-        
+
         /**
-         * return the child of a node mapping
-         * to the input childname
+         * Return the child of a node mapping to the input child name.
+         *
          * @param childName the name of the child
          * @return the child of a node
          */
         TrieNode getChild(String childName) {
-            synchronized(children) {
-               if (!children.containsKey(childName)) {
-                   return null;
-               }
-               else {
-                   return children.get(childName);
-               }
-            }
+            return this.children.get(childName);
         }
 
         /**
-         * get the list of children of this 
-         * trienode.
-         * @return the string list of its children
+         * Get the list of children of this trienode.
+         *
+         * @return A collection containing the node's children
          */
-        String[] getChildren() {
-           synchronized(children) {
-               return children.keySet().toArray(new String[0]);
-           }
+        Collection<String> getChildren() {
+            return children.keySet();
         }
-        
+
         /**
-         * get the string representation
-         * for this node
+         * Determine if this node is a leaf (has no children).
+         *
+         * @return true if this node is a lead node; otherwise false
          */
+        boolean isLeafNode() {
+            return children.isEmpty();
+        }
+
+        @Override
         public String toString() {
-            StringBuilder sb = new StringBuilder();
-            sb.append(""Children of trienode: "");
-            synchronized(children) {
-                for (String str: children.keySet()) {
-                    sb.append("" "" + str);
-                }
-            }
-            return sb.toString();
+          return ""TrieNode [name="" + value + "", property="" + property
+              + "", children="" + children.keySet() + ""]"";
         }
     }
-    
+
     /**
-     * construct a new PathTrie with
-     * a root node of /
+     * Construct a new PathTrie with a root node.
      */
     public PathTrie() {
-        this.rootNode = new TrieNode(null);
+        this.rootNode = new TrieNode(null, """");
     }
-    
+
     /**
-     * add a path to the path trie 
-     * @param path
+     * Add a path to the path trie.
+     *
+     * @param path the path to add to the trie
      */
-    public void addPath(String path) {
-        if (path == null) {
-            return;
-        }
-        String[] pathComponents = path.split(""/"");
-        TrieNode parent = rootNode;
-        String part = null;
-        if (pathComponents.length <= 1) {
-            throw new IllegalArgumentException(""Invalid path "" + path);
+    public void addPath(final String path) {
+        Objects.requireNonNull(path, ""Path cannot be null"");
+
+        final String[] pathComponents = StringUtils.split(path, '/');
+        if (pathComponents.length == 0) {
+            throw new IllegalArgumentException(""Invalid path: "" + path);
         }
-        for (int i=1; i<pathComponents.length; i++) {
-            part = pathComponents[i];
-            if (parent.getChild(part) == null) {
-                parent.addChild(part, new TrieNode(parent));
+
+        writeLock.lock();
+        try {
+            TrieNode parent = rootNode;
+            for (final String part : pathComponents) {
+                TrieNode child = parent.getChild(part);
+                if (child == null) {
+                    child = new TrieNode(parent, part);
+                    parent.addChild(part, child);","[{'comment': ""Let's take `addPath()` as an example.\r\n\r\nIn the previous version of `TrieNode` the class was already consistent, because methods were protected with synchronized and both getChild() and addChild() validated if the child was already added to `children`.\r\nFor instance, if a thread gets interrupted between getChild() and addChild() modifying the trie by adding the same child on another thread, the addChild() will be a no-op.\r\n\r\nIn your version `TrieNode` is no longer thread-safe, because you removed synchronized from all of its methods, but the entire tree is guarded by Read/Write lock in `PathTrie` class.\r\n\r\nThis seems to me heavier, because if multiple threads are manipulating different parts of the Trie, locking the entire object is not needed, because those threads are not conflicting. The previous version seems to me more accurate in certain workloads."", 'commenter': 'anmolnar'}]"
888,zookeeper-server/src/main/java/org/apache/zookeeper/common/PathTrie.java,"@@ -40,254 +46,275 @@
  *      (bc)
  *   cf/
  *   (cf)
- */    
+ */
 public class PathTrie {
-    /**
-     * the logger for this class
-     */
+
+    /** Logger for this class */
     private static final Logger LOG = LoggerFactory.getLogger(PathTrie.class);
-    
-    /**
-     * the root node of PathTrie
-     */
-    private final TrieNode rootNode ;
-    
+
+    /** Root node of PathTrie */
+    private final TrieNode rootNode;
+
+    private final ReadWriteLock lock = new ReentrantReadWriteLock(true);
+
+    private final Lock readLock = lock.readLock();
+
+    private final Lock writeLock = lock.writeLock();
+
     static class TrieNode {
-        boolean property = false;
+        final String value;
         final Map<String, TrieNode> children;
-        TrieNode parent = null;
+        boolean property;
+        TrieNode parent;
+
         /**
-         * create a trienode with parent
-         * as parameter
-         * @param parent the parent of this trienode
+         * Create a trie node with parent as parameter.
+         *
+         * @param parent the parent of this node
+         * @param value the value stored in this node
          */
-        private TrieNode(TrieNode parent) {
-            children = new HashMap<String, TrieNode>();
+        private TrieNode(TrieNode parent, String value) {
+            this.value = value;
             this.parent = parent;
+            this.property = false;
+            this.children = new HashMap<>(4);
         }
-        
+
         /**
-         * get the parent of this node
+         * Get the parent of this node.
+         *
          * @return the parent node
          */
         TrieNode getParent() {
             return this.parent;
         }
-        
+
         /**
-         * set the parent of this node
+         * set the parent of this node.
+         *
          * @param parent the parent to set to
          */
         void setParent(TrieNode parent) {
             this.parent = parent;
         }
-        
+
         /**
-         * a property that is set 
-         * for a node - making it 
-         * special.
+         * A property that is set for a node - making it special.
          */
         void setProperty(boolean prop) {
             this.property = prop;
         }
-        
-        /** the property of this
-         * node 
-         * @return the property for this
-         * node
+
+        /**
+         * The property of this node.
+         *
+         * @return the property for this node
          */
-        boolean getProperty() {
+        boolean hasProperty() {
             return this.property;
         }
+
+        /**
+         * The value stored in this node.
+         *
+         * @return the value stored in this node
+         */
+        public String getValue() {
+          return this.value;
+        }
+
         /**
-         * add a child to the existing node
+         * Add a child to the existing node.
+         *
          * @param childName the string name of the child
          * @param node the node that is the child
          */
         void addChild(String childName, TrieNode node) {
-            synchronized(children) {
-                if (children.containsKey(childName)) {
-                    return;
-                }
-                children.put(childName, node);
-            }
+            this.children.putIfAbsent(childName, node);
         }
-     
+
         /**
-         * delete child from this node
-         * @param childName the string name of the child to 
-         * be deleted
+         * Delete child from this node.
+         *
+         * @param childName the name of the child to be deleted
          */
         void deleteChild(String childName) {
-            synchronized(children) {
-                if (!children.containsKey(childName)) {
-                    return;
-                }
-                TrieNode childNode = children.get(childName);
-                // this is the only child node.
-                if (childNode.getChildren().length == 1) { 
+            this.children.computeIfPresent(childName, (key, childNode) -> {
+                // Node no longer has an external property associated
+                childNode.setProperty(false);
+
+                // Delete it if it has no children (is a leaf node)
+                if (childNode.isLeafNode()) {
                     childNode.setParent(null);
-                    children.remove(childName);
+                    return null;
                 }
-                else {
-                    // their are more child nodes
-                    // so just reset property.
-                    childNode.setProperty(false);
-                }
-            }
+
+                return childNode;
+            });
         }
-        
+
         /**
-         * return the child of a node mapping
-         * to the input childname
+         * Return the child of a node mapping to the input child name.
+         *
          * @param childName the name of the child
          * @return the child of a node
          */
         TrieNode getChild(String childName) {
-            synchronized(children) {
-               if (!children.containsKey(childName)) {
-                   return null;
-               }
-               else {
-                   return children.get(childName);
-               }
-            }
+            return this.children.get(childName);
         }
 
         /**
-         * get the list of children of this 
-         * trienode.
-         * @return the string list of its children
+         * Get the list of children of this trienode.
+         *
+         * @return A collection containing the node's children
          */
-        String[] getChildren() {
-           synchronized(children) {
-               return children.keySet().toArray(new String[0]);
-           }
+        Collection<String> getChildren() {
+            return children.keySet();
         }
-        
+
         /**
-         * get the string representation
-         * for this node
+         * Determine if this node is a leaf (has no children).
+         *
+         * @return true if this node is a lead node; otherwise false
          */
+        boolean isLeafNode() {
+            return children.isEmpty();
+        }
+
+        @Override
         public String toString() {
-            StringBuilder sb = new StringBuilder();
-            sb.append(""Children of trienode: "");
-            synchronized(children) {
-                for (String str: children.keySet()) {
-                    sb.append("" "" + str);
-                }
-            }
-            return sb.toString();
+          return ""TrieNode [name="" + value + "", property="" + property
+              + "", children="" + children.keySet() + ""]"";
         }
     }
-    
+
     /**
-     * construct a new PathTrie with
-     * a root node of /
+     * Construct a new PathTrie with a root node.
      */
     public PathTrie() {
-        this.rootNode = new TrieNode(null);
+        this.rootNode = new TrieNode(null, """");
     }
-    
+
     /**
-     * add a path to the path trie 
-     * @param path
+     * Add a path to the path trie.
+     *
+     * @param path the path to add to the trie
      */
-    public void addPath(String path) {
-        if (path == null) {
-            return;
-        }
-        String[] pathComponents = path.split(""/"");
-        TrieNode parent = rootNode;
-        String part = null;
-        if (pathComponents.length <= 1) {
-            throw new IllegalArgumentException(""Invalid path "" + path);
+    public void addPath(final String path) {
+        Objects.requireNonNull(path, ""Path cannot be null"");
+
+        final String[] pathComponents = StringUtils.split(path, '/');
+        if (pathComponents.length == 0) {
+            throw new IllegalArgumentException(""Invalid path: "" + path);
         }
-        for (int i=1; i<pathComponents.length; i++) {
-            part = pathComponents[i];
-            if (parent.getChild(part) == null) {
-                parent.addChild(part, new TrieNode(parent));
+
+        writeLock.lock();
+        try {
+            TrieNode parent = rootNode;
+            for (final String part : pathComponents) {
+                TrieNode child = parent.getChild(part);
+                if (child == null) {
+                    child = new TrieNode(parent, part);
+                    parent.addChild(part, child);
+                }
+                parent = child;
             }
-            parent = parent.getChild(part);
+            parent.setProperty(true);
+        } finally {
+            writeLock.lock();","[{'comment': ""Looks like there's a typo here: is should be `unlock()`"", 'commenter': 'anmolnar'}, {'comment': 'I pushed new version to fix this.  Thanks for the catch.', 'commenter': 'belugabehr'}]"
895,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -2278,7 +2278,6 @@ public QuorumCnxManager createCnxnManager() {
                 this.getView(),
                 this.authServer,
                 this.authLearner,
-                this.tickTime * this.syncLimit,","[{'comment': 'This seems unrelated', 'commenter': 'eolivelli'}, {'comment': 'This corresponds to removing `int socketTimeout` from the constructor of QuorumCnxManager.', 'commenter': 'enixon'}, {'comment': 'Sorry I misread the diff', 'commenter': 'eolivelli'}]"
898,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/Commands.java,"@@ -62,13 +64,17 @@
     /** Maps command names to Command instances */
     private static Map<String, Command> commands = new HashMap<String, Command>();
     private static Set<String> primaryNames = new HashSet<String>();
+    private static Set<String> commandsAvailableBeforePeerSync = new HashSet<String>();
 
     /**
      * Registers the given command. Registered commands can be run by passing
      * any of their names to runCommand.
      */
-    public static void registerCommand(Command command) {
+    public static void registerCommand(Command command, boolean enabledBeforePeerSync) {","[{'comment': 'nit: You can overload the constructor to avoid modifying the signature at so many places.', 'commenter': 'anmolnar'}]"
898,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/Commands.java,"@@ -317,79 +322,81 @@ public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
      */
     public static class MonitorCommand extends CommandBase {
         public MonitorCommand() {
-            super(Arrays.asList(""monitor"", ""mntr""));
+            super(Arrays.asList(""monitor"", ""mntr""), false);
         }
 
         @Override
         public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs) {
-            ZKDatabase zkdb = zkServer.getZKDatabase();
-            ServerStats stats = zkServer.serverStats();
-
             CommandResponse response = initializeResponse();
 
             response.put(""version"", Version.getFullVersion());
 
-            response.put(""avg_latency"", stats.getAvgLatency());
-            response.put(""max_latency"", stats.getMaxLatency());
-            response.put(""min_latency"", stats.getMinLatency());
+            OSMXBean osMbean = new OSMXBean();
+            response.put(""open_file_descriptor_count"", osMbean.getOpenFileDescriptorCount());
+            response.put(""max_file_descriptor_count"", osMbean.getMaxFileDescriptorCount());
 
-            response.put(""packets_received"", stats.getPacketsReceived());
-            response.put(""packets_sent"", stats.getPacketsSent());
-            response.put(""num_alive_connections"", stats.getNumAliveClientConnections());
+            if (zkServer != null) {
+                ZKDatabase zkdb = zkServer.getZKDatabase();
+                ServerStats stats = zkServer.serverStats();
+                response.put(""avg_latency"", stats.getAvgLatency());
+                response.put(""max_latency"", stats.getMaxLatency());
+                response.put(""min_latency"", stats.getMinLatency());
 
-            response.put(""outstanding_requests"", stats.getOutstandingRequests());
-            response.put(""uptime"", stats.getUptime());
+                response.put(""packets_received"", stats.getPacketsReceived());
+                response.put(""packets_sent"", stats.getPacketsSent());
+                response.put(""num_alive_connections"", stats.getNumAliveClientConnections());
 
-            response.put(""server_state"", stats.getServerState());
-            response.put(""znode_count"", zkdb.getNodeCount());
+                response.put(""outstanding_requests"", stats.getOutstandingRequests());
+                response.put(""uptime"", stats.getUptime());
 
-            response.put(""watch_count"", zkdb.getDataTree().getWatchCount());
-            response.put(""ephemerals_count"", zkdb.getDataTree().getEphemeralsCount());
-            response.put(""approximate_data_size"", zkdb.getDataTree().cachedApproximateDataSize());
+                response.put(""server_state"", stats.getServerState());
+                response.put(""znode_count"", zkdb.getNodeCount());
 
-            response.put(""global_sessions"", zkdb.getSessionCount());
-            response.put(""local_sessions"",
-                    zkServer.getSessionTracker().getLocalSessionCount());
+                response.put(""watch_count"", zkdb.getDataTree().getWatchCount());
+                response.put(""ephemerals_count"", zkdb.getDataTree().getEphemeralsCount());
+                response.put(""approximate_data_size"", zkdb.getDataTree().cachedApproximateDataSize());
 
-            OSMXBean osMbean = new OSMXBean();
-            response.put(""open_file_descriptor_count"", osMbean.getOpenFileDescriptorCount());
-            response.put(""max_file_descriptor_count"", osMbean.getMaxFileDescriptorCount());
-            response.put(""connection_drop_probability"", zkServer.getConnectionDropChance());
+                response.put(""global_sessions"", zkdb.getSessionCount());
+                response.put(""local_sessions"",
+                        zkServer.getSessionTracker().getLocalSessionCount());
 
-            response.put(""last_client_response_size"", stats.getClientResponseStats().getLastBufferSize());
-            response.put(""max_client_response_size"", stats.getClientResponseStats().getMaxBufferSize());
-            response.put(""min_client_response_size"", stats.getClientResponseStats().getMinBufferSize());
+                response.put(""connection_drop_probability"", zkServer.getConnectionDropChance());
 
-            if (zkServer instanceof QuorumZooKeeperServer) {
-                QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;
-                response.put(""quorum_size"", peer.getQuorumSize());
-            }
+                response.put(""last_client_response_size"", stats.getClientResponseStats().getLastBufferSize());
+                response.put(""max_client_response_size"", stats.getClientResponseStats().getMaxBufferSize());
+                response.put(""min_client_response_size"", stats.getClientResponseStats().getMinBufferSize());
 
-            if (zkServer instanceof LeaderZooKeeperServer) {
-                Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();
-
-                response.put(""learners"", leader.getLearners().size());
-                response.put(""synced_followers"", leader.getForwardingFollowers().size());
-                response.put(""synced_non_voting_followers"", leader.getNonVotingFollowers().size());
-                response.put(""synced_observers"", leader.getObservingLearners().size());
-                response.put(""pending_syncs"", leader.getNumPendingSyncs());
-                response.put(""leader_uptime"", leader.getUptime());
-
-                response.put(""last_proposal_size"", leader.getProposalStats().getLastBufferSize());
-                response.put(""max_proposal_size"", leader.getProposalStats().getMaxBufferSize());
-                response.put(""min_proposal_size"", leader.getProposalStats().getMinBufferSize());
-            }
+                if (zkServer instanceof QuorumZooKeeperServer) {","[{'comment': 'Ops.\r\nI have changed this code on https://github.com/apache/zookeeper/pull/918\r\nMaybe we can commit #918 as @enixon you already reviewed it and we are waiting for the final word from @lvfangmin', 'commenter': 'eolivelli'}, {'comment': "":) \r\n\r\nNot an issue, I'm happy to fix up any conflicts if yours lands first."", 'commenter': 'enixon'}]"
899,zookeeper-server/src/main/java/org/apache/zookeeper/ZKUtil.java,"@@ -45,20 +48,67 @@
      *
      * @throws IllegalArgumentException if an invalid path is specified
      */
-    public static void deleteRecursive(ZooKeeper zk, final String pathRoot)
+    public static boolean deleteRecursive(ZooKeeper zk, final String pathRoot)
         throws InterruptedException, KeeperException
     {
         PathUtils.validatePath(pathRoot);
 
         List<String> tree = listSubTreeBFS(zk, pathRoot);
         LOG.debug(""Deleting "" + tree);
         LOG.debug(""Deleting "" + tree.size() + "" subnodes "");
-        for (int i = tree.size() - 1; i >= 0 ; --i) {
-            //Delete the leaves first and eventually get rid of the root
-            zk.delete(tree.get(i), -1); //Delete all versions of the node with -1.
+
+        int asyncReqRateLimit = 10;
+        // Try deleting the tree nodes in batches of size 1000.
+        // If some batch failed, try again with batches of size 1 to delete as
+        // many nodes as possible.
+        boolean success = deleteInBatch(zk, tree, 1000, asyncReqRateLimit);
+        if (!success) {
+            LOG.debug(""Failed to delete all nodes in batches of 1000."");
+            LOG.debug(""Retry with batches of size 1..."");
+            success = deleteInBatch(zk, tree, 1, asyncReqRateLimit);
+        }
+        return success;
+    }
+
+    private static class BatchedDeleteCbContext {
+        public Semaphore sem;
+        public AtomicBoolean success;
+
+        public BatchedDeleteCbContext(int rateLimit) {
+            sem = new Semaphore(rateLimit);
+            success = new AtomicBoolean(true);
         }
     }
 
+    private static boolean deleteInBatch(ZooKeeper zk, List<String> tree,
+        int batchSize, int rateLimit)
+        throws InterruptedException
+    {
+        List<Op> ops = new ArrayList<>();
+        BatchedDeleteCbContext context = new BatchedDeleteCbContext(rateLimit);
+        MultiCallback cb = (rc, path, ctx, opResults) -> {
+            ((BatchedDeleteCbContext)ctx).sem.release();
+            if (rc != Code.OK.intValue()) {
+                ((BatchedDeleteCbContext)ctx).success.set(false);","[{'comment': 'Is there a way to fast fail and exit the loop at line 97 in case of failure?', 'commenter': 'eolivelli'}, {'comment': ""This is certainly possible (and I just did) but the desirability of a fail-fast depends on the reason that the delete failed. If the problem applies to a small subset of the target nodes of the subtree then it strikes me as best to honor the original command intent and at least attempt all the deletes to get as many as possible to succeed. If the problem applies to many of the targets then better not to waste the user's time.\r\n\r\nI've included a new test to demonstrate such a scenario."", 'commenter': 'enixon'}]"
899,zookeeper-server/src/main/java/org/apache/zookeeper/ZKUtil.java,"@@ -45,20 +48,67 @@
      *
      * @throws IllegalArgumentException if an invalid path is specified
      */
-    public static void deleteRecursive(ZooKeeper zk, final String pathRoot)
+    public static boolean deleteRecursive(ZooKeeper zk, final String pathRoot)
         throws InterruptedException, KeeperException
     {
         PathUtils.validatePath(pathRoot);
 
         List<String> tree = listSubTreeBFS(zk, pathRoot);
         LOG.debug(""Deleting "" + tree);
         LOG.debug(""Deleting "" + tree.size() + "" subnodes "");
-        for (int i = tree.size() - 1; i >= 0 ; --i) {
-            //Delete the leaves first and eventually get rid of the root
-            zk.delete(tree.get(i), -1); //Delete all versions of the node with -1.
+
+        int asyncReqRateLimit = 10;
+        // Try deleting the tree nodes in batches of size 1000.
+        // If some batch failed, try again with batches of size 1 to delete as
+        // many nodes as possible.
+        boolean success = deleteInBatch(zk, tree, 1000, asyncReqRateLimit);
+        if (!success) {
+            LOG.debug(""Failed to delete all nodes in batches of 1000."");
+            LOG.debug(""Retry with batches of size 1..."");
+            success = deleteInBatch(zk, tree, 1, asyncReqRateLimit);
+        }
+        return success;
+    }
+
+    private static class BatchedDeleteCbContext {
+        public Semaphore sem;
+        public AtomicBoolean success;
+
+        public BatchedDeleteCbContext(int rateLimit) {
+            sem = new Semaphore(rateLimit);
+            success = new AtomicBoolean(true);
         }
     }
 
+    private static boolean deleteInBatch(ZooKeeper zk, List<String> tree,
+        int batchSize, int rateLimit)
+        throws InterruptedException
+    {
+        List<Op> ops = new ArrayList<>();
+        BatchedDeleteCbContext context = new BatchedDeleteCbContext(rateLimit);
+        MultiCallback cb = (rc, path, ctx, opResults) -> {
+            ((BatchedDeleteCbContext)ctx).sem.release();
+            if (rc != Code.OK.intValue()) {
+                ((BatchedDeleteCbContext)ctx).success.set(false);
+            }
+        };
+
+        // Delete the leaves first and eventually get rid of the root
+        for (int i = tree.size() - 1; i >= 0 ; --i) {
+            // Create Op to delete all versions of the node with -1.
+            ops.add(Op.delete(tree.get(i), -1));
+
+            if (ops.size() == batchSize || i == 0) {
+                context.sem.acquire();
+                zk.multi(ops, cb, context);
+                ops = new ArrayList<>();
+            }","[{'comment': 'Like if !success { break;}', 'commenter': 'eolivelli'}]"
899,zookeeper-server/src/main/java/org/apache/zookeeper/ZKUtil.java,"@@ -45,20 +48,67 @@
      *
      * @throws IllegalArgumentException if an invalid path is specified
      */
-    public static void deleteRecursive(ZooKeeper zk, final String pathRoot)
+    public static boolean deleteRecursive(ZooKeeper zk, final String pathRoot)
         throws InterruptedException, KeeperException
     {
         PathUtils.validatePath(pathRoot);
 
         List<String> tree = listSubTreeBFS(zk, pathRoot);
         LOG.debug(""Deleting "" + tree);
         LOG.debug(""Deleting "" + tree.size() + "" subnodes "");
-        for (int i = tree.size() - 1; i >= 0 ; --i) {
-            //Delete the leaves first and eventually get rid of the root
-            zk.delete(tree.get(i), -1); //Delete all versions of the node with -1.
+
+        int asyncReqRateLimit = 10;
+        // Try deleting the tree nodes in batches of size 1000.
+        // If some batch failed, try again with batches of size 1 to delete as
+        // many nodes as possible.","[{'comment': ""I am not sure whether this is the right decision. Besides the case where a 1000 node `multiOp` exceeds `JuteMaxBufferSize`, I believe the retry would result in an unsuccessful delete as well. As @eolivelli pointed it out, it would be great to have an early exit in `deleteInBatch` function otherwise the retry would encounter NoNodeExceptions as well.\r\nIn my opinion, it's better to return as soon as possible and warn the user that the `deleteAll` was not successful. If the problem was only a NoNodeException or some parallel changes that we were not aware, it would be probably still faster to rerun the batched version rather than retry with smaller sizes. (Except in case of a `Len error` where `JuteMaxBufferSize` is exceeded.)\r\nWhat do you think?\r\nIn any case, I believe this error handling logic worth a test case as well."", 'commenter': 'szepet'}, {'comment': ""To help capture a plausible scenario, I've added a new unit test as you suggest.\r\n\r\nUsing a multi-op batch mode is bound to be more brittle than using single operations. As a user, I'd rather that the tool retry in the more resilient mode if the less resilient suffered a failure rather than be asked to debug/retry manually."", 'commenter': 'enixon'}, {'comment': ""I agree with @szepet : I don't think we need this retry logic in the cli.\r\nI would just let the user know about the command failed because of this and that and let him decide whether he/she wants to retry with a different batch size."", 'commenter': 'anmolnar'}, {'comment': ""Oh, this is not the cli, but `ZKUtil`, so essentially it's a public api. Another reason not to be proactive."", 'commenter': 'anmolnar'}, {'comment': 'Now that batch mode is configurable, this more conservative approach is making more sense to me. \r\n\r\nAlternate idea - the tool swallows all errors until it has tried deleting every node and then presents all errors as a single aggregate instead of halting at the first error and presenting it.', 'commenter': 'enixon'}]"
899,zookeeper-server/src/main/java/org/apache/zookeeper/ZKUtil.java,"@@ -45,20 +48,71 @@
      *
      * @throws IllegalArgumentException if an invalid path is specified
      */
-    public static void deleteRecursive(ZooKeeper zk, final String pathRoot)
+    public static boolean deleteRecursive(ZooKeeper zk, final String pathRoot)
         throws InterruptedException, KeeperException
     {
         PathUtils.validatePath(pathRoot);
 
         List<String> tree = listSubTreeBFS(zk, pathRoot);
         LOG.debug(""Deleting "" + tree);
         LOG.debug(""Deleting "" + tree.size() + "" subnodes "");
-        for (int i = tree.size() - 1; i >= 0 ; --i) {
-            //Delete the leaves first and eventually get rid of the root
-            zk.delete(tree.get(i), -1); //Delete all versions of the node with -1.
+
+        int asyncReqRateLimit = 10;
+        // Try deleting the tree nodes in batches of size 1000.","[{'comment': 'Why 1000?\r\nWhat if we make it configurable somehow?', 'commenter': 'anmolnar'}, {'comment': ""1000 seemed like a reasonable number. I'm open to the idea of allowing the user to do their own custom tuning, we didn't go with it because the available schemes looked heavyweight and in practice, the users didn't care.\r\n\r\nTwo options: (1) take this property as a java/system arg or (2) modify the cli for deleteall to allow batch size as a parameter in addition to the path. Do you want to speak for one of these?"", 'commenter': 'enixon'}, {'comment': 'I like (2)\r\nLet it be 1000 by default and make overridable with an optional parameter.', 'commenter': 'anmolnar'}]"
904,zookeeper-server/src/test/java/org/apache/zookeeper/server/util/JvmPauseMonitorTest.java,"@@ -0,0 +1,133 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import org.apache.zookeeper.server.ServerConfig;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Properties;
+
+public class JvmPauseMonitorTest {
+
+    @Test
+    public void testJvmPauseMonitorInit() {
+        final Long sleepTime = 444L;
+        final Long warnTH = 5555L;
+        final Long infoTH = 555L;
+
+        ServerConfig serverConfig = new ServerConfig();
+        QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();
+
+        Assert.assertEquals(false, serverConfig.isJvmPauseMonitorToRun());
+        Assert.assertEquals(false, quorumPeerConfig.isJvmPauseMonitorToRun());
+
+        Properties zkProp = new Properties();
+        zkProp.setProperty(""dataDir"", new File(""myDataDir"").getAbsolutePath());
+        zkProp.setProperty(""jvm.pause.monitor"", ""true"");
+        zkProp.setProperty(""jvm.pause.sleep.time.ms"", sleepTime.toString());
+        zkProp.setProperty(""jvm.pause.warn-threshold.ms"", warnTH.toString());
+        zkProp.setProperty(""jvm.pause.info-threshold.ms"", infoTH.toString());
+        try {
+            quorumPeerConfig.parseProperties(zkProp);
+        } catch (IOException | QuorumPeerConfig.ConfigException e) {
+            Assert.fail(""Exception while reading config for JvmPauseMonitor"");
+        }
+        serverConfig.readFrom(quorumPeerConfig);
+
+        Assert.assertEquals(true, serverConfig.isJvmPauseMonitorToRun());
+        Assert.assertEquals(true, quorumPeerConfig.isJvmPauseMonitorToRun());
+
+        JvmPauseMonitor pauseMonitor = new JvmPauseMonitor(serverConfig);
+        Assert.assertFalse(pauseMonitor.isStarted());
+        pauseMonitor.serviceStart();
+        Assert.assertTrue(pauseMonitor.isStarted());
+
+        Assert.assertEquals(sleepTime, Long.valueOf(pauseMonitor.sleepTimeMs));
+        Assert.assertEquals(warnTH, Long.valueOf(pauseMonitor.warnThresholdMs));
+        Assert.assertEquals(infoTH, Long.valueOf(pauseMonitor.infoThresholdMs));
+    }
+
+    @Test
+    public void testJvmPauseMonitorExceedInfoThreshold() throws InterruptedException {
+        final Long sleepTime = 100L;
+        final Long infoTH = -1L;
+
+        ServerConfig serverConfig = new ServerConfig();
+        QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();
+
+        Properties zkProp = new Properties();
+        zkProp.setProperty(""dataDir"", new File(""myDataDir"").getAbsolutePath());
+        zkProp.setProperty(""jvm.pause.monitor"", ""true"");
+        zkProp.setProperty(""jvm.pause.sleep.time.ms"", sleepTime.toString());
+        zkProp.setProperty(""jvm.pause.info-threshold.ms"", infoTH.toString());
+        try {
+            quorumPeerConfig.parseProperties(zkProp);
+        } catch (IOException | QuorumPeerConfig.ConfigException e) {
+            Assert.fail(""Exception while reading config for JvmPauseMonitor"");
+        }
+        serverConfig.readFrom(quorumPeerConfig);
+
+        JvmPauseMonitor pauseMonitor = new JvmPauseMonitor(serverConfig);
+        pauseMonitor.serviceStart();","[{'comment': ""Don't we have to stop it?"", 'commenter': 'eolivelli'}]"
904,zookeeper-server/src/test/java/org/apache/zookeeper/server/util/JvmPauseMonitorTest.java,"@@ -0,0 +1,133 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import org.apache.zookeeper.server.ServerConfig;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Properties;
+
+public class JvmPauseMonitorTest {
+
+    @Test
+    public void testJvmPauseMonitorInit() {
+        final Long sleepTime = 444L;
+        final Long warnTH = 5555L;
+        final Long infoTH = 555L;
+
+        ServerConfig serverConfig = new ServerConfig();
+        QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();
+
+        Assert.assertEquals(false, serverConfig.isJvmPauseMonitorToRun());
+        Assert.assertEquals(false, quorumPeerConfig.isJvmPauseMonitorToRun());
+
+        Properties zkProp = new Properties();
+        zkProp.setProperty(""dataDir"", new File(""myDataDir"").getAbsolutePath());
+        zkProp.setProperty(""jvm.pause.monitor"", ""true"");
+        zkProp.setProperty(""jvm.pause.sleep.time.ms"", sleepTime.toString());
+        zkProp.setProperty(""jvm.pause.warn-threshold.ms"", warnTH.toString());
+        zkProp.setProperty(""jvm.pause.info-threshold.ms"", infoTH.toString());
+        try {
+            quorumPeerConfig.parseProperties(zkProp);
+        } catch (IOException | QuorumPeerConfig.ConfigException e) {
+            Assert.fail(""Exception while reading config for JvmPauseMonitor"");
+        }
+        serverConfig.readFrom(quorumPeerConfig);
+
+        Assert.assertEquals(true, serverConfig.isJvmPauseMonitorToRun());
+        Assert.assertEquals(true, quorumPeerConfig.isJvmPauseMonitorToRun());
+
+        JvmPauseMonitor pauseMonitor = new JvmPauseMonitor(serverConfig);
+        Assert.assertFalse(pauseMonitor.isStarted());
+        pauseMonitor.serviceStart();
+        Assert.assertTrue(pauseMonitor.isStarted());
+
+        Assert.assertEquals(sleepTime, Long.valueOf(pauseMonitor.sleepTimeMs));
+        Assert.assertEquals(warnTH, Long.valueOf(pauseMonitor.warnThresholdMs));
+        Assert.assertEquals(infoTH, Long.valueOf(pauseMonitor.infoThresholdMs));
+    }
+
+    @Test
+    public void testJvmPauseMonitorExceedInfoThreshold() throws InterruptedException {
+        final Long sleepTime = 100L;
+        final Long infoTH = -1L;
+
+        ServerConfig serverConfig = new ServerConfig();
+        QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();
+
+        Properties zkProp = new Properties();
+        zkProp.setProperty(""dataDir"", new File(""myDataDir"").getAbsolutePath());
+        zkProp.setProperty(""jvm.pause.monitor"", ""true"");
+        zkProp.setProperty(""jvm.pause.sleep.time.ms"", sleepTime.toString());
+        zkProp.setProperty(""jvm.pause.info-threshold.ms"", infoTH.toString());
+        try {
+            quorumPeerConfig.parseProperties(zkProp);
+        } catch (IOException | QuorumPeerConfig.ConfigException e) {
+            Assert.fail(""Exception while reading config for JvmPauseMonitor"");
+        }
+        serverConfig.readFrom(quorumPeerConfig);
+
+        JvmPauseMonitor pauseMonitor = new JvmPauseMonitor(serverConfig);
+        pauseMonitor.serviceStart();
+
+        Assert.assertEquals(sleepTime, Long.valueOf(pauseMonitor.sleepTimeMs));
+        Assert.assertEquals(infoTH, Long.valueOf(pauseMonitor.infoThresholdMs));
+
+        Thread.sleep(1000);","[{'comment': 'It is better to have a loop and wait at most X seconds for the condition to be true.\r\nThis way we will reduce flakyness', 'commenter': 'eolivelli'}]"
904,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/JvmPauseMonitor.java,"@@ -0,0 +1,209 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import org.apache.zookeeper.server.ServerConfig;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.lang.management.GarbageCollectorMXBean;
+import java.lang.management.ManagementFactory;
+import java.time.Instant;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.List;
+
+/**
+ * This code is originally from hadoop-common, see:
+ * https://github.com/apache/hadoop/blob/trunk/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/JvmPauseMonitor.java
+ *
+ * Class which sets up a simple thread which runs in a loop sleeping
+ * for a short interval of time. If the sleep takes significantly longer
+ * than its target time, it implies that the JVM or host machine has
+ * paused processing, which may cause other problems. If such a pause is
+ * detected, the thread logs a message.
+ */
+public class JvmPauseMonitor {
+    private static final Logger LOG = LoggerFactory.getLogger(JvmPauseMonitor.class);
+
+    public static final String JVM_PAUSE_MONITOR_FEATURE_SWITCH_KEY = ""jvm.pause.monitor"";
+
+    /** The target sleep time */
+    protected long sleepTimeMs;
+    public static final String SLEEP_TIME_MS_KEY = ""jvm.pause.sleep.time.ms"";
+    public static final long SLEEP_TIME_MS_DEFAULT = 500;
+
+    /** log WARN if we detect a pause longer than this threshold */
+    protected long warnThresholdMs;
+    public static final String WARN_THRESHOLD_KEY = ""jvm.pause.warn-threshold.ms"";
+    public static final long WARN_THRESHOLD_DEFAULT = 10000;
+
+    /** log INFO if we detect a pause longer than this threshold */
+    protected long infoThresholdMs;
+    public static final String INFO_THRESHOLD_KEY = ""jvm.pause.info-threshold.ms"";
+    public static final long INFO_THRESHOLD_DEFAULT = 1000;
+
+    private long numGcWarnThresholdExceeded = 0;
+    private long numGcInfoThresholdExceeded = 0;
+    private long totalGcExtraSleepTime = 0;
+
+    private Thread monitorThread;
+    private volatile boolean shouldRun = true;
+
+    public JvmPauseMonitor(QuorumPeerConfig config) {
+        this.warnThresholdMs = config.getJvmPauseWarnThresholdMs();
+        this.infoThresholdMs = config.getJvmPauseInfoThresholdMs();
+        this.sleepTimeMs = config.getJvmPauseSleepTimeMs();
+    }
+
+    public JvmPauseMonitor(ServerConfig config) {
+        this.warnThresholdMs = config.getJvmPauseWarnThresholdMs();
+        this.infoThresholdMs = config.getJvmPauseInfoThresholdMs();
+        this.sleepTimeMs = config.getJvmPauseSleepTimeMs();
+    }
+
+    public void serviceStart() {
+        monitorThread = new Thread(new JVMMonitor());
+        monitorThread.setDaemon(true);
+        monitorThread.start();
+    }
+
+    public void serviceStop() {
+        shouldRun = false;
+        if (monitorThread != null) {
+            monitorThread.interrupt();
+            try {
+                monitorThread.join();
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+            }
+        }
+    }
+
+    public boolean isStarted() {
+        return monitorThread != null;
+    }
+
+    public long getNumGcWarnThresholdExceeded() {
+        return numGcWarnThresholdExceeded;
+    }
+
+    public long getNumGcInfoThresholdExceeded() {
+        return numGcInfoThresholdExceeded;
+    }
+
+    public long getTotalGcExtraSleepTime() {
+        return totalGcExtraSleepTime;
+    }
+
+    private String formatMessage(long extraSleepTime,
+                                 Map<String, GcTimes> gcTimesAfterSleep,
+                                 Map<String, GcTimes> gcTimesBeforeSleep) {
+
+        Set<String> gcBeanNames = new HashSet<>(gcTimesAfterSleep.keySet());
+        gcBeanNames.retainAll(gcTimesBeforeSleep.keySet());
+        List<String> gcDiffs = new ArrayList<>();
+
+        for (String name : gcBeanNames) {
+            GcTimes diff = gcTimesAfterSleep.get(name).subtract(gcTimesBeforeSleep.get(name));
+            if (diff.gcCount != 0) {
+                gcDiffs.add(""GC pool '"" + name + ""' had collection(s): "" + diff.toString());
+            }
+        }
+
+        String ret = ""Detected pause in JVM or host machine (eg GC): pause of approximately "" + extraSleepTime","[{'comment': 'Use `String.format` instead?', 'commenter': 'anmolnar'}]"
904,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/QuorumPeerConfigTest.java,"@@ -148,6 +146,28 @@ public void testClientAddrFromClientPort()
         assertEquals(quorumPeerConfig.getClientPortAddress(), qs.clientAddr);
     }
 
+    @Test
+    public void testJvmPauseMonitorConfigured()
+            throws IOException, ConfigException {
+        final Long sleepTime = 444L;
+        final Long warnTH = 5555L;
+        final Long infoTH = 555L;
+
+        QuorumPeerConfig quorumPeerConfig = new MockQuorumPeerConfig(1);","[{'comment': 'Please don\'t use the ""mocked"" version here, it\'s not needed.', 'commenter': 'anmolnar'}]"
904,zookeeper-server/src/test/java/org/apache/zookeeper/server/util/JvmPauseMonitorTest.java,"@@ -0,0 +1,54 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
+import org.junit.Assert;
+import org.junit.Test;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+public class JvmPauseMonitorTest {
+
+    @Test(timeout=5000)
+    public void testJvmPauseMonitorExceedThreshold() throws InterruptedException {
+        final Long sleepTime = 100L;
+        final Long warnTH = -1L;
+        final Long infoTH = -1L;
+
+        QuorumPeerConfig qpConfig = mock(QuorumPeerConfig.class);
+        when(qpConfig.getJvmPauseSleepTimeMs()).thenReturn(sleepTime);
+        when(qpConfig.getJvmPauseWarnThresholdMs()).thenReturn(warnTH);
+        when(qpConfig.getJvmPauseInfoThresholdMs()).thenReturn(infoTH);
+
+        JvmPauseMonitor pauseMonitor = new JvmPauseMonitor(qpConfig);
+        pauseMonitor.serviceStart();
+
+        Assert.assertEquals(sleepTime, Long.valueOf(pauseMonitor.sleepTimeMs));
+        Assert.assertEquals(warnTH, Long.valueOf(pauseMonitor.warnThresholdMs));
+        Assert.assertEquals(infoTH, Long.valueOf(pauseMonitor.infoThresholdMs));
+
+        while(pauseMonitor.getNumGcInfoThresholdExceeded() == 0 && pauseMonitor.getNumGcWarnThresholdExceeded() == 0) {","[{'comment': 'You might want to `||` here instead of `&&`.', 'commenter': 'anmolnar'}]"
904,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/JvmPauseMonitor.java,"@@ -0,0 +1,209 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import org.apache.zookeeper.server.ServerConfig;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.lang.management.GarbageCollectorMXBean;
+import java.lang.management.ManagementFactory;
+import java.time.Instant;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.List;
+
+/**
+ * This code is originally from hadoop-common, see:
+ * https://github.com/apache/hadoop/blob/trunk/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/JvmPauseMonitor.java
+ *
+ * Class which sets up a simple thread which runs in a loop sleeping
+ * for a short interval of time. If the sleep takes significantly longer
+ * than its target time, it implies that the JVM or host machine has
+ * paused processing, which may cause other problems. If such a pause is
+ * detected, the thread logs a message.
+ */
+public class JvmPauseMonitor {
+    private static final Logger LOG = LoggerFactory.getLogger(JvmPauseMonitor.class);
+
+    public static final String JVM_PAUSE_MONITOR_FEATURE_SWITCH_KEY = ""jvm.pause.monitor"";
+
+    /** The target sleep time */
+    protected long sleepTimeMs;
+    public static final String SLEEP_TIME_MS_KEY = ""jvm.pause.sleep.time.ms"";
+    public static final long SLEEP_TIME_MS_DEFAULT = 500;
+
+    /** log WARN if we detect a pause longer than this threshold */
+    protected long warnThresholdMs;
+    public static final String WARN_THRESHOLD_KEY = ""jvm.pause.warn-threshold.ms"";
+    public static final long WARN_THRESHOLD_DEFAULT = 10000;
+
+    /** log INFO if we detect a pause longer than this threshold */
+    protected long infoThresholdMs;
+    public static final String INFO_THRESHOLD_KEY = ""jvm.pause.info-threshold.ms"";
+    public static final long INFO_THRESHOLD_DEFAULT = 1000;
+
+    private long numGcWarnThresholdExceeded = 0;
+    private long numGcInfoThresholdExceeded = 0;
+    private long totalGcExtraSleepTime = 0;
+
+    private Thread monitorThread;
+    private volatile boolean shouldRun = true;
+
+    public JvmPauseMonitor(QuorumPeerConfig config) {
+        this.warnThresholdMs = config.getJvmPauseWarnThresholdMs();
+        this.infoThresholdMs = config.getJvmPauseInfoThresholdMs();
+        this.sleepTimeMs = config.getJvmPauseSleepTimeMs();
+    }
+
+    public JvmPauseMonitor(ServerConfig config) {
+        this.warnThresholdMs = config.getJvmPauseWarnThresholdMs();
+        this.infoThresholdMs = config.getJvmPauseInfoThresholdMs();
+        this.sleepTimeMs = config.getJvmPauseSleepTimeMs();
+    }
+
+    public void serviceStart() {
+        monitorThread = new Thread(new JVMMonitor());
+        monitorThread.setDaemon(true);
+        monitorThread.start();
+    }
+
+    public void serviceStop() {","[{'comment': 'This method is only used in the test currently. Please add it to `shutdown()` methods of `ZooKeeperServer` and `QuorumPeer` classes.', 'commenter': 'anmolnar'}]"
910,zookeeper-server/src/test/java/org/apache/zookeeper/test/InvalidSnapshotTest.java,"@@ -46,12 +45,13 @@
     /**
      * Verify the LogFormatter by running it on a known file.
      */
+    @SuppressWarnings(""deprecation"")
     @Test
     public void testLogFormatter() throws Exception {
         File snapDir = new File(testData, ""invalidsnap"");
         File logfile = new File(new File(snapDir, ""version-2""), ""log.274"");
         String[] args = {logfile.getCanonicalFile().toString()};
-        LogFormatter.main(args);
+        org.apache.zookeeper.server.LogFormatter.main(args);","[{'comment': 'Why have you removed the import and using full class name instead?', 'commenter': 'anmolnar'}, {'comment': 'because you cannot add @SuppressWarnings(""deprecated"") on an ""import"" clause', 'commenter': 'eolivelli'}]"
910,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/auth/MiniKdc.java,"@@ -103,7 +103,7 @@ public static void main(String[] args) throws Exception {
         Properties userConf = new Properties();
         InputStreamReader r = null;
         try {
-            r = new InputStreamReader(new FileInputStream(file), Charsets.UTF_8);
+            r = new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8);","[{'comment': 'Why is this change?', 'commenter': 'anmolnar'}, {'comment': ""I can't remember. I have to check"", 'commenter': 'eolivelli'}, {'comment': '@anmolnar \r\nit is because org.apache.commons.io.Charsets.UTF_8 is deprecated', 'commenter': 'eolivelli'}]"
910,pom.xml,"@@ -470,6 +470,15 @@
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
           <version>3.8.0</version>
+          <configuration>
+             <compilerArgs>
+               <compilerArg>-Werror</compilerArg>","[{'comment': 'If I understand it correctly now we generate warnings for ""deprecated"" and ""unchecked"" code snippets which will eventually become errors.', 'commenter': 'anmolnar'}, {'comment': 'yes, this is the core part of this change', 'commenter': 'eolivelli'}]"
910,zookeeper-server/src/main/java/org/apache/zookeeper/server/metric/AvgMinMaxCounter.java,"@@ -69,7 +70,7 @@ public double getAvg() {
         if (currentCount > 0) {
             double avgLatency = currentTotal / (double)currentCount;
             BigDecimal bg = new BigDecimal(avgLatency);
-            return bg.setScale(4, BigDecimal.ROUND_HALF_UP).doubleValue();
+            return bg.setScale(4, RoundingMode.HALF_UP).doubleValue();","[{'comment': 'this is deprecated on JDK12 and the build fails on my laptop now', 'commenter': 'eolivelli'}]"
910,zookeeper-server/src/main/java/org/apache/zookeeper/server/watch/WatchManagerFactory.java,"@@ -39,7 +39,8 @@ public static IWatchManager createWatchManager() throws IOException {
         }
         try {
             IWatchManager watchManager =
-                    (IWatchManager) Class.forName(watchManagerName).newInstance();
+                    (IWatchManager) Class.forName(watchManagerName)","[{'comment': 'this is deprecated on JDK10+ and the build fails on Travis', 'commenter': 'eolivelli'}]"
910,zookeeper-server/src/main/java/org/apache/zookeeper/metrics/impl/MetricsProviderBootstrap.java,"@@ -34,11 +35,12 @@ public static MetricsProvider startMetricsProvider(String metricsProviderClassNa
             throws MetricsProviderLifeCycleException {
         try {
             MetricsProvider metricsProvider = (MetricsProvider) Class.forName(metricsProviderClassName,
-                    true, Thread.currentThread().getContextClassLoader()).newInstance();
+                    true, Thread.currentThread().getContextClassLoader()).getConstructor().newInstance();","[{'comment': 'this is deprecated on JDK10+ and the build fails on Travis', 'commenter': 'eolivelli'}]"
910,zookeeper-server/src/test/java/org/apache/zookeeper/test/ReconfigTest.java,"@@ -997,7 +997,7 @@ public void testJMXBeanAfterRoleChange() throws Exception {
         int changingIndex = 1;
         int replica2 = 2;
         QuorumPeer peer2 = qu.getPeer(replica2).peer;
-        QuorumServer changingQS2 = peer2.getView().get(new Long(changingIndex));","[{'comment': 'this is deprecated on JDK10+ and the build fails on Travis', 'commenter': 'eolivelli'}]"
910,zookeeper-server/src/test/java/org/apache/zookeeper/test/LoadFromLogTest.java,"@@ -179,7 +179,7 @@ public void testRestore() throws Exception {
         String[] tokens = lastPath.split(""-"");
         String expectedPath = ""/invalidsnap/test-""
                 + String.format(""%010d"",
-                (new Integer(tokens[1])).intValue() + 1);","[{'comment': 'this is deprecated on JDK10+ and the build fails on Travis', 'commenter': 'eolivelli'}]"
911,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -512,44 +511,34 @@ public InetSocketAddress getLocalAddress() {
         return localAddress;
     }
 
-    private void addCnxn(NettyServerCnxn cnxn) {
+    private void addCnxn(final NettyServerCnxn cnxn) {
         cnxns.add(cnxn);
-        synchronized (ipMap){
-            InetAddress addr =
-                ((InetSocketAddress)cnxn.getChannel().remoteAddress()).getAddress();
-            Set<NettyServerCnxn> s = ipMap.get(addr);
-            if (s == null) {
-                s = new HashSet<>();
-                ipMap.put(addr, s);
+        InetAddress addr =
+            ((InetSocketAddress) cnxn.getChannel().remoteAddress()).getAddress();
+
+        ipMap.compute(addr, (a, cnxnSet) -> {
+            if (cnxnSet == null) {
+                cnxnSet = new HashSet<>();
             }
-            s.add(cnxn);
-        }
+            cnxnSet.add(cnxn);","[{'comment': 'You can do this out of the lambda, this way you will make the critical section as small as possible\r\n\r\nOr are you doing do in order not to synchronize explicitly on the Set which is a raw HashSet?', 'commenter': 'eolivelli'}, {'comment': '@eolivelli \r\n\r\nTake a look at the Map API for [computeIfAbsert](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#computeIfAbsent-K-java.util.function.Function-).  They provide an example of how to use it:\r\n\r\n```\r\nto implement a multi-value map, Map<K,Collection<V>>, supporting multiple values per key:\r\n \r\n map.computeIfAbsent(key, k -> new HashSet<V>()).add(v);\r\n```\r\n\r\nThe example is for a simple case where there is no multi-threading and the map accumulates records without removing empty records.  However, in this situation, there are a few issues with this approach:\r\n\r\n1. The underlying `HashSet` is not synchronized, so two threads from the same source could cause issue on insert\r\n2. There is a clean-up routine in `removeCnxnFromIpMap` where a key is removed if its associated `Set` has no entries.  Well, that could also conflict here since it could be the case that the `Set` returned by the `computeIfAbsent` is returned, the Thread pauses, and then another thread deletes the key in `removeCnxnFromIpMap` and therefore when the Thread resumes the `add` happens on a `Set` that was removed.  Better to do it all in a protected area.', 'commenter': 'belugabehr'}]"
911,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -512,44 +511,34 @@ public InetSocketAddress getLocalAddress() {
         return localAddress;
     }
 
-    private void addCnxn(NettyServerCnxn cnxn) {
+    private void addCnxn(final NettyServerCnxn cnxn) {
         cnxns.add(cnxn);
-        synchronized (ipMap){
-            InetAddress addr =
-                ((InetSocketAddress)cnxn.getChannel().remoteAddress()).getAddress();
-            Set<NettyServerCnxn> s = ipMap.get(addr);
-            if (s == null) {
-                s = new HashSet<>();
-                ipMap.put(addr, s);
+        InetAddress addr =
+            ((InetSocketAddress) cnxn.getChannel().remoteAddress()).getAddress();
+
+        ipMap.compute(addr, (a, cnxnSet) -> {","[{'comment': 'computeIfAbsent ?', 'commenter': 'eolivelli'}]"
911,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -512,44 +511,34 @@ public InetSocketAddress getLocalAddress() {
         return localAddress;
     }
 
-    private void addCnxn(NettyServerCnxn cnxn) {
+    private void addCnxn(final NettyServerCnxn cnxn) {
         cnxns.add(cnxn);
-        synchronized (ipMap){
-            InetAddress addr =
-                ((InetSocketAddress)cnxn.getChannel().remoteAddress()).getAddress();
-            Set<NettyServerCnxn> s = ipMap.get(addr);
-            if (s == null) {
-                s = new HashSet<>();
-                ipMap.put(addr, s);
+        InetAddress addr =
+            ((InetSocketAddress) cnxn.getChannel().remoteAddress()).getAddress();
+
+        ipMap.compute(addr, (a, cnxnSet) -> {
+            if (cnxnSet == null) {
+                cnxnSet = new HashSet<>();
             }
-            s.add(cnxn);
-        }
+            cnxnSet.add(cnxn);
+            return cnxnSet;
+        });
     }
-
+  
     void removeCnxnFromIpMap(NettyServerCnxn cnxn, InetAddress remoteAddress) {
-        synchronized (ipMap) {
-            Set<NettyServerCnxn> s = ipMap.get(remoteAddress);
-            if (s != null) {
-                s.remove(cnxn);
-                if (s.isEmpty()) {
-                    ipMap.remove(remoteAddress);
-                }
-                return;
-            }
+        ipMap.compute(remoteAddress, (addr, cnxnSet) -> {
+        if (cnxnSet == null) {
+            LOG.error(""Unexpected remote address {} when removing cnxn {}"",
+                remoteAddress, cnxn);
+            cnxnSet = Collections.emptySet();
         }
-        // Fallthrough and log errors outside the synchronized block
-        LOG.error(
-                ""Unexpected null set for remote address {} when removing cnxn {}"",
-                remoteAddress,
-                cnxn);
+        cnxnSet.remove(cnxn);","[{'comment': 'It will throw an error for emptySet', 'commenter': 'eolivelli'}, {'comment': ""Can you please share with me how you came to the conclusion that an error would be thrown?\r\n\r\nThe [remove](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#remove-java.lang.Object-) method returns a boolean to indicate if the removal was successful.  I can move the `remove` call into the check  if there is concern that somehow it could be the case that there is a Connection that isn't associated with an address.  I don't know how that would be the case.  But could improve with:\r\n\r\n```\r\nif (cnxnSet == null || !cnxnSet.remove(cnxn)) {\r\n```"", 'commenter': 'belugabehr'}]"
911,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -512,44 +511,34 @@ public InetSocketAddress getLocalAddress() {
         return localAddress;
     }
 
-    private void addCnxn(NettyServerCnxn cnxn) {
+    private void addCnxn(final NettyServerCnxn cnxn) {
         cnxns.add(cnxn);
-        synchronized (ipMap){
-            InetAddress addr =
-                ((InetSocketAddress)cnxn.getChannel().remoteAddress()).getAddress();
-            Set<NettyServerCnxn> s = ipMap.get(addr);
-            if (s == null) {
-                s = new HashSet<>();
-                ipMap.put(addr, s);
+        InetAddress addr =
+            ((InetSocketAddress) cnxn.getChannel().remoteAddress()).getAddress();
+
+        ipMap.compute(addr, (a, cnxnSet) -> {
+            if (cnxnSet == null) {
+                cnxnSet = new HashSet<>();
             }
-            s.add(cnxn);
-        }
+            cnxnSet.add(cnxn);
+            return cnxnSet;
+        });
     }
-
+  
     void removeCnxnFromIpMap(NettyServerCnxn cnxn, InetAddress remoteAddress) {
-        synchronized (ipMap) {
-            Set<NettyServerCnxn> s = ipMap.get(remoteAddress);
-            if (s != null) {
-                s.remove(cnxn);
-                if (s.isEmpty()) {
-                    ipMap.remove(remoteAddress);
-                }
-                return;
-            }
+        ipMap.compute(remoteAddress, (addr, cnxnSet) -> {
+        if (cnxnSet == null) {
+            LOG.error(""Unexpected remote address {} when removing cnxn {}"",
+                remoteAddress, cnxn);
+            cnxnSet = Collections.emptySet();
         }
-        // Fallthrough and log errors outside the synchronized block
-        LOG.error(
-                ""Unexpected null set for remote address {} when removing cnxn {}"",
-                remoteAddress,
-                cnxn);
+        cnxnSet.remove(cnxn);
+        return cnxnSet.isEmpty() ? null : cnxnSet;
+      });
     }
 
-    private int getClientCnxnCount(InetAddress addr) {
-        synchronized (ipMap) {
-            Set<NettyServerCnxn> s = ipMap.get(addr);
-            if (s == null) return 0;
-            return s.size();
-        }
+    private int getClientCnxnCount(final InetAddress addr) {
+      return ipMap.getOrDefault(addr, Collections.emptySet()).size();","[{'comment': 'We have to synchronize access to the HashSet.\r\nIt is not enough to protect write access operation but you have to guard even this call to *size()*\r\n\r\nShould we use a concurrent set ?', 'commenter': 'eolivelli'}, {'comment': ""I do not think it necessary to block here.  Calling the `size()` method will not break anything and and the most it can be off by is 1 because the insert into the map is blocking.  That is to say, imagine a `put()` call on the `Map` and the data structure has been updated with the new record, but the size has not yet been incremented.  It's possible that this call to `size()` happens right between those two actions.  I'm not sure if it's worth adding the overhead of synchronization, but I don't have a strong feeling on it either way."", 'commenter': 'belugabehr'}]"
919,zookeeper-server/src/test/java/org/apache/zookeeper/server/NettyServerCnxnTest.java,"@@ -184,4 +191,135 @@ public void run() {
             assertArrayEquals(""unexpected data"", ""test"".getBytes(StandardCharsets.UTF_8), contents);
         }
     }
+
+    @Test
+    public void testEnableDisableThrottling_secure_random() throws Exception {","[{'comment': ""Perhaps I've asked this before, but why don't you use junit's parameterized tests?"", 'commenter': 'anmolnar'}, {'comment': ""Yes, you mentioned that in a separate PR before :)\r\n\r\nParameterized test will run the combination for every tests in the class, which makes sense if it's a class wide test which is for testing classes implementing the same interface. Here it's just a test combination for the specific test scenario with enable/disable throttling, so that's why I think using a help method is better. Let me know if this makes sense or not."", 'commenter': 'lvfangmin'}, {'comment': 'Makes sense. You would have to create a separate class for it.', 'commenter': 'anmolnar'}]"
919,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -378,8 +411,33 @@ public void operationComplete(Future<Channel> future) {
             }
         }
     }
+
+    @Sharable
+    static class ReadIssuedTrackingHandler extends ChannelDuplexHandler {
+","[{'comment': 'nit: this should be a singleton instance... ', 'commenter': 'normanmaurer'}, {'comment': ""@normanmaurer I'm not sure I understand your suggestion about the singleton here, can you give more detail or example?"", 'commenter': 'lvfangmin'}, {'comment': 'You can reuse the same instance of this class across different channels. Just create one instance and reuse it', 'commenter': 'normanmaurer'}, {'comment': ""That's what it is doing now, in the current code, there is only a single instance."", 'commenter': 'lvfangmin'}, {'comment': 'I was more talking about something like this:\r\n\r\n```\r\nstatic class ReadIssuedTrackingHandler extends ChannelDuplexHandler {\r\n    static final ReadIssuedTrackingHandler INSTANCE = new ReadIssuedTrackingHandler();\r\n    private ReadIssuedTrackingHandler() { }\r\n   \r\n   ...\r\n}\r\n```\r\n\r\nAnd then use `ReadIssuedTrackingHandler.INSTANCE` when you add it to the pipeline. This way you only need one instance per JVM... That said it is basically just a nit and if it matters depends on how often you create new clients / servers etc. So feel free to ignore. ', 'commenter': 'normanmaurer'}, {'comment': 'I like this approach. What do you think @lvfangmin ?', 'commenter': 'anmolnar'}, {'comment': ""Currently, there is only a single instance of ReadIssuedTrackingHandler created in NettyServerCnxnFactory, and there is only a single instance of NettyServerCnxnFactory per JVM lifecycle, so ReadIssuedTrackingHandler is only 1 instance per JVM.\r\n\r\nPersonally, I don't see there is value to create a static instance in ReadIssuedTrackingHandler, I'll keep the current implementation here."", 'commenter': 'lvfangmin'}]"
919,zookeeper-server/src/test/java/org/apache/zookeeper/server/NettyServerCnxnTest.java,"@@ -184,4 +191,135 @@ public void run() {
             assertArrayEquals(""unexpected data"", ""test"".getBytes(StandardCharsets.UTF_8), contents);
         }
     }
+
+    @Test
+    public void testEnableDisableThrottling_secure_random() throws Exception {
+        runEnableDisableThrottling(true, true);
+    }
+
+    @Test
+    public void testEnableDisableThrottling_secure_sequentially() throws Exception {
+        runEnableDisableThrottling(true, false);
+    }
+
+    @Test
+    public void testEnableDisableThrottling_nonSecure_random() throws Exception {
+        runEnableDisableThrottling(false, true);
+    }
+
+    @Test
+    public void testEnableDisableThrottling_nonSecure_sequentially() throws Exception {
+        runEnableDisableThrottling(false, false);
+    }
+
+    public void runEnableDisableThrottling(boolean secure, boolean randomDisableEnable) throws Exception {","[{'comment': 'nit: private', 'commenter': 'normanmaurer'}]"
922,zookeeper-server/src/test/java/org/apache/zookeeper/test/GetChildrenListTest.java,"@@ -0,0 +1,122 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import java.io.IOException;
+import java.util.*;","[{'comment': ""Please don't use wildcard imports."", 'commenter': 'anmolnar'}]"
922,zookeeper-server/src/test/java/org/apache/zookeeper/test/GetChildrenListTest.java,"@@ -0,0 +1,122 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import java.io.IOException;
+import java.util.*;
+
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.data.Stat;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class GetChildrenListTest extends ClientBase {
+    private ZooKeeper zk;
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+
+        zk = createClient();
+    }
+
+    @Override
+    public void tearDown() throws Exception {
+        super.tearDown();
+
+        zk.close();
+    }
+
+    @Test
+    public void testChild()
+            throws IOException, KeeperException, InterruptedException
+    {
+        String name = ""/foo"";
+        zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE,
+                CreateMode.PERSISTENT);
+
+        String childname = name + ""/bar"";
+        zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE,","[{'comment': 'You might want to add more children to test.', 'commenter': 'anmolnar'}]"
922,zookeeper-server/src/test/java/org/apache/zookeeper/test/GetChildrenListTest.java,"@@ -0,0 +1,122 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import java.io.IOException;
+import java.util.*;
+
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.data.Stat;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class GetChildrenListTest extends ClientBase {","[{'comment': 'Please add tests for ACL checking.', 'commenter': 'anmolnar'}]"
922,zookeeper-server/src/test/java/org/apache/zookeeper/server/FinalRequestProcessorTest.java,"@@ -227,4 +232,40 @@ private void assertMasked(boolean masked) {
         assertThat(""Original ACL list has been modified"", testACLs.get(2).getId().getScheme(), equalTo(""world""));
         assertThat(""Original ACL list has been modified"", testACLs.get(2).getId().getId(), equalTo(""anyone""));
     }
+
+    @Test
+    public void testGetChildrenList_Empty_List() throws IOException {
+        GetChildrenListRequest getChildrenListRequest = new GetChildrenListRequest();
+        getChildrenListRequest.setPathList(new ArrayList<>());
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
+        getChildrenListRequest.serialize(boa, ""request"");
+        baos.close();
+
+        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getChildrenList,
+                                ByteBuffer.wrap(baos.toByteArray()), new ArrayList<Id>());
+        processor.processRequest(r);
+
+        GetChildrenListResponse rsp = (GetChildrenListResponse)responseRecord[0];
+        assertTrue(rsp.getChildren().isEmpty());
+    }
+
+    @Test
+    public void testGetChildrenList_Normal() throws IOException {
+        GetChildrenListRequest getChildrenListRequest = new GetChildrenListRequest();
+        getChildrenListRequest.setPathList(Arrays.asList(""/testPath"", ""/testPath""));","[{'comment': ""Why do you search for the same path twice?\r\nIs it a test case to validate the results won't be merged?"", 'commenter': 'anmolnar'}]"
922,zookeeper-server/src/test/java/org/apache/zookeeper/server/FinalRequestProcessorTest.java,"@@ -227,4 +232,40 @@ private void assertMasked(boolean masked) {
         assertThat(""Original ACL list has been modified"", testACLs.get(2).getId().getScheme(), equalTo(""world""));
         assertThat(""Original ACL list has been modified"", testACLs.get(2).getId().getId(), equalTo(""anyone""));
     }
+
+    @Test
+    public void testGetChildrenList_Empty_List() throws IOException {","[{'comment': 'Please consider adding some tests for ACL checking too.', 'commenter': 'anmolnar'}]"
922,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -562,12 +567,14 @@ public void register(int rc) {
             if (shouldAddWatch(rc)) {
                 Map<String, Set<Watcher>> watches = getWatches(rc);
                 synchronized(watches) {
-                    Set<Watcher> watchers = watches.get(clientPath);
-                    if (watchers == null) {
-                        watchers = new HashSet<Watcher>();
-                        watches.put(clientPath, watchers);
+                    for(String clientPath : clientPaths) {","[{'comment': 'nit: space after (.', 'commenter': 'lvfangmin'}]"
922,zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -468,6 +470,28 @@ public void processRequest(Request request) {
                 rsp = new GetChildren2Response(children, stat);
                 break;
             }
+            case OpCode.getChildrenList: {
+                lastOp = ""GETC"";
+                GetChildrenListRequest getChildrenListRequest = new GetChildrenListRequest();
+                ByteBufferInputStream.byteBuffer2Record(request.request,
+                        getChildrenListRequest);
+                List<List<String>> childrenList = new ArrayList<List<String>>();
+                for(String p : getChildrenListRequest.getPathList()) {
+                    path = p;
+                    DataNode n = zks.getZKDatabase().getNode(path);
+                    if (n == null) {","[{'comment': ""Not sure if it makes sense to return empty list if the node doesn't exist, so that we won't waste the cycle to fail often due to nodes being created and deleted often."", 'commenter': 'lvfangmin'}, {'comment': 'Yeah, I was considering something like that, however, this way we could not differentiate whether the request failed or it is a node without children.', 'commenter': 'szepet'}]"
923,zookeeper-server/src/test/resources/test-scripts.sh,"@@ -217,6 +217,9 @@ stop
 
 $ZKSI --force --myid=1 --configfile ""$ZOOCFGDIR/$ZOOCFG"" || fail $LINENO
 
+#test version script","[{'comment': 'is this file working on maven build ? \r\nIt checks for ""ls build/zookeeper*.jar"" but the mavenized build does not create such file.\r\n\r\nIf I am not wrong, do you mind @szepet fixing it up ? otherwise as soon as we drop the ant-based build this script will need a fix.\r\nHonestly I didn\'t known such file existed', 'commenter': 'eolivelli'}, {'comment': 'Is this script actually used anywhere in our code?\r\nHow is it supposed to work?', 'commenter': 'anmolnar'}, {'comment': ""It just checks whether the sh scripts working properly. Or at least that they return a '0' exit code."", 'commenter': 'szepet'}]"
924,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/UnifiedConnectionFactory.java,"@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.admin;
+
+import org.eclipse.jetty.io.Connection;
+import org.eclipse.jetty.io.EndPoint;
+import org.eclipse.jetty.io.ssl.SslConnection;
+import org.eclipse.jetty.server.Connector;
+import org.eclipse.jetty.server.ConnectionFactory;
+import org.eclipse.jetty.server.AbstractConnectionFactory;
+import org.eclipse.jetty.http.HttpVersion;
+import org.eclipse.jetty.util.ssl.SslContextFactory;
+import org.eclipse.jetty.util.annotation.Name;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLSession;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The purpose of this class is to dynamically determine whether to create
+ * a plaintext or SSL connection whenever newConnection() is called. It works
+ * in conjunction with ReadAheadEnpoint to inspect bytes on the incoming
+ * connection.
+ */
+public class UnifiedConnectionFactory extends AbstractConnectionFactory {
+    private static final Logger LOG = LoggerFactory.getLogger(UnifiedConnectionFactory.class);
+
+    private final SslContextFactory sslContextFactory;
+    private final String nextProtocol;
+
+    public UnifiedConnectionFactory() { this(HttpVersion.HTTP_1_1.asString()); }
+
+    public UnifiedConnectionFactory(String nextProtocol) { this(null, nextProtocol); }
+
+    public UnifiedConnectionFactory(SslContextFactory factory, String nextProtocol) {
+        super(""SSL"");
+        this.sslContextFactory = (factory == null) ? new SslContextFactory() : factory;
+        this.nextProtocol = nextProtocol;
+        this.addBean(this.sslContextFactory);
+    }
+
+    public SslContextFactory getSslContextFactory() { return this.sslContextFactory; }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        SSLEngine engine = this.sslContextFactory.newSSLEngine();
+        SSLSession session = engine.getSession();
+        engine.setUseClientMode(false);
+        if(session.getPacketBufferSize() > this.getInputBufferSize()) {","[{'comment': 'nit: space after if.', 'commenter': 'lvfangmin'}]"
924,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/JettyAdminServer.java,"@@ -67,24 +80,75 @@
     private final String commandUrl;
     private ZooKeeperServer zkServer;
 
-    public JettyAdminServer() throws AdminServerException {
+    public JettyAdminServer() throws AdminServerException, IOException, GeneralSecurityException {
         this(System.getProperty(""zookeeper.admin.serverAddress"", DEFAULT_ADDRESS),
              Integer.getInteger(""zookeeper.admin.serverPort"", DEFAULT_PORT),
              Integer.getInteger(""zookeeper.admin.idleTimeout"", DEFAULT_IDLE_TIMEOUT),
-             System.getProperty(""zookeeper.admin.commandURL"", DEFAULT_COMMAND_URL));
+             System.getProperty(""zookeeper.admin.commandURL"", DEFAULT_COMMAND_URL),
+             Integer.getInteger(""zookeeper.admin.httpVersion"", DEFAULT_HTTP_VERSION),
+             Boolean.getBoolean(""zookeeper.admin.portUnification""));
     }
 
-    public JettyAdminServer(String address, int port, int timeout, String commandUrl) {
+    public JettyAdminServer(String address,
+                            int port,
+                            int timeout,
+                            String commandUrl,
+                            int httpVersion,
+                            boolean portUnification) throws IOException, GeneralSecurityException {
         this.port = port;
         this.idleTimeout = timeout;
         this.commandUrl = commandUrl;
         this.address = address;
 
         server = new Server();
-        ServerConnector connector = new ServerConnector(server);
+        ServerConnector connector = null;
+
+        if (!portUnification) {
+            connector = new ServerConnector(server);
+        } else {
+            SecureRequestCustomizer customizer = new SecureRequestCustomizer();
+            customizer.setStsMaxAge(DEFAULT_STS_MAX_AGE);
+            customizer.setStsIncludeSubDomains(true);
+
+            HttpConfiguration config = new HttpConfiguration();
+            config.setSecureScheme(""https"");
+            config.addCustomizer(customizer);
+
+            try(QuorumX509Util x509Util = new QuorumX509Util()) {","[{'comment': 'nit: space after try', 'commenter': 'lvfangmin'}]"
924,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/UnifiedConnectionFactory.java,"@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.admin;
+
+import org.eclipse.jetty.io.Connection;
+import org.eclipse.jetty.io.EndPoint;
+import org.eclipse.jetty.io.ssl.SslConnection;
+import org.eclipse.jetty.server.Connector;
+import org.eclipse.jetty.server.ConnectionFactory;
+import org.eclipse.jetty.server.AbstractConnectionFactory;
+import org.eclipse.jetty.http.HttpVersion;
+import org.eclipse.jetty.util.ssl.SslContextFactory;
+import org.eclipse.jetty.util.annotation.Name;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLSession;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The purpose of this class is to dynamically determine whether to create
+ * a plaintext or SSL connection whenever newConnection() is called. It works
+ * in conjunction with ReadAheadEnpoint to inspect bytes on the incoming
+ * connection.
+ */
+public class UnifiedConnectionFactory extends AbstractConnectionFactory {
+    private static final Logger LOG = LoggerFactory.getLogger(UnifiedConnectionFactory.class);
+
+    private final SslContextFactory sslContextFactory;
+    private final String nextProtocol;
+
+    public UnifiedConnectionFactory() { this(HttpVersion.HTTP_1_1.asString()); }
+
+    public UnifiedConnectionFactory(String nextProtocol) { this(null, nextProtocol); }
+
+    public UnifiedConnectionFactory(SslContextFactory factory, String nextProtocol) {
+        super(""SSL"");
+        this.sslContextFactory = (factory == null) ? new SslContextFactory.Server() : factory;
+        this.nextProtocol = nextProtocol;
+        this.addBean(this.sslContextFactory);
+    }
+
+    public SslContextFactory getSslContextFactory() { return this.sslContextFactory; }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        SSLEngine engine = this.sslContextFactory.newSSLEngine();
+        SSLSession session = engine.getSession();
+        engine.setUseClientMode(false);
+        if (session.getPacketBufferSize() > this.getInputBufferSize()) {
+            this.setInputBufferSize(session.getPacketBufferSize());
+        }
+    }
+
+    @Override
+    public Connection newConnection(Connector connector, EndPoint realEndPoint) {
+        ReadAheadEndpoint aheadEndpoint = new ReadAheadEndpoint(realEndPoint, 1);
+        byte[] bytes = aheadEndpoint.getBytes();
+        boolean isSSL;
+
+        if (bytes == null || bytes.length == 0) {
+            isSSL = true;
+        } else {
+            byte b = bytes[0]; // TLS first byte is 0x16 , SSLv2 first byte is >= 0x80 , HTTP is guaranteed many bytes of ASCII
+            isSSL = b >= 0x7F || (b < 0x20 && b != '\n' && b != '\r' && b != '\t'); // TODO: is this the best way to do dis?
+        }
+
+        LOG.debug(""UnifiedConnectionFactory: newConnection() with SSL = "" + isSSL);","[{'comment': 'Please use the version with string formatter.', 'commenter': 'anmolnar'}]"
924,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/UnifiedConnectionFactory.java,"@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.admin;
+
+import org.eclipse.jetty.io.Connection;
+import org.eclipse.jetty.io.EndPoint;
+import org.eclipse.jetty.io.ssl.SslConnection;
+import org.eclipse.jetty.server.Connector;
+import org.eclipse.jetty.server.ConnectionFactory;
+import org.eclipse.jetty.server.AbstractConnectionFactory;
+import org.eclipse.jetty.http.HttpVersion;
+import org.eclipse.jetty.util.ssl.SslContextFactory;
+import org.eclipse.jetty.util.annotation.Name;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLSession;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The purpose of this class is to dynamically determine whether to create
+ * a plaintext or SSL connection whenever newConnection() is called. It works
+ * in conjunction with ReadAheadEnpoint to inspect bytes on the incoming
+ * connection.
+ */
+public class UnifiedConnectionFactory extends AbstractConnectionFactory {
+    private static final Logger LOG = LoggerFactory.getLogger(UnifiedConnectionFactory.class);
+
+    private final SslContextFactory sslContextFactory;
+    private final String nextProtocol;
+
+    public UnifiedConnectionFactory() { this(HttpVersion.HTTP_1_1.asString()); }
+
+    public UnifiedConnectionFactory(String nextProtocol) { this(null, nextProtocol); }
+
+    public UnifiedConnectionFactory(SslContextFactory factory, String nextProtocol) {
+        super(""SSL"");
+        this.sslContextFactory = (factory == null) ? new SslContextFactory.Server() : factory;
+        this.nextProtocol = nextProtocol;
+        this.addBean(this.sslContextFactory);
+    }
+
+    public SslContextFactory getSslContextFactory() { return this.sslContextFactory; }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        SSLEngine engine = this.sslContextFactory.newSSLEngine();
+        SSLSession session = engine.getSession();
+        engine.setUseClientMode(false);
+        if (session.getPacketBufferSize() > this.getInputBufferSize()) {
+            this.setInputBufferSize(session.getPacketBufferSize());
+        }
+    }
+
+    @Override
+    public Connection newConnection(Connector connector, EndPoint realEndPoint) {
+        ReadAheadEndpoint aheadEndpoint = new ReadAheadEndpoint(realEndPoint, 1);
+        byte[] bytes = aheadEndpoint.getBytes();
+        boolean isSSL;
+
+        if (bytes == null || bytes.length == 0) {
+            isSSL = true;
+        } else {
+            byte b = bytes[0]; // TLS first byte is 0x16 , SSLv2 first byte is >= 0x80 , HTTP is guaranteed many bytes of ASCII
+            isSSL = b >= 0x7F || (b < 0x20 && b != '\n' && b != '\r' && b != '\t'); // TODO: is this the best way to do dis?","[{'comment': 'What does this TODO message refer to?\r\nWhat is needed to be done?', 'commenter': 'anmolnar'}, {'comment': 'Needed to straighten out which version of TLS/SSL we should support.', 'commenter': 'ericlee123'}, {'comment': ""Currently it's a question, not something which needs to be done.\r\nPlease try to be specific if adding TODO or remove it."", 'commenter': 'anmolnar'}, {'comment': 'Already cleaned this up in following commit.', 'commenter': 'ericlee123'}]"
924,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/UnifiedConnectionFactory.java,"@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.admin;
+
+import org.eclipse.jetty.io.Connection;
+import org.eclipse.jetty.io.EndPoint;
+import org.eclipse.jetty.io.ssl.SslConnection;
+import org.eclipse.jetty.server.Connector;
+import org.eclipse.jetty.server.ConnectionFactory;
+import org.eclipse.jetty.server.AbstractConnectionFactory;
+import org.eclipse.jetty.http.HttpVersion;
+import org.eclipse.jetty.util.ssl.SslContextFactory;
+import org.eclipse.jetty.util.annotation.Name;","[{'comment': 'Unused import.', 'commenter': 'anmolnar'}]"
924,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/UnifiedConnectionFactory.java,"@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.admin;
+
+import org.eclipse.jetty.io.Connection;
+import org.eclipse.jetty.io.EndPoint;
+import org.eclipse.jetty.io.ssl.SslConnection;
+import org.eclipse.jetty.server.Connector;
+import org.eclipse.jetty.server.ConnectionFactory;
+import org.eclipse.jetty.server.AbstractConnectionFactory;
+import org.eclipse.jetty.http.HttpVersion;
+import org.eclipse.jetty.util.ssl.SslContextFactory;
+import org.eclipse.jetty.util.annotation.Name;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLSession;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The purpose of this class is to dynamically determine whether to create
+ * a plaintext or SSL connection whenever newConnection() is called. It works
+ * in conjunction with ReadAheadEnpoint to inspect bytes on the incoming
+ * connection.
+ */
+public class UnifiedConnectionFactory extends AbstractConnectionFactory {
+    private static final Logger LOG = LoggerFactory.getLogger(UnifiedConnectionFactory.class);
+
+    private final SslContextFactory sslContextFactory;
+    private final String nextProtocol;
+
+    public UnifiedConnectionFactory() { this(HttpVersion.HTTP_1_1.asString()); }","[{'comment': 'Unused default constructor.', 'commenter': 'anmolnar'}]"
924,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/UnifiedConnectionFactory.java,"@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.admin;
+
+import org.eclipse.jetty.io.Connection;
+import org.eclipse.jetty.io.EndPoint;
+import org.eclipse.jetty.io.ssl.SslConnection;
+import org.eclipse.jetty.server.Connector;
+import org.eclipse.jetty.server.ConnectionFactory;
+import org.eclipse.jetty.server.AbstractConnectionFactory;
+import org.eclipse.jetty.http.HttpVersion;
+import org.eclipse.jetty.util.ssl.SslContextFactory;
+import org.eclipse.jetty.util.annotation.Name;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLSession;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The purpose of this class is to dynamically determine whether to create
+ * a plaintext or SSL connection whenever newConnection() is called. It works
+ * in conjunction with ReadAheadEnpoint to inspect bytes on the incoming
+ * connection.
+ */
+public class UnifiedConnectionFactory extends AbstractConnectionFactory {
+    private static final Logger LOG = LoggerFactory.getLogger(UnifiedConnectionFactory.class);
+
+    private final SslContextFactory sslContextFactory;
+    private final String nextProtocol;
+
+    public UnifiedConnectionFactory() { this(HttpVersion.HTTP_1_1.asString()); }
+
+    public UnifiedConnectionFactory(String nextProtocol) { this(null, nextProtocol); }
+
+    public UnifiedConnectionFactory(SslContextFactory factory, String nextProtocol) {
+        super(""SSL"");
+        this.sslContextFactory = (factory == null) ? new SslContextFactory.Server() : factory;
+        this.nextProtocol = nextProtocol;
+        this.addBean(this.sslContextFactory);
+    }
+
+    public SslContextFactory getSslContextFactory() { return this.sslContextFactory; }","[{'comment': 'Unused getter. Is this code copied over from somewhere?', 'commenter': 'anmolnar'}, {'comment': 'I refactored the code from here. https://stackoverflow.com/questions/11182192/how-do-i-serve-https-and-http-for-jetty-from-one-port/40076056#40076056', 'commenter': 'ericlee123'}]"
924,zookeeper-server/src/test/java/org/apache/zookeeper/server/admin/JettyAdminServerTest.java,"@@ -19,27 +19,53 @@
 package org.apache.zookeeper.server.admin;
 
 import java.io.BufferedReader;
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.net.MalformedURLException;
 import java.net.URL;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
 
+import org.apache.zookeeper.common.KeyStoreFileType;","[{'comment': ""There're multiple unused imports in this file. Please remove them."", 'commenter': 'anmolnar'}]"
924,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/JettyAdminServer.java,"@@ -67,24 +80,75 @@
     private final String commandUrl;
     private ZooKeeperServer zkServer;
 
-    public JettyAdminServer() throws AdminServerException {
+    public JettyAdminServer() throws AdminServerException, IOException, GeneralSecurityException {
         this(System.getProperty(""zookeeper.admin.serverAddress"", DEFAULT_ADDRESS),
              Integer.getInteger(""zookeeper.admin.serverPort"", DEFAULT_PORT),
              Integer.getInteger(""zookeeper.admin.idleTimeout"", DEFAULT_IDLE_TIMEOUT),
-             System.getProperty(""zookeeper.admin.commandURL"", DEFAULT_COMMAND_URL));
+             System.getProperty(""zookeeper.admin.commandURL"", DEFAULT_COMMAND_URL),
+             Integer.getInteger(""zookeeper.admin.httpVersion"", DEFAULT_HTTP_VERSION),
+             Boolean.getBoolean(""zookeeper.admin.portUnification""));
     }
 
-    public JettyAdminServer(String address, int port, int timeout, String commandUrl) {
+    public JettyAdminServer(String address,
+                            int port,
+                            int timeout,
+                            String commandUrl,
+                            int httpVersion,
+                            boolean portUnification) throws IOException, GeneralSecurityException {
         this.port = port;
         this.idleTimeout = timeout;
         this.commandUrl = commandUrl;
         this.address = address;
 
         server = new Server();
-        ServerConnector connector = new ServerConnector(server);
+        ServerConnector connector = null;
+
+        if (!portUnification) {
+            connector = new ServerConnector(server);
+        } else {
+            SecureRequestCustomizer customizer = new SecureRequestCustomizer();
+            customizer.setStsMaxAge(DEFAULT_STS_MAX_AGE);
+            customizer.setStsIncludeSubDomains(true);
+
+            HttpConfiguration config = new HttpConfiguration();
+            config.setSecureScheme(""https"");
+            config.addCustomizer(customizer);
+
+            try (QuorumX509Util x509Util = new QuorumX509Util()) {
+                String privateKeyPath = System.getProperty(x509Util.getSslKeystoreLocationProperty(), """");
+                String privateKeyPassword = System.getProperty(x509Util.getSslKeystorePasswdProperty(), """");
+                String certAuthPath = System.getProperty(x509Util.getSslTruststoreLocationProperty(), """");
+                String certAuthPassword = System.getProperty(x509Util.getSslTruststorePasswdProperty(), """");
+                File privateKey = new File(privateKeyPath);
+                File certAuth = new File(certAuthPath);
+                KeyStore keyStore = null, trustStore = null;
+
+                try {
+                    keyStore = PemReader.loadKeyStore(privateKey, privateKey, Optional.empty());","[{'comment': 'This way you only support the PEM format for both keystore and truststore. You should highlight this in the documentation or use `FileKeyStoreLoaderBuilderProvider` like X509Util does in order to support both JKS and PEM files.\r\n\r\nGiven that this feature shares configuration properties for keystore/truststore location, I believe the latter would be better to avoid confusion. ', 'commenter': 'anmolnar'}]"
924,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/ReadAheadEndpoint.java,"@@ -74,7 +74,10 @@ public ReadAheadEndpoint(final EndPoint channel, final int readAheadLength){
 
     private synchronized void readAhead() throws IOException {
         if (leftToRead > 0) {
-            final int n = endPoint.fill(start);
+            int n = 0;","[{'comment': ""I discovered in my changes when cleaning things up. I was running into the situation where data a TLS connection wasn't ready to be read (`fill()`). Probably because secure connections have a bigger overhead, `JettyAdminServerTest` would only fail for secure connections (the plaintext connections would work fine). My idea here is to wait until the data is ready to be read, but as I am not an expert with Jetty `EndPoint`, these lines seems to have potential to infinitely loop."", 'commenter': 'ericlee123'}]"
929,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -964,7 +974,9 @@ public ProcessTxnResult processTxn(TxnHeader header, Record txn, boolean isSubTx
 
                         ByteBufferInputStream.byteBuffer2Record(bb, record);
 
-                        if (failed && subtxn.getType() != OpCode.error){
+                        if (failed && subtxn.getType() != OpCode.error &&
+                            // Before the error, the return values of getter methods are valid.","[{'comment': ""Please add more details to the comments, because it's hard to understand the intention here. Something like:\r\n> For `getChildren` requests we'd like to the see the results of requests which was made before the error in the multi."", 'commenter': 'anmolnar'}]"
929,zookeeper-server/src/test/java/org/apache/zookeeper/test/MultiTransactionTest.java,"@@ -787,6 +811,129 @@ public void testTransactionBuilder() throws Exception {
         assertNull(zk.exists(""/t2"", false));
     }
 
+    @Test
+    public void testMultiGetChildren() throws Exception {","[{'comment': ""If it doesn't add too much overhead to unit testing, please try to split this test into 2 test cases."", 'commenter': 'anmolnar'}]"
929,zookeeper-server/src/test/java/org/apache/zookeeper/test/MultiTransactionTest.java,"@@ -787,6 +811,129 @@ public void testTransactionBuilder() throws Exception {
         assertNull(zk.exists(""/t2"", false));
     }
 
+    @Test
+    public void testMultiGetChildren() throws Exception {
+        List<String> topLevelNodes = new ArrayList<String>();
+        Map<String, List<String>> childrenNodes = new HashMap<String, List<String>>();
+        // Creating a database where '/fooX' nodes has 'barXY' named children.
+        for (int i = 0; i < 10; i++) {
+            String name = ""/foo"" + i;
+            zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE,
+                    CreateMode.PERSISTENT);
+            topLevelNodes.add(name);
+            childrenNodes.put(name, new ArrayList<>());
+            for (int j = 0; j < 10; j++) {
+                String childname = name + ""/bar"" + i + j;
+                String childname_s = ""bar"" + i + j;
+                zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE,
+                        CreateMode.EPHEMERAL);
+                childrenNodes.get(name).add(childname_s);
+            }
+        }
+        // Create a multi operation, which queries the children of the nodes in topLevelNodes.
+        List<OpResult> multiChildrenList =
+                multi(zk, topLevelNodes.stream().map(Op::getChildren).collect(Collectors.toList()));
+        for (int i = 0; i < topLevelNodes.size(); i++) {
+            String nodeName = topLevelNodes.get(i);
+            Assert.assertTrue(multiChildrenList.get(i) instanceof OpResult.GetChildrenResult);
+            List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(i)).getChildren();
+            // In general, we do not demand an order from the children list but to contain every child.
+            Assert.assertEquals(new TreeSet<String>(childrenList),
+                    new TreeSet<String>(childrenNodes.get(nodeName)));
+
+            List<String> children = zk.getChildren(nodeName, false);
+            Assert.assertEquals(childrenList, children);
+        }
+
+        // Check for getting the children of the same node twice
+        List<OpResult> sameChildrenList = multi(zk, Arrays.asList(
+                Op.getChildren(topLevelNodes.get(0)),
+                Op.getChildren(topLevelNodes.get(0))));
+
+        Assert.assertEquals(sameChildrenList.size(), 2);
+        Assert.assertEquals(sameChildrenList.get(0), multiChildrenList.get(0));
+        Assert.assertEquals(sameChildrenList.get(0), sameChildrenList.get(1));
+    }
+
+    @Test
+    public void testMultiGetChildrenAuthentication() throws KeeperException, InterruptedException {","[{'comment': 'Same here. It would be nice to have 3 (or more) separate test cases.', 'commenter': 'anmolnar'}]"
933,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/LearnerHandlerMetricsTest.java,"@@ -60,36 +61,40 @@ public void setup() throws IOException {
 
         //adding 5ms artificial delay when sending each packet
         BinaryOutputArchive oa = mock(BinaryOutputArchive.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Thread.sleep(5);
-                return  null;
-            }
-        }).when(oa).writeRecord(any(QuorumPacket.class), Matchers.anyString());
+        doAnswer(invocationOnMock -> {Thread.sleep(5); return null;})
+                .when(oa).writeRecord(any(QuorumPacket.class), Matchers.anyString());
+
+        BufferedOutputStream bos = mock(BufferedOutputStream.class);
+        // flush is called when all packets are sent and the queue is empty
+        doAnswer(invocationOnMock -> {allSentLatch.countDown(); return null;}).when(bos).flush();
 
         learnerHandler = new MockLearnerHandler(socket, leader);
         learnerHandler.setOutputArchive(oa);
-        learnerHandler.setBufferedOutput(mock(BufferedOutputStream.class));
+        learnerHandler.setBufferedOutput(bos);
         learnerHandler.sid = sid;
     }
 
     @Test
-    public void testMetrics() {
+    public void testMetrics() throws InterruptedException {
         ServerMetrics.getMetrics().resetAll();
 
         //adding 1001 packets in the queue, two marker packets will be added since the interval is every 1000 packets
         for (int i=0; i<1001; i++) {
             learnerHandler.queuePacket(new QuorumPacket());
         }
+
+        allSentLatch = new CountDownLatch(1);
+
         learnerHandler.startSendingPackets();
 
+        allSentLatch.await(8, TimeUnit.SECONDS);
+
         //make sure we have enough time to send all the packets in the queue
-        try {
+        /*try {","[{'comment': 'Can we remove commented code?', 'commenter': 'eolivelli'}, {'comment': 'removed. Thanks!', 'commenter': 'jhuan31'}]"
933,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/LearnerHandlerMetricsTest.java,"@@ -43,6 +43,7 @@
 public class LearnerHandlerMetricsTest {
     private MockLearnerHandler learnerHandler;
     private long sid = 5;
+    private CountDownLatch allSentLatch;","[{'comment': 'Should this be volatile?', 'commenter': 'eolivelli'}, {'comment': 'yes.  made it volatile', 'commenter': 'jhuan31'}]"
933,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/LearnerHandlerMetricsTest.java,"@@ -60,36 +61,40 @@ public void setup() throws IOException {
 
         //adding 5ms artificial delay when sending each packet
         BinaryOutputArchive oa = mock(BinaryOutputArchive.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Thread.sleep(5);
-                return  null;
-            }
-        }).when(oa).writeRecord(any(QuorumPacket.class), Matchers.anyString());
+        doAnswer(invocationOnMock -> {Thread.sleep(5); return null;})
+                .when(oa).writeRecord(any(QuorumPacket.class), Matchers.anyString());
+
+        BufferedOutputStream bos = mock(BufferedOutputStream.class);
+        // flush is called when all packets are sent and the queue is empty
+        doAnswer(invocationOnMock -> {allSentLatch.countDown(); return null;}).when(bos).flush();","[{'comment': ""The allSentLatch needs to be initialized in setup, otherwise if the other test case in this class, and it's not initialize this latch, it will throw NPE.\r\n\r\nAlso if those test only used in testMetrics method, but not general, for other tests, then we should move it into testMetrics instead of setup."", 'commenter': 'lvfangmin'}, {'comment': ""I added check for null to avoid NPE. I try to separate setup from testing logic.  Initializing the latch I think is part of the testing logic because it might not always be appropriate to set the latch at the beginning of the test. The place where the latch is set and the count the latch is set to depend on what is being tested.   \r\nThere is one test method in this test file so far. So I could move all the setup into the test. But again I want to separate setup from testing logic itself. If later new test methods are to be added and they don't share the common setup, then we may need to refactor the setup code--but if they don't share the common setup, they probably shouldn't be in the same test file."", 'commenter': 'jhuan31'}]"
934,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -856,6 +856,10 @@ property, when available, is noted below.
     commit log is triggered.
     Does not affect the limit defined by *flushDelay*.
     Default is 1000.
+* *enforeQuota* :","[{'comment': 'This is a typo; I suppose you meant `enforceQuota`.  (This applies throughout.)\r\n\r\nFYI, Mohammad Arshad [was suggesting to use two properties](https://issues.apache.org/jira/browse/ZOOKEEPER-2593?focusedCommentId=15513419&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-15513419), `enforce.number.quota` and `enforce.byte.quota`:\r\n\r\n> enforce the quota limit at more granular level. can we add enforce.number.quota and enforce.byte.quota ?\r\n\r\n(But I don\'t know his ""use case."")', 'commenter': 'ztzg'}, {'comment': 'If users really need this two separated property, we can extend it easily in the future', 'commenter': 'maoling'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -286,6 +293,91 @@ void rollbackPendingChanges(long zxid, Map<String, ChangeRecord>pendingChangeRec
         }
     }
 
+    /**
+     * check whether exceeded the quota.
+     *
+     * @param lastPrefix
+     *            the path of the node that is quotaed.
+     * @param bytesDiff
+     *            the diff to be added to number of bytes
+     * @param countDiff
+     *            the diff to be added to the count
+     */
+    private void checkQuota(String lastPrefix, long bytesDiff, int countDiff)
+            throws KeeperException.QuotaExceededException {
+        if (!enforeQuota) {
+            return;","[{'comment': 'Wouldn\'t this mean that `LOG.warn(""Quota exceeded: ...)` entries are completely lost?  I.e., not only do we not enforce the quota (as requested), but no warnings are produced.  Is that the intent?', 'commenter': 'ztzg'}, {'comment': '`enforeQuota`  enables by default. When it disables, users will see a log to show disable infos at the start-up of server and the `LOG.warn(""Quota exceeded: ...)` will never been seen', 'commenter': 'maoling'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -286,6 +293,91 @@ void rollbackPendingChanges(long zxid, Map<String, ChangeRecord>pendingChangeRec
         }
     }
 
+    /**
+     * check whether exceeded the quota.
+     *
+     * @param lastPrefix
+     *            the path of the node that is quotaed.
+     * @param bytesDiff
+     *            the diff to be added to number of bytes
+     * @param countDiff
+     *            the diff to be added to the count
+     */
+    private void checkQuota(String lastPrefix, long bytesDiff, int countDiff)
+            throws KeeperException.QuotaExceededException {
+        if (!enforeQuota) {
+            return;
+        }
+
+        LOG.debug(""checkQuota: lastPrefix={}, bytesDiff={}, countDiff={}"", lastPrefix, bytesDiff, countDiff);
+
+        if (lastPrefix == null || lastPrefix.length() == 0) {
+            return;","[{'comment': 'Interesting that all callers check for `lastPrefix != null`, but that `checkQuota()` does another, more thorough, check.  I also note that `DataTree.getMaxPrefixWithQuota()` explicitly avoids returning empty strings.  Should we tighten some of these runtime checks, and/or turn them into invariant checks?', 'commenter': 'ztzg'}, {'comment': 'I use `if (StringUtils.isEmpty(lastPrefix))` instead now , checking extra `lastPrefix.length()` may be very cheap:)', 'commenter': 'maoling'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/StatsTrack.java,"@@ -34,22 +45,23 @@
     public StatsTrack() {
         this(null);
     }
+
     /**
-     * the stat string should be of the form count=int,bytes=long
-     * if stats is called with null the count and bytes are initialized
-     * to -1.
-     * @param stats the stat string to be intialized with
+     * the stat string should be of the form key1str=long,key2str=long,..
+     * where either , or ; are valid separators
+     * uninitialized values are returned as -1
+     * @param stats the stat string to be initialized with
      */
     public StatsTrack(String stats) {
-        if (stats == null) {
-            stats = ""count=-1,bytes=-1"";
+        this.stats.clear();
+        if (stats == null || stats.length() == 0) {
+            return;
         }
-        String[] split = stats.split("","");
-        if (split.length != 2) {
-            throw new IllegalArgumentException(""invalid string "" + stats);
+        String[] keyValuePairs = stats.split(""[,;]+"");","[{'comment': 'The [documentation for `String.split`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-int-) says:\r\n\r\n> An invocation of this method of the form `str.split(regex, n)` yields the same result as the expression `Pattern.compile(regex).split(str, n)`\r\n\r\nLooking that `String.java`, it seems that anything simpler than a single character and/or escaped character does indeed lead to the instantiation of a new `Pattern` object.  I haven\'t measured the cost, but it doesn\'t seem trivial.\r\n\r\nSo I\'d perhaps suggest keeping complex compiled patterns around; something like this (untested):\r\n\r\n```java\r\nprivate static final PAIRS_SEPARATOR = Pattern.compile(""[,;]+"");\r\n[...]\r\nString[] keyValuePairs = PAIRS_SEPARATOR.split(stats);\r\n```', 'commenter': 'ztzg'}, {'comment': 'I agree with @ztzg ', 'commenter': 'eolivelli'}, {'comment': 'Great catch', 'commenter': 'maoling'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/cli/DelQuotaCommand.java,"@@ -109,17 +123,11 @@ public static boolean delQuota(ZooKeeper zk, String path,
         } catch (IllegalArgumentException ex) {
             throw new MalformedPathException(ex.getMessage());
         } catch (KeeperException.NoNodeException ne) {
-            System.err.println(""quota does not exist for "" + path);
-            return true;
+            throw new KeeperException.NoNodeException(ne.getMessage());
         }
         StatsTrack strack = new StatsTrack(new String(data));","[{'comment': 'This assumes that [the ""platform\'s default charset""](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#String-byte:A-) is ASCII-compatible.  I would suggest being explicit about [US-ASCII](https://docs.oracle.com/javase/8/docs/api/java/nio/charset/StandardCharsets.html#US_ASCII) here:\r\n\r\n```java\r\nimport static java.nio.charset.StandardCharsets.US_ASCII;\r\n[...]\r\nnew String(data, US_ASCII)\r\n```\r\n\r\nAlso: there are quite a few instances of `new StatsTrack(new String(data))` in this patch; wouldn\'t it be better to just add a constructor which takes a `byte[]`?', 'commenter': 'ztzg'}, {'comment': 'yes and maybe UTF-8 is better', 'commenter': 'eolivelli'}, {'comment': 'Done \r\n1. set UTF-8 \r\n2. add new constructor `public StatsTrack(byte[] stat) `', 'commenter': 'maoling'}, {'comment': 'Actually, the content of quota znode is generated by server, it only contains character, figure. so no garbled codes?', 'commenter': 'maoling'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/cli/DelQuotaCommand.java,"@@ -129,7 +137,23 @@ public static boolean delQuota(ZooKeeper zk, String path,
             }
             // cut the tree till their is more than one child
             trimProcQuotas(zk, parentPath);
+        } else {
+            if (quota.getCount() > 0) {
+                strack.setCount(-1);
+            }
+            if (quota.getBytes() > 0) {
+                strack.setBytes(-1L);
+            }
+            if (quota.getCountHardLimit() > 0) {
+                strack.setCountHardLimit(-1);
+            }
+            if (quota.getByteHardLimit() > 0) {
+                strack.setByteHardLimit(-1L);
+            }
+
+            zk.setData(quotaPath, strack.toString().getBytes(), -1);","[{'comment': 'Same US-ASCII remark as above, but for [`getBytes`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#getBytes-java.nio.charset.Charset-):\r\n\r\n```java\r\nstrack.toString().getBytes(US_ASCII)\r\n```\r\n\r\nwith, perhaps, a new `byte[] StatsTrack.toNodeData()` method which centralizes the conversion in one place?', 'commenter': 'ztzg'}, {'comment': 'Add a new method `public byte[] getStatsBytes()`', 'commenter': 'maoling'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -286,6 +293,91 @@ void rollbackPendingChanges(long zxid, Map<String, ChangeRecord>pendingChangeRec
         }
     }
 
+    /**
+     * check whether exceeded the quota.
+     *
+     * @param lastPrefix
+     *            the path of the node that is quotaed.
+     * @param bytesDiff
+     *            the diff to be added to number of bytes
+     * @param countDiff
+     *            the diff to be added to the count
+     */
+    private void checkQuota(String lastPrefix, long bytesDiff, int countDiff)
+            throws KeeperException.QuotaExceededException {
+        if (!enforeQuota) {
+            return;
+        }
+
+        LOG.debug(""checkQuota: lastPrefix={}, bytesDiff={}, countDiff={}"", lastPrefix, bytesDiff, countDiff);
+
+        if (lastPrefix == null || lastPrefix.length() == 0) {
+            return;
+        }
+        // now check if the counts match the quota
+        String limitNode = Quotas.limitPath(lastPrefix);
+        DataNode node = zks.getZKDatabase().getNode(limitNode);
+        StatsTrack limitStats;
+        if (node == null) {
+            // should not happen
+            LOG.error(""Missing count node for quota "" + limitNode);
+            return;
+        }
+        synchronized (node) {
+            limitStats = new StatsTrack(new String(node.data));
+        }
+        //check the quota
+        boolean checkCountQuota = (limitStats.getCount() > -1 || limitStats.getCountHardLimit() > -1);
+        boolean checkByteQuota = (limitStats.getBytes() > -1 || limitStats.getByteHardLimit() > -1);
+
+        if (!checkCountQuota && !checkByteQuota) {
+            return;","[{'comment': 'Just thinking out loud: how often does that happen?  Should the administrator be alerted, somehow, that the clients are hitting an useless quota node?  Or am I missing an existing case and/or foreseen extension?', 'commenter': 'ztzg'}, {'comment': ""I don't get the point :)"", 'commenter': 'maoling'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -602,11 +584,11 @@ public void deleteNode(String path, long zxid)
         String lastPrefix = getMaxPrefixWithQuota(path);","[{'comment': ""(GitHub won't let me add a note on line 577—about something I noticed but which was not introduced by this patch.)\r\n\r\nIsn't this code slightly wrong?\r\n\r\n```java\r\n        if (parentName.startsWith(procZookeeper) && Quotas.limitNode.equals(childName)) {\r\n            // delete the node in the trie.\r\n            // we need to update the trie as well\r\n            pTrie.deletePath(parentName.substring(quotaZookeeper.length()));\r\n        }\r\n```\r\n\r\nShouldn't it test for `parentName.startsWith(quotaZookeeper)`, instead of `procZookeeper`?\r\n\r\nOh, and `DataTree` is full of `.substring(quotaZookeeper.length())` which could be replaced by your `trimQuotaPath` helper :)\r\n\r\n"", 'commenter': 'ztzg'}, {'comment': '- Yes, ` parentName.startsWith(quotaZookeeper)` is closer to the truth. we can create another ticket to fix it\r\n- substring(quotaZookeeper.length())  are all replaced with trimQuotaPath', 'commenter': 'maoling'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -286,6 +293,91 @@ void rollbackPendingChanges(long zxid, Map<String, ChangeRecord>pendingChangeRec
         }
     }
 
+    /**
+     * check whether exceeded the quota.
+     *
+     * @param lastPrefix
+     *            the path of the node that is quotaed.
+     * @param bytesDiff
+     *            the diff to be added to number of bytes
+     * @param countDiff
+     *            the diff to be added to the count
+     */
+    private void checkQuota(String lastPrefix, long bytesDiff, int countDiff)
+            throws KeeperException.QuotaExceededException {
+        if (!enforeQuota) {
+            return;
+        }
+
+        LOG.debug(""checkQuota: lastPrefix={}, bytesDiff={}, countDiff={}"", lastPrefix, bytesDiff, countDiff);
+
+        if (lastPrefix == null || lastPrefix.length() == 0) {
+            return;
+        }
+        // now check if the counts match the quota
+        String limitNode = Quotas.limitPath(lastPrefix);
+        DataNode node = zks.getZKDatabase().getNode(limitNode);
+        StatsTrack limitStats;
+        if (node == null) {
+            // should not happen
+            LOG.error(""Missing count node for quota "" + limitNode);
+            return;
+        }
+        synchronized (node) {
+            limitStats = new StatsTrack(new String(node.data));","[{'comment': 'This does the parsing & ""newing"" with the node locked; I\'d just get the data and move the constructors out of the `synchronized` block.', 'commenter': 'ztzg'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -286,6 +293,91 @@ void rollbackPendingChanges(long zxid, Map<String, ChangeRecord>pendingChangeRec
         }
     }
 
+    /**
+     * check whether exceeded the quota.
+     *
+     * @param lastPrefix
+     *            the path of the node that is quotaed.
+     * @param bytesDiff
+     *            the diff to be added to number of bytes
+     * @param countDiff
+     *            the diff to be added to the count
+     */
+    private void checkQuota(String lastPrefix, long bytesDiff, int countDiff)
+            throws KeeperException.QuotaExceededException {
+        if (!enforeQuota) {
+            return;
+        }
+
+        LOG.debug(""checkQuota: lastPrefix={}, bytesDiff={}, countDiff={}"", lastPrefix, bytesDiff, countDiff);
+
+        if (lastPrefix == null || lastPrefix.length() == 0) {
+            return;
+        }
+        // now check if the counts match the quota
+        String limitNode = Quotas.limitPath(lastPrefix);
+        DataNode node = zks.getZKDatabase().getNode(limitNode);
+        StatsTrack limitStats;
+        if (node == null) {
+            // should not happen
+            LOG.error(""Missing count node for quota "" + limitNode);
+            return;
+        }
+        synchronized (node) {
+            limitStats = new StatsTrack(new String(node.data));
+        }
+        //check the quota
+        boolean checkCountQuota = (limitStats.getCount() > -1 || limitStats.getCountHardLimit() > -1);","[{'comment': 'How about:\r\n\r\n```java\r\nboolean checkCountQuota = countDiff != 0 && (limitStats.getCount() > -1 || limitStats.getCountHardLimit() > -1);\r\n```\r\n\r\n(and the same for `checkByteQuota`/`bytesDiff`.)', 'commenter': 'ztzg'}, {'comment': 'Great catch', 'commenter': 'maoling'}]"
934,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -856,6 +856,10 @@ property, when available, is noted below.
     commit log is triggered.
     Does not affect the limit defined by *flushDelay*.
     Default is 1000.
+* *enforeQuota* :
+    (Java system property: **zookeeper.enforeQuota**)
+    enfore the quota check. Enable this option to use the [quota feature](http://zookeeper.apache.org/doc/current/zookeeperQuotas.html).
+    the default value:true.","[{'comment': 'this should be disabled by default, otherwise applications may break', 'commenter': 'eolivelli'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/KeeperException.java,"@@ -403,7 +407,11 @@ public void setCode(int code) {
         /** The session has been closed by server because server requires client to do SASL authentication,
          *  but client is not configured with SASL authentication or configuted with SASL but failed
          *  (i.e. wrong credential used.). */
-        SESSIONCLOSEDREQUIRESASLAUTH(-124);
+        SESSIONCLOSEDREQUIRESASLAUTH(-124),
+        /** Exceeded the count quota that setted on the path.*/","[{'comment': '""setted"" -> ""was set""', 'commenter': 'eolivelli'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/KeeperException.java,"@@ -403,7 +407,11 @@ public void setCode(int code) {
         /** The session has been closed by server because server requires client to do SASL authentication,
          *  but client is not configured with SASL authentication or configuted with SASL but failed
          *  (i.e. wrong credential used.). */
-        SESSIONCLOSEDREQUIRESASLAUTH(-124);
+        SESSIONCLOSEDREQUIRESASLAUTH(-124),
+        /** Exceeded the count quota that setted on the path.*/
+        COUNTQUOTAEXCEEDED(-125),
+        /** Exceeded the bytes quota that setted on the path.*/","[{'comment': '""setted"" -> ""was set""', 'commenter': 'eolivelli'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/KeeperException.java,"@@ -403,7 +407,11 @@ public void setCode(int code) {
         /** The session has been closed by server because server requires client to do SASL authentication,
          *  but client is not configured with SASL authentication or configuted with SASL but failed
          *  (i.e. wrong credential used.). */
-        SESSIONCLOSEDREQUIRESASLAUTH(-124);
+        SESSIONCLOSEDREQUIRESASLAUTH(-124),
+        /** Exceeded the count quota that setted on the path.*/
+        COUNTQUOTAEXCEEDED(-125),
+        /** Exceeded the bytes quota that setted on the path.*/
+        BYTEQUOTAEXCEEDED(-126);","[{'comment': 'Why do we need to use 2 separate return codes.\r\nI think that the client in any case cannot recover ""better"" if it has this information.\r\n\r\nThe real information is ""you have no more space"" and the client cannot adapt its behavior given the error code.\r\n\r\nUsually ZK clients perform tests (with java *switch* for instance) over the RC, adding 2 new RCs will be very annoying.\r\n\r\nThe best option would be to not add a new RC, but I can\'t find a good value to use', 'commenter': 'eolivelli'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/StatsTrack.java,"@@ -59,7 +71,7 @@ public StatsTrack(String stats) {
      * @return the count as part of this string
      */
     public int getCount() {
-        return this.count;
+        return (int) getValue(countStr);","[{'comment': 'why are we casting to ""int"" ?\r\nit the value is a ""long"" we must return a ""long"" or we have to handle the overflow some way', 'commenter': 'eolivelli'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -93,11 +95,16 @@
     private static final Logger LOG = LoggerFactory.getLogger(PrepRequestProcessor.class);
 
     static boolean skipACL;
+    static boolean enforeQuota;
     static {
         skipACL = System.getProperty(""zookeeper.skipACL"", ""no"").equals(""yes"");
         if (skipACL) {
             LOG.info(""zookeeper.skipACL==\""yes\"", ACL checks will be skipped"");
         }
+        enforeQuota = System.getProperty(""zookeeper.enforeQuota"", ""true"").equals(""true"");","[{'comment': 'enforeQuota -> enforceQuota', 'commenter': 'eolivelli'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -424,8 +516,25 @@ protected void pRequest2Txn(int type, long zxid, Request request,
                 validatePath(path, request.sessionId);
                 nodeRecord = getRecordForPath(path);
                 checkACL(zks, request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, path, null);
+
+                // first do a quota check if the path is in a quota subtree.
+                ZKDatabase zkDatabase = zks.getZKDatabase();
+                byte[] lastdata;
+                DataNode n = zkDatabase.getNode(path);
+                byte[] data = setDataRequest.getData();
+                if (n != null) {
+                    String lastPrefix = zkDatabase.getDataTree().getMaxPrefixWithQuota(path);","[{'comment': 'we are adding computations even if it is not needed (for instance in my project I do not have quotas)\r\nif there any way to not run this code if enforceQuota is not enabled ?', 'commenter': 'eolivelli'}]"
934,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -680,6 +789,15 @@ private void pRequest2TxnCreate(int type, Request request, Record record, boolea
         if (ephemeralParent) {
             throw new KeeperException.NoChildrenForEphemeralsException(path);
         }
+
+        //check the quota firstly
+        ZKDatabase zkDatabase = zks.getZKDatabase();
+        String lastPrefix = zkDatabase.getDataTree().getMaxPrefixWithQuota(path);","[{'comment': 'same here, please do not make the system work if it is not needed', 'commenter': 'eolivelli'}]"
940,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/Commands.java,"@@ -573,5 +574,27 @@ public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
         }
     }
 
+    /**
+     * Returns the current ensemble configuration information.
+     * It provides list of current voting members in the ensemble.
+     */
+    public static class VotingViewCommand extends CommandBase {
+        public VotingViewCommand() {
+            super(Arrays.asList(""voting_view""));
+        }
+
+        @Override
+        public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs) {
+            CommandResponse response = initializeResponse();
+            if (zkServer instanceof QuorumZooKeeperServer) {
+                QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;
+                response.put(""current_config"", peer.getVotingView());","[{'comment': 'It would be better to create an explicit bean for the representation on this endpoint (that is really like a JSON based API) \r\nIf we change the internal class we will change this API without notice.\r\n\r\nThoughts?', 'commenter': 'eolivelli'}, {'comment': ""That's a legitimate question and I don't know if I have the certain answer.\r\n\r\nMy thoughts are that jmx is clearly awesome at two things:\r\n1. exposing internal feature flags and settings for review and alteration and\r\n2. the execution of commands that require parameters.\r\n\r\nThe admin command is clearly awesome at one thing:\r\n1. presenting complicated diagnostic information.\r\n\r\nThis feature easily falls into the second category (jmx is certainly not going to alter the voting view). I don't know enough about the history of the admin command to know if the division I outline above is the same as the one seen by the community. \r\n\r\nThe other thing on my mind is that some users of ZooKeeper will opt out of jmx entirely because of the security concerns about the library. It would be generous to not shut them and their managing frameworks out of certain auditing information.\r\n"", 'commenter': 'enixon'}]"
940,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/Commands.java,"@@ -560,6 +574,47 @@ public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
         }
     }
 
+    /**
+     * All defined system properties.
+     */
+    public static class SystemPropertiesCommand extends CommandBase {
+        public SystemPropertiesCommand() {
+            super(Arrays.asList(""system_properties"", ""sysp""), false);
+        }
+
+        @Override
+        public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs) {
+            CommandResponse response = initializeResponse();
+            Properties systemProperties = System.getProperties();
+            SortedMap<String, String> sortedSystemProperties = new TreeMap<>();
+            systemProperties.forEach((k, v) -> sortedSystemProperties.put(k.toString(), v.toString()));
+            response.putAll(sortedSystemProperties);
+            return response;
+        }
+    }
+
+    /**
+     * Returns the current ensemble configuration information.
+     * It provides list of current voting members in the ensemble.
+     */
+    public static class VotingViewCommand extends CommandBase {
+        public VotingViewCommand() {
+            super(Arrays.asList(""voting_view""));
+        }
+
+        @Override
+        public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs) {
+            CommandResponse response = initializeResponse();
+            if (zkServer instanceof QuorumZooKeeperServer) {
+                QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;
+                response.put(""current_config"", peer.getVotingView());
+            } else {
+                response.put(""current_config"", """");
+            }","[{'comment': '`response.put(""current_config"", Collections.emptyList());` is better?', 'commenter': 'maoling'}]"
940,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/Commands.java,"@@ -607,12 +609,40 @@ public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
             CommandResponse response = initializeResponse();
             if (zkServer instanceof QuorumZooKeeperServer) {
                 QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;
-                response.put(""current_config"", peer.getVotingView());
+                VotingView votingView = new VotingView(peer.getVotingView());
+                response.put(""current_config"", votingView);
             } else {
                 response.put(""current_config"", """");
             }
             return response;
         }
+
+
+        private static class VotingView {
+            final String stringRepresentation;
+
+            VotingView(Map<Long,QuorumPeer.QuorumServer> view) {
+                this.stringRepresentation = view.entrySet().stream()
+                        .sorted(Comparator.comparingLong(Map.Entry::getKey))
+                        .filter(e -> e.getValue().addr != null)
+                        .map(e -> String.format(""%s=%s:%d%s:%s%s"",
+                                e.getKey().toString(),
+                                QuorumPeer.QuorumServer.delimitedHostString(e.getValue().addr),
+                                e.getValue().addr.getPort(),
+                                e.getValue().electionAddr == null ? """" : "":"" + e.getValue().electionAddr.getPort(),
+                                e.getValue().type.equals(QuorumPeer.LearnerType.PARTICIPANT) ? ""participant"" : ""observer"",
+                                e.getValue().clientAddr ==null || e.getValue().isClientAddrFromStatic ? """" :
+                                        String.format("";%s:%d"",
+                                                QuorumPeer.QuorumServer.delimitedHostString(e.getValue().clientAddr),
+                                                e.getValue().clientAddr.getPort())))
+                        .collect(Collectors.joining("", ""));
+            }
+
+            @Override
+            public String toString() {
+                return ""{"" + stringRepresentation + ""}"";
+            }
+        }
     }
 ","[{'comment': 'Is there an JSON parse Exception???\r\n```\r\n2019-07-03 13:58:49,968 [myid:3] - WARN  [qtp2134991632-28:JsonOutputter@59] - Exception writing command response to JSON:\r\ncom.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class org.apache.zookeeper.server.admin.Commands$VotingViewCommand$VotingView and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: java.util.LinkedHashMap[""current_config""])\r\n\tat com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:77)\r\n\tat com.fasterxml.jackson.databind.SerializerProvider.reportBadDefinition(SerializerProvider.java:1191)\r\n\tat com.fasterxml.jackson.databind.DatabindContext.reportBadDefinition(DatabindContext.java:313)\r\n\tat com.fasterxml.jackson.databind.ser.impl.UnknownSerializer.failForEmpty(UnknownSerializer.java:71)\r\n\tat com.fasterxml.jackson.databind.ser.impl.UnknownSerializer.serialize(UnknownSerializer.java:33)\r\n\tat com.fasterxml.jackson.databind.ser.std.MapSerializer.serializeFields(MapSerializer.java:722)\r\n\tat com.fasterxml.jackson.databind.ser.std.MapSerializer.serialize(MapSerializer.java:643)\r\n\tat com.fasterxml.jackson.databind.ser.std.MapSerializer.serialize(MapSerializer.java:33)\r\n\tat com.fasterxml.jackson.databind.ser.DefaultSerializerProvider._serialize(DefaultSerializerProvider.java:480)\r\n\tat com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:319)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._configAndWriteValue(ObjectMapper.java:3905)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.writeValue(ObjectMapper.java:3201)\r\n\tat org.apache.zookeeper.server.admin.JsonOutputter.output(JsonOutputter.java:54)\r\n\tat org.apache.zookeeper.server.admin.JettyAdminServer$CommandServlet.doGet(JettyAdminServer.java:181)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:687)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:790)\r\n\tat org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:867)\r\n```', 'commenter': 'maoling'}, {'comment': 'It is not a parse error but a serialization error, Jackson is not able to serialize a VotingView, I guess because it does not have any getter.', 'commenter': 'eolivelli'}]"
940,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/Commands.java,"@@ -560,6 +576,75 @@ public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
         }
     }
 
+    /**
+     * All defined system properties.
+     */
+    public static class SystemPropertiesCommand extends CommandBase {
+        public SystemPropertiesCommand() {
+            super(Arrays.asList(""system_properties"", ""sysp""), false);
+        }
+
+        @Override
+        public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs) {
+            CommandResponse response = initializeResponse();
+            Properties systemProperties = System.getProperties();
+            SortedMap<String, String> sortedSystemProperties = new TreeMap<>();
+            systemProperties.forEach((k, v) -> sortedSystemProperties.put(k.toString(), v.toString()));
+            response.putAll(sortedSystemProperties);
+            return response;
+        }
+    }
+
+    /**
+     * Returns the current ensemble configuration information.
+     * It provides list of current voting members in the ensemble.
+     */
+    public static class VotingViewCommand extends CommandBase {
+        public VotingViewCommand() {
+            super(Arrays.asList(""voting_view""));
+        }
+
+        @Override
+        public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs) {
+            CommandResponse response = initializeResponse();
+            if (zkServer instanceof QuorumZooKeeperServer) {
+                QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;
+                VotingView votingView = new VotingView(peer.getVotingView());
+                response.put(""current_config"", votingView);
+            } else {
+                response.put(""current_config"", """");
+            }
+            return response;
+        }
+
+
+        private static class VotingView {
+            final String stringRepresentation;
+
+            VotingView(Map<Long,QuorumPeer.QuorumServer> view) {
+                this.stringRepresentation = view.entrySet().stream()","[{'comment': 'You can have this variable as a List\\<String> and Jackson will serialize it to a json array you have to add a getter as well', 'commenter': 'eolivelli'}]"
944,build.xml,"@@ -37,7 +37,7 @@ xmlns:cs=""antlib:com.puppycrawl.tools.checkstyle.ant"">
 
     <property name=""audience-annotations.version"" value=""0.5.0"" />
 
-    <property name=""netty.version"" value=""4.1.29.Final""/>
+    <property name=""netty.version"" value=""4.1.32.Final""/>","[{'comment': 'Please update Maven pom as well.\r\n\r\nWhat about moving to latest netty?\r\nI guess we should update boring ssl dependency as well', 'commenter': 'eolivelli'}, {'comment': ""Good catch! I'll fix up the pom.xml and see about bumping it to the latest netty: 4.1.36."", 'commenter': 'enixon'}]"
944,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -315,37 +428,47 @@ protected void initChannel(SocketChannel ch) throws Exception {
         this.bootstrap.validate();
     }
 
-    private synchronized void initSSL(ChannelPipeline p)
-            throws X509Exception, KeyManagementException, NoSuchAlgorithmException {
+    private synchronized void initSSL(ChannelPipeline p, boolean supportPlaintext)
+            throws X509Exception, KeyManagementException, NoSuchAlgorithmException, SSLException {
         String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty());
-        SSLContext sslContext;
         if (authProviderProp == null) {
-            sslContext = x509Util.getDefaultSSLContext();
+            SSLContextAndOptions sslContextAndOptions = x509Util.getDefaultSSLContextAndOptions();
+            SslContext nettySslContext = sslContextAndOptions.createNettyJdkSslContext(
+                        sslContextAndOptions.getSSLContext(), false);
+
+            if (supportPlaintext) {
+                p.addLast(""ssl"", new DualModeSslHandler(nettySslContext));
+                LOG.debug(""dual mode Java SSL handler added for channel: {}"", p.channel());
+            } else {
+                p.addLast(""ssl"", nettySslContext.newHandler(p.channel().alloc()));
+                LOG.debug(""Java SSL handler added for channel: {}"", p.channel());
+            }
         } else {
-            sslContext = SSLContext.getInstance(""TLSv1"");
+            SSLContext sslContext = SSLContext.getInstance(ClientX509Util.DEFAULT_PROTOCOL);
             X509AuthenticationProvider authProvider =
-                    (X509AuthenticationProvider)ProviderRegistry.getProvider(
+                    (X509AuthenticationProvider) ProviderRegistry.getProvider(
                             System.getProperty(x509Util.getSslAuthProviderProperty(), ""x509""));
 
-            if (authProvider == null)
-            {
+            if (authProvider == null) {
                 LOG.error(""Auth provider not found: {}"", authProviderProp);
                 throw new SSLContextException(
                         ""Could not create SSLContext with specified auth provider: "" +
-                        authProviderProp);
+                                authProviderProp);
             }
 
-            sslContext.init(new X509KeyManager[] { authProvider.getKeyManager() },
-                            new X509TrustManager[] { authProvider.getTrustManager() },
-                            null);
+            sslContext.init(new X509KeyManager[]{authProvider.getKeyManager()},
+                    new X509TrustManager[]{authProvider.getTrustManager()},
+                    null);
+            SslContext nettySslContext = x509Util.getDefaultSSLContextAndOptions()
+                    .createNettyJdkSslContext(sslContext,false);
+            if (supportPlaintext) {","[{'comment': 'This looks like a duplicate of previous `if (supportPlaintext)` on L439, we can unify them to avoid code duplication.', 'commenter': 'hanm'}]"
944,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -63,16 +69,26 @@
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.common.ClientX509Util;
 import org.apache.zookeeper.common.NettyUtils;
+import org.apache.zookeeper.common.SSLContextAndOptions;
 import org.apache.zookeeper.common.X509Exception;
 import org.apache.zookeeper.common.X509Exception.SSLContextException;
 import org.apache.zookeeper.server.auth.ProviderRegistry;
 import org.apache.zookeeper.server.auth.X509AuthenticationProvider;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 public class NettyServerCnxnFactory extends ServerCnxnFactory {
     private static final Logger LOG = LoggerFactory.getLogger(NettyServerCnxnFactory.class);
 
+    /**
+     * Allow client-server sockets to accept both SSL and plaintext connections
+     */
+    public static final String PORT_UNIFICATION_KEY = ""zookeeper.client.portUnification"";
+    private final boolean shouldUsePortUnification;
+
+    private static final byte TLS_HANDSHAKE_RECORD_TYPE = 0x16;","[{'comment': 'might worth to add a comment here on this value (like a link to an RFC).', 'commenter': 'hanm'}]"
953,conf/zoo_sample.cfg,"@@ -6,6 +6,9 @@ initLimit=10
 # The number of ticks that can pass between 
 # sending a request and getting an acknowledgement
 syncLimit=5
+# The number of ticks that followers can take
+# to connect to the leader after leader election
+connectToLeaderLimit=5","[{'comment': 'I think we probably want to rename this variable to something like `connectToLearnerMasterLimit`, or if we keep the current name, at least document that this will also impact the socket timeout between observer and learner master. This is unfortunate, so maybe we ultimately want to rename the method of `connectToLeader` to something like `connectToLearnerMaster`?', 'commenter': 'hanm'}, {'comment': 'Naming is the hardest part...', 'commenter': 'enixon'}, {'comment': 'I will update the pull request to reflect the suggested changes. I will be renaming connectToLeaderLimit to connectToLearnerMasterLimit ', 'commenter': 'vladimirivic'}]"
953,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -1735,8 +1741,22 @@ public void setSyncLimit(int syncLimit) {
         LOG.info(""syncLimit set to "" + syncLimit);
         this.syncLimit = syncLimit;
     }
-    
-    
+
+    /**
+     * Get the connectToLeaderLimit
+     */
+    public int getConnectToLeaderLimit() {
+        return connectToLeaderLimit;
+    }
+
+    /**
+     * Set the connectToLeaderLimit
+     */
+    public void setConnectToLeaderLimit(int connectToLeaderLimit) {
+        LOG.info(""connectToLeaderLimit set to "" + connectToLeaderLimit);","[{'comment': 'nit: use parameterized (`{}`) log.', 'commenter': 'hanm'}]"
953,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -861,6 +862,11 @@ of servers -- that is, when deploying clusters of servers.
     connect and sync to a leader. Increased this value as needed, if
     the amount of data managed by ZooKeeper is large.
 
+* *connectToLearnerMasterLimit* :
+    (No Java system property)
+    Amount of time, in ticks (see [tickTime](#id_tickTime)), to allow followers to
+    connect to the learner master after leader election.","[{'comment': 'We must tell about the default value', 'commenter': 'eolivelli'}, {'comment': ""Default value in the example config is 5. Also if the value is not specified or it's not greater than 0, then the `initLimit` value will be used instead. Will update the docs shortly."", 'commenter': 'vladimirivic'}]"
958,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/Commands.java,"@@ -552,6 +554,39 @@ public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
         }
     }
 
+    /**
+     * Returns the current phase of Zab protocol that peer is running.
+     * It can be in one of these phases: NONE, DISCOVERY, SYNCHRONIZATION, BROADCAST
+     */
+    public static class ZabStateCommand extends CommandBase {
+        public ZabStateCommand() {
+            super(Arrays.asList(""zabstate""), false);
+        }
+
+        @Override
+        public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs) {
+            CommandResponse response = initializeResponse();
+            if (zkServer instanceof QuorumZooKeeperServer) {
+                QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;
+                QuorumPeer.ZabState zabState = peer.getZabState();
+                QuorumVerifier qv = peer.getQuorumVerifier();
+
+                QuorumPeer.QuorumServer voter = qv.getVotingMembers().get(peer.getId());
+                boolean voting = (
+                        voter != null
+                                && voter.addr.equals(peer.getQuorumAddress())
+                                && voter.electionAddr.equals(peer.getElectionAddress())
+                );
+                response.put(""voting"", voting);","[{'comment': 'Does this mean ""voting is done""?', 'commenter': 'anmolnar'}, {'comment': 'This means the peer is a voting member of the quorum. It is a way to distinguish voting Followers from non-voting followers via the admin command interface.', 'commenter': 'enixon'}]"
958,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -416,6 +416,22 @@ public void checkAddressDuplicate(QuorumServer s) throws BadArgumentsException {
         LOOKING, FOLLOWING, LEADING, OBSERVING;
     }
 
+    /**
+     * (Used for monitoring) When peer is in non-LOOKING phase, this shows the
+     * current phase of Zab protocol that peer is running.
+     */
+    public enum ZabState {
+        NONE, DISCOVERY, SYNCHRONIZATION, BROADCAST;","[{'comment': ""Do we need 'NONE' here? As the comment said, ZAB is only relevant for non-looking phase, but later in the code we are setting the state to 'NONE' for non looking peer. I guess we could:\r\n* Update comment saying 'NONE' maps to the looking phase\r\nOr \r\n* Remove 'NONE' from the state (which might be more consistent with traditional ZAB literatures), and don't set the zab state for looking peers.\r\n"", 'commenter': 'hanm'}, {'comment': 'Most of the Zab literature talks about a three phases of Zab:\r\n1. discovery\r\n2. synchronization\r\n3. broadcast\r\n\r\nLeft implicit is the degenerate phase:\r\n0. maybe in leader election\r\n\r\n(see https://distributedalgorithm.wordpress.com/2015/06/20/architecture-of-zab-zookeeper-atomic-broadcast-protocol/ or http://www.tcs.hut.fi/Studies/T-79.5001/reports/2012-deSouzaMedeiros.pdf)\r\n\r\nI\'d say that we do want a concept of the degenerate state. NONE is a reasonable thing to call it, as is ELECTION to my mind. I\'ll modify the comment to remove the mention of ""nonlooking"".', 'commenter': 'enixon'}, {'comment': '`ELECTION` sounds good to me.', 'commenter': 'hanm'}]"
958,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -757,9 +775,30 @@ public synchronized void setPeerState(ServerState newState) {
         state = newState;
         if (newState == ServerState.LOOKING) {
             setLeaderAddressAndId(null, -1);
+            setZabState(ZabState.NONE);
+        } else {
+            LOG.info(""Peer state changed: "" + getDetailedPeerState());
         }
     }
 
+    public void setZabState(ZabState zabState) {
+        this.zabState.set(zabState);
+        LOG.info(""Peer state changed: "" + getDetailedPeerState());","[{'comment': 'nit: use parameterized logging (and for the subsequent log statements).', 'commenter': 'hanm'}]"
959,zookeeper-server/src/main/java/org/apache/zookeeper/MultiTransactionRecord.java,"@@ -88,40 +113,53 @@ public void deserialize(InputArchive archive, String tag) throws IOException {
         archive.startRecord(tag);
         MultiHeader h = new MultiHeader();
         h.deserialize(archive, tag);
-
-        while (!h.getDone()) {
-            switch (h.getType()) {
-                case ZooDefs.OpCode.create:
-                case ZooDefs.OpCode.create2:
-                case ZooDefs.OpCode.createContainer:
-                    CreateRequest cr = new CreateRequest();
-                    cr.deserialize(archive, tag);
-                    add(Op.create(cr.getPath(), cr.getData(), cr.getAcl(), cr.getFlags()));
-                    break;
-                case ZooDefs.OpCode.createTTL:
-                    CreateTTLRequest crTtl = new CreateTTLRequest();
-                    crTtl.deserialize(archive, tag);
-                    add(Op.create(crTtl.getPath(), crTtl.getData(), crTtl.getAcl(), crTtl.getFlags(), crTtl.getTtl()));
-                    break;
-                case ZooDefs.OpCode.delete:
-                    DeleteRequest dr = new DeleteRequest();
-                    dr.deserialize(archive, tag);
-                    add(Op.delete(dr.getPath(), dr.getVersion()));
-                    break;
-                case ZooDefs.OpCode.setData:
-                    SetDataRequest sdr = new SetDataRequest();
-                    sdr.deserialize(archive, tag);
-                    add(Op.setData(sdr.getPath(), sdr.getData(), sdr.getVersion()));
-                    break;
-                case ZooDefs.OpCode.check:
-                    CheckVersionRequest cvr = new CheckVersionRequest();
-                    cvr.deserialize(archive, tag);
-                    add(Op.check(cvr.getPath(), cvr.getVersion()));
-                    break;
-                default:
-                    throw new IOException(""Invalid type of op"");
+        try {
+            while (!h.getDone()) {
+                switch (h.getType()) {
+                    case ZooDefs.OpCode.create:
+                    case ZooDefs.OpCode.create2:
+                    case ZooDefs.OpCode.createContainer:
+                        CreateRequest cr = new CreateRequest();
+                        cr.deserialize(archive, tag);
+                        add(Op.create(cr.getPath(), cr.getData(), cr.getAcl(), cr.getFlags()));
+                        break;
+                    case ZooDefs.OpCode.createTTL:
+                        CreateTTLRequest crTtl = new CreateTTLRequest();
+                        crTtl.deserialize(archive, tag);
+                        add(Op.create(crTtl.getPath(), crTtl.getData(), crTtl.getAcl(), crTtl.getFlags(), crTtl.getTtl()));
+                        break;
+                    case ZooDefs.OpCode.delete:
+                        DeleteRequest dr = new DeleteRequest();
+                        dr.deserialize(archive, tag);
+                        add(Op.delete(dr.getPath(), dr.getVersion()));
+                        break;
+                    case ZooDefs.OpCode.setData:
+                        SetDataRequest sdr = new SetDataRequest();
+                        sdr.deserialize(archive, tag);
+                        add(Op.setData(sdr.getPath(), sdr.getData(), sdr.getVersion()));
+                        break;
+                    case ZooDefs.OpCode.check:
+                        CheckVersionRequest cvr = new CheckVersionRequest();
+                        cvr.deserialize(archive, tag);
+                        add(Op.check(cvr.getPath(), cvr.getVersion()));
+                        break;
+                    case ZooDefs.OpCode.getChildren:
+                        GetChildrenRequest gcr = new GetChildrenRequest();
+                        gcr.deserialize(archive, tag);
+                        add(Op.getChildren(gcr.getPath()));
+                        break;
+                    case ZooDefs.OpCode.getData:
+                        GetDataRequest gdr = new GetDataRequest();
+                        gdr.deserialize(archive, tag);
+                        add(Op.getData(gdr.getPath()));
+                        break;
+                    default:
+                        throw new IOException(""Invalid type of op"");
+                }
+                h.deserialize(archive, tag);
             }
-            h.deserialize(archive, tag);
+        } catch (IllegalArgumentException e) {
+            throw new IOException(""Mixing different type of ops"");","[{'comment': 'language: ""different kind of ops""', 'commenter': 'anmolnar'}]"
959,zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -574,6 +585,41 @@ public void processRequest(Request request) {
         }
     }
 
+    private Record handleReadRequest(int opCode, Record request, ServerCnxn cnxn, List<Id> authInfo)","[{'comment': 'Please split this into 2 separate methods:\r\n```java\r\nprivate GetChildrenResponse handleGetChildrenRequest(int opCode, Record request, ServerCnxn cnxn, List<Id> authInfo)\r\n\r\nprivate GetDataResponse handleGetDataRequest(int opCode, Record request, ServerCnxn cnxn, List<Id> authInfo)\r\n```\r\n', 'commenter': 'anmolnar'}]"
959,zookeeper-server/src/test/java/org/apache/zookeeper/test/MultiTransactionTest.java,"@@ -787,6 +796,192 @@ public void testTransactionBuilder() throws Exception {
         assertNull(zk.exists(""/t2"", false));
     }
 
+    @Test
+    public void testMultiGetChildren() throws Exception {
+        List<String> topLevelNodes = new ArrayList<String>();
+        Map<String, List<String>> childrenNodes = new HashMap<String, List<String>>();
+        // Creating a database where '/fooX' nodes has 'barXY' named children.
+        for (int i = 0; i < 10; i++) {
+            String name = ""/foo"" + i;
+            zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE,
+                    CreateMode.PERSISTENT);
+            topLevelNodes.add(name);
+            childrenNodes.put(name, new ArrayList<>());
+            for (int j = 0; j < 10; j++) {
+                String childname = name + ""/bar"" + i + j;
+                String childname_s = ""bar"" + i + j;
+                zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE,
+                        CreateMode.EPHEMERAL);
+                childrenNodes.get(name).add(childname_s);
+            }
+        }
+        // Create a multi operation, which queries the children of the nodes in topLevelNodes.
+        List<OpResult> multiChildrenList =
+                multi(zk, topLevelNodes.stream().map(Op::getChildren).collect(Collectors.toList()));
+        for (int i = 0; i < topLevelNodes.size(); i++) {
+            String nodeName = topLevelNodes.get(i);
+            Assert.assertTrue(multiChildrenList.get(i) instanceof OpResult.GetChildrenResult);
+            List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(i)).getChildren();
+            // In general, we do not demand an order from the children list but to contain every child.
+            Assert.assertEquals(new TreeSet<String>(childrenList),
+                    new TreeSet<String>(childrenNodes.get(nodeName)));
+
+            List<String> children = zk.getChildren(nodeName, false);
+            Assert.assertEquals(childrenList, children);
+        }
+    }
+
+    @Test
+    public void testMultiGetChildrenSameNode() throws Exception {
+        List<String> childrenNodes = new ArrayList<String>();
+        // Creating a database where '/foo' node has 'barX' named children.
+        String topLevelNode = ""/foo"";
+        zk.create(topLevelNode, topLevelNode.getBytes(), Ids.OPEN_ACL_UNSAFE,
+                CreateMode.PERSISTENT);
+        for (int i = 0; i < 10; i++) {
+            String childname = topLevelNode + ""/bar"" + i;
+            String childname_s = ""bar"" + i;
+            zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE,
+                    CreateMode.EPHEMERAL);
+            childrenNodes.add(childname_s);
+        }
+
+        // Check for getting the children of the same node twice.
+        List<OpResult> sameChildrenList = multi(zk, Arrays.asList(
+                Op.getChildren(topLevelNode),
+                Op.getChildren(topLevelNode)));
+        // The response should contain two elements which are the same.
+        Assert.assertEquals(sameChildrenList.size(), 2);
+        Assert.assertEquals(sameChildrenList.get(0), sameChildrenList.get(1));
+        // Check the actual result.
+        Assert.assertTrue(sameChildrenList.get(0) instanceof OpResult.GetChildrenResult);
+        OpResult.GetChildrenResult gcr = (OpResult.GetChildrenResult) sameChildrenList.get(0);
+        // In general, we do not demand an order from the children list but to contain every child.
+        Assert.assertEquals(new TreeSet<String>(gcr.getChildren()),
+                new TreeSet<String>(childrenNodes));
+    }
+
+    @Test
+    public void testMultiGetChildrenAuthentication() throws KeeperException, InterruptedException {
+                List<ACL> writeOnly = Collections.singletonList(new ACL(ZooDefs.Perms.WRITE,
+                new Id(""world"", ""anyone"")));
+        zk.create(""/foo_auth"", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+        zk.create(""/foo_auth/bar"", null, Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);
+        zk.create(""/foo_no_auth"", null, writeOnly, CreateMode.PERSISTENT);
+
+        // Check for normal behaviour.
+        List<OpResult> multiChildrenList = multi(zk, Arrays.asList(Op.getChildren(""/foo_auth"")));
+        Assert.assertEquals(multiChildrenList.size(), 1);
+        Assert.assertTrue(multiChildrenList.get(0) instanceof  OpResult.GetChildrenResult);
+        List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(0)).getChildren();
+        Assert.assertEquals(childrenList.size(), 1);
+        Assert.assertEquals(childrenList.get(0), ""bar"");
+
+        // Check for authentication violation.
+        multiChildrenList = multi(zk, Arrays.asList(Op.getChildren(""/foo_no_auth"")));
+
+        Assert.assertEquals(multiChildrenList.size(), 1);
+        Assert.assertTrue(multiChildrenList.get(0) instanceof OpResult.ErrorResult);
+        Assert.assertEquals(""Expected NoAuthException for getting the children of a write only node"",
+                ((OpResult.ErrorResult) multiChildrenList.get(0)).getErr(), KeeperException.Code.NOAUTH.intValue());
+
+    }
+
+    @Test
+    public void testMultiGetChildrenMixedAuthentication() throws KeeperException, InterruptedException {
+        List<ACL> writeOnly = Collections.singletonList(new ACL(ZooDefs.Perms.WRITE,
+                new Id(""world"", ""anyone"")));
+        zk.create(""/foo_auth"", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+        zk.create(""/foo_auth/bar"", null, Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);
+        zk.create(""/foo_no_auth"", null, writeOnly, CreateMode.PERSISTENT);
+        List<OpResult> multiChildrenList;
+
+        // Mixed nodes, the operation after the error should return RuntimeInconsistency error.
+        multiChildrenList = multi(zk, Arrays.asList(Op.getChildren(""/foo_no_auth""), Op.getChildren(""/foo_auth"")));
+
+        Assert.assertEquals(multiChildrenList.size(), 2);
+        Assert.assertTrue(multiChildrenList.get(0) instanceof OpResult.ErrorResult);
+        Assert.assertEquals(""Expected NoAuthException for getting the children of a write only node"",
+                ((OpResult.ErrorResult) multiChildrenList.get(0)).getErr(), KeeperException.Code.NOAUTH.intValue());
+
+        Assert.assertTrue(multiChildrenList.get(1) instanceof OpResult.GetChildrenResult);
+        List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(1)).getChildren();
+        Assert.assertEquals(childrenList.size(), 1);
+        Assert.assertEquals(childrenList.get(0), ""bar"");
+    }
+
+    @Test
+    public void testMultiGetChildrenMixedAuthentication2() throws KeeperException, InterruptedException {","[{'comment': 'Please indicate the difference in the method name.', 'commenter': 'anmolnar'}]"
959,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -1895,23 +1897,33 @@ private Op withRootPrefix(Op op) {
 
     protected void multiInternal(MultiTransactionRecord request, MultiCallback cb, Object ctx) {
         RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.multi);
+        switch (request.getOpKind()) {
+            case TRANSACTION: h.setType(ZooDefs.OpCode.multi); break;
+            case READ: h.setType(ZooDefs.OpCode.multiRead); break;","[{'comment': 'Nit: add default', 'commenter': 'eolivelli'}]"
959,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -1895,23 +1897,33 @@ private Op withRootPrefix(Op op) {
 
     protected void multiInternal(MultiTransactionRecord request, MultiCallback cb, Object ctx) {
         RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.multi);
+        switch (request.getOpKind()) {
+            case TRANSACTION: h.setType(ZooDefs.OpCode.multi); break;
+            case READ: h.setType(ZooDefs.OpCode.multiRead); break;
+        }
         MultiResponse response = new MultiResponse();
         cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, null, null, ctx, null);
     }
 
     protected List<OpResult> multiInternal(MultiTransactionRecord request)
         throws InterruptedException, KeeperException {
         RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.multi);
+        switch (request.getOpKind()) {
+            case TRANSACTION: h.setType(ZooDefs.OpCode.multi); break;
+            case READ: h.setType(ZooDefs.OpCode.multiRead); break;","[{'comment': 'Nit: add default', 'commenter': 'eolivelli'}]"
959,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -1895,23 +1897,33 @@ private Op withRootPrefix(Op op) {
 
     protected void multiInternal(MultiTransactionRecord request, MultiCallback cb, Object ctx) {
         RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.multi);
+        switch (request.getOpKind()) {
+            case TRANSACTION: h.setType(ZooDefs.OpCode.multi); break;
+            case READ: h.setType(ZooDefs.OpCode.multiRead); break;
+        }
         MultiResponse response = new MultiResponse();
         cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, null, null, ctx, null);
     }
 
     protected List<OpResult> multiInternal(MultiTransactionRecord request)
         throws InterruptedException, KeeperException {
         RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.multi);
+        switch (request.getOpKind()) {
+            case TRANSACTION: h.setType(ZooDefs.OpCode.multi); break;
+            case READ: h.setType(ZooDefs.OpCode.multiRead); break;
+        }
         MultiResponse response = new MultiResponse();
         ReplyHeader r = cnxn.submitRequest(h, request, response, null);
         if (r.getErr() != 0) {
             throw KeeperException.create(KeeperException.Code.get(r.getErr()));
         }
 
         List<OpResult> results = response.getResultList();
-        
+        // In case of only read operations there is no need to throw an exception
+        // as the subResults are still possibly valid.
+        if(request.getOpKind() == Op.OpKind.READ)","[{'comment': 'Nit add brackets', 'commenter': 'eolivelli'}]"
959,zookeeper-server/src/main/java/org/apache/zookeeper/MultiTransactionRecord.java,"@@ -28,20 +28,25 @@
 import java.util.List;
 
 /**
- * Encodes a composite transaction.  In the wire format, each transaction
+ * Encodes a composite operation.  In the wire format, each operation
  * consists of a single MultiHeader followed by the appropriate request.
  * Each of these MultiHeaders has a type which indicates
- * the type of the following transaction or a negative number if no more transactions
+ * the type of the following operation or a negative number if no more operations
  * are included.
+ * All of the operations must be from the same OpKind.
+ * Note: This class is called MultiTransactionRecord because of legacy reasons,
+ * MultiOperationRecord would be more accurate.
  */
 public class MultiTransactionRecord implements Record, Iterable<Op> {","[{'comment': ""Should we create a new MultiReadRecord instead of reusing this one? Since the read is not txn, and we don't allow read mixed with write.\r\n\r\nIt avoided some unnecessary check in the code, and also less confusing to user."", 'commenter': 'lvfangmin'}, {'comment': 'On one hand, I definitely agree with you that the name is confusing and could be improved. Going into implementation details, I think it would be the best to create a `MultiOperationRecord` base (super) class which could have `MultiReadRecord` and `MultiTransactionRecord` subclasses.\r\nOn the other hand, (besides resolving confusion caused by the name) I do not see how it helps as to avoid any checks. It would require us to overload some function for Txn/Read operations which would lead to more duplicated code. Another way is that we could have an `instanceof` check at the beginning of these function instead of the `OpKind` checks but again, this would result the some checks.\r\nSince `Op`, `OpResult,` and `MultiResponse` is preserved as a single class (though these could be extended into more subclasses as well like `ReadOp/TransactionOp`, `MultiTxnResponse/MultiReadResponse`) to maintain the current workflow, I say it is better and more consistent to preserve it as well and make decisions based on `OpKind`.\r\nBut of course, I am convincible on this topic so feel free to argue! :) What do you think?', 'commenter': 'szepet'}, {'comment': ""One more note to this topic:\r\nAs I am a fresh contributor don't know how important the backward compatibility of a class like this is. I am not sure whether `MultiTransactionRecord` is even used outside this library since the multi functions do not require the user to construct it. So, maybe a simple rename to `MultiOperationRecord` could resolve the confusion? Would it be a deal breaker?"", 'commenter': 'szepet'}, {'comment': 'I feel we can change the name of classes as it is not a public API and class names are not stored on snapshots/ txlog', 'commenter': 'eolivelli'}]"
959,zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -574,6 +585,41 @@ public void processRequest(Request request) {
         }
     }
 
+    private Record handleReadRequest(int opCode, Record request, ServerCnxn cnxn, List<Id> authInfo)
+            throws KeeperException, IOException {
+        switch(opCode) {
+            case OpCode.getChildren: {
+                GetChildrenRequest getChildrenRequest = (GetChildrenRequest) request;","[{'comment': 'Please refactor the code to reuse existing logic for getChildren and getData, which makes it easier to maintain in the future.', 'commenter': 'lvfangmin'}, {'comment': 'Hmm, that is something that I 100% percent agree but I do not see why this code is not appropriate. The code of getChildren and getData only creates the record from the request and then calls the `handleGetChildrenRequest` or the `handleGetDataRequest` function as well just like the `multiRead` version.\r\nOr did I miss something and could we improve upon this?', 'commenter': 'szepet'}, {'comment': 'I merged your change into on our internal FB branch for getDataList and needed to do some manual refactoring to get FinalRequestProcessor working.  As part of this I defined 3 new private methods:\r\n- handleGetChildrenRequest\r\n- handleGetDataRequest\r\n- verifyPathExistsAndCheckACL: an internal helper that reduces duplicate code throughout the class\r\n\r\nThe cleanest thing about the refactoring is that the switch statement on the multiRead type only needs to be called once.  Let me upload a patch file\r\n\r\n\r\n\r\n\r\n', 'commenter': 'stickyhipp'}, {'comment': 'nm, looks like you made the changes in line with the suggestion.  looks good.\r\n\r\n', 'commenter': 'stickyhipp'}]"
959,zookeeper-server/src/main/java/org/apache/zookeeper/MultiTransactionRecord.java,"@@ -51,14 +56,32 @@ public MultiTransactionRecord(Iterable<Op> ops) {
         return ops.iterator() ;
     }
 
-    public void add(Op op) {
+    public void add(Op op) throws IllegalArgumentException {
+        setOrCheckOpKind(op.getKind());
         ops.add(op);
     }
 
     public int size() {
         return ops.size();
     }
 
+    /**
+     * Returns the kind of the operations contained by the record.
+     * @return  The OpKind value of all the elements in the record.
+     */
+    public Op.OpKind getOpKind() {
+        return opKind;
+    }
+
+    private void setOrCheckOpKind(Op.OpKind ok) throws IllegalArgumentException {
+        if(opKind == null) {","[{'comment': 'nit: space after if ', 'commenter': 'lvfangmin'}]"
959,zookeeper-server/src/main/java/org/apache/zookeeper/MultiTransactionRecord.java,"@@ -51,14 +56,32 @@ public MultiTransactionRecord(Iterable<Op> ops) {
         return ops.iterator() ;
     }
 
-    public void add(Op op) {
+    public void add(Op op) throws IllegalArgumentException {
+        setOrCheckOpKind(op.getKind());
         ops.add(op);
     }
 
     public int size() {
         return ops.size();
     }
 
+    /**
+     * Returns the kind of the operations contained by the record.
+     * @return  The OpKind value of all the elements in the record.
+     */
+    public Op.OpKind getOpKind() {
+        return opKind;
+    }
+
+    private void setOrCheckOpKind(Op.OpKind ok) throws IllegalArgumentException {
+        if(opKind == null) {
+            opKind = ok;
+        } else if(ok != opKind) {","[{'comment': 'ditto.', 'commenter': 'lvfangmin'}]"
959,zookeeper-server/src/main/java/org/apache/zookeeper/MultiResponse.java,"@@ -78,6 +82,12 @@ public void serialize(OutputArchive archive, String tag) throws IOException {
                 case ZooDefs.OpCode.setData:
                     new SetDataResponse(((OpResult.SetDataResult) result).getStat()).serialize(archive, tag);
                     break;
+                case ZooDefs.OpCode.getChildren:
+                    new GetChildrenResponse(((OpResult.GetChildrenResult) result).getChildren()).serialize(archive, tag);
+                    break;
+                case ZooDefs.OpCode.getData:
+                    new GetDataResponse(((OpResult.GetDataResult) result).getData(), new Stat()).serialize(archive, tag);","[{'comment': ""Let's return Stat from the GetData call:\r\n\r\nnew GetDataResponse(((OpResult.GetDataResult) result).getData(),((OpResult.GetDataResult) result).getStat()).serialize(archive, tag);"", 'commenter': 'stickyhipp'}]"
959,zookeeper-server/src/main/java/org/apache/zookeeper/OpResult.java,"@@ -170,6 +173,67 @@ public int hashCode() {
         }
     }
 
+    /**
+     * A result from a getChildren operation. Provides a list which contains
+     * the names of the children of a given node.
+     */
+    public static class GetChildrenResult extends OpResult {
+        private List<String> children;
+
+        public GetChildrenResult(List<String> children) {
+            super(ZooDefs.OpCode.getChildren);
+            this.children = children;
+        }
+
+        public List<String> getChildren() {
+            return children;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof GetChildrenResult)) return false;
+
+            GetChildrenResult other = (GetChildrenResult) o;
+            return getType() == other.getType() && children.equals(other.children);
+        }
+
+        @Override
+        public int hashCode() {
+            return getType() * 35 + children.hashCode();
+        }
+    }
+
+    /**
+     * A result from a getData operation. The data is represented as a byte array.
+     */
+    public static class GetDataResult extends OpResult {
+        private byte[] data;","[{'comment': 'Add Stat data member\r\n\r\nhttps://github.com/apache/zookeeper/pull/979/files#diff-7845efb4abfbb23b49a833c9042004a8R207', 'commenter': 'stickyhipp'}]"
959,zookeeper-server/src/main/java/org/apache/zookeeper/OpResult.java,"@@ -170,6 +173,67 @@ public int hashCode() {
         }
     }
 
+    /**
+     * A result from a getChildren operation. Provides a list which contains
+     * the names of the children of a given node.
+     */
+    public static class GetChildrenResult extends OpResult {
+        private List<String> children;
+
+        public GetChildrenResult(List<String> children) {
+            super(ZooDefs.OpCode.getChildren);
+            this.children = children;
+        }
+
+        public List<String> getChildren() {
+            return children;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof GetChildrenResult)) return false;
+
+            GetChildrenResult other = (GetChildrenResult) o;
+            return getType() == other.getType() && children.equals(other.children);
+        }
+
+        @Override
+        public int hashCode() {
+            return getType() * 35 + children.hashCode();
+        }
+    }
+
+    /**
+     * A result from a getData operation. The data is represented as a byte array.
+     */
+    public static class GetDataResult extends OpResult {
+        private byte[] data;
+
+        public GetDataResult(byte[] data) {
+            super(ZooDefs.OpCode.getData);
+            this.data = data.clone();","[{'comment': ""Consider Arrays.copyOf() instead of clone()?  clone feels antiquated to me, but I'm not clear what the best practice is...\r\n\r\nCheck for null on data?\r\n\r\nthis.data = (data == null ? null : Arrays.copyOf(data, data.length));"", 'commenter': 'stickyhipp'}]"
959,zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -270,6 +274,33 @@ public void processRequest(Request request) {
 
                 break;
             }
+            case OpCode.multiRead: {
+                lastOp = ""MLTR"";
+                MultiTransactionRecord multiTransactionRecord = new MultiTransactionRecord();
+                ByteBufferInputStream.byteBuffer2Record(request.request, multiTransactionRecord);
+                rsp = new MultiResponse();
+                OpResult subResult;
+                for(Op readOp : multiTransactionRecord) {
+                    try {
+                        Record rec = handleReadRequest(readOp.getType(), readOp.toRequestRecord(), cnxn, request.authInfo);
+                        switch(readOp.getType()) {
+                            case OpCode.getChildren:
+                                subResult = new GetChildrenResult(((GetChildrenResponse) rec).getChildren());
+                                break;
+                            case OpCode.getData:
+                                GetDataResponse gdr = (GetDataResponse) rec;
+                                subResult = new GetDataResult(gdr.getData());","[{'comment': 'Add Stat to GetDataResult', 'commenter': 'stickyhipp'}]"
959,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -1893,25 +1895,41 @@ private Op withRootPrefix(Op op) {
         return op;
     }
 
-    protected void multiInternal(MultiTransactionRecord request, MultiCallback cb, Object ctx) {
+    protected void multiInternal(MultiOperationRecord request, MultiCallback cb, Object ctx)
+            throws IllegalArgumentException {
         RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.multi);
+        switch (request.getOpKind()) {
+            case TRANSACTION: h.setType(ZooDefs.OpCode.multi); break;
+            case READ: h.setType(ZooDefs.OpCode.multiRead); break;
+            default:
+                throw new IllegalArgumentException(""Invalid kind of op"");","[{'comment': 'Please rephrase: ""Unsupported OpKind: "" + request.getOpKind()\r\n(or use string formatter)', 'commenter': 'anmolnar'}]"
980,.gitignore,"@@ -89,4 +89,5 @@ zookeeper-client/zookeeper-client-c/install-sh
 zookeeper-client/zookeeper-client-c/ltmain.sh
 zookeeper-client/zookeeper-client-c/missing
 zookeeper-server/src/main/java/org/apache/zookeeper/version/Info.java
+zookeeper-server/src/main/java/org/apache/zookeeper/version/VersionInfoMain.java","[{'comment': 'I just noticed this issue during a build, good to fix. I agree with Norbert - this should be part of ""generate-sources"" phase/directory.', 'commenter': 'phunt'}]"
980,zookeeper-server/src/main/java/org/apache/zookeeper/version/util/VerGen.java,"@@ -198,7 +198,7 @@ public static void main(String[] args) {
             } else {
                 rev = rev.trim();
             }
-            generateFile(new File("".""), version, rev, args[2]);
+            generateFile(new File(""../../../target/generated-sources/java""), version, rev, args[2]);","[{'comment': 'It is better to have this path passed as a parameter, this way it will be easier to drive this code from the pom.xml', 'commenter': 'eolivelli'}]"
986,zookeeper-server/src/main/java/org/apache/zookeeper/server/RequestThrottler.java,"@@ -0,0 +1,273 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.util.concurrent.LinkedBlockingQueue;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.zookeeper.common.Time;
+
+/**
+ * When enabled, the RequestThrottler limits the number of outstanding requests
+ * currently submitted to the request processor pipeline. The throttler augments
+ * the limit imposed by the <code>globalOutstandingLimit</code> that is enforced
+ * by the connection layer ({@link NIOServerCnxn}, {@link NettyServerCnxn}).
+ *
+ * The connection layer limit applies backpressure against the TCP connection by
+ * disabling selection on connections once the request limit is reached. However,
+ * the connection layer always allows a connection to send at least one request
+ * before disabling selection on that connection. Thus, in a scenario with 40000
+ * client connections, the total number of requests inflight may be as high as
+ * 40000 even if the <code>globalOustandingLimit</code> was set lower.
+ *
+ * The RequestThrottler addresses this issue by adding additional queueing. When
+ * enabled, client connections no longer submit requests directly to the request
+ * processor pipeline but instead to the RequestThrottler. The RequestThrottler
+ * is then responsible for issuing requests to the request processors, and
+ * enforces a separate <code>maxRequests</code> limit. If the total number of
+ * outstanding requests is higher than <code>maxRequests</code>, the throttler
+ * will continually stall for <code>stallTime</code> milliseconds until
+ * underlimit.
+ *
+ * The RequestThrottler can also optionally drop stale requests rather than
+ * submit them to the processor pipeline. A stale request is a request sent
+ * by a connection that is already closed, and/or a request whose latency
+ * will end up being higher than its associated session timeout. The notion
+ * of staleness is configurable, @see Request for more details.
+ *
+ * To ensure ordering guarantees, if a request is ever dropped from a connection
+ * that connection is closed and flagged as invalid. All subsequent requests
+ * inflight from that connection are then dropped as well.
+ */
+public class RequestThrottler extends ZooKeeperCriticalThread {
+    private static final Logger LOG = LoggerFactory.getLogger(RequestThrottler.class);
+
+    private final LinkedBlockingQueue<Request> submittedRequests =
+        new LinkedBlockingQueue<Request>();
+
+    private final ZooKeeperServer zks;
+    private volatile boolean stopping;
+    private volatile boolean killed;
+
+    /**
+     * enabled can only be set via system properties and not at runtime to
+     * ensure requests are never sent sometimes to the RequestThrottler and
+     * other times directly to a request processor, thus potentially reodering
+     * requests.
+     *
+     * This setting is designed as a code kill switch. In normal operation,
+     * enabled should be set to true. When enabled, maxRequests can be adjusted
+     * to enable/disable throttling at runtime.
+     */
+    private static final boolean enabled =
+        ZooKeeperServer.getBooleanProp(""zookeeper.request_throttle"", true);","[{'comment': ""Do we need this control flag? Throttle can be controlled on / off by the max requests, so this seems redundant. Are there any additional cost on instantiating a RequestThrottler but not activate it? Having less configuration option would be better as it'll be easy to use, and minimize the probability of a misconfiguration."", 'commenter': 'hanm'}, {'comment': 'completely agree. removing it...', 'commenter': 'jhuan31'}]"
986,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -250,11 +263,20 @@ public ZooKeeperServer(JvmPauseMonitor jvmPauseMonitor, FileTxnSnapLog txnLogFac
                            ZKDatabase zkDb, String initialConfig) {
         this(txnLogFactory, tickTime, minSessionTimeout, maxSessionTimeout, clientPortListenBacklog, zkDb, initialConfig);
         this.jvmPauseMonitor = jvmPauseMonitor;
-        if(jvmPauseMonitor != null) {
+        if (jvmPauseMonitor != null) {
             LOG.info(""Added JvmPauseMonitor to server"");
         }
     }
 
+    static boolean getBooleanProp(String name, boolean def) {","[{'comment': 'Is this needed? `Boolean.getBoolean` is functionally equivalent.', 'commenter': 'hanm'}, {'comment': ""it is not equivalent when we want the default to be true. But you are right that we don't need this helper function. Replacing it with Boolean.parseBoolean(System.getProperty())"", 'commenter': 'jhuan31'}]"
986,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -98,6 +98,14 @@
         Environment.logEnv(""Server environment:"", LOG);
     }
 
+    private static final String SHUTDOWN_TIMEOUT = ""zookeeper.shutdownTimeout"";","[{'comment': 'This is ambiguous (can be interpreted as server shutdown timeout especially given its defined in this file). Consider properly name space it, such as `zookeeper.request_throttler.shutdownTimeout`.', 'commenter': 'hanm'}, {'comment': 'changed the name. also move the definition in RequestThrottler since it is the shutdown timeout for request throttler', 'commenter': 'jhuan31'}]"
986,zookeeper-server/src/main/java/org/apache/zookeeper/server/RequestThrottler.java,"@@ -0,0 +1,273 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.util.concurrent.LinkedBlockingQueue;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.zookeeper.common.Time;
+
+/**
+ * When enabled, the RequestThrottler limits the number of outstanding requests
+ * currently submitted to the request processor pipeline. The throttler augments
+ * the limit imposed by the <code>globalOutstandingLimit</code> that is enforced
+ * by the connection layer ({@link NIOServerCnxn}, {@link NettyServerCnxn}).
+ *
+ * The connection layer limit applies backpressure against the TCP connection by
+ * disabling selection on connections once the request limit is reached. However,
+ * the connection layer always allows a connection to send at least one request
+ * before disabling selection on that connection. Thus, in a scenario with 40000
+ * client connections, the total number of requests inflight may be as high as
+ * 40000 even if the <code>globalOustandingLimit</code> was set lower.
+ *
+ * The RequestThrottler addresses this issue by adding additional queueing. When
+ * enabled, client connections no longer submit requests directly to the request
+ * processor pipeline but instead to the RequestThrottler. The RequestThrottler
+ * is then responsible for issuing requests to the request processors, and
+ * enforces a separate <code>maxRequests</code> limit. If the total number of
+ * outstanding requests is higher than <code>maxRequests</code>, the throttler
+ * will continually stall for <code>stallTime</code> milliseconds until
+ * underlimit.
+ *
+ * The RequestThrottler can also optionally drop stale requests rather than
+ * submit them to the processor pipeline. A stale request is a request sent
+ * by a connection that is already closed, and/or a request whose latency
+ * will end up being higher than its associated session timeout. The notion
+ * of staleness is configurable, @see Request for more details.
+ *
+ * To ensure ordering guarantees, if a request is ever dropped from a connection
+ * that connection is closed and flagged as invalid. All subsequent requests
+ * inflight from that connection are then dropped as well.
+ */
+public class RequestThrottler extends ZooKeeperCriticalThread {
+    private static final Logger LOG = LoggerFactory.getLogger(RequestThrottler.class);
+
+    private final LinkedBlockingQueue<Request> submittedRequests =
+        new LinkedBlockingQueue<Request>();
+
+    private final ZooKeeperServer zks;
+    private volatile boolean stopping;
+    private volatile boolean killed;
+
+    /**
+     * enabled can only be set via system properties and not at runtime to
+     * ensure requests are never sent sometimes to the RequestThrottler and
+     * other times directly to a request processor, thus potentially reodering
+     * requests.
+     *
+     * This setting is designed as a code kill switch. In normal operation,
+     * enabled should be set to true. When enabled, maxRequests can be adjusted
+     * to enable/disable throttling at runtime.
+     */
+    private static final boolean enabled =
+        ZooKeeperServer.getBooleanProp(""zookeeper.request_throttle"", true);
+
+    /**
+     * The total number of outstanding requests allowed before the throttler
+     * starts stalling.
+     *
+     * When maxRequests = 0, throttling is disabled.
+     */
+    private static volatile int maxRequests =
+        Integer.getInteger(""zookeeper.request_throttle_max_requests"", 0);
+
+    /**
+     * The time (in milliseconds) this is the maximum time for which throttler
+     * thread may wait to be notified that it may proceed processing a request.
+     */
+    private static volatile int stallTime =
+        Integer.getInteger(""zookeeper.request_throttle_stall_time"", 100);
+
+    /**
+     * When true, the throttler will drop stale requests rather than issue
+     * them to the request pipeline. A stale request is a request sent by
+     * a connection that is now closed, and/or a request that will have a
+     * request latency higher than the sessionTimeout. The staleness of
+     * a request is tunable property, @see Request for details.
+     */
+    private static volatile boolean dropStaleRequests =
+        ZooKeeperServer.getBooleanProp(""zookeeper.request_throttle_drop_stale"", true);
+
+    public RequestThrottler(ZooKeeperServer zks) {
+        super(""RequestThrottler"", zks.getZooKeeperServerListener());
+        this.zks = zks;
+        this.stopping = false;
+        this.killed = false;
+    }
+
+    public static int getMaxRequests() {
+        return maxRequests;
+    }
+
+    public static void setMaxRequests(int requests) {
+        maxRequests = requests;
+    }
+
+    public static int getStallTime() {
+        return stallTime;
+    }
+
+    public static void setStallTime(int time) {
+        stallTime = time;
+    }
+
+    public static boolean getDropStaleRequests() {
+        return dropStaleRequests;
+    }
+
+    public static void setDropStaleRequests(boolean drop) {
+        dropStaleRequests = drop;
+    }
+
+    public static boolean enabled() {
+        return enabled;
+    }
+
+    @Override
+    public void run() {
+        try {
+            while (true) {
+                Request request = submittedRequests.take();
+                if (Request.requestOfDeath == request) {
+                    break;
+                }
+
+                if (request.mustDrop()) {
+                    continue;
+                }
+
+                // Throttling is disabled when maxRequests = 0
+                if (maxRequests > 0) {
+                    while (!killed) {
+                        if (dropStaleRequests && request.isStale()) {
+                            // Note: this will close the connection
+                            dropRequest(request);
+                            ServerMetrics.getMetrics().STALE_REQUESTS_DROPPED.add(1);
+                            request = null;
+                            break;
+                        }
+                        if (zks.getInProcess() < maxRequests) {
+                            break;
+                        }
+                        throttleSleep(stallTime);
+                    }
+                }
+
+                if (killed) {
+                    break;
+                }
+
+                // A dropped stale request will be null
+                if (request != null) {
+                    if (request.isStale()) {
+                        ServerMetrics.getMetrics().STALE_REQUESTS.add(1);
+                    }
+                    zks.submitRequestNow(request);
+                }
+            }
+        } catch (InterruptedException e) {
+            LOG.error(""Unexpected interruption"", e);
+        }
+        int dropped = drainQueue();
+        LOG.info(""RequestThrottler shutdown. Dropped "" + dropped + "" requests"");","[{'comment': 'nit: consider using parameterized logging.', 'commenter': 'hanm'}, {'comment': 'done.', 'commenter': 'jhuan31'}]"
986,zookeeper-server/src/main/java/org/apache/zookeeper/server/RequestThrottler.java,"@@ -0,0 +1,273 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.util.concurrent.LinkedBlockingQueue;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.zookeeper.common.Time;
+
+/**
+ * When enabled, the RequestThrottler limits the number of outstanding requests
+ * currently submitted to the request processor pipeline. The throttler augments
+ * the limit imposed by the <code>globalOutstandingLimit</code> that is enforced
+ * by the connection layer ({@link NIOServerCnxn}, {@link NettyServerCnxn}).
+ *
+ * The connection layer limit applies backpressure against the TCP connection by
+ * disabling selection on connections once the request limit is reached. However,
+ * the connection layer always allows a connection to send at least one request
+ * before disabling selection on that connection. Thus, in a scenario with 40000
+ * client connections, the total number of requests inflight may be as high as
+ * 40000 even if the <code>globalOustandingLimit</code> was set lower.
+ *
+ * The RequestThrottler addresses this issue by adding additional queueing. When
+ * enabled, client connections no longer submit requests directly to the request
+ * processor pipeline but instead to the RequestThrottler. The RequestThrottler
+ * is then responsible for issuing requests to the request processors, and
+ * enforces a separate <code>maxRequests</code> limit. If the total number of
+ * outstanding requests is higher than <code>maxRequests</code>, the throttler
+ * will continually stall for <code>stallTime</code> milliseconds until
+ * underlimit.
+ *
+ * The RequestThrottler can also optionally drop stale requests rather than
+ * submit them to the processor pipeline. A stale request is a request sent
+ * by a connection that is already closed, and/or a request whose latency
+ * will end up being higher than its associated session timeout. The notion
+ * of staleness is configurable, @see Request for more details.
+ *
+ * To ensure ordering guarantees, if a request is ever dropped from a connection
+ * that connection is closed and flagged as invalid. All subsequent requests
+ * inflight from that connection are then dropped as well.
+ */
+public class RequestThrottler extends ZooKeeperCriticalThread {
+    private static final Logger LOG = LoggerFactory.getLogger(RequestThrottler.class);
+
+    private final LinkedBlockingQueue<Request> submittedRequests =
+        new LinkedBlockingQueue<Request>();
+
+    private final ZooKeeperServer zks;
+    private volatile boolean stopping;
+    private volatile boolean killed;
+
+    /**
+     * enabled can only be set via system properties and not at runtime to
+     * ensure requests are never sent sometimes to the RequestThrottler and
+     * other times directly to a request processor, thus potentially reodering
+     * requests.
+     *
+     * This setting is designed as a code kill switch. In normal operation,
+     * enabled should be set to true. When enabled, maxRequests can be adjusted
+     * to enable/disable throttling at runtime.
+     */
+    private static final boolean enabled =
+        ZooKeeperServer.getBooleanProp(""zookeeper.request_throttle"", true);
+
+    /**
+     * The total number of outstanding requests allowed before the throttler
+     * starts stalling.
+     *
+     * When maxRequests = 0, throttling is disabled.
+     */
+    private static volatile int maxRequests =
+        Integer.getInteger(""zookeeper.request_throttle_max_requests"", 0);
+
+    /**
+     * The time (in milliseconds) this is the maximum time for which throttler
+     * thread may wait to be notified that it may proceed processing a request.
+     */
+    private static volatile int stallTime =
+        Integer.getInteger(""zookeeper.request_throttle_stall_time"", 100);
+
+    /**
+     * When true, the throttler will drop stale requests rather than issue
+     * them to the request pipeline. A stale request is a request sent by
+     * a connection that is now closed, and/or a request that will have a
+     * request latency higher than the sessionTimeout. The staleness of
+     * a request is tunable property, @see Request for details.
+     */
+    private static volatile boolean dropStaleRequests =
+        ZooKeeperServer.getBooleanProp(""zookeeper.request_throttle_drop_stale"", true);
+
+    public RequestThrottler(ZooKeeperServer zks) {
+        super(""RequestThrottler"", zks.getZooKeeperServerListener());
+        this.zks = zks;
+        this.stopping = false;
+        this.killed = false;
+    }
+
+    public static int getMaxRequests() {
+        return maxRequests;
+    }
+
+    public static void setMaxRequests(int requests) {
+        maxRequests = requests;
+    }
+
+    public static int getStallTime() {
+        return stallTime;
+    }
+
+    public static void setStallTime(int time) {
+        stallTime = time;
+    }
+
+    public static boolean getDropStaleRequests() {
+        return dropStaleRequests;
+    }
+
+    public static void setDropStaleRequests(boolean drop) {
+        dropStaleRequests = drop;
+    }
+
+    public static boolean enabled() {
+        return enabled;
+    }
+
+    @Override
+    public void run() {
+        try {
+            while (true) {
+                Request request = submittedRequests.take();
+                if (Request.requestOfDeath == request) {
+                    break;
+                }
+
+                if (request.mustDrop()) {
+                    continue;
+                }
+
+                // Throttling is disabled when maxRequests = 0
+                if (maxRequests > 0) {
+                    while (!killed) {
+                        if (dropStaleRequests && request.isStale()) {
+                            // Note: this will close the connection
+                            dropRequest(request);
+                            ServerMetrics.getMetrics().STALE_REQUESTS_DROPPED.add(1);
+                            request = null;
+                            break;
+                        }
+                        if (zks.getInProcess() < maxRequests) {
+                            break;
+                        }
+                        throttleSleep(stallTime);
+                    }
+                }
+
+                if (killed) {
+                    break;
+                }
+
+                // A dropped stale request will be null
+                if (request != null) {
+                    if (request.isStale()) {
+                        ServerMetrics.getMetrics().STALE_REQUESTS.add(1);
+                    }
+                    zks.submitRequestNow(request);
+                }
+            }
+        } catch (InterruptedException e) {
+            LOG.error(""Unexpected interruption"", e);
+        }
+        int dropped = drainQueue();
+        LOG.info(""RequestThrottler shutdown. Dropped "" + dropped + "" requests"");
+    }
+
+    private synchronized void throttleSleep(int stallTime) {
+        try {
+            ServerMetrics.getMetrics().REQUEST_THROTTLE_WAIT_COUNT.add(1);
+            this.wait(stallTime);
+        } catch(InterruptedException ie) {
+            return;
+        }
+    }
+
+    @SuppressFBWarnings(value = ""NN_NAKED_NOTIFY"",
+            justification = ""state change is in ZooKeeperServer.decInProgress() "")
+    public synchronized void throttleWake() {
+        this.notify();
+    }
+
+    private int drainQueue() {
+        // If the throttler shutdown gracefully, the queue will be empty.
+        // However, if the shutdown time limit was reached and the throttler
+        // was killed, we have no other option than to drop all remaining
+        // requests on the floor.
+        int dropped = 0;
+        Request request;
+        LOG.info(""Draining request throttler queue"");
+        while ((request = submittedRequests.poll()) != null) {
+            dropped += 1;
+            dropRequest(request);
+        }
+        return dropped;
+    }
+
+    private void dropRequest(Request request) {
+        // Since we're dropping a request on the floor, we must mark the
+        // connection as invalid to ensure any future requests from this
+        // connection are also dropped in order to ensure ordering
+        // semantics.
+        ServerCnxn conn = request.getConnection();
+        if (conn != null) {
+            // Note: this will close the connection
+            conn.setInvalid();
+        }
+    }
+
+    public void submitRequest(Request request) {
+        if (stopping) {
+            LOG.debug(""Shutdown in progress. Request cannot be processed"");
+            dropRequest(request);
+        }
+        else {","[{'comment': 'nit: } else { ', 'commenter': 'hanm'}, {'comment': 'done', 'commenter': 'jhuan31'}]"
986,zookeeper-server/src/main/java/org/apache/zookeeper/server/RequestThrottler.java,"@@ -0,0 +1,273 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.util.concurrent.LinkedBlockingQueue;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.zookeeper.common.Time;
+
+/**
+ * When enabled, the RequestThrottler limits the number of outstanding requests
+ * currently submitted to the request processor pipeline. The throttler augments
+ * the limit imposed by the <code>globalOutstandingLimit</code> that is enforced
+ * by the connection layer ({@link NIOServerCnxn}, {@link NettyServerCnxn}).
+ *
+ * The connection layer limit applies backpressure against the TCP connection by
+ * disabling selection on connections once the request limit is reached. However,
+ * the connection layer always allows a connection to send at least one request
+ * before disabling selection on that connection. Thus, in a scenario with 40000
+ * client connections, the total number of requests inflight may be as high as
+ * 40000 even if the <code>globalOustandingLimit</code> was set lower.
+ *
+ * The RequestThrottler addresses this issue by adding additional queueing. When
+ * enabled, client connections no longer submit requests directly to the request
+ * processor pipeline but instead to the RequestThrottler. The RequestThrottler
+ * is then responsible for issuing requests to the request processors, and
+ * enforces a separate <code>maxRequests</code> limit. If the total number of
+ * outstanding requests is higher than <code>maxRequests</code>, the throttler
+ * will continually stall for <code>stallTime</code> milliseconds until
+ * underlimit.
+ *
+ * The RequestThrottler can also optionally drop stale requests rather than
+ * submit them to the processor pipeline. A stale request is a request sent
+ * by a connection that is already closed, and/or a request whose latency
+ * will end up being higher than its associated session timeout. The notion
+ * of staleness is configurable, @see Request for more details.
+ *
+ * To ensure ordering guarantees, if a request is ever dropped from a connection
+ * that connection is closed and flagged as invalid. All subsequent requests
+ * inflight from that connection are then dropped as well.
+ */
+public class RequestThrottler extends ZooKeeperCriticalThread {
+    private static final Logger LOG = LoggerFactory.getLogger(RequestThrottler.class);
+
+    private final LinkedBlockingQueue<Request> submittedRequests =
+        new LinkedBlockingQueue<Request>();
+
+    private final ZooKeeperServer zks;
+    private volatile boolean stopping;
+    private volatile boolean killed;
+
+    /**
+     * enabled can only be set via system properties and not at runtime to
+     * ensure requests are never sent sometimes to the RequestThrottler and
+     * other times directly to a request processor, thus potentially reodering
+     * requests.
+     *
+     * This setting is designed as a code kill switch. In normal operation,
+     * enabled should be set to true. When enabled, maxRequests can be adjusted
+     * to enable/disable throttling at runtime.
+     */
+    private static final boolean enabled =
+        ZooKeeperServer.getBooleanProp(""zookeeper.request_throttle"", true);
+
+    /**
+     * The total number of outstanding requests allowed before the throttler
+     * starts stalling.
+     *
+     * When maxRequests = 0, throttling is disabled.
+     */
+    private static volatile int maxRequests =
+        Integer.getInteger(""zookeeper.request_throttle_max_requests"", 0);
+
+    /**
+     * The time (in milliseconds) this is the maximum time for which throttler
+     * thread may wait to be notified that it may proceed processing a request.
+     */
+    private static volatile int stallTime =
+        Integer.getInteger(""zookeeper.request_throttle_stall_time"", 100);
+
+    /**
+     * When true, the throttler will drop stale requests rather than issue
+     * them to the request pipeline. A stale request is a request sent by
+     * a connection that is now closed, and/or a request that will have a
+     * request latency higher than the sessionTimeout. The staleness of
+     * a request is tunable property, @see Request for details.
+     */
+    private static volatile boolean dropStaleRequests =
+        ZooKeeperServer.getBooleanProp(""zookeeper.request_throttle_drop_stale"", true);
+
+    public RequestThrottler(ZooKeeperServer zks) {
+        super(""RequestThrottler"", zks.getZooKeeperServerListener());
+        this.zks = zks;
+        this.stopping = false;
+        this.killed = false;
+    }
+
+    public static int getMaxRequests() {
+        return maxRequests;
+    }
+
+    public static void setMaxRequests(int requests) {
+        maxRequests = requests;
+    }
+
+    public static int getStallTime() {
+        return stallTime;
+    }
+
+    public static void setStallTime(int time) {
+        stallTime = time;
+    }
+
+    public static boolean getDropStaleRequests() {
+        return dropStaleRequests;
+    }
+
+    public static void setDropStaleRequests(boolean drop) {
+        dropStaleRequests = drop;
+    }
+
+    public static boolean enabled() {
+        return enabled;
+    }
+
+    @Override
+    public void run() {
+        try {
+            while (true) {
+                Request request = submittedRequests.take();
+                if (Request.requestOfDeath == request) {
+                    break;
+                }
+
+                if (request.mustDrop()) {
+                    continue;
+                }
+
+                // Throttling is disabled when maxRequests = 0
+                if (maxRequests > 0) {
+                    while (!killed) {
+                        if (dropStaleRequests && request.isStale()) {
+                            // Note: this will close the connection
+                            dropRequest(request);
+                            ServerMetrics.getMetrics().STALE_REQUESTS_DROPPED.add(1);
+                            request = null;
+                            break;
+                        }
+                        if (zks.getInProcess() < maxRequests) {
+                            break;
+                        }
+                        throttleSleep(stallTime);
+                    }
+                }
+
+                if (killed) {
+                    break;
+                }
+
+                // A dropped stale request will be null
+                if (request != null) {
+                    if (request.isStale()) {
+                        ServerMetrics.getMetrics().STALE_REQUESTS.add(1);
+                    }
+                    zks.submitRequestNow(request);
+                }
+            }
+        } catch (InterruptedException e) {
+            LOG.error(""Unexpected interruption"", e);
+        }
+        int dropped = drainQueue();
+        LOG.info(""RequestThrottler shutdown. Dropped "" + dropped + "" requests"");
+    }
+
+    private synchronized void throttleSleep(int stallTime) {
+        try {
+            ServerMetrics.getMetrics().REQUEST_THROTTLE_WAIT_COUNT.add(1);
+            this.wait(stallTime);
+        } catch(InterruptedException ie) {
+            return;
+        }
+    }
+
+    @SuppressFBWarnings(value = ""NN_NAKED_NOTIFY"",
+            justification = ""state change is in ZooKeeperServer.decInProgress() "")
+    public synchronized void throttleWake() {
+        this.notify();
+    }
+
+    private int drainQueue() {
+        // If the throttler shutdown gracefully, the queue will be empty.
+        // However, if the shutdown time limit was reached and the throttler
+        // was killed, we have no other option than to drop all remaining
+        // requests on the floor.
+        int dropped = 0;
+        Request request;
+        LOG.info(""Draining request throttler queue"");
+        while ((request = submittedRequests.poll()) != null) {
+            dropped += 1;
+            dropRequest(request);
+        }
+        return dropped;
+    }
+
+    private void dropRequest(Request request) {
+        // Since we're dropping a request on the floor, we must mark the
+        // connection as invalid to ensure any future requests from this
+        // connection are also dropped in order to ensure ordering
+        // semantics.
+        ServerCnxn conn = request.getConnection();
+        if (conn != null) {
+            // Note: this will close the connection
+            conn.setInvalid();
+        }
+    }
+
+    public void submitRequest(Request request) {
+        if (stopping) {
+            LOG.debug(""Shutdown in progress. Request cannot be processed"");
+            dropRequest(request);
+        }
+        else {
+            submittedRequests.add(request);
+        }
+    }
+
+    public int getInflight() {
+        return submittedRequests.size();
+    }
+
+    @SuppressFBWarnings(""DM_EXIT"")
+    public void shutdown() {
+        // Try to shutdown gracefully
+        LOG.info(""Shutting down"");
+        stopping = true;
+        submittedRequests.add(Request.requestOfDeath);
+        try {
+            this.join(ZooKeeperServer.getShutdownTimeout());
+        } catch (InterruptedException e) {
+            LOG.warn(""Interrupted while waiting for {} to finish"", this);
+        }
+
+        // Forcibly shutdown if necessary in order to ensure request
+        // queue is drained.
+        killed = true;
+        try {
+            this.join();
+        } catch (InterruptedException e) {
+            LOG.warn(""Interrupted while waiting for {} to finish"", this);
+            //TODO apply ZOOKEEPER-575 and remove this line.
+            System.exit(1);","[{'comment': 'nit: use `org.apache.zookeeper.server.ExitCode`', 'commenter': 'hanm'}, {'comment': 'done', 'commenter': 'jhuan31'}]"
986,zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerCnxn.java,"@@ -82,6 +80,22 @@ public ServerCnxn(final ZooKeeperServer zkServer) {
         this.zkServer = zkServer;
     }
 
+    /**
+     * Flag that indicates that this connection is known to be closed/closing
+     * and from which we can optionally ignore outstanding requests as part
+     * of request throttling. This flag may be false when a connection is
+     * actually closed (false negative), but should never be true with
+     * a connection is still alive (false positive).","[{'comment': ""This makes sense, though I've seen weird states of heap dumps where connections were set as stale but not closed (aka stale but alive - false positive). Unfortunately I was unable to reproduce this or identify the code culprit. All I am saying is to be cautious on relying the stale flag inside the server connection object..."", 'commenter': 'hanm'}, {'comment': 'Thanks for sharing your finding. It seems working for us so far. Will keep an eye one it.', 'commenter': 'jhuan31'}]"
986,zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerCnxn.java,"@@ -229,6 +243,19 @@ public void setStale() {
         stale = true;
     }
 
+    public boolean isInvalid() {
+        return invalid;
+    }
+
+    public void setInvalid() {
+        if (!invalid) {
+            if (!stale) {","[{'comment': ""see my comments above on the stale checking... might worth considering close regardless of stale or not (not feeling strong about this, as i can't prove anything here)."", 'commenter': 'hanm'}, {'comment': 'This is a tricky one. We went through the code and had a discussion.  We\'re not sure whether calling sendCloseSession() when stale is set could help solve the ""false positive"" you saw--setStale() is only called from the close() function so closing must have been initiated already when stale is set. We do come up with an alternative solution: instead of calling sendCloseSession() in setInvalid(), we could call sendCloseSession() when dropping a request and set the invalid flag within sendCloseSession() so we could make sure that close connection is sent to the client. This solution seems simple and *should* work but it is not tested. The current implementation has been in production for 2+ years so we\'re inclined to stay put. What do you think?   ', 'commenter': 'jhuan31'}, {'comment': ""Let's stick with current battle tested solution (no change is needed to current patch)."", 'commenter': 'hanm'}]"
986,zookeeper-server/src/main/java/org/apache/zookeeper/server/RequestThrottler.java,"@@ -0,0 +1,273 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.util.concurrent.LinkedBlockingQueue;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.zookeeper.common.Time;
+
+/**
+ * When enabled, the RequestThrottler limits the number of outstanding requests
+ * currently submitted to the request processor pipeline. The throttler augments
+ * the limit imposed by the <code>globalOutstandingLimit</code> that is enforced
+ * by the connection layer ({@link NIOServerCnxn}, {@link NettyServerCnxn}).
+ *
+ * The connection layer limit applies backpressure against the TCP connection by
+ * disabling selection on connections once the request limit is reached. However,
+ * the connection layer always allows a connection to send at least one request
+ * before disabling selection on that connection. Thus, in a scenario with 40000
+ * client connections, the total number of requests inflight may be as high as
+ * 40000 even if the <code>globalOustandingLimit</code> was set lower.
+ *
+ * The RequestThrottler addresses this issue by adding additional queueing. When
+ * enabled, client connections no longer submit requests directly to the request
+ * processor pipeline but instead to the RequestThrottler. The RequestThrottler
+ * is then responsible for issuing requests to the request processors, and
+ * enforces a separate <code>maxRequests</code> limit. If the total number of
+ * outstanding requests is higher than <code>maxRequests</code>, the throttler
+ * will continually stall for <code>stallTime</code> milliseconds until
+ * underlimit.
+ *
+ * The RequestThrottler can also optionally drop stale requests rather than
+ * submit them to the processor pipeline. A stale request is a request sent
+ * by a connection that is already closed, and/or a request whose latency
+ * will end up being higher than its associated session timeout. The notion
+ * of staleness is configurable, @see Request for more details.
+ *
+ * To ensure ordering guarantees, if a request is ever dropped from a connection
+ * that connection is closed and flagged as invalid. All subsequent requests
+ * inflight from that connection are then dropped as well.
+ */
+public class RequestThrottler extends ZooKeeperCriticalThread {
+    private static final Logger LOG = LoggerFactory.getLogger(RequestThrottler.class);
+
+    private final LinkedBlockingQueue<Request> submittedRequests =
+        new LinkedBlockingQueue<Request>();
+
+    private final ZooKeeperServer zks;
+    private volatile boolean stopping;
+    private volatile boolean killed;
+
+    /**
+     * enabled can only be set via system properties and not at runtime to
+     * ensure requests are never sent sometimes to the RequestThrottler and
+     * other times directly to a request processor, thus potentially reodering
+     * requests.
+     *
+     * This setting is designed as a code kill switch. In normal operation,
+     * enabled should be set to true. When enabled, maxRequests can be adjusted
+     * to enable/disable throttling at runtime.
+     */
+    private static final boolean enabled =
+        ZooKeeperServer.getBooleanProp(""zookeeper.request_throttle"", true);
+
+    /**
+     * The total number of outstanding requests allowed before the throttler
+     * starts stalling.
+     *
+     * When maxRequests = 0, throttling is disabled.
+     */
+    private static volatile int maxRequests =
+        Integer.getInteger(""zookeeper.request_throttle_max_requests"", 0);
+
+    /**
+     * The time (in milliseconds) this is the maximum time for which throttler
+     * thread may wait to be notified that it may proceed processing a request.
+     */
+    private static volatile int stallTime =
+        Integer.getInteger(""zookeeper.request_throttle_stall_time"", 100);
+
+    /**
+     * When true, the throttler will drop stale requests rather than issue
+     * them to the request pipeline. A stale request is a request sent by
+     * a connection that is now closed, and/or a request that will have a
+     * request latency higher than the sessionTimeout. The staleness of
+     * a request is tunable property, @see Request for details.
+     */
+    private static volatile boolean dropStaleRequests =
+        ZooKeeperServer.getBooleanProp(""zookeeper.request_throttle_drop_stale"", true);
+
+    public RequestThrottler(ZooKeeperServer zks) {
+        super(""RequestThrottler"", zks.getZooKeeperServerListener());
+        this.zks = zks;
+        this.stopping = false;
+        this.killed = false;
+    }
+
+    public static int getMaxRequests() {
+        return maxRequests;
+    }
+
+    public static void setMaxRequests(int requests) {
+        maxRequests = requests;
+    }
+
+    public static int getStallTime() {
+        return stallTime;
+    }
+
+    public static void setStallTime(int time) {
+        stallTime = time;
+    }
+
+    public static boolean getDropStaleRequests() {
+        return dropStaleRequests;
+    }
+
+    public static void setDropStaleRequests(boolean drop) {
+        dropStaleRequests = drop;
+    }
+
+    public static boolean enabled() {
+        return enabled;
+    }
+
+    @Override
+    public void run() {
+        try {
+            while (true) {
+                Request request = submittedRequests.take();
+                if (Request.requestOfDeath == request) {
+                    break;
+                }
+
+                if (request.mustDrop()) {
+                    continue;
+                }
+
+                // Throttling is disabled when maxRequests = 0
+                if (maxRequests > 0) {
+                    while (!killed) {
+                        if (dropStaleRequests && request.isStale()) {
+                            // Note: this will close the connection
+                            dropRequest(request);
+                            ServerMetrics.getMetrics().STALE_REQUESTS_DROPPED.add(1);
+                            request = null;
+                            break;
+                        }
+                        if (zks.getInProcess() < maxRequests) {
+                            break;
+                        }
+                        throttleSleep(stallTime);
+                    }
+                }
+
+                if (killed) {","[{'comment': ""this could be elevated to the top of the first while block, so we can break early and start draining the queue sooner. consider one case - we have a big queue of submitted requests and most of them must be dropped. If we leave the check here, we'll not break the loop until processing the last request (the request of death.)."", 'commenter': 'hanm'}, {'comment': ""The check for killed is also in the inner while loop for each request in the queue. \r\nSo it won't delay the shutdown. "", 'commenter': 'jhuan31'}, {'comment': 'Assume while we are shutting down (`kill` is set to true), we have a large queue of requests, where each request is stale and must be dropped. With current code, the outer most `while (true) {` loop will try loop through every request in the queue, because L145 `if (request.mustDrop()) {` is evaluated as true for every request (which is stale). In this case, the check for `killed` in the inner while loop will not get executed. This was the reason I was suggesting to move the `if (killed) {` check before the `if (request.mustDrop()) {`.\r\n\r\nDoes this example make sense? Albeit this example somewhat hypothetical, having `if (killed) {` check earlier sounds no harm either.', 'commenter': 'hanm'}]"
986,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -98,6 +98,14 @@
         Environment.logEnv(""Server environment:"", LOG);
     }
 
+    private static final String SHUTDOWN_TIMEOUT = ""zookeeper.shutdownTimeout"";
+    private static int shutdownTimeout = 10000;
+
+    static {
+        shutdownTimeout = Integer.getInteger(SHUTDOWN_TIMEOUT, 10000);
+        LOG.info(SHUTDOWN_TIMEOUT + ""="" + shutdownTimeout);
+    }
+","[{'comment': 'it would be good to refactor this code a little bit, by moving all static constants and property definition to a single place and consolidate all static initializer block into a single block (instead of 3).', 'commenter': 'hanm'}, {'comment': 'this has been moved to RequestThrottler', 'commenter': 'jhuan31'}]"
986,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -735,12 +764,30 @@ public void incInProcess() {
 
     public void decInProcess() {
         requestsInProcess.decrementAndGet();
+        if (requestThrottler != null) {
+            requestThrottler.throttleWake();
+        }
     }
 
     public int getInProcess() {
         return requestsInProcess.get();
     }
 
+    public int getInflight() {
+        if (RequestThrottler.enabled()) {
+            return requestThrottleInflight();
+        } else {
+            return getInProcess();
+        }
+    }
+
+    public int requestThrottleInflight() {","[{'comment': ""consider make this private as it's not called elsewhere. "", 'commenter': 'hanm'}, {'comment': 'done', 'commenter': 'jhuan31'}]"
986,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -910,6 +957,36 @@ protected void setLocalSessionFlag(Request si) {
     }
 
     public void submitRequest(Request si) {
+        if (RequestThrottler.enabled()) {
+            enqueueRequest(si);
+        } else {
+            submitRequestNow(si);
+        }
+    }
+
+    public void enqueueRequest(Request si) {
+        if (requestThrottler == null) {
+            synchronized (this) {
+                try {
+                    // Since all requests are passed to the request
+                    // processor it should wait for setting up the request
+                    // processor chain. The state will be updated to RUNNING
+                    // after the setup.
+                    while (state == State.INITIAL) {
+                        wait(1000);","[{'comment': '1 sec feels a little bit ... longer. How did we decide this value? Should it be configurable?', 'commenter': 'hanm'}, {'comment': 'this is not invented in this patch :) it has been in the ZooKeeperServer to wait for the request pipeline to start up. We just copy/paste it.', 'commenter': 'jhuan31'}]"
986,zookeeper-server/src/main/java/org/apache/zookeeper/server/RequestThrottler.java,"@@ -0,0 +1,273 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.util.concurrent.LinkedBlockingQueue;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.zookeeper.common.Time;
+
+/**
+ * When enabled, the RequestThrottler limits the number of outstanding requests
+ * currently submitted to the request processor pipeline. The throttler augments
+ * the limit imposed by the <code>globalOutstandingLimit</code> that is enforced
+ * by the connection layer ({@link NIOServerCnxn}, {@link NettyServerCnxn}).
+ *
+ * The connection layer limit applies backpressure against the TCP connection by
+ * disabling selection on connections once the request limit is reached. However,
+ * the connection layer always allows a connection to send at least one request
+ * before disabling selection on that connection. Thus, in a scenario with 40000
+ * client connections, the total number of requests inflight may be as high as
+ * 40000 even if the <code>globalOustandingLimit</code> was set lower.
+ *
+ * The RequestThrottler addresses this issue by adding additional queueing. When
+ * enabled, client connections no longer submit requests directly to the request
+ * processor pipeline but instead to the RequestThrottler. The RequestThrottler
+ * is then responsible for issuing requests to the request processors, and
+ * enforces a separate <code>maxRequests</code> limit. If the total number of
+ * outstanding requests is higher than <code>maxRequests</code>, the throttler
+ * will continually stall for <code>stallTime</code> milliseconds until
+ * underlimit.
+ *
+ * The RequestThrottler can also optionally drop stale requests rather than
+ * submit them to the processor pipeline. A stale request is a request sent
+ * by a connection that is already closed, and/or a request whose latency
+ * will end up being higher than its associated session timeout. The notion
+ * of staleness is configurable, @see Request for more details.
+ *
+ * To ensure ordering guarantees, if a request is ever dropped from a connection
+ * that connection is closed and flagged as invalid. All subsequent requests
+ * inflight from that connection are then dropped as well.
+ */
+public class RequestThrottler extends ZooKeeperCriticalThread {
+    private static final Logger LOG = LoggerFactory.getLogger(RequestThrottler.class);
+
+    private final LinkedBlockingQueue<Request> submittedRequests =","[{'comment': 'It seems that this is unbounded - the requests submitted is bound by the max request, but this queue is not explicitly enforced in terms of the maximum items it could store. One concern is in case of too many requests coming in and this will first unconditionally queuing the requests - would this potentially lead to memory / GC issue on the server?', 'commenter': 'hanm'}, {'comment': 'this is supposed to be guarded by globalOutstandingLimit. ', 'commenter': 'jhuan31'}, {'comment': 'Could you please point me to the code where the `globalOutstandingLimit` or `maxRequests` controls enqueuing requests to `RequestThrottler `?  It seems to me that an incoming request will be unconditionally queued at `RequestThrottler `. An incoming request will first hit `ZooKeeperServer.submitRequest `, which calls `enqueueRequest `, which calls `requestThrottler.submitRequest`, which do unconditional queuing via `submittedRequests.add(request);`.', 'commenter': 'hanm'}, {'comment': 'To answer my own question - the `ZooKeeperServer.submitRequest` is called from `ZooKeeperServer.processPacket` where the `shouldThrottle` was checked against `globalOutstandingLimit`... ', 'commenter': 'hanm'}]"
989,zookeeper-server/src/test/java/org/apache/zookeeper/server/util/RequestPathMetricsCollectorTest.java,"@@ -0,0 +1,457 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Assert;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.apache.zookeeper.ZooDefs.OpCode.create;
+import static org.apache.zookeeper.ZooDefs.OpCode.create2;
+import static org.apache.zookeeper.ZooDefs.OpCode.delete;
+import static org.apache.zookeeper.ZooDefs.OpCode.exists;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren2;
+import static org.apache.zookeeper.ZooDefs.OpCode.getData;
+import static org.apache.zookeeper.ZooDefs.OpCode.setData;
+
+public class RequestPathMetricsCollectorTest {
+    public RequestPathMetricsCollectorTest() {
+        //tune the request metrics receiver parameters
+        System.setProperty(""zookeeper.pathStats.slotCapacity"", ""60"");","[{'comment': 'please init in a @Before method and clear the properties in a @After method', 'commenter': 'eolivelli'}]"
989,zookeeper-server/src/test/java/org/apache/zookeeper/server/util/RequestPathMetricsCollectorTest.java,"@@ -0,0 +1,457 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Assert;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.apache.zookeeper.ZooDefs.OpCode.create;
+import static org.apache.zookeeper.ZooDefs.OpCode.create2;
+import static org.apache.zookeeper.ZooDefs.OpCode.delete;
+import static org.apache.zookeeper.ZooDefs.OpCode.exists;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren2;
+import static org.apache.zookeeper.ZooDefs.OpCode.getData;
+import static org.apache.zookeeper.ZooDefs.OpCode.setData;
+
+public class RequestPathMetricsCollectorTest {
+    public RequestPathMetricsCollectorTest() {
+        //tune the request metrics receiver parameters
+        System.setProperty(""zookeeper.pathStats.slotCapacity"", ""60"");
+        System.setProperty(""zookeeper.pathStats.slotDuration"", ""1"");
+        System.setProperty(""zookeeper.pathStats.maxDepth"", ""6"");
+        System.setProperty(""zookeeper.pathStats.sampleRate"", ""1.0"");
+    }
+
+    @Test
+    public void testTrimPath() {
+        //normal cases
+        String trimedPath = RequestPathMetricsCollector.trimPathDepth(""/p1/p2/p3"", 1);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""/p1/p2/p3"", 2);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1/p2""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""/p1/p2/p3"", 3);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1/p2/p3""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""/p1/p2/p3"", 4);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1/p2/p3""));
+        //some extra symbols
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""//p1 next/p2.index/p3:next"",
+            3);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1 next/p2.index/p3:next""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""//p1 next/p2.index/p3:next"",
+            2);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1 next/p2.index""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""//p1 next/p2.index/p3:next"",
+            6);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1 next/p2.index/p3:next""));
+    }
+
+    @Test
+    public void testQueueMapReduce() throws InterruptedException {
+        RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();
+        RequestPathMetricsCollector.PathStatsQueue pathStatsQueue =
+            requestPathMetricsCollector.new PathStatsQueue(create2);
+        Thread path7 = new Thread(() -> {
+            for (int i = 0; i < 1000000; i++) {
+                pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5/path6/path7"" +
+                    ""_"" + i);
+            }
+        });
+        path7.start();
+        Thread path6 = new Thread(() -> {
+            pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5/path6"");
+            for(int i = 1; i < 100000; i++) {
+                pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5/path6""+""_""+i);
+            }
+        });
+        path6.start();
+        for(int i = 0; i < 1; i++) {
+            pathStatsQueue.registerRequest(""/path1"");
+        }
+        for(int i = 0; i < 10; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2""+""_""+i);
+        }
+        for(int i = 0; i < 100; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2/path3""+""_""+i);
+        }
+        for(int i = 0; i < 1000; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2/path3/path4""+""_""+i);
+        }
+        for(int i = 0; i < 10000; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5""+""_""+i);
+        }
+        path6.join();
+        path7.join();
+        Map<String, Integer> newSlot = pathStatsQueue.mapReducePaths(1,
+            pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 1);
+        Assert.assertTrue(newSlot.get(""/path1"").compareTo(1111111) == 0);
+        //cut up to 2
+        newSlot = pathStatsQueue.mapReducePaths(2, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 12);
+        Assert.assertTrue(newSlot.get(""/path1"").compareTo(1) == 0);
+        Assert.assertTrue(newSlot.get(""/path1/path2"").compareTo(1111100) == 0);
+        //cut up to 3
+        newSlot = pathStatsQueue.mapReducePaths(3, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 112);
+        Assert.assertTrue(newSlot.get(""/path1"").compareTo(1) == 0);
+        Assert.assertTrue(newSlot.get(""/path1/path2/path3"").compareTo(1111000) == 0);
+        //cut up to 4
+        newSlot = pathStatsQueue.mapReducePaths(4, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 1112);
+        Assert.assertTrue(newSlot.get(""/path1/path2/path3/path4"").compareTo(1110000) == 0);
+        //cut up to 5
+        newSlot = pathStatsQueue.mapReducePaths(5, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 11112);
+        Assert.assertTrue(newSlot.get(""/path1/path2/path3/path4/path5"").compareTo(1100000) == 0);
+        //cut up to 6
+        newSlot = pathStatsQueue.mapReducePaths(6, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 111111);
+        Assert.assertTrue(newSlot.get(""/path1/path2/path3/path4/path5/path6"").compareTo(1000001) == 0);
+        //cut up to 7
+        newSlot = pathStatsQueue.mapReducePaths(7, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 1111111);
+    }
+
+    @Test
+    public void testCollectEmptyStats() throws InterruptedException {
+        RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();
+        RequestPathMetricsCollector.PathStatsQueue pathStatsQueue =
+            requestPathMetricsCollector.new PathStatsQueue(getChildren);
+        Thread.sleep(5000);
+        Map<String, Integer> newSlot = pathStatsQueue.mapReducePaths(3,
+            pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.isEmpty());
+        pathStatsQueue.start();
+        Thread.sleep(15000);
+        newSlot = pathStatsQueue.collectStats(1);
+        Assert.assertTrue(newSlot.size() == 0);
+        newSlot = pathStatsQueue.collectStats(2);
+        Assert.assertTrue(newSlot.size() == 0);
+        newSlot = pathStatsQueue.collectStats(5);
+        Assert.assertTrue(newSlot.size() == 0);
+    }
+    
+    @Ignore
+    @Test
+    public void testCollectStats() throws InterruptedException {
+        RequestPathMetricsCollector requestPathMetricsCollector =
+            new RequestPathMetricsCollector(true);
+        RequestPathMetricsCollector.PathStatsQueue pathStatsQueue =
+            requestPathMetricsCollector.new PathStatsQueue(getChildren);
+        pathStatsQueue.start();
+        Thread path7 = new Thread(() -> {
+            for(int i = 0; i < 10; i++) {
+                try {
+                    Thread.sleep(100);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+                for (int j = 0; j < 100000; j++) {
+                    pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5/path6/path7""
+                        + ""_"" + i + ""_"" + j);
+                }
+            }
+        });
+        path7.start();
+        Thread path6 = new Thread(() -> {
+            pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5/path6"");
+            for(int i = 0; i < 10; i++) {
+                try {
+                    Thread.sleep(1000);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+                for (int j = 0; j < 10000; j++) {
+                    pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5/path6""
+                        + ""_"" + i + ""_"" + j);
+                }
+            }
+        });
+        path6.start();
+        for(int i = 0; i < 1; i++) {
+            pathStatsQueue.registerRequest(""/path1"");
+        }        
+        for(int i = 0; i < 10; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2""+""_""+i);
+        }
+        for(int i = 0; i < 100; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2/path3""+""_""+i);
+        }
+        for(int i = 0; i < 1000; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2/path3/path4""+""_""+i);
+        }
+        try {
+            Thread.sleep(1000);
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+        for(int i = 0; i < 10000; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5""+""_""+i);
+        }
+        path6.join();
+        path7.join();
+        Map<String, Integer> newSlot = pathStatsQueue.collectStats(1);
+        Assert.assertEquals(newSlot.size(), 1);
+        Assert.assertEquals(newSlot.get(""/path1"").intValue(), 1111112);
+        //cut up to 2
+        newSlot = pathStatsQueue.collectStats(2);
+        Assert.assertEquals(newSlot.size(), 12);
+        Assert.assertEquals(newSlot.get(""/path1"").intValue(), 1);
+        Assert.assertEquals(newSlot.get(""/path1/path2"").intValue(), 1111101);
+        //cut up to 3
+        newSlot = pathStatsQueue.collectStats(3);
+        Assert.assertEquals(newSlot.size(), 112);
+        Assert.assertEquals(newSlot.get(""/path1"").intValue(), 1);
+        Assert.assertEquals(newSlot.get(""/path1/path2/path3"").intValue(), 1111001);
+        //cut up to 4
+        newSlot = pathStatsQueue.collectStats(4);
+        Assert.assertEquals(newSlot.size(), 1112);
+        Assert.assertEquals(newSlot.get(""/path1/path2/path3/path4"").intValue(), 1110001);
+        //cut up to 5
+        newSlot = pathStatsQueue.collectStats(5);
+        Assert.assertEquals(newSlot.size(), 11112);
+        Assert.assertEquals(newSlot.get(""/path1/path2/path3/path4/path5"").intValue(), 1100001);
+        //cut up to 6
+        newSlot = pathStatsQueue.collectStats(6);
+        Assert.assertEquals(newSlot.size(), 111112);
+        Assert.assertEquals(newSlot.get(""/path1/path2/path3/path4/path5/path6"").intValue(),
+            1000001);
+        //cut up to 7 but the initial mapReduce kept only 6
+        newSlot = pathStatsQueue.collectStats(7);
+        Assert.assertEquals(newSlot.size(), 111112);
+        Assert.assertEquals(newSlot.get(""/path1/path2/path3/path4/path5/path6"").intValue(),
+            1000001);
+    }
+    
+    @Test
+    public void testAggregate() throws InterruptedException {
+        RequestPathMetricsCollector requestPathMetricsCollector =
+            new RequestPathMetricsCollector(true);
+        Thread path7 = new Thread(() -> {
+            for(int i = 0; i < 10; i++) {
+                try {
+                    Thread.sleep(100);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+                for (int j = 0; j < 100000; j++) {
+                    requestPathMetricsCollector.registerRequest(getData,
+                        ""/path1/path2/path3/path4/path5/path6/path7"" + ""_"" + i + ""_"" + j);
+                }
+            }
+        });
+        path7.start();
+        Thread path6 = new Thread(() -> {
+            requestPathMetricsCollector.registerRequest(getChildren2,
+                ""/path1/path2/path3/path4/path5/path6"");
+            for(int i = 0; i < 10; i++) {
+                try {
+                    Thread.sleep(1000);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+                for (int j = 0; j < 10000; j++) {
+                    requestPathMetricsCollector.registerRequest(getChildren,
+                        ""/path1/path2/path3/path4/path5/path6"" + ""_"" + i + ""_"" + j);
+                }
+            }
+        });
+        path6.start();
+        for(int i = 0; i < 1; i++) {
+            requestPathMetricsCollector.registerRequest(create2,
+                ""/path1"");
+        }
+        for(int i = 0; i < 10; i++) {
+            requestPathMetricsCollector.registerRequest(create,
+                ""/path1/path2""+""_""+i);
+        }
+        for(int i = 0; i < 100; i++) {
+            requestPathMetricsCollector.registerRequest(delete,
+                ""/path1/path2/path3""+""_""+i);
+        }
+        for(int i = 0; i < 1000; i++) {
+            requestPathMetricsCollector.registerRequest(setData,
+                ""/path1/path2/path3/path4""+""_""+i);
+        }
+        for(int i = 0; i < 10000; i++) {
+            requestPathMetricsCollector.registerRequest(exists,
+                ""/path1/path2/path3/path4/path5""+""_""+i);
+        }
+        path6.join();
+        path7.join();
+        Map<String, Integer> newSlot = requestPathMetricsCollector.aggregatePaths(2,
+            queue -> true);
+        Assert.assertEquals(newSlot.size(), 12);
+        Assert.assertEquals(newSlot.get(""/path1"").intValue(), 1);
+        Assert.assertEquals(newSlot.get(""/path1/path2"").intValue(), 1111101);
+        //cut up to 3
+        newSlot = requestPathMetricsCollector.aggregatePaths(3, queue -> true);
+        Assert.assertEquals(newSlot.size(), 112);
+        Assert.assertEquals(newSlot.get(""/path1"").intValue(), 1);
+        Assert.assertEquals(newSlot.get(""/path1/path2/path3"").intValue(), 1111001);
+        //cut up to 4
+        newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> true);
+        Assert.assertEquals(newSlot.size(), 1112);
+        Assert.assertEquals(newSlot.get(""/path1/path2/path3/path4"").intValue(), 1110001);
+        //cut up to 5
+        newSlot = requestPathMetricsCollector.aggregatePaths(5, queue -> true);
+        Assert.assertEquals(newSlot.size(), 11112);
+        Assert.assertEquals(newSlot.get(""/path1/path2/path3/path4/path5"").intValue(), 1100001);
+        //cut up to 6
+        newSlot = requestPathMetricsCollector.aggregatePaths(6, queue -> true);
+        Assert.assertEquals(newSlot.size(), 111112);
+        Assert.assertEquals(newSlot.get(""/path1/path2/path3/path4/path5/path6"").intValue(), 1000001);
+        //cut up to 7 but the initial mapReduce kept only 6
+        newSlot = requestPathMetricsCollector.aggregatePaths(7, queue -> true);
+        Assert.assertEquals(newSlot.size(), 111112);
+        Assert.assertEquals(newSlot.get(""/path1/path2/path3/path4/path5/path6"").intValue(), 1000001);
+        //test predicate
+        //cut up to 4 for all the reads
+        newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> !queue.isWriteOperation());
+        Assert.assertEquals(newSlot.size(), 1);
+        Assert.assertEquals(newSlot.get(""/path1/path2/path3/path4"").intValue(), 1110001);
+        //cut up to 4 for all the write
+        newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> queue.isWriteOperation());
+        Assert.assertEquals(newSlot.size(), 1111);
+        //cut up to 3 for all the write
+        newSlot = requestPathMetricsCollector.aggregatePaths(3, queue -> queue.isWriteOperation());
+        Assert.assertEquals(newSlot.size(), 112);
+        Assert.assertEquals(newSlot.get(""/path1/path2/path3"").intValue(), 1000);
+    }
+
+    @Test
+    public void testTopPath() throws InterruptedException {
+        RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector(true);
+        Thread path7 = new Thread(() -> {
+            for(int i = 0; i < 10; i++) {
+                try {
+                    Thread.sleep(100);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+                for (int j = 0; j < 100000; j++) {
+                    requestPathMetricsCollector.registerRequest(getData,
+                        ""/path1/path2/path3/path4/path5/path6/path7"" + ""_"" + i + ""_"" + j);
+                }
+            }
+        });
+        path7.start();
+        Thread path6 = new Thread(() -> {
+            requestPathMetricsCollector.registerRequest(getChildren2,
+                ""/path1/path2/path3/path4/path5/path6"");
+            for(int i = 0; i < 10; i++) {
+                try {
+                    Thread.sleep(1000);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+                for (int j = 0; j < 10000; j++) {
+                    requestPathMetricsCollector.registerRequest(getChildren,
+                        ""/path1/path2/path3/path4/path5/path6"" + ""_"" + i + ""_"" + j);
+                }
+            }
+        });
+        path6.start();
+        for(int i = 0; i < 1; i++) {
+            requestPathMetricsCollector.registerRequest(create2,
+                ""/path1"");
+        }
+        for(int i = 0; i < 10; i++) {
+            requestPathMetricsCollector.registerRequest(create,
+                ""/path1/path2""+""_""+i);
+        }
+        for(int i = 0; i < 100; i++) {
+            requestPathMetricsCollector.registerRequest(delete,
+                ""/path1/path2/path3""+""_""+i);
+        }
+        for(int i = 0; i < 1000; i++) {
+            requestPathMetricsCollector.registerRequest(setData,
+                ""/path1/path2/path3/path4""+""_""+i);
+        }
+        for(int i = 0; i < 10000; i++) {
+            requestPathMetricsCollector.registerRequest(exists,
+                ""/path1/path2/path3/path4/path5""+""_""+i);
+        }
+        path6.join();
+        path7.join();
+        StringBuilder sb1= new StringBuilder();
+        Map<String, Integer> newSlot = requestPathMetricsCollector.aggregatePaths(3,
+            queue -> queue.isWriteOperation());
+        requestPathMetricsCollector.logTopPaths(newSlot,
+            entry -> sb1.append(entry.getKey() + "" : "" + entry.getValue() + ""\n""));
+        Assert.assertTrue(sb1.toString().startsWith(""/path1/path2/path3 : 1000""));
+        StringBuilder sb2= new StringBuilder();
+        newSlot = requestPathMetricsCollector.aggregatePaths(3,
+            queue -> !queue.isWriteOperation());
+        requestPathMetricsCollector.logTopPaths(newSlot,
+            entry -> sb2.append(entry.getKey() + "" : "" + entry.getValue() + ""\n""));
+        Assert.assertTrue(sb2.toString().startsWith(""/path1/path2/path3 : 1110001""));
+        StringBuilder sb3= new StringBuilder();
+        newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> true);
+        requestPathMetricsCollector.logTopPaths(newSlot,
+            entry -> sb3.append(entry.getKey() + "" : "" + entry.getValue() + ""\n""));
+        Assert.assertTrue(sb3.toString().startsWith(""/path1/path2/path3/path4 : 1110001""));
+    }
+    
+    public void testMultiThreadPerf() throws InterruptedException {","[{'comment': 'this is not a @Test ?', 'commenter': 'eolivelli'}, {'comment': 'good catch. fixed.', 'commenter': 'hanm'}]"
989,zookeeper-server/src/test/java/org/apache/zookeeper/server/util/RequestPathMetricsCollectorTest.java,"@@ -0,0 +1,457 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Assert;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.apache.zookeeper.ZooDefs.OpCode.create;
+import static org.apache.zookeeper.ZooDefs.OpCode.create2;
+import static org.apache.zookeeper.ZooDefs.OpCode.delete;
+import static org.apache.zookeeper.ZooDefs.OpCode.exists;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren2;
+import static org.apache.zookeeper.ZooDefs.OpCode.getData;
+import static org.apache.zookeeper.ZooDefs.OpCode.setData;
+
+public class RequestPathMetricsCollectorTest {
+    public RequestPathMetricsCollectorTest() {
+        //tune the request metrics receiver parameters
+        System.setProperty(""zookeeper.pathStats.slotCapacity"", ""60"");
+        System.setProperty(""zookeeper.pathStats.slotDuration"", ""1"");
+        System.setProperty(""zookeeper.pathStats.maxDepth"", ""6"");
+        System.setProperty(""zookeeper.pathStats.sampleRate"", ""1.0"");
+    }
+
+    @Test
+    public void testTrimPath() {
+        //normal cases
+        String trimedPath = RequestPathMetricsCollector.trimPathDepth(""/p1/p2/p3"", 1);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""/p1/p2/p3"", 2);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1/p2""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""/p1/p2/p3"", 3);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1/p2/p3""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""/p1/p2/p3"", 4);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1/p2/p3""));
+        //some extra symbols
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""//p1 next/p2.index/p3:next"",
+            3);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1 next/p2.index/p3:next""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""//p1 next/p2.index/p3:next"",
+            2);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1 next/p2.index""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""//p1 next/p2.index/p3:next"",
+            6);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1 next/p2.index/p3:next""));
+    }
+
+    @Test
+    public void testQueueMapReduce() throws InterruptedException {
+        RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();
+        RequestPathMetricsCollector.PathStatsQueue pathStatsQueue =
+            requestPathMetricsCollector.new PathStatsQueue(create2);
+        Thread path7 = new Thread(() -> {
+            for (int i = 0; i < 1000000; i++) {
+                pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5/path6/path7"" +
+                    ""_"" + i);
+            }
+        });
+        path7.start();
+        Thread path6 = new Thread(() -> {
+            pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5/path6"");
+            for(int i = 1; i < 100000; i++) {
+                pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5/path6""+""_""+i);
+            }
+        });
+        path6.start();
+        for(int i = 0; i < 1; i++) {
+            pathStatsQueue.registerRequest(""/path1"");
+        }
+        for(int i = 0; i < 10; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2""+""_""+i);
+        }
+        for(int i = 0; i < 100; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2/path3""+""_""+i);
+        }
+        for(int i = 0; i < 1000; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2/path3/path4""+""_""+i);
+        }
+        for(int i = 0; i < 10000; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5""+""_""+i);
+        }
+        path6.join();
+        path7.join();
+        Map<String, Integer> newSlot = pathStatsQueue.mapReducePaths(1,
+            pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 1);
+        Assert.assertTrue(newSlot.get(""/path1"").compareTo(1111111) == 0);
+        //cut up to 2
+        newSlot = pathStatsQueue.mapReducePaths(2, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 12);
+        Assert.assertTrue(newSlot.get(""/path1"").compareTo(1) == 0);
+        Assert.assertTrue(newSlot.get(""/path1/path2"").compareTo(1111100) == 0);
+        //cut up to 3
+        newSlot = pathStatsQueue.mapReducePaths(3, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 112);
+        Assert.assertTrue(newSlot.get(""/path1"").compareTo(1) == 0);
+        Assert.assertTrue(newSlot.get(""/path1/path2/path3"").compareTo(1111000) == 0);
+        //cut up to 4
+        newSlot = pathStatsQueue.mapReducePaths(4, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 1112);
+        Assert.assertTrue(newSlot.get(""/path1/path2/path3/path4"").compareTo(1110000) == 0);
+        //cut up to 5
+        newSlot = pathStatsQueue.mapReducePaths(5, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 11112);
+        Assert.assertTrue(newSlot.get(""/path1/path2/path3/path4/path5"").compareTo(1100000) == 0);
+        //cut up to 6
+        newSlot = pathStatsQueue.mapReducePaths(6, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 111111);
+        Assert.assertTrue(newSlot.get(""/path1/path2/path3/path4/path5/path6"").compareTo(1000001) == 0);
+        //cut up to 7
+        newSlot = pathStatsQueue.mapReducePaths(7, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 1111111);
+    }
+
+    @Test
+    public void testCollectEmptyStats() throws InterruptedException {
+        RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();
+        RequestPathMetricsCollector.PathStatsQueue pathStatsQueue =
+            requestPathMetricsCollector.new PathStatsQueue(getChildren);
+        Thread.sleep(5000);
+        Map<String, Integer> newSlot = pathStatsQueue.mapReducePaths(3,
+            pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.isEmpty());
+        pathStatsQueue.start();
+        Thread.sleep(15000);
+        newSlot = pathStatsQueue.collectStats(1);
+        Assert.assertTrue(newSlot.size() == 0);
+        newSlot = pathStatsQueue.collectStats(2);
+        Assert.assertTrue(newSlot.size() == 0);
+        newSlot = pathStatsQueue.collectStats(5);
+        Assert.assertTrue(newSlot.size() == 0);
+    }
+    
+    @Ignore","[{'comment': 'Ignore ?', 'commenter': 'eolivelli'}, {'comment': 'good catch, unignored.', 'commenter': 'hanm'}]"
989,zookeeper-server/src/test/java/org/apache/zookeeper/server/util/RequestPathMetricsCollectorTest.java,"@@ -0,0 +1,457 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Assert;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.apache.zookeeper.ZooDefs.OpCode.create;
+import static org.apache.zookeeper.ZooDefs.OpCode.create2;
+import static org.apache.zookeeper.ZooDefs.OpCode.delete;
+import static org.apache.zookeeper.ZooDefs.OpCode.exists;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren2;
+import static org.apache.zookeeper.ZooDefs.OpCode.getData;
+import static org.apache.zookeeper.ZooDefs.OpCode.setData;
+
+public class RequestPathMetricsCollectorTest {
+    public RequestPathMetricsCollectorTest() {
+        //tune the request metrics receiver parameters
+        System.setProperty(""zookeeper.pathStats.slotCapacity"", ""60"");
+        System.setProperty(""zookeeper.pathStats.slotDuration"", ""1"");
+        System.setProperty(""zookeeper.pathStats.maxDepth"", ""6"");
+        System.setProperty(""zookeeper.pathStats.sampleRate"", ""1.0"");
+    }
+
+    @Test
+    public void testTrimPath() {
+        //normal cases
+        String trimedPath = RequestPathMetricsCollector.trimPathDepth(""/p1/p2/p3"", 1);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""/p1/p2/p3"", 2);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1/p2""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""/p1/p2/p3"", 3);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1/p2/p3""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""/p1/p2/p3"", 4);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1/p2/p3""));
+        //some extra symbols
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""//p1 next/p2.index/p3:next"",
+            3);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1 next/p2.index/p3:next""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""//p1 next/p2.index/p3:next"",
+            2);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1 next/p2.index""));
+        trimedPath = RequestPathMetricsCollector.trimPathDepth(""//p1 next/p2.index/p3:next"",
+            6);
+        Assert.assertTrue(trimedPath.equalsIgnoreCase(""/p1 next/p2.index/p3:next""));
+    }
+
+    @Test
+    public void testQueueMapReduce() throws InterruptedException {
+        RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();
+        RequestPathMetricsCollector.PathStatsQueue pathStatsQueue =
+            requestPathMetricsCollector.new PathStatsQueue(create2);
+        Thread path7 = new Thread(() -> {
+            for (int i = 0; i < 1000000; i++) {
+                pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5/path6/path7"" +
+                    ""_"" + i);
+            }
+        });
+        path7.start();
+        Thread path6 = new Thread(() -> {
+            pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5/path6"");
+            for(int i = 1; i < 100000; i++) {
+                pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5/path6""+""_""+i);
+            }
+        });
+        path6.start();
+        for(int i = 0; i < 1; i++) {
+            pathStatsQueue.registerRequest(""/path1"");
+        }
+        for(int i = 0; i < 10; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2""+""_""+i);
+        }
+        for(int i = 0; i < 100; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2/path3""+""_""+i);
+        }
+        for(int i = 0; i < 1000; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2/path3/path4""+""_""+i);
+        }
+        for(int i = 0; i < 10000; i++) {
+            pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5""+""_""+i);
+        }
+        path6.join();
+        path7.join();
+        Map<String, Integer> newSlot = pathStatsQueue.mapReducePaths(1,
+            pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 1);
+        Assert.assertTrue(newSlot.get(""/path1"").compareTo(1111111) == 0);
+        //cut up to 2
+        newSlot = pathStatsQueue.mapReducePaths(2, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 12);
+        Assert.assertTrue(newSlot.get(""/path1"").compareTo(1) == 0);
+        Assert.assertTrue(newSlot.get(""/path1/path2"").compareTo(1111100) == 0);
+        //cut up to 3
+        newSlot = pathStatsQueue.mapReducePaths(3, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 112);
+        Assert.assertTrue(newSlot.get(""/path1"").compareTo(1) == 0);
+        Assert.assertTrue(newSlot.get(""/path1/path2/path3"").compareTo(1111000) == 0);
+        //cut up to 4
+        newSlot = pathStatsQueue.mapReducePaths(4, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 1112);
+        Assert.assertTrue(newSlot.get(""/path1/path2/path3/path4"").compareTo(1110000) == 0);
+        //cut up to 5
+        newSlot = pathStatsQueue.mapReducePaths(5, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 11112);
+        Assert.assertTrue(newSlot.get(""/path1/path2/path3/path4/path5"").compareTo(1100000) == 0);
+        //cut up to 6
+        newSlot = pathStatsQueue.mapReducePaths(6, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 111111);
+        Assert.assertTrue(newSlot.get(""/path1/path2/path3/path4/path5/path6"").compareTo(1000001) == 0);
+        //cut up to 7
+        newSlot = pathStatsQueue.mapReducePaths(7, pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.size() == 1111111);
+    }
+
+    @Test
+    public void testCollectEmptyStats() throws InterruptedException {
+        RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();
+        RequestPathMetricsCollector.PathStatsQueue pathStatsQueue =
+            requestPathMetricsCollector.new PathStatsQueue(getChildren);
+        Thread.sleep(5000);
+        Map<String, Integer> newSlot = pathStatsQueue.mapReducePaths(3,
+            pathStatsQueue.getCurrentSlot());
+        Assert.assertTrue(newSlot.isEmpty());
+        pathStatsQueue.start();
+        Thread.sleep(15000);
+        newSlot = pathStatsQueue.collectStats(1);
+        Assert.assertTrue(newSlot.size() == 0);
+        newSlot = pathStatsQueue.collectStats(2);
+        Assert.assertTrue(newSlot.size() == 0);
+        newSlot = pathStatsQueue.collectStats(5);
+        Assert.assertTrue(newSlot.size() == 0);
+    }
+    
+    @Ignore
+    @Test
+    public void testCollectStats() throws InterruptedException {
+        RequestPathMetricsCollector requestPathMetricsCollector =
+            new RequestPathMetricsCollector(true);
+        RequestPathMetricsCollector.PathStatsQueue pathStatsQueue =
+            requestPathMetricsCollector.new PathStatsQueue(getChildren);
+        pathStatsQueue.start();
+        Thread path7 = new Thread(() -> {
+            for(int i = 0; i < 10; i++) {
+                try {
+                    Thread.sleep(100);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+                for (int j = 0; j < 100000; j++) {
+                    pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5/path6/path7""
+                        + ""_"" + i + ""_"" + j);
+                }
+            }
+        });
+        path7.start();
+        Thread path6 = new Thread(() -> {
+            pathStatsQueue.registerRequest(""/path1/path2/path3/path4/path5/path6"");
+            for(int i = 0; i < 10; i++) {
+                try {
+                    Thread.sleep(1000);","[{'comment': 'this test will take at least 10 seconds. \r\ncan we change it to make it quicker ?', 'commenter': 'eolivelli'}, {'comment': 'reduced to 5 sec.', 'commenter': 'hanm'}]"
989,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -200,6 +202,7 @@ void removeCnxn(ServerCnxn cnxn) {
     public ZooKeeperServer() {
         listener = new ZooKeeperServerListenerImpl(this);
         serverStats = new ServerStats(this);
+        this.requestPathMetricsCollector = new RequestPathMetricsCollector();","[{'comment': 'what about having a default no-op implementation of RequestPathMetricsCollector and make this feature disabled by default ?\r\nit would consume CPU cycles even if not needed', 'commenter': 'eolivelli'}, {'comment': 'introduced a flag `enabled` with default value `false`. Removed the old `disabled` flag.', 'commenter': 'hanm'}]"
989,zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -95,10 +91,14 @@
 public class FinalRequestProcessor implements RequestProcessor {
     private static final Logger LOG = LoggerFactory.getLogger(FinalRequestProcessor.class);
 
+    public static final String PATH_MAX_DEPTH = ""zookeeper.path.maxDepth"";","[{'comment': ""I can't find this constant PATH_MAX_DEPTH used in this patch , it looks like PATH_STATS_MAX_DEPTH"", 'commenter': 'eolivelli'}, {'comment': ""good catch, it's dead variable and I removed it."", 'commenter': 'hanm'}]"
989,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/RequestPathMetricsCollector.java,"@@ -0,0 +1,385 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.io.PrintWriter;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+import java.util.StringTokenizer;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.server.Request;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static org.apache.zookeeper.ZooDefs.OpCode.checkWatches;
+import static org.apache.zookeeper.ZooDefs.OpCode.create;
+import static org.apache.zookeeper.ZooDefs.OpCode.create2;
+import static org.apache.zookeeper.ZooDefs.OpCode.createContainer;
+import static org.apache.zookeeper.ZooDefs.OpCode.delete;
+import static org.apache.zookeeper.ZooDefs.OpCode.deleteContainer;
+import static org.apache.zookeeper.ZooDefs.OpCode.exists;
+import static org.apache.zookeeper.ZooDefs.OpCode.getACL;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren2;
+import static org.apache.zookeeper.ZooDefs.OpCode.getData;
+import static org.apache.zookeeper.ZooDefs.OpCode.removeWatches;
+import static org.apache.zookeeper.ZooDefs.OpCode.setACL;
+import static org.apache.zookeeper.ZooDefs.OpCode.setData;
+import static org.apache.zookeeper.ZooDefs.OpCode.sync;
+
+/**
+ * This class holds the requests path ( up till a certain depth) stats per request type
+ */
+public class RequestPathMetricsCollector {
+    private static final Logger LOG = LoggerFactory.getLogger(RequestPathMetricsCollector.class);
+    // How many seconds does each slot represent, default is 15 seconds.
+    private final int REQUEST_STATS_SLOT_DURATION;
+    // How many slots we keep, default is 60 so it's 15 minutes total history.
+    private final int REQUEST_STATS_SLOT_CAPACITY;
+    // How far down the path we keep, default is 6.
+    private final int REQUEST_PREPROCESS_PATH_DEPTH;
+    // Sample rate, default is 0.1 (10%).
+    private final float REQUEST_PREPROCESS_SAMPLE_RATE;
+    private final long COLLECTOR_INITIAL_DELAY;
+    private final long COLLECTOR_DELAY;
+    private final int REQUEST_PREPROCESS_TOPPATH_MAX;
+    private final boolean disabled;
+
+    public static final String PATH_STATS_SLOT_CAPACITY = ""zookeeper.pathStats.slotCapacity"";
+    public static final String PATH_STATS_SLOT_DURATION = ""zookeeper.pathStats.slotDuration"";
+    public static final String PATH_STATS_MAX_DEPTH = ""zookeeper.pathStats.maxDepth"";
+    public static final String PATH_STATS_SAMPLE_RATE = ""zookeeper.pathStats.sampleRate"";
+    public static final String PATH_STATS_COLLECTOR_INITIAL_DELAY = ""zookeeper.pathStats.initialDelay"";
+    public static final String PATH_STATS_COLLECTOR_DELAY = ""zookeeper.pathStats.delay"";
+    public static final String PATH_STATS_TOP_PATH_MAX = ""zookeeper.pathStats.topPathMax"";
+    public static final String PATH_STATS_DISABLE = ""zookeeper.pathStats.disable"";
+
+    private final Map<String, PathStatsQueue> immutableRequestsMap;
+    private final Random sampler;
+    private final ScheduledThreadPoolExecutor scheduledExecutor;
+    private final boolean accurateMode;
+
+    public RequestPathMetricsCollector() {
+        this(false);
+    }
+    
+    public RequestPathMetricsCollector(boolean accurateMode) {
+        final HashMap<String, PathStatsQueue> requestsMap = new HashMap<>();
+        this.sampler = new Random(System.currentTimeMillis());
+        this.accurateMode = accurateMode;
+
+        REQUEST_PREPROCESS_TOPPATH_MAX = Integer.getInteger(PATH_STATS_TOP_PATH_MAX, 20);
+        REQUEST_STATS_SLOT_DURATION = Integer.getInteger(PATH_STATS_SLOT_DURATION, 15);
+        REQUEST_STATS_SLOT_CAPACITY = Integer.getInteger(PATH_STATS_SLOT_CAPACITY, 60);
+        REQUEST_PREPROCESS_PATH_DEPTH = Integer.getInteger(PATH_STATS_MAX_DEPTH, 6);
+        REQUEST_PREPROCESS_SAMPLE_RATE = Float.parseFloat(
+            System.getProperty(PATH_STATS_SAMPLE_RATE, ""0.1""));
+        COLLECTOR_INITIAL_DELAY = Long.getLong(PATH_STATS_COLLECTOR_INITIAL_DELAY, 5);
+        COLLECTOR_DELAY = Long.getLong(PATH_STATS_COLLECTOR_DELAY, 5);
+        disabled = Boolean.getBoolean(PATH_STATS_DISABLE);
+
+        LOG.info(""{} = {}"", PATH_STATS_SLOT_CAPACITY, REQUEST_STATS_SLOT_CAPACITY);
+        LOG.info(""{} = {}"", PATH_STATS_SLOT_DURATION, REQUEST_STATS_SLOT_DURATION);
+        LOG.info(""{} = {}"", PATH_STATS_MAX_DEPTH, REQUEST_PREPROCESS_PATH_DEPTH);
+        LOG.info(""{} = {}"", PATH_STATS_COLLECTOR_INITIAL_DELAY, COLLECTOR_INITIAL_DELAY);
+        LOG.info(""{} = {}"", PATH_STATS_COLLECTOR_DELAY, COLLECTOR_DELAY);
+        LOG.info(""{} = {}"", PATH_STATS_DISABLE, disabled);
+
+        this.scheduledExecutor = (ScheduledThreadPoolExecutor) Executors
+            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors());
+        scheduledExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
+        scheduledExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
+        requestsMap.put(Request.op2String(create), new PathStatsQueue(create));
+        requestsMap.put(Request.op2String(create2), new PathStatsQueue(create2));
+        requestsMap.put(Request.op2String(createContainer), new PathStatsQueue(createContainer));
+        requestsMap.put(Request.op2String(deleteContainer), new PathStatsQueue(deleteContainer));
+        requestsMap.put(Request.op2String(delete), new PathStatsQueue(delete));
+        requestsMap.put(Request.op2String(exists), new PathStatsQueue(exists));
+        requestsMap.put(Request.op2String(setData), new PathStatsQueue(setData));
+        requestsMap.put(Request.op2String(getData), new PathStatsQueue(getData));
+        requestsMap.put(Request.op2String(getACL), new PathStatsQueue(getACL));
+        requestsMap.put(Request.op2String(setACL), new PathStatsQueue(setACL));
+        requestsMap.put(Request.op2String(getChildren), new PathStatsQueue(getChildren));
+        requestsMap.put(Request.op2String(getChildren2), new PathStatsQueue(getChildren2));
+        requestsMap.put(Request.op2String(checkWatches), new PathStatsQueue(checkWatches));
+        requestsMap.put(Request.op2String(removeWatches), new PathStatsQueue(removeWatches));
+        requestsMap.put(Request.op2String(sync), new PathStatsQueue(sync));
+        this.immutableRequestsMap = java.util.Collections.unmodifiableMap(requestsMap);
+    }
+
+    static boolean isWriteOp(int requestType) {
+        switch (requestType) {
+            case ZooDefs.OpCode.sync:
+            case ZooDefs.OpCode.create:
+            case ZooDefs.OpCode.create2:
+            case ZooDefs.OpCode.createContainer:
+            case ZooDefs.OpCode.delete:
+            case ZooDefs.OpCode.deleteContainer:
+            case ZooDefs.OpCode.setData:
+            case ZooDefs.OpCode.reconfig:
+            case ZooDefs.OpCode.setACL:
+            case ZooDefs.OpCode.multi:
+            case ZooDefs.OpCode.check:
+                return true;
+        }
+        return false;
+    }
+
+    static String trimPathDepth(String path, int maxDepth) {
+        int count = 0;
+        String pathSeparator = ""/"";","[{'comment': 'constant ?', 'commenter': 'eolivelli'}, {'comment': 'done.', 'commenter': 'hanm'}]"
989,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/RequestPathMetricsCollector.java,"@@ -0,0 +1,385 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.io.PrintWriter;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+import java.util.StringTokenizer;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.server.Request;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static org.apache.zookeeper.ZooDefs.OpCode.checkWatches;
+import static org.apache.zookeeper.ZooDefs.OpCode.create;
+import static org.apache.zookeeper.ZooDefs.OpCode.create2;
+import static org.apache.zookeeper.ZooDefs.OpCode.createContainer;
+import static org.apache.zookeeper.ZooDefs.OpCode.delete;
+import static org.apache.zookeeper.ZooDefs.OpCode.deleteContainer;
+import static org.apache.zookeeper.ZooDefs.OpCode.exists;
+import static org.apache.zookeeper.ZooDefs.OpCode.getACL;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren2;
+import static org.apache.zookeeper.ZooDefs.OpCode.getData;
+import static org.apache.zookeeper.ZooDefs.OpCode.removeWatches;
+import static org.apache.zookeeper.ZooDefs.OpCode.setACL;
+import static org.apache.zookeeper.ZooDefs.OpCode.setData;
+import static org.apache.zookeeper.ZooDefs.OpCode.sync;
+
+/**
+ * This class holds the requests path ( up till a certain depth) stats per request type
+ */
+public class RequestPathMetricsCollector {
+    private static final Logger LOG = LoggerFactory.getLogger(RequestPathMetricsCollector.class);
+    // How many seconds does each slot represent, default is 15 seconds.
+    private final int REQUEST_STATS_SLOT_DURATION;
+    // How many slots we keep, default is 60 so it's 15 minutes total history.
+    private final int REQUEST_STATS_SLOT_CAPACITY;
+    // How far down the path we keep, default is 6.
+    private final int REQUEST_PREPROCESS_PATH_DEPTH;
+    // Sample rate, default is 0.1 (10%).
+    private final float REQUEST_PREPROCESS_SAMPLE_RATE;
+    private final long COLLECTOR_INITIAL_DELAY;
+    private final long COLLECTOR_DELAY;
+    private final int REQUEST_PREPROCESS_TOPPATH_MAX;
+    private final boolean disabled;
+
+    public static final String PATH_STATS_SLOT_CAPACITY = ""zookeeper.pathStats.slotCapacity"";
+    public static final String PATH_STATS_SLOT_DURATION = ""zookeeper.pathStats.slotDuration"";
+    public static final String PATH_STATS_MAX_DEPTH = ""zookeeper.pathStats.maxDepth"";
+    public static final String PATH_STATS_SAMPLE_RATE = ""zookeeper.pathStats.sampleRate"";
+    public static final String PATH_STATS_COLLECTOR_INITIAL_DELAY = ""zookeeper.pathStats.initialDelay"";
+    public static final String PATH_STATS_COLLECTOR_DELAY = ""zookeeper.pathStats.delay"";
+    public static final String PATH_STATS_TOP_PATH_MAX = ""zookeeper.pathStats.topPathMax"";
+    public static final String PATH_STATS_DISABLE = ""zookeeper.pathStats.disable"";
+
+    private final Map<String, PathStatsQueue> immutableRequestsMap;
+    private final Random sampler;
+    private final ScheduledThreadPoolExecutor scheduledExecutor;
+    private final boolean accurateMode;
+
+    public RequestPathMetricsCollector() {
+        this(false);
+    }
+    
+    public RequestPathMetricsCollector(boolean accurateMode) {
+        final HashMap<String, PathStatsQueue> requestsMap = new HashMap<>();
+        this.sampler = new Random(System.currentTimeMillis());
+        this.accurateMode = accurateMode;
+
+        REQUEST_PREPROCESS_TOPPATH_MAX = Integer.getInteger(PATH_STATS_TOP_PATH_MAX, 20);
+        REQUEST_STATS_SLOT_DURATION = Integer.getInteger(PATH_STATS_SLOT_DURATION, 15);
+        REQUEST_STATS_SLOT_CAPACITY = Integer.getInteger(PATH_STATS_SLOT_CAPACITY, 60);
+        REQUEST_PREPROCESS_PATH_DEPTH = Integer.getInteger(PATH_STATS_MAX_DEPTH, 6);
+        REQUEST_PREPROCESS_SAMPLE_RATE = Float.parseFloat(
+            System.getProperty(PATH_STATS_SAMPLE_RATE, ""0.1""));
+        COLLECTOR_INITIAL_DELAY = Long.getLong(PATH_STATS_COLLECTOR_INITIAL_DELAY, 5);
+        COLLECTOR_DELAY = Long.getLong(PATH_STATS_COLLECTOR_DELAY, 5);
+        disabled = Boolean.getBoolean(PATH_STATS_DISABLE);
+
+        LOG.info(""{} = {}"", PATH_STATS_SLOT_CAPACITY, REQUEST_STATS_SLOT_CAPACITY);
+        LOG.info(""{} = {}"", PATH_STATS_SLOT_DURATION, REQUEST_STATS_SLOT_DURATION);
+        LOG.info(""{} = {}"", PATH_STATS_MAX_DEPTH, REQUEST_PREPROCESS_PATH_DEPTH);
+        LOG.info(""{} = {}"", PATH_STATS_COLLECTOR_INITIAL_DELAY, COLLECTOR_INITIAL_DELAY);
+        LOG.info(""{} = {}"", PATH_STATS_COLLECTOR_DELAY, COLLECTOR_DELAY);
+        LOG.info(""{} = {}"", PATH_STATS_DISABLE, disabled);
+
+        this.scheduledExecutor = (ScheduledThreadPoolExecutor) Executors
+            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors());
+        scheduledExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
+        scheduledExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
+        requestsMap.put(Request.op2String(create), new PathStatsQueue(create));
+        requestsMap.put(Request.op2String(create2), new PathStatsQueue(create2));
+        requestsMap.put(Request.op2String(createContainer), new PathStatsQueue(createContainer));
+        requestsMap.put(Request.op2String(deleteContainer), new PathStatsQueue(deleteContainer));
+        requestsMap.put(Request.op2String(delete), new PathStatsQueue(delete));
+        requestsMap.put(Request.op2String(exists), new PathStatsQueue(exists));
+        requestsMap.put(Request.op2String(setData), new PathStatsQueue(setData));
+        requestsMap.put(Request.op2String(getData), new PathStatsQueue(getData));
+        requestsMap.put(Request.op2String(getACL), new PathStatsQueue(getACL));
+        requestsMap.put(Request.op2String(setACL), new PathStatsQueue(setACL));
+        requestsMap.put(Request.op2String(getChildren), new PathStatsQueue(getChildren));
+        requestsMap.put(Request.op2String(getChildren2), new PathStatsQueue(getChildren2));
+        requestsMap.put(Request.op2String(checkWatches), new PathStatsQueue(checkWatches));
+        requestsMap.put(Request.op2String(removeWatches), new PathStatsQueue(removeWatches));
+        requestsMap.put(Request.op2String(sync), new PathStatsQueue(sync));
+        this.immutableRequestsMap = java.util.Collections.unmodifiableMap(requestsMap);
+    }
+
+    static boolean isWriteOp(int requestType) {
+        switch (requestType) {
+            case ZooDefs.OpCode.sync:
+            case ZooDefs.OpCode.create:
+            case ZooDefs.OpCode.create2:
+            case ZooDefs.OpCode.createContainer:
+            case ZooDefs.OpCode.delete:
+            case ZooDefs.OpCode.deleteContainer:
+            case ZooDefs.OpCode.setData:
+            case ZooDefs.OpCode.reconfig:
+            case ZooDefs.OpCode.setACL:
+            case ZooDefs.OpCode.multi:
+            case ZooDefs.OpCode.check:
+                return true;
+        }
+        return false;
+    }
+
+    static String trimPathDepth(String path, int maxDepth) {
+        int count = 0;
+        String pathSeparator = ""/"";
+        StringBuilder sb = new StringBuilder();
+        StringTokenizer pathTokenizer = new StringTokenizer(path, pathSeparator);
+        while (pathTokenizer.hasMoreElements() && count++ < maxDepth) {
+            sb.append(pathSeparator);
+            sb.append(pathTokenizer.nextToken());
+        }
+        path = sb.toString();
+        return path;
+    }
+
+    @Override
+    protected void finalize() {","[{'comment': 'I think this is not needed and nowadays finalize() is not to be used anymore\r\ncan we drop this method ?', 'commenter': 'eolivelli'}, {'comment': 'removed.', 'commenter': 'hanm'}]"
989,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/RequestPathMetricsCollector.java,"@@ -0,0 +1,385 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.io.PrintWriter;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+import java.util.StringTokenizer;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.server.Request;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static org.apache.zookeeper.ZooDefs.OpCode.checkWatches;
+import static org.apache.zookeeper.ZooDefs.OpCode.create;
+import static org.apache.zookeeper.ZooDefs.OpCode.create2;
+import static org.apache.zookeeper.ZooDefs.OpCode.createContainer;
+import static org.apache.zookeeper.ZooDefs.OpCode.delete;
+import static org.apache.zookeeper.ZooDefs.OpCode.deleteContainer;
+import static org.apache.zookeeper.ZooDefs.OpCode.exists;
+import static org.apache.zookeeper.ZooDefs.OpCode.getACL;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren2;
+import static org.apache.zookeeper.ZooDefs.OpCode.getData;
+import static org.apache.zookeeper.ZooDefs.OpCode.removeWatches;
+import static org.apache.zookeeper.ZooDefs.OpCode.setACL;
+import static org.apache.zookeeper.ZooDefs.OpCode.setData;
+import static org.apache.zookeeper.ZooDefs.OpCode.sync;
+
+/**
+ * This class holds the requests path ( up till a certain depth) stats per request type
+ */
+public class RequestPathMetricsCollector {
+    private static final Logger LOG = LoggerFactory.getLogger(RequestPathMetricsCollector.class);
+    // How many seconds does each slot represent, default is 15 seconds.
+    private final int REQUEST_STATS_SLOT_DURATION;
+    // How many slots we keep, default is 60 so it's 15 minutes total history.
+    private final int REQUEST_STATS_SLOT_CAPACITY;
+    // How far down the path we keep, default is 6.
+    private final int REQUEST_PREPROCESS_PATH_DEPTH;
+    // Sample rate, default is 0.1 (10%).
+    private final float REQUEST_PREPROCESS_SAMPLE_RATE;
+    private final long COLLECTOR_INITIAL_DELAY;
+    private final long COLLECTOR_DELAY;
+    private final int REQUEST_PREPROCESS_TOPPATH_MAX;
+    private final boolean disabled;
+
+    public static final String PATH_STATS_SLOT_CAPACITY = ""zookeeper.pathStats.slotCapacity"";
+    public static final String PATH_STATS_SLOT_DURATION = ""zookeeper.pathStats.slotDuration"";
+    public static final String PATH_STATS_MAX_DEPTH = ""zookeeper.pathStats.maxDepth"";
+    public static final String PATH_STATS_SAMPLE_RATE = ""zookeeper.pathStats.sampleRate"";
+    public static final String PATH_STATS_COLLECTOR_INITIAL_DELAY = ""zookeeper.pathStats.initialDelay"";
+    public static final String PATH_STATS_COLLECTOR_DELAY = ""zookeeper.pathStats.delay"";
+    public static final String PATH_STATS_TOP_PATH_MAX = ""zookeeper.pathStats.topPathMax"";
+    public static final String PATH_STATS_DISABLE = ""zookeeper.pathStats.disable"";
+
+    private final Map<String, PathStatsQueue> immutableRequestsMap;
+    private final Random sampler;
+    private final ScheduledThreadPoolExecutor scheduledExecutor;
+    private final boolean accurateMode;
+
+    public RequestPathMetricsCollector() {
+        this(false);
+    }
+    
+    public RequestPathMetricsCollector(boolean accurateMode) {
+        final HashMap<String, PathStatsQueue> requestsMap = new HashMap<>();
+        this.sampler = new Random(System.currentTimeMillis());
+        this.accurateMode = accurateMode;
+
+        REQUEST_PREPROCESS_TOPPATH_MAX = Integer.getInteger(PATH_STATS_TOP_PATH_MAX, 20);
+        REQUEST_STATS_SLOT_DURATION = Integer.getInteger(PATH_STATS_SLOT_DURATION, 15);
+        REQUEST_STATS_SLOT_CAPACITY = Integer.getInteger(PATH_STATS_SLOT_CAPACITY, 60);
+        REQUEST_PREPROCESS_PATH_DEPTH = Integer.getInteger(PATH_STATS_MAX_DEPTH, 6);
+        REQUEST_PREPROCESS_SAMPLE_RATE = Float.parseFloat(
+            System.getProperty(PATH_STATS_SAMPLE_RATE, ""0.1""));
+        COLLECTOR_INITIAL_DELAY = Long.getLong(PATH_STATS_COLLECTOR_INITIAL_DELAY, 5);
+        COLLECTOR_DELAY = Long.getLong(PATH_STATS_COLLECTOR_DELAY, 5);
+        disabled = Boolean.getBoolean(PATH_STATS_DISABLE);
+
+        LOG.info(""{} = {}"", PATH_STATS_SLOT_CAPACITY, REQUEST_STATS_SLOT_CAPACITY);
+        LOG.info(""{} = {}"", PATH_STATS_SLOT_DURATION, REQUEST_STATS_SLOT_DURATION);
+        LOG.info(""{} = {}"", PATH_STATS_MAX_DEPTH, REQUEST_PREPROCESS_PATH_DEPTH);
+        LOG.info(""{} = {}"", PATH_STATS_COLLECTOR_INITIAL_DELAY, COLLECTOR_INITIAL_DELAY);
+        LOG.info(""{} = {}"", PATH_STATS_COLLECTOR_DELAY, COLLECTOR_DELAY);
+        LOG.info(""{} = {}"", PATH_STATS_DISABLE, disabled);
+
+        this.scheduledExecutor = (ScheduledThreadPoolExecutor) Executors
+            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors());
+        scheduledExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
+        scheduledExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
+        requestsMap.put(Request.op2String(create), new PathStatsQueue(create));
+        requestsMap.put(Request.op2String(create2), new PathStatsQueue(create2));
+        requestsMap.put(Request.op2String(createContainer), new PathStatsQueue(createContainer));
+        requestsMap.put(Request.op2String(deleteContainer), new PathStatsQueue(deleteContainer));
+        requestsMap.put(Request.op2String(delete), new PathStatsQueue(delete));
+        requestsMap.put(Request.op2String(exists), new PathStatsQueue(exists));
+        requestsMap.put(Request.op2String(setData), new PathStatsQueue(setData));
+        requestsMap.put(Request.op2String(getData), new PathStatsQueue(getData));
+        requestsMap.put(Request.op2String(getACL), new PathStatsQueue(getACL));
+        requestsMap.put(Request.op2String(setACL), new PathStatsQueue(setACL));
+        requestsMap.put(Request.op2String(getChildren), new PathStatsQueue(getChildren));
+        requestsMap.put(Request.op2String(getChildren2), new PathStatsQueue(getChildren2));
+        requestsMap.put(Request.op2String(checkWatches), new PathStatsQueue(checkWatches));
+        requestsMap.put(Request.op2String(removeWatches), new PathStatsQueue(removeWatches));
+        requestsMap.put(Request.op2String(sync), new PathStatsQueue(sync));
+        this.immutableRequestsMap = java.util.Collections.unmodifiableMap(requestsMap);
+    }
+
+    static boolean isWriteOp(int requestType) {
+        switch (requestType) {
+            case ZooDefs.OpCode.sync:
+            case ZooDefs.OpCode.create:
+            case ZooDefs.OpCode.create2:
+            case ZooDefs.OpCode.createContainer:
+            case ZooDefs.OpCode.delete:
+            case ZooDefs.OpCode.deleteContainer:
+            case ZooDefs.OpCode.setData:
+            case ZooDefs.OpCode.reconfig:
+            case ZooDefs.OpCode.setACL:
+            case ZooDefs.OpCode.multi:
+            case ZooDefs.OpCode.check:
+                return true;
+        }
+        return false;
+    }
+
+    static String trimPathDepth(String path, int maxDepth) {
+        int count = 0;
+        String pathSeparator = ""/"";
+        StringBuilder sb = new StringBuilder();
+        StringTokenizer pathTokenizer = new StringTokenizer(path, pathSeparator);
+        while (pathTokenizer.hasMoreElements() && count++ < maxDepth) {
+            sb.append(pathSeparator);
+            sb.append(pathTokenizer.nextToken());
+        }
+        path = sb.toString();
+        return path;
+    }
+
+    @Override
+    protected void finalize() {
+        shutdown();
+    }
+        
+    public void shutdown(){
+        if (disabled) return;
+
+        LOG.info(""shutdown scheduledExecutor"");
+        scheduledExecutor.shutdownNow();
+    }
+    
+    public void start() {
+        if (disabled) return;
+
+        LOG.info(""Start the RequestPath collector"");
+        immutableRequestsMap.forEach((opType, pathStatsQueue) -> pathStatsQueue.start());
+        
+        // Schedule to log the top used read/write paths every 5 mins
+        scheduledExecutor.scheduleWithFixedDelay(() -> {
+            LOG.info(""%nHere are the top Read paths:"");
+            logTopPaths(aggregatePaths(4, queue -> !queue.isWriteOperation()),
+                entry -> LOG.info(entry.getKey() + "" : "" + entry.getValue()));
+            LOG.info(""%nHere are the top Write paths:"");
+            logTopPaths(aggregatePaths(4, queue -> queue.isWriteOperation()),
+                entry -> LOG.info(entry.getKey() + "" : "" + entry.getValue()));
+        }, COLLECTOR_INITIAL_DELAY, COLLECTOR_DELAY, TimeUnit.MINUTES);
+    }
+
+    /**
+     * The public interface of the buffer. FinalRequestHandler will call into this for
+     * each request that has a path and this needs to be fast. we sample the path so that
+     * we don't have to store too many paths in memory
+     */
+    public void registerRequest(int type, String path) {
+        if (sampler.nextFloat() <= REQUEST_PREPROCESS_SAMPLE_RATE) {
+            PathStatsQueue pathStatsQueue = immutableRequestsMap.get(Request.op2String(type));
+            if (pathStatsQueue != null) {
+                pathStatsQueue.registerRequest(path);
+            } else {
+                LOG.error(""We should not handle {}"", type);
+            }
+        }
+    }
+
+    public void dumpTopRequestPath(PrintWriter pwriter, String requestTypeName, int queryMaxDepth) {
+        if (queryMaxDepth < 1) return;","[{'comment': 'nit: add curly braces', 'commenter': 'eolivelli'}, {'comment': 'done', 'commenter': 'hanm'}]"
989,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/RequestPathMetricsCollector.java,"@@ -0,0 +1,385 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.io.PrintWriter;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+import java.util.StringTokenizer;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.server.Request;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static org.apache.zookeeper.ZooDefs.OpCode.checkWatches;
+import static org.apache.zookeeper.ZooDefs.OpCode.create;
+import static org.apache.zookeeper.ZooDefs.OpCode.create2;
+import static org.apache.zookeeper.ZooDefs.OpCode.createContainer;
+import static org.apache.zookeeper.ZooDefs.OpCode.delete;
+import static org.apache.zookeeper.ZooDefs.OpCode.deleteContainer;
+import static org.apache.zookeeper.ZooDefs.OpCode.exists;
+import static org.apache.zookeeper.ZooDefs.OpCode.getACL;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren;
+import static org.apache.zookeeper.ZooDefs.OpCode.getChildren2;
+import static org.apache.zookeeper.ZooDefs.OpCode.getData;
+import static org.apache.zookeeper.ZooDefs.OpCode.removeWatches;
+import static org.apache.zookeeper.ZooDefs.OpCode.setACL;
+import static org.apache.zookeeper.ZooDefs.OpCode.setData;
+import static org.apache.zookeeper.ZooDefs.OpCode.sync;
+
+/**
+ * This class holds the requests path ( up till a certain depth) stats per request type
+ */
+public class RequestPathMetricsCollector {
+    private static final Logger LOG = LoggerFactory.getLogger(RequestPathMetricsCollector.class);
+    // How many seconds does each slot represent, default is 15 seconds.
+    private final int REQUEST_STATS_SLOT_DURATION;
+    // How many slots we keep, default is 60 so it's 15 minutes total history.
+    private final int REQUEST_STATS_SLOT_CAPACITY;
+    // How far down the path we keep, default is 6.
+    private final int REQUEST_PREPROCESS_PATH_DEPTH;
+    // Sample rate, default is 0.1 (10%).
+    private final float REQUEST_PREPROCESS_SAMPLE_RATE;
+    private final long COLLECTOR_INITIAL_DELAY;
+    private final long COLLECTOR_DELAY;
+    private final int REQUEST_PREPROCESS_TOPPATH_MAX;
+    private final boolean disabled;
+
+    public static final String PATH_STATS_SLOT_CAPACITY = ""zookeeper.pathStats.slotCapacity"";
+    public static final String PATH_STATS_SLOT_DURATION = ""zookeeper.pathStats.slotDuration"";
+    public static final String PATH_STATS_MAX_DEPTH = ""zookeeper.pathStats.maxDepth"";
+    public static final String PATH_STATS_SAMPLE_RATE = ""zookeeper.pathStats.sampleRate"";
+    public static final String PATH_STATS_COLLECTOR_INITIAL_DELAY = ""zookeeper.pathStats.initialDelay"";
+    public static final String PATH_STATS_COLLECTOR_DELAY = ""zookeeper.pathStats.delay"";
+    public static final String PATH_STATS_TOP_PATH_MAX = ""zookeeper.pathStats.topPathMax"";
+    public static final String PATH_STATS_DISABLE = ""zookeeper.pathStats.disable"";
+
+    private final Map<String, PathStatsQueue> immutableRequestsMap;
+    private final Random sampler;
+    private final ScheduledThreadPoolExecutor scheduledExecutor;
+    private final boolean accurateMode;
+
+    public RequestPathMetricsCollector() {
+        this(false);
+    }
+    
+    public RequestPathMetricsCollector(boolean accurateMode) {
+        final HashMap<String, PathStatsQueue> requestsMap = new HashMap<>();
+        this.sampler = new Random(System.currentTimeMillis());
+        this.accurateMode = accurateMode;
+
+        REQUEST_PREPROCESS_TOPPATH_MAX = Integer.getInteger(PATH_STATS_TOP_PATH_MAX, 20);
+        REQUEST_STATS_SLOT_DURATION = Integer.getInteger(PATH_STATS_SLOT_DURATION, 15);
+        REQUEST_STATS_SLOT_CAPACITY = Integer.getInteger(PATH_STATS_SLOT_CAPACITY, 60);
+        REQUEST_PREPROCESS_PATH_DEPTH = Integer.getInteger(PATH_STATS_MAX_DEPTH, 6);
+        REQUEST_PREPROCESS_SAMPLE_RATE = Float.parseFloat(
+            System.getProperty(PATH_STATS_SAMPLE_RATE, ""0.1""));
+        COLLECTOR_INITIAL_DELAY = Long.getLong(PATH_STATS_COLLECTOR_INITIAL_DELAY, 5);
+        COLLECTOR_DELAY = Long.getLong(PATH_STATS_COLLECTOR_DELAY, 5);
+        disabled = Boolean.getBoolean(PATH_STATS_DISABLE);
+
+        LOG.info(""{} = {}"", PATH_STATS_SLOT_CAPACITY, REQUEST_STATS_SLOT_CAPACITY);
+        LOG.info(""{} = {}"", PATH_STATS_SLOT_DURATION, REQUEST_STATS_SLOT_DURATION);
+        LOG.info(""{} = {}"", PATH_STATS_MAX_DEPTH, REQUEST_PREPROCESS_PATH_DEPTH);
+        LOG.info(""{} = {}"", PATH_STATS_COLLECTOR_INITIAL_DELAY, COLLECTOR_INITIAL_DELAY);
+        LOG.info(""{} = {}"", PATH_STATS_COLLECTOR_DELAY, COLLECTOR_DELAY);
+        LOG.info(""{} = {}"", PATH_STATS_DISABLE, disabled);
+
+        this.scheduledExecutor = (ScheduledThreadPoolExecutor) Executors
+            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors());
+        scheduledExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
+        scheduledExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
+        requestsMap.put(Request.op2String(create), new PathStatsQueue(create));
+        requestsMap.put(Request.op2String(create2), new PathStatsQueue(create2));
+        requestsMap.put(Request.op2String(createContainer), new PathStatsQueue(createContainer));
+        requestsMap.put(Request.op2String(deleteContainer), new PathStatsQueue(deleteContainer));
+        requestsMap.put(Request.op2String(delete), new PathStatsQueue(delete));
+        requestsMap.put(Request.op2String(exists), new PathStatsQueue(exists));
+        requestsMap.put(Request.op2String(setData), new PathStatsQueue(setData));
+        requestsMap.put(Request.op2String(getData), new PathStatsQueue(getData));
+        requestsMap.put(Request.op2String(getACL), new PathStatsQueue(getACL));
+        requestsMap.put(Request.op2String(setACL), new PathStatsQueue(setACL));
+        requestsMap.put(Request.op2String(getChildren), new PathStatsQueue(getChildren));
+        requestsMap.put(Request.op2String(getChildren2), new PathStatsQueue(getChildren2));
+        requestsMap.put(Request.op2String(checkWatches), new PathStatsQueue(checkWatches));
+        requestsMap.put(Request.op2String(removeWatches), new PathStatsQueue(removeWatches));
+        requestsMap.put(Request.op2String(sync), new PathStatsQueue(sync));
+        this.immutableRequestsMap = java.util.Collections.unmodifiableMap(requestsMap);
+    }
+
+    static boolean isWriteOp(int requestType) {
+        switch (requestType) {
+            case ZooDefs.OpCode.sync:
+            case ZooDefs.OpCode.create:
+            case ZooDefs.OpCode.create2:
+            case ZooDefs.OpCode.createContainer:
+            case ZooDefs.OpCode.delete:
+            case ZooDefs.OpCode.deleteContainer:
+            case ZooDefs.OpCode.setData:
+            case ZooDefs.OpCode.reconfig:
+            case ZooDefs.OpCode.setACL:
+            case ZooDefs.OpCode.multi:
+            case ZooDefs.OpCode.check:
+                return true;
+        }
+        return false;
+    }
+
+    static String trimPathDepth(String path, int maxDepth) {
+        int count = 0;
+        String pathSeparator = ""/"";
+        StringBuilder sb = new StringBuilder();
+        StringTokenizer pathTokenizer = new StringTokenizer(path, pathSeparator);
+        while (pathTokenizer.hasMoreElements() && count++ < maxDepth) {
+            sb.append(pathSeparator);
+            sb.append(pathTokenizer.nextToken());
+        }
+        path = sb.toString();
+        return path;
+    }
+
+    @Override
+    protected void finalize() {
+        shutdown();
+    }
+        
+    public void shutdown(){
+        if (disabled) return;
+
+        LOG.info(""shutdown scheduledExecutor"");
+        scheduledExecutor.shutdownNow();
+    }
+    
+    public void start() {
+        if (disabled) return;
+
+        LOG.info(""Start the RequestPath collector"");
+        immutableRequestsMap.forEach((opType, pathStatsQueue) -> pathStatsQueue.start());
+        
+        // Schedule to log the top used read/write paths every 5 mins
+        scheduledExecutor.scheduleWithFixedDelay(() -> {
+            LOG.info(""%nHere are the top Read paths:"");
+            logTopPaths(aggregatePaths(4, queue -> !queue.isWriteOperation()),
+                entry -> LOG.info(entry.getKey() + "" : "" + entry.getValue()));
+            LOG.info(""%nHere are the top Write paths:"");
+            logTopPaths(aggregatePaths(4, queue -> queue.isWriteOperation()),
+                entry -> LOG.info(entry.getKey() + "" : "" + entry.getValue()));
+        }, COLLECTOR_INITIAL_DELAY, COLLECTOR_DELAY, TimeUnit.MINUTES);
+    }
+
+    /**
+     * The public interface of the buffer. FinalRequestHandler will call into this for
+     * each request that has a path and this needs to be fast. we sample the path so that
+     * we don't have to store too many paths in memory
+     */
+    public void registerRequest(int type, String path) {
+        if (sampler.nextFloat() <= REQUEST_PREPROCESS_SAMPLE_RATE) {
+            PathStatsQueue pathStatsQueue = immutableRequestsMap.get(Request.op2String(type));
+            if (pathStatsQueue != null) {
+                pathStatsQueue.registerRequest(path);
+            } else {
+                LOG.error(""We should not handle {}"", type);
+            }
+        }
+    }
+
+    public void dumpTopRequestPath(PrintWriter pwriter, String requestTypeName, int queryMaxDepth) {","[{'comment': 'where is this method used ? in an admin command ?', 'commenter': 'eolivelli'}, {'comment': 'That\'s a yes! It\'s used in a new ""path"" command we added internally. Once this patch landed, I\'ll that command. I tried to scope this patch to path stats collection only to avoid it bloated and make it easier to review.', 'commenter': 'hanm'}]"
993,zookeeper-client/zookeeper-client-c/pom.xml,"@@ -97,7 +58,7 @@
           </execution>
           <execution>
             <id>configure</id>
-            <phase>test-compile</phase>
+            <phase>process-sources</phase>","[{'comment': ""This is where --enable-gcov is passed, the phase which this runs probably surfaced the problem for Patrick? If someone doesn't have the library it will always fail, with ant only if they run a c-coverege report.\r\nThanks @symat for finding this!"", 'commenter': 'nkalmar'}]"
995,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerMaster.java,"@@ -29,18 +31,81 @@
 /**
  * interface for keeping Observers in sync
  */
-public interface LearnerMaster {
+public abstract class LearnerMaster {
+    private static final Logger LOG = LoggerFactory.getLogger(LearnerMaster.class);
+
+    // Throttle when there are too many concurrent snapshots being sent to observers
+    private static final String MAX_CONCURRENT_SNAPSYNCS = ""zookeeper.leader.maxConcurrentSnapSyncs"";","[{'comment': 'Would this configuration be shared between leader and observer master? If so, I think there are a few assumptions that worth a closer look.\r\n\r\n1) Leader and Followers are running on machines with similar capability (CPU, network bandwidth). This assumption is usually true.\r\n2) ObserverMasters and Observers are also running on machines with similar capabilities (CPU, network bandwidth). This assumption may not be true. E.g. If we deploy some Observers in a different data center than the ObserverMaster, then the effective network bandwidth between ObserverMaster and Observer could be significantly smaller than the bandwidth between Leader and Followers. In this case, we might want to set a different maxConcurrentSnapSyncs for ObserverMaster than Leader.\r\n\r\nDo those assumptions make sense here?', 'commenter': 'mayawang'}, {'comment': ""The thing is, we don't know what the appropriate thresholds are until we roll the feature out and then tune the settings.  If it turns out that we do need different settings for Leader and ObserverMaster, we can add it, instead of introducing a setting that might never be used. What do you think? (BTW, in our deployment, Leader and Followers can be in different data centers too.)"", 'commenter': 'jhuan31'}, {'comment': ""Thanks for the details! I think we can keep this configuration just one parameter for now. I'd love to learn the actual system behavior once this is used in production."", 'commenter': 'mayawang'}]"
995,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerMaster.java,"@@ -29,18 +31,81 @@
 /**
  * interface for keeping Observers in sync
  */
-public interface LearnerMaster {
+public abstract class LearnerMaster {
+    private static final Logger LOG = LoggerFactory.getLogger(LearnerMaster.class);
+
+    // Throttle when there are too many concurrent snapshots being sent to observers
+    private static final String MAX_CONCURRENT_SNAPSYNCS = ""zookeeper.leader.maxConcurrentSnapSyncs"";
+    private static final int DEFAULT_CONCURRENT_SNAPSYNCS;
+
+    // Throttle when there are too many concurrent diff syncs being sent to observers
+    private static final String MAX_CONCURRENT_DIFF_SYNCS = ""zookeeper.leader.maxConcurrentDiffSyncs"";
+    private static final int DEFAULT_CONCURRENT_DIFF_SYNCS;
+
+    static {
+        DEFAULT_CONCURRENT_SNAPSYNCS = Integer.getInteger(MAX_CONCURRENT_SNAPSYNCS, 10);
+        LOG.info(MAX_CONCURRENT_SNAPSYNCS + "" = "" + DEFAULT_CONCURRENT_SNAPSYNCS);
+
+        DEFAULT_CONCURRENT_DIFF_SYNCS = Integer.getInteger(MAX_CONCURRENT_DIFF_SYNCS, 100);
+        LOG.info(MAX_CONCURRENT_DIFF_SYNCS + "" = "" + DEFAULT_CONCURRENT_DIFF_SYNCS);
+    }
+
+    private volatile int maxConcurrentSnapSyncs = DEFAULT_CONCURRENT_SNAPSYNCS;
+    private volatile int maxConcurrentDiffSyncs = DEFAULT_CONCURRENT_DIFF_SYNCS;
+
+    private final LearnerSyncThrottler learnerSnapSyncThrottler =
+            new LearnerSyncThrottler(maxConcurrentSnapSyncs, LearnerSyncThrottler.SyncType.SNAP);
+
+    private final LearnerSyncThrottler learnerDiffSyncThrottler =
+            new LearnerSyncThrottler(maxConcurrentDiffSyncs,LearnerSyncThrottler.SyncType.DIFF);
+
+    public int getMaxConcurrentSnapSyncs() {
+        return maxConcurrentSnapSyncs;
+    }
+
+    public void setMaxConcurrentSnapSyncs(int maxConcurrentSnapSyncs) {","[{'comment': 'I have not seen any usage of setMaxConcurrentSnapSyncs, and I am not sure how we can set different values for Leader vs ObserverMaster. How do we plan to use setMaxConcurrentSnapSyncs?', 'commenter': 'mayawang'}, {'comment': ""This function is called in FollwerBean and LeaderBean. No, we can't set different values for Leader and ObserverMaster. We did have a discussion whether to support different settings for Leader and ObserverMaster. Since we don't see a need for different settings and since we have too many flags/settings already, we decide to go with one setting for both Leader and ObserverMaster"", 'commenter': 'jhuan31'}]"
995,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerHandler.java,"@@ -968,6 +984,7 @@ protected long queueCommittedProposals(Iterator<Proposal> itr,
     public void shutdown() {
         // Send the packet of death
         try {
+            queuedPackets.clear();","[{'comment': 'This seems unrelated to this patch, but it looks the right thing to do. Just want to make sure this was not accidentally introduced.', 'commenter': 'hanm'}, {'comment': 'Good catch! It is actually added in this patch to handle diff sync throttling. Diff txns are queued in syncFollower() before the throttle. Later when we decide that this diff sync should be throttled, the txns are in the queues already so we need to remove them.', 'commenter': 'jhuan31'}]"
995,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerSyncThrottler.java,"@@ -0,0 +1,121 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import org.apache.zookeeper.common.Time;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Utility class to limit the number of concurrent syncs from a leader to
+ * observers and followers.  {@link LearnerHandler} objects should call","[{'comment': 'nit: might add ""or syncs from a follower to observers"".', 'commenter': 'hanm'}, {'comment': 'done', 'commenter': 'jhuan31'}]"
995,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerHandler.java,"@@ -505,34 +510,35 @@ public void run() {
             // startForwarding() will be called in all cases
             boolean needSnap = syncFollower(peerLastZxid, learnerMaster);
 
+            boolean exemptFromThrottle = getLearnerType() != LearnerType.OBSERVER;","[{'comment': ""I think it'll be good to add a comment here what exempt means (sync throttler will not throttle if it's true) and why we need it (IIUC, we want the quorum servers to always sync and ignore throttling because it's important to keep the state of quorum serves up to date with leader). "", 'commenter': 'hanm'}, {'comment': 'done', 'commenter': 'jhuan31'}]"
995,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerHandler.java,"@@ -603,6 +612,9 @@ public void run() {
             learnerMaster.waitForNewLeaderAck(getSid(), qp.getZxid());
 
             syncLimitCheck.start();
+            // sync ends when NEWLEADER-ACK is received
+            syncThrottler.endSync();","[{'comment': 'Is this endSync() call to be put in a finally block?', 'commenter': 'eolivelli'}, {'comment': 'endSync() is called in the finally block line 720-722, if not called earlier. ', 'commenter': 'jhuan31'}]"
995,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/LearnerSyncThrottlerTest.java,"@@ -0,0 +1,169 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+
+import org.apache.zookeeper.ZKTestCase;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@RunWith(Parameterized.class)
+public class LearnerSyncThrottlerTest extends ZKTestCase {
+    private static final Logger LOG = LoggerFactory.getLogger(LearnerSyncThrottlerTest.class);
+
+    private LearnerSyncThrottler.SyncType syncType;
+    public LearnerSyncThrottlerTest(LearnerSyncThrottler.SyncType syncType){
+        this.syncType = syncType;
+    }
+
+    @Parameterized.Parameters
+    public static Collection syncTypes() {
+        return Arrays.asList(new Object[][]{
+                {LearnerSyncThrottler.SyncType.DIFF}, {LearnerSyncThrottler.SyncType.SNAP}});
+    }
+    @Test(expected = SyncThrottleException.class)
+    public void testTooManySyncsNonessential() throws Exception {
+        LearnerSyncThrottler throttler =
+                new LearnerSyncThrottler(5, syncType);
+        for (int i = 0; i < 6; i++) {
+            throttler.beginSync(false);
+        }
+    }
+
+    @Test(expected = SyncThrottleException.class)
+    public void testTooManySyncsEssential() throws Exception {
+        LearnerSyncThrottler throttler =
+                new LearnerSyncThrottler(5, syncType);
+        try {
+            for (int i = 0; i < 6; i++) {
+                throttler.beginSync(true);
+            }
+        }
+        catch (SyncThrottleException ex) {
+            Assert.fail(""essential syncs should not be throttled"");
+        }
+        throttler.endSync();
+        throttler.beginSync(false);
+    }
+
+    @Test
+    public void testNoThrottle() throws Exception {
+        LearnerSyncThrottler throttler =
+                new LearnerSyncThrottler(5, syncType);
+        try {
+            for (int i = 0; i < 6; i++) {
+                throttler.beginSync(true);
+            }
+        }
+        catch (SyncThrottleException ex) {
+            Assert.fail(""essential syncs should not be throttled"");
+        }
+        throttler.endSync();
+        for (int i = 0; i < 5; i++) {
+            throttler.endSync();
+            throttler.beginSync(false);
+        }
+        Assert.assertTrue(""should get here without exception"", true);
+    }
+
+    @Test
+    public void testTryWithResourceNoThrottle() throws Exception {
+        LearnerSyncThrottler throttler =
+                new LearnerSyncThrottler(1, syncType);
+        for (int i = 0; i < 3; i++) {
+            throttler.beginSync(false);
+            try {
+                Assert.assertEquals(1, throttler.getSyncInProgress());
+            } finally {
+                throttler.endSync();
+            }
+        }
+    }
+
+    @Test(expected = SyncThrottleException.class)
+    public void testTryWithResourceThrottle() throws Exception {","[{'comment': ""It is not very clear that we are testing that the second call to beginSync is the one that throws the exception\r\nI suggest to use an explicit catch block and not use the 'expected' attribute"", 'commenter': 'eolivelli'}, {'comment': 'done', 'commenter': 'jhuan31'}]"
995,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/LearnerSyncThrottlerTest.java,"@@ -0,0 +1,169 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+
+import org.apache.zookeeper.ZKTestCase;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@RunWith(Parameterized.class)
+public class LearnerSyncThrottlerTest extends ZKTestCase {
+    private static final Logger LOG = LoggerFactory.getLogger(LearnerSyncThrottlerTest.class);
+
+    private LearnerSyncThrottler.SyncType syncType;
+    public LearnerSyncThrottlerTest(LearnerSyncThrottler.SyncType syncType){
+        this.syncType = syncType;
+    }
+
+    @Parameterized.Parameters
+    public static Collection syncTypes() {
+        return Arrays.asList(new Object[][]{
+                {LearnerSyncThrottler.SyncType.DIFF}, {LearnerSyncThrottler.SyncType.SNAP}});
+    }
+    @Test(expected = SyncThrottleException.class)
+    public void testTooManySyncsNonessential() throws Exception {
+        LearnerSyncThrottler throttler =
+                new LearnerSyncThrottler(5, syncType);
+        for (int i = 0; i < 6; i++) {
+            throttler.beginSync(false);
+        }
+    }
+
+    @Test(expected = SyncThrottleException.class)
+    public void testTooManySyncsEssential() throws Exception {
+        LearnerSyncThrottler throttler =
+                new LearnerSyncThrottler(5, syncType);
+        try {
+            for (int i = 0; i < 6; i++) {
+                throttler.beginSync(true);
+            }
+        }
+        catch (SyncThrottleException ex) {
+            Assert.fail(""essential syncs should not be throttled"");
+        }
+        throttler.endSync();
+        throttler.beginSync(false);
+    }
+
+    @Test
+    public void testNoThrottle() throws Exception {
+        LearnerSyncThrottler throttler =
+                new LearnerSyncThrottler(5, syncType);
+        try {
+            for (int i = 0; i < 6; i++) {
+                throttler.beginSync(true);
+            }
+        }
+        catch (SyncThrottleException ex) {
+            Assert.fail(""essential syncs should not be throttled"");
+        }
+        throttler.endSync();
+        for (int i = 0; i < 5; i++) {
+            throttler.endSync();
+            throttler.beginSync(false);
+        }
+        Assert.assertTrue(""should get here without exception"", true);
+    }
+
+    @Test
+    public void testTryWithResourceNoThrottle() throws Exception {
+        LearnerSyncThrottler throttler =
+                new LearnerSyncThrottler(1, syncType);
+        for (int i = 0; i < 3; i++) {
+            throttler.beginSync(false);
+            try {
+                Assert.assertEquals(1, throttler.getSyncInProgress());
+            } finally {
+                throttler.endSync();
+            }
+        }
+    }
+
+    @Test(expected = SyncThrottleException.class)
+    public void testTryWithResourceThrottle() throws Exception {
+        LearnerSyncThrottler throttler =
+                new LearnerSyncThrottler(1, syncType);
+        throttler.beginSync(true);
+        try {
+            throttler.beginSync(false);
+            try {
+                Assert.fail(""shouldn't be able to have both syncs open"");
+            } finally {
+                throttler.endSync();
+            }
+        } finally {
+            throttler.endSync();
+        }
+    }
+
+    @Test
+    public void testParallelNoThrottle() throws Exception {
+        final int numThreads = 50;
+
+        final LearnerSyncThrottler throttler =
+                new LearnerSyncThrottler(numThreads, syncType);
+        ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);","[{'comment': 'Please shutdown this pool in a finally block', 'commenter': 'eolivelli'}, {'comment': 'done', 'commenter': 'jhuan31'}]"
1003,zookeeper-server/src/main/java/org/apache/zookeeper/common/StandardTypeFileKeyStoreLoader.java,"@@ -0,0 +1,91 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+
+/**
+ * Base class for instances of {@link KeyStoreLoader} which load the key/trust
+ * stores from files on a filesystem using standard {@link KeyStore} types like
+ * JKS or PKCS12.
+ */
+abstract class StandardTypeFileKeyStoreLoader extends FileKeyStoreLoader {
+    private static final Logger LOG = LoggerFactory.getLogger(StandardTypeFileKeyStoreLoader.class);
+
+    private static final char[] EMPTY_CHAR_ARRAY = new char[0];
+
+    StandardTypeFileKeyStoreLoader(String keyStorePath,
+                                   String trustStorePath,
+                                   String keyStorePassword,
+                                   String trustStorePassword) {
+        super(keyStorePath, trustStorePath, keyStorePassword, trustStorePassword);
+    }
+
+    @Override
+    public KeyStore loadKeyStore() throws IOException, GeneralSecurityException {
+        KeyStore ks = keyStoreInstance();
+        InputStream inputStream = null;","[{'comment': 'We can use try-with-resources now.\r\nI know this is only a refactoring but we can take this opportunity to clean up code', 'commenter': 'eolivelli'}, {'comment': 'The propagation of `IOException`s on `close()` is prevented (only logging is done), in contrast to other `IOException`s. I guess we need to keep this behaviour, right?\r\nIf so, try-with-resources doesn\'t appear beneficial to me. For instance, this might be the code:\r\n```java\r\ntry (InputStream inputStream = new FileInputStream(new File(trustStorePath))) {\r\n    ts.load(inputStream, passwordStringToCharArray(trustStorePassword));\r\n    return ts;\r\n} catch (IOException e) {\r\n    // some cumbersome logic to differentiate IOExceptions\r\n    boolean isExceptionOnClose = ...;\r\n    if (isExceptionOnClose) {\r\n        LOG.info(""Failed to close key store input stream"", e);\r\n    } else {\r\n        throw e;\r\n    }\r\n}\r\n```\r\nOr I\'m missing something?', 'commenter': 'ivanyu'}, {'comment': ""@ivanyu I see your point and I thought about it before adding this comment, thank you for pointing it out explicitly.\r\nAn exception on close() is really unexpected and it is a symptom of a weird status of the system  (and we can end with open FD leaks...)\r\n\r\nSo I don't see much value in keeping the method exiting normally when there is something bad going on.\r\n\r\nAs a counterpart the try-with-resources is a cleaner syntax.\r\n\r\nIt is just nitpicking, it is not a blocker for this change to be merged.\r\n\r\nHow does it sound to you ?"", 'commenter': 'eolivelli'}, {'comment': ""I totally share this idea about making the methods fail explicitly if closing fails. So I've changed to try-with-resources."", 'commenter': 'ivanyu'}]"
1003,zookeeper-server/src/main/java/org/apache/zookeeper/common/StandardTypeFileKeyStoreLoader.java,"@@ -0,0 +1,91 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+
+/**
+ * Base class for instances of {@link KeyStoreLoader} which load the key/trust
+ * stores from files on a filesystem using standard {@link KeyStore} types like
+ * JKS or PKCS12.
+ */
+abstract class StandardTypeFileKeyStoreLoader extends FileKeyStoreLoader {
+    private static final Logger LOG = LoggerFactory.getLogger(StandardTypeFileKeyStoreLoader.class);
+
+    private static final char[] EMPTY_CHAR_ARRAY = new char[0];
+
+    StandardTypeFileKeyStoreLoader(String keyStorePath,
+                                   String trustStorePath,
+                                   String keyStorePassword,
+                                   String trustStorePassword) {
+        super(keyStorePath, trustStorePath, keyStorePassword, trustStorePassword);
+    }
+
+    @Override
+    public KeyStore loadKeyStore() throws IOException, GeneralSecurityException {
+        KeyStore ks = keyStoreInstance();
+        InputStream inputStream = null;
+        try {
+            inputStream = new FileInputStream(new File(keyStorePath));
+            ks.load(inputStream, passwordStringToCharArray(keyStorePassword));
+            return ks;
+        } finally {
+            forceClose(inputStream);
+        }
+    }
+
+    @Override
+    public KeyStore loadTrustStore() throws IOException, GeneralSecurityException {
+        KeyStore ts = keyStoreInstance();
+        InputStream inputStream = null;
+        try {
+            inputStream = new FileInputStream(new File(trustStorePath));
+            ts.load(inputStream, passwordStringToCharArray(trustStorePassword));
+            return ts;
+        } finally {
+            forceClose(inputStream);
+        }
+    }
+
+    protected abstract KeyStore keyStoreInstance() throws KeyStoreException;
+
+    private char[] passwordStringToCharArray(String password) {","[{'comment': 'Nit: static', 'commenter': 'eolivelli'}]"
1003,zookeeper-server/src/test/java/org/apache/zookeeper/common/X509TestContext.java,"@@ -214,6 +219,28 @@ private File getTrustStorePemFile() throws IOException {
         return trustStorePemFile;
     }
 
+    private File getTrustStorePkcs12File() throws IOException {
+        if (trustStorePkcs12File == null) {
+            try {
+                File trustStorePkcs12File = File.createTempFile(
+                    TRUST_STORE_PREFIX, KeyStoreFileType.PKCS12.getDefaultFileExtension(), tempDir);
+                trustStorePkcs12File.deleteOnExit();
+                final FileOutputStream trustStoreOutputStream = new FileOutputStream(trustStorePkcs12File);","[{'comment': 'Use try-with-resources (change all the file)', 'commenter': 'eolivelli'}, {'comment': 'Done in this file. Also checked other files, all except for `StandardTypeFileKeyStoreLoader`, which is being discussed https://github.com/apache/zookeeper/pull/1003#discussion_r297314763', 'commenter': 'ivanyu'}]"
1019,pom.xml,"@@ -582,19 +582,20 @@
               <version>${checkstyle.version}</version>
             </dependency>
           </dependencies>
-          <configuration>
-            <configLocation>checkstyle.xml</configLocation>
-            <suppressionsLocation>checkstyleSuppressions.xml</suppressionsLocation>
-            <encoding>UTF-8</encoding>
-            <consoleOutput>true</consoleOutput>
-            <failOnViolation>true</failOnViolation>
-            <includeResources>false</includeResources>
-            <includeTestSourceDirectory>true</includeTestSourceDirectory>
-          </configuration>
           <executions>
             <execution>
               <id>checkstyle</id>
               <phase>validate</phase>
+              <configuration>
+                <configLocation>checkstyle.xml</configLocation>","[{'comment': ""this way you are disabling the minimal checkstyle configuration I added to prevent the presence of '@author' tags.\r\nAs your new configuration is applied only to some limited list of packages you are implicitly disabling that check on a part of the codebase.\r\n\r\nPlease  add a new   '<execution>' of the plugin with your new checkstyle.xml and checkstyleSuppressions.xml\r\n\r\nPlease test manually that if you add a '@author' javadoc tag anywhere in code the PR validation fails\r\n"", 'commenter': 'eolivelli'}, {'comment': ""@eolivelli \r\n- Done.use the separate `checkstyle-strict.xml` for the `zookeeper-server` module.\r\n- I check that our code base doesn't have the **'@author'** tag"", 'commenter': 'maoling'}, {'comment': 'It is reasonable to use a `checkstyle-strict.xml` covering the simple config in pkgs we want to enable more rules.\r\n\r\nFor ""I check that our code base doesn\'t have the \'@author\' tag"", I think you should also test if a \'@author\' tag exists, the build fails with correct reason.', 'commenter': 'tisonkun'}, {'comment': '- @TisonKun  Thanks for the notice.\r\n- I check the rule for the ""the \'@author\' tag"" \r\n\r\n> <module name=""TodoComment"">\r\n            <!-- Checks that disallowed strings are not used in comments.  -->\r\n            <property name=""format"" value=""(@author)"" />\r\n        </module>\r\n\r\nand found it doesn\'t work.search around and don\'t find a valid way to enforce no `author` tag in the javaDoc.Cc @eolivelli ', 'commenter': 'maoling'}, {'comment': ""Hi @maoling , you can try out enable the former simple checkstyle configuration in parent pom.xml and enable strict checkstyle configuration in, for example, zookeeper-server pkg. Make sure the strict checkstyle configuration contains rules in the simple one including forbid '@author' tag. I would provide a patch you can make use of in this week if you stuck."", 'commenter': 'tisonkun'}, {'comment': '@TisonKun \r\nNothing can make me get stuck, except the beautiful girls;)', 'commenter': 'maoling'}, {'comment': '@maoling you can take a look at ZOOKEEPER-3465 and #1022 #1023 where I show you how to enable checkstyle configuration per pkg and why I stand ""no need"" for extra suppression configuration. \r\n\r\nYou can rebase the subtasks enable it on zookeeper-server(i.e., this thread) on #1022 . Feel free to share you opinion because I did change the checkstyle configuration choice.', 'commenter': 'tisonkun'}]"
1020,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -619,14 +619,21 @@ public void toSend(Long sid, ByteBuffer b) {
              /*
               * Start a new connection if doesn't have one already.
               */
-             ArrayBlockingQueue<ByteBuffer> bq = new ArrayBlockingQueue<ByteBuffer>(
+             /*ArrayBlockingQueue<ByteBuffer> bq = new ArrayBlockingQueue<ByteBuffer>(","[{'comment': ""Please don't push commented out code. That's what git is for, to keep history."", 'commenter': 'nkalmar'}]"
1023,checkstyleSuppressions.xml,"@@ -21,5 +21,5 @@
     <suppress checks="".*"" files="".+[\\/]generated[\\/].+\.java"" />
     <suppress checks="".*"" files="".+[\\/]generated-sources[\\/].+\.java"" />
     <suppress checks="".*"" files="".+[\\/]generated-test-sources[\\/].+\.java"" />
-
+    <suppress checks=""LineLength"" files="".+[\\/]jute[\\/].+\.java""/>","[{'comment': 'This is added because for code generation we have to write some lines quite long and break them down actually turns into worse readability.', 'commenter': 'tisonkun'}]"
1023,zookeeper-jute/src/main/java/org/apache/jute/RecordReader.java,"@@ -1,14 +1,14 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * ""License""); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>","[{'comment': 'I am not sure that we need to change license headers', 'commenter': 'eolivelli'}, {'comment': ""I am sorry that I don't understand. Could you explain it in detail?"", 'commenter': 'tisonkun'}, {'comment': ""Sorry I meant 'I am not sure...'\r\nI have fixed my comment.\r\nSuch headers are not javadocs, it is not HTML so we do not need HTML tags"", 'commenter': 'eolivelli'}, {'comment': 'I agree with you. This is occasionally modified when I auto format the file. Let me revert it...', 'commenter': 'tisonkun'}]"
1023,zookeeper-jute/src/main/java/org/apache/jute/BinaryInputArchive.java,"@@ -22,108 +22,124 @@
 import java.io.DataInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
 
 /**
  *","[{'comment': ""Don't we have a rule about javadocs of public classes?"", 'commenter': 'eolivelli'}, {'comment': 'Yes we have. If we remove this placeholder checkstyle would fail on\r\n\r\n>[ERROR] /Users/chenzili/IdeaProjects/zookeeper/zookeeper-jute/src/main/java/org/apache/jute/BinaryInputArchive.java:28: Missing a Javadoc comment. [JavadocType]\r\n\r\nHowever, it just checks whether or not there is a javadoc.\r\n\r\nIf you want to forbid empty javadoc as well, we can enable \r\n\r\n```\r\n<module name=""JavadocStyle"">\r\n  <property name=""checkEmptyJavadoc"" value=""true""/>\r\n</module>\r\n```\r\n\r\nBut I\'m afraid it would be not easy to add proper javadoc in this pass. We can file another JIRA fixing all empty javadoc and enable this property. WDYT?', 'commenter': 'tisonkun'}, {'comment': 'Otherwise we can enable it in this pass and set javadoc placeholder. Now I think it would be better and update accordingly.', 'commenter': 'tisonkun'}, {'comment': 'I think we can fix javadocs in a second pass.\r\nThis first pass should be as much manual as possible', 'commenter': 'eolivelli'}]"
1023,zookeeper-jute/src/main/java/org/apache/jute/BinaryInputArchive.java,"@@ -22,108 +22,124 @@
 import java.io.DataInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
 
 /**
  *
  */
 public class BinaryInputArchive implements InputArchive {
-    static public final String UNREASONBLE_LENGTH= ""Unreasonable length = "";
+
+    public static final String UNREASONBLE_LENGTH = ""Unreasonable length = "";
+    public static final int MAX_BUFFER = Integer.getInteger(""jute.maxbuffer"", 0xfffff);
+
     private DataInput in;
-    
-    static public BinaryInputArchive getArchive(InputStream strm) {
+
+    public static BinaryInputArchive getArchive(InputStream strm) {
         return new BinaryInputArchive(new DataInputStream(strm));
     }
-    
-    static private class BinaryIndex implements Index {
+
+    private static class BinaryIndex implements Index {
         private int nelems;
+
         BinaryIndex(int nelems) {
             this.nelems = nelems;
         }
+
         public boolean done() {
             return (nelems <= 0);
         }
+
         public void incr() {
             nelems--;
         }
     }
-    /** Creates a new instance of BinaryInputArchive */
+
+    /**
+     * Creates a new instance of BinaryInputArchive.
+     */
     public BinaryInputArchive(DataInput in) {
         this.in = in;
     }
-    
+
     public byte readByte(String tag) throws IOException {
         return in.readByte();
     }
-    
+
     public boolean readBool(String tag) throws IOException {
         return in.readBoolean();
     }
-    
+
     public int readInt(String tag) throws IOException {
         return in.readInt();
     }
-    
+
     public long readLong(String tag) throws IOException {
         return in.readLong();
     }
-    
+
     public float readFloat(String tag) throws IOException {
         return in.readFloat();
     }
-    
+
     public double readDouble(String tag) throws IOException {
         return in.readDouble();
     }
-    
+
     public String readString(String tag) throws IOException {
-    	int len = in.readInt();
-    	if (len == -1) return null;
+        int len = in.readInt();
+        if (len == -1) {
+            return null;
+        }
         checkLength(len);
-    	byte b[] = new byte[len];
-    	in.readFully(b);
-    	return new String(b, ""UTF8"");
+        byte[] b = new byte[len];
+        in.readFully(b);
+        return new String(b, StandardCharsets.UTF_8);
     }
-    
-    static public final int maxBuffer = Integer.getInteger(""jute.maxbuffer"", 0xfffff);","[{'comment': ""We can't rename a 'public static final' constant.\r\nIt is an API break we can create an issue to gather all the changes that we are not doing because we can't.\r\nWe have to keep code 100% compatible with the prev version\r\nYou should add a suppression (there is a way to add a directive in source code 'CHECKSTYLE OFF'\r\n"", 'commenter': 'eolivelli'}, {'comment': 'Yes, I will update.', 'commenter': 'tisonkun'}]"
1027,zookeeper-server/src/test/java/org/apache/zookeeper/server/NettyServerCnxnFactoryTest.java,"@@ -0,0 +1,120 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.common.ClientX509Util;
+import org.apache.zookeeper.server.metric.SimpleCounter;
+import org.apache.zookeeper.test.ClientBase;
+import org.apache.zookeeper.test.SSLAuthTest;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class NettyServerCnxnFactoryTest extends ClientBase {
+
+    private static final Logger LOG = LoggerFactory
+            .getLogger(NettyServerCnxnFactoryTest.class);
+
+    @Override
+    public void setUp() throws Exception {
+        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY,","[{'comment': 'we need to reset this property in a @Before block', 'commenter': 'eolivelli'}, {'comment': ""I guess you mean at the @After teardown block, right? I'll add that."", 'commenter': 'lvfangmin'}, {'comment': 'Yep! Sorry', 'commenter': 'eolivelli'}]"
1027,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -915,6 +915,14 @@ property, when available, is noted below.
     ZooKeeper when loading database from disk, and syncing with leader.
     By default, this feautre is disabled, set ""true"" to enable it.
 
+* *outstandingHandshake.limit* ","[{'comment': 'Sounds like something that should be turned on all the time with some meaningful default value. What do you think about setting it to 250 by default and let this property to override it.', 'commenter': 'anmolnar'}, {'comment': ""This feature hasn't been fully rollout internally, I would suggest to enable this by default, when we verified on our internal environment for a while, so if there is bug we can find it and fix it before its affecting the community."", 'commenter': 'lvfangmin'}, {'comment': ""This is a master-only patch which doesn't even have an alpha-release, so I believe we could be a little bit more flexible about that, but I'm also happy with leaving it off."", 'commenter': 'anmolnar'}]"
1027,zookeeper-server/src/test/java/org/apache/zookeeper/server/NettyServerCnxnFactoryTest.java,"@@ -0,0 +1,121 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.common.ClientX509Util;
+import org.apache.zookeeper.server.metric.SimpleCounter;
+import org.apache.zookeeper.test.ClientBase;
+import org.apache.zookeeper.test.SSLAuthTest;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class NettyServerCnxnFactoryTest extends ClientBase {
+
+    private static final Logger LOG = LoggerFactory
+            .getLogger(NettyServerCnxnFactoryTest.class);
+
+    @Override
+    public void setUp() throws Exception {
+        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY,
+                ""org.apache.zookeeper.server.NettyServerCnxnFactory"");
+        super.setUp();
+    }
+
+    @Override
+    public void tearDown() throws Exception {
+        System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);
+        super.tearDown();
+    }
+
+    @Test
+    public void testOutstandingHandshakeLimit() throws Exception {
+
+        SimpleCounter tlsHandshakeExceeded = (SimpleCounter) ServerMetrics.getMetrics().TLS_HANDSHAKE_EXCEEDED;
+        tlsHandshakeExceeded.reset();
+        Assert.assertEquals(tlsHandshakeExceeded.get(), 0);
+
+        ClientX509Util x509Util = SSLAuthTest.setUpSecure();
+        NettyServerCnxnFactory factory = (NettyServerCnxnFactory) serverFactory;
+        factory.setSecure(true);
+        factory.setOutstandingHandshakeLimit(10);
+
+        int threadNum = 3;
+        int cnxnPerThread = 10;
+        Thread[] cnxnWorker = new Thread[threadNum];
+        final LinkedBlockingQueue<ZooKeeper> zks = new LinkedBlockingQueue<ZooKeeper>();
+
+        AtomicInteger cnxnCreated = new AtomicInteger(0);
+        CountDownLatch latch = new CountDownLatch(1);
+
+        for (int i = 0; i < cnxnWorker.length; i++) {
+            cnxnWorker[i] = new Thread() {
+                @Override
+                public void run() {
+                    for (int i = 0; i < cnxnPerThread; i++) {
+                        try {
+                            zks.add(new ZooKeeper(hostPort, 3000, new Watcher() {
+                                @Override
+                                public void process(WatchedEvent event) {
+                                    int created = cnxnCreated.addAndGet(1);
+                                    if (created == threadNum * cnxnPerThread) {
+                                        latch.countDown();
+                                    }
+                                }
+                            }));
+                        } catch (Exception e) {
+                            LOG.info(""Error while creating zk client"", e);
+                        }
+                    }
+                }
+            };
+            cnxnWorker[i].start();
+        }
+
+        Assert.assertTrue(latch.await(3, TimeUnit.SECONDS));
+        LOG.info(""created {} connections"", threadNum * cnxnPerThread);
+
+        // Assert throttling not 0
+        long handshakeThrottledNum = tlsHandshakeExceeded.get();
+        LOG.info(""TLS_HANDSHAKE_EXCEEDED: {}"", handshakeThrottledNum);
+        Assert.assertTrue(handshakeThrottledNum > 0);
+
+        // Assert there is no outstanding handshake anymore
+        int outstandingHandshakeNum = factory.getOutstandingHandshakeNum();
+        LOG.info(""outstanding handshake is {}"", outstandingHandshakeNum);
+        Assert.assertTrue(outstandingHandshakeNum == 0);
+
+        // clean up","[{'comment': 'Put the cleanup in the `tearDown` method.', 'commenter': 'anmolnar'}]"
1027,zookeeper-server/src/test/java/org/apache/zookeeper/server/NettyServerCnxnFactoryTest.java,"@@ -0,0 +1,121 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.common.ClientX509Util;
+import org.apache.zookeeper.server.metric.SimpleCounter;
+import org.apache.zookeeper.test.ClientBase;
+import org.apache.zookeeper.test.SSLAuthTest;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class NettyServerCnxnFactoryTest extends ClientBase {
+
+    private static final Logger LOG = LoggerFactory","[{'comment': 'Why do you use logging in tests?', 'commenter': 'anmolnar'}, {'comment': 'To print the useful information which is useful for debugging unexpected test behavior. Do you suggest to use System.out ?', 'commenter': 'lvfangmin'}, {'comment': ""I usually don't output anything in (unit)tests, but feel free to leave it there if it's comfortable."", 'commenter': 'anmolnar'}]"
1027,zookeeper-server/src/test/java/org/apache/zookeeper/server/NettyServerCnxnFactoryTest.java,"@@ -0,0 +1,121 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.common.ClientX509Util;
+import org.apache.zookeeper.server.metric.SimpleCounter;
+import org.apache.zookeeper.test.ClientBase;
+import org.apache.zookeeper.test.SSLAuthTest;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class NettyServerCnxnFactoryTest extends ClientBase {
+
+    private static final Logger LOG = LoggerFactory
+            .getLogger(NettyServerCnxnFactoryTest.class);
+
+    @Override
+    public void setUp() throws Exception {
+        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY,
+                ""org.apache.zookeeper.server.NettyServerCnxnFactory"");
+        super.setUp();
+    }
+
+    @Override
+    public void tearDown() throws Exception {
+        System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);
+        super.tearDown();
+    }
+
+    @Test
+    public void testOutstandingHandshakeLimit() throws Exception {
+
+        SimpleCounter tlsHandshakeExceeded = (SimpleCounter) ServerMetrics.getMetrics().TLS_HANDSHAKE_EXCEEDED;
+        tlsHandshakeExceeded.reset();
+        Assert.assertEquals(tlsHandshakeExceeded.get(), 0);
+
+        ClientX509Util x509Util = SSLAuthTest.setUpSecure();
+        NettyServerCnxnFactory factory = (NettyServerCnxnFactory) serverFactory;
+        factory.setSecure(true);
+        factory.setOutstandingHandshakeLimit(10);
+
+        int threadNum = 3;
+        int cnxnPerThread = 10;
+        Thread[] cnxnWorker = new Thread[threadNum];
+        final LinkedBlockingQueue<ZooKeeper> zks = new LinkedBlockingQueue<ZooKeeper>();
+
+        AtomicInteger cnxnCreated = new AtomicInteger(0);
+        CountDownLatch latch = new CountDownLatch(1);
+
+        for (int i = 0; i < cnxnWorker.length; i++) {
+            cnxnWorker[i] = new Thread() {
+                @Override
+                public void run() {
+                    for (int i = 0; i < cnxnPerThread; i++) {
+                        try {
+                            zks.add(new ZooKeeper(hostPort, 3000, new Watcher() {
+                                @Override
+                                public void process(WatchedEvent event) {
+                                    int created = cnxnCreated.addAndGet(1);
+                                    if (created == threadNum * cnxnPerThread) {
+                                        latch.countDown();
+                                    }
+                                }
+                            }));
+                        } catch (Exception e) {
+                            LOG.info(""Error while creating zk client"", e);
+                        }
+                    }
+                }
+            };
+            cnxnWorker[i].start();
+        }
+
+        Assert.assertTrue(latch.await(3, TimeUnit.SECONDS));","[{'comment': 'Please use `assertThat`.', 'commenter': 'anmolnar'}, {'comment': 'There is no additional information about the result of latch.await, so I think assertTrue is good enough.', 'commenter': 'lvfangmin'}, {'comment': 'Not the end of the world, but I always use assertThat(...) in tests for convenience. Apart from that I find it very beneficial to add some helpful error message explaining what the problem was if assertion failed.', 'commenter': 'anmolnar'}, {'comment': ""In this case: znodes haven't been created within timeout"", 'commenter': 'anmolnar'}, {'comment': ""That's a good suggestion, I've changed to use assertThat, will add the description as well."", 'commenter': 'lvfangmin'}]"
1027,zookeeper-server/src/test/java/org/apache/zookeeper/server/NettyServerCnxnFactoryTest.java,"@@ -0,0 +1,121 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.common.ClientX509Util;
+import org.apache.zookeeper.server.metric.SimpleCounter;
+import org.apache.zookeeper.test.ClientBase;
+import org.apache.zookeeper.test.SSLAuthTest;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class NettyServerCnxnFactoryTest extends ClientBase {
+
+    private static final Logger LOG = LoggerFactory
+            .getLogger(NettyServerCnxnFactoryTest.class);
+
+    @Override
+    public void setUp() throws Exception {
+        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY,
+                ""org.apache.zookeeper.server.NettyServerCnxnFactory"");
+        super.setUp();
+    }
+
+    @Override
+    public void tearDown() throws Exception {
+        System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);
+        super.tearDown();
+    }
+
+    @Test
+    public void testOutstandingHandshakeLimit() throws Exception {
+
+        SimpleCounter tlsHandshakeExceeded = (SimpleCounter) ServerMetrics.getMetrics().TLS_HANDSHAKE_EXCEEDED;
+        tlsHandshakeExceeded.reset();
+        Assert.assertEquals(tlsHandshakeExceeded.get(), 0);
+
+        ClientX509Util x509Util = SSLAuthTest.setUpSecure();
+        NettyServerCnxnFactory factory = (NettyServerCnxnFactory) serverFactory;
+        factory.setSecure(true);
+        factory.setOutstandingHandshakeLimit(10);
+
+        int threadNum = 3;
+        int cnxnPerThread = 10;
+        Thread[] cnxnWorker = new Thread[threadNum];
+        final LinkedBlockingQueue<ZooKeeper> zks = new LinkedBlockingQueue<ZooKeeper>();
+
+        AtomicInteger cnxnCreated = new AtomicInteger(0);
+        CountDownLatch latch = new CountDownLatch(1);
+
+        for (int i = 0; i < cnxnWorker.length; i++) {
+            cnxnWorker[i] = new Thread() {
+                @Override
+                public void run() {
+                    for (int i = 0; i < cnxnPerThread; i++) {
+                        try {
+                            zks.add(new ZooKeeper(hostPort, 3000, new Watcher() {
+                                @Override
+                                public void process(WatchedEvent event) {
+                                    int created = cnxnCreated.addAndGet(1);
+                                    if (created == threadNum * cnxnPerThread) {
+                                        latch.countDown();
+                                    }
+                                }
+                            }));
+                        } catch (Exception e) {
+                            LOG.info(""Error while creating zk client"", e);
+                        }
+                    }
+                }
+            };
+            cnxnWorker[i].start();
+        }
+
+        Assert.assertTrue(latch.await(3, TimeUnit.SECONDS));
+        LOG.info(""created {} connections"", threadNum * cnxnPerThread);
+
+        // Assert throttling not 0
+        long handshakeThrottledNum = tlsHandshakeExceeded.get();
+        LOG.info(""TLS_HANDSHAKE_EXCEEDED: {}"", handshakeThrottledNum);
+        Assert.assertTrue(handshakeThrottledNum > 0);","[{'comment': 'Same here.', 'commenter': 'anmolnar'}, {'comment': 'Will do.', 'commenter': 'lvfangmin'}]"
1027,zookeeper-server/src/test/java/org/apache/zookeeper/server/NettyServerCnxnFactoryTest.java,"@@ -0,0 +1,121 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.common.ClientX509Util;
+import org.apache.zookeeper.server.metric.SimpleCounter;
+import org.apache.zookeeper.test.ClientBase;
+import org.apache.zookeeper.test.SSLAuthTest;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class NettyServerCnxnFactoryTest extends ClientBase {
+
+    private static final Logger LOG = LoggerFactory
+            .getLogger(NettyServerCnxnFactoryTest.class);
+
+    @Override
+    public void setUp() throws Exception {
+        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY,
+                ""org.apache.zookeeper.server.NettyServerCnxnFactory"");
+        super.setUp();
+    }
+
+    @Override
+    public void tearDown() throws Exception {
+        System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);
+        super.tearDown();
+    }
+
+    @Test
+    public void testOutstandingHandshakeLimit() throws Exception {
+
+        SimpleCounter tlsHandshakeExceeded = (SimpleCounter) ServerMetrics.getMetrics().TLS_HANDSHAKE_EXCEEDED;
+        tlsHandshakeExceeded.reset();
+        Assert.assertEquals(tlsHandshakeExceeded.get(), 0);
+
+        ClientX509Util x509Util = SSLAuthTest.setUpSecure();
+        NettyServerCnxnFactory factory = (NettyServerCnxnFactory) serverFactory;
+        factory.setSecure(true);
+        factory.setOutstandingHandshakeLimit(10);
+
+        int threadNum = 3;
+        int cnxnPerThread = 10;
+        Thread[] cnxnWorker = new Thread[threadNum];
+        final LinkedBlockingQueue<ZooKeeper> zks = new LinkedBlockingQueue<ZooKeeper>();
+
+        AtomicInteger cnxnCreated = new AtomicInteger(0);
+        CountDownLatch latch = new CountDownLatch(1);
+
+        for (int i = 0; i < cnxnWorker.length; i++) {
+            cnxnWorker[i] = new Thread() {
+                @Override
+                public void run() {
+                    for (int i = 0; i < cnxnPerThread; i++) {
+                        try {
+                            zks.add(new ZooKeeper(hostPort, 3000, new Watcher() {
+                                @Override
+                                public void process(WatchedEvent event) {
+                                    int created = cnxnCreated.addAndGet(1);
+                                    if (created == threadNum * cnxnPerThread) {
+                                        latch.countDown();
+                                    }
+                                }
+                            }));
+                        } catch (Exception e) {
+                            LOG.info(""Error while creating zk client"", e);
+                        }
+                    }
+                }
+            };
+            cnxnWorker[i].start();
+        }
+
+        Assert.assertTrue(latch.await(3, TimeUnit.SECONDS));
+        LOG.info(""created {} connections"", threadNum * cnxnPerThread);
+
+        // Assert throttling not 0
+        long handshakeThrottledNum = tlsHandshakeExceeded.get();
+        LOG.info(""TLS_HANDSHAKE_EXCEEDED: {}"", handshakeThrottledNum);
+        Assert.assertTrue(handshakeThrottledNum > 0);
+
+        // Assert there is no outstanding handshake anymore
+        int outstandingHandshakeNum = factory.getOutstandingHandshakeNum();
+        LOG.info(""outstanding handshake is {}"", outstandingHandshakeNum);
+        Assert.assertTrue(outstandingHandshakeNum == 0);","[{'comment': '...and here', 'commenter': 'anmolnar'}]"
1028,zookeeper-metrics-providers/pom.xml,"@@ -37,4 +37,41 @@
     <module>zookeeper-prometheus-metrics</module>
   </modules>
 
+  <build>
+    <pluginManagement>
+      <plugins>
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-checkstyle-plugin</artifactId>
+          <version>3.0.0</version>","[{'comment': '3.1.0 please', 'commenter': 'eolivelli'}, {'comment': 'Also updated maven-checkstyle-plugin version in pom.xml and zookeeper-jute/pom.xml', 'commenter': 'tisonkun'}]"
1037,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -608,7 +610,11 @@ public synchronized void startup() {
         registerMetrics();
 
         setState(State.RUNNING);
+
         requestPathMetricsCollector.start();
+
+        localSessionEnabled = sessionTracker instanceof UpgradeableSessionTracker","[{'comment': ""this 'instanceof' looks like a 'code smell'\r\nwhat about adding a isLocalSessionsEnabled method to the base class (SessionTracker) with a default return value of 'false' ?\r\n\r\n"", 'commenter': 'eolivelli'}, {'comment': 'Yeap, makes sense. changes made.', 'commenter': 'jhuan31'}]"
1037,zookeeper-server/src/main/java/org/apache/zookeeper/server/BlueThrottle.java,"@@ -86,36 +90,106 @@
     Random rng;
 
     public static final String CONNECTION_THROTTLE_TOKENS = ""zookeeper.connection_throttle_tokens"";
-    public static final int DEFAULT_CONNECTION_THROTTLE_TOKENS;
+    private static final int DEFAULT_CONNECTION_THROTTLE_TOKENS;
 
     public static final String CONNECTION_THROTTLE_FILL_TIME = ""zookeeper.connection_throttle_fill_time"";
-    public static final int DEFAULT_CONNECTION_THROTTLE_FILL_TIME;
+    private static final int DEFAULT_CONNECTION_THROTTLE_FILL_TIME;
 
     public static final String CONNECTION_THROTTLE_FILL_COUNT = ""zookeeper.connection_throttle_fill_count"";
-    public static final int DEFAULT_CONNECTION_THROTTLE_FILL_COUNT;
+    private static final int DEFAULT_CONNECTION_THROTTLE_FILL_COUNT;
 
     public static final String CONNECTION_THROTTLE_FREEZE_TIME = ""zookeeper.connection_throttle_freeze_time"";
-    public static final int DEFAULT_CONNECTION_THROTTLE_FREEZE_TIME;
+    private static final int DEFAULT_CONNECTION_THROTTLE_FREEZE_TIME;
 
     public static final String CONNECTION_THROTTLE_DROP_INCREASE = ""zookeeper.connection_throttle_drop_increase"";
-    public static final double DEFAULT_CONNECTION_THROTTLE_DROP_INCREASE;
+    private static final double DEFAULT_CONNECTION_THROTTLE_DROP_INCREASE;
 
     public static final String CONNECTION_THROTTLE_DROP_DECREASE = ""zookeeper.connection_throttle_drop_decrease"";
-    public static final double DEFAULT_CONNECTION_THROTTLE_DROP_DECREASE;
+    private static final double DEFAULT_CONNECTION_THROTTLE_DROP_DECREASE;
 
     public static final String CONNECTION_THROTTLE_DECREASE_RATIO = ""zookeeper.connection_throttle_decrease_ratio"";
-    public static final double DEFAULT_CONNECTION_THROTTLE_DECREASE_RATIO;
+    private static final double DEFAULT_CONNECTION_THROTTLE_DECREASE_RATIO;
+
+    public static final String WEIGHED_CONNECTION_THROTTLE = ""zookeeper.connection_throttle_weight_enabled"";
+    private static boolean connectionWeightEnabled;
+
+    public static final String GLOBAL_SESSION_WEIGHT = ""zookeeper.connection_throttle_global_session_weight"";
+    private static final int DEFAULT_GLOBAL_SESSION_WEIGHT;
+
+    public static final String LOCAL_SESSION_WEIGHT = ""zookeeper.connection_throttle_local_session_weight"";
+    private static final int DEFAULT_LOCAL_SESSION_WEIGHT;
 
+    public static final String RENEW_SESSION_WEIGHT = ""zookeeper.connection_throttle_renew_session_weight"";
+    private static final int DEFAULT_RENEW_SESSION_WEIGHT;
+
+    // for unit tests only
+    protected  static void setConnectionWeightEnabled(boolean enabled) {
+        connectionWeightEnabled = enabled;
+        logWeighedThrottlingSetting();
+    }
+
+    private static void logWeighedThrottlingSetting() {
+        if (connectionWeightEnabled) {
+            LOG.info(""Weighed connection throttling is enabled. "" +
+                    ""But it will only be effective if connection throttling is enabled"");
+            LOG.info(
+                    ""The weights for different session types are: global {} renew {} local {}"",
+                    DEFAULT_GLOBAL_SESSION_WEIGHT,
+                    DEFAULT_RENEW_SESSION_WEIGHT,
+                    DEFAULT_LOCAL_SESSION_WEIGHT
+            );
+        } else {
+            LOG.info(""Weighed connection throttling is disabled"");
+        }
+    }
 
     static {
-        DEFAULT_CONNECTION_THROTTLE_TOKENS = Integer.getInteger(CONNECTION_THROTTLE_TOKENS, 0);
-        DEFAULT_CONNECTION_THROTTLE_FILL_TIME = Integer.getInteger(CONNECTION_THROTTLE_FILL_TIME, 1);
-        DEFAULT_CONNECTION_THROTTLE_FILL_COUNT = Integer.getInteger(CONNECTION_THROTTLE_FILL_COUNT, 1);
+        int tokens = Integer.getInteger(CONNECTION_THROTTLE_TOKENS, 0);
+        int fillCount = Integer.getInteger(CONNECTION_THROTTLE_FILL_COUNT, 1);
+
+        connectionWeightEnabled = Boolean.getBoolean(WEIGHED_CONNECTION_THROTTLE);
+
+        // if not specified, the weights for a global session, a local session, and a renew session
+        // are 3, 1, 2 respectively. The weight for a global session is 3 because in our connection benchmarking,
+        // the throughput of global sessions is about one third of that of local sessions. Renewing a session
+        // requires is more expensive than establishing a local session and cheaper than creating a global session so
+        // its default weight is set to 2.
+        int setting = Integer.getInteger(GLOBAL_SESSION_WEIGHT, 3);
+        if (setting <= 0) {
+            LOG.warn(""Invalid global session weight {}. It should be larger than 0"");","[{'comment': 'Missing the log parameter (the intention was to print `setting`?).\r\n\r\nSimilar for the subsequent `LOG.warn` for `LOCAL_SESSION_WEIGHT` and `RENEW_SESSION_WEIGHT`.', 'commenter': 'hanm'}, {'comment': 'Thanks for catching this!', 'commenter': 'jhuan31'}]"
1037,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -822,6 +822,27 @@ property, when available, is noted below.
     dropping. This parameter defines the threshold to decrease the dropping
     probability. The default is 0.
 
+* *zookeeper.connection_throttle_weight_enabled* :
+    (Java system property only)
+    **New in 3.6.0:**
+    Whether to consider connection weights when throttling. Only useful when connection throttle is enabled, that is, connectionMaxTokens is larger than 0. The default is false.
+
+* *zookeeper.connection_throttle_global_session_weight* :
+    (Java system property only)
+    **New in 3.6.0:**
+    The weight of a global session. It is the number of tokens required for a global session request to get through the connection throttler. The default is 3.    ","[{'comment': 'Aside from default value, it might also worth mention only positive integers are allowed.', 'commenter': 'hanm'}, {'comment': 'changed.', 'commenter': 'jhuan31'}]"
1037,zookeeper-server/src/main/java/org/apache/zookeeper/server/BlueThrottle.java,"@@ -86,36 +90,106 @@
     Random rng;
 
     public static final String CONNECTION_THROTTLE_TOKENS = ""zookeeper.connection_throttle_tokens"";
-    public static final int DEFAULT_CONNECTION_THROTTLE_TOKENS;
+    private static final int DEFAULT_CONNECTION_THROTTLE_TOKENS;
 
     public static final String CONNECTION_THROTTLE_FILL_TIME = ""zookeeper.connection_throttle_fill_time"";
-    public static final int DEFAULT_CONNECTION_THROTTLE_FILL_TIME;
+    private static final int DEFAULT_CONNECTION_THROTTLE_FILL_TIME;
 
     public static final String CONNECTION_THROTTLE_FILL_COUNT = ""zookeeper.connection_throttle_fill_count"";
-    public static final int DEFAULT_CONNECTION_THROTTLE_FILL_COUNT;
+    private static final int DEFAULT_CONNECTION_THROTTLE_FILL_COUNT;
 
     public static final String CONNECTION_THROTTLE_FREEZE_TIME = ""zookeeper.connection_throttle_freeze_time"";
-    public static final int DEFAULT_CONNECTION_THROTTLE_FREEZE_TIME;
+    private static final int DEFAULT_CONNECTION_THROTTLE_FREEZE_TIME;
 
     public static final String CONNECTION_THROTTLE_DROP_INCREASE = ""zookeeper.connection_throttle_drop_increase"";
-    public static final double DEFAULT_CONNECTION_THROTTLE_DROP_INCREASE;
+    private static final double DEFAULT_CONNECTION_THROTTLE_DROP_INCREASE;
 
     public static final String CONNECTION_THROTTLE_DROP_DECREASE = ""zookeeper.connection_throttle_drop_decrease"";
-    public static final double DEFAULT_CONNECTION_THROTTLE_DROP_DECREASE;
+    private static final double DEFAULT_CONNECTION_THROTTLE_DROP_DECREASE;
 
     public static final String CONNECTION_THROTTLE_DECREASE_RATIO = ""zookeeper.connection_throttle_decrease_ratio"";
-    public static final double DEFAULT_CONNECTION_THROTTLE_DECREASE_RATIO;
+    private static final double DEFAULT_CONNECTION_THROTTLE_DECREASE_RATIO;
+
+    public static final String WEIGHED_CONNECTION_THROTTLE = ""zookeeper.connection_throttle_weight_enabled"";
+    private static boolean connectionWeightEnabled;
+
+    public static final String GLOBAL_SESSION_WEIGHT = ""zookeeper.connection_throttle_global_session_weight"";
+    private static final int DEFAULT_GLOBAL_SESSION_WEIGHT;
+
+    public static final String LOCAL_SESSION_WEIGHT = ""zookeeper.connection_throttle_local_session_weight"";
+    private static final int DEFAULT_LOCAL_SESSION_WEIGHT;
 
+    public static final String RENEW_SESSION_WEIGHT = ""zookeeper.connection_throttle_renew_session_weight"";
+    private static final int DEFAULT_RENEW_SESSION_WEIGHT;
+
+    // for unit tests only
+    protected  static void setConnectionWeightEnabled(boolean enabled) {
+        connectionWeightEnabled = enabled;
+        logWeighedThrottlingSetting();
+    }
+
+    private static void logWeighedThrottlingSetting() {
+        if (connectionWeightEnabled) {
+            LOG.info(""Weighed connection throttling is enabled. "" +
+                    ""But it will only be effective if connection throttling is enabled"");
+            LOG.info(
+                    ""The weights for different session types are: global {} renew {} local {}"",
+                    DEFAULT_GLOBAL_SESSION_WEIGHT,
+                    DEFAULT_RENEW_SESSION_WEIGHT,
+                    DEFAULT_LOCAL_SESSION_WEIGHT
+            );
+        } else {
+            LOG.info(""Weighed connection throttling is disabled"");
+        }
+    }
 
     static {
-        DEFAULT_CONNECTION_THROTTLE_TOKENS = Integer.getInteger(CONNECTION_THROTTLE_TOKENS, 0);
-        DEFAULT_CONNECTION_THROTTLE_FILL_TIME = Integer.getInteger(CONNECTION_THROTTLE_FILL_TIME, 1);
-        DEFAULT_CONNECTION_THROTTLE_FILL_COUNT = Integer.getInteger(CONNECTION_THROTTLE_FILL_COUNT, 1);
+        int tokens = Integer.getInteger(CONNECTION_THROTTLE_TOKENS, 0);
+        int fillCount = Integer.getInteger(CONNECTION_THROTTLE_FILL_COUNT, 1);
+
+        connectionWeightEnabled = Boolean.getBoolean(WEIGHED_CONNECTION_THROTTLE);
+
+        // if not specified, the weights for a global session, a local session, and a renew session
+        // are 3, 1, 2 respectively. The weight for a global session is 3 because in our connection benchmarking,
+        // the throughput of global sessions is about one third of that of local sessions. Renewing a session
+        // requires is more expensive than establishing a local session and cheaper than creating a global session so","[{'comment': 'It seems obvious (even without benchmarking) that the cost of creating a global session is greater than a local session.\r\nSo, do we need enforce that the weight on a global session is always bigger than a local session? Currently there is no such constraint and user can put whatever they like (by mistake). Or, maybe just document this without actual enforcement in code?', 'commenter': 'hanm'}, {'comment': 'I add the check. If global weight is less than local weight, use the local weight as the global weight, which is equivalent to no weights.', 'commenter': 'jhuan31'}]"
1048,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/Commands.java,"@@ -18,16 +18,8 @@
 
 package org.apache.zookeeper.server.admin;
 
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.Set;
-import java.util.SortedMap;
-import java.util.TreeMap;
+import java.net.InetSocketAddress;
+import java.util.*;","[{'comment': 'Please avoid using asterisk imports. This a common coding practice across ZooKeeper.', 'commenter': 'anmolnar'}, {'comment': 'sure, thanks!', 'commenter': 'symat'}]"
1048,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/Commands.java,"@@ -657,11 +647,31 @@ public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
                                 TreeMap::new));
             }
 
+            private String getMultiAddressString(QuorumPeer.QuorumServer qs) {
+                return qs.addr.getAllAddresses().stream()
+                        .map(address -> getSingleAddressString(qs, address))
+                        .collect(Collectors.joining("",""));
+            }
+
+            private String getSingleAddressString(QuorumPeer.QuorumServer qs, InetSocketAddress address) {","[{'comment': ""I believe that we don't need this magic here which is trying to recreate the original config file contents. The output of admin command doesn't need to match with the configuration, so you can just dump the contents of the internal representation (map) which I think more helpful for anyway reading this output."", 'commenter': 'anmolnar'}, {'comment': ""Yes, I agree, I will change it. \r\n\r\nThis admin command is about to show the internal view of the voting members (how the zookeeper server thinks who the voting members are and where do they listen). I wouldn't complicate this PR any further, but it might be a good idea to create a follow-up ticket to have some admin command showing if the given server can actually reach all the different ports of the other servers (and not only the voting members). It can help debugging network problems, showing if certain network interfaces on some servers are unreachable. "", 'commenter': 'symat'}, {'comment': 'I changed the format, this is how the `voting_view` admin command responds now:\r\n```\r\n{\r\n  ""current_config"" : {\r\n    ""1"" : {\r\n      ""server_addresses"" : [ ""/172.16.101.11:2888"", ""/172.16.102.11:2888"" ],\r\n      ""election_addresses"" : [ ""/172.16.101.11:3888"", ""/172.16.102.11:3888"" ],\r\n      ""client_address"" : ""/0.0.0.0:2181"",\r\n      ""learner_type"" : ""participant""\r\n    },\r\n    ""2"" : {\r\n      ""server_addresses"" : [ ""/172.16.101.22:2888"", ""/172.16.102.22:2888"" ],\r\n      ""election_addresses"" : [ ""/172.16.101.22:3888"", ""/172.16.102.22:3888"" ],\r\n      ""client_address"" : ""/0.0.0.0:2181"",\r\n      ""learner_type"" : ""participant""\r\n    },\r\n    ""3"" : {\r\n      ""server_addresses"" : [ ""/172.16.101.33:2888"", ""/172.16.102.33:2888"" ],\r\n      ""election_addresses"" : [ ""/172.16.101.33:3888"", ""/172.16.102.33:3888"" ],\r\n      ""client_address"" : ""/0.0.0.0:2181"",\r\n      ""learner_type"" : ""participant""\r\n    }\r\n  },\r\n  ""command"" : ""voting_view"",\r\n  ""error"" : null\r\n}\r\n```', 'commenter': 'symat'}, {'comment': 'Perfect!\r\n', 'commenter': 'anmolnar'}]"
1048,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java,"@@ -271,39 +278,42 @@ public boolean isQuorumSynced(QuorumVerifier qv) {
        return qv.containsQuorum(ids);
     }
 
-    private final ServerSocket ss;
+    private final List<ServerSocket> serverSockets = new LinkedList<>();
 
     Leader(QuorumPeer self,LeaderZooKeeperServer zk) throws IOException {
         this.self = self;
         this.proposalStats = new BufferStats();
+
+        Set<InetSocketAddress> addresses;
+        if (self.getQuorumListenOnAllIPs()) {
+            addresses = self.getQuorumAddress().getWildcardAddresses();
+        } else {
+            addresses = self.getQuorumAddress().getAllAddresses();
+        }
+
+        for (InetSocketAddress address : addresses) {
+            serverSockets.add(createServerSocket(address, self.shouldUsePortUnification(), self.isSslQuorum()));
+        }
+
+        this.zk = zk;
+    }
+
+    ServerSocket createServerSocket(InetSocketAddress address, boolean portUnification, boolean sslQuorum)
+            throws IOException {
+        ServerSocket serverSocket;
         try {
-            if (self.shouldUsePortUnification() || self.isSslQuorum()) {
-                boolean allowInsecureConnection = self.shouldUsePortUnification();
-                if (self.getQuorumListenOnAllIPs()) {
-                    ss = new UnifiedServerSocket(self.getX509Util(), allowInsecureConnection, self.getQuorumAddress().getPort());
-                } else {
-                    ss = new UnifiedServerSocket(self.getX509Util(), allowInsecureConnection);
-                }
+            if (portUnification || sslQuorum) {
+                serverSocket = new UnifiedServerSocket(self.getX509Util(), portUnification);
             } else {
-                if (self.getQuorumListenOnAllIPs()) {
-                    ss = new ServerSocket(self.getQuorumAddress().getPort());
-                } else {
-                    ss = new ServerSocket();
-                }
-            }
-            ss.setReuseAddress(true);
-            if (!self.getQuorumListenOnAllIPs()) {
-                ss.bind(self.getQuorumAddress());
+                serverSocket = new ServerSocket();
             }
+            serverSocket.setReuseAddress(true);
+            serverSocket.bind(address);
+            return serverSocket;
         } catch (BindException e) {
-            if (self.getQuorumListenOnAllIPs()) {
-                LOG.error(""Couldn't bind to port "" + self.getQuorumAddress().getPort(), e);
-            } else {
-                LOG.error(""Couldn't bind to "" + self.getQuorumAddress(), e);
-            }
+            LOG.error(""Couldn't bind to "" + self.getQuorumAddress(), e);","[{'comment': ""Instead of `self.getQuorumAddress()`, you should print `address`, because that's the actual address that you're trying to bind."", 'commenter': 'anmolnar'}, {'comment': 'thanks!', 'commenter': 'symat'}]"
1048,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -228,28 +240,33 @@ static public InitialMessage parse(Long protocolVersion, DataInputStream din)
                         num_read, remaining, sid);
             }
 
-            String addr = new String(b);
-            String[] host_port;
-            try {
-                host_port = ConfigUtils.getHostAndPort(addr);
-            } catch (ConfigException e) {
-                throw new InitialMessageException(""Badly formed address: %s"", addr);
-            }
+            String[] addressStrings = new String(b).split("","");","[{'comment': 'As discussed offline, we probably need 2 things here:\r\n- Increment PROTOCOL_VERSION, because the patch introduces new InitialMessage format,\r\n- Use JSON format and add Jackson JSON serialiser to enable forward compatibility for future changes.', 'commenter': 'anmolnar'}, {'comment': 'referring to our second offline discussion:\r\n- I incremented the PROTOCOL_VERSION\r\n- did not do the JSON format modification, as it makes the future code complicated to always ensure both forward and backward compatibility of the election protocol during the rolling upgrades. The current solution (simply failing if the protocol versions mismatch) is more simple and still working just fine: as the servers are restarted one-by-one, the nodes with the old protocol version and the nodes with the new protocol version will form two partitions, but any given time only one partition will have the quorum.', 'commenter': 'symat'}]"
1048,zookeeper-server/src/main/java/org/apache/zookeeper/server/ObserverBean.java,"@@ -49,10 +50,11 @@ public String getQuorumAddress() {
 
     public String getLearnerMaster() {
         QuorumPeer.QuorumServer learnerMaster = observer.getCurrentLearnerMaster();
-        if (learnerMaster == null || learnerMaster.addr == null) {
+        InetSocketAddress address = learnerMaster.addr.getReachableOrOne();
+        if (learnerMaster == null || address == null) {","[{'comment': ""if `learnerMaster` is `null` here then you'll get a NPE on the `learnerMaster.addr.getReachableOrOne()` above. "", 'commenter': 'enixon'}, {'comment': 'thanks, nice catch!\r\n(actually beside this, we also got a NoSuchElementException if learnerMaster.addr is empty)\r\nI will fix this in the next commit', 'commenter': 'symat'}]"
1048,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java,"@@ -417,71 +427,111 @@ public boolean isQuorumSynced(QuorumVerifier qv) {
     protected final Proposal newLeaderProposal = new Proposal();
 
     class LearnerCnxAcceptor extends ZooKeeperCriticalThread {
-        private volatile boolean stop = false;
+        private final AtomicBoolean stop = new AtomicBoolean(false);
+        private final AtomicBoolean fail = new AtomicBoolean(false);
 
-        public LearnerCnxAcceptor() {
-            super(""LearnerCnxAcceptor-"" + ss.getLocalSocketAddress(), zk
-                    .getZooKeeperServerListener());
+        LearnerCnxAcceptor() {
+            super(""LearnerCnxAcceptor-"" + serverSockets.stream()
+                      .map(ServerSocket::getLocalSocketAddress)
+                      .map(Objects::toString)
+                      .collect(Collectors.joining("","")),
+                  zk.getZooKeeperServerListener());
         }
 
         @Override
         public void run() {
-            try {
-                while (!stop) {
-                    Socket s = null;
-                    boolean error = false;
-                    try {
-                        s = ss.accept();
-
-                        // start with the initLimit, once the ack is processed
-                        // in LearnerHandler switch to the syncLimit
-                        s.setSoTimeout(self.tickTime * self.initLimit);
-                        s.setTcpNoDelay(nodelay);
-
-                        BufferedInputStream is = new BufferedInputStream(
-                                s.getInputStream());
-                        LearnerHandler fh = new LearnerHandler(s, is,
-                                Leader.this);
-                        fh.start();
-                    } catch (SocketException e) {
-                        error = true;
-                        if (stop) {
-                            LOG.info(""exception while shutting down acceptor: ""
-                                    + e);
-
-                            // When Leader.shutdown() calls ss.close(),
-                            // the call to accept throws an exception.
-                            // We catch and set stop to true.
-                            stop = true;
-                        } else {
-                            throw e;
-                        }
-                    } catch (SaslException e){
-                        LOG.error(""Exception while connecting to quorum learner"", e);
-                        error = true;
-                    } catch (Exception e) {
-                        error = true;
+            if (!stop.get() && !serverSockets.isEmpty()) {
+                ExecutorService executor = Executors.newFixedThreadPool(serverSockets.size());
+                CountDownLatch latch = new CountDownLatch(serverSockets.size());
+
+                serverSockets.forEach(serverSocket ->
+                        executor.submit(new LearnerCnxAcceptorHandler(serverSocket, latch)));
+
+                try {
+                    latch.await();","[{'comment': 'should there be a timeout here?', 'commenter': 'enixon'}, {'comment': ""The code basically now starting listener threads on all local addresses, then waiting until all the listeners are dead, and then simply start over again (assuming no stop was requested by Leader.shutdown() or no unexpected failure happened in the Listener threads). \r\n\r\nI don't think we need a timeout here... ideally we want to wait forever :)"", 'commenter': 'symat'}]"
1048,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java,"@@ -418,66 +426,108 @@ public boolean isQuorumSynced(QuorumVerifier qv) {
 
     class LearnerCnxAcceptor extends ZooKeeperCriticalThread {
 
-        private volatile boolean stop = false;
+        private final AtomicBoolean stop = new AtomicBoolean(false);
+        private final AtomicBoolean fail = new AtomicBoolean(false);
 
-        public LearnerCnxAcceptor() {
-            super(""LearnerCnxAcceptor-"" + ss.getLocalSocketAddress(), zk.getZooKeeperServerListener());
+        LearnerCnxAcceptor() {
+            super(""LearnerCnxAcceptor-"" + serverSockets.stream()
+                      .map(ServerSocket::getLocalSocketAddress)
+                      .map(Objects::toString)
+                      .collect(Collectors.joining("","")),
+                  zk.getZooKeeperServerListener());
         }
 
         @Override
         public void run() {
-            try {
-                while (!stop) {
-                    Socket s = null;
-                    boolean error = false;
-                    try {
-                        s = ss.accept();
-
-                        // start with the initLimit, once the ack is processed
-                        // in LearnerHandler switch to the syncLimit
-                        s.setSoTimeout(self.tickTime * self.initLimit);
-                        s.setTcpNoDelay(nodelay);
-
-                        BufferedInputStream is = new BufferedInputStream(s.getInputStream());
-                        LearnerHandler fh = new LearnerHandler(s, is, Leader.this);
-                        fh.start();
-                    } catch (SocketException e) {
-                        error = true;
-                        if (stop) {
-                            LOG.info(""exception while shutting down acceptor: "" + e);
-
-                            // When Leader.shutdown() calls ss.close(),
-                            // the call to accept throws an exception.
-                            // We catch and set stop to true.
-                            stop = true;
-                        } else {
-                            throw e;
-                        }
-                    } catch (SaslException e) {
-                        LOG.error(""Exception while connecting to quorum learner"", e);
-                        error = true;
-                    } catch (Exception e) {
-                        error = true;
+            if (!stop.get() && !serverSockets.isEmpty()) {
+                ExecutorService executor = Executors.newFixedThreadPool(serverSockets.size());
+                CountDownLatch latch = new CountDownLatch(serverSockets.size());
+
+                serverSockets.forEach(serverSocket ->
+                        executor.submit(new LearnerCnxAcceptorHandler(serverSocket, latch)));
+
+                try {
+                    latch.await();
+                } catch (InterruptedException ie) {
+                    LOG.error(""Interrupted while sleeping. Ignoring exception"", ie);
+                } finally {
+                    closeSockets();","[{'comment': 'we should shutdown the Executor.\r\nI am thinking mostly about test cases runs', 'commenter': 'eolivelli'}, {'comment': 'thanks, nice catch. I will use executor.shutdownNow() to terminate the tasks immediately.\r\n\r\nI was thinking on adding a timeout first to wait for the tasks to shutdown gracefully in case of an interrupted exception, but I decided against it. At this point we are in a phase when all the tasks are finished (or will be finished anyway because of closing the sockets). This point I think it is better to finish everything quickly so that a new leader election can took place.', 'commenter': 'symat'}, {'comment': 'I think the executor.shutdown() + executor.awaitTermination(1 second) is enough for tests.\r\n\r\nshutdownNow may set the interrupted flag (https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html#shutdownNow()) on the threads, leading to unpredictable behaviour', 'commenter': 'eolivelli'}]"
1048,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java,"@@ -418,66 +426,108 @@ public boolean isQuorumSynced(QuorumVerifier qv) {
 
     class LearnerCnxAcceptor extends ZooKeeperCriticalThread {
 
-        private volatile boolean stop = false;
+        private final AtomicBoolean stop = new AtomicBoolean(false);
+        private final AtomicBoolean fail = new AtomicBoolean(false);
 
-        public LearnerCnxAcceptor() {
-            super(""LearnerCnxAcceptor-"" + ss.getLocalSocketAddress(), zk.getZooKeeperServerListener());
+        LearnerCnxAcceptor() {
+            super(""LearnerCnxAcceptor-"" + serverSockets.stream()
+                      .map(ServerSocket::getLocalSocketAddress)
+                      .map(Objects::toString)
+                      .collect(Collectors.joining("","")),
+                  zk.getZooKeeperServerListener());
         }
 
         @Override
         public void run() {
-            try {
-                while (!stop) {
-                    Socket s = null;
-                    boolean error = false;
-                    try {
-                        s = ss.accept();
-
-                        // start with the initLimit, once the ack is processed
-                        // in LearnerHandler switch to the syncLimit
-                        s.setSoTimeout(self.tickTime * self.initLimit);
-                        s.setTcpNoDelay(nodelay);
-
-                        BufferedInputStream is = new BufferedInputStream(s.getInputStream());
-                        LearnerHandler fh = new LearnerHandler(s, is, Leader.this);
-                        fh.start();
-                    } catch (SocketException e) {
-                        error = true;
-                        if (stop) {
-                            LOG.info(""exception while shutting down acceptor: "" + e);
-
-                            // When Leader.shutdown() calls ss.close(),
-                            // the call to accept throws an exception.
-                            // We catch and set stop to true.
-                            stop = true;
-                        } else {
-                            throw e;
-                        }
-                    } catch (SaslException e) {
-                        LOG.error(""Exception while connecting to quorum learner"", e);
-                        error = true;
-                    } catch (Exception e) {
-                        error = true;
+            if (!stop.get() && !serverSockets.isEmpty()) {
+                ExecutorService executor = Executors.newFixedThreadPool(serverSockets.size());
+                CountDownLatch latch = new CountDownLatch(serverSockets.size());
+
+                serverSockets.forEach(serverSocket ->
+                        executor.submit(new LearnerCnxAcceptorHandler(serverSocket, latch)));
+
+                try {
+                    latch.await();
+                } catch (InterruptedException ie) {
+                    LOG.error(""Interrupted while sleeping. Ignoring exception"", ie);
+                } finally {
+                    closeSockets();
+                }
+            }
+        }
+
+        public void halt() {
+            stop.set(true);
+            closeSockets();
+        }
+
+        class LearnerCnxAcceptorHandler implements Runnable {
+            private ServerSocket serverSocket;
+            private CountDownLatch latch;
+
+            LearnerCnxAcceptorHandler(ServerSocket serverSocket, CountDownLatch latch) {
+                this.serverSocket = serverSocket;
+                this.latch = latch;
+            }
+
+            @Override
+            public void run() {
+                try {
+                    Thread.currentThread().setName(""LearnerCnxAcceptorHandler-"" + serverSocket.getLocalSocketAddress());
+
+                    while (!stop.get()) {
+                        acceptConnections();
+                    }
+                } catch (Exception e) {
+                    LOG.warn(""Exception while accepting follower"", e);
+                    if (fail.compareAndSet(false, true)) {
+                        handleException(getName(), e);
+                        halt();
+                    }
+                } finally {
+                    latch.countDown();
+                }
+            }
+
+            private void acceptConnections() throws IOException {
+                Socket socket = null;
+                boolean error = false;
+                try {
+                    socket = serverSocket.accept();
+
+                    // start with the initLimit, once the ack is processed
+                    // in LearnerHandler switch to the syncLimit
+                    socket.setSoTimeout(self.tickTime * self.initLimit);
+                    socket.setTcpNoDelay(nodelay);
+
+                    BufferedInputStream is = new BufferedInputStream(socket.getInputStream());
+                    LearnerHandler fh = new LearnerHandler(socket, is, Leader.this);
+                    fh.start();
+                } catch (SocketException e) {
+                    error = true;
+                    if (stop.get()) {
+                        LOG.info(""Exception while shutting down acceptor"", e);
+                    } else {
                         throw e;
-                    } finally {
-                        // Don't leak sockets on errors
-                        if (error && s != null && !s.isClosed()) {
-                            try {
-                                s.close();
-                            } catch (IOException e) {
-                                LOG.warn(""Error closing socket"", e);
-                            }
+                    }
+                } catch (SaslException e) {
+                    LOG.error(""Exception while connecting to quorum learner"", e);
+                    error = true;
+                } catch (Exception e) {
+                    error = true;
+                    throw e;
+                } finally {
+                    // Don't leak sockets on errors
+                    if (error && socket != null && !socket.isClosed()) {
+                        try {
+                            socket.close();
+                        } catch (IOException e) {
+                            LOG.warn(""Error closing socket"", e);","[{'comment': 'we can take a change to print the socket#toString result here', 'commenter': 'eolivelli'}, {'comment': 'thanks, I will do it', 'commenter': 'symat'}]"
1048,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Learner.java,"@@ -255,65 +260,114 @@ protected void sockConnect(Socket sock, InetSocketAddress addr, int timeout) thr
      * @throws X509Exception
      * @throws InterruptedException
      */
-    protected void connectToLeader(InetSocketAddress addr, String hostname) throws IOException, InterruptedException, X509Exception {
-        this.sock = createSocket();
+    protected void connectToLeader(MultipleAddresses addr, String hostname)
+            throws IOException, InterruptedException {
+
         this.leaderAddr = addr;
+        Set<InetSocketAddress> addresses = addr.getAllAddresses();
+        ExecutorService executor = Executors.newFixedThreadPool(addresses.size());","[{'comment': 'we should shutdown the executor', 'commenter': 'eolivelli'}, {'comment': 'thanks, I will do it', 'commenter': 'symat'}]"
1048,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/MultipleAddresses.java,"@@ -0,0 +1,226 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.NoRouteToHostException;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * This class allows to store several quorum and electing addresses.
+ *
+ * See ZOOKEEPER-3188 for a discussion of this feature.
+ */
+public class MultipleAddresses {","[{'comment': 'nit: final', 'commenter': 'eolivelli'}, {'comment': 'thx', 'commenter': 'symat'}]"
1048,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/MultipleAddresses.java,"@@ -0,0 +1,226 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.NoRouteToHostException;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * This class allows to store several quorum and electing addresses.
+ *
+ * See ZOOKEEPER-3188 for a discussion of this feature.
+ */
+public class MultipleAddresses {
+    private static final int DEFAULT_TIMEOUT = 100;
+
+    private Set<InetSocketAddress> addresses;
+    private int timeout;
+
+    public MultipleAddresses() {
+        addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        timeout = DEFAULT_TIMEOUT;
+    }
+
+    public MultipleAddresses(List<InetSocketAddress> addresses) {
+        this(addresses, DEFAULT_TIMEOUT);
+    }
+
+    public MultipleAddresses(InetSocketAddress address) {
+        this(address, DEFAULT_TIMEOUT);
+    }
+
+    public MultipleAddresses(List<InetSocketAddress> addresses, int timeout) {
+        this.addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        this.addresses.addAll(addresses);
+        this.timeout = timeout;
+    }
+
+    public MultipleAddresses(InetSocketAddress address, int timeout) {
+        addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        addresses.add(address);
+        this.timeout = timeout;
+    }
+
+    public int getTimeout() {
+        return timeout;
+    }
+
+    public void setTimeout(int timeout) {
+        this.timeout = timeout;
+    }
+
+    public boolean isEmpty() {
+        return addresses.isEmpty();
+    }
+
+    /**
+     * Returns all addresses.
+     *
+     * @return set of all InetSocketAddress
+     */
+    public Set<InetSocketAddress> getAllAddresses() {
+        return Collections.unmodifiableSet(addresses);
+    }
+
+    /**
+     * Returns wildcard addresses for all ports
+     *
+     * @return set of InetSocketAddress with wildcards for all ports
+     */
+    public Set<InetSocketAddress> getWildcardAddresses() {
+        return addresses.stream().map(a -> new InetSocketAddress(a.getPort())).collect(Collectors.toSet());
+    }
+
+    /**
+     * Returns all ports
+     *
+     * @return list of all ports
+     */
+    public List<Integer> getAllPorts() {
+        return addresses.stream().map(InetSocketAddress::getPort).distinct().collect(Collectors.toList());
+    }
+
+    /**
+     * Returns distinct list of all host strings
+     *
+     * @return list of all hosts
+     */
+    public List<String> getAllHostStrings() {
+        return addresses.stream().map(InetSocketAddress::getHostString).distinct().collect(Collectors.toList());
+    }
+
+    public void addAddress(InetSocketAddress address) {
+        addresses.add(address);
+    }
+
+    /**
+     * Returns reachable address. If none is reachable than throws exception.
+     *
+     * @return address which is reachable.
+     * @throws NoRouteToHostException if none address is reachable
+     */
+    public InetSocketAddress getReachableAddress() throws NoRouteToHostException {
+        AtomicReference<InetSocketAddress> address = new AtomicReference<>(null);
+        getInetSocketAddressStream().forEach(addr -> checkIfAddressIsReachableAndSet(addr, address));
+
+        if (address.get() != null) {
+            return address.get();
+        } else {
+            throw new NoRouteToHostException(""No valid address among "" + addresses);
+        }
+    }
+
+    /**
+     * Returns reachable address or first one, if none is reachable.
+     *
+     * @return address which is reachable or fist one.
+     */
+    public InetSocketAddress getReachableOrOne() {
+        InetSocketAddress address;
+        try {
+            address = getReachableAddress();
+        } catch (NoRouteToHostException e) {
+            address = getOne();
+        }
+        return address;
+    }
+
+    /**
+     * Performs a DNS lookup for addresses.
+     *
+     * If the DNS lookup fails, than address remain unmodified.
+     */
+    public void recreateSocketAddresses() {
+        Set<InetSocketAddress> temp = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        temp.addAll(getInetSocketAddressStream().map(this::recreateSocketAddress).collect(Collectors.toSet()));
+        addresses = temp;
+    }
+
+    /**
+     * Returns first address from set.
+     *
+     * @return address from a set.
+     */
+    public InetSocketAddress getOne() {
+        return addresses.iterator().next();","[{'comment': 'what happens if there is no address ?\r\nit seems a possible case, as we have a default empty cconstructor', 'commenter': 'eolivelli'}, {'comment': ""Even with the normal constructors, it is possible to initialize the class with an empty list.\r\nIn this case both the `getOne()` and `GetReachableOrOne()` functions will throw `NoSuchElementException`, what is a non-checked Exception.\r\n\r\nI would prefer to keep the implementation this way (we also have an `isEmpty()` method, so the user of this class can verify if there is any address). This class is created during the reading of the configs, and it is enough to validate the number of addresses that time, I wouldn't complicate the code with a checked exception. Having 0 quorum or election port is not a meaningful config anyway.\r\n\r\nBut thanks for the remark, I will mention the `NoSuchElementException` to the javadocs for these functions.\r\n"", 'commenter': 'symat'}, {'comment': 'ok', 'commenter': 'eolivelli'}]"
1048,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/MultipleAddresses.java,"@@ -0,0 +1,226 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.NoRouteToHostException;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * This class allows to store several quorum and electing addresses.
+ *
+ * See ZOOKEEPER-3188 for a discussion of this feature.
+ */
+public class MultipleAddresses {
+    private static final int DEFAULT_TIMEOUT = 100;
+
+    private Set<InetSocketAddress> addresses;
+    private int timeout;
+
+    public MultipleAddresses() {
+        addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        timeout = DEFAULT_TIMEOUT;
+    }
+
+    public MultipleAddresses(List<InetSocketAddress> addresses) {
+        this(addresses, DEFAULT_TIMEOUT);
+    }
+
+    public MultipleAddresses(InetSocketAddress address) {
+        this(address, DEFAULT_TIMEOUT);
+    }
+
+    public MultipleAddresses(List<InetSocketAddress> addresses, int timeout) {
+        this.addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        this.addresses.addAll(addresses);
+        this.timeout = timeout;
+    }
+
+    public MultipleAddresses(InetSocketAddress address, int timeout) {
+        addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        addresses.add(address);
+        this.timeout = timeout;
+    }
+
+    public int getTimeout() {
+        return timeout;
+    }
+
+    public void setTimeout(int timeout) {
+        this.timeout = timeout;
+    }
+
+    public boolean isEmpty() {
+        return addresses.isEmpty();
+    }
+
+    /**
+     * Returns all addresses.
+     *
+     * @return set of all InetSocketAddress
+     */
+    public Set<InetSocketAddress> getAllAddresses() {
+        return Collections.unmodifiableSet(addresses);
+    }
+
+    /**
+     * Returns wildcard addresses for all ports
+     *
+     * @return set of InetSocketAddress with wildcards for all ports
+     */
+    public Set<InetSocketAddress> getWildcardAddresses() {
+        return addresses.stream().map(a -> new InetSocketAddress(a.getPort())).collect(Collectors.toSet());
+    }
+
+    /**
+     * Returns all ports
+     *
+     * @return list of all ports
+     */
+    public List<Integer> getAllPorts() {
+        return addresses.stream().map(InetSocketAddress::getPort).distinct().collect(Collectors.toList());
+    }
+
+    /**
+     * Returns distinct list of all host strings
+     *
+     * @return list of all hosts
+     */
+    public List<String> getAllHostStrings() {
+        return addresses.stream().map(InetSocketAddress::getHostString).distinct().collect(Collectors.toList());
+    }
+
+    public void addAddress(InetSocketAddress address) {
+        addresses.add(address);
+    }
+
+    /**
+     * Returns reachable address. If none is reachable than throws exception.
+     *
+     * @return address which is reachable.
+     * @throws NoRouteToHostException if none address is reachable
+     */
+    public InetSocketAddress getReachableAddress() throws NoRouteToHostException {
+        AtomicReference<InetSocketAddress> address = new AtomicReference<>(null);
+        getInetSocketAddressStream().forEach(addr -> checkIfAddressIsReachableAndSet(addr, address));
+
+        if (address.get() != null) {
+            return address.get();
+        } else {
+            throw new NoRouteToHostException(""No valid address among "" + addresses);
+        }
+    }
+
+    /**
+     * Returns reachable address or first one, if none is reachable.
+     *
+     * @return address which is reachable or fist one.
+     */
+    public InetSocketAddress getReachableOrOne() {
+        InetSocketAddress address;
+        try {
+            address = getReachableAddress();
+        } catch (NoRouteToHostException e) {
+            address = getOne();
+        }
+        return address;
+    }
+
+    /**
+     * Performs a DNS lookup for addresses.
+     *
+     * If the DNS lookup fails, than address remain unmodified.
+     */
+    public void recreateSocketAddresses() {
+        Set<InetSocketAddress> temp = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        temp.addAll(getInetSocketAddressStream().map(this::recreateSocketAddress).collect(Collectors.toSet()));
+        addresses = temp;
+    }
+
+    /**
+     * Returns first address from set.
+     *
+     * @return address from a set.
+     */
+    public InetSocketAddress getOne() {
+        return addresses.iterator().next();
+    }
+
+    private void checkIfAddressIsReachableAndSet(InetSocketAddress address,
+                                                 AtomicReference<InetSocketAddress> reachableAddress) {
+        for (int i = 0; i < 5 && reachableAddress.get() == null; i++) {
+            try {
+                if (address.getAddress().isReachable((i + 1) * timeout)) {
+                    reachableAddress.compareAndSet(null, address);
+                    break;
+                }
+                Thread.sleep(timeout);
+            } catch (NullPointerException | IOException | InterruptedException ignored) {","[{'comment': 'catching NullPointerException is a code and usually a bad practice.\r\nplease remove this case\r\n\r\ncatching InterruptedException requires to reset Thread#interrupt flag, please fix or explain', 'commenter': 'eolivelli'}, {'comment': 'Thanks, I agree... this one needs to be refactored. I will remove the atomic reference and do a simple parallel stream filtering in the `getReachableAddress()`. Please review after I push the new commit.', 'commenter': 'symat'}, {'comment': ""@symat why are you talking about parallelStream ? we are not talking about hundreds of addresses, using more that one thread won't help and maybe it could be more expensive"", 'commenter': 'eolivelli'}]"
1048,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/MultipleAddresses.java,"@@ -0,0 +1,226 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.NoRouteToHostException;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * This class allows to store several quorum and electing addresses.
+ *
+ * See ZOOKEEPER-3188 for a discussion of this feature.
+ */
+public class MultipleAddresses {
+    private static final int DEFAULT_TIMEOUT = 100;
+
+    private Set<InetSocketAddress> addresses;
+    private int timeout;
+
+    public MultipleAddresses() {
+        addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        timeout = DEFAULT_TIMEOUT;
+    }
+
+    public MultipleAddresses(List<InetSocketAddress> addresses) {
+        this(addresses, DEFAULT_TIMEOUT);
+    }
+
+    public MultipleAddresses(InetSocketAddress address) {
+        this(address, DEFAULT_TIMEOUT);
+    }
+
+    public MultipleAddresses(List<InetSocketAddress> addresses, int timeout) {
+        this.addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        this.addresses.addAll(addresses);
+        this.timeout = timeout;
+    }
+
+    public MultipleAddresses(InetSocketAddress address, int timeout) {
+        addresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        addresses.add(address);
+        this.timeout = timeout;
+    }
+
+    public int getTimeout() {
+        return timeout;
+    }
+
+    public void setTimeout(int timeout) {
+        this.timeout = timeout;
+    }
+
+    public boolean isEmpty() {
+        return addresses.isEmpty();
+    }
+
+    /**
+     * Returns all addresses.
+     *
+     * @return set of all InetSocketAddress
+     */
+    public Set<InetSocketAddress> getAllAddresses() {
+        return Collections.unmodifiableSet(addresses);
+    }
+
+    /**
+     * Returns wildcard addresses for all ports
+     *
+     * @return set of InetSocketAddress with wildcards for all ports
+     */
+    public Set<InetSocketAddress> getWildcardAddresses() {
+        return addresses.stream().map(a -> new InetSocketAddress(a.getPort())).collect(Collectors.toSet());
+    }
+
+    /**
+     * Returns all ports
+     *
+     * @return list of all ports
+     */
+    public List<Integer> getAllPorts() {
+        return addresses.stream().map(InetSocketAddress::getPort).distinct().collect(Collectors.toList());
+    }
+
+    /**
+     * Returns distinct list of all host strings
+     *
+     * @return list of all hosts
+     */
+    public List<String> getAllHostStrings() {
+        return addresses.stream().map(InetSocketAddress::getHostString).distinct().collect(Collectors.toList());
+    }
+
+    public void addAddress(InetSocketAddress address) {
+        addresses.add(address);
+    }
+
+    /**
+     * Returns reachable address. If none is reachable than throws exception.
+     *
+     * @return address which is reachable.
+     * @throws NoRouteToHostException if none address is reachable
+     */
+    public InetSocketAddress getReachableAddress() throws NoRouteToHostException {
+        AtomicReference<InetSocketAddress> address = new AtomicReference<>(null);
+        getInetSocketAddressStream().forEach(addr -> checkIfAddressIsReachableAndSet(addr, address));
+
+        if (address.get() != null) {
+            return address.get();
+        } else {
+            throw new NoRouteToHostException(""No valid address among "" + addresses);
+        }
+    }
+
+    /**
+     * Returns reachable address or first one, if none is reachable.
+     *
+     * @return address which is reachable or fist one.
+     */
+    public InetSocketAddress getReachableOrOne() {
+        InetSocketAddress address;
+        try {
+            address = getReachableAddress();
+        } catch (NoRouteToHostException e) {
+            address = getOne();
+        }
+        return address;
+    }
+
+    /**
+     * Performs a DNS lookup for addresses.
+     *
+     * If the DNS lookup fails, than address remain unmodified.
+     */
+    public void recreateSocketAddresses() {
+        Set<InetSocketAddress> temp = Collections.newSetFromMap(new ConcurrentHashMap<>());
+        temp.addAll(getInetSocketAddressStream().map(this::recreateSocketAddress).collect(Collectors.toSet()));
+        addresses = temp;
+    }
+
+    /**
+     * Returns first address from set.
+     *
+     * @return address from a set.
+     */
+    public InetSocketAddress getOne() {
+        return addresses.iterator().next();
+    }
+
+    private void checkIfAddressIsReachableAndSet(InetSocketAddress address,
+                                                 AtomicReference<InetSocketAddress> reachableAddress) {
+        for (int i = 0; i < 5 && reachableAddress.get() == null; i++) {
+            try {
+                if (address.getAddress().isReachable((i + 1) * timeout)) {
+                    reachableAddress.compareAndSet(null, address);
+                    break;
+                }
+                Thread.sleep(timeout);
+            } catch (NullPointerException | IOException | InterruptedException ignored) {
+            }
+        }
+    }
+
+    private InetSocketAddress recreateSocketAddress(InetSocketAddress address) {
+        try {
+            return new InetSocketAddress(InetAddress.getByName(address.getHostString()), address.getPort());
+        } catch (UnknownHostException e) {
+            return address;
+        }
+    }
+
+    private Stream<InetSocketAddress> getInetSocketAddressStream() {
+        if (addresses.size() > 1) {
+            return addresses.parallelStream();","[{'comment': 'Can we ad a comment for this parallelStream ?\r\nis it really needed ?', 'commenter': 'eolivelli'}]"
1051,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1358,6 +1395,68 @@ static void setMaxBatchSize(int size) {
         maxBatchSize = size;
     }
 
+    public int getLargeRequestMaxBytes() {
+        return largeRequestMaxBytes;
+    }
+
+    public void setLargeRequestMaxBytes(int bytes) {
+        largeRequestMaxBytes = bytes;
+    }
+
+    public int getLargeRequestThreshold() {
+        return largeRequestThreshold;
+    }
+
+    public void setLargeRequestThreshold(int threshold) {
+        largeRequestThreshold = threshold;
+    }
+
+    public int getLargeRequestBytes() {
+        return currentLargeRequestBytes.get();
+    }
+
+    private boolean isLargeRequest(int length) {
+        // The large request limit is disabled when threshold is -1
+        if (largeRequestThreshold == -1) {
+            return false;
+        }
+        return length > largeRequestThreshold;
+    }
+
+    private boolean testRequestSize(int length, boolean increment) {
+        if (!isLargeRequest(length)) {
+            // Always allow small requests
+            return true;
+        }
+
+        LOG.info(""length {} increment {}"", length, increment);","[{'comment': ""This `testRequestSize` is on critical path of every request (when every request is a large request - or when it's configured that way with -1), having three `LOG.info` in this function will probably lead to miserable performance.\r\n\r\nShould we change it to DEBUG or just remove the log completely?"", 'commenter': 'hanm'}, {'comment': 'Thanks so much! I added those for debugging and forgot to delete them. ', 'commenter': 'jhuan31'}]"
1051,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1358,6 +1395,68 @@ static void setMaxBatchSize(int size) {
         maxBatchSize = size;
     }
 
+    public int getLargeRequestMaxBytes() {
+        return largeRequestMaxBytes;
+    }
+
+    public void setLargeRequestMaxBytes(int bytes) {
+        largeRequestMaxBytes = bytes;
+    }
+
+    public int getLargeRequestThreshold() {
+        return largeRequestThreshold;
+    }
+
+    public void setLargeRequestThreshold(int threshold) {
+        largeRequestThreshold = threshold;
+    }
+
+    public int getLargeRequestBytes() {
+        return currentLargeRequestBytes.get();
+    }
+
+    private boolean isLargeRequest(int length) {
+        // The large request limit is disabled when threshold is -1
+        if (largeRequestThreshold == -1) {
+            return false;
+        }
+        return length > largeRequestThreshold;
+    }
+
+    private boolean testRequestSize(int length, boolean increment) {","[{'comment': ""having a boolean parameter in a function seems an anti pattern to me.\r\n\r\nIs there a case when we don't want increment?"", 'commenter': 'hanm'}, {'comment': 'We check while receiving the packet and after we receive the whole packet. We increment only after we receive the whole packet.  I refactor the code. Let me know whether it is easier to read. ', 'commenter': 'jhuan31'}, {'comment': ""yes, i think although the new code is a little bit verbose it's easier to understand."", 'commenter': 'hanm'}, {'comment': 'One nit - we could use void return type instead of boolean as these check function will never return false. Though, current form is ok to me too.', 'commenter': 'hanm'}]"
1051,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -221,6 +221,37 @@
     private RequestThrottler requestThrottler;
     public static final String SNAP_COUNT = ""zookeeper.snapCount"";
 
+    /**
+     * This setting sets a limit on the total number of large requests that
+     * can be inflight and is designed to prevent ZooKeeper from accepting
+     * too many large requests such that the JVM runs out of usable heap and
+     * ultimately crashes.
+     *
+     * The limit is enforced by the {@link checkRequestSize(int, boolean)}
+     * method which is called by the connection layer ({@link NIOServerCnxn},
+     * {@link NettyServerCnxn}) before allocating a byte buffer and pulling
+     * data off the TCP socket. The limit is then checked again by the
+     * ZooKeeper server in {@link processPacket(ServerCnxn, ByteBuffer)} which
+     * also atomically updates {@link currentLargeRequestBytes}. The request is
+     * then marked as a large request, with the request size stored in the Request
+     * object so that it can later be decremented from {@link currentLargeRequestsBytes}.
+     *
+     * When a request is completed or dropped, the relevant code path calls the
+     * {@link requestFinished(Request)} method which performs the decrement if
+     * needed.
+     */
+    private volatile int largeRequestMaxBytes =
+        Integer.getInteger(""zookeeper.largeRequestMaxBytes"", 100 * 1024 * 1024);
+
+    /**
+     * The size threshold after which a request is considered a large request
+     * and is checked against the large request byte limit.
+     */
+    private volatile int largeRequestThreshold =","[{'comment': ""I think it's necessary to do a validation of the values on these two newly added property, and throw argument exceptions if they are off the chart (and update doc to reflect the valid ranges.)."", 'commenter': 'hanm'}, {'comment': ""I add some basic checking and printing the current settings to the log. It's really hard to say what the valid ranges should be. Also I feel throwing an exception is a little too harsh. I just disable the large request throttling if the values are wrong. What do you think?"", 'commenter': 'jhuan31'}, {'comment': ""looks good to me, as this feature is not about correctness so even if it's misconfigured it's ok to have the cluster running with warning messages printed in log. "", 'commenter': 'hanm'}]"
1051,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1358,6 +1395,85 @@ static void setMaxBatchSize(int size) {
         maxBatchSize = size;
     }
 
+    private void initLargeRequestThrottlingSettings() {
+        setLargeRequestMaxBytes(Integer.getInteger(""zookeeper.largeRequestMaxBytes"", 100 * 1024 * 1024));","[{'comment': 'Why not just use the already defined largeRequestMaxBytes int here for default value?', 'commenter': 'nkalmar'}, {'comment': ""Good question and I don't know an answer :) changed to use largeRequestMaxBytes instead "", 'commenter': 'jhuan31'}]"
1052,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/Commands.java,"@@ -743,7 +744,14 @@ public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
                                 && voter.addr.equals(peer.getQuorumAddress())
                                 && voter.electionAddr.equals(peer.getElectionAddress())
                 );
+                response.put(""myid"", zkServer.getConf().getServerId());
+                response.put(""is_leader"", zkServer instanceof LeaderZooKeeperServer);","[{'comment': ""We' better not use 'instanceof', can you please add a method to the base class and implement it with a default value of 'false'?\r\n\r\n"", 'commenter': 'eolivelli'}, {'comment': ""@eolivelli \r\n- I just follow the implementation of command:`LeaderCommand` and I have no idea whether there is a better way\r\n\r\n- > We' better not use 'instanceof', can you please add a method to the base class and implement it with a default value of 'false'?\r\n\r\n   I may not get your idea,Could you plz give me more info?"", 'commenter': 'maoling'}]"
1052,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/Commands.java,"@@ -743,7 +744,14 @@ public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
                                 && voter.addr.equals(peer.getQuorumAddress())
                                 && voter.electionAddr.equals(peer.getElectionAddress())
                 );
+                response.put(""myid"", zkServer.getConf().getServerId());
+                response.put(""is_leader"", zkServer instanceof LeaderZooKeeperServer);
+                response.put(""endpoint"", peer.getElectionAddress().toString().split("":"")[0]+ "":"" + peer.getClientPort());","[{'comment': 'I would council you to omit or refactor ""endpoint"". The client address can be configured separately from the election address so this may be inaccurate and if the server is using the secure client port only then the address/port combination here also will not respond. ', 'commenter': 'enixon'}, {'comment': 'Good catch', 'commenter': 'maoling'}]"
1054,bin/zkServer.sh,"@@ -212,6 +212,7 @@ stop)
     else
       $KILL $(cat ""$ZOOPIDFILE"")
       rm ""$ZOOPIDFILE""
+      sleep 1","[{'comment': 'Why do we need this line?', 'commenter': 'eolivelli'}, {'comment': ""Hi Enrico,\r\n\r\nProbably for the same reason that there is a `sleep 3` in `restart`.  Here is what I have put in the corresponding commit message:\r\n\r\n---\r\n\r\nZOOKEEPER-1112: Make `zkServer.sh stop` more reliable\r\n\r\nKill is asynchronous, and without the sleep, the server's TCP port can still be busy when the next server is started—causing flaky runs of the C client's test suite.\r\n\r\n(It would probably be better to spin a few times, probing with `ps -p`.)\r\n\r\n---\r\n\r\nThis is not hypothetical: I am observing `FAILED TO START` errors in the C test suite; the log consistently shows that those are caused by `java.net.BindException: Address already in use`.\r\n\r\nAs noted above, the `sleep` is far from optimal, an adaptive mechanism would be better—but I did not want to make the patch too complicated.\r\n\r\nHere is what I would suggest: I will drop the patch from my upcoming respin, create a dedicated ticket, and carry it locally in the meantime."", 'commenter': 'ztzg'}]"
1054,zookeeper-server/src/main/java/org/apache/zookeeper/util/SecurityUtils.java,"@@ -153,6 +155,11 @@ public SaslClient run() throws SaslException {
     public static SaslServer createSaslServer(final Subject subject,
             final String protocol, final String serverName,
             final CallbackHandler callbackHandler, final Logger LOG) {
+        // required by c client api - Sasl.QOP=""auth"" is not set
+        // by default although stated in javadoc (Sun JRE 1.6.0_26-b03)
+        HashMap<String, Object> props = new HashMap<String, Object>();","[{'comment': 'May this change have any impact on existing setups?\r\nIf I understand correctly this will alter someway how the JAAS runtime operates.\r\n\r\nShould we make it configurable?', 'commenter': 'eolivelli'}, {'comment': 'That change was part of the original patches, which I have tried to ""rebase"" with a minimum amount of changes.\r\n\r\nI don\'t have a good answer to this question.  I don\'t know if @kloni is still around, and if he could comment on it.\r\n\r\nLooking closer, it looks like putting anything else than `auth` in there might not be compliant—so I am planning to revert this part of the patch in an upcoming respin, and am including the preliminary commit message below.\r\n\r\n(Note that I am not against squashing some of the patches if it makes the series easier to ingest; just let me know if you prefer sequential changes or mixed authorship.)\r\n\r\n---\r\n\r\nZOOKEEPER-1112: Do not specify QOP for the SASL server\r\n    \r\nThe explicit QOP setting had been added with a comment specifying that `Sasl.QOP=""auth""` was not set by the 1.6 JRE.\r\n\r\nMore recent JREs, such as 1.8, properly set QOP to `auth` by default, and both Cyrus SASL and Perl\'s `Authen::SASL` have been verified to be okay with it.\r\n\r\nThe patch also included `auth-conf` and `auth-int` in the preferences list; the reason for that is unclear.  It also seems incorrect, as the wire protocol does not provide checksums nor encryption.  (The plan is to carry everything over TLS anyway; perhaps QOP should be set to that triple when TLS is active?)', 'commenter': 'ztzg'}]"
1056,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/DigestCalculator.java,"@@ -37,19 +37,28 @@
 
     // The hardcoded digest version, should bump up this version whenever
     // we changed the digest method or fields.
-    //
-    // Defined it as Integer to make it able to be changed in test via reflection
-    public static final Integer DIGEST_VERSION = 2;
+    private static final int DIGEST_VERSION = 2;
 
+    public static final DigestCalculator DIGEST_CALCULATOR;
     public static final String ZOOKEEPER_DIGEST_ENABLED = ""zookeeper.digest.enabled"";
-    private static boolean digestEnabled;
 
     static {
-        digestEnabled = Boolean.parseBoolean(
+        boolean digestEnabled = Boolean.parseBoolean(
                 System.getProperty(ZOOKEEPER_DIGEST_ENABLED, ""true""));
         LOG.info(""{} = {}"", ZOOKEEPER_DIGEST_ENABLED, digestEnabled);
+        DIGEST_CALCULATOR = new DigestCalculator(digestEnabled, DIGEST_VERSION);
     }
 
+","[{'comment': ""This is not final, why don't you add a setDigestEnabled method?\r\nMake it 'volatile'\r\n\r\nWe won't lose much in performances"", 'commenter': 'eolivelli'}]"
1056,zookeeper-server/src/test/java/org/apache/zookeeper/server/DigestCalculatorTestUtil.java,"@@ -0,0 +1,36 @@
+package org.apache.zookeeper.server;","[{'comment': 'Please add license header.', 'commenter': 'anmolnar'}, {'comment': '👍 ', 'commenter': 'symat'}, {'comment': 'the file has been removed in the latest version', 'commenter': 'symat'}]"
1056,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/DigestCalculator.java,"@@ -37,19 +37,28 @@
 
     // The hardcoded digest version, should bump up this version whenever
     // we changed the digest method or fields.
-    //
-    // Defined it as Integer to make it able to be changed in test via reflection
-    public static final Integer DIGEST_VERSION = 2;
+    private static final int DIGEST_VERSION = 2;
 
+    public static final DigestCalculator DIGEST_CALCULATOR;","[{'comment': ""What if we make `DigestCalculator` interface, remove final from here and mock it easily in tests?\r\nWhat's the benefit of making it final?"", 'commenter': 'anmolnar'}, {'comment': ""I think that would work too, and mocking is more elegant than using plain reflection in the tests. (I think with Mockito you can even mock the class and you don't even need an intreface)\r\n\r\nThe only issue with the removal of the `final` modifier is that from that point anywhere from the production code you can easily change this singleton. But we can write a comment that it is to be changed only from tests...\r\n"", 'commenter': 'symat'}]"
1056,zookeeper-server/src/main/java/org/apache/zookeeper/server/NodeHashMapImpl.java,"@@ -33,6 +33,7 @@
     private final ConcurrentHashMap<String, DataNode> nodes = new ConcurrentHashMap<String, DataNode>();
 
     private AdHash hash = new AdHash();
+    private final DigestCalculator digestCalculator = new DigestCalculator();","[{'comment': 'Rather than instantiating new object here, request for it in the constructor. You should get the same object as `DataTree` is using.', 'commenter': 'anmolnar'}, {'comment': 'you are right, thanks! I just pushed this change.', 'commenter': 'symat'}]"
1056,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/DigestCalculator.java,"@@ -35,18 +35,21 @@
 
     // The hardcoded digest version, should bump up this version whenever
     // we changed the digest method or fields.
-    //
-    // Defined it as Integer to make it able to be changed in test via reflection
-    public static final Integer DIGEST_VERSION = 2;
+    private static final int DIGEST_VERSION = 2;
 
     public static final String ZOOKEEPER_DIGEST_ENABLED = ""zookeeper.digest.enabled"";
-    private static boolean digestEnabled;
 
     static {
-        digestEnabled = Boolean.parseBoolean(System.getProperty(ZOOKEEPER_DIGEST_ENABLED, ""true""));
-        LOG.info(""{} = {}"", ZOOKEEPER_DIGEST_ENABLED, digestEnabled);
+        LOG.info(""{} = {}"", ZOOKEEPER_DIGEST_ENABLED, System.getProperty(ZOOKEEPER_DIGEST_ENABLED, ""true""));
     }
 
+    private boolean digestEnabled;
+
+    public DigestCalculator() {","[{'comment': 'Move it to the same package as `DataTree` lives and make package-private everything.', 'commenter': 'anmolnar'}, {'comment': '@lvfangmin mentioned that he will use the DigestCalculator from other places, so I would wait for his PR. If it turns out still to be used only from this package, then I will move it.', 'commenter': 'symat'}, {'comment': 'He mentioned `PrepRequestProcessor` which is also in `server` package, so it should be even better there.', 'commenter': 'anmolnar'}, {'comment': ""Let's make the class 'final' it will slightly help the JVM for optimizations.\r\nWe had 'static' methods that were not overridable.\r\n"", 'commenter': 'eolivelli'}, {'comment': ""This is a good idea. I tried it, but in `SnapshotDigestTest.testDifferentDigestVersion` we create a Mockito Spy on the class and apparently you can not create Mockito Spy on a final class.\r\n\r\nSo instead of this I take @anmolnar 's original idea and moved this class to the `server` package and made it packet private, so at least it can not be overwritten from non-ZK code. Let's hope it will work also for @lvfangmin. If not, then we can move back..."", 'commenter': 'symat'}, {'comment': 'Besides PrepRequestProcessor, SerializeUtils will also reference to DigestCalculator when deserialize digest from txn:\r\n\r\nhttps://github.com/apache/zookeeper/pull/1059/files#diff-d21faf00209dfd3c78b50788f07474ffR127. ', 'commenter': 'lvfangmin'}, {'comment': ""@lvfangmin I think that `DigestCalculator` is an internal utility of `DataTree` and should not be exposed to anywhere else. `PrepRequestProcessor` could do better to access properties like `digestEnabled` and `DIGEST_VERSION` through `DataTree` getters. Like:\r\n```java\r\nzks.getZKDatabase().getDataTree().getDigestEnabled();\r\n```\r\nIt can cache the 2 values in the constructor like it's doing currently with `digestEnabled`.\r\n\r\nUnfortunately `SerializeUtils` is a different story. It's another piece of logic which I think should be organised differently. It breaks both encapsulation and responsibility principles. Let me think about if there's a way to get round that."", 'commenter': 'anmolnar'}]"
1056,zookeeper-server/src/test/java/org/apache/zookeeper/server/DataTreeTest.java,"@@ -219,7 +219,7 @@ public void testPzxidUpdatedWhenDeletingNonExistNode() throws Exception {
     @Test
     public void testDigestUpdatedWhenReplayCreateTxnForExistNode() {
         try {
-            DigestCalculator.setDigestEnabled(true);
+            System.setProperty(DigestCalculator.ZOOKEEPER_DIGEST_ENABLED, ""true"");","[{'comment': ""This won't have effect of you don't instantiate a new DataTree and the internal DigestCalculator"", 'commenter': 'eolivelli'}, {'comment': 'Nice catch, thanks! I modified the test to create a new DataTree after setting the system property.\r\n(I also made the test cleaner by creating the DataTree now only in the test cases and removed the field from the `setUp` method - previously half the tests used the field, half of them not)\r\n', 'commenter': 'symat'}]"
1056,zookeeper-server/src/main/java/org/apache/zookeeper/server/DigestCalculator.java,"@@ -16,37 +16,39 @@
  * limitations under the License.
  */
 
-package org.apache.zookeeper.server.util;
+package org.apache.zookeeper.server;
 
 import java.nio.ByteBuffer;
 import java.util.zip.CRC32;
 import org.apache.zookeeper.ZooDefs;
 import org.apache.zookeeper.data.StatPersisted;
-import org.apache.zookeeper.server.DataNode;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * Defines how to calculate the digest for a given node.
  */
-public class DigestCalculator {
+class DigestCalculator {
 
     private static final Logger LOG = LoggerFactory.getLogger(DigestCalculator.class);
 
     // The hardcoded digest version, should bump up this version whenever
     // we changed the digest method or fields.
-    //
-    // Defined it as Integer to make it able to be changed in test via reflection
-    public static final Integer DIGEST_VERSION = 2;
+    private static final int DIGEST_VERSION = 2;
 
     public static final String ZOOKEEPER_DIGEST_ENABLED = ""zookeeper.digest.enabled"";
-    private static boolean digestEnabled;
 
     static {
-        digestEnabled = Boolean.parseBoolean(System.getProperty(ZOOKEEPER_DIGEST_ENABLED, ""true""));
-        LOG.info(""{} = {}"", ZOOKEEPER_DIGEST_ENABLED, digestEnabled);
+        LOG.info(""{} = {}"", ZOOKEEPER_DIGEST_ENABLED, System.getProperty(ZOOKEEPER_DIGEST_ENABLED, ""true""));
     }
 
+    private boolean digestEnabled;
+
+    DigestCalculator() {
+        this.digestEnabled = Boolean.parseBoolean(System.getProperty(ZOOKEEPER_DIGEST_ENABLED, ""true""));","[{'comment': 'Probably we should move this setting to ZooKeeperServer, so that it can be shared and used in static classes like SerializeUtil.', 'commenter': 'lvfangmin'}, {'comment': 'That could work.', 'commenter': 'anmolnar'}]"
1059,zookeeper-contrib/zookeeper-contrib-loggraph/src/main/java/org/apache/zookeeper/graph/TxnLogSource.java,"@@ -180,8 +180,10 @@ private LogEntry readNextEntry() {
 		    throw new IOException(""CRC doesn't match "" + crcValue +
 					  "" vs "" + crc.getValue());
 		}
-		TxnHeader hdr = new TxnHeader();
-		Record r = SerializeUtils.deserializeTxn(bytes, hdr);
+
+    TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);","[{'comment': 'nit: indentation here looks way off.', 'commenter': 'hanm'}]"
1059,zookeeper-contrib/zookeeper-contrib-loggraph/src/main/java/org/apache/zookeeper/graph/TxnLogSource.java,"@@ -327,8 +329,9 @@ public TxnLogSource(String file) throws IOException {
 		if (logStream.readByte(""EOR"") != 'B') {
 		    throw new EOFException(""Last transaction was partial."");
 		}
-		TxnHeader hdr = new TxnHeader();
-		Record r = SerializeUtils.deserializeTxn(bytes, hdr);
+    TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);","[{'comment': 'nit: indentation ', 'commenter': 'hanm'}]"
1059,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -1641,7 +1642,40 @@ public boolean deserializeZxidDigest(InputArchive ia) throws IOException {
             zxidDigest.deserialize(ia);
             if (zxidDigest.zxid > 0) {
                 digestFromLoadedSnapshot = zxidDigest;
+                LOG.info(""The digest in the snapshot is {}, 0x{}, {}"",","[{'comment': 'would it be better to provide more description here? example: the digest in the snapshot has a digest version of {}, with zxid as {}, and the digest value as {}.', 'commenter': 'hanm'}]"
1059,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -1631,7 +1632,7 @@ public boolean serializeZxidDigest(OutputArchive oa) throws IOException {
      * @param ia the input stream to read from","[{'comment': 'nit: missing comment for param startZxidOfSnapshot', 'commenter': 'hanm'}, {'comment': 'Will add it.', 'commenter': 'lvfangmin'}]"
1059,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -1668,8 +1702,56 @@ public void compareSnapshotDigests(long zxid) {
             }
             digestFromLoadedSnapshot = null;
         } else if (digestFromLoadedSnapshot.zxid != 0 && zxid > digestFromLoadedSnapshot.zxid) {
-            LOG.error(""Watching for zxid 0x{} during snapshot recovery, but it wasn't found."",
-                      Long.toHexString(digestFromLoadedSnapshot.zxid));
+            RATE_LOGGER.rateLimitLog(""The txn 0x{} of snapshot digest does not ""
+                    + ""exist."", Long.toHexString(digestFromLoadedSnapshot.zxid));
+        }
+    }
+
+    /**
+     * Compares the digest of the tree with the digest present in transaction digest.
+     * If there is any error, logs and alerts the watchers.
+     *
+     * @param header transaction header being applied
+     * @param txn    transaction
+     * @param digest transaction digest
+     *
+     * @return false if digest in the txn doesn't match what we have now in
+     *               the data tree
+     */
+    public boolean compareDigest(TxnHeader header, Record txn, TxnDigest digest) {
+        long zxid = header.getZxid();
+
+        if (!DigestCalculator.digestEnabled() || digest == null) {
+            return true;
+        }
+        // do not compare digest if we're still in fuzzy state
+        if (digestFromLoadedSnapshot != null) {
+            return true;
+        }
+        // do not compare digest if there is digest version change
+        if (DigestCalculator.DIGEST_VERSION != digest.getVersion()) {
+            RATE_LOGGER.rateLimitLog(""Digest version not the same on zxid."",
+                    String.valueOf(zxid));
+            return true;
+        }
+
+        long logDigest = digest.getTreeDigest();
+        long actualDigest = getTreeDigest();
+        if (logDigest != actualDigest) {
+            reportDigestMismatch(zxid);
+            LOG.debug(""Digest in log: {}, actual tree: {}"", logDigest, actualDigest);
+            if (firstMismatchTxn) {
+                LOG.error(""First digest mismatch on txn: {}, {}, ""
+                        + ""expected digest is {}, actual digest is {}, "",
+                        header, txn, digest, actualDigest);
+                firstMismatchTxn = false;
+            }
+            return false;
+        } else {
+            RATE_LOGGER.flush();","[{'comment': 'why do we need flush the rate logger here? ', 'commenter': 'hanm'}, {'comment': 'To make sure we have a log summary up to the time when the digest matches again.', 'commenter': 'lvfangmin'}]"
1059,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/QuorumDigestTest.java,"@@ -0,0 +1,191 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.apache.zookeeper.AsyncCallback.StringCallback;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.ZooKeeper.States;
+import org.apache.zookeeper.server.ServerMetrics;
+import org.apache.zookeeper.server.TxnLogDigestTest;
+import org.apache.zookeeper.server.metric.SimpleCounter;
+import org.apache.zookeeper.server.util.DigestCalculator;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class QuorumDigestTest extends QuorumPeerTestBase {
+
+    private static final Logger LOG =
+          LoggerFactory.getLogger(QuorumDigestTest.class);
+
+    private Servers servers;
+
+    @Before
+    public void setup() throws Exception {
+        DigestCalculator.setDigestEnabled(true);
+        ((SimpleCounter) ServerMetrics.getMetrics().DIGEST_MISMATCHES_COUNT).reset();
+        servers = LaunchServers(3, 1, null);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        if (servers != null) {
+            servers.shutDownAllServers();
+        }
+        DigestCalculator.setDigestEnabled(false);
+        System.clearProperty(LearnerHandler.FORCE_SNAP_SYNC);
+    }
+
+    /**
+     * Check positive case without digest mismatch during diff sync.
+     */
+    @Test
+    public void testDigestMatchesDuringDiffSync() throws Exception {
+        triggerSync(false);
+    }
+
+    /**
+     * Check positive case without digest mismatch during snap sync.
+     */
+    @Test
+    public void testDigestMatchesDuringSnapSync() throws Exception {
+        triggerSync(true);
+
+        // have some extra txns
+        int leader = servers.findLeader();
+        TxnLogDigestTest.performOperations(servers.zk[leader],
+                ""/testDigestMatchesDuringSnapSync"");
+        Assert.assertEquals(0L, getMismatchDigestCount());
+    }
+
+    @Test
+    public void testDigestMatchesWithAsyncRequests() throws Exception {
+
+        int leader = servers.findLeader();
+
+        final ZooKeeper client = servers.zk[leader];
+        final AtomicBoolean stopped = new AtomicBoolean(true);
+        final String prefix = ""/testDigestMatchesWithAsyncRequests"";
+
+        // start a thread to send requests asynchronously,
+        Thread createTrafficThread = new Thread () {
+            @Override
+            public void run() {
+                int i = 0;
+                while (!stopped.get()) {
+                    String path = prefix + ""-"" + i;
+                    client.create(path, path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,
+                            CreateMode.PERSISTENT, new StringCallback() {
+                        @Override
+                        public void processResult(int rc, String path,
+                                Object ctx, String name) {
+                            // ignore the result
+                        }
+                    }, null);
+                    try {
+                        Thread.sleep(10);
+                    } catch (InterruptedException e) { /* ignore */ }
+                }
+            }
+        };
+        createTrafficThread.start();
+
+        // shutdown a follower and observer
+        List<Integer> targets = Arrays.asList(
+                servers.findAnyFollower(), servers.findAnyObserver());
+        stopServers(targets);
+
+        // start the follower and observer to have a diff sync
+        startServers(targets);
+
+        // make sure there is no digest mismatch
+        Assert.assertEquals(0L, getMismatchDigestCount());
+
+        // stop the leader
+        targets = Arrays.asList(leader);
+        stopServers(targets);
+        startServers(targets);
+
+        // make sure there is no digest mismatch
+        Assert.assertEquals(0L, getMismatchDigestCount());
+
+        stopped.set(true);
+    }
+
+    private void stopServers(List<Integer> sids) throws InterruptedException {
+        for (int sid : sids) {
+            if (sid != -1) {
+                servers.mt[sid].shutdown();
+                waitForOne(servers.zk[sid], States.CONNECTING);
+            }
+        }
+    }
+
+    private void startServers(List<Integer> sids) throws InterruptedException {
+        for (int sid : sids) {
+            servers.mt[sid].start();
+            waitForOne(servers.zk[sid], States.CONNECTED);
+        }
+    }
+
+    private void triggerOps(int sid, String prefix) throws Exception {
+        TxnLogDigestTest.performOperations(servers.zk[sid], prefix);
+        servers.restartClient(sid, null);
+        waitForOne(servers.zk[sid], States.CONNECTED);
+    }
+
+    private void triggerSync(boolean snapSync) throws Exception {
+        if (snapSync) {
+            System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, ""true"");","[{'comment': 'In my opinion we should reset this systen property at the end and maybe even at the begin of each test.\r\nOtherwise we are not sure about the current value before and after the test', 'commenter': 'eolivelli'}, {'comment': ""@eolivelli we've already doing clearProperty in the tearDown."", 'commenter': 'lvfangmin'}, {'comment': 'Yep.\r\nI missed it', 'commenter': 'eolivelli'}]"
1059,zookeeper-server/src/main/java/org/apache/zookeeper/server/NodeHashMapImpl.java,"@@ -30,9 +31,16 @@
  */
 public class NodeHashMapImpl implements NodeHashMap {
 
-    private final ConcurrentHashMap<String, DataNode> nodes = new ConcurrentHashMap<String, DataNode>();
+    private final ConcurrentHashMap<String, DataNode> nodes;
+    private final boolean digestEnabled;
 
-    private AdHash hash = new AdHash();
+    private AdHash hash;","[{'comment': 'nit: final ?', 'commenter': 'eolivelli'}]"
1059,zookeeper-server/src/main/java/org/apache/zookeeper/server/NodeHashMapImpl.java,"@@ -30,9 +31,16 @@
  */
 public class NodeHashMapImpl implements NodeHashMap {
 
-    private final ConcurrentHashMap<String, DataNode> nodes = new ConcurrentHashMap<String, DataNode>();
+    private final ConcurrentHashMap<String, DataNode> nodes;
+    private final boolean digestEnabled;
 
-    private AdHash hash = new AdHash();
+    private AdHash hash;
+
+    public NodeHashMapImpl() {
+        nodes = new ConcurrentHashMap<String, DataNode>();","[{'comment': 'nit: no need for String, DataNode>', 'commenter': 'eolivelli'}]"
1059,zookeeper-server/src/main/java/org/apache/zookeeper/server/TxnLogEntry.java,"@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.jute.Record;
+import org.apache.zookeeper.txn.TxnDigest;
+import org.apache.zookeeper.txn.TxnHeader;
+
+/**
+ * A helper class to represent the txn entry.
+ */
+public class TxnLogEntry {","[{'comment': 'nit: final the class and all of the fields', 'commenter': 'eolivelli'}]"
1059,zookeeper-server/src/test/java/org/apache/zookeeper/server/PrepRequestProcessorTest.java,"@@ -151,6 +165,35 @@ public void testMultiOutstandingChange() throws Exception {
         assertEquals(""Record zxid wasn't set correctly"", 2, cr.zxid);
     }
 
+    @Test
+    public void testReconfigWithAnotherOutstandingChange() throws Exception {
+        QuorumPeer qp = new QuorumPeer();
+        QuorumVerifier quorumVerifierMock = mock(QuorumVerifier.class);
+        when(quorumVerifierMock.getAllMembers()).thenReturn(LeaderBeanTest.getMockedPeerViews(qp.getId()));
+
+        qp.setQuorumVerifier(quorumVerifierMock, false);
+        FileTxnSnapLog snapLog = new FileTxnSnapLog(tmpDir, tmpDir);
+        LeaderZooKeeperServer lzks = new LeaderZooKeeperServer(snapLog, qp, new ZKDatabase(snapLog));
+        qp.leader = new Leader(qp, lzks);
+        lzks.sessionTracker = new MySessionTracker();
+        DigestCalculator.setDigestEnabled(true);
+        processor = new PrepRequestProcessor(lzks, new MyRequestProcessor());
+
+        Record record = new CreateRequest(""/foo"", ""data"".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT.toFlag());
+        pLatch = new CountDownLatch(1);
+        processor.pRequest(createRequest(record, OpCode.create, false));
+        assertTrue(""request hasn't been processed in chain"", pLatch.await(5, TimeUnit.SECONDS));
+
+        QuorumPeerConfig.setReconfigEnabled(true);","[{'comment': 'nit:\r\nreset the flag in a ""finally"" block, otherwise we are going to pollute the env, other tests will see ReconfigEnabled = true', 'commenter': 'eolivelli'}]"
1059,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -964,8 +964,59 @@ property, when available, is noted below.
 * *digest.enabled* :
     (Java system property only: **zookeeper.digest.enabled**)
     **New in 3.6.0:**
-    The digest feature is added to self-verify the correctness inside
-    ZooKeeper when loading database from disk, and syncing with leader.
+    The digest feature is added to detect the data inconsistency inside
+    ZooKeeper when loading database from disk, catching up and following
+    leader, its doing incrementally hash check for the DataTree based on 
+    the adHash paper mentioned in mentioned in 
+","[{'comment': '- `mentioned in mentioned in`？\r\n- Great doc, I got the idea.', 'commenter': 'maoling'}, {'comment': 'good catch on the doc error. +1', 'commenter': 'hanm'}, {'comment': 'Thanks, will correct the doc here.', 'commenter': 'lvfangmin'}]"
1059,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -500,6 +501,10 @@ public void loadData() throws IOException, InterruptedException {
         takeSnapshot();
     }
 
+    public boolean compareDigest(TxnHeader header, Record txn, TxnDigest digest) {","[{'comment': 'This method is not used in code base. Is this still needed?', 'commenter': 'hanm'}, {'comment': ""Good catch, this is the method we used in a later feature to check consistency during DIFF sync, I'll remove it here."", 'commenter': 'lvfangmin'}]"
1059,zookeeper-server/src/main/java/org/apache/zookeeper/server/DigestCalculator.java,"@@ -28,7 +28,7 @@
 /**
  * Defines how to calculate the digest for a given node.
  */
-class DigestCalculator {
+public class DigestCalculator {
 
     private static final Logger LOG = LoggerFactory.getLogger(DigestCalculator.class);","[{'comment': 'logger is not used.', 'commenter': 'hanm'}]"
1059,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -964,8 +964,59 @@ property, when available, is noted below.
 * *digest.enabled* :
     (Java system property only: **zookeeper.digest.enabled**)
     **New in 3.6.0:**
-    The digest feature is added to self-verify the correctness inside
-    ZooKeeper when loading database from disk, and syncing with leader.
+    The digest feature is added to detect the data inconsistency inside
+    ZooKeeper when loading database from disk, catching up and following
+    leader, its doing incrementally hash check for the DataTree based on 
+    the adHash paper mentioned in mentioned in 
+
+        https://cseweb.ucsd.edu/~daniele/papers/IncHash.pdf
+
+    The idea is simple, the hash value of DataTree will be updated incrementally 
+    based on the changes to the set of data. When the leader is preparing the txn, 
+    it will pre-calculate the hash of the tree based on the changes happened with 
+    formula:
+
+        current_hash = current_hash + hash(new node data) - hash(old node data)
+
+    If it’s creating a new node, the hash(old node data) will be 0, and if it’s a 
+    delete node op, the hash(new node data) will be 0.
+
+    This hash will be associated with each txn to represent the expected hash value 
+    after applying the txn to the data tree, it will be sent to followers with 
+    original proposals. Learner will compare the actual hash value with the one in 
+    the txn after applying the txn to the data tree, and report mismatch if it’s not 
+    the same.
+
+    These digest value will also be persisted with each txn and snapshot on the disk, 
+    so when servers restarted and load data from disk, it will compare and see if 
+    there is hash mismatch, which will help detect data loss issue on disk.
+
+    For the actual hash function, we’re using CRC internally, it’s not a collisionless 
+    hash function, but it’s more efficient compared to collisionless hash, and the 
+    collision possibility is really really rare and can already meet our needs here.
+
+    This feature is backward and forward compatible, so it can safely rolling upgrade, 
+    downgrade, enabled and later disabled without any compatible issue. Here are the 
+    scenarios have been covered and tested:
+
+    1. When leader runs with new code while follower runs with old one, the digest will 
+       be append to the end of each txn, follower will only read header and txn data, 
+       digest value in the txn will be ignored. It won't affect the follower reads and 
+       processes the next txn.
+    2. When leader runs with old code while follower runs with new one, the digest won't
+       be sent with txn, when follower tries to read the digest, it will throw EOF which 
+       is caught and handled gracefully with digest value set to null.
+    3. When loading old snapshot with new code, it will throw IOException when trying to
+       read the non-exist digest value, and the exception will be caught and digest will
+       be set to null, which means we won't compare digest when loading this snapshot, 
+       which is expected to happen during rolling upgrade
+    4. When loading new snapshot with old code, it will finish successfully after deserialzing 
+       the data tree, the digest value at the end of snapshot file will be ignored
+    5. The scenarios of rolling restart with flags change are similar to the 1st and 2nd 
+       scenarios discussed above, if the leader enabled but follower not, digest value will
+       be ignored, and follower won't compare the digest during runtime; if leader disabled
+       but follower enabled, follower will get EOF exception which is handled gracefully.
+
     By default, this feautre is disabled, set ""true"" to enable it.","[{'comment': 'should we mention in the doc that path /zookeeper/ is excluded from digest calculation?', 'commenter': 'hanm'}, {'comment': ""That's a good suggestion, I'll add that."", 'commenter': 'lvfangmin'}]"
1059,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -297,8 +315,12 @@ private String validatePathForCreate(String path, long sessionId) throws BadArgu
      * @param record
      */
     protected void pRequest2Txn(int type, long zxid, Request request, Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException {
-        request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, Time.currentWallTime(), type));
+        if (request.getHdr() == null) {","[{'comment': 'is this check needed? I think we always let this method fill in the txn header, but I might be missing something here.', 'commenter': 'hanm'}, {'comment': ""It's related to multi-op, previously we use a different header for different sub-txn, which is not ideal, and I remember there is some issue caused by that, but I cannot memorize it now."", 'commenter': 'lvfangmin'}]"
1059,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -956,4 +1050,81 @@ public void shutdown() {
         nextProcessor.shutdown();
     }
 
+    /**
+     * Calculate the node digest and tree digest after the change.
+     *
+     * @param type the type of operations about the digest change
+     * @param path the path of the node
+     * @param data the data of the node
+     * @param s the stat of the nodek","[{'comment': 'typo nodek', 'commenter': 'hanm'}]"
1059,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileSnap.java,"@@ -78,15 +78,17 @@ public long deserialize(DataTree dt, Map<Long, Integer> sessions) throws IOExcep
             return -1L;
         }
         File snap = null;
+        long snapZxid = 0;","[{'comment': 'should the default value of `snapZxid` be -1 instead of 0? -1 is what `Util.getZxidFromName` returns if finds nothing valid.', 'commenter': 'hanm'}, {'comment': ""There is no correctness issue with 0, but I'll change it to -1 to make it identical with the default returned from Util.getZxidFromName."", 'commenter': 'lvfangmin'}]"
1064,zookeeper-server/src/main/java/org/apache/zookeeper/Watcher.java,"@@ -31,6 +31,8 @@
 @InterfaceAudience.Public
 public interface Watcher {
 
+    Watcher DUMMY_WATCHER = event -> { };","[{'comment': ""Please do not add this constant to this public API.\r\nIf you want to do this change for tests let's create a class inside the test packages"", 'commenter': 'eolivelli'}, {'comment': ""Make sense. I'd like to introduce a `DummyWatch` in test scope and corresponding updates."", 'commenter': 'tisonkun'}, {'comment': 'Updated', 'commenter': 'tisonkun'}]"
1069,zookeeper-server/src/test/java/org/apache/zookeeper/test/EmptiedSnapshotRecoveryTest.java,"@@ -119,7 +125,15 @@ public void testRestoreWithEmptySnapFiles() throws Exception {
      */
     @Test
     public void testRestoreWithNoSnapFiles() throws Exception {
-        runTest(false);
+        runTest(false, false);
+    }
+
+    @Test
+    public void testRestoreWithTrustedEmptySnapFiles() throws Exception {
+        FileTxnSnapLog.setTrustEmptySnapshotFlag(true);","[{'comment': 'what about resetting the value to ""false"" in a finally block, this way if the test fails we will be sure that the rest of the tests are executed with the default value', 'commenter': 'eolivelli'}, {'comment': 'good catch, and find bug complains about something similar. I changed the flag variable to an instance variable instead and move the set / check logic inside the shared test implementation. Tests will not be interfering with each other.', 'commenter': 'hanm'}]"
1069,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -232,11 +242,19 @@ public long restore(DataTree dt, Map<Long, Integer> sessions, PlayBackListener l
         } else {
             trustEmptyDB = autoCreateDB;
         }
+
         if (-1L == deserializeResult) {
             /* this means that we couldn't find any snapshot, so we need to
              * initialize an empty database (reported in ZOOKEEPER-2325) */
             if (txnLog.getLastLoggedZxid() != -1) {
-                throw new IOException(""No snapshot found, but there are log entries. "" + ""Something is broken!"");
+                // ZOOKEEPER-3056: provides an escape hatch for users upgrading
+                // from old versions of zookeeper (3.4.x, pre 3.5.3).
+                if (!trustEmptySnapshot) {
+                    throw new IOException(EMPTY_SNAPSHOT_WARNING + ""Something is broken!"");
+                } else {
+                    LOG.warn(EMPTY_SNAPSHOT_WARNING + ""This should only be allowed during upgrading."");
+                    trustEmptySnapshot = false;","[{'comment': 'I am not an expert of this part, just want to share my doubts\r\n\r\nIdeally we will hit the case of the issue only while the server is starting up, not during internal reloads of the database, it is allowed to have such lack of snapshot file only during bootstrap.\r\nFor instance I see that this method (""restore"") is called in QuorumPeer#getLastLoggedZxid()\r\nif we refactor the code in the future and change the boot sequence this change won\'t take effect.\r\n\r\n\r\nI wonder if there is a cleaner way to allow this special case only during ""start"" and not during all of the other code paths that leads to the invocations of this method.\r\n', 'commenter': 'eolivelli'}, {'comment': '>> during internal reloads of the database\r\n\r\ndatabase will only be loaded once from disk during a process\'s life time now we don\'t clear the in memory data base anymore every time a server (object) restarts; so this is less a concern. \r\n\r\n>> I wonder if there is a cleaner way to allow this special case only during ""start"" and not during all of the other code paths\r\n\r\n""start"" and ""other code paths"" are no different, from server point of view they are all recovery cases, be it a first start up or recovery from faults. So if we care about empty snapshot, we should check in all places. If we ignore empty snapshot, we should ignore in all places. The check logic and the skip check logic should be co-located, so refactoring sequence of start ups will not impact that.', 'commenter': 'hanm'}, {'comment': ""If we call this method only once.\r\nWhy should we reset this variable, as it won't be used anymore?\r\n\r\nCan you please give an example of multiple calls of this method?"", 'commenter': 'eolivelli'}, {'comment': "">> we don't clear the in memory data base anymore\r\n\r\nActually, we still clear database sometimes (the case I was referring to was the database retain introduced in ZOOKEEPER-2678 and following up jira). There are two cases we still clear database: a recovering server get a TRUNC from leader; or a recovering server get a SNAP sync from leader. Both cases will clear db, leads to reload local snap to initialize the database.\r\n\r\nIn any case, one invariant here is the first invoke of `restore` will always happen when a fresh server is starting. I don't think a future refactoring will change this fact (if, there will be such refactoring at all) given the essence of this step during start up. With this invariant, we need reset the flag so further database reloading at run time does not accidentally skip the snapshot validation.\r\n\r\nNow, one alternative is instead of trying to be clever and reset the flag in code, we remove the reset, but require ops admin to restart the zookeeper process after upgrading by reset the flag manually. This means upgrading a cluster will trigger leader election at least twice, instead of once, which seems not too bad, with the benefit of making code easier to understand. Even in this case, we can still keep this reset logic in code as an extra layer of protection, as that logic will only introduce false negative instead of false positive in terms of the data safety of the system, in worst case."", 'commenter': 'hanm'}, {'comment': 'I am okay with keeping this reset logic.\r\n\r\nIn fact I found those other execution path that lead to calls to *restore*\r\nand I asked for confirmation.', 'commenter': 'eolivelli'}, {'comment': 'I\'m tempted toward the unclever solution of not resetting the flag since this is easy to reason about. Unless we can guarantee that a snapshot is created by the server as the flag is flipped then it makes sense to have the admin bare the risk of operating in ""snapshot not required"" mode.', 'commenter': 'enixon'}, {'comment': 'removed reset logic and update doc to recommend an advisory flag reset after upgrade. ', 'commenter': 'hanm'}]"
1069,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -102,6 +107,9 @@ public FileTxnSnapLog(File dataDir, File snapDir) throws IOException {
         boolean enableAutocreate = Boolean.parseBoolean(
             System.getProperty(ZOOKEEPER_DATADIR_AUTOCREATE, ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT));
 
+        trustEmptySnapshot = Boolean.getBoolean(ZOOKEEPER_SNAPSHOT_TRUST_EMPTY);
+        LOG.info(ZOOKEEPER_SNAPSHOT_TRUST_EMPTY + "" : "" + trustEmptySnapshot);","[{'comment': 'nit on the log format', 'commenter': 'enixon'}, {'comment': 'What would you recommend? I thought about `        LOG.info(ZOOKEEPER_SNAPSHOT_TRUST_EMPTY + "" :  {}"", trustEmptySnapshot);\r\n`, but there is a `+` I can\'t get rid of, so why bother :)', 'commenter': 'hanm'}, {'comment': 'I was thinking:\r\n\r\n`LOG.info(""{}:{}"", ZOOKEEPER_SNAPSHOT_TRUST_EMPTY, trustEmptySnapshot);`\r\n\r\nbut just a nit', 'commenter': 'enixon'}]"
1069,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -232,11 +240,19 @@ public long restore(DataTree dt, Map<Long, Integer> sessions, PlayBackListener l
         } else {
             trustEmptyDB = autoCreateDB;
         }
+
         if (-1L == deserializeResult) {
             /* this means that we couldn't find any snapshot, so we need to
              * initialize an empty database (reported in ZOOKEEPER-2325) */
             if (txnLog.getLastLoggedZxid() != -1) {
-                throw new IOException(""No snapshot found, but there are log entries. "" + ""Something is broken!"");
+                // ZOOKEEPER-3056: provides an escape hatch for users upgrading
+                // from old versions of zookeeper (3.4.x, pre 3.5.3).
+                if (!trustEmptySnapshot) {
+                    throw new IOException(EMPTY_SNAPSHOT_WARNING + ""Something is broken!"");
+                } else {
+                    LOG.warn(EMPTY_SNAPSHOT_WARNING + ""This should only be allowed during upgrading."");
+                    trustEmptySnapshot = false;
+                }
             }
 
             if (trustEmptyDB) {","[{'comment': 'If `trustEmptyDB` is not set does the code (1) load the transaction log and (2) create a snapshot? With the second question, can we have a scenario where clearing `trustEmptySnapshot` causes the Peer to shutdown because it cannot find a snapshot on a second pass?', 'commenter': 'enixon'}, {'comment': ""I thought about this, and I didn't get into `trustEmptyDB` because it seems create another problem for upgrading, which might require a separate discussion.\r\n\r\nBasically if we don't set `trustEmptyDB`, then it's possible to have zookeeper server in a valid state with no snapshot files but only transaction log files similar to older version of ZooKeeper. Since we treat such case as invalid, yet we essentially allow such case happen in first place, this seems self contradictory and inconsistent. Always creating at least one snapshot sounds like a good solution here, but that require we always execute the code path when `trustEmptyDB ` is set (which, is the default case).\r\n\r\nIs there any cases where we don't want to set `trustEmptyDB ` ?\r\n"", 'commenter': 'hanm'}, {'comment': ""One concrete example:\r\n* Create a fresh zookeeper cluster with `zookeeper.db.autocreate` set to false.\r\n* Start a fresh cluster, create a client and issue some transactions.\r\n* The default snap count is 100000 so no snapshot will be created; `zookeeper.db.autocreate` is set to false so no snapshot will be created upon server start up.\r\n* Now restart all zookeeper servers. We can't load because there is no snapshot. \r\n\r\nDoes this sound a reasonable example to demonstrate the problem with `trustEmptyDB ` set to false?"", 'commenter': 'hanm'}]"
1073,zookeeper-docs/src/main/resources/markdown/zookeeperUseCases.md,"@@ -0,0 +1,377 @@
+<!--
+Copyright 2002-2019 The Apache Software Foundation
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+//-->
+
+# ZooKeeper Use Cases
+
+- Applications and organizations using ZooKeeper include (alphabetically)[1].
+- If your use case wants to be listed here. Please do not hesitate, submit a pull request or write an email to **dev@zookeeper.apache.org**,
+  and then, your use case will be included.
+
+
+## Free Software Projects
+
+### [AdroitLogic UltraESB](http://adroitlogic.org/)
+  - Uses ZooKeeper to implement node coordination, in clustering support. This allows the management of the complete cluster,
+  or any specific node - from any other node connected via JMX. A Cluster wide command framework developed on top of the
+  ZooKeeper coordination allows commands that fail on some nodes to be retried etc. We also support the automated graceful
+  round-robin-restart of a complete cluster of nodes using the same framework.
+
+### [Akka](http://akka.io/)
+  - Akka is the platform for the next generation event-driven, scalable and fault-tolerant architectures on the JVM.
+  Or: Akka is a toolkit and runtime for building highly concurrent, distributed, and fault tolerant event-driven applications on the JVM.
+
+### [Eclipse Communication Framework](http://www.eclipse.org/ecf) 
+  - The Eclipse ECF project provides an implementation of its Abstract Discovery services using Zookeeper. ECF itself
+  is used in many projects providing base functionallity for communication, all based on OSGi.
+
+### [Eclipse Gyrex](http://www.eclipse.org/gyrex)
+  - The Eclipse Gyrex project provides a platform for building your own Java OSGi based clouds. 
+  - ZooKeeper is used as the core cloud component for node membership and management, coordination of jobs executing among workers,
+  a lock service and a simple queue service and a lot more.
+
+### [GoldenOrb](http://www.goldenorbos.org/)
+  - massive-scale Graph analysis
+
+### [Juju](https://juju.ubuntu.com/)
+  - Service deployment and orchestration framework, formerly called Ensemble.
+
+### [Katta](http://katta.sourceforge.net/)
+  - Katta serves distributed Lucene indexes in a grid environment.
+  - Zookeeper is used for node, master and index management in the grid.
+
+### [KeptCollections](https://github.com/anthonyu/KeptCollections)
+  - KeptCollections is a library of drop-in replacements for the data structures in the Java Collections framework.
+  - KeptCollections uses Apache ZooKeeper as a backing store, thus making its data structures distributed and scalable.
+
+### [Neo4j](https://neo4j.com/)
+  - Neo4j is a Graph Database. It's a disk based, ACID compliant transactional storage engine for big graphs and fast graph traversals,
+    using external indicies like Lucene/Solr for global searches.
+  - We use ZooKeeper in the Neo4j High Availability components for write-master election,
+    read slave coordination and other cool stuff. ZooKeeper is a great and focused project - we like!
+
+### [Norbert](http://sna-projects.com/norbert)
+  - Partitioned routing and cluster management.
+
+### [OpenStack Nova](http://www.openstack.org/)
+  - OpenStack  is an open source software stack for the creation and management of private and public clouds. It is designed to manage pools of compute,
+    storage, and networking resources in data centers, allowing the management of these resources through a consolidated dashboard and flexible APIs.
+  - Nova is the software component in OpenStack, which is responsible for managing the compute resources, where virtual machines (VMs) are hosted in a cloud computing environment. It is also known as the OpenStack Compute Service. OpenStack
+    Nova provides a cloud computing fabric controller, supporting a wide variety of virtualization technologies such as KVM, Xen, VMware, and many more. In addition to its native API, it also includes compatibility with Amazon EC2 and S3 APIs.
+    Nova depends on up-to-date information about the availability of the various compute nodes and services that run on them, for its proper operation. For example, the virtual machine placement operation requires to know the currently available compute nodes and their current state.
+    Nova uses ZooKeeper to implement an efficient membership service, which monitors the availability of registered services. This is done through the ZooKeeper ServiceGroup Driver, which works by using ZooKeeper's ephemeral znodes. Each service registers by creating an ephemeral znode on startup. Now, when the service dies, ZooKeeper will automatically delete the corresponding ephemeral znode. The removal of this znode can be used to trigger the corresponding recovery logic.
+    For example, when a compute node crashes, the nova-compute service that is running in that node also dies. This causes the session with ZooKeeper service to expire, and as a result, ZooKeeper deletes the ephemeral znode created by the nova-compute service. If the cloud controller keeps a watch on this node-deletion event, it will come to know about the compute node crash and can trigger a migration procedure to evacuate all the VMs that are running in the failed compute node to other nodes. This way, high availability of the VMs can be ensured in real time.
+  - ZooKeeper is also being considered for the following use cases in OpenStack Nova:
+    - Storing the configuration metadata (nova.conf)
+    - Maintaining high availability of services and automatic failover using
+    leader election
+
+### [spring-cloud-zookeeper](https://spring.io/projects/spring-cloud-zookeeper)
+  - Spring Cloud Zookeeper provides Apache Zookeeper integrations for Spring Boot apps through autoconfiguration
+    and binding to the Spring Environment and other Spring programming model idioms. With a few simple annotations
+    you can quickly enable and configure the common patterns inside your application and build large distributed systems with Zookeeper.
+    The patterns provided include Service Discovery and Distributed Configuration.
+
+### [Talend ESB](http://www.talend.com/products-application-integration/application-integration-esb-se.php)
+  - Talend ESB is a versatile and flexible, enterprise service bus.
+  - It uses ZooKeeper as endpoint repository of both REST and SOAP Web services.
+    By using ZooKeeper Talend ESB is able to provide failover and load balancing capabilities in a very light-weight manner
+
+### [redis_failover](https://github.com/ryanlecompte/redis_failover)
+  - Redis Failover is a ZooKeeper-based automatic master/slave failover solution for Ruby.
+
+
+## Apache Projects
+
+### [Apache Accumulo](https://accumulo.apache.org/)
+  - Accumulo is a distributed key/value store that provides expressive, cell-level access labels.
+  - Apache ZooKeeper plays a central role within the Accumulo architecture. Its quorum consistency model supports an overall
+    Accumulo architecture with no single points of failure. Beyond that, Accumulo leverages ZooKeeper to store and communication 
+    configuration information for users and tables, as well as operational states of processes and tablets.[2]
+
+### [Apache BookKeeper](https://bookkeeper.apache.org/)
+  - A scalable, fault-tolerant, and low-latency storage service optimized for real-time workloads.
+  - BookKeeper requires a metadata storage service to store information related to ledgers and available bookies. BookKeeper currently uses
+    ZooKeeper for this and other tasks[3].
+
+### [Apache CXF DOSGi](http://cxf.apache.org/distributed-osgi.html)
+  - Apache CXF is an open source services framework. CXF helps you build and develop services using frontend programming
+    APIs, like JAX-WS and JAX-RS. These services can speak a variety of protocols such as SOAP, XML/HTTP, RESTful HTTP,
+    or CORBA and work over a variety of transports such as HTTP, JMS or JBI.
+  - The Distributed OSGi implementation at Apache CXF uses ZooKeeper for its Discovery functionality.[4]
+
+### [Apache Dubbo](http://dubbo.apache.org)
+  - Apache Dubbo is a high-performance, java based open source RPC framework.
+  - Zookeeper is used for service registration discovery and configuration management in Dubbo.[6]
+
+### [Apache Flink](https://flink.apache.org/)
+  - Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.
+    Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale.
+  - To enable JobManager High Availability you have to set the high-availability mode to zookeeper, configure a ZooKeeper quorum and set up a masters file with all JobManagers hosts and their web UI ports.
+    Flink leverages ZooKeeper for distributed coordination between all running JobManager instances. ZooKeeper is a separate service from Flink,
+    which provides highly reliable distributed coordination via leader election and light-weight consistent state storage[23].
+
+### [Apache Flume](https://flume.apache.org/)
+  - Flume is a distributed, reliable, and available service for efficiently collecting, aggregating, and moving large amounts
+    of log data. It has a simple and flexible architecture based on streaming data flows. It is robust and fault tolerant
+    with tunable reliability mechanisms and many failover and recovery mechanisms. It uses a simple extensible data model
+    that allows for online analytic application.
+  - Flume supports Agent configurations via Zookeeper. This is an experimental feature.[5]
+
+### [Apache Hadoop](http://hadoop.apache.org/)
+  - The Apache Hadoop software library is a framework that allows for the distributed processing of large data sets across
+    clusters of computers using simple programming models. It is designed to scale up from single servers to thousands of machines,
+    each offering local computation and storage. Rather than rely on hardware to deliver high-availability,
+    the library itself is designed to detect and handle failures at the application layer, so delivering a highly-available service on top of a cluster of computers, each of which may be prone to failures.
+  - The implementation of automatic HDFS failover relies on ZooKeeper for the following things:
+    - **Failure detection** - each of the NameNode machines in the cluster maintains a persistent session in ZooKeeper.
+      If the machine crashes, the ZooKeeper session will expire, notifying the other NameNode that a failover should be triggered.
+    - **Active NameNode election** - ZooKeeper provides a simple mechanism to exclusively elect a node as active. If the current active NameNode crashes,
+      another node may take a special exclusive lock in ZooKeeper indicating that it should become the next active.
+  - The ZKFailoverController (ZKFC) is a new component which is a ZooKeeper client which also monitors and manages the state of the NameNode.
+    Each of the machines which runs a NameNode also runs a ZKFC, and that ZKFC is responsible for:
+    - **Health monitoring** - the ZKFC pings its local NameNode on a periodic basis with a health-check command.
+      So long as the NameNode responds in a timely fashion with a healthy status, the ZKFC considers the node healthy.
+      If the node has crashed, frozen, or otherwise entered an unhealthy state, the health monitor will mark it as unhealthy.
+    - **ZooKeeper session management** - when the local NameNode is healthy, the ZKFC holds a session open in ZooKeeper.
+      If the local NameNode is active, it also holds a special “lock” znode. This lock uses ZooKeeper’s support for “ephemeral” nodes;
+      if the session expires, the lock node will be automatically deleted.
+    - **ZooKeeper-based election** - if the local NameNode is healthy, and the ZKFC sees that no other node currently holds the lock znode,
+      it will itself try to acquire the lock. If it succeeds, then it has “won the election”, and is responsible for running a failover to make its local NameNode active.
+      The failover process is similar to the manual failover described above: first, the previous active is fenced if necessary,
+      and then the local NameNode transitions to active state.[7]
+
+### [Apache HBase](https://hbase.apache.org/)
+  - HBase is the Hadoop database. It's an open-source, distributed, column-oriented store model.
+  - HBase uses ZooKeeper for master election, server lease management, bootstrapping, and coordination between servers.
+    A distributed Apache HBase installation depends on a running ZooKeeper cluster. All participating nodes and clients
+    need to be able to access the running ZooKeeper ensemble.[8]
+  - As you can see, ZooKeeper is a fundamental part of HBase. All operations that require coordination, such as Regions
+    assignment, Master-Failover, replication, and snapshots, are built on ZooKeeper[20]. 
+
+### [Apache Hedwig](https://bookkeeper.apache.org/docs/r4.2.3/hedwigConsole.html)","[{'comment': 'This is dead', 'commenter': 'eolivelli'}, {'comment': 'this project can not be found any more, Let me delete it.', 'commenter': 'maoling'}, {'comment': ""- I pick up **Apache Pulsar**\r\n\r\n> Pravega https://pravega.io\r\nHerdDB\r\nhttps://github.com/diennea/herddb\r\nBlazingCache https://diennea/blazingcache\r\n\r\nI don't have too much knowledge about these projects,It's couldn't be better that you can write some description for them and me if you want these use cases committed with this PR.\r\nOf course, You can create another PR to do this after this PR has landed."", 'commenter': 'maoling'}, {'comment': '> Where did you find these resources?\r\n\r\nthe main skeleton is from the original [wiki](https://cwiki.apache.org/confluence/display/ZOOKEEPER/PoweredBy), others from my wide knowledge:D', 'commenter': 'maoling'}, {'comment': 'I will update the wiki, so that you can pick the descriptions from there', 'commenter': 'eolivelli'}, {'comment': 'Thanks for this!', 'commenter': 'maoling'}]"
1073,zookeeper-docs/src/main/resources/markdown/zookeeperUseCases.md,"@@ -0,0 +1,377 @@
+<!--
+Copyright 2002-2019 The Apache Software Foundation
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+//-->
+
+# ZooKeeper Use Cases
+
+- Applications and organizations using ZooKeeper include (alphabetically)[1].
+- If your use case wants to be listed here. Please do not hesitate, submit a pull request or write an email to **dev@zookeeper.apache.org**,
+  and then, your use case will be included.
+
+
+## Free Software Projects
+
+### [AdroitLogic UltraESB](http://adroitlogic.org/)
+  - Uses ZooKeeper to implement node coordination, in clustering support. This allows the management of the complete cluster,
+  or any specific node - from any other node connected via JMX. A Cluster wide command framework developed on top of the
+  ZooKeeper coordination allows commands that fail on some nodes to be retried etc. We also support the automated graceful
+  round-robin-restart of a complete cluster of nodes using the same framework.
+
+### [Akka](http://akka.io/)
+  - Akka is the platform for the next generation event-driven, scalable and fault-tolerant architectures on the JVM.
+  Or: Akka is a toolkit and runtime for building highly concurrent, distributed, and fault tolerant event-driven applications on the JVM.
+
+### [Eclipse Communication Framework](http://www.eclipse.org/ecf) 
+  - The Eclipse ECF project provides an implementation of its Abstract Discovery services using Zookeeper. ECF itself
+  is used in many projects providing base functionallity for communication, all based on OSGi.
+
+### [Eclipse Gyrex](http://www.eclipse.org/gyrex)
+  - The Eclipse Gyrex project provides a platform for building your own Java OSGi based clouds. 
+  - ZooKeeper is used as the core cloud component for node membership and management, coordination of jobs executing among workers,
+  a lock service and a simple queue service and a lot more.
+
+### [GoldenOrb](http://www.goldenorbos.org/)
+  - massive-scale Graph analysis
+
+### [Juju](https://juju.ubuntu.com/)
+  - Service deployment and orchestration framework, formerly called Ensemble.
+
+### [Katta](http://katta.sourceforge.net/)
+  - Katta serves distributed Lucene indexes in a grid environment.
+  - Zookeeper is used for node, master and index management in the grid.
+
+### [KeptCollections](https://github.com/anthonyu/KeptCollections)
+  - KeptCollections is a library of drop-in replacements for the data structures in the Java Collections framework.
+  - KeptCollections uses Apache ZooKeeper as a backing store, thus making its data structures distributed and scalable.
+
+### [Neo4j](https://neo4j.com/)
+  - Neo4j is a Graph Database. It's a disk based, ACID compliant transactional storage engine for big graphs and fast graph traversals,
+    using external indicies like Lucene/Solr for global searches.
+  - We use ZooKeeper in the Neo4j High Availability components for write-master election,
+    read slave coordination and other cool stuff. ZooKeeper is a great and focused project - we like!
+
+### [Norbert](http://sna-projects.com/norbert)
+  - Partitioned routing and cluster management.
+
+### [OpenStack Nova](http://www.openstack.org/)
+  - OpenStack  is an open source software stack for the creation and management of private and public clouds. It is designed to manage pools of compute,
+    storage, and networking resources in data centers, allowing the management of these resources through a consolidated dashboard and flexible APIs.
+  - Nova is the software component in OpenStack, which is responsible for managing the compute resources, where virtual machines (VMs) are hosted in a cloud computing environment. It is also known as the OpenStack Compute Service. OpenStack
+    Nova provides a cloud computing fabric controller, supporting a wide variety of virtualization technologies such as KVM, Xen, VMware, and many more. In addition to its native API, it also includes compatibility with Amazon EC2 and S3 APIs.
+    Nova depends on up-to-date information about the availability of the various compute nodes and services that run on them, for its proper operation. For example, the virtual machine placement operation requires to know the currently available compute nodes and their current state.
+    Nova uses ZooKeeper to implement an efficient membership service, which monitors the availability of registered services. This is done through the ZooKeeper ServiceGroup Driver, which works by using ZooKeeper's ephemeral znodes. Each service registers by creating an ephemeral znode on startup. Now, when the service dies, ZooKeeper will automatically delete the corresponding ephemeral znode. The removal of this znode can be used to trigger the corresponding recovery logic.
+    For example, when a compute node crashes, the nova-compute service that is running in that node also dies. This causes the session with ZooKeeper service to expire, and as a result, ZooKeeper deletes the ephemeral znode created by the nova-compute service. If the cloud controller keeps a watch on this node-deletion event, it will come to know about the compute node crash and can trigger a migration procedure to evacuate all the VMs that are running in the failed compute node to other nodes. This way, high availability of the VMs can be ensured in real time.
+  - ZooKeeper is also being considered for the following use cases in OpenStack Nova:
+    - Storing the configuration metadata (nova.conf)
+    - Maintaining high availability of services and automatic failover using
+    leader election
+
+### [spring-cloud-zookeeper](https://spring.io/projects/spring-cloud-zookeeper)
+  - Spring Cloud Zookeeper provides Apache Zookeeper integrations for Spring Boot apps through autoconfiguration
+    and binding to the Spring Environment and other Spring programming model idioms. With a few simple annotations
+    you can quickly enable and configure the common patterns inside your application and build large distributed systems with Zookeeper.
+    The patterns provided include Service Discovery and Distributed Configuration.
+
+### [Talend ESB](http://www.talend.com/products-application-integration/application-integration-esb-se.php)
+  - Talend ESB is a versatile and flexible, enterprise service bus.
+  - It uses ZooKeeper as endpoint repository of both REST and SOAP Web services.
+    By using ZooKeeper Talend ESB is able to provide failover and load balancing capabilities in a very light-weight manner
+
+### [redis_failover](https://github.com/ryanlecompte/redis_failover)
+  - Redis Failover is a ZooKeeper-based automatic master/slave failover solution for Ruby.
+
+
+## Apache Projects","[{'comment': 'other projects I know: Apache Druid (Incubating), Apache Hive', 'commenter': 'hanm'}]"
1073,zookeeper-docs/src/main/resources/markdown/zookeeperUseCases.md,"@@ -0,0 +1,377 @@
+<!--
+Copyright 2002-2019 The Apache Software Foundation
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+//-->
+
+# ZooKeeper Use Cases
+
+- Applications and organizations using ZooKeeper include (alphabetically)[1].
+- If your use case wants to be listed here. Please do not hesitate, submit a pull request or write an email to **dev@zookeeper.apache.org**,
+  and then, your use case will be included.
+
+
+## Free Software Projects
+
+### [AdroitLogic UltraESB](http://adroitlogic.org/)
+  - Uses ZooKeeper to implement node coordination, in clustering support. This allows the management of the complete cluster,
+  or any specific node - from any other node connected via JMX. A Cluster wide command framework developed on top of the
+  ZooKeeper coordination allows commands that fail on some nodes to be retried etc. We also support the automated graceful
+  round-robin-restart of a complete cluster of nodes using the same framework.
+
+### [Akka](http://akka.io/)
+  - Akka is the platform for the next generation event-driven, scalable and fault-tolerant architectures on the JVM.
+  Or: Akka is a toolkit and runtime for building highly concurrent, distributed, and fault tolerant event-driven applications on the JVM.
+
+### [Eclipse Communication Framework](http://www.eclipse.org/ecf) 
+  - The Eclipse ECF project provides an implementation of its Abstract Discovery services using Zookeeper. ECF itself
+  is used in many projects providing base functionallity for communication, all based on OSGi.
+
+### [Eclipse Gyrex](http://www.eclipse.org/gyrex)
+  - The Eclipse Gyrex project provides a platform for building your own Java OSGi based clouds. 
+  - ZooKeeper is used as the core cloud component for node membership and management, coordination of jobs executing among workers,
+  a lock service and a simple queue service and a lot more.
+
+### [GoldenOrb](http://www.goldenorbos.org/)
+  - massive-scale Graph analysis
+
+### [Juju](https://juju.ubuntu.com/)
+  - Service deployment and orchestration framework, formerly called Ensemble.
+
+### [Katta](http://katta.sourceforge.net/)
+  - Katta serves distributed Lucene indexes in a grid environment.
+  - Zookeeper is used for node, master and index management in the grid.
+
+### [KeptCollections](https://github.com/anthonyu/KeptCollections)
+  - KeptCollections is a library of drop-in replacements for the data structures in the Java Collections framework.
+  - KeptCollections uses Apache ZooKeeper as a backing store, thus making its data structures distributed and scalable.
+
+### [Neo4j](https://neo4j.com/)
+  - Neo4j is a Graph Database. It's a disk based, ACID compliant transactional storage engine for big graphs and fast graph traversals,
+    using external indicies like Lucene/Solr for global searches.
+  - We use ZooKeeper in the Neo4j High Availability components for write-master election,
+    read slave coordination and other cool stuff. ZooKeeper is a great and focused project - we like!
+
+### [Norbert](http://sna-projects.com/norbert)
+  - Partitioned routing and cluster management.
+
+### [OpenStack Nova](http://www.openstack.org/)
+  - OpenStack  is an open source software stack for the creation and management of private and public clouds. It is designed to manage pools of compute,
+    storage, and networking resources in data centers, allowing the management of these resources through a consolidated dashboard and flexible APIs.
+  - Nova is the software component in OpenStack, which is responsible for managing the compute resources, where virtual machines (VMs) are hosted in a cloud computing environment. It is also known as the OpenStack Compute Service. OpenStack
+    Nova provides a cloud computing fabric controller, supporting a wide variety of virtualization technologies such as KVM, Xen, VMware, and many more. In addition to its native API, it also includes compatibility with Amazon EC2 and S3 APIs.
+    Nova depends on up-to-date information about the availability of the various compute nodes and services that run on them, for its proper operation. For example, the virtual machine placement operation requires to know the currently available compute nodes and their current state.
+    Nova uses ZooKeeper to implement an efficient membership service, which monitors the availability of registered services. This is done through the ZooKeeper ServiceGroup Driver, which works by using ZooKeeper's ephemeral znodes. Each service registers by creating an ephemeral znode on startup. Now, when the service dies, ZooKeeper will automatically delete the corresponding ephemeral znode. The removal of this znode can be used to trigger the corresponding recovery logic.
+    For example, when a compute node crashes, the nova-compute service that is running in that node also dies. This causes the session with ZooKeeper service to expire, and as a result, ZooKeeper deletes the ephemeral znode created by the nova-compute service. If the cloud controller keeps a watch on this node-deletion event, it will come to know about the compute node crash and can trigger a migration procedure to evacuate all the VMs that are running in the failed compute node to other nodes. This way, high availability of the VMs can be ensured in real time.
+  - ZooKeeper is also being considered for the following use cases in OpenStack Nova:
+    - Storing the configuration metadata (nova.conf)
+    - Maintaining high availability of services and automatic failover using
+    leader election
+
+### [spring-cloud-zookeeper](https://spring.io/projects/spring-cloud-zookeeper)
+  - Spring Cloud Zookeeper provides Apache Zookeeper integrations for Spring Boot apps through autoconfiguration
+    and binding to the Spring Environment and other Spring programming model idioms. With a few simple annotations
+    you can quickly enable and configure the common patterns inside your application and build large distributed systems with Zookeeper.
+    The patterns provided include Service Discovery and Distributed Configuration.
+
+### [Talend ESB](http://www.talend.com/products-application-integration/application-integration-esb-se.php)
+  - Talend ESB is a versatile and flexible, enterprise service bus.
+  - It uses ZooKeeper as endpoint repository of both REST and SOAP Web services.
+    By using ZooKeeper Talend ESB is able to provide failover and load balancing capabilities in a very light-weight manner
+
+### [redis_failover](https://github.com/ryanlecompte/redis_failover)
+  - Redis Failover is a ZooKeeper-based automatic master/slave failover solution for Ruby.
+
+
+## Apache Projects
+
+### [Apache Accumulo](https://accumulo.apache.org/)
+  - Accumulo is a distributed key/value store that provides expressive, cell-level access labels.
+  - Apache ZooKeeper plays a central role within the Accumulo architecture. Its quorum consistency model supports an overall
+    Accumulo architecture with no single points of failure. Beyond that, Accumulo leverages ZooKeeper to store and communication 
+    configuration information for users and tables, as well as operational states of processes and tablets.[2]
+
+### [Apache BookKeeper](https://bookkeeper.apache.org/)
+  - A scalable, fault-tolerant, and low-latency storage service optimized for real-time workloads.
+  - BookKeeper requires a metadata storage service to store information related to ledgers and available bookies. BookKeeper currently uses
+    ZooKeeper for this and other tasks[3].
+
+### [Apache CXF DOSGi](http://cxf.apache.org/distributed-osgi.html)
+  - Apache CXF is an open source services framework. CXF helps you build and develop services using frontend programming
+    APIs, like JAX-WS and JAX-RS. These services can speak a variety of protocols such as SOAP, XML/HTTP, RESTful HTTP,
+    or CORBA and work over a variety of transports such as HTTP, JMS or JBI.
+  - The Distributed OSGi implementation at Apache CXF uses ZooKeeper for its Discovery functionality.[4]
+
+### [Apache Dubbo](http://dubbo.apache.org)
+  - Apache Dubbo is a high-performance, java based open source RPC framework.
+  - Zookeeper is used for service registration discovery and configuration management in Dubbo.[6]
+
+### [Apache Flink](https://flink.apache.org/)
+  - Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.
+    Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale.
+  - To enable JobManager High Availability you have to set the high-availability mode to zookeeper, configure a ZooKeeper quorum and set up a masters file with all JobManagers hosts and their web UI ports.
+    Flink leverages ZooKeeper for distributed coordination between all running JobManager instances. ZooKeeper is a separate service from Flink,
+    which provides highly reliable distributed coordination via leader election and light-weight consistent state storage[23].
+
+### [Apache Flume](https://flume.apache.org/)
+  - Flume is a distributed, reliable, and available service for efficiently collecting, aggregating, and moving large amounts
+    of log data. It has a simple and flexible architecture based on streaming data flows. It is robust and fault tolerant
+    with tunable reliability mechanisms and many failover and recovery mechanisms. It uses a simple extensible data model
+    that allows for online analytic application.
+  - Flume supports Agent configurations via Zookeeper. This is an experimental feature.[5]
+
+### [Apache Hadoop](http://hadoop.apache.org/)
+  - The Apache Hadoop software library is a framework that allows for the distributed processing of large data sets across
+    clusters of computers using simple programming models. It is designed to scale up from single servers to thousands of machines,
+    each offering local computation and storage. Rather than rely on hardware to deliver high-availability,
+    the library itself is designed to detect and handle failures at the application layer, so delivering a highly-available service on top of a cluster of computers, each of which may be prone to failures.
+  - The implementation of automatic HDFS failover relies on ZooKeeper for the following things:
+    - **Failure detection** - each of the NameNode machines in the cluster maintains a persistent session in ZooKeeper.
+      If the machine crashes, the ZooKeeper session will expire, notifying the other NameNode that a failover should be triggered.
+    - **Active NameNode election** - ZooKeeper provides a simple mechanism to exclusively elect a node as active. If the current active NameNode crashes,
+      another node may take a special exclusive lock in ZooKeeper indicating that it should become the next active.
+  - The ZKFailoverController (ZKFC) is a new component which is a ZooKeeper client which also monitors and manages the state of the NameNode.
+    Each of the machines which runs a NameNode also runs a ZKFC, and that ZKFC is responsible for:
+    - **Health monitoring** - the ZKFC pings its local NameNode on a periodic basis with a health-check command.
+      So long as the NameNode responds in a timely fashion with a healthy status, the ZKFC considers the node healthy.
+      If the node has crashed, frozen, or otherwise entered an unhealthy state, the health monitor will mark it as unhealthy.
+    - **ZooKeeper session management** - when the local NameNode is healthy, the ZKFC holds a session open in ZooKeeper.
+      If the local NameNode is active, it also holds a special “lock” znode. This lock uses ZooKeeper’s support for “ephemeral” nodes;
+      if the session expires, the lock node will be automatically deleted.
+    - **ZooKeeper-based election** - if the local NameNode is healthy, and the ZKFC sees that no other node currently holds the lock znode,
+      it will itself try to acquire the lock. If it succeeds, then it has “won the election”, and is responsible for running a failover to make its local NameNode active.
+      The failover process is similar to the manual failover described above: first, the previous active is fenced if necessary,
+      and then the local NameNode transitions to active state.[7]
+
+### [Apache HBase](https://hbase.apache.org/)
+  - HBase is the Hadoop database. It's an open-source, distributed, column-oriented store model.
+  - HBase uses ZooKeeper for master election, server lease management, bootstrapping, and coordination between servers.
+    A distributed Apache HBase installation depends on a running ZooKeeper cluster. All participating nodes and clients
+    need to be able to access the running ZooKeeper ensemble.[8]
+  - As you can see, ZooKeeper is a fundamental part of HBase. All operations that require coordination, such as Regions
+    assignment, Master-Failover, replication, and snapshots, are built on ZooKeeper[20]. 
+
+### [Apache Hedwig](https://bookkeeper.apache.org/docs/r4.2.3/hedwigConsole.html)
+  - Hedwig is a publish-subscribe system designed to carry large amounts of data across the internet in a guaranteed-delivery
+    fashion from those who produce it (publishers) to those who are interested in it (subscribers).
+
+### [Apache Helix](http://helix.apache.org/)
+  - Apache Helix is a cluster management framework for partitioned and replicated distributed resources.
+  - It provides a generic way of automatically managing the resources in a cluster. Helix acts as a decision subsystem for the cluster, and is responsible for the following tasks and many more:
+    - Automating the reassignment of resources to the nodes
+    - Handling node failure detection and recovery
+    - Dynamic cluster reconfiguration (node and resource addition/deletion)
+    - Scheduling of maintenance tasks (backups, index rebuilds, and so on)
+    - Maintaining load balancing and flow control in the cluster
+    In order to store the current cluster state, Helix needs a distributed and highly available configuration or cluster metadata store, for which it uses ZooKeeper.
+  - ZooKeeper provides Helix with the following capabilities:
+    - This framework represents the PERSISTENT state, which remains until it's removed
+    - This framework also represents the TRANSIENT/EPHEMERAL state, which goes away when the process that created the state leaves the cluster
+    - This framework notifies the subsystem when there is a change in the PERSISTENT and EPHEMERAL state of the cluster
+  - Helix also allows simple lookups of task assignments through the configuration store built on top of ZooKeeper. Through this, clients can look up where the tasks are currently assigned.
+    This way, Helix can also provide a service discovery registry.[21]
+
+### [Apache Kafka](https://kafka.apache.org/)
+  - Kafka is a distributed publish/subscribe messaging system
+  - Apache Kafka relies on ZooKeeper for the following things:
+    - **Controller election**
+    The controller is one of the most important broking entity in a Kafka ecosystem, and it also has the responsibility
+    to maintain the leader-follower relationship across all the partitions. If a node by some reason is shutting down,
+    it’s the controller’s responsibility to tell all the replicas to act as partition leaders in order to fulfill the
+    duties of the partition leaders on the node that is about to fail. So, whenever a node shuts down, a new controller
+    can be elected and it can also be made sure that at any given time, there is only one controller and all the follower nodes have agreed on that.
+    - **Configuration Of Topics**
+    The configuration regarding all the topics including the list of existing topics, the number of partitions for each topic,
+    the location of all the replicas, list of configuration overrides for all topics and which node is the preferred leader, etc.
+    - **Access control lists**
+    Access control lists or ACLs for all the topics are also maintained within Zookeeper.
+    - **Membership of the cluster**
+    Zookeeper also maintains a list of all the brokers that are functioning at any given moment and are a part of the cluster.[9]
+
+### [Apache Mesos](http://mesos.apache.org/)
+  - Apache Mesos abstracts CPU, memory, storage, and other compute resources away from machines (physical or virtual),
+    enabling fault-tolerant and elastic distributed systems to easily be built and run effectively.
+  - Mesos has a high-availability mode that uses multiple Mesos masters: one active master (called the leader or leading master)
+    and several backups in case it fails. The masters elect the leader, with Apache ZooKeeper both coordinating the election
+    and handling leader detection by masters, agents, and scheduler drivers.[10]
+
+### [Apache S4](https://github.com/apache/incubator-retired-s4)
+  - S4(**retired** on 2014-06-19[11]) is a general-purpose, distributed, scalable, partially fault-tolerant, pluggable platform that allows programmers
+    to easily develop applications for processing continuous unbounded streams of data.
+
+### [Apache Solr](https://lucene.apache.org/solr/)
+  - Solr is the popular, blazing-fast, open source enterprise search platform built on Apache Lucene.
+  - In the ""Cloud"" edition (v4.x and up) of enterprise search engine Apache Solr, ZooKeeper is used for configuration,
+    leader election and more[12,13]
+
+### [Apache Spark](https://spark.apache.org/)
+  - Apache Spark is a unified analytics engine for large-scale data processing.
+  - Utilizing ZooKeeper to provide leader election and some state storage, you can launch multiple Masters in your cluster connected to the same ZooKeeper instance.
+    One will be elected “leader” and the others will remain in standby mode. If the current leader dies, another Master will be elected,
+    recover the old Master’s state, and then resume scheduling[14]
+
+
+## Companies
+
+### [101tec](http://101tec.com/)","[{'comment': 'this should be removed.', 'commenter': 'hanm'}]"
1073,zookeeper-docs/src/main/resources/markdown/zookeeperUseCases.md,"@@ -0,0 +1,377 @@
+<!--
+Copyright 2002-2019 The Apache Software Foundation
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+//-->
+
+# ZooKeeper Use Cases
+
+- Applications and organizations using ZooKeeper include (alphabetically)[1].
+- If your use case wants to be listed here. Please do not hesitate, submit a pull request or write an email to **dev@zookeeper.apache.org**,
+  and then, your use case will be included.
+
+
+## Free Software Projects
+
+### [AdroitLogic UltraESB](http://adroitlogic.org/)
+  - Uses ZooKeeper to implement node coordination, in clustering support. This allows the management of the complete cluster,
+  or any specific node - from any other node connected via JMX. A Cluster wide command framework developed on top of the
+  ZooKeeper coordination allows commands that fail on some nodes to be retried etc. We also support the automated graceful
+  round-robin-restart of a complete cluster of nodes using the same framework.
+
+### [Akka](http://akka.io/)
+  - Akka is the platform for the next generation event-driven, scalable and fault-tolerant architectures on the JVM.
+  Or: Akka is a toolkit and runtime for building highly concurrent, distributed, and fault tolerant event-driven applications on the JVM.
+
+### [Eclipse Communication Framework](http://www.eclipse.org/ecf) 
+  - The Eclipse ECF project provides an implementation of its Abstract Discovery services using Zookeeper. ECF itself
+  is used in many projects providing base functionallity for communication, all based on OSGi.
+
+### [Eclipse Gyrex](http://www.eclipse.org/gyrex)
+  - The Eclipse Gyrex project provides a platform for building your own Java OSGi based clouds. 
+  - ZooKeeper is used as the core cloud component for node membership and management, coordination of jobs executing among workers,
+  a lock service and a simple queue service and a lot more.
+
+### [GoldenOrb](http://www.goldenorbos.org/)
+  - massive-scale Graph analysis
+
+### [Juju](https://juju.ubuntu.com/)
+  - Service deployment and orchestration framework, formerly called Ensemble.
+
+### [Katta](http://katta.sourceforge.net/)
+  - Katta serves distributed Lucene indexes in a grid environment.
+  - Zookeeper is used for node, master and index management in the grid.
+
+### [KeptCollections](https://github.com/anthonyu/KeptCollections)
+  - KeptCollections is a library of drop-in replacements for the data structures in the Java Collections framework.
+  - KeptCollections uses Apache ZooKeeper as a backing store, thus making its data structures distributed and scalable.
+
+### [Neo4j](https://neo4j.com/)
+  - Neo4j is a Graph Database. It's a disk based, ACID compliant transactional storage engine for big graphs and fast graph traversals,
+    using external indicies like Lucene/Solr for global searches.
+  - We use ZooKeeper in the Neo4j High Availability components for write-master election,
+    read slave coordination and other cool stuff. ZooKeeper is a great and focused project - we like!
+
+### [Norbert](http://sna-projects.com/norbert)
+  - Partitioned routing and cluster management.
+
+### [OpenStack Nova](http://www.openstack.org/)
+  - OpenStack  is an open source software stack for the creation and management of private and public clouds. It is designed to manage pools of compute,
+    storage, and networking resources in data centers, allowing the management of these resources through a consolidated dashboard and flexible APIs.
+  - Nova is the software component in OpenStack, which is responsible for managing the compute resources, where virtual machines (VMs) are hosted in a cloud computing environment. It is also known as the OpenStack Compute Service. OpenStack
+    Nova provides a cloud computing fabric controller, supporting a wide variety of virtualization technologies such as KVM, Xen, VMware, and many more. In addition to its native API, it also includes compatibility with Amazon EC2 and S3 APIs.
+    Nova depends on up-to-date information about the availability of the various compute nodes and services that run on them, for its proper operation. For example, the virtual machine placement operation requires to know the currently available compute nodes and their current state.
+    Nova uses ZooKeeper to implement an efficient membership service, which monitors the availability of registered services. This is done through the ZooKeeper ServiceGroup Driver, which works by using ZooKeeper's ephemeral znodes. Each service registers by creating an ephemeral znode on startup. Now, when the service dies, ZooKeeper will automatically delete the corresponding ephemeral znode. The removal of this znode can be used to trigger the corresponding recovery logic.
+    For example, when a compute node crashes, the nova-compute service that is running in that node also dies. This causes the session with ZooKeeper service to expire, and as a result, ZooKeeper deletes the ephemeral znode created by the nova-compute service. If the cloud controller keeps a watch on this node-deletion event, it will come to know about the compute node crash and can trigger a migration procedure to evacuate all the VMs that are running in the failed compute node to other nodes. This way, high availability of the VMs can be ensured in real time.
+  - ZooKeeper is also being considered for the following use cases in OpenStack Nova:
+    - Storing the configuration metadata (nova.conf)
+    - Maintaining high availability of services and automatic failover using
+    leader election
+
+### [spring-cloud-zookeeper](https://spring.io/projects/spring-cloud-zookeeper)
+  - Spring Cloud Zookeeper provides Apache Zookeeper integrations for Spring Boot apps through autoconfiguration
+    and binding to the Spring Environment and other Spring programming model idioms. With a few simple annotations
+    you can quickly enable and configure the common patterns inside your application and build large distributed systems with Zookeeper.
+    The patterns provided include Service Discovery and Distributed Configuration.
+
+### [Talend ESB](http://www.talend.com/products-application-integration/application-integration-esb-se.php)
+  - Talend ESB is a versatile and flexible, enterprise service bus.
+  - It uses ZooKeeper as endpoint repository of both REST and SOAP Web services.
+    By using ZooKeeper Talend ESB is able to provide failover and load balancing capabilities in a very light-weight manner
+
+### [redis_failover](https://github.com/ryanlecompte/redis_failover)
+  - Redis Failover is a ZooKeeper-based automatic master/slave failover solution for Ruby.
+
+
+## Apache Projects
+
+### [Apache Accumulo](https://accumulo.apache.org/)
+  - Accumulo is a distributed key/value store that provides expressive, cell-level access labels.
+  - Apache ZooKeeper plays a central role within the Accumulo architecture. Its quorum consistency model supports an overall
+    Accumulo architecture with no single points of failure. Beyond that, Accumulo leverages ZooKeeper to store and communication 
+    configuration information for users and tables, as well as operational states of processes and tablets.[2]
+
+### [Apache BookKeeper](https://bookkeeper.apache.org/)
+  - A scalable, fault-tolerant, and low-latency storage service optimized for real-time workloads.
+  - BookKeeper requires a metadata storage service to store information related to ledgers and available bookies. BookKeeper currently uses
+    ZooKeeper for this and other tasks[3].
+
+### [Apache CXF DOSGi](http://cxf.apache.org/distributed-osgi.html)
+  - Apache CXF is an open source services framework. CXF helps you build and develop services using frontend programming
+    APIs, like JAX-WS and JAX-RS. These services can speak a variety of protocols such as SOAP, XML/HTTP, RESTful HTTP,
+    or CORBA and work over a variety of transports such as HTTP, JMS or JBI.
+  - The Distributed OSGi implementation at Apache CXF uses ZooKeeper for its Discovery functionality.[4]
+
+### [Apache Dubbo](http://dubbo.apache.org)
+  - Apache Dubbo is a high-performance, java based open source RPC framework.
+  - Zookeeper is used for service registration discovery and configuration management in Dubbo.[6]
+
+### [Apache Flink](https://flink.apache.org/)
+  - Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.
+    Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale.
+  - To enable JobManager High Availability you have to set the high-availability mode to zookeeper, configure a ZooKeeper quorum and set up a masters file with all JobManagers hosts and their web UI ports.
+    Flink leverages ZooKeeper for distributed coordination between all running JobManager instances. ZooKeeper is a separate service from Flink,
+    which provides highly reliable distributed coordination via leader election and light-weight consistent state storage[23].
+
+### [Apache Flume](https://flume.apache.org/)
+  - Flume is a distributed, reliable, and available service for efficiently collecting, aggregating, and moving large amounts
+    of log data. It has a simple and flexible architecture based on streaming data flows. It is robust and fault tolerant
+    with tunable reliability mechanisms and many failover and recovery mechanisms. It uses a simple extensible data model
+    that allows for online analytic application.
+  - Flume supports Agent configurations via Zookeeper. This is an experimental feature.[5]
+
+### [Apache Hadoop](http://hadoop.apache.org/)
+  - The Apache Hadoop software library is a framework that allows for the distributed processing of large data sets across
+    clusters of computers using simple programming models. It is designed to scale up from single servers to thousands of machines,
+    each offering local computation and storage. Rather than rely on hardware to deliver high-availability,
+    the library itself is designed to detect and handle failures at the application layer, so delivering a highly-available service on top of a cluster of computers, each of which may be prone to failures.
+  - The implementation of automatic HDFS failover relies on ZooKeeper for the following things:
+    - **Failure detection** - each of the NameNode machines in the cluster maintains a persistent session in ZooKeeper.
+      If the machine crashes, the ZooKeeper session will expire, notifying the other NameNode that a failover should be triggered.
+    - **Active NameNode election** - ZooKeeper provides a simple mechanism to exclusively elect a node as active. If the current active NameNode crashes,
+      another node may take a special exclusive lock in ZooKeeper indicating that it should become the next active.
+  - The ZKFailoverController (ZKFC) is a new component which is a ZooKeeper client which also monitors and manages the state of the NameNode.
+    Each of the machines which runs a NameNode also runs a ZKFC, and that ZKFC is responsible for:
+    - **Health monitoring** - the ZKFC pings its local NameNode on a periodic basis with a health-check command.
+      So long as the NameNode responds in a timely fashion with a healthy status, the ZKFC considers the node healthy.
+      If the node has crashed, frozen, or otherwise entered an unhealthy state, the health monitor will mark it as unhealthy.
+    - **ZooKeeper session management** - when the local NameNode is healthy, the ZKFC holds a session open in ZooKeeper.
+      If the local NameNode is active, it also holds a special “lock” znode. This lock uses ZooKeeper’s support for “ephemeral” nodes;
+      if the session expires, the lock node will be automatically deleted.
+    - **ZooKeeper-based election** - if the local NameNode is healthy, and the ZKFC sees that no other node currently holds the lock znode,
+      it will itself try to acquire the lock. If it succeeds, then it has “won the election”, and is responsible for running a failover to make its local NameNode active.
+      The failover process is similar to the manual failover described above: first, the previous active is fenced if necessary,
+      and then the local NameNode transitions to active state.[7]
+
+### [Apache HBase](https://hbase.apache.org/)
+  - HBase is the Hadoop database. It's an open-source, distributed, column-oriented store model.
+  - HBase uses ZooKeeper for master election, server lease management, bootstrapping, and coordination between servers.
+    A distributed Apache HBase installation depends on a running ZooKeeper cluster. All participating nodes and clients
+    need to be able to access the running ZooKeeper ensemble.[8]
+  - As you can see, ZooKeeper is a fundamental part of HBase. All operations that require coordination, such as Regions
+    assignment, Master-Failover, replication, and snapshots, are built on ZooKeeper[20]. 
+
+### [Apache Hedwig](https://bookkeeper.apache.org/docs/r4.2.3/hedwigConsole.html)
+  - Hedwig is a publish-subscribe system designed to carry large amounts of data across the internet in a guaranteed-delivery
+    fashion from those who produce it (publishers) to those who are interested in it (subscribers).
+
+### [Apache Helix](http://helix.apache.org/)
+  - Apache Helix is a cluster management framework for partitioned and replicated distributed resources.
+  - It provides a generic way of automatically managing the resources in a cluster. Helix acts as a decision subsystem for the cluster, and is responsible for the following tasks and many more:
+    - Automating the reassignment of resources to the nodes
+    - Handling node failure detection and recovery
+    - Dynamic cluster reconfiguration (node and resource addition/deletion)
+    - Scheduling of maintenance tasks (backups, index rebuilds, and so on)
+    - Maintaining load balancing and flow control in the cluster
+    In order to store the current cluster state, Helix needs a distributed and highly available configuration or cluster metadata store, for which it uses ZooKeeper.
+  - ZooKeeper provides Helix with the following capabilities:
+    - This framework represents the PERSISTENT state, which remains until it's removed
+    - This framework also represents the TRANSIENT/EPHEMERAL state, which goes away when the process that created the state leaves the cluster
+    - This framework notifies the subsystem when there is a change in the PERSISTENT and EPHEMERAL state of the cluster
+  - Helix also allows simple lookups of task assignments through the configuration store built on top of ZooKeeper. Through this, clients can look up where the tasks are currently assigned.
+    This way, Helix can also provide a service discovery registry.[21]
+
+### [Apache Kafka](https://kafka.apache.org/)
+  - Kafka is a distributed publish/subscribe messaging system
+  - Apache Kafka relies on ZooKeeper for the following things:
+    - **Controller election**
+    The controller is one of the most important broking entity in a Kafka ecosystem, and it also has the responsibility
+    to maintain the leader-follower relationship across all the partitions. If a node by some reason is shutting down,
+    it’s the controller’s responsibility to tell all the replicas to act as partition leaders in order to fulfill the
+    duties of the partition leaders on the node that is about to fail. So, whenever a node shuts down, a new controller
+    can be elected and it can also be made sure that at any given time, there is only one controller and all the follower nodes have agreed on that.
+    - **Configuration Of Topics**
+    The configuration regarding all the topics including the list of existing topics, the number of partitions for each topic,
+    the location of all the replicas, list of configuration overrides for all topics and which node is the preferred leader, etc.
+    - **Access control lists**
+    Access control lists or ACLs for all the topics are also maintained within Zookeeper.
+    - **Membership of the cluster**
+    Zookeeper also maintains a list of all the brokers that are functioning at any given moment and are a part of the cluster.[9]
+
+### [Apache Mesos](http://mesos.apache.org/)
+  - Apache Mesos abstracts CPU, memory, storage, and other compute resources away from machines (physical or virtual),
+    enabling fault-tolerant and elastic distributed systems to easily be built and run effectively.
+  - Mesos has a high-availability mode that uses multiple Mesos masters: one active master (called the leader or leading master)
+    and several backups in case it fails. The masters elect the leader, with Apache ZooKeeper both coordinating the election
+    and handling leader detection by masters, agents, and scheduler drivers.[10]
+
+### [Apache S4](https://github.com/apache/incubator-retired-s4)
+  - S4(**retired** on 2014-06-19[11]) is a general-purpose, distributed, scalable, partially fault-tolerant, pluggable platform that allows programmers
+    to easily develop applications for processing continuous unbounded streams of data.
+
+### [Apache Solr](https://lucene.apache.org/solr/)
+  - Solr is the popular, blazing-fast, open source enterprise search platform built on Apache Lucene.
+  - In the ""Cloud"" edition (v4.x and up) of enterprise search engine Apache Solr, ZooKeeper is used for configuration,
+    leader election and more[12,13]
+
+### [Apache Spark](https://spark.apache.org/)
+  - Apache Spark is a unified analytics engine for large-scale data processing.
+  - Utilizing ZooKeeper to provide leader election and some state storage, you can launch multiple Masters in your cluster connected to the same ZooKeeper instance.
+    One will be elected “leader” and the others will remain in standby mode. If the current leader dies, another Master will be elected,
+    recover the old Master’s state, and then resume scheduling[14]
+
+
+## Companies
+
+### [101tec](http://101tec.com/)
+ - we do consulting in the area of enterprise distributed systems.
+ - We use zookeeper to manage a system build out of hadoop, katta, oracle batch jobs and a web component.
+
+### [AGETO](http://www.ageto.de/)
+ - The AGETO RnD team uses ZooKeeper in a variety of internal as well as external consulting projects.
+
+### [Benipal Technologies](http://www.benipaltechnologies.com/)
+ - ZooKeeper is used for internal application development with Solr and Hadoop with Hbase.
+
+### [Box](http://box.net/)
+ - Box uses ZooKeeper for service discovery, service coordination, Solr and Hadoop support, etc.
+
+### [Deepdyve](http://www.deepdyve.com/)
+ - We do search for research and provide access to high quality content using advanced search technologies Zookeeper is used to
+   manage server state, control index deployment and a myriad other tasks.
+
+### [eBay](https://www.ebay.com/)
+ - eBay uses ZooKeeper to develop a job type limiter. The job limiter limits the execution of the same type of jobs from running simultaneously beyond a specified number in the grid.
+   For each job type, the type limiter keeps track of the running count and the limit. When the running count hits the limit, spawning of a new job
+   is not allowed until a job of that type finishes or terminates. This job type limiter is used for jobs that use third-party services using APIs to update the maximum bid for keyword ads.
+   Usually, the API call capacity is limited. Even if the grid has enough capacity to run hundreds of jobs, the job limiter system built with ZooKeeper allows
+   only a predetermined number (for example, N) of concurrent jobs against a partner API. The type limiter ensures that the (N+1)th job waits until one of the N running jobs has completed[21,22].
+
+### [Facebook](https://www.facebook.com/)
+ - Facebook uses ZooKeeper in its messaging platform and many other use cases. Facebook's messaging system is powered by a system called cell system.
+   The entire messaging system (e-mail, SMS, Facebook Chat, and the Facebook Inbox) is divided into cells. Cells are composed of a cluster of servers and services,
+   and each cell serves only a fraction of Facebook users. The use of cells has the following advantages:
+   - Incremental scaling with minuscule failures
+   - Easy upgrading of hardware and software
+   - Failures affect only the cell boundary, which affects limited users
+   - Hosting cells in distributed data centers avoids disasters
+   - Each cell comprises a cluster of servers and is coordinated by a ZooKeeper ensemble. The servers that host a particular application register themselves with ZooKeeper.
+     The mapping between users and servers is then done using the consistent hashing algorithm. Basically, the nodes are arranged in a ring,
+     and each node is responsible for a specified range of the users depending on the hash values.
+   - If a node fails, another node in the neighboring position in the ring takes over the load for those users affected by the failure.
+     This allows for an even distribution of the load and also enables easy addition and removal of nodes into and from the cluster in the cell[21].
+ - Facebook uses the Zeus([17,18]) for configuration management which is a forked version of ZooKeeper, with many scalability
+   and performance en- hancements in order to work at the Facebook scale.
+   It runs a consensus protocol among servers distributed across mul- tiple regions for resilience. If the leader fails,
+   a follower is converted into a new leader.
+
+### [Idium Portal](http://www.idium.no/no/idium_portal/)
+ - Idium Portal is a hosted web-publishing system delivered by Norwegian company, Idium AS.
+ - ZooKeeper is used for cluster messaging, service bootstrapping, and service coordination.
+
+### [Makara](http://www.makara.com/)
+ - Using ZooKeeper on 2-node cluster on VMware workstation, Amazon EC2, Zen
+ - Using zkpython
+ - Looking into expanding into 100 node cluster
+
+### [Midokura](http://www.midokura.com/)
+ - We do virtualized networking for the cloud computing era. We use ZooKeeper for various aspects of our distributed control plane.
+
+### [Netflix](https://www.netflix.com)
+ - Netflix([21]) is an avid ZooKeeper user in its distributed platform, which led them to develop Curator and Exhibitor to enhance the functionalities of ZooKeeper.
+   A few of the use cases of ZooKeeper/Curator at Netflix are as follows:
+    - Ensuring the generation of unique values in various sequence ID generators
+    - Cassandra backups
+    - Implementing the TrackID service
+    - Performing leader election with ZooKeeper for various distributed tasks
+    - Implementing a distributed semaphore for concurrent jobs
+    - Distributed caching
+
+### [Nutanix](http://www.nutanix.com/)
+  - Nutanix develops a hyper-converged storage and compute solution, which leverages local components of a host machine, such as storage capacity (disks) and compute (CPUs),
+    to create a distributed platform for virtualization. This solution is known as the Nutanix Virtual Computing Platform. It supports industry-standard hypervisor ESXi, KVM, and Hyper-V.
+    The platform is bundled in the appliance form factor with two nodes or four nodes. A VM in the platform known as the Nutanix Controller VM works as the decision subsystem, which manages the platform.
+  - The Nutanix platform uses Apache ZooKeeper as a Cluster configuration manager. The configuration data that pertains to the platform, such as hostnames, IP addresses,
+    and the cluster state, is stored in a ZooKeeper ensemble. ZooKeeper is also used to query the state of the various services that run in the platform[21].
+
+### [Pinterest](https://www.pinterest.com/)
+ - Pinterest uses the ZooKeeper for Service discovery and dynamic configuration.Like many large scale web sites, Pinterest’s infrastructure consists of servers that communicate with
+   backend services composed of a number of individual servers for managing load and fault tolerance. Ideally, we’d like the configuration to reflect only the active hosts,
+   so clients don’t need to deal with bad hosts as often. ZooKeeper provides a well known pattern to solve this problem[19].
+
+### [Rackspace](http://www.rackspace.com/email_hosting)
+ - The Email & Apps team uses ZooKeeper to coordinate sharding and responsibility changes in a distributed e-mail client
+   that pulls and indexes data for search. ZooKeeper also provides distributed locking for connections to prevent a cluster from overwhelming servers.
+
+### [Sematext](http://sematext.com/)
+ - Uses ZooKeeper in SPM (which includes ZooKeeper monitoring component, too!), Search Analytics, and Logsene.
+
+### [Tubemogul](http://tubemogul.com/)
+ - Uses ZooKeeper for leader election, configuration management, locking, group membership
+
+### [Twitter](https://twitter.com/)
+ - ZooKeeper is used at Twitter as the source of truth for storing critical metadata. It serves as a coordination kernel to
+   provide distributed coordination services, such as leader election and distributed locking.
+   Some concrete examples of ZooKeeper in action include[15,16]:
+   - ZooKeeper is used to store service registry, which is used by Twitter’s naming service for service discovery.
+   - Manhattan, Twitter’s in-house key-value database, stores its cluster topology information in ZooKeeper.","[{'comment': ""I'd like to add a little bit more content here:\r\n`Manhattan (Twitter’s in-house key-value database), Nighthawk (sharded Redis), and Blobstore (in-house photo and video storage),  store their cluster topology information in ZooKeeper.`"", 'commenter': 'hanm'}]"
1073,zookeeper-docs/src/main/resources/markdown/zookeeperUseCases.md,"@@ -0,0 +1,377 @@
+<!--
+Copyright 2002-2019 The Apache Software Foundation
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+//-->
+
+# ZooKeeper Use Cases
+
+- Applications and organizations using ZooKeeper include (alphabetically)[1].
+- If your use case wants to be listed here. Please do not hesitate, submit a pull request or write an email to **dev@zookeeper.apache.org**,
+  and then, your use case will be included.
+
+
+## Free Software Projects
+
+### [AdroitLogic UltraESB](http://adroitlogic.org/)
+  - Uses ZooKeeper to implement node coordination, in clustering support. This allows the management of the complete cluster,
+  or any specific node - from any other node connected via JMX. A Cluster wide command framework developed on top of the
+  ZooKeeper coordination allows commands that fail on some nodes to be retried etc. We also support the automated graceful
+  round-robin-restart of a complete cluster of nodes using the same framework.
+
+### [Akka](http://akka.io/)
+  - Akka is the platform for the next generation event-driven, scalable and fault-tolerant architectures on the JVM.
+  Or: Akka is a toolkit and runtime for building highly concurrent, distributed, and fault tolerant event-driven applications on the JVM.
+
+### [Eclipse Communication Framework](http://www.eclipse.org/ecf) 
+  - The Eclipse ECF project provides an implementation of its Abstract Discovery services using Zookeeper. ECF itself
+  is used in many projects providing base functionallity for communication, all based on OSGi.
+
+### [Eclipse Gyrex](http://www.eclipse.org/gyrex)
+  - The Eclipse Gyrex project provides a platform for building your own Java OSGi based clouds. 
+  - ZooKeeper is used as the core cloud component for node membership and management, coordination of jobs executing among workers,
+  a lock service and a simple queue service and a lot more.
+
+### [GoldenOrb](http://www.goldenorbos.org/)
+  - massive-scale Graph analysis
+
+### [Juju](https://juju.ubuntu.com/)
+  - Service deployment and orchestration framework, formerly called Ensemble.
+
+### [Katta](http://katta.sourceforge.net/)
+  - Katta serves distributed Lucene indexes in a grid environment.
+  - Zookeeper is used for node, master and index management in the grid.
+
+### [KeptCollections](https://github.com/anthonyu/KeptCollections)
+  - KeptCollections is a library of drop-in replacements for the data structures in the Java Collections framework.
+  - KeptCollections uses Apache ZooKeeper as a backing store, thus making its data structures distributed and scalable.
+
+### [Neo4j](https://neo4j.com/)
+  - Neo4j is a Graph Database. It's a disk based, ACID compliant transactional storage engine for big graphs and fast graph traversals,
+    using external indicies like Lucene/Solr for global searches.
+  - We use ZooKeeper in the Neo4j High Availability components for write-master election,
+    read slave coordination and other cool stuff. ZooKeeper is a great and focused project - we like!
+
+### [Norbert](http://sna-projects.com/norbert)
+  - Partitioned routing and cluster management.
+
+### [OpenStack Nova](http://www.openstack.org/)
+  - OpenStack  is an open source software stack for the creation and management of private and public clouds. It is designed to manage pools of compute,
+    storage, and networking resources in data centers, allowing the management of these resources through a consolidated dashboard and flexible APIs.
+  - Nova is the software component in OpenStack, which is responsible for managing the compute resources, where virtual machines (VMs) are hosted in a cloud computing environment. It is also known as the OpenStack Compute Service. OpenStack
+    Nova provides a cloud computing fabric controller, supporting a wide variety of virtualization technologies such as KVM, Xen, VMware, and many more. In addition to its native API, it also includes compatibility with Amazon EC2 and S3 APIs.
+    Nova depends on up-to-date information about the availability of the various compute nodes and services that run on them, for its proper operation. For example, the virtual machine placement operation requires to know the currently available compute nodes and their current state.
+    Nova uses ZooKeeper to implement an efficient membership service, which monitors the availability of registered services. This is done through the ZooKeeper ServiceGroup Driver, which works by using ZooKeeper's ephemeral znodes. Each service registers by creating an ephemeral znode on startup. Now, when the service dies, ZooKeeper will automatically delete the corresponding ephemeral znode. The removal of this znode can be used to trigger the corresponding recovery logic.
+    For example, when a compute node crashes, the nova-compute service that is running in that node also dies. This causes the session with ZooKeeper service to expire, and as a result, ZooKeeper deletes the ephemeral znode created by the nova-compute service. If the cloud controller keeps a watch on this node-deletion event, it will come to know about the compute node crash and can trigger a migration procedure to evacuate all the VMs that are running in the failed compute node to other nodes. This way, high availability of the VMs can be ensured in real time.
+  - ZooKeeper is also being considered for the following use cases in OpenStack Nova:
+    - Storing the configuration metadata (nova.conf)
+    - Maintaining high availability of services and automatic failover using
+    leader election
+
+### [spring-cloud-zookeeper](https://spring.io/projects/spring-cloud-zookeeper)
+  - Spring Cloud Zookeeper provides Apache Zookeeper integrations for Spring Boot apps through autoconfiguration
+    and binding to the Spring Environment and other Spring programming model idioms. With a few simple annotations
+    you can quickly enable and configure the common patterns inside your application and build large distributed systems with Zookeeper.
+    The patterns provided include Service Discovery and Distributed Configuration.
+
+### [Talend ESB](http://www.talend.com/products-application-integration/application-integration-esb-se.php)
+  - Talend ESB is a versatile and flexible, enterprise service bus.
+  - It uses ZooKeeper as endpoint repository of both REST and SOAP Web services.
+    By using ZooKeeper Talend ESB is able to provide failover and load balancing capabilities in a very light-weight manner
+
+### [redis_failover](https://github.com/ryanlecompte/redis_failover)
+  - Redis Failover is a ZooKeeper-based automatic master/slave failover solution for Ruby.
+
+
+## Apache Projects
+
+### [Apache Accumulo](https://accumulo.apache.org/)
+  - Accumulo is a distributed key/value store that provides expressive, cell-level access labels.
+  - Apache ZooKeeper plays a central role within the Accumulo architecture. Its quorum consistency model supports an overall
+    Accumulo architecture with no single points of failure. Beyond that, Accumulo leverages ZooKeeper to store and communication 
+    configuration information for users and tables, as well as operational states of processes and tablets.[2]
+
+### [Apache BookKeeper](https://bookkeeper.apache.org/)
+  - A scalable, fault-tolerant, and low-latency storage service optimized for real-time workloads.
+  - BookKeeper requires a metadata storage service to store information related to ledgers and available bookies. BookKeeper currently uses
+    ZooKeeper for this and other tasks[3].
+
+### [Apache CXF DOSGi](http://cxf.apache.org/distributed-osgi.html)
+  - Apache CXF is an open source services framework. CXF helps you build and develop services using frontend programming
+    APIs, like JAX-WS and JAX-RS. These services can speak a variety of protocols such as SOAP, XML/HTTP, RESTful HTTP,
+    or CORBA and work over a variety of transports such as HTTP, JMS or JBI.
+  - The Distributed OSGi implementation at Apache CXF uses ZooKeeper for its Discovery functionality.[4]
+
+### [Apache Dubbo](http://dubbo.apache.org)
+  - Apache Dubbo is a high-performance, java based open source RPC framework.
+  - Zookeeper is used for service registration discovery and configuration management in Dubbo.[6]
+
+### [Apache Flink](https://flink.apache.org/)
+  - Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.
+    Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale.
+  - To enable JobManager High Availability you have to set the high-availability mode to zookeeper, configure a ZooKeeper quorum and set up a masters file with all JobManagers hosts and their web UI ports.
+    Flink leverages ZooKeeper for distributed coordination between all running JobManager instances. ZooKeeper is a separate service from Flink,
+    which provides highly reliable distributed coordination via leader election and light-weight consistent state storage[23].
+
+### [Apache Flume](https://flume.apache.org/)
+  - Flume is a distributed, reliable, and available service for efficiently collecting, aggregating, and moving large amounts
+    of log data. It has a simple and flexible architecture based on streaming data flows. It is robust and fault tolerant
+    with tunable reliability mechanisms and many failover and recovery mechanisms. It uses a simple extensible data model
+    that allows for online analytic application.
+  - Flume supports Agent configurations via Zookeeper. This is an experimental feature.[5]
+
+### [Apache Hadoop](http://hadoop.apache.org/)
+  - The Apache Hadoop software library is a framework that allows for the distributed processing of large data sets across
+    clusters of computers using simple programming models. It is designed to scale up from single servers to thousands of machines,
+    each offering local computation and storage. Rather than rely on hardware to deliver high-availability,
+    the library itself is designed to detect and handle failures at the application layer, so delivering a highly-available service on top of a cluster of computers, each of which may be prone to failures.
+  - The implementation of automatic HDFS failover relies on ZooKeeper for the following things:
+    - **Failure detection** - each of the NameNode machines in the cluster maintains a persistent session in ZooKeeper.
+      If the machine crashes, the ZooKeeper session will expire, notifying the other NameNode that a failover should be triggered.
+    - **Active NameNode election** - ZooKeeper provides a simple mechanism to exclusively elect a node as active. If the current active NameNode crashes,
+      another node may take a special exclusive lock in ZooKeeper indicating that it should become the next active.
+  - The ZKFailoverController (ZKFC) is a new component which is a ZooKeeper client which also monitors and manages the state of the NameNode.
+    Each of the machines which runs a NameNode also runs a ZKFC, and that ZKFC is responsible for:
+    - **Health monitoring** - the ZKFC pings its local NameNode on a periodic basis with a health-check command.
+      So long as the NameNode responds in a timely fashion with a healthy status, the ZKFC considers the node healthy.
+      If the node has crashed, frozen, or otherwise entered an unhealthy state, the health monitor will mark it as unhealthy.
+    - **ZooKeeper session management** - when the local NameNode is healthy, the ZKFC holds a session open in ZooKeeper.
+      If the local NameNode is active, it also holds a special “lock” znode. This lock uses ZooKeeper’s support for “ephemeral” nodes;
+      if the session expires, the lock node will be automatically deleted.
+    - **ZooKeeper-based election** - if the local NameNode is healthy, and the ZKFC sees that no other node currently holds the lock znode,
+      it will itself try to acquire the lock. If it succeeds, then it has “won the election”, and is responsible for running a failover to make its local NameNode active.
+      The failover process is similar to the manual failover described above: first, the previous active is fenced if necessary,
+      and then the local NameNode transitions to active state.[7]
+
+### [Apache HBase](https://hbase.apache.org/)
+  - HBase is the Hadoop database. It's an open-source, distributed, column-oriented store model.
+  - HBase uses ZooKeeper for master election, server lease management, bootstrapping, and coordination between servers.
+    A distributed Apache HBase installation depends on a running ZooKeeper cluster. All participating nodes and clients
+    need to be able to access the running ZooKeeper ensemble.[8]
+  - As you can see, ZooKeeper is a fundamental part of HBase. All operations that require coordination, such as Regions
+    assignment, Master-Failover, replication, and snapshots, are built on ZooKeeper[20]. 
+
+### [Apache Hedwig](https://bookkeeper.apache.org/docs/r4.2.3/hedwigConsole.html)
+  - Hedwig is a publish-subscribe system designed to carry large amounts of data across the internet in a guaranteed-delivery
+    fashion from those who produce it (publishers) to those who are interested in it (subscribers).
+
+### [Apache Helix](http://helix.apache.org/)
+  - Apache Helix is a cluster management framework for partitioned and replicated distributed resources.
+  - It provides a generic way of automatically managing the resources in a cluster. Helix acts as a decision subsystem for the cluster, and is responsible for the following tasks and many more:
+    - Automating the reassignment of resources to the nodes
+    - Handling node failure detection and recovery
+    - Dynamic cluster reconfiguration (node and resource addition/deletion)
+    - Scheduling of maintenance tasks (backups, index rebuilds, and so on)
+    - Maintaining load balancing and flow control in the cluster
+    In order to store the current cluster state, Helix needs a distributed and highly available configuration or cluster metadata store, for which it uses ZooKeeper.
+  - ZooKeeper provides Helix with the following capabilities:
+    - This framework represents the PERSISTENT state, which remains until it's removed
+    - This framework also represents the TRANSIENT/EPHEMERAL state, which goes away when the process that created the state leaves the cluster
+    - This framework notifies the subsystem when there is a change in the PERSISTENT and EPHEMERAL state of the cluster
+  - Helix also allows simple lookups of task assignments through the configuration store built on top of ZooKeeper. Through this, clients can look up where the tasks are currently assigned.
+    This way, Helix can also provide a service discovery registry.[21]
+
+### [Apache Kafka](https://kafka.apache.org/)
+  - Kafka is a distributed publish/subscribe messaging system
+  - Apache Kafka relies on ZooKeeper for the following things:
+    - **Controller election**
+    The controller is one of the most important broking entity in a Kafka ecosystem, and it also has the responsibility
+    to maintain the leader-follower relationship across all the partitions. If a node by some reason is shutting down,
+    it’s the controller’s responsibility to tell all the replicas to act as partition leaders in order to fulfill the
+    duties of the partition leaders on the node that is about to fail. So, whenever a node shuts down, a new controller
+    can be elected and it can also be made sure that at any given time, there is only one controller and all the follower nodes have agreed on that.
+    - **Configuration Of Topics**
+    The configuration regarding all the topics including the list of existing topics, the number of partitions for each topic,
+    the location of all the replicas, list of configuration overrides for all topics and which node is the preferred leader, etc.
+    - **Access control lists**
+    Access control lists or ACLs for all the topics are also maintained within Zookeeper.
+    - **Membership of the cluster**
+    Zookeeper also maintains a list of all the brokers that are functioning at any given moment and are a part of the cluster.[9]
+
+### [Apache Mesos](http://mesos.apache.org/)
+  - Apache Mesos abstracts CPU, memory, storage, and other compute resources away from machines (physical or virtual),
+    enabling fault-tolerant and elastic distributed systems to easily be built and run effectively.
+  - Mesos has a high-availability mode that uses multiple Mesos masters: one active master (called the leader or leading master)
+    and several backups in case it fails. The masters elect the leader, with Apache ZooKeeper both coordinating the election
+    and handling leader detection by masters, agents, and scheduler drivers.[10]
+
+### [Apache S4](https://github.com/apache/incubator-retired-s4)
+  - S4(**retired** on 2014-06-19[11]) is a general-purpose, distributed, scalable, partially fault-tolerant, pluggable platform that allows programmers
+    to easily develop applications for processing continuous unbounded streams of data.
+
+### [Apache Solr](https://lucene.apache.org/solr/)
+  - Solr is the popular, blazing-fast, open source enterprise search platform built on Apache Lucene.
+  - In the ""Cloud"" edition (v4.x and up) of enterprise search engine Apache Solr, ZooKeeper is used for configuration,
+    leader election and more[12,13]
+
+### [Apache Spark](https://spark.apache.org/)
+  - Apache Spark is a unified analytics engine for large-scale data processing.
+  - Utilizing ZooKeeper to provide leader election and some state storage, you can launch multiple Masters in your cluster connected to the same ZooKeeper instance.
+    One will be elected “leader” and the others will remain in standby mode. If the current leader dies, another Master will be elected,
+    recover the old Master’s state, and then resume scheduling[14]
+
+
+## Companies
+
+### [101tec](http://101tec.com/)
+ - we do consulting in the area of enterprise distributed systems.
+ - We use zookeeper to manage a system build out of hadoop, katta, oracle batch jobs and a web component.
+
+### [AGETO](http://www.ageto.de/)
+ - The AGETO RnD team uses ZooKeeper in a variety of internal as well as external consulting projects.
+
+### [Benipal Technologies](http://www.benipaltechnologies.com/)
+ - ZooKeeper is used for internal application development with Solr and Hadoop with Hbase.
+
+### [Box](http://box.net/)
+ - Box uses ZooKeeper for service discovery, service coordination, Solr and Hadoop support, etc.
+
+### [Deepdyve](http://www.deepdyve.com/)
+ - We do search for research and provide access to high quality content using advanced search technologies Zookeeper is used to
+   manage server state, control index deployment and a myriad other tasks.
+
+### [eBay](https://www.ebay.com/)
+ - eBay uses ZooKeeper to develop a job type limiter. The job limiter limits the execution of the same type of jobs from running simultaneously beyond a specified number in the grid.
+   For each job type, the type limiter keeps track of the running count and the limit. When the running count hits the limit, spawning of a new job
+   is not allowed until a job of that type finishes or terminates. This job type limiter is used for jobs that use third-party services using APIs to update the maximum bid for keyword ads.
+   Usually, the API call capacity is limited. Even if the grid has enough capacity to run hundreds of jobs, the job limiter system built with ZooKeeper allows
+   only a predetermined number (for example, N) of concurrent jobs against a partner API. The type limiter ensures that the (N+1)th job waits until one of the N running jobs has completed[21,22].
+
+### [Facebook](https://www.facebook.com/)
+ - Facebook uses ZooKeeper in its messaging platform and many other use cases. Facebook's messaging system is powered by a system called cell system.
+   The entire messaging system (e-mail, SMS, Facebook Chat, and the Facebook Inbox) is divided into cells. Cells are composed of a cluster of servers and services,
+   and each cell serves only a fraction of Facebook users. The use of cells has the following advantages:
+   - Incremental scaling with minuscule failures
+   - Easy upgrading of hardware and software
+   - Failures affect only the cell boundary, which affects limited users
+   - Hosting cells in distributed data centers avoids disasters
+   - Each cell comprises a cluster of servers and is coordinated by a ZooKeeper ensemble. The servers that host a particular application register themselves with ZooKeeper.
+     The mapping between users and servers is then done using the consistent hashing algorithm. Basically, the nodes are arranged in a ring,
+     and each node is responsible for a specified range of the users depending on the hash values.
+   - If a node fails, another node in the neighboring position in the ring takes over the load for those users affected by the failure.
+     This allows for an even distribution of the load and also enables easy addition and removal of nodes into and from the cluster in the cell[21].
+ - Facebook uses the Zeus([17,18]) for configuration management which is a forked version of ZooKeeper, with many scalability
+   and performance en- hancements in order to work at the Facebook scale.
+   It runs a consensus protocol among servers distributed across mul- tiple regions for resilience. If the leader fails,
+   a follower is converted into a new leader.
+
+### [Idium Portal](http://www.idium.no/no/idium_portal/)
+ - Idium Portal is a hosted web-publishing system delivered by Norwegian company, Idium AS.
+ - ZooKeeper is used for cluster messaging, service bootstrapping, and service coordination.
+
+### [Makara](http://www.makara.com/)
+ - Using ZooKeeper on 2-node cluster on VMware workstation, Amazon EC2, Zen
+ - Using zkpython
+ - Looking into expanding into 100 node cluster
+
+### [Midokura](http://www.midokura.com/)
+ - We do virtualized networking for the cloud computing era. We use ZooKeeper for various aspects of our distributed control plane.
+
+### [Netflix](https://www.netflix.com)
+ - Netflix([21]) is an avid ZooKeeper user in its distributed platform, which led them to develop Curator and Exhibitor to enhance the functionalities of ZooKeeper.
+   A few of the use cases of ZooKeeper/Curator at Netflix are as follows:
+    - Ensuring the generation of unique values in various sequence ID generators
+    - Cassandra backups
+    - Implementing the TrackID service
+    - Performing leader election with ZooKeeper for various distributed tasks
+    - Implementing a distributed semaphore for concurrent jobs
+    - Distributed caching
+
+### [Nutanix](http://www.nutanix.com/)
+  - Nutanix develops a hyper-converged storage and compute solution, which leverages local components of a host machine, such as storage capacity (disks) and compute (CPUs),
+    to create a distributed platform for virtualization. This solution is known as the Nutanix Virtual Computing Platform. It supports industry-standard hypervisor ESXi, KVM, and Hyper-V.
+    The platform is bundled in the appliance form factor with two nodes or four nodes. A VM in the platform known as the Nutanix Controller VM works as the decision subsystem, which manages the platform.
+  - The Nutanix platform uses Apache ZooKeeper as a Cluster configuration manager. The configuration data that pertains to the platform, such as hostnames, IP addresses,
+    and the cluster state, is stored in a ZooKeeper ensemble. ZooKeeper is also used to query the state of the various services that run in the platform[21].
+
+### [Pinterest](https://www.pinterest.com/)
+ - Pinterest uses the ZooKeeper for Service discovery and dynamic configuration.Like many large scale web sites, Pinterest’s infrastructure consists of servers that communicate with
+   backend services composed of a number of individual servers for managing load and fault tolerance. Ideally, we’d like the configuration to reflect only the active hosts,
+   so clients don’t need to deal with bad hosts as often. ZooKeeper provides a well known pattern to solve this problem[19].
+
+### [Rackspace](http://www.rackspace.com/email_hosting)
+ - The Email & Apps team uses ZooKeeper to coordinate sharding and responsibility changes in a distributed e-mail client
+   that pulls and indexes data for search. ZooKeeper also provides distributed locking for connections to prevent a cluster from overwhelming servers.
+
+### [Sematext](http://sematext.com/)
+ - Uses ZooKeeper in SPM (which includes ZooKeeper monitoring component, too!), Search Analytics, and Logsene.
+
+### [Tubemogul](http://tubemogul.com/)
+ - Uses ZooKeeper for leader election, configuration management, locking, group membership
+
+### [Twitter](https://twitter.com/)
+ - ZooKeeper is used at Twitter as the source of truth for storing critical metadata. It serves as a coordination kernel to
+   provide distributed coordination services, such as leader election and distributed locking.
+   Some concrete examples of ZooKeeper in action include[15,16]:
+   - ZooKeeper is used to store service registry, which is used by Twitter’s naming service for service discovery.
+   - Manhattan, Twitter’s in-house key-value database, stores its cluster topology information in ZooKeeper.
+   - EventBus, Twitter’s pub-sub messaging system, stores critical metadata in ZooKeeper and uses ZooKeeper for leader election.
+   - Mesos, Twitter’s compute platform, uses ZooKeeper for leader election.
+ 
+### [Vast.com](http://www.vast.com/)
+ - Used internally as a part of sharding services, distributed synchronization of data/index updates, configuration management and failover support
+
+### [VMware vSphere Storage Appliance](https://www.vmware.com/products/vsphere-storage-appliance.html)
+ - VMware vSphere Storage Appliance (VSA) is a software-storage appliance. The VMware VSA comes in a cluster configuration of two or three nodes,
+   known as the VSA Storage Cluster. A virtual machine instance inside each of the VMware ESXiTM host in the VSA Storage
+   Cluster claims all the available local directed attached storage space and presents it as one mirrored volume of all the ESXi hosts in the VMware vCenter Server datacenter.
+   It uses the NFS protocol to export the volume.
+ - VSA uses ZooKeeper as the base clustering library for the following primitives:
+    - As a cluster membership model to detect VSA failures in the cluster
+    - As a distributed metadata storage system to store the cluster states
+    - As a leader elector to select a master VSA that performs metadata operations
+
+### [Wealthfront](http://wealthfront.com/)
+ - Wealthfront uses ZooKeeper for service discovery, leader election and distributed locking among its many backend services.
+   ZK is an essential part of Wealthfront's continuous [deployment infrastructure](http://eng.wealthfront.com/2010/05/02/deployment-infrastructure-for-continuous-deployment/).
+
+### [Yahoo!](http://www.yahoo.com/)
+ - ZooKeeper is used for a myriad of services inside Yahoo! for doing leader election, configuration management, sharding, locking, group membership etc[1].
+ - ZooKeeper was originally developed by Yahoo! before it became an Apache project. It is used for a multitude of services inside Yahoo! to perform leader election, configuration management, 
+   naming system, sharding, distributed locking, group membership, and so on. Yahoo! is a big Hadoop shop that performs analysis in its massive datasets,
+   and ZooKeeper is used for various distributed coordination and synchronization tasks[21].
+
+### [Zynga](http://www.zynga.com/)
+ - ZooKeeper at Zynga is used for a variety of services including configuration management, leader election, sharding and more...[1]
+ - Zynga uses ZooKeeper for configuration management of their hosted games. ZooKeeper allows Zynga to update the configuration files for a plethora of online games,
+   which are used across the world by millions of users in a very short span of time. The games are served from Zynga's multiple data centers.
+   With ZooKeeper, the configuration's system updates thousands of configuration files in a very small span of time.
+   The configurations are validated by validation systems against the business logic to ensure that configurations are updated correctly and services are properly configured to the updated data.
+   In the absence of ZooKeeper, the configuration update at the same time in a short time interval would be a real nightmare.
+   Again, failure to sync these configuration files within the available time span would have caused severe service disruption[21].
+
+#### References
+- [1] https://cwiki.apache.org/confluence/display/ZOOKEEPER/PoweredBy
+- [2] https://www.youtube.com/watch?v=Ew53T6h9oRw
+- [3] https://bookkeeper.apache.org/docs/4.7.3/getting-started/concepts/#ledgers
+- [4] http://cxf.apache.org/dosgi-discovery-demo-page.html
+- [5] https://flume.apache.org/FlumeUserGuide.html
+- [6] http://dubbo.apache.org/en-us/blog/dubbo-zk.html
+- [7] https://hadoop.apache.org/docs/r2.7.1/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html
+- [8] https://hbase.apache.org/book.html#zookeeper
+- [9] https://www.cloudkarafka.com/blog/2018-07-04-cloudkarafka_what_is_zookeeper.html
+- [10] http://mesos.apache.org/documentation/latest/high-availability/
+- [11] http://incubator.apache.org/projects/s4.html
+- [12] https://lucene.apache.org/solr/guide/6_6/using-zookeeper-to-manage-configuration-files.html#UsingZooKeepertoManageConfigurationFiles-StartupBootstrap
+- [13] https://lucene.apache.org/solr/guide/6_6/setting-up-an-external-zookeeper-ensemble.html
+- [14] https://spark.apache.org/docs/latest/spark-standalone.html#standby-masters-with-zookeeper
+- [15] https://blog.twitter.com/engineering/en_us/topics/infrastructure/2018/zookeeper-at-twitter.html
+- [16] https://blog.twitter.com/engineering/en_us/topics/infrastructure/2018/dynamic-configuration-at-twitter.html
+- [17] TANG, C., KOOBURAT, T., VENKATACHALAM, P.,CHANDER, A., WEN, Z., NARAYANAN, A., DOWELL,P., AND KARL, R. Holistic Configuration Management
+       at Facebook. In Proceedings of the 25th Symposium on Operating System Principles (SOSP’15) (Monterey, CA,USA, Oct. 2015).
+- [18] https://www.youtube.com/watch?v=SeZV373gUZc
+- [19] https://medium.com/@Pinterest_Engineering/zookeeper-resilience-at-pinterest-adfd8acf2a6b
+- [20] https://blog.cloudera.com/what-are-hbase-znodes/
+- [21] Saurav Haloi(2015). *Apache ZooKeeper essentials*. Packt Publishing.","[{'comment': 'Given this book is not free and in public space, do we have the consent agreement of the author to post part of the contents of the book here?', 'commenter': 'hanm'}, {'comment': ""Oops, I have written an email to the author of this book. If he/she doesn't agree or no reply within ten days,I will revert/delete all the references from that book"", 'commenter': 'maoling'}]"
1073,zookeeper-docs/src/main/resources/markdown/zookeeperUseCases.md,"@@ -0,0 +1,377 @@
+<!--
+Copyright 2002-2019 The Apache Software Foundation
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+//-->
+
+# ZooKeeper Use Cases
+
+- Applications and organizations using ZooKeeper include (alphabetically)[1].
+- If your use case wants to be listed here. Please do not hesitate, submit a pull request or write an email to **dev@zookeeper.apache.org**,
+  and then, your use case will be included.
+
+
+## Free Software Projects
+
+### [AdroitLogic UltraESB](http://adroitlogic.org/)
+  - Uses ZooKeeper to implement node coordination, in clustering support. This allows the management of the complete cluster,
+  or any specific node - from any other node connected via JMX. A Cluster wide command framework developed on top of the
+  ZooKeeper coordination allows commands that fail on some nodes to be retried etc. We also support the automated graceful
+  round-robin-restart of a complete cluster of nodes using the same framework.
+
+### [Akka](http://akka.io/)
+  - Akka is the platform for the next generation event-driven, scalable and fault-tolerant architectures on the JVM.
+  Or: Akka is a toolkit and runtime for building highly concurrent, distributed, and fault tolerant event-driven applications on the JVM.
+
+### [Eclipse Communication Framework](http://www.eclipse.org/ecf) 
+  - The Eclipse ECF project provides an implementation of its Abstract Discovery services using Zookeeper. ECF itself
+  is used in many projects providing base functionallity for communication, all based on OSGi.
+
+### [Eclipse Gyrex](http://www.eclipse.org/gyrex)
+  - The Eclipse Gyrex project provides a platform for building your own Java OSGi based clouds. 
+  - ZooKeeper is used as the core cloud component for node membership and management, coordination of jobs executing among workers,
+  a lock service and a simple queue service and a lot more.
+
+### [GoldenOrb](http://www.goldenorbos.org/)
+  - massive-scale Graph analysis
+
+### [Juju](https://juju.ubuntu.com/)
+  - Service deployment and orchestration framework, formerly called Ensemble.
+
+### [Katta](http://katta.sourceforge.net/)
+  - Katta serves distributed Lucene indexes in a grid environment.
+  - Zookeeper is used for node, master and index management in the grid.
+
+### [KeptCollections](https://github.com/anthonyu/KeptCollections)
+  - KeptCollections is a library of drop-in replacements for the data structures in the Java Collections framework.
+  - KeptCollections uses Apache ZooKeeper as a backing store, thus making its data structures distributed and scalable.
+
+### [Neo4j](https://neo4j.com/)
+  - Neo4j is a Graph Database. It's a disk based, ACID compliant transactional storage engine for big graphs and fast graph traversals,
+    using external indicies like Lucene/Solr for global searches.
+  - We use ZooKeeper in the Neo4j High Availability components for write-master election,
+    read slave coordination and other cool stuff. ZooKeeper is a great and focused project - we like!
+
+### [Norbert](http://sna-projects.com/norbert)
+  - Partitioned routing and cluster management.
+
+### [OpenStack Nova](http://www.openstack.org/)
+  - OpenStack  is an open source software stack for the creation and management of private and public clouds. It is designed to manage pools of compute,
+    storage, and networking resources in data centers, allowing the management of these resources through a consolidated dashboard and flexible APIs.
+  - Nova is the software component in OpenStack, which is responsible for managing the compute resources, where virtual machines (VMs) are hosted in a cloud computing environment. It is also known as the OpenStack Compute Service. OpenStack
+    Nova provides a cloud computing fabric controller, supporting a wide variety of virtualization technologies such as KVM, Xen, VMware, and many more. In addition to its native API, it also includes compatibility with Amazon EC2 and S3 APIs.
+    Nova depends on up-to-date information about the availability of the various compute nodes and services that run on them, for its proper operation. For example, the virtual machine placement operation requires to know the currently available compute nodes and their current state.
+    Nova uses ZooKeeper to implement an efficient membership service, which monitors the availability of registered services. This is done through the ZooKeeper ServiceGroup Driver, which works by using ZooKeeper's ephemeral znodes. Each service registers by creating an ephemeral znode on startup. Now, when the service dies, ZooKeeper will automatically delete the corresponding ephemeral znode. The removal of this znode can be used to trigger the corresponding recovery logic.
+    For example, when a compute node crashes, the nova-compute service that is running in that node also dies. This causes the session with ZooKeeper service to expire, and as a result, ZooKeeper deletes the ephemeral znode created by the nova-compute service. If the cloud controller keeps a watch on this node-deletion event, it will come to know about the compute node crash and can trigger a migration procedure to evacuate all the VMs that are running in the failed compute node to other nodes. This way, high availability of the VMs can be ensured in real time.
+  - ZooKeeper is also being considered for the following use cases in OpenStack Nova:
+    - Storing the configuration metadata (nova.conf)
+    - Maintaining high availability of services and automatic failover using
+    leader election
+
+### [spring-cloud-zookeeper](https://spring.io/projects/spring-cloud-zookeeper)
+  - Spring Cloud Zookeeper provides Apache Zookeeper integrations for Spring Boot apps through autoconfiguration
+    and binding to the Spring Environment and other Spring programming model idioms. With a few simple annotations
+    you can quickly enable and configure the common patterns inside your application and build large distributed systems with Zookeeper.
+    The patterns provided include Service Discovery and Distributed Configuration.
+
+### [Talend ESB](http://www.talend.com/products-application-integration/application-integration-esb-se.php)
+  - Talend ESB is a versatile and flexible, enterprise service bus.
+  - It uses ZooKeeper as endpoint repository of both REST and SOAP Web services.
+    By using ZooKeeper Talend ESB is able to provide failover and load balancing capabilities in a very light-weight manner
+
+### [redis_failover](https://github.com/ryanlecompte/redis_failover)
+  - Redis Failover is a ZooKeeper-based automatic master/slave failover solution for Ruby.
+
+
+## Apache Projects
+
+### [Apache Accumulo](https://accumulo.apache.org/)
+  - Accumulo is a distributed key/value store that provides expressive, cell-level access labels.
+  - Apache ZooKeeper plays a central role within the Accumulo architecture. Its quorum consistency model supports an overall
+    Accumulo architecture with no single points of failure. Beyond that, Accumulo leverages ZooKeeper to store and communication 
+    configuration information for users and tables, as well as operational states of processes and tablets.[2]
+
+### [Apache BookKeeper](https://bookkeeper.apache.org/)
+  - A scalable, fault-tolerant, and low-latency storage service optimized for real-time workloads.
+  - BookKeeper requires a metadata storage service to store information related to ledgers and available bookies. BookKeeper currently uses
+    ZooKeeper for this and other tasks[3].
+
+### [Apache CXF DOSGi](http://cxf.apache.org/distributed-osgi.html)
+  - Apache CXF is an open source services framework. CXF helps you build and develop services using frontend programming
+    APIs, like JAX-WS and JAX-RS. These services can speak a variety of protocols such as SOAP, XML/HTTP, RESTful HTTP,
+    or CORBA and work over a variety of transports such as HTTP, JMS or JBI.
+  - The Distributed OSGi implementation at Apache CXF uses ZooKeeper for its Discovery functionality.[4]
+
+### [Apache Dubbo](http://dubbo.apache.org)
+  - Apache Dubbo is a high-performance, java based open source RPC framework.
+  - Zookeeper is used for service registration discovery and configuration management in Dubbo.[6]
+
+### [Apache Flink](https://flink.apache.org/)
+  - Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.
+    Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale.
+  - To enable JobManager High Availability you have to set the high-availability mode to zookeeper, configure a ZooKeeper quorum and set up a masters file with all JobManagers hosts and their web UI ports.
+    Flink leverages ZooKeeper for distributed coordination between all running JobManager instances. ZooKeeper is a separate service from Flink,
+    which provides highly reliable distributed coordination via leader election and light-weight consistent state storage[23].
+
+### [Apache Flume](https://flume.apache.org/)
+  - Flume is a distributed, reliable, and available service for efficiently collecting, aggregating, and moving large amounts
+    of log data. It has a simple and flexible architecture based on streaming data flows. It is robust and fault tolerant
+    with tunable reliability mechanisms and many failover and recovery mechanisms. It uses a simple extensible data model
+    that allows for online analytic application.
+  - Flume supports Agent configurations via Zookeeper. This is an experimental feature.[5]
+
+### [Apache Hadoop](http://hadoop.apache.org/)
+  - The Apache Hadoop software library is a framework that allows for the distributed processing of large data sets across
+    clusters of computers using simple programming models. It is designed to scale up from single servers to thousands of machines,
+    each offering local computation and storage. Rather than rely on hardware to deliver high-availability,
+    the library itself is designed to detect and handle failures at the application layer, so delivering a highly-available service on top of a cluster of computers, each of which may be prone to failures.
+  - The implementation of automatic HDFS failover relies on ZooKeeper for the following things:
+    - **Failure detection** - each of the NameNode machines in the cluster maintains a persistent session in ZooKeeper.
+      If the machine crashes, the ZooKeeper session will expire, notifying the other NameNode that a failover should be triggered.
+    - **Active NameNode election** - ZooKeeper provides a simple mechanism to exclusively elect a node as active. If the current active NameNode crashes,
+      another node may take a special exclusive lock in ZooKeeper indicating that it should become the next active.
+  - The ZKFailoverController (ZKFC) is a new component which is a ZooKeeper client which also monitors and manages the state of the NameNode.
+    Each of the machines which runs a NameNode also runs a ZKFC, and that ZKFC is responsible for:
+    - **Health monitoring** - the ZKFC pings its local NameNode on a periodic basis with a health-check command.
+      So long as the NameNode responds in a timely fashion with a healthy status, the ZKFC considers the node healthy.
+      If the node has crashed, frozen, or otherwise entered an unhealthy state, the health monitor will mark it as unhealthy.
+    - **ZooKeeper session management** - when the local NameNode is healthy, the ZKFC holds a session open in ZooKeeper.
+      If the local NameNode is active, it also holds a special “lock” znode. This lock uses ZooKeeper’s support for “ephemeral” nodes;
+      if the session expires, the lock node will be automatically deleted.
+    - **ZooKeeper-based election** - if the local NameNode is healthy, and the ZKFC sees that no other node currently holds the lock znode,
+      it will itself try to acquire the lock. If it succeeds, then it has “won the election”, and is responsible for running a failover to make its local NameNode active.
+      The failover process is similar to the manual failover described above: first, the previous active is fenced if necessary,
+      and then the local NameNode transitions to active state.[7]
+
+### [Apache HBase](https://hbase.apache.org/)
+  - HBase is the Hadoop database. It's an open-source, distributed, column-oriented store model.
+  - HBase uses ZooKeeper for master election, server lease management, bootstrapping, and coordination between servers.
+    A distributed Apache HBase installation depends on a running ZooKeeper cluster. All participating nodes and clients
+    need to be able to access the running ZooKeeper ensemble.[8]
+  - As you can see, ZooKeeper is a fundamental part of HBase. All operations that require coordination, such as Regions
+    assignment, Master-Failover, replication, and snapshots, are built on ZooKeeper[20]. 
+
+### [Apache Hedwig](https://bookkeeper.apache.org/docs/r4.2.3/hedwigConsole.html)
+  - Hedwig is a publish-subscribe system designed to carry large amounts of data across the internet in a guaranteed-delivery
+    fashion from those who produce it (publishers) to those who are interested in it (subscribers).
+
+### [Apache Helix](http://helix.apache.org/)
+  - Apache Helix is a cluster management framework for partitioned and replicated distributed resources.
+  - It provides a generic way of automatically managing the resources in a cluster. Helix acts as a decision subsystem for the cluster, and is responsible for the following tasks and many more:
+    - Automating the reassignment of resources to the nodes
+    - Handling node failure detection and recovery
+    - Dynamic cluster reconfiguration (node and resource addition/deletion)
+    - Scheduling of maintenance tasks (backups, index rebuilds, and so on)
+    - Maintaining load balancing and flow control in the cluster
+    In order to store the current cluster state, Helix needs a distributed and highly available configuration or cluster metadata store, for which it uses ZooKeeper.
+  - ZooKeeper provides Helix with the following capabilities:
+    - This framework represents the PERSISTENT state, which remains until it's removed
+    - This framework also represents the TRANSIENT/EPHEMERAL state, which goes away when the process that created the state leaves the cluster
+    - This framework notifies the subsystem when there is a change in the PERSISTENT and EPHEMERAL state of the cluster
+  - Helix also allows simple lookups of task assignments through the configuration store built on top of ZooKeeper. Through this, clients can look up where the tasks are currently assigned.
+    This way, Helix can also provide a service discovery registry.[21]
+
+### [Apache Kafka](https://kafka.apache.org/)
+  - Kafka is a distributed publish/subscribe messaging system
+  - Apache Kafka relies on ZooKeeper for the following things:
+    - **Controller election**
+    The controller is one of the most important broking entity in a Kafka ecosystem, and it also has the responsibility
+    to maintain the leader-follower relationship across all the partitions. If a node by some reason is shutting down,
+    it’s the controller’s responsibility to tell all the replicas to act as partition leaders in order to fulfill the
+    duties of the partition leaders on the node that is about to fail. So, whenever a node shuts down, a new controller
+    can be elected and it can also be made sure that at any given time, there is only one controller and all the follower nodes have agreed on that.
+    - **Configuration Of Topics**
+    The configuration regarding all the topics including the list of existing topics, the number of partitions for each topic,
+    the location of all the replicas, list of configuration overrides for all topics and which node is the preferred leader, etc.
+    - **Access control lists**
+    Access control lists or ACLs for all the topics are also maintained within Zookeeper.
+    - **Membership of the cluster**
+    Zookeeper also maintains a list of all the brokers that are functioning at any given moment and are a part of the cluster.[9]
+
+### [Apache Mesos](http://mesos.apache.org/)
+  - Apache Mesos abstracts CPU, memory, storage, and other compute resources away from machines (physical or virtual),
+    enabling fault-tolerant and elastic distributed systems to easily be built and run effectively.
+  - Mesos has a high-availability mode that uses multiple Mesos masters: one active master (called the leader or leading master)
+    and several backups in case it fails. The masters elect the leader, with Apache ZooKeeper both coordinating the election
+    and handling leader detection by masters, agents, and scheduler drivers.[10]
+
+### [Apache S4](https://github.com/apache/incubator-retired-s4)
+  - S4(**retired** on 2014-06-19[11]) is a general-purpose, distributed, scalable, partially fault-tolerant, pluggable platform that allows programmers
+    to easily develop applications for processing continuous unbounded streams of data.
+
+### [Apache Solr](https://lucene.apache.org/solr/)
+  - Solr is the popular, blazing-fast, open source enterprise search platform built on Apache Lucene.
+  - In the ""Cloud"" edition (v4.x and up) of enterprise search engine Apache Solr, ZooKeeper is used for configuration,
+    leader election and more[12,13]
+
+### [Apache Spark](https://spark.apache.org/)
+  - Apache Spark is a unified analytics engine for large-scale data processing.
+  - Utilizing ZooKeeper to provide leader election and some state storage, you can launch multiple Masters in your cluster connected to the same ZooKeeper instance.
+    One will be elected “leader” and the others will remain in standby mode. If the current leader dies, another Master will be elected,
+    recover the old Master’s state, and then resume scheduling[14]
+
+
+## Companies
+
+### [101tec](http://101tec.com/)
+ - we do consulting in the area of enterprise distributed systems.
+ - We use zookeeper to manage a system build out of hadoop, katta, oracle batch jobs and a web component.
+
+### [AGETO](http://www.ageto.de/)
+ - The AGETO RnD team uses ZooKeeper in a variety of internal as well as external consulting projects.
+
+### [Benipal Technologies](http://www.benipaltechnologies.com/)
+ - ZooKeeper is used for internal application development with Solr and Hadoop with Hbase.
+
+### [Box](http://box.net/)
+ - Box uses ZooKeeper for service discovery, service coordination, Solr and Hadoop support, etc.
+
+### [Deepdyve](http://www.deepdyve.com/)
+ - We do search for research and provide access to high quality content using advanced search technologies Zookeeper is used to
+   manage server state, control index deployment and a myriad other tasks.
+
+### [eBay](https://www.ebay.com/)
+ - eBay uses ZooKeeper to develop a job type limiter. The job limiter limits the execution of the same type of jobs from running simultaneously beyond a specified number in the grid.
+   For each job type, the type limiter keeps track of the running count and the limit. When the running count hits the limit, spawning of a new job
+   is not allowed until a job of that type finishes or terminates. This job type limiter is used for jobs that use third-party services using APIs to update the maximum bid for keyword ads.
+   Usually, the API call capacity is limited. Even if the grid has enough capacity to run hundreds of jobs, the job limiter system built with ZooKeeper allows
+   only a predetermined number (for example, N) of concurrent jobs against a partner API. The type limiter ensures that the (N+1)th job waits until one of the N running jobs has completed[21,22].
+
+### [Facebook](https://www.facebook.com/)","[{'comment': 'cc @lvfangmin @enixon for reviewing FB use cases', 'commenter': 'hanm'}]"
1073,zookeeper-docs/src/main/resources/markdown/zookeeperUseCases.md,"@@ -0,0 +1,319 @@
+<!--
+Copyright 2002-2019 The Apache Software Foundation
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+//-->
+
+# ZooKeeper Use Cases
+
+- Applications and organizations using ZooKeeper include (alphabetically)[1].
+- If your use case wants to be listed here. Please do not hesitate, submit a pull request or write an email to **dev@zookeeper.apache.org**,
+  and then, your use case will be included.
+- If this documentation has violated your intellectual property rights or you and your company's privacy,write an email to **dev@zookeeper.apache.org**,
+  we will handle them in a timely manner.
+
+
+## Free Software Projects
+
+### [AdroitLogic UltraESB](http://adroitlogic.org/)
+  - Uses ZooKeeper to implement node coordination, in clustering support. This allows the management of the complete cluster,
+  or any specific node - from any other node connected via JMX. A Cluster wide command framework developed on top of the
+  ZooKeeper coordination allows commands that fail on some nodes to be retried etc. We also support the automated graceful
+  round-robin-restart of a complete cluster of nodes using the same framework[1].
+
+### [Akka](http://akka.io/)
+  - Akka is the platform for the next generation event-driven, scalable and fault-tolerant architectures on the JVM.
+  Or: Akka is a toolkit and runtime for building highly concurrent, distributed, and fault tolerant event-driven applications on the JVM[1].
+
+### [Eclipse Communication Framework](http://www.eclipse.org/ecf)
+  - The Eclipse ECF project provides an implementation of its Abstract Discovery services using Zookeeper. ECF itself
+  is used in many projects providing base functionallity for communication, all based on OSGi[1].
+
+### [Eclipse Gyrex](http://www.eclipse.org/gyrex)
+  - The Eclipse Gyrex project provides a platform for building your own Java OSGi based clouds. 
+  - ZooKeeper is used as the core cloud component for node membership and management, coordination of jobs executing among workers,
+  a lock service and a simple queue service and a lot more[1].
+
+### [GoldenOrb](http://www.goldenorbos.org/)
+  - massive-scale Graph analysis[1]
+
+### [Juju](https://juju.ubuntu.com/)
+  - Service deployment and orchestration framework, formerly called Ensemble[1].
+
+### [Katta](http://katta.sourceforge.net/)
+  - Katta serves distributed Lucene indexes in a grid environment.
+  - Zookeeper is used for node, master and index management in the grid[1].
+
+### [KeptCollections](https://github.com/anthonyu/KeptCollections)
+  - KeptCollections is a library of drop-in replacements for the data structures in the Java Collections framework.
+  - KeptCollections uses Apache ZooKeeper as a backing store, thus making its data structures distributed and scalable[1].
+
+### [Neo4j](https://neo4j.com/)
+  - Neo4j is a Graph Database. It's a disk based, ACID compliant transactional storage engine for big graphs and fast graph traversals,
+    using external indicies like Lucene/Solr for global searches.
+  - We use ZooKeeper in the Neo4j High Availability components for write-master election,
+    read slave coordination and other cool stuff. ZooKeeper is a great and focused project - we like![1]
+
+### [Norbert](http://sna-projects.com/norbert)
+  - Partitioned routing and cluster management[1].
+
+### [spring-cloud-zookeeper](https://spring.io/projects/spring-cloud-zookeeper)
+  - Spring Cloud Zookeeper provides Apache Zookeeper integrations for Spring Boot apps through autoconfiguration
+    and binding to the Spring Environment and other Spring programming model idioms. With a few simple annotations
+    you can quickly enable and configure the common patterns inside your application and build large distributed systems with Zookeeper.
+    The patterns provided include Service Discovery and Distributed Configuration.
+
+### [Talend ESB](http://www.talend.com/products-application-integration/application-integration-esb-se.php)
+  - Talend ESB is a versatile and flexible, enterprise service bus.
+  - It uses ZooKeeper as endpoint repository of both REST and SOAP Web services.
+    By using ZooKeeper Talend ESB is able to provide failover and load balancing capabilities in a very light-weight manner[1]
+
+### [redis_failover](https://github.com/ryanlecompte/redis_failover)
+  - Redis Failover is a ZooKeeper-based automatic master/slave failover solution for Ruby.[1]
+
+
+## Apache Projects
+
+### [Apache Accumulo](https://accumulo.apache.org/)
+  - Accumulo is a distributed key/value store that provides expressive, cell-level access labels.
+  - Apache ZooKeeper plays a central role within the Accumulo architecture. Its quorum consistency model supports an overall
+    Accumulo architecture with no single points of failure. Beyond that, Accumulo leverages ZooKeeper to store and communication 
+    configuration information for users and tables, as well as operational states of processes and tablets.[2]
+
+### [Apache BookKeeper](https://bookkeeper.apache.org/)
+  - A scalable, fault-tolerant, and low-latency storage service optimized for real-time workloads.
+  - BookKeeper requires a metadata storage service to store information related to ledgers and available bookies. BookKeeper currently uses
+    ZooKeeper for this and other tasks[3].
+
+### [Apache CXF DOSGi](http://cxf.apache.org/distributed-osgi.html)
+  - Apache CXF is an open source services framework. CXF helps you build and develop services using frontend programming
+    APIs, like JAX-WS and JAX-RS. These services can speak a variety of protocols such as SOAP, XML/HTTP, RESTful HTTP,
+    or CORBA and work over a variety of transports such as HTTP, JMS or JBI.
+  - The Distributed OSGi implementation at Apache CXF uses ZooKeeper for its Discovery functionality.[4]
+
+### [Apache Druid(Incubating)](https://druid.apache.org/)
+  - Apache Druid (incubating) is a high performance real-time analytics database.
+  - Apache Druid (incubating) uses Apache ZooKeeper (ZK) for management of current cluster state. The operations that happen over ZK are[27]:
+    - Coordinator leader election
+    - Segment ""publishing"" protocol from Historical and Realtime
+    - Segment load/drop protocol between Coordinator and Historical
+    - Overlord leader election
+    - Overlord and MiddleManager task management
+
+### [Apache Dubbo](http://dubbo.apache.org)
+  - Apache Dubbo is a high-performance, java based open source RPC framework.
+  - Zookeeper is used for service registration discovery and configuration management in Dubbo.[6]
+
+### [Apache Flink](https://flink.apache.org/)
+  - Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.
+    Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale.
+  - To enable JobManager High Availability you have to set the high-availability mode to zookeeper, configure a ZooKeeper quorum and set up a masters file with all JobManagers hosts and their web UI ports.
+    Flink leverages ZooKeeper for distributed coordination between all running JobManager instances. ZooKeeper is a separate service from Flink,
+    which provides highly reliable distributed coordination via leader election and light-weight consistent state storage[23].
+
+### [Apache Flume](https://flume.apache.org/)
+  - Flume is a distributed, reliable, and available service for efficiently collecting, aggregating, and moving large amounts
+    of log data. It has a simple and flexible architecture based on streaming data flows. It is robust and fault tolerant
+    with tunable reliability mechanisms and many failover and recovery mechanisms. It uses a simple extensible data model
+    that allows for online analytic application.
+  - Flume supports Agent configurations via Zookeeper. This is an experimental feature.[5]
+
+### [Apache Hadoop](http://hadoop.apache.org/)
+  - The Apache Hadoop software library is a framework that allows for the distributed processing of large data sets across
+    clusters of computers using simple programming models. It is designed to scale up from single servers to thousands of machines,
+    each offering local computation and storage. Rather than rely on hardware to deliver high-availability,
+    the library itself is designed to detect and handle failures at the application layer, so delivering a highly-available service on top of a cluster of computers, each of which may be prone to failures.
+  - The implementation of automatic HDFS failover relies on ZooKeeper for the following things:
+    - **Failure detection** - each of the NameNode machines in the cluster maintains a persistent session in ZooKeeper.
+      If the machine crashes, the ZooKeeper session will expire, notifying the other NameNode that a failover should be triggered.
+    - **Active NameNode election** - ZooKeeper provides a simple mechanism to exclusively elect a node as active. If the current active NameNode crashes,
+      another node may take a special exclusive lock in ZooKeeper indicating that it should become the next active.
+  - The ZKFailoverController (ZKFC) is a new component which is a ZooKeeper client which also monitors and manages the state of the NameNode.
+    Each of the machines which runs a NameNode also runs a ZKFC, and that ZKFC is responsible for:
+    - **Health monitoring** - the ZKFC pings its local NameNode on a periodic basis with a health-check command.
+      So long as the NameNode responds in a timely fashion with a healthy status, the ZKFC considers the node healthy.
+      If the node has crashed, frozen, or otherwise entered an unhealthy state, the health monitor will mark it as unhealthy.
+    - **ZooKeeper session management** - when the local NameNode is healthy, the ZKFC holds a session open in ZooKeeper.
+      If the local NameNode is active, it also holds a special “lock” znode. This lock uses ZooKeeper’s support for “ephemeral” nodes;
+      if the session expires, the lock node will be automatically deleted.
+    - **ZooKeeper-based election** - if the local NameNode is healthy, and the ZKFC sees that no other node currently holds the lock znode,
+      it will itself try to acquire the lock. If it succeeds, then it has “won the election”, and is responsible for running a failover to make its local NameNode active.
+      The failover process is similar to the manual failover described above: first, the previous active is fenced if necessary,
+      and then the local NameNode transitions to active state.[7]
+
+### [Apache HBase](https://hbase.apache.org/)
+  - HBase is the Hadoop database. It's an open-source, distributed, column-oriented store model.
+  - HBase uses ZooKeeper for master election, server lease management, bootstrapping, and coordination between servers.
+    A distributed Apache HBase installation depends on a running ZooKeeper cluster. All participating nodes and clients
+    need to be able to access the running ZooKeeper ensemble.[8]
+  - As you can see, ZooKeeper is a fundamental part of HBase. All operations that require coordination, such as Regions
+    assignment, Master-Failover, replication, and snapshots, are built on ZooKeeper[20].
+
+### [Apache Helix](http://helix.apache.org/)
+
+
+### [Apache Hive](https://hive.apache.org)
+  - The Apache Hive data warehouse software facilitates reading, writing, and managing large datasets residing in distributed
+    storage using SQL. Structure can be projected onto data already in storage. A command line tool and JDBC driver are provided to connect users to Hive.
+  - Hive has been using ZooKeeper as distributed lock manager to support concurrency in HiveServer2.[25,26]
+
+### [Apache Kafka](https://kafka.apache.org/)
+  - Kafka is a distributed publish/subscribe messaging system
+  - Apache Kafka relies on ZooKeeper for the following things:
+    - **Controller election**
+    The controller is one of the most important broking entity in a Kafka ecosystem, and it also has the responsibility
+    to maintain the leader-follower relationship across all the partitions. If a node by some reason is shutting down,
+    it’s the controller’s responsibility to tell all the replicas to act as partition leaders in order to fulfill the
+    duties of the partition leaders on the node that is about to fail. So, whenever a node shuts down, a new controller
+    can be elected and it can also be made sure that at any given time, there is only one controller and all the follower nodes have agreed on that.
+    - **Configuration Of Topics**
+    The configuration regarding all the topics including the list of existing topics, the number of partitions for each topic,
+    the location of all the replicas, list of configuration overrides for all topics and which node is the preferred leader, etc.
+    - **Access control lists**
+    Access control lists or ACLs for all the topics are also maintained within Zookeeper.
+    - **Membership of the cluster**
+    Zookeeper also maintains a list of all the brokers that are functioning at any given moment and are a part of the cluster.[9]
+
+### [Apache Mesos](http://mesos.apache.org/)
+  - Apache Mesos abstracts CPU, memory, storage, and other compute resources away from machines (physical or virtual),
+    enabling fault-tolerant and elastic distributed systems to easily be built and run effectively.
+  - Mesos has a high-availability mode that uses multiple Mesos masters: one active master (called the leader or leading master)
+    and several backups in case it fails. The masters elect the leader, with Apache ZooKeeper both coordinating the election
+    and handling leader detection by masters, agents, and scheduler drivers.[10]
+
+### [Apache Pulsar](https://pulsar.apache.org)
+  - Apache Pulsar is an open-source distributed pub-sub messaging system originally created at Yahoo and now part of the Apache Software Foundation
+  - Pulsar uses Apache Zookeeper for metadata storage, cluster configuration, and coordination. In a Pulsar instance:
+    - A configuration store quorum stores configuration for tenants, namespaces, and other entities that need to be globally consistent.
+    - Each cluster has its own local ZooKeeper ensemble that stores cluster-specific configuration and coordination such as ownership metadata,
+      broker load reports, BookKeeper ledger metadata, and more[24].
+
+### [Apache S4](https://github.com/apache/incubator-retired-s4)
+  - S4(**retired** on 2014-06-19[11]) is a general-purpose, distributed, scalable, partially fault-tolerant, pluggable platform that allows programmers
+    to easily develop applications for processing continuous unbounded streams of data.
+
+### [Apache Solr](https://lucene.apache.org/solr/)
+  - Solr is the popular, blazing-fast, open source enterprise search platform built on Apache Lucene.
+  - In the ""Cloud"" edition (v4.x and up) of enterprise search engine Apache Solr, ZooKeeper is used for configuration,
+    leader election and more[12,13]
+
+### [Apache Spark](https://spark.apache.org/)
+  - Apache Spark is a unified analytics engine for large-scale data processing.
+  - Utilizing ZooKeeper to provide leader election and some state storage, you can launch multiple Masters in your cluster connected to the same ZooKeeper instance.
+    One will be elected “leader” and the others will remain in standby mode. If the current leader dies, another Master will be elected,
+    recover the old Master’s state, and then resume scheduling[14]
+
+
+## Companies
+
+### 101tec","[{'comment': 'i meant this entire section of ""101tec"" should be removed as it\'s already removed from wiki.', 'commenter': 'hanm'}]"
1073,zookeeper-docs/src/main/resources/markdown/zookeeperUseCases.md,"@@ -0,0 +1,319 @@
+<!--
+Copyright 2002-2019 The Apache Software Foundation
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+//-->
+
+# ZooKeeper Use Cases
+
+- Applications and organizations using ZooKeeper include (alphabetically)[1].
+- If your use case wants to be listed here. Please do not hesitate, submit a pull request or write an email to **dev@zookeeper.apache.org**,
+  and then, your use case will be included.
+- If this documentation has violated your intellectual property rights or you and your company's privacy,write an email to **dev@zookeeper.apache.org**,
+  we will handle them in a timely manner.
+
+
+## Free Software Projects
+
+### [AdroitLogic UltraESB](http://adroitlogic.org/)
+  - Uses ZooKeeper to implement node coordination, in clustering support. This allows the management of the complete cluster,
+  or any specific node - from any other node connected via JMX. A Cluster wide command framework developed on top of the
+  ZooKeeper coordination allows commands that fail on some nodes to be retried etc. We also support the automated graceful
+  round-robin-restart of a complete cluster of nodes using the same framework[1].
+
+### [Akka](http://akka.io/)
+  - Akka is the platform for the next generation event-driven, scalable and fault-tolerant architectures on the JVM.
+  Or: Akka is a toolkit and runtime for building highly concurrent, distributed, and fault tolerant event-driven applications on the JVM[1].
+
+### [Eclipse Communication Framework](http://www.eclipse.org/ecf)
+  - The Eclipse ECF project provides an implementation of its Abstract Discovery services using Zookeeper. ECF itself
+  is used in many projects providing base functionallity for communication, all based on OSGi[1].
+
+### [Eclipse Gyrex](http://www.eclipse.org/gyrex)
+  - The Eclipse Gyrex project provides a platform for building your own Java OSGi based clouds. 
+  - ZooKeeper is used as the core cloud component for node membership and management, coordination of jobs executing among workers,
+  a lock service and a simple queue service and a lot more[1].
+
+### [GoldenOrb](http://www.goldenorbos.org/)
+  - massive-scale Graph analysis[1]
+
+### [Juju](https://juju.ubuntu.com/)
+  - Service deployment and orchestration framework, formerly called Ensemble[1].
+
+### [Katta](http://katta.sourceforge.net/)
+  - Katta serves distributed Lucene indexes in a grid environment.
+  - Zookeeper is used for node, master and index management in the grid[1].
+
+### [KeptCollections](https://github.com/anthonyu/KeptCollections)
+  - KeptCollections is a library of drop-in replacements for the data structures in the Java Collections framework.
+  - KeptCollections uses Apache ZooKeeper as a backing store, thus making its data structures distributed and scalable[1].
+
+### [Neo4j](https://neo4j.com/)
+  - Neo4j is a Graph Database. It's a disk based, ACID compliant transactional storage engine for big graphs and fast graph traversals,
+    using external indicies like Lucene/Solr for global searches.
+  - We use ZooKeeper in the Neo4j High Availability components for write-master election,
+    read slave coordination and other cool stuff. ZooKeeper is a great and focused project - we like![1]
+
+### [Norbert](http://sna-projects.com/norbert)
+  - Partitioned routing and cluster management[1].
+
+### [spring-cloud-zookeeper](https://spring.io/projects/spring-cloud-zookeeper)
+  - Spring Cloud Zookeeper provides Apache Zookeeper integrations for Spring Boot apps through autoconfiguration
+    and binding to the Spring Environment and other Spring programming model idioms. With a few simple annotations
+    you can quickly enable and configure the common patterns inside your application and build large distributed systems with Zookeeper.
+    The patterns provided include Service Discovery and Distributed Configuration.
+
+### [Talend ESB](http://www.talend.com/products-application-integration/application-integration-esb-se.php)
+  - Talend ESB is a versatile and flexible, enterprise service bus.
+  - It uses ZooKeeper as endpoint repository of both REST and SOAP Web services.
+    By using ZooKeeper Talend ESB is able to provide failover and load balancing capabilities in a very light-weight manner[1]
+
+### [redis_failover](https://github.com/ryanlecompte/redis_failover)
+  - Redis Failover is a ZooKeeper-based automatic master/slave failover solution for Ruby.[1]
+
+
+## Apache Projects
+
+### [Apache Accumulo](https://accumulo.apache.org/)
+  - Accumulo is a distributed key/value store that provides expressive, cell-level access labels.
+  - Apache ZooKeeper plays a central role within the Accumulo architecture. Its quorum consistency model supports an overall
+    Accumulo architecture with no single points of failure. Beyond that, Accumulo leverages ZooKeeper to store and communication 
+    configuration information for users and tables, as well as operational states of processes and tablets.[2]
+
+### [Apache BookKeeper](https://bookkeeper.apache.org/)
+  - A scalable, fault-tolerant, and low-latency storage service optimized for real-time workloads.
+  - BookKeeper requires a metadata storage service to store information related to ledgers and available bookies. BookKeeper currently uses
+    ZooKeeper for this and other tasks[3].
+
+### [Apache CXF DOSGi](http://cxf.apache.org/distributed-osgi.html)
+  - Apache CXF is an open source services framework. CXF helps you build and develop services using frontend programming
+    APIs, like JAX-WS and JAX-RS. These services can speak a variety of protocols such as SOAP, XML/HTTP, RESTful HTTP,
+    or CORBA and work over a variety of transports such as HTTP, JMS or JBI.
+  - The Distributed OSGi implementation at Apache CXF uses ZooKeeper for its Discovery functionality.[4]
+
+### [Apache Druid(Incubating)](https://druid.apache.org/)
+  - Apache Druid (incubating) is a high performance real-time analytics database.
+  - Apache Druid (incubating) uses Apache ZooKeeper (ZK) for management of current cluster state. The operations that happen over ZK are[27]:
+    - Coordinator leader election
+    - Segment ""publishing"" protocol from Historical and Realtime
+    - Segment load/drop protocol between Coordinator and Historical
+    - Overlord leader election
+    - Overlord and MiddleManager task management
+
+### [Apache Dubbo](http://dubbo.apache.org)
+  - Apache Dubbo is a high-performance, java based open source RPC framework.
+  - Zookeeper is used for service registration discovery and configuration management in Dubbo.[6]
+
+### [Apache Flink](https://flink.apache.org/)
+  - Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.
+    Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale.
+  - To enable JobManager High Availability you have to set the high-availability mode to zookeeper, configure a ZooKeeper quorum and set up a masters file with all JobManagers hosts and their web UI ports.
+    Flink leverages ZooKeeper for distributed coordination between all running JobManager instances. ZooKeeper is a separate service from Flink,
+    which provides highly reliable distributed coordination via leader election and light-weight consistent state storage[23].
+
+### [Apache Flume](https://flume.apache.org/)
+  - Flume is a distributed, reliable, and available service for efficiently collecting, aggregating, and moving large amounts
+    of log data. It has a simple and flexible architecture based on streaming data flows. It is robust and fault tolerant
+    with tunable reliability mechanisms and many failover and recovery mechanisms. It uses a simple extensible data model
+    that allows for online analytic application.
+  - Flume supports Agent configurations via Zookeeper. This is an experimental feature.[5]
+
+### [Apache Hadoop](http://hadoop.apache.org/)
+  - The Apache Hadoop software library is a framework that allows for the distributed processing of large data sets across
+    clusters of computers using simple programming models. It is designed to scale up from single servers to thousands of machines,
+    each offering local computation and storage. Rather than rely on hardware to deliver high-availability,
+    the library itself is designed to detect and handle failures at the application layer, so delivering a highly-available service on top of a cluster of computers, each of which may be prone to failures.
+  - The implementation of automatic HDFS failover relies on ZooKeeper for the following things:
+    - **Failure detection** - each of the NameNode machines in the cluster maintains a persistent session in ZooKeeper.
+      If the machine crashes, the ZooKeeper session will expire, notifying the other NameNode that a failover should be triggered.
+    - **Active NameNode election** - ZooKeeper provides a simple mechanism to exclusively elect a node as active. If the current active NameNode crashes,
+      another node may take a special exclusive lock in ZooKeeper indicating that it should become the next active.
+  - The ZKFailoverController (ZKFC) is a new component which is a ZooKeeper client which also monitors and manages the state of the NameNode.
+    Each of the machines which runs a NameNode also runs a ZKFC, and that ZKFC is responsible for:
+    - **Health monitoring** - the ZKFC pings its local NameNode on a periodic basis with a health-check command.
+      So long as the NameNode responds in a timely fashion with a healthy status, the ZKFC considers the node healthy.
+      If the node has crashed, frozen, or otherwise entered an unhealthy state, the health monitor will mark it as unhealthy.
+    - **ZooKeeper session management** - when the local NameNode is healthy, the ZKFC holds a session open in ZooKeeper.
+      If the local NameNode is active, it also holds a special “lock” znode. This lock uses ZooKeeper’s support for “ephemeral” nodes;
+      if the session expires, the lock node will be automatically deleted.
+    - **ZooKeeper-based election** - if the local NameNode is healthy, and the ZKFC sees that no other node currently holds the lock znode,
+      it will itself try to acquire the lock. If it succeeds, then it has “won the election”, and is responsible for running a failover to make its local NameNode active.
+      The failover process is similar to the manual failover described above: first, the previous active is fenced if necessary,
+      and then the local NameNode transitions to active state.[7]
+
+### [Apache HBase](https://hbase.apache.org/)
+  - HBase is the Hadoop database. It's an open-source, distributed, column-oriented store model.
+  - HBase uses ZooKeeper for master election, server lease management, bootstrapping, and coordination between servers.
+    A distributed Apache HBase installation depends on a running ZooKeeper cluster. All participating nodes and clients
+    need to be able to access the running ZooKeeper ensemble.[8]
+  - As you can see, ZooKeeper is a fundamental part of HBase. All operations that require coordination, such as Regions
+    assignment, Master-Failover, replication, and snapshots, are built on ZooKeeper[20].
+
+### [Apache Helix](http://helix.apache.org/)
+","[{'comment': 'the abstract of this project is missing here.', 'commenter': 'hanm'}, {'comment': ""- Now this PR re-enters into a state of reviewing.\r\n- I'am always here to wait whether someone else wants to add other additions."", 'commenter': 'maoling'}]"
1080,zookeeper-jute/src/main/java/org/apache/jute/BinaryInputArchive.java,"@@ -85,6 +85,14 @@ public String readString(String tag) throws IOException {
     }
     
     static public final int maxBuffer = Integer.getInteger(""jute.maxbuffer"", 0xfffff);
+    static public int readExtraSize = Integer.getInteger(""zookeeper.jute.maxbuffer.extrasize"",","[{'comment': 'please make it final', 'commenter': 'eolivelli'}, {'comment': 'variable readExtraSize is reinitialized at line number 93.  So I think it cannot be marked final.', 'commenter': 'arshadmohammad'}]"
1080,zookeeper-jute/src/main/java/org/apache/jute/BinaryInputArchive.java,"@@ -85,6 +85,14 @@ public String readString(String tag) throws IOException {
     }
     
     static public final int maxBuffer = Integer.getInteger(""jute.maxbuffer"", 0xfffff);
+    static public int readExtraSize = Integer.getInteger(""zookeeper.jute.maxbuffer.extrasize"",
+            maxBuffer);
+    static {
+        // Earlier hard coded value is 1024, So the value should not be less than that
+        if (readExtraSize < 1024) {","[{'comment': 'Assign an initial value to a temp variable here, do this small computation, then assign the value to the variable.\r\nIt is legal to assign a value in a static block to a final static field, the only constraint is that you do the assignement only once', 'commenter': 'eolivelli'}, {'comment': 'ok, changed it', 'commenter': 'arshadmohammad'}]"
1080,zookeeper-server/src/test/java/org/apache/zookeeper/JuteMaxBufferTest.java,"@@ -0,0 +1,146 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper;
+
+import static org.apache.zookeeper.test.ClientBase.CONNECTION_TIMEOUT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.common.ZKConfig;
+import org.apache.zookeeper.server.ZKDatabase;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class JuteMaxBufferTest extends QuorumPeerTestBase {
+    private MainThread mt;
+
+    @Before
+    public void setup() throws Exception {
+        // Request size for 100 nodes in this test class is 6197 bytes
+        System.setProperty(ZKConfig.JUTE_MAXBUFFER, Integer.toString(6197));","[{'comment': ""This trick won't work, because the variable will be inizialized only at the first loading of the class.\r\nOnce you assign a value you cannot change it"", 'commenter': 'eolivelli'}, {'comment': 'ZKConfig.JUTE_MAXBUFFER is initialized with only one value that is why it was working, anyway I moved initialization to class level so it is initialized only once', 'commenter': 'arshadmohammad'}, {'comment': '@arshadmohammad if you run this test together with the other ones you will see that the system property does not  have effect. \r\nYou can add an assertion in your test case that the value of *readExtraSize* is the expected value and it is different from the default one. ', 'commenter': 'eolivelli'}, {'comment': 'Thanks @eolivelli for your suggestions. I had run this test in ant build setup and it was working fine. I think in ant it was forking new jvm for every test class. that is why it might have passed. \r\nBut yes , if in one jvm multiple tests are running, value assigned to org.apache.jute.BinaryInputArchive#maxBuffer can not be changed from this test case.', 'commenter': 'arshadmohammad'}, {'comment': 'So what shall we do, shall we commit without test case? any other idea?\r\n', 'commenter': 'arshadmohammad'}]"
1080,zookeeper-server/src/test/java/org/apache/zookeeper/JuteMaxBufferTest.java,"@@ -0,0 +1,146 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper;
+
+import static org.apache.zookeeper.test.ClientBase.CONNECTION_TIMEOUT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.common.ZKConfig;
+import org.apache.zookeeper.server.ZKDatabase;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class JuteMaxBufferTest extends QuorumPeerTestBase {
+    private MainThread mt;
+
+    @Before
+    public void setup() throws Exception {
+        // Request size for 100 nodes in this test class is 6197 bytes
+        System.setProperty(ZKConfig.JUTE_MAXBUFFER, Integer.toString(6197));
+    }
+
+    /**
+     * ZOOKEEPER-3496
+     */
+    @Test
+    public void testServerAllowsTransactionMoreThanMaxBufferSize() throws Exception {
+        // in this test case, multi operation request size is 6196 bytes
+        int clientPort = PortAssignment.unique();
+        String quorumCfgSection = ""server.1=127.0.0.1:"" + (PortAssignment.unique()) + "":""
+                + (PortAssignment.unique()) + "":participant;"" + clientPort + ""\n"";
+
+        mt = new MainThread(1, clientPort, quorumCfgSection, false);
+        mt.start();
+        Assert.assertTrue(""waiting for server 1 being up"",
+                ClientBase.waitForServerUp(""127.0.0.1:"" + clientPort, CONNECTION_TIMEOUT));
+
+        ZooKeeper zk = ClientBase.createZKClient(""127.0.0.1:"" + clientPort);
+        String parent = ""/parent"";
+        zk.create(parent, """".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+        zk.addAuthInfo(""digest"", ""pat:test"".getBytes());
+        List<Op> ops = new ArrayList<Op>();
+        int numberOfNodes = 100;
+        for (int i = 0; i < numberOfNodes; i++) {
+            ops.add(Op.create(parent + ""/child"" + i, (""data"" + i).getBytes(), Ids.CREATOR_ALL_ACL,
+                    CreateMode.PERSISTENT));
+        }
+        /**
+         * Have set jute.maxbuffer to 6197. 100 znode size is 6197, so creation will be
+         * success
+         */
+        zk.multi(ops);
+        List<String> children = zk.getChildren(parent, false);
+        // check nodes are created successfully.
+        assertEquals(numberOfNodes, children.size());
+
+        /**
+         * Server added some additional information(ACL in this case) in those 100
+         * znodes. So total size of 100 records in transaction log file is more than
+         * 6197. Total size is around 9616. So it added 3419 extra bytes. If extrasize
+         * is kept 1024, then test case will fail (earlier default scenario). Now the
+         * extraSize default value is same as jute buffer size. In this case it will be
+         * 6197. So 9616 less than (6197+6197) will pass.
+         */
+        File dataDir = new File(mt.getConfFile().getParentFile(), ""data"");
+        assertTrue(""data directory does not exist"", dataDir.exists());
+        ZKDatabase database = new ZKDatabase(new FileTxnSnapLog(dataDir, dataDir));
+        database.loadDataBase();
+    }
+
+    /**
+     * ZOOKEEPER-3496. This test is normal jute.maxbuffer functionality test. It
+     * should pass before and after fix
+     */
+    @Test
+    public void testZKOperationRequestOfSizeGreaterThanMaxBuffer() throws Exception {
+        int clientPort = PortAssignment.unique();
+        String quorumCfgSection = ""server.1=127.0.0.1:"" + (PortAssignment.unique()) + "":""
+                + (PortAssignment.unique()) + "":participant;"" + clientPort + ""\n"";
+
+        mt = new MainThread(1, clientPort, quorumCfgSection, false);
+        mt.start();
+        Assert.assertTrue(""waiting for server 1 being up"",
+                ClientBase.waitForServerUp(""127.0.0.1:"" + clientPort, CONNECTION_TIMEOUT));
+
+        ZooKeeper zk = ClientBase.createZKClient(""127.0.0.1:"" + clientPort);
+        String parent = ""/parent"";
+        zk.create(parent, """".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+        zk.addAuthInfo(""digest"", ""pat:test"".getBytes());
+        List<Op> ops = new ArrayList<Op>();
+
+        /**
+         * This code will create 101 Nodes , 100 node size is 6197 Bytes. So this
+         * operation should fail
+         */
+        int numberOfNodes = 101;
+        for (int i = 0; i < numberOfNodes; i++) {
+            ops.add(Op.create(parent + ""/child"" + i, (""data"" + i).getBytes(), Ids.CREATOR_ALL_ACL,
+                    CreateMode.PERSISTENT));
+        }
+        try {
+            zk.multi(ops);
+            fail(""KeeperException is expected as request size is more than jute.maxbuffer size"");
+        } catch (KeeperException e) {
+            System.out.println(""Expected to fail as request size exceeded jute max buffer size""
+                    + e.getMessage());
+            // do nothing, Exception is expected
+        }
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        System.clearProperty(ZKConfig.JUTE_MAXBUFFER);","[{'comment': 'Same here', 'commenter': 'eolivelli'}, {'comment': 'moved to class level clean up', 'commenter': 'arshadmohammad'}]"
1080,zookeeper-jute/src/main/java/org/apache/jute/BinaryInputArchive.java,"@@ -85,6 +85,18 @@ public String readString(String tag) throws IOException {
     }
     
     static public final int maxBuffer = Integer.getInteger(""jute.maxbuffer"", 0xfffff);","[{'comment': 'In order to have better testing we can do as follows:\r\n- make maxBuffer and readExtraSize two instance variables\r\n- add two new constants (final static) DEFAULT_MAX_BUFFER and DEFAULT_READEXTRASIZE initialized with the system properties\r\n- in the constructor initialize the value using DEFAULT_MAX_BUFFER and DEFAULT_READEXTRASIZE\r\n- add a new constructor that allows to initialize maxBuffer and readExtraSize\r\n- add only unit tests about BinaryInputArchive, and not end to end tests', 'commenter': 'eolivelli'}, {'comment': 'I liked the approach. thanks.  Addressed the comments more or less same way. Please have a look.  \r\nmaxBuffer is used many places and it is not the default value, it is the configured value. So leaving this variable as it is. created other instance variable as suggested but with different name, hope it is ok.', 'commenter': 'arshadmohammad'}]"
1080,zookeeper-jute/src/main/java/org/apache/jute/BinaryInputArchive.java,"@@ -85,6 +85,18 @@ public String readString(String tag) throws IOException {
     }
     
     static public final int maxBuffer = Integer.getInteger(""jute.maxbuffer"", 0xfffff);
+    static public final int readExtraSize;
+
+    static {
+        Integer configuredValue =
+            Integer.getInteger(""zookeeper.jute.maxbuffer.extrasize"", maxBuffer);
+        if (configuredValue < 1024) {
+            // Earlier hard coded value is 1024, So the value should not be less than that
+            readExtraSize = 1024;","[{'comment': ""Do we have a reasonable estimate of an upper bound of the extra field padding which could reasonably cover more practice use cases, so users don't have to configure this value themselves? Obviously it's not tractable to find a single value that cover all cases (unless we use infinity), but it seems reasonable to increase this value - say by 10x while still be safeguarding requests with unreasonable length.\r\n\r\n"", 'commenter': 'hanm'}, {'comment': 'In this patch we have changed the default value of extra size to same as max buffer value.  I do not foresee any scenario where record extra size is more than the actual record size.\r\n\tSo this value is going to be sufficient and possibly there would not be any need to configure jute.maxbuffer.extrasize.', 'commenter': 'arshadmohammad'}]"
1080,zookeeper-jute/src/main/java/org/apache/jute/BinaryInputArchive.java,"@@ -27,8 +27,23 @@
  *
  */
 public class BinaryInputArchive implements InputArchive {
-    static public final String UNREASONBLE_LENGTH= ""Unreasonable length = "";
+    public static final String UNREASONBLE_LENGTH= ""Unreasonable length = "";
+    public static final int maxBuffer = Integer.getInteger(""jute.maxbuffer"", 0xfffff);
+    private static final int extraMaxBuffer;
+
+    static {
+        Integer configuredExtraMaxBuffer =
+            Integer.getInteger(""zookeeper.jute.maxbuffer.extrasize"", maxBuffer);","[{'comment': 'one suggestion: existing maxbuffer has a name of ""jute.maxbuffer"" (note, without zookeeper prefix), so it might be better\r\nthat we name this extra size property as ""jute.maxbuffer.extrasize"" to be consistent with existing style.\r\n\r\nalso, we need documentation on this new property. ', 'commenter': 'hanm'}, {'comment': 'There is big problem with jute.maxbuffer. It can not be configured in zoo.cfg.  We are forced to configure it though java system property like -Djute.maxbuffer=someValue.\r\n\r\nWhen we are giving property name zookeeper.jute.maxbuffer.extrasize. it can be configured in zoo.cfg as jute.maxbuffer.extrasize=someValue\r\n\r\nThis is the reason I do not want to be consistent with jute.maxbuffer.  is it OK?\r\n\r\n\r\n', 'commenter': 'arshadmohammad'}, {'comment': ""i see - sounds reasonable. I am ok with current name.\r\n\r\nside note - I never really remember why we have a few configuration options that's only available through java system properties and what's the criteria of choosing one versus another. "", 'commenter': 'hanm'}]"
1080,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1077,6 +1077,17 @@ the variable does.
     problems will arise. This is really a sanity check. ZooKeeper is
     designed to store data on the order of kilobytes in size.
 
+* *jute.maxbuffer.extrasize*:
+    (Java system property: **zookeeper.jute.maxbuffer.extrasize**)
+    **New in 3.5.7:**
+    While processing client requests ZooKeeper server adds some additional information into 
+    the requests before persisting it as a transaction. Earlier this additional information size 
+    was fixed to 1024 bytes. For many scenarios, specially scenarios where jute.maxbuffer value
+    is more than 1 MB and request type is multi, this fixed size was sufficient.","[{'comment': 'replace `sufficient` with `insufficient` ?', 'commenter': 'hanm'}, {'comment': 'right, corrected it', 'commenter': 'arshadmohammad'}]"
1084,zookeeper-server/src/main/java/org/apache/zookeeper/client/ZooKeeperSaslClient.java,"@@ -274,7 +274,7 @@ public void respondToServer(byte[] serverToken, ClientCnxn cnxn) {
             } catch (SaslException e) {
                 LOG.error(""SASL authentication failed using login context '""
                           + this.getLoginContext()
-                          + ""' with exception: {}"", e);","[{'comment': ""I think slf4 still logs the exception as exceptions are handled in a special way.\r\nDoesn't it?"", 'commenter': 'eolivelli'}, {'comment': '![image](https://user-images.githubusercontent.com/7615397/64586920-4a04d600-d3d0-11e9-87be-1f880bc6c8c6.png)\r\nJust like this.', 'commenter': 'ajingxian200'}, {'comment': '@eolivelli there are several overload methods, what are relevant is as below\r\n\r\n```java\r\npublic void error(String format, Object arg);\r\npublic void error(String format, Object arg1, Object arg2);\r\npublic void error(String format, Object... arguments);\r\npublic void error(String msg, Throwable t);\r\n```\r\n\r\nI think\r\n\r\n```java\r\nLOG.error(String.format(""... %s"", e.getMessage()), e);\r\n```\r\n\r\nis also a valid fix.', 'commenter': 'tisonkun'}, {'comment': 'Ya, this example is a bit odd.\r\n\r\n```\r\n                LOG.error(""SASL authentication failed using login context \'""\r\n                          + this.getLoginContext()\r\n                          + ""\' with exception: {}"", e);\r\n```\r\n\r\nIt is using parameters and concatenation.  Typically one or the other is used, not both.\r\n\r\n`Throwable` objects are handled special.  They do not need the marker `{}` to be included in the message, they just need to be the last argument in the list.  If a stack trace is not desirable, then  using a marker in conjunction with `e.getMessage()` can be used.\r\n\r\nSomething better would be:\r\n```\r\nLOG.error(""SASL authentication failed using login context \'{}\'"", this.getLoginContext(), e);\r\n```\r\n\r\nThe login context is passed to the marker, and the `Exception` message (plus stack trace) is printed as well.', 'commenter': 'belugabehr'}]"
1085,zookeeper-server/src/main/java/org/apache/zookeeper/util/SocketUtils.java,"@@ -0,0 +1,44 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.util;
+
+import java.net.Socket;
+import java.net.SocketException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Util class used to set the common options on socket.
+ */
+public class SocketUtils {
+    private static final Logger LOG = LoggerFactory.getLogger(SocketUtils.class);
+
+    public static final String SOCKET_SO_LINGER = ""zookeeper.quorum.solinger"";
+    private static int soLinger = 0;
+
+    static {
+        soLinger = Integer.getInteger(SOCKET_SO_LINGER, 0);
+        LOG.info(""{} = {}"", SOCKET_SO_LINGER, soLinger);
+    }
+
+    public static void setSocketOption(Socket sock, int soTimeout) throws SocketException {
+        sock.setSoTimeout(soTimeout);
+        sock.setSoLinger(true, soLinger);","[{'comment': ""There's no way to turn it off. Is that intentional?"", 'commenter': 'anmolnar'}, {'comment': ""It seems soLinger is always useful, and set the value to a big value is kind of turning it off, that's why we didn't add option to set it to false. Do you suggest to add it? "", 'commenter': 'lvfangmin'}]"
1091,zookeeper-server/src/main/java/org/apache/zookeeper/server/ContainerManager.java,"@@ -139,14 +140,22 @@ protected long getMinIntervalMs() {
         Set<String> candidates = new HashSet<String>();
         for (String containerPath : zkDb.getDataTree().getContainers()) {
             DataNode node = zkDb.getDataTree().getNode(containerPath);
-            /*
-                cversion > 0: keep newly created containers from being deleted
-                before any children have been added. If you were to create the
-                container just before a container cleaning period the container
-                would be immediately be deleted.
-             */
-            if ((node != null) && (node.stat.getCversion() > 0) && (node.getChildren().isEmpty())) {
-                candidates.add(containerPath);
+            boolean wasNewWithNoChildren = noChildrenAtLastCheck.remove(containerPath);
+
+            if (node != null && node.getChildren().isEmpty()) {
+                if (node.stat.getCversion() == 0) {
+                    // Give newly created containers a grace period and avoid deleting
+                    // them before any children could be added. If you were to create the
+                    // container just before a container cleaning period the container
+                    // would be immediately be deleted.
+                    if (wasNewWithNoChildren) {
+                        candidates.add(containerPath);
+                    } else {
+                        noChildrenAtLastCheck.add(containerPath);","[{'comment': 'At a first glance we are only adding elements and never clearing the collection', 'commenter': 'eolivelli'}, {'comment': ""Yes, we do it outside of the `getChildren().isEmpty()` test. Children may have been added since the container was added to that collection, so we need to make sure that containers with children don't stay in it forever.\r\n\r\n```java\r\nboolean wasNewWithNoChildren = noChildrenAtLastCheck.remove(containerPath);\r\n```"", 'commenter': 'swallez'}]"
1091,zookeeper-server/src/test/java/org/apache/zookeeper/server/CreateContainerTest.java,"@@ -237,6 +237,22 @@ public Void call() throws Exception {
         assertEquals(queue.poll(5, TimeUnit.SECONDS), ""/four"");
     }
 
+    @Test(timeout = 30000)
+    public void testContainerWithNoChildGracePeriod() throws KeeperException, InterruptedException {
+        zk.create(""/foo"", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);
+
+        ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100);
+        containerManager.checkContainers();
+        Thread.sleep(1000);
+
+        assertNotNull(""Container should still be there"", zk.exists(""/foo"", false));
+
+        containerManager.checkContainers();","[{'comment': 'Can we avoid this sleep?\r\nThis test may turn into a flaky one', 'commenter': 'eolivelli'}, {'comment': 'I used the same approach as other tests in that class, where I understand that these `sleep` after each call to `checkContainers` are precisely there to avoid flakiness by giving time to the ZK server to asynchronously delete the nodes that have been selected for removal.\r\n\r\nDid I miss something?', 'commenter': 'swallez'}]"
1095,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -155,13 +155,11 @@
 
     private final int sessionTimeout;
 
-    private final ZooKeeper zooKeeper;
-
-    private final ClientWatchManager watcher;
+    private final ZKWatchManager watchManager;","[{'comment': 'this one should be ClientWatchManager', 'commenter': 'eolivelli'}, {'comment': 'Nope *for now*. `ClientWatchManager` provides the only interface `materialize` while we need to retrieve dataWatches and so on. It can be a separated issue we revisit `ClientWatchManager` and enrich interfaces it provides, as well as loose this type constrain to `ClientWatchManager`.', 'commenter': 'tisonkun'}]"
1095,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -605,7 +321,7 @@ public DataWatchRegistration(Watcher watcher, String clientPath) {
 
         @Override
         protected Map<String, Set<Watcher>> getWatches(int rc) {
-            return watchManager.dataWatches;
+            return getWatchManager().dataWatches;","[{'comment': 'dataWatches -> getDataWatches() \r\notherwise we are breaking the incapsulation you are introducing', 'commenter': 'eolivelli'}, {'comment': 'good point. Addressing...', 'commenter': 'tisonkun'}]"
1095,zookeeper-server/src/main/java/org/apache/zookeeper/ZKWatchManager.java,"@@ -0,0 +1,297 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Manage watchers and handle events generated by the ClientCnxn object.
+ * <p>
+ * We are implementing this as a nested class of ZooKeeper so that
+ * the public methods will not be exposed as part of the ZooKeeper client
+ * API.
+ */","[{'comment': 'this copied annotate needs a update?', 'commenter': 'maoling'}, {'comment': ""Thanks for your review. I'm going to update it and rebase the pull request in this week."", 'commenter': 'tisonkun'}]"
1095,zookeeper-server/src/main/java/org/apache/zookeeper/ZKWatchManager.java,"@@ -0,0 +1,443 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import org.apache.zookeeper.server.watch.PathParentIterator;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Manage watchers and handle events generated by the ClientCnxn object.
+ *
+ * This class is intended to be packaged-private so that it doesn't serve
+ * as part of ZooKeeper client API.
+ */
+class ZKWatchManager implements ClientWatchManager {
+","[{'comment': 'Great', 'commenter': 'maoling'}]"
1095,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -2268,7 +1885,7 @@ public Stat exists(final String path, Watcher watcher) throws KeeperException, I
      * @throws InterruptedException If the server transaction is interrupted.
      */
     public Stat exists(String path, boolean watch) throws KeeperException, InterruptedException {
-        return exists(path, watch ? watchManager.defaultWatcher : null);
+        return exists(path, watch ? defaultWatcher : null);
     }","[{'comment': '> let ZooKeeper syncs a copy of default watcher, in order to reduce dependencies to getWatchManager()\r\n\r\n You have used `getWatchManager()` in the `zookeeper.java`, `getWatchManager().getDefaultWatcher()` is better? The origin logic is: get the `defaultWatcher` from `ZKWatchManager`.', 'commenter': 'maoling'}, {'comment': 'Yes definitely. Updating...', 'commenter': 'tisonkun'}]"
1095,zookeeper-server/src/test/java/org/apache/zookeeper/server/NettyServerCnxnTest.java,"@@ -85,10 +85,9 @@ public void tearDown() throws Exception {
     public void testSendCloseSession() throws Exception {
         assertTrue(""Didn't instantiate ServerCnxnFactory with NettyServerCnxnFactory!"", serverFactory instanceof NettyServerCnxnFactory);
 
-        final ZooKeeper zk = createClient();
-        final ZooKeeperServer zkServer = serverFactory.getZooKeeperServer();
-        final String path = ""/a"";
-        try {
+        try (ZooKeeper zk = createClient()) {
+            final ZooKeeperServer zkServer = serverFactory.getZooKeeperServer();","[{'comment': ""Please don't do unrelated refactor work next time"", 'commenter': 'maoling'}, {'comment': 'Sorry for that. I will keep in mind.', 'commenter': 'tisonkun'}]"
1095,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -352,35 +354,29 @@ public String toString() {
      * established until needed. The start() instance method must be called
      * subsequent to construction.
      *
-     * @param chrootPath - the chroot of this client. Should be removed from this Class in ZOOKEEPER-838
-     * @param hostProvider
-     *                the list of ZooKeeper servers to connect to
-     * @param sessionTimeout
-     *                the timeout for connections.
-     * @param zooKeeper
-     *                the zookeeper object that this connection is related to.
-     * @param watcher watcher for this connection
-     * @param clientCnxnSocket
-     *                the socket implementation used (e.g. NIO/Netty)
-     * @param canBeReadOnly
-     *                whether the connection is allowed to go to read-only
-     *                mode in case of partitioning
-     * @throws IOException
+     * @param chrootPath the chroot of this client. Should be removed from this Class in ZOOKEEPER-838
+     * @param hostProvider the list of ZooKeeper servers to connect to
+     * @param sessionTimeout the timeout for connections.
+     * @param clientConfig the client configuration.
+     * @param defaultWatcher default watcher for this connection
+     * @param clientCnxnSocket the socket implementation used (e.g. NIO/Netty)
+     * @param canBeReadOnly whether the connection is allowed to go to read-only mode in case of partitioning
      */
     public ClientCnxn(
         String chrootPath,
         HostProvider hostProvider,
         int sessionTimeout,
-        ZooKeeper zooKeeper,
-        ClientWatchManager watcher,
+        ZKClientConfig clientConfig,","[{'comment': ""this is my major concern.\r\n\r\nIt is true that we are not changing the very high level API, as ClientCnxn is an internal class and applications should not use it directly.\r\n\r\nBut it is probable that frameworks like Curator (ping @Randgalt ) do tricks over this stuff.\r\n\r\nThis change is a big refactor and touches the very internals of the client so we should handle it with care.\r\n\r\nDon't get my wrong, I think this work is awesome and I hope we can make it land it to master someday.\r\n\r\nThat's only my opinion, let's see if any other reviewer wants to sponsor this change"", 'commenter': 'eolivelli'}, {'comment': ""On first glance it doesn't look like it conflicts with Curator. But, maybe @TisonKun can test with Curator locally. As an aside, I wonder if we shouldn't include some Curator test in ZooKeeper in the future - i.e. validate that new changes don't break Curator. "", 'commenter': 'Randgalt'}, {'comment': ""@eolivelli After a close look I find that where Curator hacking into `ClientCnxn` is only `InjectSessionExpiration` that get access of `cnxn`/`eventThread`/`queueEvent`. So this patch should not break Curator.\r\n\r\nAnd I second @Randgalt that it is Curator responsibility to adjust its trick for accessing ZooKeeper internal concept since they don't promise compatibility. IMO Curator already has a `Compatibility` utils for different manner between zk34 and zk35. We should continue refining codebase so that projects such as Curator don't have to rely on internal concepts, though."", 'commenter': 'tisonkun'}]"
1095,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -1010,11 +1002,11 @@ void primeConnection() throws IOException {
             // TODO: here we have the only remaining use of zooKeeper in
             // this class. It's to be eliminated!","[{'comment': 'nit: I think we can remove this comment now', 'commenter': 'symat'}, {'comment': 'Exactly! I think the removal lost in the last rebase :/\r\n\r\nUpdated.', 'commenter': 'tisonkun'}]"
1096,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1387,6 +1387,17 @@ the variable does.
     problems will arise. This is really a sanity check. ZooKeeper is
     designed to store data on the order of kilobytes in size.
 
+* *jute.maxbuffer.extrasize*:
+    (Java system property: **zookeeper.jute.maxbuffer.extrasize**)
+    **New in 3.6.0:**","[{'comment': ""You have committed **New in 3.5.7** for branch-3.5.\r\n\r\nI feel we should stick to 3.5.7, though I don't know which ever we will release first "", 'commenter': 'eolivelli'}, {'comment': 'What should be the version in branch-3.4? 3.4.15 or 3.5.7?\r\n\r\n', 'commenter': 'arshadmohammad'}, {'comment': ""I think we won't port it to 3.4, it is a maintenance only version"", 'commenter': 'eolivelli'}, {'comment': 'OK', 'commenter': 'arshadmohammad'}]"
1098,zookeeper-server/src/main/java/org/apache/zookeeper/server/NIOServerCnxn.java,"@@ -712,7 +691,7 @@ public void process(WatchedEvent event) {
         // Convert WatchedEvent to a type that can be sent over the wire
         WatcherEvent e = event.getWrapper();
 
-        sendResponse(h, e, ""notification"", null, null);
+        sendResponse(h, e, ""notification"", null, null, -1);","[{'comment': 'This -1 smells a little.\r\nI wonder if a constant may speak more about the fact that it is a non value', 'commenter': 'eolivelli'}, {'comment': '@eolivelli Good suggestion. Instead of passing -1 here, I pass the corresponding OpCode enum (OpCode.error) as the signal of ""we don\'t care"" (with added comments). This also has benefit that in future if we ever change the OpCode values, we will not accidentally end up with using response cache when we don\'t want to.', 'commenter': 'hanm'}]"
1098,zookeeper-server/src/main/java/org/apache/zookeeper/server/ResponseCache.java,"@@ -22,23 +22,31 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 import org.apache.zookeeper.data.Stat;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 @SuppressWarnings(""serial"")
 public class ResponseCache {
+    private static final Logger LOG = LoggerFactory.getLogger(ResponseCache.class);
 
     // Magic number chosen to be ""big enough but not too big""
-    private static final int DEFAULT_RESPONSE_CACHE_SIZE = 400;
-
+    public static final int DEFAULT_RESPONSE_CACHE_SIZE = 400;
+    private final int cacheSize;
     private static class Entry {
-
         public Stat stat;
         public byte[] data;
-
     }
 
-    private Map<String, Entry> cache = Collections.synchronizedMap(new LRUCache<String, Entry>(getResponseCacheSize()));
+    private Map<String, Entry> cache;","[{'comment': 'nit: final?', 'commenter': 'eolivelli'}]"
1098,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -719,6 +719,15 @@ property, when available, is noted below.
     by default with a value of 400, set to 0 or a negative
     integer to turn the feature off.
 
+* *maxGetChildrenResponseCacheSize* :","[{'comment': 'Please add ""**New in 3.6.0**""', 'commenter': 'anmolnar'}]"
1098,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -307,9 +310,13 @@ public ZooKeeperServer(FileTxnSnapLog txnLogFactory, int tickTime, int minSessio
 
         listener = new ZooKeeperServerListenerImpl(this);
 
-        readResponseCache = new ResponseCache();
+        readResponseCache = new ResponseCache(Integer.getInteger(
+            GET_DATA_RESPONSE_CACHE_SIZE,
+            ResponseCache.DEFAULT_RESPONSE_CACHE_SIZE));
 
-        getChildrenResponseCache = new ResponseCache();
+        getChildrenResponseCache = new ResponseCache(Integer.getInteger(
+            GET_CHILDREN_RESPONSE_CACHE_SIZE,
+            ResponseCache.DEFAULT_RESPONSE_CACHE_SIZE));","[{'comment': 'need to print the log of these two parameters to let users know?', 'commenter': 'maoling'}]"
1105,zookeeper-server/src/main/java/org/apache/zookeeper/ZKUtil.java,"@@ -20,18 +20,22 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Deque;
+import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 
 import org.apache.zookeeper.AsyncCallback.StringCallback;
 import org.apache.zookeeper.AsyncCallback.VoidCallback;
 import org.apache.zookeeper.KeeperException.Code;
 import org.apache.zookeeper.common.PathUtils;
+import org.apache.zookeeper.data.ACL;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 public class ZKUtil {
     private static final Logger LOG = LoggerFactory.getLogger(ZKUtil.class);
+    private static final Map<Integer, String> permCache = new HashMap<Integer, String>();","[{'comment': 'ConcurrentHashMap?', 'commenter': 'eolivelli'}, {'comment': 'Changed.', 'commenter': 'arshadmohammad'}]"
1105,zookeeper-docs/src/main/resources/markdown/zookeeperAuditLogs.md,"@@ -0,0 +1,124 @@
+<!--
+Copyright 2002-2004 The Apache Software Foundation
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+//-->
+
+# ZooKeeper Audit Logging
+
+* [ZooKeeper Audit Logs](#ch_auditLogs)
+* [ZooKeeper Audit Log Configuration](#ch_reconfig_format)
+* [Who is taken as user in audit logs?](#ch_zkAuditUser)
+<a name=""ch_auditLogs""></a>
+
+## ZooKeeper Audit Logs
+
+Apache ZooKeeper supports audit logs form version 3.5.7. By default audit logs are disabled. To enable audit logs configure audit.enable=true in conf/zoo.cfg. Audit logs are not logged on all the ZooKeeper servers, but logged only on the servers where client is connected as depicted in below figure.","[{'comment': 'Typo: form -> from.\r\n\r\nI think we should say 3.6.0', 'commenter': 'eolivelli'}, {'comment': 'This PR I have raised for branch-3.5. After commit I will raise PR for master branch that time I will change this to 3.6.0.  Branch releases are independent. I think this way we can be bit more accurate. In last PR was discussed but on second thought this would be the better way.\r\nare you ok with  3.5.7 for branch-5  and 3.6..0 for master?', 'commenter': 'arshadmohammad'}, {'comment': 'corrected typo', 'commenter': 'arshadmohammad'}]"
1105,zookeeper-server/src/main/java/org/apache/zookeeper/Login.java,"@@ -286,6 +286,13 @@ public Subject getSubject() {
         return subject;
     }
 
+    public String getUserName() {
+        if (principal == null || principal.isEmpty()) {
+            return System.getProperty(""user.name"", ""<NA>"");","[{'comment': 'You can sample the value as a static variable. You will save an access to the system properties map', 'commenter': 'eolivelli'}, {'comment': 'done', 'commenter': 'arshadmohammad'}]"
1105,zookeeper-server/src/main/java/org/apache/zookeeper/ZKUtil.java,"@@ -168,4 +172,53 @@ private static void visitSubTreeDFSHelper(ZooKeeper zk, final String path,
             return; // ignore
         }
     }
+
+    /**
+     * @param perms
+     *            ACL permissions
+     * @return string representation of permissions
+     */
+    public static String getPermString(int perms) {
+        String permString = permCache.get(perms);","[{'comment': 'what about using computeIfAbsent?', 'commenter': 'eolivelli'}, {'comment': 'nice', 'commenter': 'arshadmohammad'}]"
1105,zookeeper-server/src/main/java/org/apache/zookeeper/audit/AuditConstants.java,"@@ -0,0 +1,37 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+public class AuditConstants {","[{'comment': 'final\r\n\r\nPlease also add a private constructor', 'commenter': 'eolivelli'}, {'comment': 'Done', 'commenter': 'arshadmohammad'}]"
1105,zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -210,7 +224,8 @@ public void processRequest(Request request) {
             case OpCode.multi: {
                 lastOp = ""MULT"";
                 rsp = new MultiResponse() ;
-
+                Map<String, String> createModes = getCreateModes(request);","[{'comment': 'Can we create this map only if needed?', 'commenter': 'eolivelli'}]"
1105,zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -514,4 +555,157 @@ public void shutdown() {
         LOG.info(""shutdown of request processor complete"");
     }
 
+    private void addSuccessAudit(Request request, ServerCnxn cnxn, String op, String path) {
+        addSuccessAudit(request, cnxn, op, path, null, null);
+    }
+
+    private void addSuccessAudit(Request request, ServerCnxn cnxn, String op, String path,
+        String acl, String createMode) {
+        if (!ZKAuditLogger.isAuditEnabled()) {
+            return;
+        }
+        ZKAuditLogger
+            .logSuccess(request.getUsers(), op, path, acl, createMode, cnxn.getSessionIdHex(),
+                cnxn.getHostAddress());
+    }
+
+    private void addFailureAudit(Request request, ServerCnxn cnxn, String op, String path) {
+        addFailureAudit(request, cnxn, op, path, null, null);
+    }
+
+    private void addFailureAudit(Request request, ServerCnxn cnxn, String op, String path,
+        String acl, String createMode) {
+        if (!ZKAuditLogger.isAuditEnabled()) {
+            return;
+        }
+        ZKAuditLogger
+            .logFailure(request.getUsers(), op, path, acl, createMode, cnxn.getSessionIdHex(),
+                cnxn.getHostAddress());
+    }
+
+    private void addAuditLog(Request request, ServerCnxn cnxn, String op, String path, String acl,
+        String createMode, Code err) {
+        if (!ZKAuditLogger.isAuditEnabled()) {
+            return;
+        }
+        if (err == Code.OK) {
+            ZKAuditLogger
+                .logSuccess(request.getUsers(), op, path, acl, createMode, cnxn.getSessionIdHex(),
+                    cnxn.getHostAddress());
+        } else {
+            ZKAuditLogger
+                .logFailure(request.getUsers(), op, path, acl, createMode, cnxn.getSessionIdHex(),
+                    cnxn.getHostAddress());
+        }
+    }
+
+    private String getACLs(Request request) {
+        ByteBuffer reqData = request.request.duplicate();","[{'comment': ""what about 'slice'?"", 'commenter': 'eolivelli'}, {'comment': 'good point, done', 'commenter': 'arshadmohammad'}]"
1105,zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -514,4 +555,157 @@ public void shutdown() {
         LOG.info(""shutdown of request processor complete"");
     }
 
+    private void addSuccessAudit(Request request, ServerCnxn cnxn, String op, String path) {
+        addSuccessAudit(request, cnxn, op, path, null, null);
+    }
+
+    private void addSuccessAudit(Request request, ServerCnxn cnxn, String op, String path,
+        String acl, String createMode) {
+        if (!ZKAuditLogger.isAuditEnabled()) {
+            return;
+        }
+        ZKAuditLogger
+            .logSuccess(request.getUsers(), op, path, acl, createMode, cnxn.getSessionIdHex(),
+                cnxn.getHostAddress());
+    }
+
+    private void addFailureAudit(Request request, ServerCnxn cnxn, String op, String path) {
+        addFailureAudit(request, cnxn, op, path, null, null);
+    }
+
+    private void addFailureAudit(Request request, ServerCnxn cnxn, String op, String path,
+        String acl, String createMode) {
+        if (!ZKAuditLogger.isAuditEnabled()) {
+            return;
+        }
+        ZKAuditLogger
+            .logFailure(request.getUsers(), op, path, acl, createMode, cnxn.getSessionIdHex(),
+                cnxn.getHostAddress());
+    }
+
+    private void addAuditLog(Request request, ServerCnxn cnxn, String op, String path, String acl,
+        String createMode, Code err) {
+        if (!ZKAuditLogger.isAuditEnabled()) {
+            return;
+        }
+        if (err == Code.OK) {
+            ZKAuditLogger
+                .logSuccess(request.getUsers(), op, path, acl, createMode, cnxn.getSessionIdHex(),
+                    cnxn.getHostAddress());
+        } else {
+            ZKAuditLogger
+                .logFailure(request.getUsers(), op, path, acl, createMode, cnxn.getSessionIdHex(),
+                    cnxn.getHostAddress());
+        }
+    }
+
+    private String getACLs(Request request) {
+        ByteBuffer reqData = request.request.duplicate();
+        reqData.rewind();
+        SetACLRequest setACLRequest = new SetACLRequest();
+        try {
+            ByteBufferInputStream.byteBuffer2Record(reqData, setACLRequest);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return ZKUtil.aclToString(setACLRequest.getAcl());
+    }
+
+    private void addFailedTxnAuditLog(Request request) {
+        if (!ZKAuditLogger.isAuditEnabled()) {
+            return;
+        }
+        String op = AuditConstants.OP_CREATE;
+        String path = null;
+        long sessionId = -1;
+        String address = null;
+        String acls = null;
+        String createMode = null;
+        ByteBuffer reqData = request.request.duplicate();","[{'comment': 'Slice?', 'commenter': 'eolivelli'}, {'comment': 'done', 'commenter': 'arshadmohammad'}]"
1105,zookeeper-server/src/test/java/org/apache/zookeeper/audit/AuditLogPerfReading.java,"@@ -0,0 +1,74 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+/**
+ * Audit log performance reading
+ */
+public class AuditLogPerfReading {","[{'comment': 'final?', 'commenter': 'eolivelli'}, {'comment': 'done', 'commenter': 'arshadmohammad'}]"
1105,zookeeper-server/src/test/java/org/apache/zookeeper/audit/ZKAuditLoggerPerformance.java,"@@ -0,0 +1,151 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+import java.io.IOException;
+import java.util.concurrent.TimeoutException;
+
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.common.Time;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.test.ClientBase.CountdownWatcher;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ZKAuditLoggerPerformance {
+    private static final Logger LOG = LoggerFactory
+            .getLogger(ZKAuditLoggerPerformance.class);
+    private ZooKeeper zkClient;
+    private String parentPath;
+    private int numberOfRecords;
+
+    public ZKAuditLoggerPerformance(ZooKeeper zkClient, String parentPath,
+            int numberOfRecords) {
+        this.zkClient = zkClient;
+        this.parentPath = parentPath;
+        this.numberOfRecords = numberOfRecords;
+    }
+
+    public void create() throws Exception {
+        for (int i = 0; i < numberOfRecords; i++) {
+            zkClient.create(getPath(i), ""0123456789"".getBytes(),
+                    Ids.OPEN_ACL_UNSAFE,
+                    CreateMode.PERSISTENT);
+
+        }
+    }
+
+    public void setData() throws Exception {
+        for (int i = 0; i < numberOfRecords; i++) {
+            zkClient.setData(getPath(i), ""9876543210"".getBytes(), -1);
+        }
+    }
+
+    public void delete() throws Exception {
+        for (int i = 0; i < numberOfRecords; i++) {
+            zkClient.delete(getPath(i), -1);
+        }
+    }
+
+    public AuditLogPerfReading doOperations() throws Exception {
+        AuditLogPerfReading perfReading = new AuditLogPerfReading();
+        // create
+        long startTime = Time.currentElapsedTime();
+        create();
+        perfReading.setCreate(Time.currentElapsedTime() - startTime);
+
+        // setData
+        startTime = Time.currentElapsedTime();
+        setData();
+        perfReading.setSetData(Time.currentElapsedTime() - startTime);
+
+        // delete
+        startTime = Time.currentElapsedTime();
+        delete();
+        perfReading.setDelete(Time.currentElapsedTime() - startTime);
+        return perfReading;
+    }
+
+    private String getPath(int i) {
+        return parentPath + ""zNode"" + i;
+    }
+
+    public static void main(String[] args) {","[{'comment': 'Is this program really needed? Or is it just a tool you used to profile this new code?', 'commenter': 'eolivelli'}, {'comment': 'This program was just to see the performance impact of audit log. I added here so anybody can run and see the audit log impact on their environment. Also it is added test folder.', 'commenter': 'arshadmohammad'}]"
1106,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -1028,14 +1019,21 @@ void primeConnection() throws IOException {
                             } else if (childWatchesIter.hasNext()) {
                                 watch = childWatchesIter.next();
                                 childWatchesBatch.add(watch);
+                            }  else if (persistentWatchesIter.hasNext()) {
+                                watch = persistentWatchesIter.next();
+                                persistentWatchesBatch.add(watch);
+                            } else if (persistentRecursiveWatchesIter.hasNext()) {
+                                watch = persistentRecursiveWatchesIter.next();
+                                persistentRecursiveWatchesBatch.add(watch);
                             } else {
                                 break;
                             }
                             batchLength += watch.length();
                         }
 
-                        SetWatches sw = new SetWatches(setWatchesLastZxid, dataWatchesBatch, existWatchesBatch, childWatchesBatch);
-                        RequestHeader header = new RequestHeader(-8, OpCode.setWatches);
+                        SetWatches2 sw = new SetWatches2(setWatchesLastZxid, dataWatchesBatch, existWatchesBatch,","[{'comment': 'How to deal with old servers? Should we have a configuration flag?', 'commenter': 'eolivelli'}, {'comment': ""Hmm - good point. I'll add that. Are there other examples of this?"", 'commenter': 'Randgalt'}, {'comment': ""It's only an issue for the client, so maybe add a method to `ZooKeeper()`, something like `oldServerMode()` (name TBD) that causes SetWatches to be used instead of SetWatches2."", 'commenter': 'Randgalt'}, {'comment': 'I think it is better to use the new message type when it is required, that is when you have at least one persistent watch', 'commenter': 'eolivelli'}, {'comment': ""That's a good solution. I've just pushed this change."", 'commenter': 'Randgalt'}]"
1106,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -53,36 +53,10 @@
 import org.apache.zookeeper.common.PathUtils;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
-import org.apache.zookeeper.proto.CheckWatchesRequest;
-import org.apache.zookeeper.proto.Create2Response;
-import org.apache.zookeeper.proto.CreateRequest;
-import org.apache.zookeeper.proto.CreateResponse;
-import org.apache.zookeeper.proto.CreateTTLRequest;
-import org.apache.zookeeper.proto.DeleteRequest;
-import org.apache.zookeeper.proto.ExistsRequest;
-import org.apache.zookeeper.proto.GetACLRequest;
-import org.apache.zookeeper.proto.GetACLResponse;
-import org.apache.zookeeper.proto.GetAllChildrenNumberRequest;
-import org.apache.zookeeper.proto.GetAllChildrenNumberResponse;
-import org.apache.zookeeper.proto.GetChildren2Request;
-import org.apache.zookeeper.proto.GetChildren2Response;
-import org.apache.zookeeper.proto.GetChildrenRequest;
-import org.apache.zookeeper.proto.GetChildrenResponse;
-import org.apache.zookeeper.proto.GetDataRequest;
-import org.apache.zookeeper.proto.GetDataResponse;
-import org.apache.zookeeper.proto.GetEphemeralsRequest;
-import org.apache.zookeeper.proto.GetEphemeralsResponse;
-import org.apache.zookeeper.proto.RemoveWatchesRequest;
-import org.apache.zookeeper.proto.ReplyHeader;
-import org.apache.zookeeper.proto.RequestHeader;
-import org.apache.zookeeper.proto.SetACLRequest;
-import org.apache.zookeeper.proto.SetACLResponse;
-import org.apache.zookeeper.proto.SetDataRequest;
-import org.apache.zookeeper.proto.SetDataResponse;
-import org.apache.zookeeper.proto.SyncRequest;
-import org.apache.zookeeper.proto.SyncResponse;
+import org.apache.zookeeper.proto.*;","[{'comment': 'You will see checkstyle erros, please do not use star import', 'commenter': 'eolivelli'}]"
1106,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -3028,6 +3112,77 @@ public void removeAllWatches(String path, WatcherType watcherType, boolean local
         removeWatches(ZooDefs.OpCode.removeWatches, path, null, watcherType, local, cb, ctx);
     }
 
+    /**
+     * <p>
+     * Set a watcher on the given path that: a) does not get removed when triggered (i.e. it stays active
+     * until it is removed); b) optionally applies not only to the registered path but all child paths recursively. This watcher
+     * is triggered for both data and child events. To remove the watcher, use
+     * <tt>removeWatches()</tt> with <tt>WatcherType.Any</tt>
+     * </p>
+     *
+     * <p>
+     * If <tt>recursive</tt> is <tt>false</tt>, the watcher behaves as if you placed an exists() watch and
+     * a getData() watch on the ZNode at the given path.
+     * </p>
+     *
+     * <p>
+     * If <tt>recursive</tt> is <tt>true</tt>, the watcher behaves as if you placed an exists() watch and
+     * a getData() watch on the ZNode at the given path <strong>and</strong> any ZNodes that are children
+     * of the given path including children added later.
+     * </p>
+     *
+     * <p>
+     * NOTE: when there are active recursive watches there is a small performance decrease as all segments
+     * of ZNode paths must be checked for watch triggering.
+     * </p>
+     *
+     * @param basePath the top path that the watcher applies to
+     * @param watcher the watcher
+     * @param recursive if true applies not only to the registered path but all child paths recursively including
+     *                  any child nodes added in the future
+     * @throws InterruptedException If the server transaction is interrupted.
+     * @throws KeeperException If the server signals an error with a non-zero
+     *  error code.
+     */
+    public void addPersistentWatch(String basePath, Watcher watcher, boolean recursive)","[{'comment': ""What about using an enum instead of a boolean for 'recursive'?"", 'commenter': 'eolivelli'}, {'comment': 'Do you anticipate more types? It would be easy to do.', 'commenter': 'Randgalt'}, {'comment': ""Yes.\r\nWe could also call the method 'addWatch' and have enum values like PERSISTENT_RECURSIVE and PERSISTENT_RECURSIVE\r\n\r\nOr even better we can use EnumSet and two flags PERSISTENT,RECURSIVE\r\n\r\naddWatch(...., EnumSet.of(PERSISTENT,RECURSIVE))"", 'commenter': 'eolivelli'}, {'comment': ""The problem with an EnumSet (or a var args) is that it would allow empty sets/arrays which is illegal. I'd rather have a single enum argument."", 'commenter': 'Randgalt'}, {'comment': 'So, I propose adding:\r\n\r\n```java\r\npublic enum PersistentWatchMode {\r\n    NON_RECURSIVE,\r\n    RECURSIVE\r\n}\r\n```\r\n\r\nAnd changing the APIs to take this instead of the `boolean`. OK?', 'commenter': 'Randgalt'}, {'comment': '+1 from me on PersistentWatchMode', 'commenter': 'eolivelli'}, {'comment': 'Hmm - I wonder now if we should rename the method to something more generic like `addWatch(...)` and make the enum `AddWatchMode`. This way we have more flexibility in the future. Thoughts?', 'commenter': 'Randgalt'}, {'comment': ""That's what I suggest above :-) "", 'commenter': 'eolivelli'}, {'comment': 'Doh :D 🤣 ', 'commenter': 'Randgalt'}, {'comment': ""Note: this is actually a pretty big change. I'm going to flow the watch mode through the server and not just make this a client change."", 'commenter': 'Randgalt'}, {'comment': 'we should narrow down the patch to the minimum needed, otherwise it will be hard to merge it soon.\r\nif we have more complex plan for the future and change deeply protocols and server side flows we should discuss on the ML more.\r\n', 'commenter': 'eolivelli'}, {'comment': ""So, you're suggesting a client only change? i.e. this enum is merely to avoid using a boolean in the public API?"", 'commenter': 'Randgalt'}, {'comment': 'yes\r\nYou already did a great work and the client with your changes is  still compatibile at 100% with 3.5 servers in case of not using persistent watches.\r\nIf we change the protocol regarding watches (adding some watchtype to the wireprotocol) you will really need a ""compatibility flag"" on the client configuration or some more complicated handshake with version/feature discovery.\r\n', 'commenter': 'eolivelli'}, {'comment': 'Look at the commit I just pushed. This is merely a refinement. I think this is much better actually and we\'ll thank ourselves in the future. Now, things are more generic ""add watch with a mode"". The mode is currently only persistent or recursive but we now have room to change in the future. The number/scope of the change is exactly the same as before.', 'commenter': 'Randgalt'}]"
1106,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -3028,6 +3147,104 @@ public void removeAllWatches(String path, WatcherType watcherType, boolean local
         removeWatches(ZooDefs.OpCode.removeWatches, path, null, watcherType, local, cb, ctx);
     }
 
+    /**
+     * Modes available to {@link ZooKeeper#addWatch(String, Watcher, AddWatchMode)}
+     */
+    public enum AddWatchMode {","[{'comment': 'What about moving this enum  to the top level (not an inner class) ?', 'commenter': 'eolivelli'}, {'comment': 'Makes no different to me. You prefer top level?', 'commenter': 'Randgalt'}, {'comment': 'yes, this way if will be less tied to the ZooKeeper class, not a big deal.', 'commenter': 'eolivelli'}, {'comment': 'done', 'commenter': 'Randgalt'}]"
1106,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -3028,6 +3147,104 @@ public void removeAllWatches(String path, WatcherType watcherType, boolean local
         removeWatches(ZooDefs.OpCode.removeWatches, path, null, watcherType, local, cb, ctx);
     }
 
+    /**
+     * Modes available to {@link ZooKeeper#addWatch(String, Watcher, AddWatchMode)}
+     */
+    public enum AddWatchMode {
+        /**
+         * <p>
+         * Set a watcher on the given path that does not get removed when triggered (i.e. it stays active
+         * until it is removed). This watcher
+         * is triggered for both data and child events. To remove the watcher, use
+         * <tt>removeWatches()</tt> with <tt>WatcherType.Any</tt>. The watcher behaves as if you placed an exists() watch and
+         * a getData() watch on the ZNode at the given path.
+         * </p>
+         */
+        PERSISTENT(ZooDefs.AddWatchModes.persistent),
+
+        /**
+         * <p>
+         * Set a watcher on the given path that: a) does not get removed when triggered (i.e. it stays active
+         * until it is removed); b) applies not only to the registered path but all child paths recursively. This watcher
+         * is triggered for both data and child events. To remove the watcher, use
+         * <tt>removeWatches()</tt> with <tt>WatcherType.Any</tt>
+         * </p>
+         *
+         * <p>
+         * The watcher behaves as if you placed an exists() watch and
+         * a getData() watch on the ZNode at the given path <strong>and</strong> any ZNodes that are children
+         * of the given path including children added later.
+         * </p>
+         *
+         * <p>
+         * NOTE: when there are active recursive watches there is a small performance decrease as all segments
+         * of ZNode paths must be checked for watch triggering.
+         * </p>
+         */
+        PERSISTENT_RECURSIVE(ZooDefs.AddWatchModes.persistentRecursive)
+        ;
+
+        public int getMode() {
+            return mode;
+        }
+
+        private final int mode;
+
+        AddWatchMode(int mode) {
+            this.mode = mode;
+        }
+    }
+
+    /**
+     * Add a watch to the given znode using the given mode. Note: not all
+     * watch types can be set with this method. Only the modes available
+     * in {@link AddWatchMode} can be set with this method.
+     *
+     * @param basePath the path that the watcher applies to
+     * @param watcher the watcher
+     * @param mode type of watcher to add
+     * @throws InterruptedException If the server transaction is interrupted.
+     * @throws KeeperException If the server signals an error with a non-zero
+     *  error code.
+     */
+    public void addWatch(String basePath, Watcher watcher, AddWatchMode mode)","[{'comment': '@Randgalt  this is perfect to me !', 'commenter': 'eolivelli'}]"
1106,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -267,6 +282,8 @@ public ZKClientConfig getClientConfig() {
         private final Map<String, Set<Watcher>> dataWatches = new HashMap<String, Set<Watcher>>();
         private final Map<String, Set<Watcher>> existWatches = new HashMap<String, Set<Watcher>>();
         private final Map<String, Set<Watcher>> childWatches = new HashMap<String, Set<Watcher>>();
+        private final Map<String, Set<Watcher>> persistentWatches = new HashMap<String, Set<Watcher>>();","[{'comment': 'Why not using `ConcurrentHashMap` instead of synchronizing everywhere?', 'commenter': 'anmolnar'}, {'comment': 'I agree - but it should probably be a separate tech-debt ticket.', 'commenter': 'Randgalt'}]"
1106,zookeeper-server/src/main/java/org/apache/zookeeper/server/watch/IWatchManager.java,"@@ -34,6 +34,22 @@
      */
     boolean addWatch(String path, Watcher watcher);
 
+    /**
+     * Add watch to specific path.
+     *
+     * @param path znode path
+     * @param watcher watcher object reference
+     * @param watcherMode the watcher mode to use
+     *
+     * @return true if the watcher added is not already present
+     */
+    default boolean addWatch(String path, Watcher watcher, WatcherMode watcherMode) {
+        if (watcherMode == WatcherMode.DEFAULT_WATCHER_MODE) {
+            return addWatch(path, watcher);
+        }
+        throw new UnsupportedOperationException();  // custom implementations must defeat this","[{'comment': 'This path will be followed with OptimizedWatchManager.\r\nHow will it bubble up to the client?\r\n\r\nI see two ways:\r\n- implement the method everywhere (it will have a cost!) \r\n- add a test case about the behaviour of a client that it is trying to use this feature with a server that does not support it because it has not the default WatchManager impl\r\n\r\nThoughts?', 'commenter': 'eolivelli'}, {'comment': '@eolivelli test added. See: https://github.com/Randgalt/zookeeper/blob/ZOOKEEPER-1416/zookeeper-server/src/test/java/org/apache/zookeeper/test/UnsupportedAddWatcherTest.java', 'commenter': 'Randgalt'}]"
1106,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -373,6 +405,18 @@ void containsWatcher(String path, Watcher watcher, WatcherType watcherType) thro
                 synchronized (childWatches) {
                     containsWatcher = contains(path, watcher, childWatches);
                 }
+
+                synchronized (persistentWatches) {
+                    boolean contains_temp = contains(path, watcher,
+                            persistentWatches);","[{'comment': '`isContained` is better?', 'commenter': 'maoling'}]"
1115,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Learner.java,"@@ -705,12 +712,28 @@ boolean isRunning() {
     }
 
     void closeSocket() {
-        try {
-            if (sock != null) {
+        if (closeSocketAsync) {
+            new Thread(new Runnable() {","[{'comment': 'What about giving a meaningful name to the thread and making it a daemon thread?', 'commenter': 'eolivelli'}, {'comment': 'done!', 'commenter': 'jhuan31'}]"
1115,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Learner.java,"@@ -75,6 +77,7 @@
     protected BufferedOutputStream bufferedOutput;
 
     protected Socket sock;
+    protected boolean sockBeingClosed = false;","[{'comment': ""This variable should be volatile as it is accessed from multiple threads.\r\nI think that AtomicBoolean would be better.\r\nSo you can enter the real 'close' only once.\r\nIf (sockBeingClosed.compareAndSet(false,true))...sock.close()"", 'commenter': 'eolivelli'}, {'comment': 'I see it is accessed only from the QuorumPeer thread. Do I miss anything?', 'commenter': 'jhuan31'}, {'comment': 'Yes, I did miss something. Changed to use AtomicBoolean.', 'commenter': 'jhuan31'}]"
1115,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Learner.java,"@@ -103,9 +106,12 @@ public Socket getSocket() {
 
     private static final boolean nodelay = System.getProperty(""follower.nodelay"", ""true"").equals(""true"");
 
+    public static final String LEARNER_CLOSE_SOCKET_ASYNC = ""learner.closeSocketAsync"";
+    public static final boolean closeSocketAsync = Boolean.getBoolean(LEARNER_CLOSE_SOCKET_ASYNC);
     static {
         LOG.info(""leaderConnectDelayDuringRetryMs: {}"", leaderConnectDelayDuringRetryMs);
         LOG.info(""TCP NoDelay set to: {}"", nodelay);
+        LOG.info(""[] = {}"", LEARNER_CLOSE_SOCKET_ASYNC, closeSocketAsync);","[{'comment': 'Typo []--> {}', 'commenter': 'eolivelli'}, {'comment': 'blushing...', 'commenter': 'jhuan31'}]"
1115,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Learner.java,"@@ -780,12 +787,25 @@ boolean isRunning() {
     }
 
     void closeSocket() {
-        try {
-            if (sock != null) {
+        if (closeSocketAsync) {
+            final Thread closingThread = new Thread(() -> closeSock(), ""CloseSocketThread(sid:"" + zk.getServerId());
+            closingThread.setDaemon(true);
+            closingThread.start();
+        } else {
+            closeSock();
+        }
+    }
+
+    void closeSock() {","[{'comment': 'Maybe change the method name to closeSocketSync will reduce the confusion.', 'commenter': 'lvfangmin'}]"
1115,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Learner.java,"@@ -86,6 +89,7 @@
 
     protected Socket sock;
     protected MultipleAddresses leaderAddr;
+    protected AtomicBoolean sockBeingClosed = new AtomicBoolean(false);","[{'comment': 'I think `socketClosed` would be a better name for this variable, because it\'s not only guarding the ""closing"" method.', 'commenter': 'anmolnar'}, {'comment': 'It is ONLY guarding the closing method. When it is set, the socket might not be closed for a long time, e.g. 30 seconds. But I don\'t want to name it ""socketClosed"" because it doesn\'t mean the socket is closed. Thoughts?', 'commenter': 'jhuan31'}]"
1115,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Learner.java,"@@ -792,10 +800,24 @@ boolean isRunning() {
     }
 
     void closeSocket() {
-        try {
-            if (sock != null) {
-                sock.close();
+        if (sock != null) {
+            if (sockBeingClosed.compareAndSet(false, true)) {
+                if (closeSocketAsync) {
+                    final Thread closingThread = new Thread(() -> closeSockSync(), ""CloseSocketThread(sid:"" + zk.getServerId());
+                    closingThread.setDaemon(true);
+                    closingThread.start();
+                } else {
+                    closeSockSync();
+                }
             }
+        }
+    }
+
+    void closeSockSync() {
+        try {
+            long startTime = Time.currentElapsedTime();
+            sock.close();","[{'comment': 'You might want to add 2 more things here:\r\n- double check if sock is still not `null`\r\n- make sock = null after the close to prevent further usage of the object and let GC collect it', 'commenter': 'anmolnar'}, {'comment': 'done.', 'commenter': 'jhuan31'}]"
1115,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Learner.java,"@@ -116,10 +120,14 @@ public Socket getSocket() {
 
     public static final String LEARNER_ASYNC_SENDING = ""learner.asyncSending"";
     private static boolean asyncSending = Boolean.getBoolean(LEARNER_ASYNC_SENDING);
+    public static final String LEARNER_CLOSE_SOCKET_ASYNC = ""learner.closeSocketAsync"";
+    public static final boolean closeSocketAsync = Boolean.getBoolean(LEARNER_CLOSE_SOCKET_ASYNC);","[{'comment': ""Not trying to block this PR, and things can be improved later, but:\r\n\r\nI see that such properties, including `learner.asyncSending` above it, are not documented.  Is there a specific policy regarding which properties are to be mentioned in `zookeeperAdmin.md`?  I am wondering how one can learn about all these knobs, and their raison d'être?  (I know the corresponding ticket ID can be found via Git, but that incurs some overhead.)"", 'commenter': 'ztzg'}, {'comment': 'Thanks for your comments. I will add the flag to zookeeperAdmin. As for test, I find it is hard to construct a unit test for this. But this feature has been enabled in our production for months. ', 'commenter': 'jhuan31'}, {'comment': '@jhuan31: By ""untested,"" I meant: I have looked into the code, but *I* haven\'t tested it :)  I understand that it is not always easy to create meaningful tests for socket behavior.  Thank you for taking care of the documentation.', 'commenter': 'ztzg'}]"
1116,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/LearnerMetricsTest.java,"@@ -32,16 +34,30 @@
 import org.hamcrest.Matcher;
 import org.junit.After;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
+@RunWith(Parameterized.class)
 public class LearnerMetricsTest extends QuorumPeerTestBase {
 
     private static final int TIMEOUT_SECONDS = 30;
     private static final int SERVER_COUNT = 4; // 1 observer, 3 participants
     private final QuorumPeerTestBase.MainThread[] mt = new QuorumPeerTestBase.MainThread[SERVER_COUNT];
     private ZooKeeper zk_client;
+    private boolean asyncSending;
+
+    public LearnerMetricsTest(boolean asyncSending) {
+        this.asyncSending = asyncSending;
+    }
+
+    @Parameterized.Parameters
+    public static Collection sendingModes() {
+        return Arrays.asList(new Object[][]{{true}, {false}});
+    }
 
     @Test
     public void testLearnerMetricsTest() throws Exception {
+        Learner.setAsyncSending(asyncSending);","[{'comment': 'please reset the value in a @Before method\r\nit is a static flag, so it will affect other tests', 'commenter': 'eolivelli'}, {'comment': 'I assume you mean ""reset in @after?""', 'commenter': 'jhuan31'}]"
1116,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/ReconfigDuringLeaderSyncTest.java,"@@ -40,18 +42,33 @@
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+@RunWith(Parameterized.class)
 public class ReconfigDuringLeaderSyncTest extends QuorumPeerTestBase {
 
     protected static final Logger LOG = LoggerFactory.getLogger(ReconfigDuringLeaderSyncTest.class);
     private static int SERVER_COUNT = 3;
     private MainThread[] mt;
 
+    private boolean asyncSending;
+
+    public ReconfigDuringLeaderSyncTest(boolean asyncSending) {
+        this.asyncSending = asyncSending;
+    }
+
+    @Parameterized.Parameters
+    public static Collection sendingModes() {
+        return Arrays.asList(new Object[][]{{true}, {false}});
+    }
+
     @Before
     public void setup() {
         System.setProperty(""zookeeper.DigestAuthenticationProvider.superDigest"", ""super:D/InIHSb7yEEbrWz8b9l71RjZJU=""/* password is 'test'*/);
+        Learner.setAsyncSending(asyncSending);","[{'comment': 'please reset the value in a @before method\r\nit is a static flag, so it will affect other tests', 'commenter': 'eolivelli'}, {'comment': 'reset in @AfterClass', 'commenter': 'jhuan31'}]"
1116,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Learner.java,"@@ -149,6 +159,14 @@ void validateSession(ServerCnxn cnxn, long clientId, int timeout) throws IOExcep
      * @throws IOException
      */
     void writePacket(QuorumPacket pp, boolean flush) throws IOException {
+        if (asyncSending) {
+            sender.queuePacket(pp);","[{'comment': ""what about this 'flush' parameter ?\r\n"", 'commenter': 'eolivelli'}, {'comment': 'If packet are sent asynchronously, flush is no use. If async sending is turned off, then flush is passed on to writePacketNow() and will cause the output buffer flushed. ', 'commenter': 'jhuan31'}]"
1116,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerSender.java,"@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.io.IOException;
+import java.util.concurrent.LinkedBlockingQueue;
+import org.apache.zookeeper.server.ZooKeeperCriticalThread;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class LearnerSender extends ZooKeeperCriticalThread {
+    private static final Logger LOG = LoggerFactory.getLogger(LearnerSender.class);
+
+    private final LinkedBlockingQueue<QuorumPacket> queuedPackets = new LinkedBlockingQueue<>();
+    private final QuorumPacket proposalOfDeath = new QuorumPacket();
+
+    Learner learner;
+
+    public LearnerSender(Learner learner) {
+        super(""LearnerSender:"" + learner.zk.getServerId(), learner.zk.getZooKeeperServerListener());
+        this.learner = learner;
+    }
+
+    @Override
+    public void run() {
+        while (true) {
+            try {
+                QuorumPacket p = queuedPackets.poll();
+                if (p == null) {
+                    learner.bufferedOutput.flush();
+                    p = queuedPackets.take();
+                }
+
+                if (p == proposalOfDeath) {
+                    // Packet of death!
+                    break;
+                }
+
+                learner.messageTracker.trackSent(p.getType());","[{'comment': 'here https://github.com/apache/zookeeper/pull/1116/files#diff-c8b414c1ca2084ecb9fe32a0a3832d44R170\r\nwe accessing learner internal variables inside a synchronized block.\r\nit looks like an inconsistent synchronization\r\n\r\nmaybe it depends on the fact that this feature is enabled or not, but I am not sure we are 100% safe\r\ncan you please motivate or at least leave some comment for future inspection and understanding of the flow ?', 'commenter': 'eolivelli'}, {'comment': ""Without LearnerSender, there might be more than one thread writing to leaderOs so synchronization is required. \r\n\r\nWith LearnerSender, there still might be more than one thread calling writePacket but they are writing to a BlockingQueue so it's fine. Reading from the queue and writing to leaderOs is one thread (the learner sender thread), so we don't need synchronization.  It's like we synchronize on the blockingQueue implicitly. \r\n\r\nThis is tricky. I may have missed some thing. Let me know and I'll fix the code."", 'commenter': 'jhuan31'}, {'comment': 'Can you add a minimal comment to explain this point?\r\nI agree with your explanation', 'commenter': 'eolivelli'}, {'comment': 'This looks good to me, it might be better to not visit the internal variable directly, but using things like get to make the code easier to manage and reason about though.', 'commenter': 'lvfangmin'}]"
1116,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Learner.java,"@@ -693,6 +726,11 @@ public void shutdown() {
         self.setZooKeeperServer(null);
         self.closeAllConnections();
         self.adminServer.setZooKeeperServer(null);
+
+       if (sender != null) {","[{'comment': 'nit: diff shows a missing space', 'commenter': 'eolivelli'}, {'comment': 'good catch', 'commenter': 'jhuan31'}]"
1120,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -3398,6 +3403,26 @@ private ClientCnxnSocket getClientCnxnSocket() throws IOException {
         }
     }
 
+    /**
+     * Return the default watcher of this instance if requested.
+     *
+     * @param requested if the default watcher requested
+     * @return the default watcher if request, otherwise {@code null}.
+     * @throws IllegalStateException if a null default watcher is requested
+     */
+    @Nullable
+    private Watcher requestDefaultWatcher(boolean requested) {","[{'comment': ""I would name this method\r\ngetDefaultWatcher\r\nand the parameter 'required'"", 'commenter': 'eolivelli'}, {'comment': 'Done.', 'commenter': 'tisonkun'}]"
1120,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -3398,6 +3403,26 @@ private ClientCnxnSocket getClientCnxnSocket() throws IOException {
         }
     }
 
+    /**
+     * Return the default watcher of this instance if requested.
+     *
+     * @param requested if the default watcher requested
+     * @return the default watcher if request, otherwise {@code null}.
+     * @throws IllegalStateException if a null default watcher is requested
+     */
+    @Nullable","[{'comment': 'I am not sure about this.\r\nAre we using it in ZK?', 'commenter': 'eolivelli'}, {'comment': ""I do a global check and find there isn't anywhere else using it. Possibly annotate `@Nullable` is a good idea which helps notify users taking care of nullable value but let's discuss in another thread.\r\n\r\nIn short, reverted."", 'commenter': 'tisonkun'}]"
1123,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java,"@@ -1080,4 +1080,8 @@ private boolean isRunning() {
     private boolean isParticipant(long sid) {
         return self.getVotingView().containsKey(sid);
     }
+
+    public void startSnapshot() {","[{'comment': ""I can't find this method in the original patch.\r\nIt seems that it is only logging a line.\r\nIs it needed?"", 'commenter': 'eolivelli'}, {'comment': 'Actually this method is added to make test can happen.\r\nThe issue occurrence must meet several conditions.\r\nOne import condition of them is that quorum must commit one proposal during the time window that is between the NEWLEADER package firing and the snapshot firing. To meet it, our test must find a hook to emit one data writing in the time window. \r\nIn 3.5, it invokes getLearnerSnapshotThrottler during the time window. So @lvfangmin original patch is override getLearnerSnapshotThrottler to make a hook to fire the data writing. \r\nIn 3.4, nothing is invoked during the time window. I have not any chance to make a hook. So I add startSnapshot method during the window and use it to make the fire data writing data hook.\r\n\r\n Maybe we can discuss it to make a better one. I have not found it yet.\r\n', 'commenter': 'yfxhust'}]"
1123,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/QuorumPeerMainTest.java,"@@ -62,10 +64,14 @@
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
 import org.apache.zookeeper.server.quorum.Leader.Proposal;
 import org.apache.zookeeper.server.util.ZxidUtils;
+import org.apache.zookeeper.server.SyncRequestProcessor;
 import org.apache.zookeeper.test.ClientBase;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Test;
+import org.junit.Ignore;","[{'comment': 'Can you please fix the order of imports?\r\nIn branch 3.4 we do not have checkstyle', 'commenter': 'eolivelli'}, {'comment': 'OK. I will run checkstyle for this commit. ', 'commenter': 'yfxhust'}]"
1133,zookeeper-server/src/main/java/org/apache/zookeeper/audit/AuditEvent.java,"@@ -0,0 +1,79 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Set;
+
+public class AuditEvent {","[{'comment': 'Nit: final', 'commenter': 'eolivelli'}, {'comment': 'added', 'commenter': 'arshadmohammad'}]"
1133,zookeeper-server/src/main/java/org/apache/zookeeper/audit/AuditLogger.java,"@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+public interface AuditLogger {","[{'comment': ""Do we need a 'close' or 'shutdown' method?"", 'commenter': 'eolivelli'}, {'comment': 'There is no need for life cycle management for these  loggers. so not required.', 'commenter': 'arshadmohammad'}]"
1133,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/AuthUtil.java,"@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server.util;
+
+import org.apache.zookeeper.data.Id;
+import org.apache.zookeeper.server.auth.AuthenticationProvider;
+import org.apache.zookeeper.server.auth.ProviderRegistry;
+
+public class AuthUtil {","[{'comment': 'final\r\nAnd please add a private default constructor', 'commenter': 'eolivelli'}, {'comment': 'added', 'commenter': 'arshadmohammad'}]"
1133,zookeeper-server/src/main/java/org/apache/zookeeper/audit/AuditEvent.java,"@@ -0,0 +1,79 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Set;
+
+public final class AuditEvent {
+    private static final char PAIR_SEPARATOR = '\t';
+    private static final String KEY_VAL_SEPARATOR = ""="";
+    // Holds the entries which to be logged.
+    private Map<String, String> logEntries = new LinkedHashMap<String, String>();
+
+    /**
+     * Gives all entries to be logged.
+     *
+     * @return log entries
+     */
+    public Set<Map.Entry<String, String>> getLogEntries() {","[{'comment': 'This getter is not used anywhere.', 'commenter': 'anmolnar'}, {'comment': 'AuditLogger implantation classes may need this to access all logging fields.', 'commenter': 'arshadmohammad'}]"
1133,zookeeper-server/src/main/java/org/apache/zookeeper/audit/AuditEvent.java,"@@ -0,0 +1,79 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Set;
+
+public final class AuditEvent {
+    private static final char PAIR_SEPARATOR = '\t';
+    private static final String KEY_VAL_SEPARATOR = ""="";
+    // Holds the entries which to be logged.
+    private Map<String, String> logEntries = new LinkedHashMap<String, String>();
+
+    /**
+     * Gives all entries to be logged.
+     *
+     * @return log entries
+     */
+    public Set<Map.Entry<String, String>> getLogEntries() {
+        return logEntries.entrySet();
+    }
+
+    public void addEntry(FieldName fieldName, String value) {","[{'comment': 'package-private ?', 'commenter': 'anmolnar'}, {'comment': 'changed', 'commenter': 'arshadmohammad'}]"
1133,zookeeper-server/src/main/java/org/apache/zookeeper/audit/Log4jAuditLogger.java,"@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Log4j based audit logger
+ */
+public class Log4jAuditLogger implements AuditLogger {
+    private static final Logger LOG = LoggerFactory.getLogger(Log4jAuditLogger.class);
+
+    @Override
+    public void logAuditEvent(AuditEvent auditEvent) {
+        if (AuditConstants.FAILURE.equals(auditEvent.getValue(AuditEvent.FieldName.RESULT))) {","[{'comment': 'If RESULT is a mandatory field of an `AuditEvent`, it should be a member field instead of adding it to the Map. In which case we could replace this part with a single field comparison.', 'commenter': 'anmolnar'}, {'comment': 'Additionally this is currently a string comparison every time an audit event occurs. I rather use a boolean value for success/failure instead to make it as fast as possible.', 'commenter': 'anmolnar'}, {'comment': 'Currently we have three possible values as result. Can not use Boolean. Extracted results to enum.\r\nAlso added a Result type field AuditEvent to address above concern.', 'commenter': 'arshadmohammad'}, {'comment': 'Awesome! Thank you.', 'commenter': 'anmolnar'}]"
1133,zookeeper-server/src/main/java/org/apache/zookeeper/audit/ZKAuditLogger.java,"@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+import static org.apache.zookeeper.audit.AuditEvent.FieldName;
+import java.lang.reflect.Constructor;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ZKAuditLogger {
+    public static final String SYSPROP_AUDIT_ENABLE = ""zookeeper.audit.enable"";
+    public static final String SYSPROP_AUDIT_LOGGER_IMPL = ""zookeeper.audit.impl.class"";","[{'comment': 'Both package-private ?', 'commenter': 'anmolnar'}, {'comment': 'changed', 'commenter': 'arshadmohammad'}]"
1133,zookeeper-server/src/main/java/org/apache/zookeeper/audit/ZKAuditLogger.java,"@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+import static org.apache.zookeeper.audit.AuditEvent.FieldName;
+import java.lang.reflect.Constructor;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ZKAuditLogger {
+    public static final String SYSPROP_AUDIT_ENABLE = ""zookeeper.audit.enable"";
+    public static final String SYSPROP_AUDIT_LOGGER_IMPL = ""zookeeper.audit.impl.class"";
+    private static final Logger LOG = LoggerFactory.getLogger(ZKAuditLogger.class);
+    // By default audit logging is disabled
+    private static boolean auditEnabled = Boolean.getBoolean(SYSPROP_AUDIT_ENABLE);
+    private static AuditLogger auditLogger;
+
+    static {
+        if (auditEnabled) {
+            //initialise only when audit logging is enabled
+            auditLogger = getAuditLogger();
+            LOG.info(""ZooKeeper audit is enabled."");
+        } else {
+            LOG.info(""ZooKeeper audit is disabled."");
+        }
+    }
+
+    private static AuditLogger getAuditLogger() {
+        String auditLoggerClass = System.getProperty(SYSPROP_AUDIT_LOGGER_IMPL);
+        if (auditLoggerClass == null) {
+            auditLoggerClass = Log4jAuditLogger.class.getName();
+        }
+        try {
+            Constructor<?> clientCxnConstructor = Class.forName(auditLoggerClass)
+                    .getDeclaredConstructor();
+            AuditLogger auditLogger = (AuditLogger) clientCxnConstructor.newInstance();
+            auditLogger.initialize();
+            return auditLogger;
+        } catch (Exception e) {
+            throw new RuntimeException(""Couldn't instantiate "" + auditLoggerClass, e);
+        }
+    }
+
+    /**
+     * @return true if audit log is enabled
+     */
+    public static boolean isAuditEnabled() {
+        return auditEnabled;
+    }
+
+    // @VisibleForTesting
+    public static void setAuditEnabled(boolean auditEnabled) {","[{'comment': 'Unused?', 'commenter': 'anmolnar'}, {'comment': 'Removed', 'commenter': 'arshadmohammad'}]"
1133,zookeeper-server/src/main/java/org/apache/zookeeper/audit/ZKAuditLogger.java,"@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+import static org.apache.zookeeper.audit.AuditEvent.FieldName;
+import java.lang.reflect.Constructor;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ZKAuditLogger {
+    public static final String SYSPROP_AUDIT_ENABLE = ""zookeeper.audit.enable"";
+    public static final String SYSPROP_AUDIT_LOGGER_IMPL = ""zookeeper.audit.impl.class"";
+    private static final Logger LOG = LoggerFactory.getLogger(ZKAuditLogger.class);
+    // By default audit logging is disabled
+    private static boolean auditEnabled = Boolean.getBoolean(SYSPROP_AUDIT_ENABLE);
+    private static AuditLogger auditLogger;
+
+    static {
+        if (auditEnabled) {
+            //initialise only when audit logging is enabled
+            auditLogger = getAuditLogger();
+            LOG.info(""ZooKeeper audit is enabled."");
+        } else {
+            LOG.info(""ZooKeeper audit is disabled."");
+        }
+    }
+
+    private static AuditLogger getAuditLogger() {
+        String auditLoggerClass = System.getProperty(SYSPROP_AUDIT_LOGGER_IMPL);
+        if (auditLoggerClass == null) {
+            auditLoggerClass = Log4jAuditLogger.class.getName();
+        }
+        try {
+            Constructor<?> clientCxnConstructor = Class.forName(auditLoggerClass)
+                    .getDeclaredConstructor();
+            AuditLogger auditLogger = (AuditLogger) clientCxnConstructor.newInstance();
+            auditLogger.initialize();
+            return auditLogger;
+        } catch (Exception e) {
+            throw new RuntimeException(""Couldn't instantiate "" + auditLoggerClass, e);
+        }
+    }
+
+    /**
+     * @return true if audit log is enabled
+     */
+    public static boolean isAuditEnabled() {
+        return auditEnabled;
+    }
+
+    // @VisibleForTesting
+    public static void setAuditEnabled(boolean auditEnabled) {
+        ZKAuditLogger.auditEnabled = auditEnabled;
+    }
+
+    public static void logSuccess(String user, String operation) {
+        log(user, operation, AuditConstants.SUCCESS);
+    }
+
+    public static void logInvoked(String user, String operation) {
+        log(user, operation, AuditConstants.INVOKED);","[{'comment': 'Both could be private.', 'commenter': 'anmolnar'}]"
1133,zookeeper-server/src/main/java/org/apache/zookeeper/audit/ZKAuditLogger.java,"@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+import static org.apache.zookeeper.audit.AuditEvent.FieldName;
+import java.lang.reflect.Constructor;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ZKAuditLogger {
+    public static final String SYSPROP_AUDIT_ENABLE = ""zookeeper.audit.enable"";
+    public static final String SYSPROP_AUDIT_LOGGER_IMPL = ""zookeeper.audit.impl.class"";
+    private static final Logger LOG = LoggerFactory.getLogger(ZKAuditLogger.class);
+    // By default audit logging is disabled
+    private static boolean auditEnabled = Boolean.getBoolean(SYSPROP_AUDIT_ENABLE);
+    private static AuditLogger auditLogger;
+
+    static {
+        if (auditEnabled) {
+            //initialise only when audit logging is enabled
+            auditLogger = getAuditLogger();
+            LOG.info(""ZooKeeper audit is enabled."");
+        } else {
+            LOG.info(""ZooKeeper audit is disabled."");
+        }
+    }
+
+    private static AuditLogger getAuditLogger() {
+        String auditLoggerClass = System.getProperty(SYSPROP_AUDIT_LOGGER_IMPL);
+        if (auditLoggerClass == null) {
+            auditLoggerClass = Log4jAuditLogger.class.getName();
+        }
+        try {
+            Constructor<?> clientCxnConstructor = Class.forName(auditLoggerClass)
+                    .getDeclaredConstructor();
+            AuditLogger auditLogger = (AuditLogger) clientCxnConstructor.newInstance();
+            auditLogger.initialize();
+            return auditLogger;
+        } catch (Exception e) {
+            throw new RuntimeException(""Couldn't instantiate "" + auditLoggerClass, e);
+        }
+    }
+
+    /**
+     * @return true if audit log is enabled
+     */
+    public static boolean isAuditEnabled() {
+        return auditEnabled;
+    }
+
+    // @VisibleForTesting
+    public static void setAuditEnabled(boolean auditEnabled) {
+        ZKAuditLogger.auditEnabled = auditEnabled;
+    }
+
+    public static void logSuccess(String user, String operation) {
+        log(user, operation, AuditConstants.SUCCESS);
+    }
+
+    public static void logInvoked(String user, String operation) {
+        log(user, operation, AuditConstants.INVOKED);
+    }
+
+    public static void logSuccess(String user, String operation, String znode, String acl,
+                                  String createMode, String session, String ip) {
+        log(user, operation, znode, acl, createMode, session, ip,
+                AuditConstants.SUCCESS);
+    }
+
+    public static void logFailure(String user, String operation, String znode, String acl,
+                                  String createMode, String session, String ip) {
+        log(user, operation, znode, acl, createMode, session, ip,
+                AuditConstants.FAILURE);
+    }
+
+    private static void log(String user, String operation, String result) {
+        auditLogger.logAuditEvent(createLogEvent(user, operation, result));
+    }
+
+    private static void log(String user, String operation, String znode, String acl,
+                            String createMode, String session, String ip, String result) {
+        auditLogger.logAuditEvent(createLogEvent(user, operation, znode, acl, createMode, session, ip, result));
+    }
+
+    /**
+     * A helper api for creating an AuditEvent object.
+     */
+    public static AuditEvent createLogEvent(String user, String operation, String result) {","[{'comment': 'Both methods could be package-private.', 'commenter': 'anmolnar'}, {'comment': 'changed', 'commenter': 'arshadmohammad'}]"
1133,zookeeper-server/src/main/java/org/apache/zookeeper/audit/ZKAuditLogger.java,"@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.audit;
+
+import static org.apache.zookeeper.audit.AuditEvent.FieldName;
+import java.lang.reflect.Constructor;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ZKAuditLogger {","[{'comment': ""I'd rename this to `ZKAuditLog` or something like that to distinguish from implementations of `AuditLogger`."", 'commenter': 'anmolnar'}, {'comment': 'Changed to ZKAuditProvider', 'commenter': 'arshadmohammad'}]"
1133,zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -280,6 +306,8 @@ public void processRequest(Request request) {
                 rsp = new CreateResponse(rc.path);
                 err = Code.get(rc.err);
                 requestPathMetricsCollector.registerRequest(request.type, rc.path);
+                String createMode = getCreateMode(request);","[{'comment': 'This `getCreateMode()` is quite expensive. It should be moved inside the if which checks whether audit logging is enabled. You might want to just pass the request object to `addAuditLog()` and extract in there if necessary.\r\n\r\nAdditionally we might not need AuditConstant for every single operation, but use OpCode directly. In which case audit logging could be called at one place instead of every case branch.', 'commenter': 'anmolnar'}, {'comment': 'Refactored complete code and this is addressed in code refactoring.', 'commenter': 'arshadmohammad'}]"
1133,zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -311,13 +343,19 @@ public void processRequest(Request request) {
                     ((QuorumZooKeeperServer) zks).self.getQuorumVerifier().toString().getBytes(),
                     rc.stat);
                 err = Code.get(rc.err);
+                addAuditLog(request, cnxn, AuditConstants.OP_RECONFIG, rc.path, null, null, err);
                 break;
             }
             case OpCode.setACL: {
                 lastOp = ""SETA"";
                 rsp = new SetACLResponse(rc.stat);
                 err = Code.get(rc.err);
                 requestPathMetricsCollector.registerRequest(request.type, rc.path);
+                /** Here audit enable check is done to avoid getACLs() call in case audit is disabled. */
+                if (ZKAuditLogger.isAuditEnabled()) {","[{'comment': 'Similarly pass the `request` object to `addAuditLog()` and extract the required information inside the `if`.', 'commenter': 'anmolnar'}, {'comment': 'Refactored complete code and this is addressed in code refactoring.', 'commenter': 'arshadmohammad'}]"
1133,zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -624,4 +662,157 @@ private void updateStats(Request request, String lastOp, long lastZxid) {
         request.cnxn.updateStatsForResponse(request.cxid, lastZxid, lastOp, request.createTime, currentTime);
     }
 
+    private void addSuccessAudit(Request request, ServerCnxn cnxn, String op, String path) {
+        addSuccessAudit(request, cnxn, op, path, null, null);
+    }
+
+    private void addSuccessAudit(Request request, ServerCnxn cnxn, String op, String path,
+                                 String acl, String createMode) {
+        if (!ZKAuditLogger.isAuditEnabled()) {
+            return;
+        }
+        ZKAuditLogger
+                .logSuccess(request.getUsers(), op, path, acl, createMode, cnxn.getSessionIdHex(),
+                        cnxn.getHostAddress());
+    }
+
+    private void addFailureAudit(Request request, ServerCnxn cnxn, String op, String path) {
+        addFailureAudit(request, cnxn, op, path, null, null);
+    }
+
+    private void addFailureAudit(Request request, ServerCnxn cnxn, String op, String path,
+                                 String acl, String createMode) {
+        if (!ZKAuditLogger.isAuditEnabled()) {
+            return;
+        }
+        ZKAuditLogger
+                .logFailure(request.getUsers(), op, path, acl, createMode, cnxn.getSessionIdHex(),
+                        cnxn.getHostAddress());
+    }
+
+    private void addAuditLog(Request request, ServerCnxn cnxn, String op, String path, String acl,
+                             String createMode, Code err) {
+        if (!ZKAuditLogger.isAuditEnabled()) {
+            return;
+        }
+        if (err == Code.OK) {
+            ZKAuditLogger
+                    .logSuccess(request.getUsers(), op, path, acl, createMode, cnxn.getSessionIdHex(),
+                            cnxn.getHostAddress());
+        } else {
+            ZKAuditLogger
+                    .logFailure(request.getUsers(), op, path, acl, createMode, cnxn.getSessionIdHex(),
+                            cnxn.getHostAddress());
+        }
+    }
+
+    private String getACLs(Request request) {
+        ByteBuffer reqData = request.request.slice();
+        reqData.rewind();
+        SetACLRequest setACLRequest = new SetACLRequest();
+        try {
+            ByteBufferInputStream.byteBuffer2Record(reqData, setACLRequest);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return ZKUtil.aclToString(setACLRequest.getAcl());
+    }
+
+    private void addFailedTxnAuditLog(Request request) {","[{'comment': ""I'd make something very similar to this for success events:\r\nGet the `request` as input, short circuit if audit is disabled or the event is not eligible for auditing and then do stuff."", 'commenter': 'anmolnar'}, {'comment': 'done', 'commenter': 'arshadmohammad'}]"
1133,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -956,6 +956,18 @@ property, when available, is noted below.
     and restart ZooKeeper process so ZooKeeper can continue normal data
     consistency check during recovery process.
     Default value is false.
+* *audit.enabled* :","[{'comment': 'There\'s a typo here: the property name is `enable` without the ""D"".', 'commenter': 'anmolnar'}]"
1134,zookeeper-client/zookeeper-client-c/Makefile.am,"@@ -59,6 +65,7 @@ libzkmt_la_LIBADD = -lm $(CLOCK_GETTIME_LIBS)
 
 lib_LTLIBRARIES += libzookeeper_mt.la
 libzookeeper_mt_la_SOURCES =
+libzookeeper_mt_la_CFLAGS = -DTHREADED","[{'comment': 'just a question: you needed to add this flag because of the SASL support, or it is independent?', 'commenter': 'symat'}, {'comment': 'This is a leftover from the various rebases the patch has gone through.  Unrelated to SASL, and unnecessary as `libzookeeper_mt` is made of already-compiled objects. Removed.', 'commenter': 'ztzg'}]"
1134,zookeeper-client/zookeeper-client-c/include/zookeeper.h,"@@ -575,6 +579,93 @@ ZOOAPI zhandle_t *zookeeper_init2(const char *host, watcher_fn fn,
   int recv_timeout, const clientid_t *clientid, void *context, int flags,
   log_callback_fn log_callback);
 
+#ifdef HAVE_CYRUS_SASL_H","[{'comment': ""FYI: It looks like we have a bug and don't support both SASL and SSL together now in ZooKeeper, at least it is not working with the Java Client (there was a thread on the zookeeper user mail list about this, and also there is a jira: https://issues.apache.org/jira/browse/ZOOKEEPER-3482). I see that in your implementation it is also not possible to connect to ZooKeeper using SSL for wire encryption and also authenticate using e.g. Kerberos. \r\n\r\nAs it is not supported in the Java Client either, I don't think you need to do anything with this scenario in this PR. Just keep in mind, that we might need to extend the C client here as well later, to support  / test with both SSL and SASL in a single session."", 'commenter': 'symat'}, {'comment': ""Okay, good to know!\r\n\r\nA related problem is that the SSL support adds `zookeeper_init_ssl`, whereas SASL adds `zookeeper_init_sasl`.  That obviously does not compose.  I suppose we'll have to introduce something like `zookeeper_init_with_options(..., zookeeper_options_t *)` at some point—but one step at a time."", 'commenter': 'ztzg'}]"
1134,zookeeper-client/zookeeper-client-c/src/cli.c,"@@ -840,10 +877,26 @@ int main(int argc, char **argv) {
                 ""-s, --ssl <ssl params>         Comma separated parameters to initiate SSL connection\n""
                 ""                                 e.g.: server_cert.crt,client_cert.crt,client_priv_key.pem,passwd\n""
 #endif
+#ifdef HAVE_CYRUS_SASL_H
+                ""-z, --service <service>        SASL service parameter (default: 'zookeeper')\n""
+                ""-o, --server-fqdn <fqdn>       SASL host name (default: reverse DNS lookup)\n""
+                ""-n, --mechlist <mechlist>      Comma separated list of SASL mechanisms\n""
+                ""-u, --user <user>              SASL user name\n""
+                ""-l, --realm <realm>            SASL realm\n""
+                ""-p, --password-file <file>     File containing the password for SASL\n""","[{'comment': ""could you mention what is the default here? (e.g. the client will ask for the password?)\r\nin one of the examples below you don't specify a password file."", 'commenter': 'symat'}, {'comment': 'I have added a note regarding `--password-file`, and clarified the use of parameters in general (they depend on the chosen SASL mechanism; missing bits are obtained via callbacks).', 'commenter': 'ztzg'}]"
1134,zookeeper-client/zookeeper-client-c/src/cli.c,"@@ -876,18 +929,43 @@ int main(int argc, char **argv) {
 #endif
     zoo_deterministic_conn_order(1); // enable deterministic order
 
-#ifdef HAVE_OPENSSL_H
-    if (!cert) {
-        zh = zookeeper_init(hostPort, watcher, 30000, &myid, NULL, flags);
-    } else {
-        zh = zookeeper_init_ssl(hostPort, cert, watcher, 30000, &myid, NULL, flags);
+#ifdef HAVE_CYRUS_SASL_H
+    if (mechlist) {
+        zoo_sasl_params_t sasl_params = { 0 };
+
+        if (sasl_client_init(NULL) != SASL_OK) {
+            return 1;","[{'comment': ""NIT: isn't there some SASL / other more informative error code we can use instead of `1`?"", 'commenter': 'symat'}, {'comment': 'This is the status code which is returned to the OS.  `cli.c` returns a mixture of 1, 2 and sometimes `errno` (?!) on error.  It would be good to rationalize this, but I would suggest doing it in one go (and perhaps just using `EXIT_FAILURE`).\r\n\r\nI have added some diagnostics, however, as there is no good reason to ""just exit"" without telling why.', 'commenter': 'ztzg'}]"
1134,zookeeper-client/zookeeper-client-c/tests/TestSASLAuth.cc,"@@ -0,0 +1,188 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifdef THREADED
+
+#include <cppunit/extensions/HelperMacros.h>
+#include ""CppAssertHelper.h""
+
+#include <sys/socket.h>
+#include <unistd.h>
+
+#include <zookeeper.h>
+
+#include ""Util.h""
+#include ""WatchUtil.h""
+
+class Zookeeper_SASLAuth : public CPPUNIT_NS::TestFixture {
+    CPPUNIT_TEST_SUITE(Zookeeper_SASLAuth);
+    CPPUNIT_TEST(testServerRequireClientSASL);
+#ifdef HAVE_CYRUS_SASL_H
+    CPPUNIT_TEST(testClientSASL);
+#endif /* HAVE_CYRUS_SASL_H */
+    CPPUNIT_TEST_SUITE_END();
+    FILE *logfile;
+    static const char hostPorts[];
+    static const char jaasConf[];
+    static void watcher(zhandle_t *, int type, int state, const char *path,void*v){
+        watchctx_t *ctx = (watchctx_t*)v;
+
+        if (state == ZOO_CONNECTED_STATE) {
+            ctx->connected = true;
+        } else {
+            ctx->connected = false;
+        }
+        if (type != ZOO_SESSION_EVENT) {
+            evt_t evt;
+            evt.path = path;
+            evt.type = type;
+            ctx->putEvent(evt);
+        }
+    }
+
+public:
+    Zookeeper_SASLAuth() {
+      logfile = openlogfile(""Zookeeper_SASLAuth"");
+    }
+
+    ~Zookeeper_SASLAuth() {
+      if (logfile) {
+        fflush(logfile);
+        fclose(logfile);
+        logfile = 0;
+      }
+    }
+
+    void setUp() {
+        zoo_set_log_stream(logfile);
+
+        // Create SASL configuration file for server.
+        FILE *conff = fopen(""Zookeeper_SASLAuth.jaas.conf"", ""wt"");
+        CPPUNIT_ASSERT(conff);
+        size_t confLen = strlen(jaasConf);
+        CPPUNIT_ASSERT_EQUAL(fwrite(jaasConf, 1, confLen, conff), confLen);
+        CPPUNIT_ASSERT_EQUAL(fclose(conff), 0);
+        conff = NULL;
+
+        // Create password file for client.
+        FILE *passf = fopen(""Zookeeper_SASLAuth.password"", ""wt"");
+        CPPUNIT_ASSERT(passf);
+        CPPUNIT_ASSERT(fputs(""mypassword"", passf) > 0);
+        CPPUNIT_ASSERT_EQUAL(fclose(passf), 0);
+        passf = NULL;
+    }
+
+    void startServer(bool useJaasConf = true) {
+        char cmd[1024];
+        sprintf(cmd, ""%s startRequireSASLAuth%s%s"",
+                ZKSERVER_CMD,
+                useJaasConf ? "" "" : """",
+                useJaasConf ? ""Zookeeper_SASLAuth.jaas.conf"" : """");
+        CPPUNIT_ASSERT(system(cmd) == 0);
+    }
+
+    void stopServer() {
+        char cmd[1024];
+        sprintf(cmd, ""%s stop"", ZKSERVER_CMD);
+        CPPUNIT_ASSERT(system(cmd) == 0);
+    }
+
+    void testServerRequireClientSASL() {
+        startServer(false);
+
+        watchctx_t ctx;
+        int rc = 0;
+        zhandle_t *zk = zookeeper_init(hostPorts, watcher, 10000, 0, &ctx, 0);
+        ctx.zh = zk;
+        CPPUNIT_ASSERT(zk);
+
+        // Wait for handle to be connected.
+        CPPUNIT_ASSERT(ctx.waitForConnected(zk));
+
+        char pathbuf[80];
+        struct Stat stat_a = {0};
+
+        rc = zoo_create2(zk, ""/serverRequireClientSASL"", """", 0,
+                         &ZOO_OPEN_ACL_UNSAFE, 0, pathbuf, sizeof(pathbuf), &stat_a);
+        CPPUNIT_ASSERT_EQUAL((int)ZSESSIONCLOSEDREQUIRESASLAUTH, rc);
+
+        stopServer();
+    }
+
+#ifdef HAVE_CYRUS_SASL_H
+    void testClientSASL() {
+        startServer();
+
+        // Initialize Cyrus SASL.
+        CPPUNIT_ASSERT_EQUAL(sasl_client_init(NULL), SASL_OK);
+
+        // Initialize SASL parameters.
+        zoo_sasl_params_t sasl_params = { 0 };
+
+        sasl_params.service = ""zookeeper"";
+        sasl_params.host = ""zk-sasl-md5"";
+        sasl_params.mechlist = ""DIGEST-MD5"";
+        sasl_params.callbacks = zoo_sasl_make_basic_callbacks(
+            ""myuser"", NULL, ""Zookeeper_SASLAuth.password"");
+
+        // Connect.
+        watchctx_t ctx;
+        int rc = 0;
+        zhandle_t *zk = zookeeper_init_sasl(hostPorts, watcher, 10000, NULL,
+            &ctx, /*flags*/0, /*log_callback*/NULL, &sasl_params);
+        ctx.zh = zk;
+        CPPUNIT_ASSERT(zk);
+
+        // Wait for SASL auth to complete and handle to be connected.
+        CPPUNIT_ASSERT(ctx.waitForConnected(zk));
+
+        // Leave mark.
+        char pathbuf[80];
+        struct Stat stat_a = {0};
+        rc = zoo_create2(zk, ""/serverRequireClientSASL"", """", 0,
+            &ZOO_OPEN_ACL_UNSAFE, 0, pathbuf, sizeof(pathbuf), &stat_a);
+        CPPUNIT_ASSERT_EQUAL((int)ZOK, rc);
+
+        // Stop and restart the server to test automatic reconnect & re-auth.
+        stopServer();
+        CPPUNIT_ASSERT(ctx.waitForDisconnected(zk));
+        startServer();
+
+        // Wait for automatic SASL re-auth to complete.
+        CPPUNIT_ASSERT(ctx.waitForConnected(zk));
+
+        // Check mark left above.
+        rc = zoo_exists(zk, ""/serverRequireClientSASL"", /*watch*/false, &stat_a);
+        CPPUNIT_ASSERT_EQUAL((int)ZOK, rc);
+
+        stopServer();
+    }
+#endif /* HAVE_CYRUS_SASL_H */
+};","[{'comment': 'Would you mind adding / trying to add an IPv6 testcase as well? (this is something I missed for SSL and I should still do some time) I hope it should be fairly trivial, just try the same test with `hostPorts[] = ""::1:22181""`\r\nsome example: https://github.com/apache/zookeeper/blob/48e5eaadffd8e23d2f47fe3eb0d0437b172dcd39/zookeeper-client/zookeeper-client-c/tests/TestClient.cc#L794', 'commenter': 'symat'}, {'comment': 'Done.', 'commenter': 'ztzg'}]"
1134,zookeeper-client/zookeeper-client-c/src/cli.c,"@@ -840,10 +877,26 @@ int main(int argc, char **argv) {
                 ""-s, --ssl <ssl params>         Comma separated parameters to initiate SSL connection\n""
                 ""                                 e.g.: server_cert.crt,client_cert.crt,client_priv_key.pem,passwd\n""
 #endif
+#ifdef HAVE_CYRUS_SASL_H
+                ""-z, --service <service>        SASL service parameter (default: 'zookeeper')\n""
+                ""-o, --server-fqdn <fqdn>       SASL host name (default: reverse DNS lookup)\n""
+                ""-n, --mechlist <mechlist>      Comma separated list of SASL mechanisms\n""
+                ""-u, --user <user>              SASL user name\n""
+                ""-l, --realm <realm>            SASL realm\n""
+                ""-p, --password-file <file>     File containing the password for SASL\n""
+#endif /* HAVE_CYRUS_SASL_H */
                 ""-r, --readonly                 Connect in read-only mode\n""
                 ""-d, --debug                    Activate debug logs right from the beginning (you can also use the \n""
                 ""                                 command 'verbose' later to activate debug logs in the cli shell)\n\n"",
                 argv[0]);
+#ifdef HAVE_CYRUS_SASL_H
+        fprintf(stderr,
+                ""SASL EXAMPLES:\n""","[{'comment': 'please also mention here, that SSL and SASL are not working together at the moment. AFAICS in the implementation, if the user defines both SSL and SASL parameters, then only the SASL will be used. (I am not sure what happens, if the SASL fails to authenticate... do we in this case fallback to SSL?)', 'commenter': 'symat'}, {'comment': 'Done.  (But see the note above above, about `zookeeper_init_with_options`.)', 'commenter': 'ztzg'}]"
1143,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/CommitProcessor.java,"@@ -624,21 +626,19 @@ public void shutdown() {
 
         try {
             this.join(workerShutdownTimeoutMS);
+            if (this.isAlive()) {
+                LOG.warn(""CommitProcessor does not shutdown gracefully after ""
+                        + ""waiting for {} ms, exit to avoid potential ""
+                        + ""inconsistency issue"", workerShutdownTimeoutMS);
+                System.exit(ExitCode.SHUTDOWN_UNGRACEFULLY.getValue());","[{'comment': ""Catch (InterruptedException) won't help for System.exit.\r\n\r\nMaybe the best idea is to have a system property to disable the real 'System.exit' and add such property in tests (Maven surefire plugin config)\r\n\r\n"", 'commenter': 'eolivelli'}]"
1147,excludeFindBugsFilter.xml,"@@ -7,8 +7,5 @@
     <!-- this problem is to be addressed in ZOOKEEPER-3227 -->
     <Bug pattern=""DM_DEFAULT_ENCODING""/>
 
-    <!-- not really a problem -->
-    <Bug pattern=""DM_EXIT""/>","[{'comment': 'know we have only one place in code allowed to call directly System.exit, so it is better to enable the rule and suppress it locally', 'commenter': 'eolivelli'}]"
1150,pom.xml,"@@ -574,7 +574,7 @@
         <plugin>
           <groupId>org.owasp</groupId>
           <artifactId>dependency-check-maven</artifactId>
-          <version>5.2.1</version>
+          <version>5.2.4</version>","[{'comment': 'please also cite this change in the commit message and update JIRA case', 'commenter': 'eolivelli'}, {'comment': '@eolivelli Done', 'commenter': 'coheigea'}]"
1171,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -1226,12 +1226,6 @@ protected Election createElectionAlgorithm(int electionAlgorithm) {
 
         //TODO: use a factory rather than a switch
         switch (electionAlgorithm) {","[{'comment': ""- Now we can remove this `TODO`\r\n- Now we don't need this `switch-case ` structure, only support `Algorithm3` "", 'commenter': 'maoling'}, {'comment': 'Hey @maoling I have made addressed your comments and please do let me know if you see any additional changes that are required.', 'commenter': 'rabi-kumar'}]"
1171,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -1224,33 +1224,20 @@ protected Observer makeObserver(FileTxnSnapLog logFactory) throws IOException {
     protected Election createElectionAlgorithm(int electionAlgorithm) {
         Election le = null;
 
-        //TODO: use a factory rather than a switch
-        switch (electionAlgorithm) {
-        case 1:
-            le = new AuthFastLeaderElection(this);
-            break;
-        case 2:
-            le = new AuthFastLeaderElection(this, true);
-            break;
-        case 3:
-            QuorumCnxManager qcm = createCnxnManager();
-            QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);
-            if (oldQcm != null) {
-                LOG.warn(""Clobbering already-set QuorumCnxManager (restarting leader election?)"");
-                oldQcm.halt();
-            }
-            QuorumCnxManager.Listener listener = qcm.listener;
-            if (listener != null) {
-                listener.start();
-                FastLeaderElection fle = new FastLeaderElection(this, qcm);
-                fle.start();
-                le = fle;
-            } else {
-                LOG.error(""Null listener when initializing cnx manager"");
-            }
-            break;
-        default:
-            assert false;
+        QuorumCnxManager qcm = createCnxnManager();","[{'comment': 'Does it make sense to make this variable (and the others) `final`?', 'commenter': 'HorizonNet'}, {'comment': 'Making variables as final makes sense. I will push the changes shortly.', 'commenter': 'rabi-kumar'}]"
1171,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1025,10 +1025,11 @@ of servers -- that is, when deploying clusters of servers.
     non-authenticated UDP-based version of fast leader election, ""2""
     corresponds to the authenticated UDP-based version of fast
     leader election, and ""3"" corresponds to TCP-based version of
-    fast leader election. Currently, algorithm 3 is the default.
+    fast leader election. Currently, algorithm 3 is the default and 
+    algorithm 1, 2 has been removed from the implementation.
     ###### Note
     >The implementations of leader election 1, and 2 are now
-    **deprecated**. We have the intention","[{'comment': 'We can chop more this comment,\r\nif there is no choice why document it?', 'commenter': 'eolivelli'}, {'comment': 'Yes @eolivelli you are right. I will remove any mention of algorithm ""1"", ""2"" from the docs and will focus on algorithm ""3"" only.', 'commenter': 'rabi-kumar'}]"
1171,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1021,16 +1021,9 @@ of servers -- that is, when deploying clusters of servers.
 
 * *electionAlg* :
     (No Java system property)
-    Election implementation to use. A value of ""1"" corresponds to the
-    non-authenticated UDP-based version of fast leader election, ""2""
-    corresponds to the authenticated UDP-based version of fast
-    leader election, and ""3"" corresponds to TCP-based version of
-    fast leader election. Currently, algorithm 3 is the default.
-    ###### Note
-    >The implementations of leader election 1, and 2 are now
-    **deprecated**. We have the intention
-    of removing them in the next release, at which point only the
-    FastLeaderElection will be available.","[{'comment': ""Wouldn't it be a good idea to note that these values have been used in prior versions (note which) and are no longer valid in the current version as they were deprecated in 3.4.0 and removed in...\r\n\r\nSomething along these lines would help people coming in with issues, ie if they were using 1 or 2 and upgraded."", 'commenter': 'phunt'}, {'comment': '@phunt I have added back the removed explanation of the election algorithm back in the documentation along with changes that you mentioned. Default value was made 3 in 3.2 as per [ZOOKEEPER-499](https://issues.apache.org/jira/browse/ZOOKEEPER-499) and was deprecated in 3.4 and will be removed in 3.6.0.', 'commenter': 'rabi-kumar'}]"
1171,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -1221,36 +1221,23 @@ protected Observer makeObserver(FileTxnSnapLog logFactory) throws IOException {
     }
 
     @SuppressWarnings(""deprecation"")
-    protected Election createElectionAlgorithm(int electionAlgorithm) {","[{'comment': ""why remove this entirely? Wouldn't it be a good idea to keep it available for folks interested in implementing their own?"", 'commenter': 'phunt'}, {'comment': ""I agree with @phunt . Let's keep this patch as simple as possible which would also make backporting easier. I would just blindly remove the option for AuthFastLeaderElection (and the class itself) making a note in documentation that it has been deprecated since 3.4.0."", 'commenter': 'anmolnar'}, {'comment': 'done', 'commenter': 'rabi-kumar'}]"
1171,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -1221,36 +1221,23 @@ protected Observer makeObserver(FileTxnSnapLog logFactory) throws IOException {
     }
 
     @SuppressWarnings(""deprecation"")
-    protected Election createElectionAlgorithm(int electionAlgorithm) {
+    protected Election createElectionAlgorithm() {
         Election le = null;
 
-        //TODO: use a factory rather than a switch
-        switch (electionAlgorithm) {
-        case 1:
-            le = new AuthFastLeaderElection(this);
-            break;
-        case 2:
-            le = new AuthFastLeaderElection(this, true);
-            break;","[{'comment': ""similar to my comment above - if this were/is set wouldn't it be good to emit an error message?"", 'commenter': 'phunt'}, {'comment': 'Agree. Throw an UnsupportedException here instead of removing the switch.', 'commenter': 'anmolnar'}, {'comment': 'Added back the switch statement and if cases are 1 and 2 then throw UnsupportedOperationException', 'commenter': 'rabi-kumar'}]"
1171,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java,"@@ -312,8 +312,8 @@ public void parseProperties(Properties zkProp) throws IOException, ConfigExcepti
                 connectToLearnerMasterLimit = Integer.parseInt(value);
             } else if (key.equals(""electionAlg"")) {
                 electionAlg = Integer.parseInt(value);
-                if (electionAlg != 1 && electionAlg != 2 && electionAlg != 3) {","[{'comment': 'perhaps a better location for the error..', 'commenter': 'phunt'}, {'comment': ""Didn't make any changes in this part because default value of electionAlg is 3 and if other than 3 is used then configException is thrown instead made changes in QuorumPeer.createElectionAlgorithm"", 'commenter': 'rabi-kumar'}]"
1171,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1021,9 +1021,16 @@ of servers -- that is, when deploying clusters of servers.
 
 * *electionAlg* :
     (No Java system property)
-    Election implementation to use. Default value is ""3"" 
-    which corresponds to TCP-based version of
-    fast leader election.
+    Election implementation to use. A value of ""1"" corresponds to the
+    non-authenticated UDP-based version of fast leader election, ""2""
+    corresponds to the authenticated UDP-based version of fast
+    leader election, and ""3"" corresponds to TCP-based version of
+    fast leader election. Algorithm 3 was made default in 3.2.0 and 
+    prior versions (3.0.0 and 3.1.0) were using algorithm 1 and 2 as well.
+    ###### Note
+    >The implementations of leader election 1, and 2 were 
+    **deprecated** in 3.4.0. We will be removing them in release of 3.6.0, ","[{'comment': 'What about:\r\n`Since 3.6.0 only FastLeaderElection is available, in case of upgrade you have to shutdown all of your servers and restart them with electionAlg=3 (or removing the line from the configuration file)`', 'commenter': 'eolivelli'}, {'comment': 'done pending QA', 'commenter': 'rabi-kumar'}]"
1193,zookeeper-recipes/zookeeper-recipes-lock/src/main/java/org/apache/zookeeper/recipes/lock/ZNodeName.java,"@@ -102,9 +125,9 @@ public String getName() {
     }
 
     /**
-     * Returns the sequence number.
+     * Returns the optional sequence number.
      */
-    public int getZNodeName() {
+    public Optional<Integer> getSequence() {","[{'comment': ""it looks like this method is called only in tests.\r\nyou can drop the 'public' modifier"", 'commenter': 'eolivelli'}, {'comment': 'All of the other `getters` are also public, so I think it should be consistent with them.', 'commenter': 'belugabehr'}]"
1193,zookeeper-recipes/zookeeper-recipes-lock/src/main/java/org/apache/zookeeper/recipes/lock/ZNodeName.java,"@@ -18,45 +18,62 @@
 
 package org.apache.zookeeper.recipes.lock;
 
+import java.util.Objects;
+import java.util.Optional;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * Represents an ephemeral znode name which has an ordered sequence number
- * and can be sorted in order.
+ * Represents an immutable ephemeral znode name which has an ordered sequence
+ * number and can be sorted in order. The expected name format of the znode is
+ * as follows:
  *
+ * <pre>
+ * &lt;name&gt;-&lt;sequence&gt;
+ *
+ * For example: lock-00001
+ * </pre>
  */
 class ZNodeName implements Comparable<ZNodeName> {
 
-    private final String name;
-    private String prefix;
-    private int sequence = -1;
     private static final Logger LOG = LoggerFactory.getLogger(ZNodeName.class);
 
-    public ZNodeName(String name) {
-        if (name == null) {
-            throw new NullPointerException(""id cannot be null"");
-        }
-        this.name = name;
-        this.prefix = name;
-        int idx = name.lastIndexOf('-');
-        if (idx >= 0) {
+    private final String name;
+    private final String prefix;
+    private final Optional<Integer> sequence;","[{'comment': ""The difference from int to Optional<Integer> in terms of space/memory usage is considerable.\r\nIs it really worth to change it ?\r\n\r\nThis is only a 'recipe' so not a big deal, but I wonder if is it better to keep it simpler."", 'commenter': 'eolivelli'}, {'comment': ""@eolivelli I always prefer using Optional.  It's always very clear as to its usage and the caller must deal with it.  Better than forcing the user to correctly check for a special negative value that indicates 'no sequence available'.  This is not performance-critical code, so readability and usability should be prioritized."", 'commenter': 'belugabehr'}]"
1195,bin/zkCli.cmd,"@@ -17,7 +17,7 @@ REM limitations under the License.
 setlocal
 call ""%~dp0zkEnv.cmd""
 
-ZOO_LOG_FILE=zookeeper-%USERNAME%-cli-%COMPUTERNAME%.log
+set ZOO_LOG_FILE=zookeeper-%USERNAME%-cli-%COMPUTERNAME%.log
 
 set ZOOMAIN=org.apache.zookeeper.ZooKeeperMain","[{'comment': '@wordfeng\r\n- Yes, this bug has been fixed by [ZOOKEEPER-3453](https://issues.apache.org/jira/browse/ZOOKEEPER-3453)\r\n- Please change this github description to ""`ZOOKEEPER-3453: missing \'SET\' in zkCli on windows`""', 'commenter': 'maoling'}, {'comment': 'ok, i changed it', 'commenter': 'wordfeng'}]"
1211,zookeeper-server/src/main/java/org/apache/zookeeper/server/SyncRequestProcessor.java,"@@ -178,7 +178,7 @@ public void run() {
                 ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_TIME.add(startProcessTime - si.syncQueueStartTime);
 
                 // track the number of records written to the log
-                if (zks.getZKDatabase().append(si)) {
+                if (!si.isThrottled() && zks.getZKDatabase().append(si)) {","[{'comment': 'I believe this new code to be correct, but its ""shape"" raised a red flag for me as 1/ there is an `else` branch and 2/ it sports an ""outdated"" comment (the ""iff read,"" in particular, is confusing):\r\n\r\n```java\r\n} else if (toFlush.isEmpty()) {\r\n    // optimization for read heavy workloads\r\n    // iff this is a read, and there are no pending\r\n    // flushes (writes), then just pass this to the next\r\n    // processor\r\n```\r\n\r\n(Feel free to ignore this, but I thought I\'d mention it.)', 'commenter': 'ztzg'}, {'comment': 'Thanks for raising the red flag. Now I see it too!', 'commenter': 'jhuan31'}, {'comment': 'updated the comment', 'commenter': 'jhuan31'}]"
1211,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/CommitProcessor.java,"@@ -306,6 +309,11 @@ public void run() {
                         // Process committed head
                         request = committedRequests.peek();
 
+                        if (request.isThrottled()) {
+                            LOG.error(""Throttled request in committed pool: "" + request + "". Exiting."");
+                            System.exit(1);","[{'comment': 'See `ServiceUtils.requestSystemExit()` and [ZOOKEEPER-3620](https://issues.apache.org/jira/browse/ZOOKEEPER-3620).  (There are multiple instances of this.)', 'commenter': 'ztzg'}, {'comment': 'fixed. Thanks!', 'commenter': 'jhuan31'}]"
1211,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeerMain.java,"@@ -65,7 +65,6 @@
  * message (including heartbeats) from the leader.</li>
  * <li>server.<i>id</i> - This is the host:port[:port] that the server with the
  * given id will use for the quorum protocol.</li>
- * </ol>
  * In addition to the config file. There is a file in the data directory called","[{'comment': 'This looks like an accidental deletion, and breaks the `<ol>` list.', 'commenter': 'ztzg'}, {'comment': 'oh yea. fixed', 'commenter': 'jhuan31'}]"
1211,zookeeper-server/src/test/java/org/apache/zookeeper/test/ThrottledOpHelper.java,"@@ -0,0 +1,224 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import mockit.Mock;
+import mockit.MockUp;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.data.ACL;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.server.Request;
+import org.apache.zookeeper.server.RequestThrottler;
+import org.apache.zookeeper.server.ZooKeeperServer;
+import org.junit.Assert;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ThrottledOpHelper {
+    protected static final Logger LOG = LoggerFactory.getLogger(ThrottledOpHelper.class);
+
+    public static final class RequestThrottleMock extends MockUp<RequestThrottler> {
+        public static void throttleEveryNthOp(int n) {
+            everyNthOp = n;
+            opCounter = 0;
+        }
+        private static int everyNthOp = 0;
+        private static int opCounter = 0;
+
+        @Mock
+        private boolean shouldThrottleOp(Request request, long elapsedTime) {
+            if (everyNthOp > 0 && request.isThrottlable() && (++opCounter % everyNthOp == 0)) {
+                opCounter %= everyNthOp;
+                return true;
+            }
+            return false;
+        }
+    }
+
+    public static void applyMockUps() {
+        new RequestThrottleMock();
+    }
+
+    public void testThrottledOp(ZooKeeper zk, ZooKeeperServer zs) throws IOException, InterruptedException, KeeperException {
+        final int N = 5; // must be greater than 3
+        final int COUNT = 100;
+        RequestThrottleMock.throttleEveryNthOp(N);
+        LOG.info(""Before create /ivailo nodes"");
+        int opCount = 0;
+        for (int i = 0; i < COUNT; i++) {
+            String nodeName = ""/ivailo"" + i;
+            if (opCount % N == N - 1) {
+                try {
+                    zk.create(nodeName, """".getBytes(), Ids.OPEN_ACL_UNSAFE,
+                        (i % 2 == 0) ? CreateMode.PERSISTENT : CreateMode.EPHEMERAL);
+                    Assert.fail(""Should have gotten ThrottledOp exception"");
+                } catch (KeeperException.ThrottledOpException e) {
+                    // anticipated outcome
+                    Stat stat = zk.exists(nodeName, null);
+                    Assert.assertNull(stat);
+                    zk.create(nodeName, """".getBytes(), Ids.OPEN_ACL_UNSAFE,
+                        (i % 2 == 0) ? CreateMode.PERSISTENT : CreateMode.EPHEMERAL);
+                } catch (KeeperException e) {
+                    Assert.fail(""Should have gotten ThrottledOp exception"");
+                }
+                opCount += 3; // three ops issues
+            } else {
+                zk.create(nodeName, """".getBytes(), Ids.OPEN_ACL_UNSAFE,
+                    (i % 2 == 0) ? CreateMode.PERSISTENT : CreateMode.EPHEMERAL);
+                opCount++; // one op only issued
+            }
+            if (opCount % N == N - 1) {
+                try {
+                    zk.setData(nodeName, nodeName.getBytes(), -1);
+                    Assert.fail(""Should have gotten ThrottledOp exception"");
+                } catch (KeeperException.ThrottledOpException e) {
+                    // anticipated outcome & retry
+                    zk.setData(nodeName, nodeName.getBytes(), -1);
+                } catch (KeeperException e) {
+                    Assert.fail(""Should have gotten ThrottledOp exception"");
+                }
+                opCount += 2; // two ops issues, one for retry
+            } else {
+                zk.setData(nodeName, nodeName.getBytes(), -1);
+                opCount++; // one op only issued
+            }
+        }
+        LOG.info(""Before delete /ivailo nodes"");
+        for (int i = 0; i < COUNT; i++) {
+            String nodeName = ""/ivailo"" + i;
+            if (opCount % N == N - 1) {
+                try {
+                    zk.exists(nodeName, null);
+                    Assert.fail(""Should have gotten ThrottledOp exception"");
+                } catch (KeeperException.ThrottledOpException e) {
+                    // anticipated outcome & retry
+                    Stat stat = zk.exists(nodeName, null);
+                    Assert.assertNotNull(stat);
+                    opCount += 2; // two ops issued, one is retry
+                } catch (KeeperException e) {
+                    Assert.fail(""Should have gotten ThrottledOp exception"");
+                }
+            } else {
+                Stat stat = zk.exists(nodeName, null);
+                Assert.assertNotNull(stat);
+                opCount++;
+            }
+            if (opCount % N == N - 1) {
+                try {
+                    zk.getData(nodeName, null, null);
+                    Assert.fail(""Should have gotten ThrottledOp exception"");
+                } catch (KeeperException.ThrottledOpException e) {
+                    // anticipated outcome & retry
+                    byte[] data = zk.getData(nodeName, null, null);
+                    Assert.assertEquals(nodeName, new String(data));
+                    opCount += 2; // two ops issued, one is retry
+                } catch (KeeperException e) {
+                    Assert.fail(""Should have gotten ThrottledOp exception"");
+                }
+            } else {
+                byte[] data = zk.getData(nodeName, null, null);
+                Assert.assertEquals(nodeName, new String(data));
+                opCount++;
+            }
+            if (opCount % N == N - 1) {
+                try {
+                    // version 0 should not trigger BadVersion exception
+                    zk.delete(nodeName, 0);","[{'comment': ""Is this correct/intentional?  `setData` is called once on each node, so I would expect the actual version to be `1`.  Of course, the check won't trigger, as the request is throttled—I suppose that's what that comment is trying to draw attention to?"", 'commenter': 'ztzg'}, {'comment': 'yes. we just want to make sure that no BadVersion exception is thrown.', 'commenter': 'jhuan31'}]"
1211,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1133,6 +1133,15 @@ property, when available, is noted below.
     effect due to TLS handshake timeout when there are too many in-flight TLS 
     handshakes. Set it to something like 250 is good enough to avoid herd effect.
 
+* *throttledOpWaitTime*
+    (Jave system property: **zookeeper.throttled_op_wait_time**)
+    The time in the RequestThrottler queue longer than which a request will be marked as throttled.","[{'comment': 'Nit: `Jave` is a typo for `Java`.', 'commenter': 'ztzg'}, {'comment': 'fixed.', 'commenter': 'jhuan31'}]"
1211,zookeeper-client/zookeeper-client-c/include/zookeeper.h,"@@ -136,7 +136,8 @@ enum ZOO_ERRORS {
   ZEPHEMERALONLOCALSESSION = -120, /*!< Attempt to create ephemeral node on a local session */
   ZNOWATCHER = -121, /*!< The watcher couldn't be found */
   ZRECONFIGDISABLED = -123, /*!< Attempts to perform a reconfiguration operation when reconfiguration feature is disabled */
-  ZSESSIONCLOSEDREQUIRESASLAUTH = -124 /*!< The session has been closed by server because server requires client to do SASL authentication, but client is not configured with SASL authentication or configuted with SASL but failed (i.e. wrong credential used.). */
+  ZSESSIONCLOSEDREQUIRESASLAUTH = -124, /*!< The session has been closed by server because server requires client to do SASL authentication, but client is not configured with SASL authentication or configuted with SASL but failed (i.e. wrong credential used.). */
+  ZTHROTTLEDOP = -127 /*!< Operation was throttled and not executed at all. please, retry! */","[{'comment': 'Any reason not to use -125 as the value of `ZTHROTTLEDOP` here?', 'commenter': 'hanm'}, {'comment': ""We usually upstream a feature after it is deployed and if the number is taken when we upstream it, it's quite some trouble especially the number is used on the client side too. So we usually leave some holes."", 'commenter': 'jhuan31'}]"
1211,zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -150,6 +139,24 @@ public void processRequest(Request request) {
             }
         }
 
+        return rc;
+    }
+
+    public void processRequest(Request request) {
+        LOG.debug(""Processing request:: "" + request);","[{'comment': 'Please use parameterized logging format here - I believe that in its current form the string concatenation will happen as the parameter has to be evaluated first, even when debug level logging is disabled. Since this is on critical path of request processing, the performance will take a hit.', 'commenter': 'hanm'}, {'comment': ""Update -  I realized that this was not new code, so my previous comment is non blocking for landing the PR. But it's still good to update the log format since we are here..."", 'commenter': 'hanm'}, {'comment': 'done.', 'commenter': 'jhuan31'}]"
1211,zookeeper-server/src/main/java/org/apache/zookeeper/KeeperException.java,"@@ -404,7 +406,9 @@ public void setCode(int code) {
         /** The session has been closed by server because server requires client to do SASL authentication,
          *  but client is not configured with SASL authentication or configuted with SASL but failed
          *  (i.e. wrong credential used.). */
-        SESSIONCLOSEDREQUIRESASLAUTH(-124);
+        SESSIONCLOSEDREQUIRESASLAUTH(-124),
+        /** Operation was throttled and not executed at all. please, retry! */","[{'comment': 'It might be better to add more document here on how to deal with this new error code. `please, retry!` does not sound a good answer, as our intention, according to the design is to not to let clients retry the requests immediately. Something like - ""this error code indicates that zookeeper server is under heavy load and can\'t process incoming requests at full speed; please retry with back off"" sounds more useful to user.', 'commenter': 'hanm'}, {'comment': 'Thanks!', 'commenter': 'jhuan31'}]"
1211,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1237,6 +1240,15 @@ public void setTickTime(int tickTime) {
         this.tickTime = tickTime;
     }
 
+    public static int getThrottledOpWaitTime() {
+        return throttledOpWaitTime;
+    }
+
+    public static void setThrottledOpWaitTime(int time) {
+        LOG.info(""throttledOpWaitTime set to "" + time);","[{'comment': 'please use parameterized logging here :)', 'commenter': 'hanm'}, {'comment': 'changed', 'commenter': 'jhuan31'}]"
1211,zookeeper-server/src/main/java/org/apache/zookeeper/server/Request.java,"@@ -100,6 +100,8 @@ public Request(long sessionId, int xid, int type, TxnHeader hdr, Record txn, lon
 
     public long syncQueueStartTime;
 
+    public long requestThrottleQueueTime;","[{'comment': ""I might miss something here, but I don't see where this value is actually get set anywhere in this patch. Without this value being set, I don't think we'll know when a request will be throttled or not ..."", 'commenter': 'hanm'}, {'comment': ""You've saved my PR again :) Thanks!"", 'commenter': 'jhuan31'}, {'comment': ':) \r\n\r\nWould be good to add a test case that cover the real logic of `shouldThrottleOp` instead of using a mock; if we have such test it will catch issue like this but this is non blocking and latest change lgtm.', 'commenter': 'hanm'}]"
1217,zookeeper-server/src/main/java/org/apache/zookeeper/common/StringUtils.java,"@@ -44,22 +45,24 @@ private StringUtils() {/** non instantiable and non inheritable **/}
     }
 
     /**
-     * This method takes a List&lt;String&gt; and a delimiter and joins the strings
-     * into a single string, where the original strings are separated using
-     * the given delimiter.
+     * This method takes a List&lt;String&gt; and a delimiter and joins the
+     * strings into a single string, where the original strings are separated
+     * using the given delimiter. This method is a null-safe version of
+     * {@link String#join(CharSequence, Iterable)}
      *
+     * <p>
+     * Note that if an individual element is null, then ""null"" is added.
+     * </p>
+     * @param list a {@code List} that will have its elements joined together
+     * @param delim a sequence of characters that is used to separate each of the
+     *          elements in the resulting String
+     * @return a new String that is composed from the elements argument or
+     *         {@code null} if list is {@code null}
+     * @throws NullPointerException if delim is {@code null}
      */
     public static String joinStrings(List<String> list, String delim) {
-        if (list == null) {
-            return null;
-        }
-
-        StringBuilder builder = new StringBuilder(list.get(0));
-        for (String s : list.subList(1, list.size())) {
-            builder.append(delim).append(s);
-        }
-
-        return builder.toString();
+        Objects.requireNonNull(delim);
+        return list == null ? null : String.join(delim, list);
     }
 
 }","[{'comment': '- Good catch.\r\n- Could you please add an unit case to assert this change?', 'commenter': 'maoling'}]"
1217,zookeeper-server/src/test/java/org/apache/zookeeper/test/StringUtilTest.java,"@@ -19,24 +19,50 @@
 package org.apache.zookeeper.test;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import java.util.Arrays;
+import java.util.Collections;
 import org.apache.zookeeper.ZKTestCase;
 import org.apache.zookeeper.common.StringUtils;
+import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 
 public class StringUtilTest extends ZKTestCase {
 
     @Test
-    public void testStrings() {
+    public void testStringSplit() {
+        final String s1 = ""   a  ,   b  , "";
+        assertEquals(Arrays.asList(""a"", ""b""), StringUtils.split(s1, "",""));
 
-        String s1 = ""   a  ,   b  , "";
-        assertEquals(""[a, b]"", StringUtils.split(s1, "","").toString());
+        assertEquals(Collections.emptyList(), StringUtils.split("""", "",""));
 
-        String s2 = """";
-        assertEquals(0, StringUtils.split(s2, "","").size());
+        final String s3 = ""1, , 2"";
+        assertEquals(Arrays.asList(""1"", ""2""), StringUtils.split(s3, "",""));
+    }
+
+    public void testStringJoinNullDelim() {","[{'comment': 'I believe you are missing a `@Test` here.', 'commenter': 'ztzg'}, {'comment': 'Nice catch. Ya, JUNIT went from v4 -> v5 between my pull requests so I had to re-do some of the JUnit related stuff and clearly missed this one.  Thanks!  Changes made directly in GitHub.', 'commenter': 'belugabehr'}]"
1233,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/LearnerTest.java,"@@ -300,4 +307,52 @@ public void syncTest() throws Exception {
         }
     }
 
+    @Test
+    public void truncFailTest() throws Exception {
+        final boolean[] exitProcCalled = {false};
+
+        ServiceUtils.setSystemExitProcedure(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer exitCode) {
+                exitProcCalled[0] = true;
+                assertThat(exitCode, equalTo(ExitCode.QUORUM_PACKET_ERROR.getValue()));","[{'comment': ""This assertion will not happen in the main junit thread, so if it asserts false, the behaviour will be unpredictable (the test will probably ignore it). \r\n\r\nInstead of this, I'd replace exitProcCalled with a ```CompletableFuture<Integer>``` and at the end of the  test method do\r\n```\r\nassertThat(exitCode.get(10, TimeUnit.SECONDS), equalTo(ExitCode.QUORUM_PACKET_ERROR.getValue()));\r\n```"", 'commenter': 'ivankelly'}, {'comment': ""I double checked it. Consumer's accept() method is called synchronously, no threading involved. In other words it will be called on junit's main thread."", 'commenter': 'anmolnar'}, {'comment': 'Ok. I see that now.', 'commenter': 'ivankelly'}]"
1233,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -499,23 +499,28 @@ public void save(
      * @return true if able to truncate the log, false if not
      * @throws IOException
      */
-    public boolean truncateLog(long zxid) throws IOException {
-        // close the existing txnLog and snapLog
-        close();
-
-        // truncate it
-        FileTxnLog truncLog = new FileTxnLog(dataDir);
-        boolean truncated = truncLog.truncate(zxid);
-        truncLog.close();
-
-        // re-open the txnLog and snapLog
-        // I'd rather just close/reopen this object itself, however that
-        // would have a big impact outside ZKDatabase as there are other
-        // objects holding a reference to this object.
-        txnLog = new FileTxnLog(dataDir);
-        snapLog = new FileSnap(snapDir);
-
-        return truncated;
+    public boolean truncateLog(long zxid) {
+        try {
+            // close the existing txnLog and snapLog
+            close();
+
+            // truncate it
+            FileTxnLog truncLog = new FileTxnLog(dataDir);
+            boolean truncated = truncLog.truncate(zxid);
+            truncLog.close();
+
+            // re-open the txnLog and snapLog
+            // I'd rather just close/reopen this object itself, however that
+            // would have a big impact outside ZKDatabase as there are other
+            // objects holding a reference to this object.
+            txnLog = new FileTxnLog(dataDir);
+            snapLog = new FileSnap(snapDir);
+
+            return truncated;
+        } catch (IOException e) {","[{'comment': 'I\'m wondering if IOException is sufficient. If you look at \r\nhttps://github.com/apache/zookeeper/blob/c234848caef0cc920f19befd1b0b14251b17da92/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Follower.java#L128\r\nIt\'s catching an Exception, so basically any exception other than IOException occurring here, could kick us back into the same situation. In fact, even the caller of Follower.followLeader() catches Exception. They\'re all over QuorumPeer, with ""Unexpected exception"" log warnings.\r\n\r\nI think as part of the same fix, these ""Unexpected exception"" errors should also take down the process. wdyt?', 'commenter': 'ivankelly'}, {'comment': ""I'll check it, but currently I don't see any reason why not change it to `Exception`."", 'commenter': 'anmolnar'}, {'comment': 'I think it would be better to change the behaviour in QuorumPeer to requestSystemExit any time it gets an unexpected exception. QuorumPeer runs in a loop starting Learners and Leaders etc. There are objects shared between iterations of these loops, and as far I can see little checking that the objects are in a sane state if an exception occurred. Of course, I this is a bigger change, so perhaps it can be done later.', 'commenter': 'ivankelly'}, {'comment': 'I also think this should be another ticket/improvement to fix', 'commenter': 'nkalmar'}]"
1233,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -499,23 +499,28 @@ public void save(
      * @return true if able to truncate the log, false if not
      * @throws IOException
      */
-    public boolean truncateLog(long zxid) throws IOException {
-        // close the existing txnLog and snapLog
-        close();
-
-        // truncate it
-        FileTxnLog truncLog = new FileTxnLog(dataDir);
-        boolean truncated = truncLog.truncate(zxid);
-        truncLog.close();
-
-        // re-open the txnLog and snapLog
-        // I'd rather just close/reopen this object itself, however that
-        // would have a big impact outside ZKDatabase as there are other
-        // objects holding a reference to this object.
-        txnLog = new FileTxnLog(dataDir);
-        snapLog = new FileSnap(snapDir);
-
-        return truncated;
+    public boolean truncateLog(long zxid) {
+        try {
+            // close the existing txnLog and snapLog
+            close();
+
+            // truncate it
+            FileTxnLog truncLog = new FileTxnLog(dataDir);
+            boolean truncated = truncLog.truncate(zxid);
+            truncLog.close();","[{'comment': 'what about calling this **close** in a finally block ?\r\n\r\n```\r\ntry { \r\n    FileTxnLog truncLog = new FileTxnLog(dataDir);\r\n            boolean truncated = truncLog.truncate(zxid);\r\n  } finally {\r\n            truncLog.close();\r\n}\r\n```', 'commenter': 'eolivelli'}, {'comment': 'this is done slightly differently. please check.', 'commenter': 'anmolnar'}]"
1233,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileSnap.java,"@@ -260,6 +260,8 @@ public synchronized void serialize(
                     Util.getZxidFromName(snapShot.getName(), SNAPSHOT_FILE_PREFIX),
                     snapShot.lastModified() / 1000);
             }
+        } else {
+            throw new IllegalStateException(""FileSnap has already been closed"");","[{'comment': 'will existing code handle this RuntimeException properly ?\r\nwhat about throwing a IOException ?', 'commenter': 'eolivelli'}, {'comment': ""I dunno if I suggested IllegalStateException originally, but it's what I had in mind when I suggested this should throw an exception. \r\n\r\nIf you call close() on FileSnap, and it's already closed, that's a programmer's mistake. There *should not* be any handling for this, because the object is in a state which it should never be. The best thing in this case is for the process to crash (this isn't necessarily the case though, due to the catchall Exception handlers in QuorumPeer)."", 'commenter': 'ivankelly'}, {'comment': '@ivankelly @eolivelli This is the serialize() method of FileSnap. Call chain is:\r\nFileSnap.serialize() <- FileTxnSnapLog.save() <- ZooKeeperServer.takeSnapshot()\r\n\r\n`takeSnapshot()` catches IOException and call system exit with error code of `TXNLOG_ERROR_TAKING_SNAPSHOT`. Sounds like this should be the expected behavior.', 'commenter': 'anmolnar'}, {'comment': 'Ok, IOException works in that case. ', 'commenter': 'ivankelly'}]"
1233,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -595,7 +600,9 @@ public void rollLog() throws IOException {
      */
     public void close() throws IOException {
         txnLog.close();
+        txnLog = null;","[{'comment': 'if you set this variable to null then calling twice this method will result in an ugly NullPointerException\r\nwhat about\r\n```\r\ntry {\r\nif (txnLog != null) {\r\n      txnLog.close();\r\n}\r\n}\xa0finally {\r\ntxnLog = null;\r\n}\r\n\r\n```', 'commenter': 'eolivelli'}, {'comment': 'Done', 'commenter': 'anmolnar'}]"
1233,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -595,7 +600,9 @@ public void rollLog() throws IOException {
      */
     public void close() throws IOException {
         txnLog.close();
+        txnLog = null;
         snapLog.close();
+        snapLog = null;","[{'comment': 'the same here', 'commenter': 'eolivelli'}, {'comment': 'Done.', 'commenter': 'anmolnar'}]"
1235,zookeeper-server/src/test/java/org/apache/zookeeper/ClientCnxnSocketFragilityTest.java,"@@ -0,0 +1,310 @@
+package org.apache.zookeeper;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.util.Queue;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;","[{'comment': 'Some imports are never used, also notice the useless field in this class(e.g: `scheduledExecutor`)', 'commenter': 'maoling'}, {'comment': 'Thanks for comment. Accept it. I miss the check for unused field. I will fix it.', 'commenter': 'yfxhust'}]"
1235,zookeeper-server/src/test/java/org/apache/zookeeper/ClientCnxnSocketFragilityTest.java,"@@ -0,0 +1,310 @@
+package org.apache.zookeeper;","[{'comment': 'LICENSE ?', 'commenter': 'maoling'}, {'comment': 'Thanks for comment. Accept it. I will add LICENSE statement in the test case.', 'commenter': 'yfxhust'}]"
1235,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -782,6 +782,10 @@ void queueCallback(AsyncCallback cb, int rc, String path, Object ctx) {
         eventThread.queueCallback(cb, rc, path, ctx);
     }
 
+    protected void onConnecting(InetSocketAddress addr) {
+        LOG.info(""Connecting server {}."", addr);
+    }
+","[{'comment': '- I wonder whether a log is needed here? because I found the `logStartConnect` in the `SendThread#startConnect`?\r\n- If needed, `LOG.info(""Start to reconnect to server {}."", addr); `or `LOG.info(""Try to reconnect to server {}."", addr)`; is better?', 'commenter': 'maoling'}, {'comment': 'Actually onConnecting() method is added to facilitate the test case. onConnecting() is placed at the unsafe point that is described in JIRA issue. We can override this method to inject some actions in test case. The injected actions make issue happen. If we don\'t have this method, it is difficult to construct a test case to reproduce the issue.\r\nYour suggestion of log changing is good for me. Accept it. I will change the log to ""Try to connect to server {}.""  I change the word ""reconnect"" to ""connect"" in your word. I think ""connect"" is better because the first connect also can hit here. The first connect attempt should not be treated as ""reconnect"".  \r\nThanks for your comments.', 'commenter': 'yfxhust'}]"
1235,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -1121,6 +1125,9 @@ private void startConnect(InetSocketAddress addr) throws IOException {
                     LOG.warn(""Unexpected exception"", e);
                 }
             }
+            if (!state.isAlive()) {
+                throw new RuntimeException(""Already closed"");
+            }","[{'comment': 'Just as you said, this issue happens when network is broken, so `IOException` is better? e.g. \r\n`throw new IOException(""Socket has already closed when reconnecting to ""+ addr);`', 'commenter': 'maoling'}, {'comment': 'I prefer RuntimeException. In my opinion, IOException indicates the actual physical network is broken. But I think it is not proper to throw IOException here. Here it is software issue that misses the state check. The direct reason is not a real physical network broken.  I think that throwing of IOException here would confuse the users. So I still prefer to use RuntimeException here.', 'commenter': 'yfxhust'}, {'comment': ""`RuntimeException` indicates unrecoverable programming error - such as illegal arguments or unrecoverable errors. Our case here is not that dramatic, it's recoverable by throwing an IOException if the state is `CLOSED` and it's being set to another value. `CLOSED` state will signal `SenderThread` to terminate and the benefit is we will be able to clean up resources - like the sockets sender thread held, and more importantly, the event thread will also be properly shutdown. \r\nAnd since we are explicitly programming in this issue to prevent this error, it does not sound like a logic error to me that worth to throw a RuntimeException."", 'commenter': 'hanm'}, {'comment': 'Both of you convince me. Now I throw IOException in SendThread.setZkState(). Please check the latest patch ', 'commenter': 'yfxhust'}]"
1235,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -1121,6 +1125,9 @@ private void startConnect(InetSocketAddress addr) throws IOException {
                     LOG.warn(""Unexpected exception"", e);
                 }
             }
+            if (!state.isAlive()) {","[{'comment': 'I suspect this will not completely fix the race condition between setting the state to closed and connecting. Another thread could set the state to close immediately after this check but before the subsequent `state = States.CONNECTING;` statement. We could make sure that this ""check and assign"" operation is atomic to completely address the race condition.', 'commenter': 'hanm'}, {'comment': 'Thanks for your comments. I agree with your concern. I would add synchronized(state) to ensure the atomic operation. I also add synchronized(state) guard at SendThread.close() to set state as States.CLOSED. I think these guards can resolve the problem.', 'commenter': 'yfxhust'}, {'comment': 'synchronized(state) is still not safe. Maybe SendThread.close() and SendThread.startConnect() synchronize on different objects because state is mutable and can be changed between SendThread.close() and SendThread.startConnect().\r\nI prefer synchronized(this) guard to lock on SendThread..', 'commenter': 'yfxhust'}, {'comment': ""I think this will work. \r\n\r\nI would recommend instead of doing the check here, we add a set of new `synchronized` methods to `SenderThread` where we get and set the states of the `SenderThread.state`. Then, we can move the checks in the `setState` method, where we can put constraints on how the connection state may transit. For example, we can enforce in that method that a `CLOSED` state can't be transit to a different state, which will prevent the problem we are seeing in this issue (that setting a state to `CONNECTING` after being in `CLOSED` state). This has additional benefits as currently, there are multiple write paths to the `SenderThread.state`, and by consolidate read and write access of the state in these synchronized methods, we can be sure there will not be future race conditions w.r.t accessing this state variable.\r\n\r\nI also thought about an alternative - instead of synchronizing on `SenderThread`, we could wrap the state variable in an `AtomicReference` and then provide get/set/compareAndSet methods on top of the atomic reference. This however is less flexible to allow us to control how the state could transit, so it still looks to me that  synchronizing on `SenderThread` is better."", 'commenter': 'hanm'}, {'comment': 'Accept it. Now I make a new method SendThread.setZkState() with checked IOException. Please check the latest patch.', 'commenter': 'yfxhust'}]"
1235,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -782,6 +782,10 @@ void queueCallback(AsyncCallback cb, int rc, String path, Object ctx) {
         eventThread.queueCallback(cb, rc, path, ctx);
     }
 
+    protected void onConnecting(InetSocketAddress addr) {
+        LOG.info(""Try to connect to server {}."", addr);","[{'comment': 'Since the primary reason of adding this is for injection in unit tests, I\'d suggest we mark this method which a comment like ""for tests only"", and remove the log statement which if leaving as is, will create a lot of noises in client side logs. We can still override an empty method in test implementation.', 'commenter': 'hanm'}, {'comment': 'Thanks your comments. Accept it. I will add comments to declare it as ""for test only"" and leave this method as empty.', 'commenter': 'yfxhust'}]"
1235,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -971,10 +980,20 @@ void readResponse(ByteBuffer incomingBuffer) throws IOException {
          *
          * @return
          */
-        ZooKeeper.States getZkState() {
+        synchronized ZooKeeper.States getZkState() {
             return state;
         }
 
+        synchronized void setZkState(ZooKeeper.States newState) throws IOException {
+            if (!state.isAlive()) {
+                if (newState == States.CONNECTING) {
+                    throw new IOException(","[{'comment': '`if (!state.isAlive() && newState == States.CONNECTING)` ?', 'commenter': 'maoling'}, {'comment': 'Thank you for your comments.\r\nCurrent implementation seems more structural for future evaluation because it will handle more scenarios.\r\nBut anyway I accept your suggestion. Your suggestion seems more compact.', 'commenter': 'yfxhust'}]"
1235,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -1179,6 +1198,7 @@ public void run() {
                         } else {
                             serverAddress = hostProvider.next(1000);
                         }
+                        ClientCnxn.this.onConnecting(serverAddress);
                         startConnect(serverAddress);","[{'comment': '`onConnecting(serverAddress);`  ?', 'commenter': 'maoling'}, {'comment': 'Accept it. Good suggestion.', 'commenter': 'yfxhust'}]"
1235,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -971,10 +980,20 @@ void readResponse(ByteBuffer incomingBuffer) throws IOException {
          *
          * @return
          */
-        ZooKeeper.States getZkState() {
+        synchronized ZooKeeper.States getZkState() {
             return state;","[{'comment': '`state` is already modified by `volatile`, so `synchronized` is no need ?', 'commenter': 'maoling'}, {'comment': 'Thank you for your comments.\r\nspotbugs-maven-plugin:3.1.9:check may report error for UG_SYNC_SET_UNSYNC_GET if remove `synchronized` from getZkState because we have synchronized setZkState. \r\nAnother reason of adding `synchronized` is to prevent future risk if we add more complex task in setZkState() in future.\r\nIn current implementation, we have implicit convention for setZkSate() - state modification must be placed at the end of setZkState() otherwise incomplete internal state may be exposed to outside. Adding `synchronized` to getZkState() can avoid this risk because getZkState() only be allowed to interleave execution with the whole setZkState().\r\n\r\nAnyway I accept your suggestion. Maybe it has potential performance benefit if I remove `synchronized` from getZkState(). I will add more comments to clarify the implicit convention of state modification and rename setZkState() to changZkState() to make spotbugs-maven-plugin happy.', 'commenter': 'yfxhust'}, {'comment': ""I actually prefer the previous synchronized getZkState() approach - it's simple and consistent and easy to understand than the current approach. It's good to have performance in mind, but unless there is a real bottleneck, I would always choose simple code over premature optimization."", 'commenter': 'hanm'}, {'comment': 'Thank you for your comments.\r\nYou convince me. Accept it. Add `synchronized` back to getZkState()', 'commenter': 'yfxhust'}]"
1235,zookeeper-server/src/test/java/org/apache/zookeeper/ClientCnxnSocketFragilityTest.java,"@@ -0,0 +1,321 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.util.Queue;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import org.apache.zookeeper.ClientCnxn.Packet;
+import org.apache.zookeeper.Watcher.Event.KeeperState;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.client.HostProvider;
+import org.apache.zookeeper.client.ZKClientConfig;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class ClientCnxnSocketFragilityTest extends QuorumPeerTestBase {
+
+    private static final int SERVER_COUNT = 3;
+
+    private static final int SESSION_TIMEOUT = 40000;
+
+    public static final int CONNECTION_TIMEOUT = 30000;
+
+    private final UnsafeCoordinator unsafeCoordinator = new UnsafeCoordinator();
+
+    private volatile CustomZooKeeper zk = null;
+
+    private volatile FragileClientCnxnSocketNIO socket = null;
+
+    private volatile CustomClientCnxn cnxn = null;
+
+    private String getCxnString(int[] clientPorts) {
+        StringBuffer hostPortBuffer = new StringBuffer();
+        for (int i = 0; i < clientPorts.length; i++) {
+            hostPortBuffer.append(""127.0.0.1:"");
+            hostPortBuffer.append(clientPorts[i]);
+            if (i != (clientPorts.length - 1)) {
+                hostPortBuffer.append(',');
+            }
+        }
+        return hostPortBuffer.toString();
+    }
+
+    private void closeZookeeper(ZooKeeper zk) {
+        Executors.newSingleThreadExecutor().submit(() -> {
+            try {
+                LOG.info(""closeZookeeper is fired"");
+                zk.close();
+            } catch (InterruptedException e) {
+            }
+        });
+    }
+
+    private void getDataBackgroundRetryForever(CustomZooKeeper zk, String path) {
+        new Thread(() -> {
+            for (;;) {
+                try {
+                    zk.getData(path, false, new Stat());
+                } catch (Exception e) {
+                }
+            }
+        }).start();
+    }
+
+    @Test
+    public void testClientCnxnSocketFragility() throws Exception {
+        System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, FragileClientCnxnSocketNIO.class.getName());
+        System.setProperty(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT, ""1000"");
+        final int[] clientPorts = new int[SERVER_COUNT];
+        StringBuilder sb = new StringBuilder();
+        String server;
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            clientPorts[i] = PortAssignment.unique();
+            server = ""server."" + i + ""=127.0.0.1:"" + PortAssignment.unique() + "":"" + PortAssignment.unique()
+                     + "":participant;127.0.0.1:"" + clientPorts[i];
+            sb.append(server + ""\n"");
+        }
+        String currentQuorumCfgSection = sb.toString();
+        MainThread[] mt = new MainThread[SERVER_COUNT];
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);
+            mt[i].start();
+        }
+
+        // Ensure server started
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            Assert.assertTrue(
+                ""waiting for server "" + i + "" being up"",
+                ClientBase.waitForServerUp(""127.0.0.1:"" + clientPorts[i], CONNECTION_TIMEOUT));
+        }
+        String path = ""/testClientCnxnSocketFragility"";
+        String data = ""balabala"";
+        ClientWatcher watcher = new ClientWatcher();
+        zk = new CustomZooKeeper(getCxnString(clientPorts), SESSION_TIMEOUT, watcher);
+        watcher.watchFor(zk);
+
+        // Let's see some successful operations
+        zk.create(path, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+        Assert.assertEquals(new String(zk.getData(path, false, new Stat())), data);
+        Assert.assertTrue(!watcher.isSessionExpired());
+
+        // Let's make a broken operation
+        socket.mute();
+        boolean catchKeeperException = false;
+        try {
+            zk.getData(path, false, new Stat());
+        } catch (KeeperException e) {
+            catchKeeperException = true;
+            Assert.assertFalse(e instanceof KeeperException.SessionExpiredException);
+        }
+        socket.unmute();
+        Assert.assertTrue(catchKeeperException);
+        Assert.assertTrue(!watcher.isSessionExpired());
+
+        getDataBackgroundRetryForever(zk, path);
+        // Let's make a broken network
+        socket.mute();
+
+        // Let's attempt to close ZooKeeper
+        cnxn.attemptClose();
+
+        // Wait some time to expect continuous reconnecting.
+        // We try to make reconnecting hit the unsafe point.
+        TimeUnit.MILLISECONDS.sleep(3000);","[{'comment': 'Is it possible to instead of using sleep, we do explicit synchronization and only execute when certain criteria is satisfied? We generally discourage the usage of sleep in zookeeper unit test as the use of sleep proved to be a source of flaky-ness in the past when running on different environment.', 'commenter': 'hanm'}, {'comment': 'Thanks for your comments.\r\nAgree with you. I add CustomClientCnxn.waitUntilHitUnsafeRegion(). It ensures the unsafe region is hit. Please see the latest patch. ', 'commenter': 'yfxhust'}]"
1235,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -957,7 +962,11 @@ void readResponse(ByteBuffer incomingBuffer) throws IOException {
 
         SendThread(ClientCnxnSocket clientCnxnSocket) {
             super(makeThreadName(""-SendThread()""));
-            state = States.CONNECTING;
+            try {
+                changeZkState(States.CONNECTING);
+            } catch (IOException e) {
+                throw new RuntimeException(""Connection setup failed when migrate state to CONNECTING"");","[{'comment': 'Throwing a RuntimeException may lead to unexpected behaviour. \r\nSo we have a way to throw a checked exception and deal explicitly with this case?', 'commenter': 'eolivelli'}]"
1235,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -1428,7 +1447,10 @@ void onConnected(
         }
 
         void close() {
-            state = States.CLOSED;
+            try {
+                changeZkState(States.CLOSED);
+            } catch (IOException e) {","[{'comment': ""Please add a comment\r\nWe could anyway spend a line of log, thus case won't happen but if it is happening we won't know"", 'commenter': 'eolivelli'}]"
1235,zookeeper-server/src/test/java/org/apache/zookeeper/ClientCnxnSocketFragilityTest.java,"@@ -0,0 +1,333 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.util.Queue;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import org.apache.zookeeper.ClientCnxn.Packet;
+import org.apache.zookeeper.Watcher.Event.KeeperState;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.client.HostProvider;
+import org.apache.zookeeper.client.ZKClientConfig;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class ClientCnxnSocketFragilityTest extends QuorumPeerTestBase {
+
+    private static final int SERVER_COUNT = 3;
+
+    private static final int SESSION_TIMEOUT = 40000;
+
+    public static final int CONNECTION_TIMEOUT = 30000;
+
+    private final UnsafeCoordinator unsafeCoordinator = new UnsafeCoordinator();
+
+    private volatile CustomZooKeeper zk = null;
+
+    private volatile FragileClientCnxnSocketNIO socket = null;
+
+    private volatile CustomClientCnxn cnxn = null;
+
+    private String getCxnString(int[] clientPorts) {
+        StringBuffer hostPortBuffer = new StringBuffer();
+        for (int i = 0; i < clientPorts.length; i++) {
+            hostPortBuffer.append(""127.0.0.1:"");
+            hostPortBuffer.append(clientPorts[i]);
+            if (i != (clientPorts.length - 1)) {
+                hostPortBuffer.append(',');
+            }
+        }
+        return hostPortBuffer.toString();
+    }
+
+    private void closeZookeeper(ZooKeeper zk) {
+        Executors.newSingleThreadExecutor().submit(() -> {
+            try {
+                LOG.info(""closeZookeeper is fired"");
+                zk.close();
+            } catch (InterruptedException e) {
+            }
+        });
+    }
+
+    private void getDataBackgroundRetryForever(CustomZooKeeper zk, String path) {
+        new Thread(() -> {
+            for (;;) {","[{'comment': ""Please use a daemon thread.\r\nI wonder of we can create a safer way to stop this thread.\r\nI wouldn't like to leak this thread during the execution of the test suite.\r\nIt could easily use a CPU at 100%"", 'commenter': 'eolivelli'}]"
1242,zookeeper-server/src/main/java/org/apache/zookeeper/server/NIOServerCnxn.java,"@@ -81,6 +81,11 @@
      */
     private long sessionId;
 
+    /**
+     * Client socket option for TCP keepalive
+     */
+    private final boolean clientTcpKeepAlive = Boolean.getBoolean(""zookeeper.clientTcpKeepAlive"");
+","[{'comment': 'please doc this new property in the `zookeeperAdmin.md`', 'commenter': 'maoling'}, {'comment': 'Thanks your comments. Accept it. I add items in zookeeperAdmin in latest patch. Please review it.', 'commenter': 'yfxhust'}]"
1251,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1584,6 +1596,16 @@ and [SASL authentication for ZooKeeper](https://cwiki.apache.org/confluence/disp
     (e.g. the zk/myhost@EXAMPLE.COM client principal will be authenticated in ZooKeeper as zk/myhost)
     Default: false
 
+* *multiAddress.enable* :","[{'comment': 'multiAddress.enabled', 'commenter': 'eolivelli'}, {'comment': 'nice catch, thanks!', 'commenter': 'symat'}]"
1251,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/QuorumPeerMainMultiAddressTest.java,"@@ -230,6 +233,29 @@ public void shouldReconfigIncrementally_IPv6() throws Exception {
     checkIfZooKeeperQuorumWorks(newQuorumConfig);
   }
 
+  @Test(expected = KeeperException.class)","[{'comment': ""this way of testing for an expected exception is too broad, you don't know where KeeperException has been thrown.\r\nI suggest to push the assertion around the  ReconfigTest.reconfig call"", 'commenter': 'eolivelli'}, {'comment': ""thanks, it's nicer that way indeed, I will fix it"", 'commenter': 'symat'}]"
1251,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1584,6 +1596,16 @@ and [SASL authentication for ZooKeeper](https://cwiki.apache.org/confluence/disp
     (e.g. the zk/myhost@EXAMPLE.COM client principal will be authenticated in ZooKeeper as zk/myhost)
     Default: false
 
+* *multiAddress.enable* :
+    (Java system property: **zookeeper.multiAddress.enable**)","[{'comment': 'Same here, missing the d (internet has ruined me, no pun intended)', 'commenter': 'nkalmar'}, {'comment': 'true, thanks. :)', 'commenter': 'symat'}]"
1251,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -639,7 +657,7 @@ public void toSend(Long sid, ByteBuffer b) {
     synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) {
         if (senderWorkerMap.get(sid) != null) {
             LOG.debug(""There is a connection already for server {}"", sid);
-            if (electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {
+            if (electionAddr.size() > 1 && self.isMultiAddressEnabled() && self.isMultiAddressReachabilityCheckEnabled()) {","[{'comment': 'Why do you need the ""enabled"" check here?', 'commenter': 'anmolnar'}, {'comment': 'Does not do any harm though... move it to the beginning of `if` please.', 'commenter': 'anmolnar'}, {'comment': ""you are right, actually if multi-address is disabled, then we can't have more than one address anyway. Still, I think it is good to have the extra condition there (if for nothing else, maybe just to make the code easier to understand)\r\nI will move it to the beginning."", 'commenter': 'symat'}]"
1251,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -113,9 +115,12 @@
     private AtomicLong observerCounter = new AtomicLong(-1);
 
     /*
-     * Protocol identifier used among peers
+     * Protocol identifier used among peers (must be a negative number for backward compatibility reasons)
      */
-    public static final long PROTOCOL_VERSION = -65535L;
+    // the following protocol version was sent in every connection initiation message since ZOOKEEPER-2186 released in 3.4.7
+    public static final long PROTOCOL_VERSION_3_4_7 = -65536L;","[{'comment': 'I would call this constant PROTOCOL_VERSION_V1\r\nand the other one PROTOCOL_VERSION_V2', 'commenter': 'eolivelli'}, {'comment': ""The reason why I named this way was that I am not sure if we won't need to add other previous versions later (e.g. to support rolling restart from pre-3.4.7 versions). But giving a second thought, I like your proposal better. These are just constants, we can rename them later in any ways. I will change this in the next commit."", 'commenter': 'symat'}]"
1251,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -416,10 +424,20 @@ private boolean startConnection(Socket sock, Long sid) throws IOException {
 
             // Sending id and challenge
 
-            // represents protocol version (in other words - message type)
-            dout.writeLong(PROTOCOL_VERSION);
+            // First sending the protocol version (in other words - message type).
+            // For backward compatibility reasons we stick to the old protocol version, unless the MultiAddress
+            // feature is enabled. During rolling upgrade, we must make sure that all the servers can
+            // understand the protocol version we use to avoid multiple partitions. see ZOOKEEPER-3720
+            long protocolVersion = self.isMultiAddressEnabled() ? PROTOCOL_VERSION_3_6_0_MULTI_ADDRESS : PROTOCOL_VERSION_3_4_7;
+            dout.writeLong(protocolVersion);","[{'comment': ""In case of new protocol (v2) I would like to spend here a 64bit long of 'flags' (filled with zeros in 3.6.0) in order to introduce a more futureproof 'feature detection' that is better than using protocol version numbers.\r\n\r\nWe can then add 'multiaddress' as an enabled feature.\r\n\r\nWe should do more reasoning and design steps but this way of coding the initial handshake is quite common and it will open up the way for future improvements.\r\n\r\n"", 'commenter': 'eolivelli'}, {'comment': ""Thanks, I really like this idea with the 'feature flags', I will change accordingly. \r\n\r\nThe only constraint is that the version number must be negative. I think I saw in the git history, that some years ago, when the protocol version was not introduced yet, this was the way how someone solved the introduction of versioning. The old code sent some positive sid or message size, and the new code sent a negative version number. This way enforcing the old code to break and throw away the message, while the new code was able to verify if it got the message in the new format based on the negative number. But I need to double-check this tomorrow, maybe I remember wrong.\r\n\r\nAnd also there can be maybe 1-2 negative numbers already used as protocol versions, so I will check which bits are still available.\r\n\r\nAlthough I think it is enough to support the rolling upgrade from the first stable 3.4 release, which can simplify things, and we don't need to go back in time in the code too much."", 'commenter': 'symat'}, {'comment': ""OK, I did some deeper digging in the git history, this is what I found:\r\n\r\nThe different version numbers / behaviors we had before:\r\n- protocol version originally introduced by ZOOKEEPER-107 in 3.5.0\r\n- before 3.5.0, always a positive SID was sent in the beginning of the connection initiation message and there were no address information there. Even 3.4.14 still only sends a positive SID.\r\n- since ZOOKEEPER-107 (in 3.5.0+): version -65536L (0xffff0000) was sent, and on the receiver side:\r\n   - if any positive (incl. 0) Long number received, then accept the number as SID and get the address from the own config\r\n   - if -65536L was received, then parsing the message with the new format and use the address provided there\r\n   - for any other negative numbers, we fail\r\n - in ZOOKEEPER-1633 (3.4.7), the receiver logic was making more clever to expect the SID as the second Long in the message, if the first Long was negative. So from 3.4.7 all the 3.4 servers can at least not die due to the new message formats, and rolling upgrades become possible without multiple partitions. However, all 3.4.X still sends only the positive SID and will not use any address information from the initial message (just reads the SID).\r\n\r\nThis also means, that we can choose any negative number as new protocol version for the MultiAddress feature, and then the rolling upgrade from 3.4.7-3.4.14 to 3.6.0 could work theoretically even with MultiAddress enabled, as long as we always send the SID right after the protocol version.\r\n\r\nBut the value of the protocol version is actually checked in 3.5.0, so we definitely need to disable MultiAddress to be able to get the rolling upgrade to work from 3.5.\r\n\r\nLong story short: we only have a single protocol version, -65536 (0xffff0000) as of now, plus the case when positive numbers are sent. The -65535 (0xffff0001) seems to me a good protocol version candidate for the multiaddress compatible protocol, since it is also only a single bit difference between the two. So if later we will introduce the 'feature flags' we can already say that the last bit represented the multiaddress feature. \r\n\r\nWhat do you think? (maybe I misunderstood your proposal here)\r\n\r\nBut I just don't know how this whole thing should look in the later releases. Also this whole protocol version is now only about the initial message. We don't know if there is any other incompatibility between the other messages."", 'commenter': 'symat'}, {'comment': ""@eolivelli what do you think?\r\n\r\nshould we add the 'feature flags' implementation here in 3.6.0? Or is it enough if we choose a new optional version number that differs only in a single bit to the current version number, so that we are keeping this possibility of 'feature flags' open for the future? (currently we have only a single 'feature' anyway) \r\n\r\nI am not sure if it worths to push for a more generic solution, given that we don't really know yet how to design this in the future."", 'commenter': 'symat'}]"
1254,zookeeper-server/src/test/java/org/apache/zookeeper/test/QuorumRestartTest.java,"@@ -0,0 +1,131 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import static org.apache.zookeeper.client.ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET;
+import static org.junit.Assert.assertTrue;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class QuorumRestartTest extends ZKTestCase {
+
+    private static final Logger LOG = LoggerFactory.getLogger(QuorumRestartTest.class);
+    private QuorumUtil qu;
+
+    @Before
+    public void setUp() throws Exception {
+        System.setProperty(ZOOKEEPER_CLIENT_CNXN_SOCKET, ""org.apache.zookeeper.ClientCnxnSocketNetty"");","[{'comment': 'Clear these properties in tearDown', 'commenter': 'eolivelli'}, {'comment': '@symat  please take a look to this comment', 'commenter': 'eolivelli'}, {'comment': 'nice catch, thank you!', 'commenter': 'symat'}]"
1254,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -552,10 +577,13 @@ private void handleConnection(Socket sock, DataInputStream din) throws IOExcepti
                 try {
                     InitialMessage init = InitialMessage.parse(protocolVersion, din);
                     sid = init.sid;
-                    electionAddr = new MultipleAddresses(init.electionAddr,
-                        Duration.ofMillis(self.getMultiAddressReachabilityCheckTimeoutMs()));
+                    if (!init.electionAddr.isEmpty()) {","[{'comment': ""This is for my understanding only:\r\nIn case of multiple Addresses(if one of the address is the wildcard address and other is not), this will connect to that address. In other words, we will be calling connectOne(sid, electionAddr) and not connectOne(sid).\r\nWas wondering what if we always called connectOne(sid)?\r\nI'm just afraid what if we get some address that is not wildcard address but is still NOT connectible. Should we be connecting to the last known address in config for that SID which connectOne(sid) does.\r\n\r\n\r\n\r\n"", 'commenter': 'suhasdantkale'}, {'comment': 'But, I think we can worry about that when we run into that. Your debug messages will be useful for that.', 'commenter': 'suhasdantkale'}, {'comment': ""well, theoretically it is possible that someone adds both wildcard address and normal IP / FQDN for a multi-address config, but that doesn't make much sense. I would rather throw an exception at startup in this case... The whole point of multi-address is to use different networks for redundancy, so you should always provide FQDN / IP there."", 'commenter': 'symat'}]"
1254,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -266,12 +267,33 @@ public static InitialMessage parse(Long protocolVersion, DataInputStream din) th
                 } catch (ArrayIndexOutOfBoundsException e) {
                     throw new InitialMessageException(""No port number in: %s"", addr);
                 }
-                addresses.add(new InetSocketAddress(host_port[0], port));
+                if (!isWildcardAddress(host_port[0])) {
+                    addresses.add(new InetSocketAddress(host_port[0], port));
+                }
             }
 
             return new InitialMessage(sid, addresses);
         }
 
+        /**
+         * Returns true if the specified hostname is a wildcard address,
+         * like 0.0.0.0 for IPv4 or :: for IPv6
+         *
+         * (the function is package-private to be visible for testing)
+         */
+        static boolean isWildcardAddress(final String hostname) {
+            try {
+                return InetAddress.getByName(hostname).isAnyLocalAddress();
+            } catch (UnknownHostException e) {
+                // if we can not resolve, it can not be a wildcard address
+                return false;","[{'comment': 'I think if we cannot resolve this address, we should be still taking care of not adding this address to the electionAddr() in the caller function - parse().\r\nMay be in that case should be return true from this function and change the name of the function to reflect that(?)\r\nBecause in that case we are not only checking the wildcard addresses, but also the unresolvable hostnames(?)\r\nOR should we just have one Warning message here saying that the Initial message has the unresolvable hostname(?)', 'commenter': 'suhasdantkale'}, {'comment': ""The reasoning here is, that even if in this particular time we can not resolve the hostname, it is possible we will be able to do so in the future. So I wouldn't throw it away. In case of multi-address, if there are multiple addresses provided, then we will start to establish connections in parallel for all of them and keeping the one that is alive.\r\n"", 'commenter': 'symat'}]"
1254,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/CnxManagerTest.java,"@@ -667,6 +667,17 @@ public void testInitialMessage() throws Exception {
         }
     }
 
+    @Test
+    public void testWildcardAddressRecognition() {","[{'comment': 'Nice test!\r\nInterested to know what happens in case of IPv6 loopback address like ""::1"" ', 'commenter': 'suhasdantkale'}]"
1254,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java,"@@ -266,12 +267,33 @@ public static InitialMessage parse(Long protocolVersion, DataInputStream din) th
                 } catch (ArrayIndexOutOfBoundsException e) {
                     throw new InitialMessageException(""No port number in: %s"", addr);
                 }
-                addresses.add(new InetSocketAddress(host_port[0], port));
+                if (!isWildcardAddress(host_port[0])) {
+                    addresses.add(new InetSocketAddress(host_port[0], port));
+                }
             }
 
             return new InitialMessage(sid, addresses);
         }
 
+        /**
+         * Returns true if the specified hostname is a wildcard address,
+         * like 0.0.0.0 for IPv4 or :: for IPv6
+         *
+         * (the function is package-private to be visible for testing)
+         */
+        static boolean isWildcardAddress(final String hostname) {
+            try {
+                return InetAddress.getByName(hostname).isAnyLocalAddress();
+            } catch (UnknownHostException e) {","[{'comment': 'Looks like getByName() can also throw SecurityException. Should we handle this gracefully or log the warning somewhere for easier debugging?', 'commenter': 'suhasdantkale'}, {'comment': 'good question... that is an unchecked exception, which I think kind of indicate that we will not be able to start ZooKeeper properly. I am fine just simply die in this case (most probably in this case we will never reach this point). But adding an extra log here can not hurt...', 'commenter': 'symat'}]"
1254,zookeeper-server/src/test/java/org/apache/zookeeper/test/QuorumRestartTest.java,"@@ -0,0 +1,131 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import static org.apache.zookeeper.client.ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET;
+import static org.junit.Assert.assertTrue;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class QuorumRestartTest extends ZKTestCase {","[{'comment': 'Nice tests!', 'commenter': 'suhasdantkale'}]"
1254,zookeeper-server/src/test/java/org/apache/zookeeper/test/QuorumUtil.java,"@@ -97,7 +101,7 @@ public QuorumUtil(int n, int syncLimit) throws RuntimeException {
             N = n;
             ALL = 2 * N + 1;
             tickTime = 2000;
-            initLimit = 3;
+            initLimit = 5;","[{'comment': 'why are you changing this value ?', 'commenter': 'eolivelli'}, {'comment': ""It is unnecessary, doesn't make any difference, thanks for noticing it.\r\nI just committed this by accident, I will revert."", 'commenter': 'symat'}]"
1266,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/QuorumPeerConfigTest.java,"@@ -164,6 +164,31 @@ public void testJvmPauseMonitorConfigured() throws IOException, ConfigException
         assertTrue(quorumPeerConfig.isJvmPauseMonitorToRun());
     }
 
+    /**
+     * Test case for https://issues.apache.org/jira/browse/ZOOKEEPER-3721
+     */
+    @Test
+    public void testParseBoolean() throws IOException, ConfigException {
+        QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();
+        Properties zkProp = getDefaultZKProperties();
+
+        zkProp.setProperty(""localSessionsEnabled"", ""true"");
+        quorumPeerConfig.parseProperties(zkProp);
+        assertEquals(true, quorumPeerConfig.areLocalSessionsEnabled());
+
+        zkProp.setProperty(""localSessionsEnabled"", ""false"");
+        quorumPeerConfig.parseProperties(zkProp);
+        assertEquals(false, quorumPeerConfig.areLocalSessionsEnabled());
+
+        zkProp.setProperty(""localSessionsEnabled"", ""yes"");
+        try {
+            quorumPeerConfig.parseProperties(zkProp);
+            fail(""Must throw exception as 'yes' is not accpetable for parseBoolean!"");","[{'comment': 'we also need to assert `True` or `False` ?', 'commenter': 'maoling'}, {'comment': 'Do you mean things like:\r\n```\r\nzkProp.setProperty(""localSessionsEnabled"", ""True"");\r\nquorumPeerConfig.parseProperties(zkProp);\r\nassertEquals(true, quorumPeerConfig.areLocalSessionsEnabled());\r\n\r\nzkProp.setProperty(""localSessionsEnabled"", ""False"");\r\nquorumPeerConfig.parseProperties(zkProp);\r\nassertEquals(false, quorumPeerConfig.areLocalSessionsEnabled());\r\n```\r\nto test whether ignoring case can work?', 'commenter': 'ctest-team'}, {'comment': 'Yes it is', 'commenter': 'maoling'}]"
1266,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java,"@@ -969,4 +953,15 @@ public static void setReconfigEnabled(boolean enabled) {
         reconfigEnabled = enabled;
     }
 
+    private boolean parseBoolean(String value) throws ConfigException {
+        if (value.equalsIgnoreCase(""true"")) {
+            return true;
+        } else if (value.equalsIgnoreCase(""false"")) {
+            return false;
+        } else {
+            throw new ConfigException(""Invalid option ""","[{'comment': 'please also log the parameter name, helping the users to find out which config is wrong.', 'commenter': 'symat'}]"
1266,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java,"@@ -335,48 +335,32 @@ public void parseProperties(Properties zkProp) throws IOException, ConfigExcepti
                     throw new ConfigException(""Unrecognised peertype: "" + value);
                 }
             } else if (key.equals(""syncEnabled"")) {
-                syncEnabled = Boolean.parseBoolean(value);
+                syncEnabled = parseBoolean(key, value);
             } else if (key.equals(""dynamicConfigFile"")) {
                 dynamicConfigFileStr = value;
             } else if (key.equals(""autopurge.snapRetainCount"")) {
                 snapRetainCount = Integer.parseInt(value);
             } else if (key.equals(""autopurge.purgeInterval"")) {
                 purgeInterval = Integer.parseInt(value);
             } else if (key.equals(""standaloneEnabled"")) {
-                if (value.toLowerCase().equals(""true"")) {
-                    setStandaloneEnabled(true);
-                } else if (value.toLowerCase().equals(""false"")) {
-                    setStandaloneEnabled(false);
-                } else {
-                    throw new ConfigException(""Invalid option ""
-                                              + value
-                                              + "" for standalone mode. Choose 'true' or 'false.'"");
-                }
+                setStandaloneEnabled(parseBoolean(key, value));","[{'comment': 'We could have a version of parseBoolean that reports a better error message.\r\nOtherwise only the stacktrace can give an hint about which parameter is wrong\r\n\r\nI suggest to pass the name of the property to parseBoolean', 'commenter': 'eolivelli'}, {'comment': 'Hi @eolivelli , thank you for your review.\r\nI think the current `parseBoolean` already takes the name of the property -- `key`,\r\nand will log out `key` when throwing exception to tell users which parameter is wrong.', 'commenter': 'ctest-team'}]"
1269,zookeeper-server/src/main/java/org/apache/zookeeper/common/FileChangeWatcher.java,"@@ -72,7 +71,7 @@ public FileChangeWatcher(Path dirPath, Consumer<WatchEvent<?>> callback) throws
 
         LOG.debug(""Registering with watch service: {}"", dirPath);
 
-        dirPath.register(watchService, new WatchEvent.Kind<?>[]{StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.OVERFLOW}, SensitivityWatchEventModifier.HIGH);","[{'comment': ""Can't we detect the presence of that option at runtime and use it with reflection?\r\n\r\nWhat's the impact of this patch?\r\n\r\nCc @enixon PTAL"", 'commenter': 'eolivelli'}, {'comment': ""> Can't we detect the presence of that option at runtime and use it with reflection?\r\n\r\nCode to do that would look similar to what is described in:\r\nhttps://github.com/HotswapProjects/HotswapAgent/issues/41#issue-39256602\r\n\r\nHowever, because of module access restrictions in future JVMs, there's a strong possibility that doing this would result in runtime exceptions in newer JVMs, unless users added the `jdk.unsupported` module to their module path at runtime... and even then, these unsupported APIs are supposed to be phased out entirely at some point... so there's a good chance this will add complexity which will never matter, because the complex code path will never be traversed (or will be traversed and cause an access restriction error at runtime).\r\n\r\n> What's the impact of this patch?\r\n\r\nThat's the question I had, too (and the related: is it even worth it to try to keep the modifier?).\r\n\r\nFrom what I could tell, the behavior this modifies is not well defined anyway. On some systems, the modifier *could* make file changes observed more quickly... but there's no guarantee of that... and there's no guarantee of seeing *every* change event on the file being watched, no matter what modifier is on it. Even with the modifier, it's probably still going to be on the order of a few seconds to notice changes. In my opinion, it's probably not worth it, but I'm not an expert on NIO stuff by far.\r\n"", 'commenter': 'ctubbsii'}, {'comment': 'I think this code was contributed from Facebook\r\n\r\n@lvfangmin @enixon do you have any insight ?', 'commenter': 'eolivelli'}, {'comment': ""Looking into this a little bit more, it seems this utility is only ever used by the X509Util class to monitor changes to keyStore and trustStore files on disk, presumably for some sort of automatic reconfiguration.\r\n\r\nThe modifier seems to be an attempt to work around the slow polling implementation of the watch service on Mac OS X (https://bugs.openjdk.java.net/browse/JDK-7133447), which doesn't have a native implementation on that platform.\r\n\r\nI can't imagine those files changing frequently enough for this to matter. But, even if they did change, I can't imagine that the optimization to automatically reconfigure a few seconds sooner matters either.\r\n\r\nHowever, if rapid automatic TLS reconfiguration on OSX was a critical need for somebody... there are lots of alternative watch service implementations out there to work around this issue. One is https://github.com/takari/directory-watcher ; I'm not advocating for using any of these... I don't know enough about them, but if it was important for somebody, they could consider contributing a change that makes use of one of those, instead of relying on the com.sun modifier to the built-in watch service that this PR removes."", 'commenter': 'ctubbsii'}, {'comment': '@eolivelli If @lvfangmin and @enixon do not reply, what happens next?', 'commenter': 'ctubbsii'}, {'comment': ""Digging into this I also found a bunch of patch for OSX to speed up file change event.\r\n\r\nThere is not much info if this is still useful at all. In fact, most source (patch, stackoverflow etc.) I found are a few years old.\r\n\r\nAnd in any case, I don't think there are many running production ZK on OSX. (If this change would primarily affect Linux systems I would be more keen on doing further research)\r\n\r\nIn short, LGTM"", 'commenter': 'nkalmar'}]"
1269,pom.xml,"@@ -307,6 +307,26 @@
             </plugins>
         </build>
     </profile>
+    <profile>
+      <id>m2e</id>
+      <activation>
+        <property>
+          <name>m2e.version</name>
+        </property>
+      </activation>
+      <properties>
+        <maven.compiler.release>8</maven.compiler.release>
+      </properties>
+    </profile>
+    <profile>
+      <id>jdk-release-flag</id>
+      <activation>
+        <jdk>[9,)</jdk>
+      </activation>
+      <properties>
+        <maven.compiler.release>8</maven.compiler.release>","[{'comment': 'Good', 'commenter': 'eolivelli'}]"
1270,zookeeper-server/src/main/java/org/apache/zookeeper/jmx/ManagedUtil.java,"@@ -35,27 +35,25 @@
     private static boolean isLog4jJmxEnabled() {
         boolean enabled = false;
 
-        try {
-            Class.forName(""org.apache.log4j.spi.LoggerRepository"");
-
-            if (Boolean.getBoolean(""zookeeper.jmx.log4j.disable"")) {
-                LOG.info(""Log4j found but jmx support is disabled."");
-            } else {
+        if (Boolean.getBoolean(""zookeeper.jmx.log4j.disable"")) {
+            LOG.info(""Log4j 1.2 jmx support is disabled by property."");
+        } else {
+            try {
+                Class.forName(""org.apache.log4j.jmx.HierarchyDynamicMBean"");
                 enabled = true;
-                LOG.info(""Log4j found with jmx enabled."");
+                LOG.info(""Log4j 1.2 jmx support found and enabled."");
+            } catch (ClassNotFoundException e) {
+                LOG.info(""Log4j 1.2 jmx support not found; jmx disabled."");
             }
-
-        } catch (ClassNotFoundException e) {
-            LOG.info(""Log4j not found."");
         }
 
         return enabled;
     }
 
     /**
-     * Register the log4j JMX mbeans. Set environment variable
+     * Register the log4j JMX mbeans. Set system property
      * ""zookeeper.jmx.log4j.disable"" to true to disable registration.
-     * See http://logging.apache.org/log4j/1.2/apidocs/index.html?org/apache/log4j/jmx/package-summary.html
+     * @see http://logging.apache.org/log4j/1.2/apidocs/index.html?org/apache/log4j/jmx/package-summary.html","[{'comment': 'Just for curiosity:\r\nI am not sure it is a good thing to link to an external website using @see \r\nIt is not so relevant this link and javadoc tools may want to validate this link or to download?\r\n', 'commenter': 'eolivelli'}, {'comment': ""I'm not aware of any built-in link validation in javadoc. This just cleans it up slightly to use proper javadoc syntax to reference a resource."", 'commenter': 'ctubbsii'}, {'comment': 'I can change it back, though if you really want.', 'commenter': 'ctubbsii'}, {'comment': 'no problem from my side.\r\nI was just asking', 'commenter': 'eolivelli'}]"
1280,src/main/resources/markdown/releases.md,"@@ -27,27 +28,28 @@ Apache ZooKeeper 3.6.0 is our latest stable release.
 
 ### Apache ZooKeeper 3.6.0
 
-[Apache ZooKeeper 3.6.0](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0-bin.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0-bin.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0-bin.tar.gz.sha512))
+[Apache ZooKeeper 3.6.0](https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0-bin.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0-bin.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0-bin.tar.gz.sha512))
 
-[Apache ZooKeeper 3.6.0 Source Release](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0.tar.gz.sha512))
-
-You can verify the integrity of a downloaded release using the PGP signatures and hashes (MD5 or SHA1) hosted at the main [Apache distro site](https://apache.org/dist/zookeeper/).  For additional information, refer to the Apache documentation for [verifying the integrity of Apache project releases](https://www.apache.org/dyn/closer.cgi#verify).
+[Apache ZooKeeper 3.6.0 Source Release](https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0.tar.gz.sha512))
 
 ---
 
 Older releases are available.
 
 ### Apache ZooKeeper 3.5.7
 
-[Apache ZooKeeper 3.5.7](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7-bin.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7-bin.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7-bin.tar.gz.sha512))
+[Apache ZooKeeper 3.5.7](https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7-bin.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7-bin.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7-bin.tar.gz.sha512))
 
-[Apache ZooKeeper 3.5.7 Source Release](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7.tar.gz.sha512))
+[Apache ZooKeeper 3.5.7 Source Release](https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7.tar.gz.sha512))
 
 ### Apache ZooKeeper 3.4.14
 
-[Apache ZooKeeper 3.4.14](https://downloads.apache.org/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz.asc), [sha256](https://downloads.apache.org/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz.sha256), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz.sha512))
+[Apache ZooKeeper 3.4.14](https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz.asc), [sha256](https://downloads.apache.org/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz.sha256), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz.sha512))
+
+<a name=""verifying""></a>
+## Verifying Hashes and Signatures
 
-You can verify the integrity of a downloaded release using the PGP signatures and hashes (MD5 or SHA1) hosted at the main [Apache distro site](https://apache.org/dist/zookeeper/).  For additional information, refer to the Apache documentation for [verifying the integrity of Apache project releases](https://www.apache.org/dyn/closer.cgi#verify).
+You can verify the integrity of a downloaded release using any of these release-signing [KEYS](https://www.apache.org/dist/zookeeper/KEYS). For additional information, refer to the Apache documentation for [verifying the integrity of Apache project releases](http://www.apache.org/info/verification.html).","[{'comment': 'https?', 'commenter': 'eolivelli'}, {'comment': 'Make sense. Updated.', 'commenter': 'tisonkun'}, {'comment': 'The following sentence does not make sense:\r\n""You can verify the integrity of a downloaded release using any of these release-signing [KEYS](https://www.apache.org/dist/zookeeper/KEYS). ""\r\n\r\nSignature verification uses the ASC file, along with the associated key(s) from the KEYS file.\r\n\r\nUnless you always sign all releases with all the keys in the KEYS file, only the correct key(s) will do for signature verification. You can\'t just pick a random key from the file.\r\n', 'commenter': 'sebbASF'}, {'comment': ""@TisunKun please remove the words 'any of'\r\n\r\nThank you @sebbASF for taking a look.\r\n\r\nI feel this finale form is okay.\r\n\r\nI will wait for feedback from at least another committer or PMC in the community before merging this patch and re sending the announce email"", 'commenter': 'eolivelli'}, {'comment': 'Updated. Please check no misunderstanding :-)', 'commenter': 'tisonkun'}]"
1280,src/main/resources/markdown/releases.md,"@@ -27,27 +28,28 @@ Apache ZooKeeper 3.6.0 is our latest stable release.
 
 ### Apache ZooKeeper 3.6.0
 
-[Apache ZooKeeper 3.6.0](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0-bin.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0-bin.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0-bin.tar.gz.sha512))
+[Apache ZooKeeper 3.6.0](https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0-bin.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0-bin.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0-bin.tar.gz.sha512))
 
-[Apache ZooKeeper 3.6.0 Source Release](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0.tar.gz.sha512))
-
-You can verify the integrity of a downloaded release using the PGP signatures and hashes (MD5 or SHA1) hosted at the main [Apache distro site](https://apache.org/dist/zookeeper/).  For additional information, refer to the Apache documentation for [verifying the integrity of Apache project releases](https://www.apache.org/dyn/closer.cgi#verify).
+[Apache ZooKeeper 3.6.0 Source Release](https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0.tar.gz.sha512))
 
 ---
 
 Older releases are available.
 
 ### Apache ZooKeeper 3.5.7
 
-[Apache ZooKeeper 3.5.7](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7-bin.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7-bin.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7-bin.tar.gz.sha512))
+[Apache ZooKeeper 3.5.7](https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7-bin.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7-bin.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7-bin.tar.gz.sha512))
 
-[Apache ZooKeeper 3.5.7 Source Release](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7.tar.gz.sha512))
+[Apache ZooKeeper 3.5.7 Source Release](https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7.tar.gz.sha512))
 
 ### Apache ZooKeeper 3.4.14
 
-[Apache ZooKeeper 3.4.14](https://downloads.apache.org/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz.asc), [sha256](https://downloads.apache.org/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz.sha256), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz.sha512))
+[Apache ZooKeeper 3.4.14](https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz.asc), [sha256](https://downloads.apache.org/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz.sha256), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz.sha512))
+
+<a name=""verifying""></a>
+## Verifying Hashes and Signatures
 
-You can verify the integrity of a downloaded release using the PGP signatures and hashes (MD5 or SHA1) hosted at the main [Apache distro site](https://apache.org/dist/zookeeper/).  For additional information, refer to the Apache documentation for [verifying the integrity of Apache project releases](https://www.apache.org/dyn/closer.cgi#verify).
+You can verify the integrity of a downloaded release using release-signing [KEYS](https://www.apache.org/dist/zookeeper/KEYS). For additional information, refer to the Apache documentation for [verifying the integrity of Apache project releases](https://www.apache.org/info/verification.html).","[{'comment': 'www.apache.org/dist redirects to downloads.apache.org now. Should link directly there for KEYS.\r\n\r\n```suggestion\r\nYou can verify the integrity of a downloaded release using release-signing [KEYS](https://downloads.apache.org/zookeeper/KEYS). For additional information, refer to the Apache documentation for [verifying the integrity of Apache project releases](https://www.apache.org/info/verification.html).\r\n```', 'commenter': 'ctubbsii'}, {'comment': ""emmm from the mailing list I see some sentence\r\n\r\n> Also the links to release artifacts must not use downloads.a.o, they must\r\n> use the mirror system.\r\n\r\nWell, KEYS is not release artifacts, but I'm not very sure the rules to link to downloads.a.o"", 'commenter': 'tisonkun'}, {'comment': 'KEYS, checksums, and signatures, should always use apache.org directly, and not the mirror system, and should be downloaded using https. Any other mechanism means you can\'t trust the content of the keys you\'re using to validate the signatures.\r\n\r\nAlthough they don\'t specifically say ""KEYS"", they do say ""signature and checksum verification"" in the INFRA blog post at https://blogs.apache.org/infra/entry/more-secure-and-robust-downloads\r\n\r\nAlso, it\'s pretty obvious that downloads.apache.org is the correct new canonical location for these things, since that\'s where www.apache.org/dist redirects to now anyway.', 'commenter': 'ctubbsii'}, {'comment': 'Thanks for your information. Commit the suggestion.', 'commenter': 'tisonkun'}]"
1284,zookeeper-it/pom.xml,"@@ -0,0 +1,77 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+  <!--
+  /**
+   * Licensed to the Apache Software Foundation (ASF) under one
+   * or more contributor license agreements.  See the NOTICE file
+   * distributed with this work for additional information
+   * regarding copyright ownership.  The ASF licenses this file
+   * to you under the Apache License, Version 2.0 (the
+   * ""License""); you may not use this file except in compliance
+   * with the License.  You may obtain a copy of the License at
+   *
+   *     http://www.apache.org/licenses/LICENSE-2.0
+   *
+   * Unless required by applicable law or agreed to in writing, software
+   * distributed under the License is distributed on an ""AS IS"" BASIS,
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   */
+  -->
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.zookeeper</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.7.0-SNAPSHOT</version>","[{'comment': 'is there a way to have one version that all sub pom.xml files pull from. it seems like this would be a pain to keep up to date.', 'commenter': 'breed'}, {'comment': 'Done. Thanks!', 'commenter': 'sushantmane'}, {'comment': ""@breed\r\nIt seems the maven version plugin is used to update the version in pom files. Therefore I've reverted single version changes."", 'commenter': 'sushantmane'}]"
1284,pom.xml,"@@ -31,7 +31,7 @@
   <artifactId>parent</artifactId>
   <packaging>pom</packaging>
   <!-- to change version: mvn -\-batch-mode release:update-versions -DdevelopmentVersion=3.6.0-SNAPSHOT -->
-  <version>3.7.0-SNAPSHOT</version>
+  <version>${revision}</version>","[{'comment': ""In my opinion this won't work together with the maven release plugin.\r\nWe are using it in order to automate the release process.\r\nIs it necessary for you ?\r\n\r\n"", 'commenter': 'eolivelli'}, {'comment': ""No it's not necessary. "", 'commenter': 'sushantmane'}, {'comment': ""I've updated the patch. Thanks."", 'commenter': 'sushantmane'}]"
1301,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerHandler.java,"@@ -1150,4 +1140,33 @@ public void setFirstPacket(boolean value) {
         needOpPacket = value;
     }
 
+    void closeSocket() {
+        if (sock != null && !sock.isClosed() && sockBeingClosed.compareAndSet(false, true)) {
+            LOG.error(""Unexpected exception causing shutdown while sock is still open"");
+
+            if (closeSocketAsync) {
+                closeSockAsync();
+            } else {
+                closeSockSync();
+            }
+        }
+    }
+
+    void closeSockAsync() {
+        final Thread closingThread = new Thread(() -> closeSockSync(), ""CloseSocketThread(sid:"" + this.sid);
+        closingThread.setDaemon(true);
+        closingThread.start();
+    }
+
+    void closeSockSync() {
+        try {
+            if (sock != null) {
+                long startTime = Time.currentElapsedTime();
+                sock.close();
+                ServerMetrics.getMetrics().SOCKET_CLOSING_TIME.add(Time.currentElapsedTime() - startTime);
+            }
+        } catch (IOException e) {
+            LOG.warn(""Ignoring error closing connection to learner"", e);","[{'comment': 'please add id, like this.sid', 'commenter': 'eolivelli'}, {'comment': 'done', 'commenter': 'jhuan31'}]"
1301,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerHandler.java,"@@ -1150,4 +1140,33 @@ public void setFirstPacket(boolean value) {
         needOpPacket = value;
     }
 
+    void closeSocket() {
+        if (sock != null && !sock.isClosed() && sockBeingClosed.compareAndSet(false, true)) {
+            LOG.error(""Unexpected exception causing shutdown while sock is still open"");
+
+            if (closeSocketAsync) {
+                closeSockAsync();
+            } else {
+                closeSockSync();
+            }
+        }
+    }
+
+    void closeSockAsync() {
+        final Thread closingThread = new Thread(() -> closeSockSync(), ""CloseSocketThread(sid:"" + this.sid);
+        closingThread.setDaemon(true);
+        closingThread.start();
+    }
+
+    void closeSockSync() {
+        try {
+            if (sock != null) {
+                long startTime = Time.currentElapsedTime();
+                sock.close();
+                ServerMetrics.getMetrics().SOCKET_CLOSING_TIME.add(Time.currentElapsedTime() - startTime);","[{'comment': 'would it be useful to record this value even in case of failure ?', 'commenter': 'eolivelli'}, {'comment': ""I'm hesitating... This metric is to measure the real time for closing a socket. If it fails, say, the socket is closed already, then the elapsed time is not really the time for closing the socket."", 'commenter': 'jhuan31'}]"
1301,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerHandler.java,"@@ -1150,4 +1140,33 @@ public void setFirstPacket(boolean value) {
         needOpPacket = value;
     }
 
+    void closeSocket() {
+        if (sock != null && !sock.isClosed() && sockBeingClosed.compareAndSet(false, true)) {
+            LOG.error(""Unexpected exception causing shutdown while sock is still open"");","[{'comment': 'if I am right, when we are here, we already logged out the exception, if we had any.\r\nBut we can also get here from the `shutdown()` function, when we close the socket just without  catching any exceptions.\r\n\r\nWhat about instead of `LOG.error(""Unexpected exception...` just print out a `LOG.info` about closing the socket, and also indicating in the logs if we will do it sync or async?', 'commenter': 'symat'}, {'comment': ""You're right. The message is confusing. Changed."", 'commenter': 'jhuan31'}]"
1301,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1142,6 +1142,10 @@ property, when available, is noted below.
     The intent is for the clients not to retry them immediately.
     When set to 0, no requests will be throttled. The default is 0.
 
+* *leader.closeSocketAsync*","[{'comment': 'please also mention this parameter in the description of the Quorum TLS config parameter (look for `sslQuorum` in the same zookeeperAdmin.md) as this should be considered when someone is enabling Quorum TLS.', 'commenter': 'symat'}, {'comment': 'done.', 'commenter': 'jhuan31'}]"
1301,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1142,6 +1142,10 @@ property, when available, is noted below.
     The intent is for the clients not to retry them immediately.
     When set to 0, no requests will be throttled. The default is 0.
 
+* *leader.closeSocketAsync*
+   (Java system property only: **leader.closeSocketAsync**)","[{'comment': 'Please also tag this property with the ZooKeeper version (as you can see in other properties added recently). Something like`**New in 3.6.2:**` \r\n\r\nI think we should backport this also to branch 3.6, as it is a good optional feature for those who use SSL. @eolivelli do you agree?', 'commenter': 'symat'}, {'comment': 'done.', 'commenter': 'jhuan31'}]"
1301,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1497,7 +1501,8 @@ and [SASL authentication for ZooKeeper](https://cwiki.apache.org/confluence/disp
 * *sslQuorum* :
     (Java system property: **zookeeper.sslQuorum**)
     **New in 3.5.5:**
-    Enables encrypted quorum communication. Default is `false`.
+    Enables encrypted quorum communication. Default is `false`. When enabling this feature, please also consider enabling *leader.closeSocketAsync*
+    and *learner.closeSocketAsync* to avoid issues associated with the potentially long socket closing time when shutting down an SSL connection.","[{'comment': ""I haven't found `learner.closeSocketAsync` in the code. Did I miss something, or should we not mention that property here?"", 'commenter': 'symat'}, {'comment': ""it's in PR https://github.com/apache/zookeeper/pull/1115, which hasn't been merged yet. "", 'commenter': 'jhuan31'}]"
1301,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerHandler.java,"@@ -63,12 +65,21 @@
 
     private static final Logger LOG = LoggerFactory.getLogger(LearnerHandler.class);
 
+    public static final String LEADER_CLOSE_SOCKET_ASYNC = ""leader.closeSocketAsync"";
+    public static final boolean closeSocketAsync = Boolean.parseBoolean(System.getProperty(LEADER_CLOSE_SOCKET_ASYNC, ""true""));","[{'comment': 'please set the default value to false (as you also indicated in the docs)', 'commenter': 'symat'}, {'comment': 'Thank you so much for catching this!', 'commenter': 'jhuan31'}]"
1304,zookeeper-server/src/main/java/org/apache/zookeeper/version/util/VerGen.java,"@@ -84,6 +84,7 @@ public static void generateFile(File outputDir, Version version, String rev, Str
             if (rev.equals(""-1"")) {
                 System.out.println(""Unknown REVISION number, using "" + rev);
             }
+            w.write(""    int REVISION=-1; //@deprecated, will be removed in 3.7.0\n"");","[{'comment': ""Don't claim it to be removed in a specific version. \r\n"", 'commenter': 'eolivelli'}]"
1306,zookeeper-server/src/main/java/org/apache/zookeeper/JLineZNodeCompleter.java,"@@ -65,11 +67,8 @@ private int completeZNode(String buffer, String token, List<String> candidates)
             // Only the root path can end in a /, so strip it off every other prefix
             String dir = idx == 1 ? ""/"" : path.substring(0, idx - 1);
             List<String> children = zk.getChildren(dir, false);
-            for (String child : children) {
-                if (child.startsWith(prefix)) {
-                    candidates.add(child);
-                }
-            }
+            candidates = children.stream().filter(child -> child.startsWith(prefix)).collect(Collectors.toList());","[{'comment': ""Personally I don't find a real benefit and code actually doesn't look better.\r\nWhy do you want to change this loop?\r\n\r\nIt is actually using more resources than the fore each loop.\r\nThis is not an hot path but the question is more general.\r\nStreams look appealing but sometimes the overhead is not worth"", 'commenter': 'eolivelli'}]"
1306,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -758,9 +758,8 @@ public Stat statNode(String path, Watcher watcher) throws KeeperException.NoNode
         }
 
         int bytes = 0;
-        for (String child : children) {
-            bytes += child.length();
-        }
+        bytes = children.stream().mapToInt(child -> child.length()).sum();","[{'comment': 'This is not better than the original code', 'commenter': 'eolivelli'}]"
1306,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -241,13 +240,14 @@ public int getEphemeralsCount() {
      */
     public long approximateDataSize() {
         long result = 0;
-        for (Map.Entry<String, DataNode> entry : nodes.entrySet()) {
-            DataNode value = entry.getValue();
-            synchronized (value) {
-                result += getNodeSize(entry.getKey(), value.data);
-            }
-        }
-        return result;
+		
+		for (Map.Entry<String, DataNode> entry : nodes.entrySet()) { 
+			DataNode value =entry.getValue(); 
+			synchronized (value) { 
+				result +=getNodeSize(entry.getKey(), value.data); 
+				} 
+			} 
+		return result;
     }
 ","[{'comment': 'why need this?', 'commenter': 'maoling'}, {'comment': ""I was trying to use a stream here but couldn't come up with the correct approach and reverted back to the original for loop. I'll remove the extra indendations. "", 'commenter': 'severussundar'}]"
1306,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1625,12 +1618,9 @@ private static boolean shouldRequireClientSaslAuth() {
     }
 
     private boolean hasCnxSASLAuthenticated(ServerCnxn cnxn) {
-        for (Id id : cnxn.getAuthInfo()) {
-            if (id.getScheme().equals(SASL_AUTH_SCHEME)) {
-                return true;
-            }
-        }
-        return false;
+    	
+       return cnxn.getAuthInfo().stream().filter(id -> id.getScheme().equals(SASL_AUTH_SCHEME)).count() > 0;
+
     }","[{'comment': '` return cnxn.getAuthInfo().stream().anyMatch(id -> id.getScheme().equals(SASL_AUTH_SCHEME));` is better?', 'commenter': 'maoling'}, {'comment': ""HI maoling, good suggestion. I'll update it. Thanks!"", 'commenter': 'severussundar'}]"
1306,zookeeper-server/src/main/java/org/apache/zookeeper/server/ContainerManager.java,"@@ -125,24 +125,29 @@ public void stop() {
      */
     public void checkContainers() throws InterruptedException {
         long minIntervalMs = getMinIntervalMs();
-        for (String containerPath : getCandidates()) {
-            long startMs = Time.currentElapsedTime();
-
-            ByteBuffer path = ByteBuffer.wrap(containerPath.getBytes());
-            Request request = new Request(null, 0, 0, ZooDefs.OpCode.deleteContainer, path, null);
-            try {
-                LOG.info(""Attempting to delete candidate container: {}"", containerPath);
-                postDeleteRequest(request);
-            } catch (Exception e) {
-                LOG.error(""Could not delete container: {}"", containerPath, e);
-            }
+        getCandidates().stream()
+                .forEach(containerPath -> {
+                    long startMs = Time.currentElapsedTime();
 
-            long elapsedMs = Time.currentElapsedTime() - startMs;
-            long waitMs = minIntervalMs - elapsedMs;
-            if (waitMs > 0) {
-                Thread.sleep(waitMs);
-            }
-        }
+                    ByteBuffer path = ByteBuffer.wrap(containerPath.getBytes());
+                    Request request = new Request(null, 0, 0, ZooDefs.OpCode.deleteContainer, path, null);
+                    try {
+                        LOG.info(""Attempting to delete candidate container: {}"", containerPath);
+                        postDeleteRequest(request);
+                    } catch (Exception e) {
+                        LOG.error(""Could not delete container: {}"", containerPath, e);
+                    }
+
+                    long elapsedMs = Time.currentElapsedTime() - startMs;
+                    long waitMs = minIntervalMs - elapsedMs;
+                    if (waitMs > 0) {
+                        try {
+                            Thread.sleep(waitMs);
+                        } catch (InterruptedException e) {
+                            e.printStackTrace();
+                        }
+                    }
+                });
     }","[{'comment': 'this change makes the body of `forEach` so fat? just a personal aesthetics.', 'commenter': 'maoling'}, {'comment': ""Thanks for the comment! I'll revert back to the original for loop"", 'commenter': 'severussundar'}]"
1306,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -227,11 +230,7 @@ public int getWatchCount() {
     }
 
     public int getEphemeralsCount() {
-        int result = 0;
-        for (HashSet<String> set : ephemerals.values()) {
-            result += set.size();
-        }
-        return result;
+        return ephemerals.values().stream().mapToInt(i -> i.size()).sum();","[{'comment': ""what's the value of this change ?"", 'commenter': 'eolivelli'}]"
1306,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -1175,30 +1174,33 @@ void killSession(long session, long zxid, Set<String> paths2DeleteLocal,
     }
 
     void deleteNodes(long session, long zxid, Iterable<String> paths2Delete) {
-        for (String path : paths2Delete) {
-            boolean deleted = false;
-            String sessionHex = ""0x"" + Long.toHexString(session);
-            try {
-                deleteNode(path, zxid);
-                deleted = true;
-                LOG.debug(""Deleting ephemeral node {} for session {}"", path, sessionHex);
-            } catch (NoNodeException e) {
-                LOG.warn(
-                    ""Ignoring NoNodeException for path {} while removing ephemeral for dead session {}"",
-                        path, sessionHex);
-            }
-            if (ZKAuditProvider.isAuditEnabled()) {
-                if (deleted) {
-                    ZKAuditProvider.log(ZKAuditProvider.getZKUser(),
-                            AuditConstants.OP_DEL_EZNODE_EXP, path, null, null,
-                            sessionHex, null, Result.SUCCESS);
-                } else {
-                    ZKAuditProvider.log(ZKAuditProvider.getZKUser(),
-                            AuditConstants.OP_DEL_EZNODE_EXP, path, null, null,
-                            sessionHex, null, Result.FAILURE);
+
+        StreamSupport.stream(paths2Delete.spliterator(),false)","[{'comment': ""what's the benefit of this change ?"", 'commenter': 'eolivelli'}]"
1310,pom.xml,"@@ -324,6 +324,88 @@
       <properties>
         <maven.compiler.release>8</maven.compiler.release>
       </properties>
+      <build>
+        <pluginManagement>
+          <plugins>
+            <plugin>
+              <groupId>org.eclipse.m2e</groupId>","[{'comment': 'Can we keep this Eclipse stuff in a separate patch?\r\nIt deserves separate discussion ', 'commenter': 'eolivelli'}, {'comment': ""Sure thing. I'll update the PR."", 'commenter': 'ctubbsii'}, {'comment': 'Updated.', 'commenter': 'ctubbsii'}]"
1310,zookeeper-server/src/test/java/org/apache/zookeeper/VerGenTest.java,"@@ -1,71 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * ""License""); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.zookeeper;
-
-import static org.junit.Assert.assertEquals;
-import java.io.File;
-import java.util.Arrays;
-import java.util.Collection;
-import org.apache.zookeeper.test.ClientBase;
-import org.apache.zookeeper.version.util.VerGen;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-/**
- * Test VerGen, used during the build.
- *
- */
-@RunWith(Parameterized.class)
-@Parameterized.UseParametersRunnerFactory(ZKParameterized.RunnerFactory.class)
-public class VerGenTest extends ZKTestCase {","[{'comment': 'Why dropping this class?', 'commenter': 'eolivelli'}, {'comment': 'Because the class it is testing was dropped.', 'commenter': 'ctubbsii'}]"
1311,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -488,17 +488,9 @@ public void loadData() throws IOException, InterruptedException {
         }
 
         // Clean up dead sessions
-        List<Long> deadSessions = new ArrayList<>();
-        for (Long session : zkDb.getSessions()) {
-            if (zkDb.getSessionWithTimeOuts().get(session) == null) {
-                deadSessions.add(session);
-            }
-        }
-
-        for (long session : deadSessions) {
-            // TODO: Is lastProcessedZxid really the best thing to use?
-            killSession(session, zkDb.getDataTreeLastProcessedZxid());
-        }
+        zkDb.getSessions().stream()","[{'comment': ""I don't find this change so useful.\r\nUsing streams does not speed up things and it usually add overhead.\r\n\r\nWhy do you want to make this change ? and the other ones ?\r\n"", 'commenter': 'eolivelli'}, {'comment': 'I am trying to refactor those for loops that just performs basic filtering and collections. I feel those are better accomplished using streams.', 'commenter': 'severussundar'}, {'comment': '@eolivelli Please guide me regarding the kind of refactoring expected as part of issue 3415 (https://issues.apache.org/jira/browse/ZOOKEEPER-3415)', 'commenter': 'severussundar'}, {'comment': ""I like these changes. If performance is not impacted, I think we're fine. They make the code more readable."", 'commenter': 'anmolnar'}, {'comment': ""@eolivelli Streams don't add much overhead, when used properly. They might add some overhead sometimes, but that's not always the case, and even when they do add a slight overhead, the increased reliability of the code, due to its readability/maintainability can be worth the trade.\r\n\r\nIn this case, it:\r\n\r\n1. Makes two loops (`O(n + m)`) into a single loop (`O(n)`),\r\n2. Avoids creating an intermediate data structure entirely (saving 'm' memory units), and\r\n3. It's much nicer to read.\r\n\r\nI see no reason to not apply these changes."", 'commenter': 'ctubbsii'}]"
1316,zookeeper-server/src/test/java/org/apache/zookeeper/server/RequestThrottlerTest.java,"@@ -307,4 +308,37 @@ public void testLargeRequestThrottling() throws Exception {
         metrics = MetricsUtils.currentServerMetrics();
         Assert.assertEquals(2, (long) metrics.get(""stale_replies""));
     }
+
+    @Test
+    public void testGlobalOutstandingRequestThrottlingWithRequestThrottlerDisabled() throws Exception {
+        System.setProperty(ZooKeeperServer.GLOBAL_OUTSTANDING_LIMIT, GLOBAL_OUTSTANDING_LIMIT);
+        ServerMetrics.getMetrics().resetAll();
+
+        // Here we disable RequestThrottler and let incoming requests queued at first request processor.
+        RequestThrottler.setMaxRequests(0);
+        resumeProcess = new CountDownLatch(1);
+        int totalRequests = 10;
+        submitted = new CountDownLatch(totalRequests);
+
+        for (int i = 0; i < totalRequests; i++) {
+            zk.create(""/request_throttle_test- "" + i, (""/request_throttle_test- ""
+                    + i).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {
+            }, null);
+        }
+
+        submitted.await(5, TimeUnit.SECONDS);
+
+        resumeProcess.countDown();
+
+        // We should start throttling instead of queuing more requests.
+        //
+        // We always allow up to GLOBAL_OUTSTANDING_LIMIT + 1 number of requests coming in request processing pipeline
+        // before throttling. For the next request, we will throttle by disabling receiving future requests but we still
+        // allow this single request coming in. So the total number of queued requests in processing pipeline would
+        // be GLOBAL_OUTSTANDING_LIMIT + 2.
+        assertEquals(Integer.parseInt(GLOBAL_OUTSTANDING_LIMIT) + 2,
+                (long) MetricsUtils.currentServerMetrics().get(""prep_processor_request_queued""));
+
+        System.clearProperty(ZooKeeperServer.GLOBAL_OUTSTANDING_LIMIT);","[{'comment': 'It would be better to clear the property in a finally block', 'commenter': 'eolivelli'}, {'comment': 'updated', 'commenter': 'hanm'}]"
1316,zookeeper-server/src/test/java/org/apache/zookeeper/server/RequestThrottlerTest.java,"@@ -311,34 +311,38 @@ public void testLargeRequestThrottling() throws Exception {
 
     @Test
     public void testGlobalOutstandingRequestThrottlingWithRequestThrottlerDisabled() throws Exception {
-        System.setProperty(ZooKeeperServer.GLOBAL_OUTSTANDING_LIMIT, GLOBAL_OUTSTANDING_LIMIT);
-        ServerMetrics.getMetrics().resetAll();
+        try {
+            System.setProperty(ZooKeeperServer.GLOBAL_OUTSTANDING_LIMIT, GLOBAL_OUTSTANDING_LIMIT);
 
-        // Here we disable RequestThrottler and let incoming requests queued at first request processor.
-        RequestThrottler.setMaxRequests(0);
-        resumeProcess = new CountDownLatch(1);
-        int totalRequests = 10;
-        submitted = new CountDownLatch(totalRequests);
+            ServerMetrics.getMetrics().resetAll();
 
-        for (int i = 0; i < totalRequests; i++) {
-            zk.create(""/request_throttle_test- "" + i, (""/request_throttle_test- ""
-                    + i).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {
-            }, null);
-        }
+            // Here we disable RequestThrottler and let incoming requests queued at first request processor.
+            RequestThrottler.setMaxRequests(0);
+            resumeProcess = new CountDownLatch(1);
+            int totalRequests = 10;
+            submitted = new CountDownLatch(totalRequests);
 
-        submitted.await(5, TimeUnit.SECONDS);
-
-        resumeProcess.countDown();
-
-        // We should start throttling instead of queuing more requests.
-        //
-        // We always allow up to GLOBAL_OUTSTANDING_LIMIT + 1 number of requests coming in request processing pipeline
-        // before throttling. For the next request, we will throttle by disabling receiving future requests but we still
-        // allow this single request coming in. So the total number of queued requests in processing pipeline would
-        // be GLOBAL_OUTSTANDING_LIMIT + 2.
-        assertEquals(Integer.parseInt(GLOBAL_OUTSTANDING_LIMIT) + 2,
-                (long) MetricsUtils.currentServerMetrics().get(""prep_processor_request_queued""));
+            for (int i = 0; i < totalRequests; i++) {
+                zk.create(""/request_throttle_test- "" + i, (""/request_throttle_test- ""
+                        + i).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {
+                }, null);
+            }
 
-        System.clearProperty(ZooKeeperServer.GLOBAL_OUTSTANDING_LIMIT);
+            submitted.await(5, TimeUnit.SECONDS);
+
+            resumeProcess.countDown();
+
+            // We should start throttling instead of queuing more requests.
+            //
+            // We always allow up to GLOBAL_OUTSTANDING_LIMIT + 1 number of requests coming in request processing pipeline
+            // before throttling. For the next request, we will throttle by disabling receiving future requests but we still
+            // allow this single request coming in. So the total number of queued requests in processing pipeline would
+            // be GLOBAL_OUTSTANDING_LIMIT + 2.
+            assertEquals(Integer.parseInt(GLOBAL_OUTSTANDING_LIMIT) + 2,
+                    (long) MetricsUtils.currentServerMetrics().get(""prep_processor_request_queued""));
+        } catch (Exception e) {","[{'comment': 'ops, this is not good.\r\nI missed this part.\r\nif you catch every Exception you are making JUnit ignore errors', 'commenter': 'eolivelli'}, {'comment': 'I can amend your commit @hanm if you do not have time.\r\nI would like to prepare the RC0 of 3.6.1 today or tomorrow\r\n\r\nsorry I missed this problem', 'commenter': 'eolivelli'}, {'comment': 'fixed by rethrowing.', 'commenter': 'hanm'}]"
1318,zookeeper-server/src/main/java/org/apache/zookeeper/server/auth/DigestStrategyFactory.java,"@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.auth;
+
+import static org.apache.zookeeper.server.auth.DigestStrategyFactory.DigestAlgEnum.SHA3_256;
+import static org.apache.zookeeper.server.auth.DigestStrategyFactory.DigestAlgEnum.SHA_1;
+import static org.apache.zookeeper.server.auth.DigestStrategyFactory.DigestAlgEnum.SHA_256;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.digests.SHA3Digest;
+
+public class DigestStrategyFactory {
+    private static Map<String, DigestStrategy> digestStrategyMap = new HashMap<>();","[{'comment': 'final', 'commenter': 'eolivelli'}, {'comment': '- Done\r\n\r\n> How can we deal with the transition? \r\n      \r\nplease look at the github description', 'commenter': 'maoling'}]"
1318,zookeeper-server/src/test/java/org/apache/zookeeper/test/AuthTest.java,"@@ -20,22 +20,38 @@
 
 import static org.junit.Assert.fail;
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.TestableZooKeeper;
 import org.apache.zookeeper.WatchedEvent;
 import org.apache.zookeeper.Watcher.Event.KeeperState;
+import org.apache.zookeeper.ZooDefs;
 import org.apache.zookeeper.ZooDefs.Ids;
 import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.data.ACL;
+import org.apache.zookeeper.data.Id;
+import org.apache.zookeeper.server.auth.DigestStrategyFactory;
 import org.junit.Test;
 
 public class AuthTest extends ClientBase {
 
     static {
         // password is test
-        System.setProperty(""zookeeper.DigestAuthenticationProvider.superDigest"", ""super:D/InIHSb7yEEbrWz8b9l71RjZJU="");
+        if (System.currentTimeMillis() % 3 == 0) {","[{'comment': ""I don't understand this part.\r\nYou should run the tests against all digest types"", 'commenter': 'eolivelli'}, {'comment': 'I redo the unit test to test all digest types', 'commenter': 'maoling'}]"
1318,zookeeper-server/src/main/java/org/apache/zookeeper/server/auth/DigestAuthenticationProvider.java,"@@ -20,16 +20,40 @@
 
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.security.Security;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.data.Id;
 import org.apache.zookeeper.server.ServerCnxn;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 public class DigestAuthenticationProvider implements AuthenticationProvider {
 
     private static final Logger LOG = LoggerFactory.getLogger(DigestAuthenticationProvider.class);
 
+    private static final String DEFAULT_DIGEST_ALGORITHM = ""SHA1"";
+
+    public static final String DIGEST_ALGORITHM_KEY = ""zookeeper.DigestAuthenticationProvider.digestAlg"";
+
+    private static final String DIGEST_ALGORITHM = System.getProperty(DIGEST_ALGORITHM_KEY, DEFAULT_DIGEST_ALGORITHM);
+
+    static {
+        // To keep backward compatibility, the SHA1 still uses the implementation of JDK, other algorithms
+        // use the implementation of BouncyCastle which supports more types of algorithms than native JDK.
+        if (!DIGEST_ALGORITHM.equals(DEFAULT_DIGEST_ALGORITHM)) {
+            Security.addProvider(new BouncyCastleProvider());
+        }
+
+        try {
+            //sanity check, pre-check the availability of the algorithm to avoid some unexpected exceptions in the runtime
+            generateDigest(DEFAULT_DIGEST_ALGORITHM);","[{'comment': 'I guess you wanted to call with ""DIGEST_ALGORITHM"" and not with ""DEFAULT_DIGEST_ALGORITHM""', 'commenter': 'symat'}, {'comment': 'In fact, any string is OK.', 'commenter': 'maoling'}, {'comment': 'I see now, you are right. The parameter is the password not the algorithm. Anyway, thanks for checking. :)', 'commenter': 'symat'}]"
1318,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1461,6 +1461,33 @@ and [SASL authentication for ZooKeeper](https://cwiki.apache.org/confluence/disp
     localhost (not over the network) or over an encrypted
     connection.
 
+* *DigestAuthenticationProvider.digestAlg* :
+    (Java system property: **zookeeper.DigestAuthenticationProvider.digestAlg**)","[{'comment': 'this is great that you provided all the info here in the docs! \r\nthanks', 'commenter': 'symat'}, {'comment': '@symat  I have updated the github description', 'commenter': 'maoling'}, {'comment': 'thanks you!', 'commenter': 'symat'}]"
1318,zookeeper-server/src/test/java/org/apache/zookeeper/test/AuthSHA2Test.java,"@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import java.security.NoSuchAlgorithmException;
+import java.security.Security;
+import org.apache.zookeeper.server.auth.DigestAuthenticationProvider;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+public class AuthSHA2Test extends AuthTest {
+
+    @BeforeEach
+    @Override
+    public void setup() {
+        // use the BouncyCastle's Provider for testing
+        Security.addProvider(new BouncyCastleProvider());","[{'comment': 'this is going to pollute all of the other tests in an unpredictable way.\r\nis there a way to remove it ? ', 'commenter': 'eolivelli'}, {'comment': ""I don't think it will have any side-effect. (you can have as many security providers registered as many you wish... the JVM will go through them one-after-another in the order of their registrations, asking them for the given algorithm)\r\n\r\nIt still might be more elegant to register the provider in a @BeforeAll method. But doesn't really matter, as according to the JavaDocs it won't register the same security provider twice in the same JVM. (if I read it correctly: https://docs.oracle.com/javase/8/docs/api/java/security/Security.html#addProvider-java.security.Provider-)"", 'commenter': 'symat'}, {'comment': 'maybe I misunderstood your comment... thinking about side effects, maybe doing a \r\n```\r\nSystem.clearProperty(DigestAuthenticationProvider.DIGEST_ALGORITHM_KEY);\r\nSystem.clearProperty(""zookeeper.authProvider.1"");\r\n```\r\nin an `@AfterAll` method could be important here indeed to clean-up our custom configs after the tests.', 'commenter': 'symat'}, {'comment': 'Good catch', 'commenter': 'maoling'}]"
1318,zookeeper-server/src/test/java/org/apache/zookeeper/test/AuthTest.java,"@@ -18,27 +18,45 @@
 
 package org.apache.zookeeper.test;
 
+import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.fail;
 import java.io.IOException;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.TestableZooKeeper;
 import org.apache.zookeeper.WatchedEvent;
 import org.apache.zookeeper.Watcher.Event.KeeperState;
+import org.apache.zookeeper.ZooDefs;
 import org.apache.zookeeper.ZooDefs.Ids;
 import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.data.ACL;
+import org.apache.zookeeper.data.Id;
+import org.apache.zookeeper.server.auth.DigestAuthenticationProvider;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 public class AuthTest extends ClientBase {
 
-    static {
+    @BeforeEach
+    public void setup() {
         // password is test
+        // the default digestAlg is: SHA1
         System.setProperty(""zookeeper.DigestAuthenticationProvider.superDigest"", ""super:D/InIHSb7yEEbrWz8b9l71RjZJU="");
         System.setProperty(""zookeeper.authProvider.1"", ""org.apache.zookeeper.test.InvalidAuthProvider"");
     }
 
+    @AfterEach
+    public void teardown() {
+        System.clearProperty(""zookeeper.DigestAuthenticationProvider.superDigest"");","[{'comment': 'what about adding a constant for zookeeper.DigestAuthenticationProvider.superDigest ?', 'commenter': 'eolivelli'}, {'comment': ""This property is not introduced by my patch. I don't know whether it is appropriate for me to do this in this patch"", 'commenter': 'maoling'}, {'comment': ""I think you can add the new constant (it makes the code nicer).\r\n\r\nBut on the other hand I don't think that it would be required for +1 (as it is not directly related to this Jira issue). Anyway, it's up to @eolivelli , I already accepted the PR."", 'commenter': 'symat'}]"
1318,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1461,6 +1461,33 @@ and [SASL authentication for ZooKeeper](https://cwiki.apache.org/confluence/disp
     localhost (not over the network) or over an encrypted
     connection.
 
+* *DigestAuthenticationProvider.digestAlg* :
+    (Java system property: **zookeeper.DigestAuthenticationProvider.digestAlg**)
+     **New in 3.7.0:**
+    Set ACL digest algorithm. The default value is: `SHA1` which will be deprecated in the future for security issues.
+    Set this property the same value in all the servers.
+
+    - How to support other more algorithms?
+        - modify the `java.security` configuration file under `$JAVA_HOME/jre/lib/security/java.security` by specifying:
+             `security.provider.<n>=<provider class name>`.
+
+             ```
+             For example:
+             set zookeeper.DigestAuthenticationProvider.digestAlg=RipeMD160
+             security.provider.3=org.bouncycastle.jce.provider.BouncyCastleProvider
+             ```
+
+        - copy the jar file to `$JAVA_HOME/jre/lib/ext/`.","[{'comment': ""isn't it enough to add it to the classpath ?\r\n\r\nModifying the JRE is something that usually no one can do, because people have the JDK/JRE pre-installed or managed by some system and modifying the contents of the directory can be forbidden in many  environments.\r\n\r\nAlso how to deal with this stuff in a Docker image ?"", 'commenter': 'eolivelli'}, {'comment': ""I think it isn't hard to make these global changes even in docker. But if you need to do this only for your java process, then the standard way is:\r\n- create your own security property file where you add the single line with the new security provider\r\n- use the `-Djava.security.properties=<path/to/my/custom/properties>` system property\r\n\r\nsee: https://dzone.com/articles/how-override-java-security\r\n\r\nStill, I think if you use a modern JVM, then there is a very good chance, that the hash algorithms in the default providers will be good enough for you. And if you need something really fancy (like Bouncy Castle FIPS Provider for some regulatory reasons) then you will need to tweak your security properies anyway..."", 'commenter': 'symat'}]"
1322,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1648,6 +1648,11 @@ New features that are currently considered experimental.
     values and see changes from other clients. See
     ZOOKEEPER-784 for more details.
 
+* *zookeeper.follower.skipLearnerRequestToNextProcessor* :
+    (Java system property: **zookeeper.follower.skipLearnerRequestToNextProcessor**)
+    Boolean flag to skip learner request to be processed by next processor of followerRequestProcessor when set to true.
+    Default value is false.
+","[{'comment': 'we should improve this description, this is a bit too technical, the users will not understand it without understanding a very specific small part in the code. We should mention that this property helps when there are observers used in the cluster. Also we can mention that it helps in memory pressure.', 'commenter': 'symat'}, {'comment': 'I agree. @mayank99fb Please add some clarification in what circumstances could this setting be useful.', 'commenter': 'anmolnar'}, {'comment': ""@symat i'll update the description "", 'commenter': 'mayank99fb'}, {'comment': 'cool, I like the new description', 'commenter': 'symat'}]"
1322,zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerMetrics.java,"@@ -455,6 +457,8 @@ private ServerMetrics(MetricsProvider metricsProvider) {
 
     public final Counter CNXN_CLOSED_WITHOUT_ZK_SERVER_RUNNING;
 
+    public final Counter SKIP_LEARNER_REQUEST_TO_NEXT_PROCESSOR_COUNT;","[{'comment': 'I see that introducing this counter helps in unit testing. Other than unit testing, do you think this counter will come handy for the customers during production? \r\n- If yes, then we might document this (but I am not sure if we usually mention counters in the admin docs).\r\n- If no, then do you think we would have any other way for testing this, without adding an unnecessary metrics?\r\n ', 'commenter': 'symat'}, {'comment': ""@mayank99fb will probably confirm this, but I think this was intentional. It's a useful thing to monitor the effect of such a new feature when you turn on first time in production. We should keep it."", 'commenter': 'anmolnar'}, {'comment': '@symat this is used to monitor the feature, internally, we have the metrics reporting system which will read and report from this value.', 'commenter': 'lvfangmin'}, {'comment': '@symat , as @anmolnar and @lvfangmin mentioned - the intention of this counter was to help in monitoring and I would suggest me keeping it in the code unless you still have some concerns on this ?', 'commenter': 'mayank99fb'}, {'comment': ""no concerns, let's keep it then :)"", 'commenter': 'symat'}]"
1322,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java,"@@ -115,6 +124,14 @@ public void run() {
         LOG.info(""FollowerRequestProcessor exited loop!"");
     }
 
+    private void maybeSendRequestToNextProcessor(Request request) throws RequestProcessorException {
+        if (request.isFromLearner() && skipLearnerRequestToNextProcessor) {","[{'comment': 'Maybe you can invert the order, make the test over the field as first,\r\nThis option is disabled by default and we can save a bunch of CPU cycles', 'commenter': 'eolivelli'}, {'comment': ""That's a nice suggestion, @mayank99fb please consider this it."", 'commenter': 'lvfangmin'}, {'comment': 'done', 'commenter': 'mayank99fb'}]"
1323,pom.xml,"@@ -258,6 +258,7 @@
     <profile>
       <id>full-build</id>
       <modules>
+        <module>zookeeper-it</module>","[{'comment': 'What the reason of this change? It seems a change we should cheery pick for master.', 'commenter': 'tisonkun'}, {'comment': 'Because fatjar needs it.\r\nmaster branch is differentf from branch-3.6', 'commenter': 'eolivelli'}]"
1323,zookeeper-it/pom.xml,"@@ -33,6 +33,22 @@
     ZooKeeper system tests
   </description>
 
+  <profiles>
+    <profile>
+      <id>full-build</id>
+      <build>
+         <plugins>
+            <plugin>
+              <artifactId>maven-surefire-plugin</artifactId>
+              <configuration>
+                 <skipTests>true</skipTests>
+              </configuration>
+	    </plugin>
+         </plugins>
+      </build>","[{'comment': 'This can be shorter.\r\n\r\n```suggestion\r\n      <properties>\r\n         <skipTests>true</skipTests>\r\n      </properties>\r\n```', 'commenter': 'ctubbsii'}, {'comment': 'done, thank you @ctubbsii ', 'commenter': 'eolivelli'}]"
1323,zookeeper-it/pom.xml,"@@ -33,6 +33,16 @@
     ZooKeeper system tests
   </description>
 
+  <profiles>
+    <profile>
+      <id>full-build</id>
+      <properties>
+         <skipTests>true</skipTests>
+         <spotbugs.skip>true</spotbugs.skip>","[{'comment': 'Lesson learned from #1314 : you might need to skip checkstyle, too.\r\n\r\n```suggestion\r\n         <checkstyle.skip>true</checkstyle.skip>\r\n         <skipTests>true</skipTests>\r\n         <spotbugs.skip>true</spotbugs.skip>\r\n```', 'commenter': 'ctubbsii'}]"
1348,bin/zkServer.sh,"@@ -235,51 +235,64 @@ restart)
     ;;
 status)
     # -q is necessary on some versions of linux where nc returns too quickly, and no stat result is output
+    isSSL=""false""
     clientPortAddress=`$GREP ""^[[:space:]]*clientPortAddress[^[:alpha:]]"" ""$ZOOCFG"" | sed -e 's/.*=//'`
     if ! [ $clientPortAddress ]
     then
-	clientPortAddress=""localhost""
+	      clientPortAddress=""localhost""
     fi
     clientPort=`$GREP ""^[[:space:]]*clientPort[^[:alpha:]]"" ""$ZOOCFG"" | sed -e 's/.*=//'`
     if ! [[ ""$clientPort""  =~ ^[0-9]+$ ]]
     then
-       dataDir=`$GREP ""^[[:space:]]*dataDir"" ""$ZOOCFG"" | sed -e 's/.*=//'`
-       myid=`cat ""$dataDir/myid""`
-       if ! [[ ""$myid"" =~ ^[0-9]+$ ]] ; then
-         echo ""clientPort not found and myid could not be determined. Terminating.""
-         exit 1
-       fi
-       clientPortAndAddress=`$GREP ""^[[:space:]]*server.$myid=.*;.*"" ""$ZOOCFG"" | sed -e 's/.*=//' | sed -e 's/.*;//'`
-       if [ ! ""$clientPortAndAddress"" ] ; then
-           echo ""Client port not found in static config file. Looking in dynamic config file.""
-           dynamicConfigFile=`$GREP ""^[[:space:]]*dynamicConfigFile"" ""$ZOOCFG"" | sed -e 's/.*=//'`
-           clientPortAndAddress=`$GREP ""^[[:space:]]*server.$myid=.*;.*"" ""$dynamicConfigFile"" | sed -e 's/.*=//' | sed -e 's/.*;//'`
-       fi
-       if [ ! ""$clientPortAndAddress"" ] ; then
-          echo ""Client port not found. Terminating.""
-          exit 1
-       fi
-       if [[ ""$clientPortAndAddress"" =~ ^.*:[0-9]+ ]] ; then
-          clientPortAddress=`echo ""$clientPortAndAddress"" | sed -e 's/:.*//'`
-       fi
-       clientPort=`echo ""$clientPortAndAddress"" | sed -e 's/.*://'`
-       if [ ! ""$clientPort"" ] ; then
-          echo ""Client port not found. Terminating.""
-          exit 1
-       fi
+      dataDir=`$GREP ""^[[:space:]]*dataDir"" ""$ZOOCFG"" | sed -e 's/.*=//'`
+      myid=`cat ""$dataDir/myid"" 2> /dev/null`
+      if ! [[ ""$myid"" =~ ^[0-9]+$ ]] ; then
+        echo ""myid could not be determined, will not able to locate clientPort in the server configs.""
+      else
+        clientPortAndAddress=`$GREP ""^[[:space:]]*server.$myid=.*;.*"" ""$ZOOCFG"" | sed -e 's/.*=//' | sed -e 's/.*;//'`
+        if [ ! ""$clientPortAndAddress"" ] ; then
+          echo ""Client port not found in static config file. Looking in dynamic config file.""
+          dynamicConfigFile=`$GREP ""^[[:space:]]*dynamicConfigFile"" ""$ZOOCFG"" | sed -e 's/.*=//'`
+          clientPortAndAddress=`$GREP ""^[[:space:]]*server.$myid=.*;.*"" ""$dynamicConfigFile"" | sed -e 's/.*=//' | sed -e 's/.*;//'`
+        fi
+        if [ ! ""$clientPortAndAddress"" ] ; then
+          echo ""Client port not found in the server configs""
+        else
+          if [[ ""$clientPortAndAddress"" =~ ^.*:[0-9]+ ]] ; then
+            clientPortAddress=`echo ""$clientPortAndAddress"" | sed -e 's/:.*//'`
+          fi
+          clientPort=`echo ""$clientPortAndAddress"" | sed -e 's/.*://'`
+        fi
+      fi
     fi
-    echo ""Client port found: $clientPort. Client address: $clientPortAddress.""
+    if [ ! ""$clientPort"" ] ; then
+      echo ""Client port not found. Looking for secureClientPort in the static config.""
+      secureClientPort=`$GREP ""^[[:space:]]*secureClientPort[^[:alpha:]]"" ""$ZOOCFG"" | sed -e 's/.*=//'`
+      if [ ""$secureClientPort"" ] ; then
+        isSSL=""true""
+      fi
+      clientPort=$secureClientPort
+    fi
+    if [ ! ""$clientPort"" ] ; then
+      echo ""Unable to find either secure or unsecure client port in any configs. Terminating.""
+      exit 1
+    fi
+    echo ""Client port found: $clientPort. Client address: $clientPortAddress. Client SSL: $isSSL.""
     STAT=`""$JAVA"" ""-Dzookeeper.log.dir=${ZOO_LOG_DIR}"" ""-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}"" ""-Dzookeeper.log.file=${ZOO_LOG_FILE}"" \
-             -cp ""$CLASSPATH"" $JVMFLAGS org.apache.zookeeper.client.FourLetterWordMain \
-             $clientPortAddress $clientPort srvr 2> /dev/null    \
+          -cp ""$CLASSPATH"" $CLIENT_JVMFLAGS $JVMFLAGS org.apache.zookeeper.client.FourLetterWordMain \
+          $clientPortAddress $clientPort srvr $isSSL 2> /dev/null    \
           | $GREP Mode`
     if [ ""x$STAT"" = ""x"" ]
     then
-        echo ""Error contacting service. It is probably not running.""
-        exit 1
+      if [ ""$isSSL"" ] ; then
+        echo ""We used secureClientPort ($secureClientPort) to establish connection, but we failed. Please make sure you provided all the Client SSL connection related parameters in the SERVER_JVMFLAGS environment variable!""
+        echo ""example: SERVER_JVMFLAGS=\""-Dzookeeper.clientCnxnSocket=org.apache.zookeeper.ClientCnxnSocketNetty -Dzookeeper.ssl.trustStore.location=/tmp/clienttrust.jks -Dzookeeper.ssl.trustStore.password=password -Dzookeeper.ssl.keyStore.location=/tmp/client.jks -Dzookeeper.ssl.keyStore.password=password -Dzookeeper.client.secure=true\"" ./zkServer.sh status""","[{'comment': 'Why do we need ""Client SSL connection related parameters in the SERVER_JVMFLAGS""? \r\n(Missing the concept from my end)', 'commenter': 'aishwaryasoni1991'}, {'comment': 'yep, this is not very intuitive.\r\n- the status command in zkServer.sh will initiate a client connection to execute diagnostic command against the server. To be able to connect to the server, it needs to have all the client-side credentials / ssl configs (and these configs can not be read from the server-side zoo.cfg file)\r\n- normally you put these client SSL parameters to the CLIENT_JVMFLAGS environment variable. But the zkServer.sh extra configuration goes usually to the SERVER_JVMFLAGS. We could change this by processing the CLIENT_JVMFLAGS during the `zkServer.sh status` command, but I am not sure if it would be less confusing.', 'commenter': 'symat'}, {'comment': 'I will add a bit more context to the documentation / error message.', 'commenter': 'symat'}, {'comment': 'Thinking it through again, I think it will be actually less confusing to use the CLIENT_JVMFLAGS. I fixed it in my last commit. Thanks for the note!', 'commenter': 'symat'}, {'comment': 'Thank you for explaining the logic :) \r\nIf we need the flags set, can we do an if check in the zkEnv.sh if its TLS enabled or not? So when zkCli runs, it will get the CLIENT_JVMFLAGS which already has everything needed. Your comments rightly serve the purpose of telling the user how to run status command but just thinking how can we simplify a bit more.', 'commenter': 'aishwaryasoni1991'}, {'comment': 'Do you know if running the 4 letter commands are SSL secured or not? Also, when we open the zk cli console (./bin/zkCli.sh), if the TLS is enabled, are all the communications by default SSL encrypted, or do we need to provide the client flags as above while starting the cli?', 'commenter': 'aishwaryasoni1991'}, {'comment': ""4lw commands are not ssl secured, you can't use it with SSL port.\r\nYou need to provide those flags if you want to connect to a secure port. "", 'commenter': 'nkalmar'}, {'comment': '""can we do an if check in the zkEnv.sh"" - Sounds good, but I\'m not sure we want to complicate zkServer.sh with client jvm flag checks. I\'ll leave this for Mate to decide, he is much more involved in this.', 'commenter': 'nkalmar'}, {'comment': '> ""can we do an if check in the zkEnv.sh""\r\n\r\nI was also thinking about more automation, but I don\'t think it would be easy to do this reliably. The problem is that usually (in production environment) we use different keystore / truststore files (or jaas configs for SASL) for the server and for the client. And in the `zoo.conf` file or in  `zkEnv.sh` we don\'t have the SSL config needed for the client to connect. Usually it is something one configures in the code or by using system properties when one tries to connect to ZooKeeper.\r\n\r\nBut maybe I misunderstood your idea...', 'commenter': 'symat'}, {'comment': ""apologize for the delay in reverting. I didn't know that to enable client-side TLS changes we always need to set in the JVM flags. I thought setting them in the zoo.cfg (using ssl.keyStore.location, ssl.keyStore.password, ssl.keyStore.location and ssl.keyStore.password ) will help to achieve the same feat. So I suggested if we can set the keystore and trustore related config by default in an SSL enabled env. But I see your point regarding dev and prod having different paths for either of the stores. \r\nBut we can define some ENV variables to check if its prod or dev and still set the appropriate configs in zkEnv.sh right? Like just providing flexibility so that people don't have to put it everytime they do a status check (or maybe I am overthinking all this :) )"", 'commenter': 'aishwaryasoni1991'}, {'comment': '@nkalmar Thank you for testing this out. Regarding 4lw, we use netcat like,\r\n**echo ruok | nc <zookeeper ip> 2181**\r\nso if we pass the CLIENT_JVMFLAGS will it be SSL protected?', 'commenter': 'aishwaryasoni1991'}, {'comment': ""> But we can define some ENV variables to check if its prod or dev and still set the appropriate configs in zkEnv.sh right? Like just providing flexibility so that people don't have to put it everytime they do a status check (or maybe I am overthinking all this :) )\r\n\r\nI think anyone can easily make an alias or a one-liner shell script for his environment if he needs to call the zkServer.sh with some extra environment variables, so I wouldn't complicate this any more :)"", 'commenter': 'symat'}, {'comment': '> so if we pass the CLIENT_JVMFLAGS will it be SSL protected?\r\n\r\nno, the CLIENT_JVMFLAGS will not be used / processed by `nc`. I think you will have to specify the key / trust files with some netcat specific options. (see `nc --help`)', 'commenter': 'symat'}]"
1348,bin/zkServer.sh,"@@ -235,51 +235,64 @@ restart)
     ;;
 status)
     # -q is necessary on some versions of linux where nc returns too quickly, and no stat result is output
+    isSSL=""false""
     clientPortAddress=`$GREP ""^[[:space:]]*clientPortAddress[^[:alpha:]]"" ""$ZOOCFG"" | sed -e 's/.*=//'`
     if ! [ $clientPortAddress ]
     then
-	clientPortAddress=""localhost""
+	      clientPortAddress=""localhost""
     fi
     clientPort=`$GREP ""^[[:space:]]*clientPort[^[:alpha:]]"" ""$ZOOCFG"" | sed -e 's/.*=//'`
     if ! [[ ""$clientPort""  =~ ^[0-9]+$ ]]
     then
-       dataDir=`$GREP ""^[[:space:]]*dataDir"" ""$ZOOCFG"" | sed -e 's/.*=//'`
-       myid=`cat ""$dataDir/myid""`
-       if ! [[ ""$myid"" =~ ^[0-9]+$ ]] ; then
-         echo ""clientPort not found and myid could not be determined. Terminating.""
-         exit 1
-       fi
-       clientPortAndAddress=`$GREP ""^[[:space:]]*server.$myid=.*;.*"" ""$ZOOCFG"" | sed -e 's/.*=//' | sed -e 's/.*;//'`
-       if [ ! ""$clientPortAndAddress"" ] ; then
-           echo ""Client port not found in static config file. Looking in dynamic config file.""
-           dynamicConfigFile=`$GREP ""^[[:space:]]*dynamicConfigFile"" ""$ZOOCFG"" | sed -e 's/.*=//'`
-           clientPortAndAddress=`$GREP ""^[[:space:]]*server.$myid=.*;.*"" ""$dynamicConfigFile"" | sed -e 's/.*=//' | sed -e 's/.*;//'`
-       fi
-       if [ ! ""$clientPortAndAddress"" ] ; then
-          echo ""Client port not found. Terminating.""
-          exit 1
-       fi
-       if [[ ""$clientPortAndAddress"" =~ ^.*:[0-9]+ ]] ; then
-          clientPortAddress=`echo ""$clientPortAndAddress"" | sed -e 's/:.*//'`
-       fi
-       clientPort=`echo ""$clientPortAndAddress"" | sed -e 's/.*://'`
-       if [ ! ""$clientPort"" ] ; then
-          echo ""Client port not found. Terminating.""
-          exit 1
-       fi
+      dataDir=`$GREP ""^[[:space:]]*dataDir"" ""$ZOOCFG"" | sed -e 's/.*=//'`
+      myid=`cat ""$dataDir/myid"" 2> /dev/null`
+      if ! [[ ""$myid"" =~ ^[0-9]+$ ]] ; then
+        echo ""myid could not be determined, will not able to locate clientPort in the server configs.""
+      else
+        clientPortAndAddress=`$GREP ""^[[:space:]]*server.$myid=.*;.*"" ""$ZOOCFG"" | sed -e 's/.*=//' | sed -e 's/.*;//'`
+        if [ ! ""$clientPortAndAddress"" ] ; then
+          echo ""Client port not found in static config file. Looking in dynamic config file.""
+          dynamicConfigFile=`$GREP ""^[[:space:]]*dynamicConfigFile"" ""$ZOOCFG"" | sed -e 's/.*=//'`
+          clientPortAndAddress=`$GREP ""^[[:space:]]*server.$myid=.*;.*"" ""$dynamicConfigFile"" | sed -e 's/.*=//' | sed -e 's/.*;//'`
+        fi
+        if [ ! ""$clientPortAndAddress"" ] ; then
+          echo ""Client port not found in the server configs""
+        else
+          if [[ ""$clientPortAndAddress"" =~ ^.*:[0-9]+ ]] ; then
+            clientPortAddress=`echo ""$clientPortAndAddress"" | sed -e 's/:.*//'`
+          fi
+          clientPort=`echo ""$clientPortAndAddress"" | sed -e 's/.*://'`
+        fi
+      fi
     fi
-    echo ""Client port found: $clientPort. Client address: $clientPortAddress.""
+    if [ ! ""$clientPort"" ] ; then
+      echo ""Client port not found. Looking for secureClientPort in the static config.""
+      secureClientPort=`$GREP ""^[[:space:]]*secureClientPort[^[:alpha:]]"" ""$ZOOCFG"" | sed -e 's/.*=//'`
+      if [ ""$secureClientPort"" ] ; then
+        isSSL=""true""
+      fi
+      clientPort=$secureClientPort","[{'comment': 'do we need this considering value of secureClientPort will be null if not set? As in line 276 the check for the value of clientPort is done and if secureClientPort is also missing, it will get caught.\r\nI think we need to set clientPort=$secureClientPort immediately before/after setting isSSL = ""true"".\r\n', 'commenter': 'aishwaryasoni1991'}, {'comment': 'yes, I aggre, moving the `clientPort=$secureClientPort` inside the `if` after `isSSL=""true""` would make the code more logical / readable. (although it wouldn\'t change the behaviour, as you pointed out). I will push the fix.', 'commenter': 'symat'}]"
1348,bin/zkServer.sh,"@@ -270,8 +270,8 @@ status)
       secureClientPort=`$GREP ""^[[:space:]]*secureClientPort[^[:alpha:]]"" ""$ZOOCFG"" | sed -e 's/.*=//'`
       if [ ""$secureClientPort"" ] ; then
         isSSL=""true""
+        clientPort=$secureClientPort
       fi
-      clientPort=$secureClientPort
     fi
     if [ ! ""$clientPort"" ] ; then","[{'comment': 'Can we refactor it like this?\r\n```\r\nif [ ! ""$clientPort"" ] ; then\r\n      echo ""Client port not found. Looking for secureClientPort in the static config.""\r\n      secureClientPort=`$GREP ""^[[:space:]]*secureClientPort[^[:alpha:]]"" ""$ZOOCFG"" | sed -e \'s/.*=//\'`\r\n      if [ ""$secureClientPort"" ] ; then\r\n        isSSL=""true""\r\n        clientPort=$secureClientPort\r\n      else\r\n        echo ""Unable to find either secure or unsecure client port in any configs. Terminating.""\r\n        exit 1\r\n    fi\r\nfi\r\n```', 'commenter': 'aishwaryasoni1991'}, {'comment': 'yes, thanks!\r\nyou are right, it is a bit more compact this way. I changed.', 'commenter': 'symat'}]"
1353,zookeeper-server/src/main/java/org/apache/zookeeper/common/ZKHostnameVerifier.java,"@@ -324,8 +324,14 @@ private static HostNameType determineHostFormat(final String host) {
             for (List<?> entry : entries) {
                 final Integer type = entry.size() >= 2 ? (Integer) entry.get(0) : null;
                 if (type != null) {
-                    final String s = (String) entry.get(1);
-                    result.add(new SubjectName(s, type));
+                    if (type == SubjectName.DNS || type == SubjectName.IP) {
+                        final Object o = entry.get(1);
+                        if (o instanceof String) {
+                            result.add(new SubjectName((String) o, type));
+                        } else if (o instanceof byte[]) {
+                            // TODO ASN.1 DER encoded form","[{'comment': 'I am not sure what ASN.1 DER is or how commonly it is used, but I think at least printing out a warning here would make sense (informing the user that ASN.1 DER is not supported). (?)', 'commenter': 'symat'}, {'comment': ""I believe it can be done with BouncyCastle ASN1 libraries, but this part was missing in the original patch too. I'd be happy to add it as a separate ticket, but first I need an example certificate with ASN1 encoded data."", 'commenter': 'anmolnar'}, {'comment': 'I agree with Mate here, probably adding a warning until this TODO is not implemented would be nice.', 'commenter': 'nkalmar'}, {'comment': 'This is a static method. How can I log here?', 'commenter': 'anmolnar'}, {'comment': ""Didn't see it's a static method. But I believe you can log by making the logger also static. Not sure it is worth it though, it's not a stopper from my side if we leave the TODO, just a nice-to-have."", 'commenter': 'nkalmar'}]"
1353,zookeeper-server/src/test/java/org/apache/zookeeper/common/ZKHostnameVerifierTest.java,"@@ -0,0 +1,158 @@
+/**","[{'comment': 'this is a great test to have, thanks!', 'commenter': 'symat'}]"
1353,zookeeper-server/src/test/java/org/apache/zookeeper/common/CertificatesToPlayWith.java,"@@ -0,0 +1,569 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+/**
+ * Some X509 certificates to test against.
+ * <p>
+ * Note:  some of these certificates have Japanese Kanji in the ""subjectAlt""
+ * field (UTF8).  Not sure how realistic that is since international characters
+ * in DNS names usually get translated into ASCII using ""xn--"" style DNS
+ * entries.  ""xn--i8s592g.co.jp"" is what FireFox actually uses when trying to
+ * find &#x82b1;&#x5b50;.co.jp.  So would the CN in the certificate contain
+ * ""xn--i8s592g.co.jp"" in ASCII, or ""&#x82b1;&#x5b50;.co.jp"" in UTF8?  (Both?)
+ * </p>
+ *
+ * @since 11-Dec-2006","[{'comment': 'Do we have to cite the source of this code ?\r\nOr did you create this file by yourself ?\r\n\r\nIf it is not from an ASF project we have to add some line in NOTICE file', 'commenter': 'eolivelli'}, {'comment': 'Tests and test resources (this file) have been copied from ASF project http client. Name of the project is Apache HttpComponents: https://hc.apache.org/\r\nWhat do I need to add exactly?', 'commenter': 'anmolnar'}, {'comment': ""AFAIK (and Enrico's question also applies this) if it's from another Apache project, the Apache license header is enough."", 'commenter': 'nkalmar'}, {'comment': 'Just checked JVMPauseMonitor out of curiosity. I got that class from hadoop, but modified it. I do have a comment indicating the original source. Maybe adding something similar?\r\nhttps://github.com/apache/zookeeper/blob/fe940cdd8fb23ba09684cefb73233d570f4a20fa/zookeeper-server/src/main/java/org/apache/zookeeper/server/util/JvmPauseMonitor.java', 'commenter': 'nkalmar'}, {'comment': 'I would just write something like\r\n""These test case have been taken from the Apache HttpComponents project.""\r\nNothing more.\r\nIt is just a test resource (but we are going to ""release it"", in the source release)', 'commenter': 'eolivelli'}, {'comment': 'Sure. Thanks.', 'commenter': 'anmolnar'}]"
1354,pom.xml,"@@ -679,32 +677,26 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-assembly-plugin</artifactId>
-          <version>3.1.0</version>
         </plugin>
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-release-plugin</artifactId>
-          <version>3.0.0-M1</version>
         </plugin>
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-scm-plugin</artifactId>
-          <version>1.11.2</version>","[{'comment': '1.11.2 is newer than the one set in the parent pom, so it should stay.', 'commenter': 'ctubbsii'}]"
1354,pom.xml,"@@ -421,6 +421,7 @@
     <maven.compiler.source>1.8</maven.compiler.source>
     <maven.compiler.target>1.8</maven.compiler.target>
     <dependency.locations.enabled>false</dependency.locations.enabled>
+    <surefire.version>2.22.1</surefire.version>","[{'comment': 'Why did you add this property?', 'commenter': 'nkalmar'}, {'comment': ""NVM, I see it's 2.22.0 in parent apache pom."", 'commenter': 'nkalmar'}]"
1358,zookeeper-server/src/test/java/org/apache/zookeeper/test/AtomicFileOutputStreamTest.java,"@@ -64,7 +66,7 @@ public void testWriteNewFile() throws IOException {
         fos.close();
         assertTrue(dstFile.exists());
 
-        String readBackData = ClientBase.readFile(dstFile);
+        String readBackData = FileUtils.readFileToString(dstFile, StandardCharsets.UTF_8);","[{'comment': '`UTF_8` is one thing that can be really useful to have a static import, for readability.', 'commenter': 'ctubbsii'}, {'comment': ""Also, there are many new ways in Java 7/8 to read from a file. I'm not sure it is necessary to rely on Commons for this. Keeping the number of uses of Commons down means that it may be easier to drop as a dependency in future, as functions are provided directly by Java itself. Fewer dependencies means greater stability in the long run, so if ZK doesn't need to use a dependency, it shouldn't.\r\n\r\nHere are some ways to read from a File without commons, found by using Google: https://howtodoinjava.com/java/io/java-read-file-to-string-examples/\r\n\r\nWe probably want something like:\r\n\r\n```java\r\n  String readBackData = new String(Files.readAllBytes(dst.toPath()), UTF_8);\r\n```"", 'commenter': 'ctubbsii'}, {'comment': ""Good point on the apache commons usage. Honestly, didn't even realised it's from there, I am also used to FileUtils so much... "", 'commenter': 'nkalmar'}, {'comment': 'Thanks.  Made the changes.', 'commenter': 'belugabehr'}, {'comment': '@belugabehr You only changed it in one place. I only commented once, but there were many lines that were changed in the same way in the PR.', 'commenter': 'ctubbsii'}]"
1360,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/ReconfigBackupTest.java,"@@ -93,7 +83,7 @@ public void testBackupStatic() throws Exception {
             mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);
             // check that a dynamic configuration file doesn't exist
             assertNull(""static file backup shouldn't exist before bootup"", mt[i].getFileByName(""zoo.cfg.bak""));
-            staticFileContent[i] = getFileContent(mt[i].confFile);
+            staticFileContent[i] = FileUtils.readFileToString(mt[i].confFile, StandardCharsets.UTF_8);","[{'comment': 'You seem to have a lot of little open PRs for the same action in different parts of the code. It is making reviewing a bit redundant. See my comments on your other PR with my suggestions to use static imports for `UTF_8` for readability, and the Java-native options for reading files without needing to use Commons.', 'commenter': 'ctubbsii'}]"
1363,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -419,7 +419,7 @@ protected void pRequest2Txn(int type, long zxid, Request request, Record record,
             try {
                 lzks = (LeaderZooKeeperServer) zks;
             } catch (ClassCastException e) {
-                // standalone mode - reconfiguration currently not supported
+                LOG.error(""Reconfig operation requested but this feature is currently not supported on standalone mode.”);
                 throw new KeeperException.UnimplementedException();
             }","[{'comment': ""- Adding  more logs may be better, I wonder `warn` is better than `error` ?\r\n- @rodrigongarcia It's better to create a [JIRA](https://issues.apache.org/jira/projects/ZOOKEEPER/) issues (sign up JIRA if you don't have an account) to \r\nbind this PR to a JIRA-ID. The contributor guideline\r\n is [here](https://cwiki.apache.org/confluence/display/ZOOKEEPER/HowToContribute)"", 'commenter': 'maoling'}, {'comment': 'I agree with @maoling, I also feel that a WARN would be more appropriate here.', 'commenter': 'symat'}]"
1369,zookeeper-compatibility-tests/src/test/java/org/apache/zookeeper/compatibility/TestApacheCuratorCompatibility.java,"@@ -0,0 +1,77 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.compatibility;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.CuratorFrameworkFactory;
+import org.apache.curator.framework.recipes.cache.CuratorCache;
+import org.apache.curator.retry.RetryOneTime;
+import org.apache.curator.test.TestingServer;
+import org.junit.Test;
+
+/**
+ * Make sure minimal Apache Curator APIs work correctly. As it's a widely used ZooKeeper
+ * client library we should not break it.
+ */
+public class TestApacheCuratorCompatibility {
+    private static final int TIMEOUT_MS = 5000;
+
+    @Test
+    public void testBasicUsageOfApisAndRecipes() throws Exception {
+        try (TestingServer server = new TestingServer()) {
+            RetryOneTime retryPolicy = new RetryOneTime(1);
+            try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), retryPolicy)) {
+                try (CuratorCache cache = CuratorCache.build(client, ""/base/path"")) {
+                    client.start();
+                    cache.start();
+
+                    BlockingQueue<String> paths = new LinkedBlockingQueue<>();
+                    cache.listenable().addListener((dummy1, dummy2, data) -> paths.add(data.getPath()));
+
+                    client.create().creatingParentsIfNeeded().forPath(""/base/path/1"");
+                    client.create().creatingParentsIfNeeded().forPath(""/base/path/2"");
+                    client.create().creatingParentsIfNeeded().forPath(""/base/path/1/a"");
+                    client.create().creatingParentsIfNeeded().forPath(""/base/path/2/a"");
+
+                    assertEquals(""/base/path"", poll(paths));
+                    assertEquals(""/base/path/1"", poll(paths));
+                    assertEquals(""/base/path/2"", poll(paths));
+                    assertEquals(""/base/path/1/a"", poll(paths));
+                    assertEquals(""/base/path/2/a"", poll(paths));
+                }
+            }
+        }
+    }
+
+    private String poll(BlockingQueue<String> queue) {","[{'comment': 'static?', 'commenter': 'eolivelli'}]"
1369,pom.xml,"@@ -64,6 +64,7 @@
     <module>zookeeper-client</module>
     <module>zookeeper-recipes</module>
     <module>zookeeper-assembly</module>
+      <module>zookeeper-compatibility-tests</module>","[{'comment': 'It is good to have this top level module.\r\nI feel we will have more modules of this type in the future.\r\nSo I would like to see a separate module for curator\r\n\r\nLike the Zookeeper clients module and the c client', 'commenter': 'eolivelli'}, {'comment': 'So you want a 3rd level module? Something like:\r\n\r\n```\r\nroot\r\n     zookeeper-compatibility-tests\r\n          zookeeper-compatibility-test-curator\r\n```\r\n\r\nWhat purpose, then, does the parent `zookeeper-compatibility-tests` module serve?', 'commenter': 'Randgalt'}, {'comment': ""It will be container of future compatibility modules like yours.\r\n\r\nWe won't have only Curator one day.\r\n\r\nDoesn't  it make sense to you?"", 'commenter': 'eolivelli'}, {'comment': 'I guess it could serve to make sure there are no dependency incompatibilities between components being tested. ', 'commenter': 'Randgalt'}]"
1372,pom.xml,"@@ -641,7 +648,7 @@
              <showWarnings>true</showWarnings>
              <compilerArgs>
                <compilerArg>-Werror</compilerArg>
-               <compilerArg>-Xlint:deprecation</compilerArg>
+               <!--compilerArg>-Xlint:deprecation</compilerArg-->","[{'comment': 'Why comment it out?\r\nPlease just remove if not needed. But I think it is intentional to fail the build if we use deprecated code.', 'commenter': 'nkalmar'}, {'comment': 'Done', 'commenter': 'tamaashu'}]"
1372,pom.xml,"@@ -642,7 +649,6 @@
              <showWarnings>true</showWarnings>
              <compilerArgs>
                <compilerArg>-Werror</compilerArg>
-               <compilerArg>-Xlint:deprecation</compilerArg>","[{'comment': 'Any reason to remove this? I had another PR not so long ago where after deprecating a function supposedly not used caused the build to fail, it was useful. We can remove it, warning is also fine for me, just not sure why to remove it in this patch, or why it has been decided so.', 'commenter': 'nkalmar'}, {'comment': ""All the important jUnit methods got deprecated and if we don't remove this line the build fails. (In this phase I use the jUnit4 compatibility mode.)\r\nAfter the test code will have been converted to use jUnit5 methods (so not running in compatibility mode anymore) this line must be put back.\r\n(This is why I commented it out originally instead of removing.)"", 'commenter': 'tamaashu'}, {'comment': '@tamaashu Please create a Blocker issue for restoring this value.\r\n', 'commenter': 'eolivelli'}, {'comment': 'Done. See ZOOKEEPER-3862', 'commenter': 'tamaashu'}]"
1398,zookeeper-server/src/main/java/org/apache/zookeeper/client/ConnectStringParser.java,"@@ -70,16 +69,22 @@ public ConnectStringParser(String connectString) {
         List<String> hostsList = split(connectString, "","");
         for (String host : hostsList) {
             int port = DEFAULT_PORT;
-            try {
-                String[] hostAndPort = ConfigUtils.getHostAndPort(host);
+            String[] hostAndPort = NetUtils.getIPV6HostAndPort(host);
+            if (hostAndPort.length != 0) {
                 host = hostAndPort[0];
                 if (hostAndPort.length == 2) {
                     port = Integer.parseInt(hostAndPort[1]);
                 }
-            } catch (ConfigException e) {
-                e.printStackTrace();
+            } else {","[{'comment': 'Why this part of the logic is not inside \r\nNetUtils.getIPV6HostAndPort(host) ?\r\nWhat about pushing it up there?', 'commenter': 'eolivelli'}, {'comment': 'I wanted to make getIPV6HostAndPort  API more generic so it can be used other places as well for example it can be used to input of  host:port:port and [host]:port:port  as well. If we move above said logic to getIPV6HostAndPort  host:port:port will give wrong result; So I wanted to keep only common logic in  getIPV6HostAndPort.', 'commenter': 'arshadmohammad'}, {'comment': 'makes sense to me', 'commenter': 'eolivelli'}]"
1409,Jenkinsfile,"@@ -0,0 +1,71 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+pipeline {
+   agent none
+
+    options {
+        buildDiscarder(logRotator(daysToKeepStr: '14'))
+    }
+
+    triggers {
+        pollSCM 'H/10 * * * *'
+        cron('@daily')
+    }
+
+    stages {
+        stage('Prepare') {
+            matrix {
+                agent any
+                axes {
+                    axis {
+                        name 'JAVA_VERSION'
+                        values 'JDK 1.8 (latest)', 'JDK 11 (latest)'
+                    }
+                }
+
+                tools {
+                    // Install the Maven version configured as ""M3"" and add it to the path.
+                    maven ""Maven 3.5.4""","[{'comment': '3.6.3 is better. It is the latest version.', 'commenter': 'eolivelli'}, {'comment': 'Ok, done.', 'commenter': 'anmolnar'}]"
1411,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxnSocketNIO.java,"@@ -289,6 +289,10 @@ void connect(InetSocketAddress addr) throws IOException {
             LOG.error(""Unable to open socket to "" + addr);
             sock.close();
             throw e;
+        } catch (RuntimeException e) {
+            LOG.error(""Unable to open socket to "" + addr);","[{'comment': 'This code looks like the code above.\r\nCan we use multicatch syntax?', 'commenter': 'eolivelli'}, {'comment': 'No, because of Java 6 in this version. Sorry, but I have to use different catch blocks...', 'commenter': 'saltos'}, {'comment': 'Zookeeper is java8+ \r\nAs you can see we use lambdas and other language features', 'commenter': 'eolivelli'}, {'comment': 'Not this version. This is 3.4.14.\r\n```\r\n    <!-- maven properties -->\r\n    <maven.compiler.source>1.6</maven.compiler.source>\r\n    <maven.compiler.target>1.6</maven.compiler.target>\r\n```\r\nhttps://github.com/apache/zookeeper/blob/branch-3.4.14/pom.xml#L265\r\n', 'commenter': 'saltos'}, {'comment': 'We still use Zookeeper 3.4.13 because our Zookeeper Server is the same version. We can switch on 3.4.14, but I am not sure about more recent versions like 3.5 or 3.6. I fear that client library of the version 3.5 or 3.6 will not work with Zookeeper Server 3.4...', 'commenter': 'saltos'}]"
1416,Jenkinsfile-PreCommit,"@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+pipeline {
+    agent {
+        label 'Hadoop'
+    }
+
+    options {
+        disableConcurrentBuilds()
+        buildDiscarder(logRotator(daysToKeepStr: '14'))
+        timeout(time: 2, unit: 'HOURS')
+        timestamps()
+    }
+
+    tools {
+        maven ""Maven (latest)""
+        jdk ""JDK 1.8 (latest)""
+    }
+
+    stages {
+        stage('BuildAndTest') {
+            steps {
+                git 'https://github.com/apache/zookeeper'
+                sh ""mvn verify spotbugs:check checkstyle:check -Pfull-build -Dsurefire-forkcount=4""
+            }
+            post {
+                always {
+                   junit '**/target/surefire-reports/TEST-*.xml'
+                   archiveArtifacts '**/target/*.jar'","[{'comment': 'Why do you want to archive these files?', 'commenter': 'eolivelli'}, {'comment': ""Good catch. I'll remove it."", 'commenter': 'anmolnar'}]"
1416,Jenkinsfile-PreCommit,"@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+pipeline {","[{'comment': 'How do you tell Jenkins that this file is for PR?', 'commenter': 'eolivelli'}, {'comment': ""HBase folks have created separate Jenkins job for PRs. That's what we currently.\r\nI'll look into whether different options can be set for branches and PRs."", 'commenter': 'anmolnar'}]"
1417,zookeeper-server/pom.xml,"@@ -152,8 +152,22 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.junit.vintage</groupId>
-      <artifactId>junit-vintage-engine</artifactId>
+      <groupId>org.junit.jupiter</groupId>
+      <artifactId>junit-jupiter-api</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.junit.jupiter</groupId>
+      <artifactId>junit-jupiter-engine</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.junit.platform</groupId>
+      <artifactId>junit-platform-runner</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.junit.jupiter</groupId>
+      <artifactId>junit-jupiter</artifactId>
+      <version>5.4.2</version>","[{'comment': ""I guess we don't need this version here. (also it differs from the {junit.version} defined in the parent pom)"", 'commenter': 'symat'}, {'comment': 'Fixed', 'commenter': 'tamaashu'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/ClientRequestTimeoutTest.java,"@@ -19,78 +19,84 @@
 package org.apache.zookeeper;
 
 import static org.apache.zookeeper.test.ClientBase.CONNECTION_TIMEOUT;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTimeout;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
 import java.io.IOException;
+import java.time.Duration;
 import org.apache.zookeeper.ZooDefs.Ids;
 import org.apache.zookeeper.client.HostProvider;
 import org.apache.zookeeper.client.ZKClientConfig;
 import org.apache.zookeeper.server.quorum.QuorumPeerTestBase;
 import org.apache.zookeeper.test.ClientBase;
 import org.apache.zookeeper.test.ClientBase.CountdownWatcher;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class ClientRequestTimeoutTest extends QuorumPeerTestBase {
 
     private static final int SERVER_COUNT = 3;
     private boolean dropPacket = false;
     private int dropPacketType = ZooDefs.OpCode.create;
 
-    @Test(timeout = 120000)
+    @Test","[{'comment': 'I see there is a @Timeout annotation since 5.5. Although it is experimental. Did you try it maybe?\r\nhttps://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Timeout.html', 'commenter': 'symat'}, {'comment': 'assertTimeout is stable, so I preferred to use it.\r\nBut I can try it out.', 'commenter': 'tamaashu'}, {'comment': 'I would much prefer to use the annotation (for readability / clean code), if the timeout is really about the whole test and not only some small part of it. But only if it is stable. I wonder why is this experimental still. It was introduced in 5.5 and we are using 5.6 here.', 'commenter': 'symat'}, {'comment': 'Hmm, tried it out with a few cases, looks working.', 'commenter': 'tamaashu'}, {'comment': ""it is a huge work to change it back to annotations for all test cases... let's wait for the opinion of others, before you would change it"", 'commenter': 'symat'}, {'comment': ""@symat I've uploaded a change to use Timeout annotation. It looks working for me.\r\nThis way we need much less code changes which helps backportability."", 'commenter': 'tamaashu'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/ZKTestCase.java,"@@ -54,54 +52,35 @@ protected String getTestName() {
         return testName;
     }
 
-    @BeforeClass
+    @BeforeAll
     public static void before() {
         if (!testBaseDir.exists()) {
-            assertTrue(
-                ""Cannot properly create test base directory "" + testBaseDir.getAbsolutePath(),
-                testBaseDir.mkdirs());
+            assertTrue(testBaseDir.mkdirs(),
+                ""Cannot properly create test base directory "" + testBaseDir.getAbsolutePath());
         } else if (!testBaseDir.isDirectory()) {
-            assertTrue(
-                ""Cannot properly delete file with duplicate name of test base directory "" + testBaseDir.getAbsolutePath(),
-                testBaseDir.delete());
-            assertTrue(
-                ""Cannot properly create test base directory "" + testBaseDir.getAbsolutePath(),
-                testBaseDir.mkdirs());
+            assertTrue(testBaseDir.delete(),
+                ""Cannot properly delete file with duplicate name of test base directory "" + testBaseDir.getAbsolutePath());
+            assertTrue(testBaseDir.mkdirs(),
+                ""Cannot properly create test base directory "" + testBaseDir.getAbsolutePath());
         }
     }
 
-    @Rule
-    public TestWatcher watchman = new TestWatcher() {
-
-        @Override
-        public void starting(Description method) {
-            // By default, disable starting a JettyAdminServer in tests to avoid
-            // accidentally attempting to start multiple admin servers on the
-            // same port.
-            System.setProperty(""zookeeper.admin.enableServer"", ""false"");
-            // ZOOKEEPER-2693 disables all 4lw by default.
-            // Here we enable the 4lw which ZooKeeper tests depends.
-            System.setProperty(""zookeeper.4lw.commands.whitelist"", ""*"");
-            testName = method.getMethodName();
-            LOG.info(""STARTING {}"", testName);
-        }
-
-        @Override
-        public void finished(Description method) {
-            LOG.info(""FINISHED {}"", testName);
-        }
-
-        @Override
-        public void succeeded(Description method) {
-            LOG.info(""SUCCEEDED {}"", testName);
-        }
-
-        @Override
-        public void failed(Throwable e, Description method) {
-            LOG.error(""FAILED {}"", testName, e);
-        }
+    @BeforeEach
+    public void starting(TestInfo testInfo) {","[{'comment': 'just for curiosity: is it guaranteed, that the ZKTestCase.starting will be executed before any `@BeforeEach` annotated setup method in the child classes?', 'commenter': 'symat'}, {'comment': 'According to the documentation yes, except they get overridden: https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/BeforeEach.html', 'commenter': 'tamaashu'}, {'comment': 'cool', 'commenter': 'symat'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/common/BaseX509ParameterizedTestCase.java,"@@ -106,4 +108,24 @@ protected BaseX509ParameterizedTestCase(
         }
     }
 
+    public void init(","[{'comment': ""do we need this method to be public?  protected wouldn't be more appropriate?\r\nmaybe we do need public, I might not see all the usage (it's not a small PR :p). but AFAICS we only call this from child classes."", 'commenter': 'symat'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/RemoveWatchesTest.java,"@@ -82,15 +84,10 @@ public void tearDown() throws Exception {
         super.tearDown();
     }
 
-    private final boolean useAsync;
-
-    public RemoveWatchesTest(boolean useAsync) {
-        this.useAsync = useAsync;
-    }
-
-    @Parameters
-    public static Collection<Object[]> configs() {
-        return Arrays.asList(new Object[][]{{false}, {true}});
+    public static Stream<Arguments> data() throws Exception {","[{'comment': ""for these trivial test parameter wouldn't be nicer to use `@ValueSource` instead of `@MethodSource` ?\r\nsee: https://www.baeldung.com/parameterized-tests-junit-5#1-simple-values"", 'commenter': 'symat'}, {'comment': ""the page above doesn't list `booleans` as annotation parameter, but according to the javadoc, it works too:  https://junit.org/junit5/docs/current/api/org.junit.jupiter.params/org/junit/jupiter/params/provider/ValueSource.html"", 'commenter': 'symat'}, {'comment': 'Fixed', 'commenter': 'tamaashu'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/LearnerMetricsTest.java,"@@ -32,50 +31,41 @@
 import org.apache.zookeeper.server.ServerMetrics;
 import org.apache.zookeeper.test.ClientBase;
 import org.hamcrest.Matcher;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-@RunWith(Parameterized.class)
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
 public class LearnerMetricsTest extends QuorumPeerTestBase {
 
     private static final int TIMEOUT_SECONDS = 30;
     private static final int SERVER_COUNT = 4; // 1 observer, 3 participants
     private final QuorumPeerTestBase.MainThread[] mt = new QuorumPeerTestBase.MainThread[SERVER_COUNT];
     private ZooKeeper zk_client;
-    private boolean asyncSending;
     private static boolean bakAsyncSending;
 
-    public LearnerMetricsTest(boolean asyncSending) {
-        this.asyncSending = asyncSending;
-    }
-
-    @Parameterized.Parameters
-    public static Collection sendingModes() {
-        return Arrays.asList(new Object[][]{{true}, {false}});
+    public static Stream<Arguments> data() {","[{'comment': 'maybe `@ValueSource(booleans={true,false})` here too?\r\nhttps://junit.org/junit5/docs/current/api/org.junit.jupiter.params/org/junit/jupiter/params/provider/ValueSource.html', 'commenter': 'symat'}, {'comment': 'Fixed', 'commenter': 'tamaashu'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/LearnerSyncThrottlerTest.java,"@@ -18,63 +18,66 @@
 
 package org.apache.zookeeper.server.quorum;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
 import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
+import java.util.stream.Stream;
 import org.apache.zookeeper.ZKTestCase;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-@RunWith(Parameterized.class)
 public class LearnerSyncThrottlerTest extends ZKTestCase {
 
     private static final Logger LOG = LoggerFactory.getLogger(LearnerSyncThrottlerTest.class);
 
-    private LearnerSyncThrottler.SyncType syncType;
-    public LearnerSyncThrottlerTest(LearnerSyncThrottler.SyncType syncType) {
-        this.syncType = syncType;
+    public static Stream<Arguments> data() {","[{'comment': 'instead of data(), we can use `@EnumSource`\r\nhttps://www.baeldung.com/parameterized-tests-junit-5#3-enum', 'commenter': 'symat'}, {'comment': 'Fixed', 'commenter': 'tamaashu'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/ReconfigDuringLeaderSyncTest.java,"@@ -39,48 +38,40 @@
 import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
 import org.apache.zookeeper.test.ClientBase;
 import org.apache.zookeeper.test.ClientBase.CountdownWatcher;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-@RunWith(Parameterized.class)
 public class ReconfigDuringLeaderSyncTest extends QuorumPeerTestBase {
 
     private static final Logger LOG = LoggerFactory.getLogger(ReconfigDuringLeaderSyncTest.class);
     private static int SERVER_COUNT = 3;
     private MainThread[] mt;
     private static boolean bakAsyncSending;
 
-    private boolean asyncSending;
-
-    public ReconfigDuringLeaderSyncTest(boolean asyncSending) {
-        this.asyncSending = asyncSending;
-    }
-
-    @Parameterized.Parameters
-    public static Collection sendingModes() {
-        return Arrays.asList(new Object[][]{{true}, {false}});
+    public static Stream<Arguments> data() {","[{'comment': '`@ValueSource` here too', 'commenter': 'symat'}, {'comment': 'Fixed', 'commenter': 'tamaashu'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/UnifiedServerSocketModeDetectionTest.java,"@@ -61,23 +59,19 @@
  * trigger blocking mode detection. This is necessary to ensure that the
  * Leader's accept() thread doesn't get blocked.
  */
-@RunWith(Parameterized.class)
 public class UnifiedServerSocketModeDetectionTest extends ZKTestCase {
 
     private static final Logger LOG = LoggerFactory.getLogger(UnifiedServerSocketModeDetectionTest.class);
 
-    @Parameterized.Parameters
-    public static Collection<Object[]> params() {
-        ArrayList<Object[]> result = new ArrayList<>();
-        result.add(new Object[]{true});
-        result.add(new Object[]{false});
-        return result;
+    public static Stream<Arguments> data() throws Exception {","[{'comment': '`@ValueSource` here too', 'commenter': 'symat'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/WatchLeakTest.java,"@@ -70,36 +67,30 @@
 /**
  * Demonstrate ZOOKEEPER-1382 : Watches leak on expired session
  */
-@RunWith(Parameterized.class)
-@Parameterized.UseParametersRunnerFactory(ZKParameterized.RunnerFactory.class)
 public class WatchLeakTest {
 
     protected static final Logger LOG = LoggerFactory.getLogger(WatchLeakTest.class);
 
     final long SESSION_ID = 0xBABEL;
 
-    private final boolean sessionTimedout;
-
-    @Before
+    @BeforeEach
     public void setUp() {
         System.setProperty(""zookeeper.admin.enableServer"", ""false"");
     }
 
-    public WatchLeakTest(boolean sessionTimedout) {
-        this.sessionTimedout = sessionTimedout;
-    }
-
-    @Parameters
-    public static Collection<Object[]> configs() {
-        return Arrays.asList(new Object[][]{{false}, {true}});
+    public static Stream<Arguments> data() throws Exception {","[{'comment': '`@ValueSource` here too', 'commenter': 'symat'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/test/MultiOperationTest.java,"@@ -52,42 +54,33 @@
 import org.apache.zookeeper.Transaction;
 import org.apache.zookeeper.WatchedEvent;
 import org.apache.zookeeper.Watcher;
-import org.apache.zookeeper.ZKParameterized;
 import org.apache.zookeeper.ZooDefs;
 import org.apache.zookeeper.ZooDefs.Ids;
 import org.apache.zookeeper.ZooKeeper;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Id;
 import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.server.SyncRequestProcessor;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-@RunWith(Parameterized.class)
-@Parameterized.UseParametersRunnerFactory(ZKParameterized.RunnerFactory.class)
 public class MultiOperationTest extends ClientBase {
 
     private static final Logger LOG = LoggerFactory.getLogger(MultiOperationTest.class);
     private ZooKeeper zk;
     private ZooKeeper zk_chroot;
 
-    private final boolean useAsync;
-
-    public MultiOperationTest(boolean useAsync) {
-        this.useAsync = useAsync;
-    }
-
-    @Parameters
-    public static Collection<Object[]> configs() {
-        return Arrays.asList(new Object[][]{{false}, {true}});
+    public static Stream<Arguments> data() throws Exception {","[{'comment': '`@ValueSource(booleans={true,false})` here too', 'commenter': 'symat'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/test/ObserverMasterTest.java,"@@ -60,30 +59,20 @@
 import org.apache.zookeeper.server.admin.Commands;
 import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
 import org.apache.zookeeper.server.util.PortForwarder;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-@RunWith(Parameterized.class)
 public class ObserverMasterTest extends ObserverMasterTestBase {
 
     protected static final Logger LOG = LoggerFactory.getLogger(ObserverMasterTest.class);
 
-    public ObserverMasterTest(Boolean testObserverMaster) {
-        this.testObserverMaster = testObserverMaster;
-    }
-
-    @Parameterized.Parameters
-    public static List<Object[]> data() {
-        return Arrays.asList(new Object[][]{{Boolean.TRUE}, {Boolean.FALSE}});
-    }
-
-    private Boolean testObserverMaster;
-
-    private PortForwarder setUp(final int omProxyPort) throws IOException {
-        return setUp(omProxyPort, testObserverMaster);
+    public static Stream<Arguments> data() {","[{'comment': '`@ValueSource(booleans={true,false})` here too', 'commenter': 'symat'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/test/ObserverMasterTest.java,"@@ -416,8 +398,9 @@ private ZooKeeperAdmin createAdmin(int clientPort) throws IOException {
 
     // This test is known to be flaky and fail due to ""reconfig already in progress"".
     // TODO: Investigate intermittent testDynamicReconfig failures.
-    // @Test
-    public void testDynamicReconfig() throws InterruptedException, IOException, KeeperException {
+    // @ParameterizedTest","[{'comment': 'I would prefer to properly ignore the test (`@Disabled`), so it is listed among the ignored tests.', 'commenter': 'symat'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/test/QuorumBase.java,"@@ -70,11 +71,12 @@
     protected boolean localSessionsEnabled = false;
     protected boolean localSessionsUpgradingEnabled = false;
 
-    @Test
+    //@Test
     // This just avoids complaints by junit
     public void testNull() {","[{'comment': 'do we still need this method?', 'commenter': 'symat'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/test/ThrottledOpQuorumTest.java,"@@ -23,15 +23,22 @@
 import org.apache.zookeeper.ZooKeeper;
 import org.apache.zookeeper.server.ZooKeeperServer;
 import org.apache.zookeeper.server.quorum.QuorumPeer;
-import org.junit.BeforeClass;
-import org.junit.Test;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
 public class ThrottledOpQuorumTest extends QuorumBase {
-    @BeforeClass
+    @BeforeAll
     public static void applyMockUps() {
         ThrottledOpHelper.applyMockUps();
     }
 
+    @BeforeEach
+    @Override
+    public void setUp() throws Exception {","[{'comment': 'why do we need this method? (maybe I just miss something)', 'commenter': 'symat'}]"
1417,zookeeper-server/src/test/java/org/apache/zookeeper/util/PemReaderTest.java,"@@ -18,50 +18,35 @@
 
 package org.apache.zookeeper.util;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
 import java.io.IOException;
 import java.security.GeneralSecurityException;
 import java.security.KeyStoreException;
 import java.security.PrivateKey;
 import java.security.cert.X509Certificate;
-import java.util.Collection;
 import java.util.List;
 import java.util.Optional;
+import java.util.stream.Stream;
 import org.apache.zookeeper.common.BaseX509ParameterizedTestCase;
 import org.apache.zookeeper.common.KeyStoreFileType;
 import org.apache.zookeeper.common.X509KeyType;
-import org.apache.zookeeper.common.X509TestContext;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
 
-@RunWith(Parameterized.class)
 public class PemReaderTest extends BaseX509ParameterizedTestCase {
 
-    @Parameterized.Parameters
-    public static Collection<Object[]> params() {
+    public static Stream<Arguments> data() {
         return BaseX509ParameterizedTestCase.defaultParams();
     }
 
-    public PemReaderTest(
-            X509KeyType caKeyType, X509KeyType certKeyType, String keyPassword, Integer paramIndex) {
-        super(paramIndex, () -> {
-            try {
-                return X509TestContext.newBuilder()
-                        .setTempDir(tempDir)
-                        .setKeyStorePassword(keyPassword)
-                        .setKeyStoreKeyType(certKeyType)
-                        .setTrustStorePassword(keyPassword)
-                        .setTrustStoreKeyType(caKeyType)
-                        .build();
-            } catch (Exception e) {
-                throw new RuntimeException(e);
-            }
-        });
-    }
-
-    @Test
-    public void testLoadPrivateKeyFromKeyStore() throws IOException, GeneralSecurityException {
+    @ParameterizedTest
+    @MethodSource(""data"")","[{'comment': 'just for curiosity... wouldn\'t `@MethodSource(""defaultParams"")` or `@MethodSource(""org.apache.zookeeper.common.BaseX509ParameterizedTestCase#defaultParams"")` work in all the child classes of `BaseX509ParameterizedTestCase`? then we wouldn\'t need to define the `data()` method in any of these, making the code a bit more compact.\r\n', 'commenter': 'symat'}, {'comment': 'Done', 'commenter': 'tamaashu'}]"
1420,bin/zkServer.sh,"@@ -37,73 +37,62 @@ fi
 # up the JVM to accept JMX remote management:
 # http://java.sun.com/javase/6/docs/technotes/guides/management/agent.html
 # by default we allow local JMX connections
-if [ ""x$JMXLOCALONLY"" = ""x"" ]
-then
-    JMXLOCALONLY=false
+if [ -n ""$JMXLOCALONLY"" ]; then
+  JMXLOCALONLY=false","[{'comment': 'Shouldn\'t this be:\r\n\r\n```suggestion\r\nif [ -z ""$JMXLOCALONLY"" ]; then\r\n  JMXLOCALONLY=false\r\n```', 'commenter': 'ctubbsii'}, {'comment': ""Yeah, it got me pretty messed up the x=x xDD. You are absolutely right, I'm gonna change it 👍 \r\nThanks!"", 'commenter': 'tanisdlj'}]"
1420,bin/zkServer.sh,"@@ -37,73 +37,62 @@ fi
 # up the JVM to accept JMX remote management:
 # http://java.sun.com/javase/6/docs/technotes/guides/management/agent.html
 # by default we allow local JMX connections
-if [ ""x$JMXLOCALONLY"" = ""x"" ]
-then
-    JMXLOCALONLY=false
+if [ -z ""$JMXLOCALONLY"" ]; then
+  JMXLOCALONLY=false
 fi
 
-if [ ""x$JMXDISABLE"" = ""x"" ] || [ ""$JMXDISABLE"" = 'false' ]
-then
+if [ -z ""$JMXDISABLE"" ] || [ ""$JMXDISABLE"" == 'false' ]; then
   echo ""ZooKeeper JMX enabled by default"" >&2
-  if [ ""x$JMXPORT"" = ""x"" ]
-  then
+  if [ -z ""$JMXPORT"" ];   then
     # for some reason these two options are necessary on jdk6 on Ubuntu
     #   accord to the docs they are not necessary, but otw jconsole cannot
     #   do a local attach
     ZOOMAIN=""-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=$JMXLOCALONLY org.apache.zookeeper.server.quorum.QuorumPeerMain""
   else
-    if [ ""x$JMXAUTH"" = ""x"" ]
-    then
+    if [ -z ""$JMXAUTH"" ]; then
       JMXAUTH=false
     fi
-    if [ ""x$JMXSSL"" = ""x"" ]
-    then
+    if [ -z ""$JMXSSL"" ]; then
       JMXSSL=false
     fi
-    if [ ""x$JMXLOG4J"" = ""x"" ]
-    then
+    if [ -z ""$JMXLOG4J"" ]; then
       JMXLOG4J=true
     fi
     echo ""ZooKeeper remote JMX Port set to $JMXPORT"" >&2
     echo ""ZooKeeper remote JMX authenticate set to $JMXAUTH"" >&2
     echo ""ZooKeeper remote JMX ssl set to $JMXSSL"" >&2
     echo ""ZooKeeper remote JMX log4j set to $JMXLOG4J"" >&2
-    if [ ""x$JMXHOSTNAME"" = ""x"" ]
-    then
+    if [ -z ""$JMXHOSTNAME"" ]; then
       ZOOMAIN=""-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=$JMXPORT -Dcom.sun.management.jmxremote.authenticate=$JMXAUTH -Dcom.sun.management.jmxremote.ssl=$JMXSSL -Dzookeeper.jmx.log4j.disable=$JMXLOG4J org.apache.zookeeper.server.quorum.QuorumPeerMain""
     else
       echo ""ZooKeeper remote JMX Hostname set to $JMXHOSTNAME"" >&2
       ZOOMAIN=""-Dcom.sun.management.jmxremote -Djava.rmi.server.hostname=$JMXHOSTNAME -Dcom.sun.management.jmxremote.port=$JMXPORT -Dcom.sun.management.jmxremote.authenticate=$JMXAUTH -Dcom.sun.management.jmxremote.ssl=$JMXSSL -Dzookeeper.jmx.log4j.disable=$JMXLOG4J org.apache.zookeeper.server.quorum.QuorumPeerMain""
     fi
   fi
 else
-    echo ""JMX disabled by user request"" >&2
-    ZOOMAIN=""org.apache.zookeeper.server.quorum.QuorumPeerMain""
+  echo ""JMX disabled by user request"" >&2
+  ZOOMAIN=""org.apache.zookeeper.server.quorum.QuorumPeerMain""
 fi
 
-if [ ""x$SERVER_JVMFLAGS"" != ""x"" ]
-then
-    JVMFLAGS=""$SERVER_JVMFLAGS $JVMFLAGS""
+if [ -z ""$SERVER_JVMFLAGS"" ]; then","[{'comment': 'This one should be `-n`, since it was a `!=`.\r\n```suggestion\r\nif [ -n ""$SERVER_JVMFLAGS"" ]; then\r\n```', 'commenter': 'ctubbsii'}]"
1420,bin/zkServer.sh,"@@ -37,73 +37,62 @@ fi
 # up the JVM to accept JMX remote management:
 # http://java.sun.com/javase/6/docs/technotes/guides/management/agent.html
 # by default we allow local JMX connections
-if [ ""x$JMXLOCALONLY"" = ""x"" ]
-then
-    JMXLOCALONLY=false
+if [ -z ""$JMXLOCALONLY"" ]; then
+  JMXLOCALONLY=false
 fi
 
-if [ ""x$JMXDISABLE"" = ""x"" ] || [ ""$JMXDISABLE"" = 'false' ]
-then
+if [ -z ""$JMXDISABLE"" ] || [ ""$JMXDISABLE"" == 'false' ]; then
   echo ""ZooKeeper JMX enabled by default"" >&2
-  if [ ""x$JMXPORT"" = ""x"" ]
-  then
+  if [ -z ""$JMXPORT"" ];   then
     # for some reason these two options are necessary on jdk6 on Ubuntu
     #   accord to the docs they are not necessary, but otw jconsole cannot
     #   do a local attach
     ZOOMAIN=""-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=$JMXLOCALONLY org.apache.zookeeper.server.quorum.QuorumPeerMain""
   else
-    if [ ""x$JMXAUTH"" = ""x"" ]
-    then
+    if [ -z ""$JMXAUTH"" ]; then
       JMXAUTH=false
     fi
-    if [ ""x$JMXSSL"" = ""x"" ]
-    then
+    if [ -z ""$JMXSSL"" ]; then
       JMXSSL=false
     fi
-    if [ ""x$JMXLOG4J"" = ""x"" ]
-    then
+    if [ -z ""$JMXLOG4J"" ]; then
       JMXLOG4J=true
     fi
     echo ""ZooKeeper remote JMX Port set to $JMXPORT"" >&2
     echo ""ZooKeeper remote JMX authenticate set to $JMXAUTH"" >&2
     echo ""ZooKeeper remote JMX ssl set to $JMXSSL"" >&2
     echo ""ZooKeeper remote JMX log4j set to $JMXLOG4J"" >&2
-    if [ ""x$JMXHOSTNAME"" = ""x"" ]
-    then
+    if [ -z ""$JMXHOSTNAME"" ]; then
       ZOOMAIN=""-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=$JMXPORT -Dcom.sun.management.jmxremote.authenticate=$JMXAUTH -Dcom.sun.management.jmxremote.ssl=$JMXSSL -Dzookeeper.jmx.log4j.disable=$JMXLOG4J org.apache.zookeeper.server.quorum.QuorumPeerMain""
     else
       echo ""ZooKeeper remote JMX Hostname set to $JMXHOSTNAME"" >&2
       ZOOMAIN=""-Dcom.sun.management.jmxremote -Djava.rmi.server.hostname=$JMXHOSTNAME -Dcom.sun.management.jmxremote.port=$JMXPORT -Dcom.sun.management.jmxremote.authenticate=$JMXAUTH -Dcom.sun.management.jmxremote.ssl=$JMXSSL -Dzookeeper.jmx.log4j.disable=$JMXLOG4J org.apache.zookeeper.server.quorum.QuorumPeerMain""
     fi
   fi
 else
-    echo ""JMX disabled by user request"" >&2
-    ZOOMAIN=""org.apache.zookeeper.server.quorum.QuorumPeerMain""
+  echo ""JMX disabled by user request"" >&2
+  ZOOMAIN=""org.apache.zookeeper.server.quorum.QuorumPeerMain""
 fi
 
-if [ ""x$SERVER_JVMFLAGS"" != ""x"" ]
-then
-    JVMFLAGS=""$SERVER_JVMFLAGS $JVMFLAGS""
+if [ -z ""$SERVER_JVMFLAGS"" ]; then
+  JVMFLAGS=""$SERVER_JVMFLAGS $JVMFLAGS""
 fi
 
-if [ ""x$2"" != ""x"" ]
-then
-    ZOOCFG=""$ZOOCFGDIR/$2""
+if [ -z ""$2"" ]; then","[{'comment': 'This one should be `-n`, since it was a `!=`.\r\n```suggestion\r\nif [ -n ""$2"" ]; then\r\n```', 'commenter': 'ctubbsii'}]"
1420,bin/zkServer.sh,"@@ -122,51 +111,51 @@ ZOO_DATALOGDIR=""$($GREP ""^[[:space:]]*dataLogDir"" ""$ZOOCFG"" | sed -e 's/.*=//')""
 
 # iff autocreate is turned off and the datadirs don't exist fail
 # immediately as we can't create the PID file, etc..., anyway.
-if [ -n ""$ZOO_DATADIR_AUTOCREATE_DISABLE"" ]; then
-    if [ ! -d ""$ZOO_DATADIR/version-2"" ]; then
-        echo ""ZooKeeper data directory is missing at $ZOO_DATADIR fix the path or run initialize""
-        exit 1
-    fi
+if [ -z ""$ZOO_DATADIR_AUTOCREATE_DISABLE"" ]; then","[{'comment': 'I\'m not sure this should have been changed.\r\n```suggestion\r\nif [ -n ""$ZOO_DATADIR_AUTOCREATE_DISABLE"" ]; then\r\n```', 'commenter': 'ctubbsii'}]"
1420,bin/zkServer.sh,"@@ -122,51 +111,51 @@ ZOO_DATALOGDIR=""$($GREP ""^[[:space:]]*dataLogDir"" ""$ZOOCFG"" | sed -e 's/.*=//')""
 
 # iff autocreate is turned off and the datadirs don't exist fail
 # immediately as we can't create the PID file, etc..., anyway.
-if [ -n ""$ZOO_DATADIR_AUTOCREATE_DISABLE"" ]; then
-    if [ ! -d ""$ZOO_DATADIR/version-2"" ]; then
-        echo ""ZooKeeper data directory is missing at $ZOO_DATADIR fix the path or run initialize""
-        exit 1
-    fi
+if [ -z ""$ZOO_DATADIR_AUTOCREATE_DISABLE"" ]; then
+  if [ ! -d ""$ZOO_DATADIR/version-2"" ]; then
+    echo ""ZooKeeper data directory is missing at $ZOO_DATADIR fix the path or run initialize""
+    exit 1
+  fi
 
-    if [ -n ""$ZOO_DATALOGDIR"" ] && [ ! -d ""$ZOO_DATALOGDIR/version-2"" ]; then
-        echo ""ZooKeeper txnlog directory is missing at $ZOO_DATALOGDIR fix the path or run initialize""
-        exit 1
-    fi
-    ZOO_DATADIR_AUTOCREATE=""-Dzookeeper.datadir.autocreate=false""
+  if [ -z ""$ZOO_DATALOGDIR"" ] && [ ! -d ""$ZOO_DATALOGDIR/version-2"" ]; then","[{'comment': 'This one shouldn\'t have changed:\r\n```suggestion\r\n  if [ -n ""$ZOO_DATALOGDIR"" ] && [ ! -d ""$ZOO_DATALOGDIR/version-2"" ]; then\r\n```', 'commenter': 'ctubbsii'}]"
1420,bin/zkServer.sh,"@@ -122,51 +111,51 @@ ZOO_DATALOGDIR=""$($GREP ""^[[:space:]]*dataLogDir"" ""$ZOOCFG"" | sed -e 's/.*=//')""
 
 # iff autocreate is turned off and the datadirs don't exist fail
 # immediately as we can't create the PID file, etc..., anyway.
-if [ -n ""$ZOO_DATADIR_AUTOCREATE_DISABLE"" ]; then
-    if [ ! -d ""$ZOO_DATADIR/version-2"" ]; then
-        echo ""ZooKeeper data directory is missing at $ZOO_DATADIR fix the path or run initialize""
-        exit 1
-    fi
+if [ -z ""$ZOO_DATADIR_AUTOCREATE_DISABLE"" ]; then
+  if [ ! -d ""$ZOO_DATADIR/version-2"" ]; then
+    echo ""ZooKeeper data directory is missing at $ZOO_DATADIR fix the path or run initialize""
+    exit 1
+  fi
 
-    if [ -n ""$ZOO_DATALOGDIR"" ] && [ ! -d ""$ZOO_DATALOGDIR/version-2"" ]; then
-        echo ""ZooKeeper txnlog directory is missing at $ZOO_DATALOGDIR fix the path or run initialize""
-        exit 1
-    fi
-    ZOO_DATADIR_AUTOCREATE=""-Dzookeeper.datadir.autocreate=false""
+  if [ -z ""$ZOO_DATALOGDIR"" ] && [ ! -d ""$ZOO_DATALOGDIR/version-2"" ]; then
+    echo ""ZooKeeper txnlog directory is missing at $ZOO_DATALOGDIR fix the path or run initialize""
+    exit 1
+  fi
+  ZOO_DATADIR_AUTOCREATE=""-Dzookeeper.datadir.autocreate=false""
 fi
 
 if [ -z ""$ZOOPIDFILE"" ]; then
-    if [ ! -d ""$ZOO_DATADIR"" ]; then
-        mkdir -p ""$ZOO_DATADIR""
-    fi
-    ZOOPIDFILE=""$ZOO_DATADIR/zookeeper_server.pid""
+  if [ ! -d ""$ZOO_DATADIR"" ]; then
+    mkdir -p ""$ZOO_DATADIR""
+  fi
+  ZOOPIDFILE=""$ZOO_DATADIR/zookeeper_server.pid""
 else
-    # ensure it exists, otw stop will fail
-    mkdir -p ""$(dirname ""$ZOOPIDFILE"")""
+  # ensure it exists, otw stop will fail
+  mkdir -p ""$(dirname ""$ZOOPIDFILE"")""
 fi
 
 if [ ! -w ""$ZOO_LOG_DIR"" ] ; then
-mkdir -p ""$ZOO_LOG_DIR""
+  mkdir -p ""$ZOO_LOG_DIR""
 fi
 
 ZOO_LOG_FILE=zookeeper-$USER-server-$HOSTNAME.log
 _ZOO_DAEMON_OUT=""$ZOO_LOG_DIR/zookeeper-$USER-server-$HOSTNAME.out""
 
 case $1 in
 start)
-    echo  -n ""Starting zookeeper ... ""
+    echo -n ""Starting zookeeper ... ""
     if [ -f ""$ZOOPIDFILE"" ]; then
-      if kill -0 `cat ""$ZOOPIDFILE""` > /dev/null 2>&1; then
-         echo $command already running as process `cat ""$ZOOPIDFILE""`.
-         exit 1
+      if kill -0 $(cat ""$ZOOPIDFILE"") > /dev/null 2>&1; then
+        echo ""$command"" already running as process $(cat ""$ZOOPIDFILE"").","[{'comment': 'It\'d be better to quote the entire arg as a single arg, rather than pass multiple args.\r\n```suggestion\r\n        echo ""$command already running as process $(cat ""$ZOOPIDFILE"").""\r\n```', 'commenter': 'ctubbsii'}, {'comment': 'Agree', 'commenter': 'tanisdlj'}]"
1420,bin/zkServer.sh,"@@ -122,51 +111,51 @@ ZOO_DATALOGDIR=""$($GREP ""^[[:space:]]*dataLogDir"" ""$ZOOCFG"" | sed -e 's/.*=//')""
 
 # iff autocreate is turned off and the datadirs don't exist fail
 # immediately as we can't create the PID file, etc..., anyway.
-if [ -n ""$ZOO_DATADIR_AUTOCREATE_DISABLE"" ]; then
-    if [ ! -d ""$ZOO_DATADIR/version-2"" ]; then
-        echo ""ZooKeeper data directory is missing at $ZOO_DATADIR fix the path or run initialize""
-        exit 1
-    fi
+if [ -z ""$ZOO_DATADIR_AUTOCREATE_DISABLE"" ]; then
+  if [ ! -d ""$ZOO_DATADIR/version-2"" ]; then
+    echo ""ZooKeeper data directory is missing at $ZOO_DATADIR fix the path or run initialize""
+    exit 1
+  fi
 
-    if [ -n ""$ZOO_DATALOGDIR"" ] && [ ! -d ""$ZOO_DATALOGDIR/version-2"" ]; then
-        echo ""ZooKeeper txnlog directory is missing at $ZOO_DATALOGDIR fix the path or run initialize""
-        exit 1
-    fi
-    ZOO_DATADIR_AUTOCREATE=""-Dzookeeper.datadir.autocreate=false""
+  if [ -z ""$ZOO_DATALOGDIR"" ] && [ ! -d ""$ZOO_DATALOGDIR/version-2"" ]; then
+    echo ""ZooKeeper txnlog directory is missing at $ZOO_DATALOGDIR fix the path or run initialize""
+    exit 1
+  fi
+  ZOO_DATADIR_AUTOCREATE=""-Dzookeeper.datadir.autocreate=false""
 fi
 
 if [ -z ""$ZOOPIDFILE"" ]; then
-    if [ ! -d ""$ZOO_DATADIR"" ]; then
-        mkdir -p ""$ZOO_DATADIR""
-    fi
-    ZOOPIDFILE=""$ZOO_DATADIR/zookeeper_server.pid""
+  if [ ! -d ""$ZOO_DATADIR"" ]; then
+    mkdir -p ""$ZOO_DATADIR""
+  fi
+  ZOOPIDFILE=""$ZOO_DATADIR/zookeeper_server.pid""
 else
-    # ensure it exists, otw stop will fail
-    mkdir -p ""$(dirname ""$ZOOPIDFILE"")""
+  # ensure it exists, otw stop will fail
+  mkdir -p ""$(dirname ""$ZOOPIDFILE"")""
 fi
 
 if [ ! -w ""$ZOO_LOG_DIR"" ] ; then
-mkdir -p ""$ZOO_LOG_DIR""
+  mkdir -p ""$ZOO_LOG_DIR""
 fi
 
 ZOO_LOG_FILE=zookeeper-$USER-server-$HOSTNAME.log
 _ZOO_DAEMON_OUT=""$ZOO_LOG_DIR/zookeeper-$USER-server-$HOSTNAME.out""
 
 case $1 in
 start)
-    echo  -n ""Starting zookeeper ... ""
+    echo -n ""Starting zookeeper ... ""
     if [ -f ""$ZOOPIDFILE"" ]; then
-      if kill -0 `cat ""$ZOOPIDFILE""` > /dev/null 2>&1; then
-         echo $command already running as process `cat ""$ZOOPIDFILE""`.
-         exit 1
+      if kill -0 $(cat ""$ZOOPIDFILE"") > /dev/null 2>&1; then
+        echo ""$command"" already running as process $(cat ""$ZOOPIDFILE"").
+        exit 1
       fi
     fi
     nohup ""$JAVA"" $ZOO_DATADIR_AUTOCREATE ""-Dzookeeper.log.dir=${ZOO_LOG_DIR}"" \
     ""-Dzookeeper.log.file=${ZOO_LOG_FILE}"" ""-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}"" \
     -XX:+HeapDumpOnOutOfMemoryError -XX:OnOutOfMemoryError='kill -9 %p' \
-    -cp ""$CLASSPATH"" $JVMFLAGS $ZOOMAIN ""$ZOOCFG"" > ""$_ZOO_DAEMON_OUT"" 2>&1 < /dev/null &
-    if [ $? -eq 0 ]
-    then
+    -cp ""$CLASSPATH"" ""$JVMFLAGS"" $ZOOMAIN ""$ZOOCFG"" > ""$_ZOO_DAEMON_OUT"" 2>&1 < /dev/null &","[{'comment': 'Even though this one will trigger a ShellCheck warning, it should *not* be quoted. It is intentionally split, since the variable is not an array and it\'s expected that multiple JVM flags can be provided in a single variable. This is normal for this kind of variable. You can probably configure ShellCheck to ignore this one, but it will probably be too aggressive and ignore the entire line. It\'s probably best to just add a comment that `$JVMFLAGS` should not be double-quoted.\r\n\r\n```suggestion\r\n    -cp ""$CLASSPATH"" $JVMFLAGS $ZOOMAIN ""$ZOOCFG"" > ""$_ZOO_DAEMON_OUT"" 2>&1 < /dev/null &\r\n```\r\n\r\nAlso, `-cp` shouldn\'t be used at all. Instead, the `CLASSPATH` environment variable should be exported. The `-cp` method for passing the class path makes the command-line insanely long, sometimes exceeding the system\'s maximum command-line length. However, that is a separate issue and should be fixed separately.', 'commenter': 'ctubbsii'}, {'comment': 'Agree in the second part, and you are right :)', 'commenter': 'tanisdlj'}]"
1420,bin/zkServer.sh,"@@ -202,7 +190,7 @@ start-foreground)
     ""${ZOO_CMD[@]}"" $ZOO_DATADIR_AUTOCREATE ""-Dzookeeper.log.dir=${ZOO_LOG_DIR}"" \
     ""-Dzookeeper.log.file=${ZOO_LOG_FILE}"" ""-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}"" \
     -XX:+HeapDumpOnOutOfMemoryError -XX:OnOutOfMemoryError='kill -9 %p' \
-    -cp ""$CLASSPATH"" $JVMFLAGS $ZOOMAIN ""$ZOOCFG""
+    -cp ""$CLASSPATH"" ""$JVMFLAGS"" $ZOOMAIN ""$ZOOCFG""","[{'comment': 'Another intentionally unquoted `$JVMFLAGS`\r\n\r\n```suggestion\r\n    -cp ""$CLASSPATH"" $JVMFLAGS $ZOOMAIN ""$ZOOCFG""\r\n```', 'commenter': 'ctubbsii'}]"
1420,bin/zkServer.sh,"@@ -236,43 +223,41 @@ restart)
 status)
     # -q is necessary on some versions of linux where nc returns too quickly, and no stat result is output
     isSSL=""false""
-    clientPortAddress=`$GREP ""^[[:space:]]*clientPortAddress[^[:alpha:]]"" ""$ZOOCFG"" | sed -e 's/.*=//'`
-    if ! [ $clientPortAddress ]
-    then
-	      clientPortAddress=""localhost""
+    clientPortAddress=$($GREP ""^[[:space:]]*clientPortAddress[^[:alpha:]]"" ""$ZOOCFG"" | sed -e 's/.*=//')
+    if ! [ ""$clientPortAddress"" ]; then","[{'comment': 'I think this is trying to do:\r\n\r\n```suggestion\r\n    if [ -z ""$clientPortAddress"" ]; then\r\n```\r\n\r\nI\'m not exactly, sure, though. This is used in a few places.', 'commenter': 'ctubbsii'}]"
1420,bin/zkServer.sh,"@@ -236,43 +223,41 @@ restart)
 status)
     # -q is necessary on some versions of linux where nc returns too quickly, and no stat result is output
     isSSL=""false""
-    clientPortAddress=`$GREP ""^[[:space:]]*clientPortAddress[^[:alpha:]]"" ""$ZOOCFG"" | sed -e 's/.*=//'`
-    if ! [ $clientPortAddress ]
-    then
-	      clientPortAddress=""localhost""
+    clientPortAddress=$($GREP ""^[[:space:]]*clientPortAddress[^[:alpha:]]"" ""$ZOOCFG"" | sed -e 's/.*=//')
+    if ! [ ""$clientPortAddress"" ]; then
+      clientPortAddress=""localhost""
     fi
-    clientPort=`$GREP ""^[[:space:]]*clientPort[^[:alpha:]]"" ""$ZOOCFG"" | sed -e 's/.*=//'`
-    if ! [[ ""$clientPort""  =~ ^[0-9]+$ ]]
-    then
-      dataDir=`$GREP ""^[[:space:]]*dataDir"" ""$ZOOCFG"" | sed -e 's/.*=//'`
-      myid=`cat ""$dataDir/myid"" 2> /dev/null`
+    clientPort=$($GREP ""^[[:space:]]*clientPort[^[:alpha:]]"" ""$ZOOCFG"" | sed -e 's/.*=//')
+    if ! [[ ""$clientPort""  =~ ^[0-9]+$ ]]; then","[{'comment': ""This is the first time I've seen the use of the double-square brackets in this code review for a test block. It probably doesn't matter, but FWIW, if you're writing bash, it's best to use the double-square everywhere rather than the single-square braces, because then there's no ambiguity between the bash language syntax and the literal command `/usr/bin/[`. Many people don't realize that `/usr/bin/[` is actually a separate process, although I believe bash just uses its own built-in anyway, so it doesn't have the loss of performance for executing a separate process, but I'm not sure about that. In general, I prefer double over single, if you are using bash. However, I'm not sure it's worth changing this throughout the script."", 'commenter': 'ctubbsii'}, {'comment': 'I prefer double square brackets vs single one, but here the only change is replacing the old `Command` by $(Command). The command itself has not been changed at all', 'commenter': 'tanisdlj'}, {'comment': ""Right. My comment was inspired by the change I noticed here, but does not pertain to this change. Rather, it pertains to all the other occurrences in the script where single square brackets are used. It's up to you whether you want to migrate everything to double-square brackets in this PR or a subsequent or not at all. :smiley_cat:"", 'commenter': 'ctubbsii'}]"
1420,bin/zkServer.sh,"@@ -282,12 +267,11 @@ status)
       fi
     fi
     echo ""Client port found: $clientPort. Client address: $clientPortAddress. Client SSL: $isSSL.""
-    STAT=`""$JAVA"" ""-Dzookeeper.log.dir=${ZOO_LOG_DIR}"" ""-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}"" ""-Dzookeeper.log.file=${ZOO_LOG_FILE}"" \
-          -cp ""$CLASSPATH"" $CLIENT_JVMFLAGS $JVMFLAGS org.apache.zookeeper.client.FourLetterWordMain \
-          $clientPortAddress $clientPort srvr $isSSL 2> /dev/null    \
-          | $GREP Mode`
-    if [ ""x$STAT"" = ""x"" ]
-    then
+    STAT=$(""$JAVA"" ""-Dzookeeper.log.dir=${ZOO_LOG_DIR}"" ""-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}"" ""-Dzookeeper.log.file=${ZOO_LOG_FILE}"" \
+          -cp ""$CLASSPATH"" ""$CLIENT_JVMFLAGS"" ""$JVMFLAGS"" org.apache.zookeeper.client.FourLetterWordMain \","[{'comment': 'Another case of intentionally unquoted flags:\r\n\r\n```suggestion\r\n          -cp ""$CLASSPATH"" $CLIENT_JVMFLAGS $JVMFLAGS org.apache.zookeeper.client.FourLetterWordMain \\\r\n```', 'commenter': 'ctubbsii'}]"
1422,zookeeper-server/src/main/java/org/apache/zookeeper/server/auth/ProviderRegistry.java,"@@ -29,8 +29,10 @@
 
     private static final Logger LOG = LoggerFactory.getLogger(ProviderRegistry.class);
 
+    public static final String AUTHPROVIDER_PROPERTY_PREFIX = ""zookeeper.authProvider."";","[{'comment': 'nit:\r\n\r\nI like that you created this public constant. I searched for this, and the same string is also used in `QuorumPeerConfig`:\r\n\r\nhttps://github.com/apache/zookeeper/blob/c42c8c94085ed1d94a22158fbdfe2945118a82bc/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java#L508\r\n\r\nCan you use `AUTHPROVIDER_PROPERTY_PREFIX` there too?', 'commenter': 'symat'}, {'comment': ""Sure, will do. Looks like there are a lot of unit tests where we use the same string, but I won't replace all of them in this PR."", 'commenter': 'anmolnar'}]"
1422,zookeeper-server/src/test/java/org/apache/zookeeper/test/ClientSSLTest.java,"@@ -156,4 +161,26 @@ public void testSecureStandaloneServer() throws Exception {
         mt.shutdown();
     }
 
+    @Test
+    public void testSecureStandaloneServerAuthFail() throws IOException {
+        try {
+            System.setProperty(ProviderRegistry.AUTHPROVIDER_PROPERTY_PREFIX + ""authfail"",
+                ""org.apache.zookeeper.test.AuthFailX509AuthenticationProvider"");","[{'comment': ""nit:\r\nyou can use `AuthFailX509AuthenticationProvider.class.getName()`\r\nthis way this code won't be subject to problems in case of refactor/move class/rename class"", 'commenter': 'eolivelli'}]"
1422,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -115,6 +115,9 @@ public void close() {
         // if this is not in cnxns then it's already closed
         if (!factory.cnxns.remove(this)) {
             LOG.debug(""cnxns size:{}"", factory.cnxns.size());
+            if (channel.isOpen()) {","[{'comment': 'Does `CertificateVerifier` take care of setting the `DisconnectReason`? Do we print them somewhere in server logs?', 'commenter': 'karanmehta93'}, {'comment': 'It prints ""authentication failed"" in the server logs.', 'commenter': 'anmolnar'}, {'comment': ""I'm not familiar with the concept of `DisconnectReason`, need to take a look first. There should be quite straightforward to add it to CertificateVerifier if it's any help to you."", 'commenter': 'anmolnar'}, {'comment': 'Oh, sorry, I\'m completely wrong. It\'s already done.\r\n```\r\nif (KeeperException.Code.OK != authProvider.handleAuthentication(cnxn, null)) {\r\n    LOG.error(""Authentication failed for session 0x{}"", Long.toHexString(cnxn.getSessionId()));\r\n    cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);\r\n    return;\r\n}\r\n```', 'commenter': 'anmolnar'}]"
1438,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -696,6 +696,18 @@ protected void startRequestThrottler() {
 
     }
 
+    /**
+     * This is working when in standalone mode.
+     * <p>
+     * The leader, follower, observer, readOnly have fished by themselves. You can see the Class below:","[{'comment': 'Fished?', 'commenter': 'eolivelli'}, {'comment': ""@eolivelli \r\nwhat's the matter with you? I don't understand, please give a detailed comment."", 'commenter': 'PatricYan'}, {'comment': '@eolivelli \r\nI have modified the spelling error.\r\nDone', 'commenter': 'PatricYan'}]"
1443,zookeeper-server/src/main/java/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -178,6 +178,14 @@ public void run() {
             try {
                 while (!stopped && !acceptSocket.socket().isClosed()) {
                     try {
+                        /** if zkServer is null, don't accept the connection, until not null.
+                         *  if accept the connection, when reading data from socket, it will be closed by null of zkServer
+                         *
+                         */
+                        if (zkServer == null) {","[{'comment': 'shall we sleep a little time ?\r\notherwise we are in a busy loop', 'commenter': 'eolivelli'}, {'comment': '@eolivelli \r\nNo need. The loop is ok.  If sleep a little time, maybe cause the clients waiting to connect to servers.\r\n\r\n', 'commenter': 'PatricYan'}]"
1443,zookeeper-server/src/main/java/org/apache/zookeeper/server/NIOServerCnxnFactory.java,"@@ -820,7 +828,12 @@ private void addCnxn(NIOServerCnxn cnxn) throws IOException {
     }
 
     protected NIOServerCnxn createConnection(SocketChannel sock, SelectionKey sk, SelectorThread selectorThread) throws IOException {
-        return new NIOServerCnxn(zkServer, sock, sk, this, selectorThread);
+        if (zkServer != null) {","[{'comment': 'given your fix above, is this check still useful ?', 'commenter': 'eolivelli'}, {'comment': '@eolivelli \r\n\r\nhere is not required, but can check again. So I think adding  it is well', 'commenter': 'PatricYan'}]"
1456,zookeeper-server/src/main/java/org/apache/zookeeper/version/util/VerGen.java,"@@ -119,7 +119,7 @@ public static void generateFile(File outputDir, Version version, String rev, Str
             w.write(""public class "" + VERSION_CLASS_NAME + "" implements "" + PACKAGE_NAME + "".Info {\n"");
             w.write(""    public static void main(String[] args) {\n"");
             w.write(""        final String VER_STRING = MAJOR + \"".\"" + MINOR + \"".\"" + MICRO +"");
-            w.write(""            (QUALIFIER == null ? \""\"" : \""-\"" + QUALIFIER)  + \"" \"" +"");
+            w.write(""            (QUALIFIER.isEmpty() ? \""\"" : \""-\"" + QUALIFIER)  + \"" \"" +"");","[{'comment': 'What happens if it is null?', 'commenter': 'eolivelli'}, {'comment': 'In line 83, it is set to empty string, if it is null - ` w.write(""    String QUALIFIER="" + (version.qualifier == null ? ""\\""\\"""" : ""\\"""" + version.qualifier + ""\\"""") + "";\\n"");` which the VersionInfoMain implements. I don\'t think it can be null in this context.', 'commenter': 'surnaik'}, {'comment': 'Could do:\r\n\r\n```suggestion\r\n            w.write(""            (QUALIFIER == null || QUALIFIER.isEmpty() ? \\""\\"" : \\""-\\"" + QUALIFIER)  + \\"" \\"" +"");\r\n```', 'commenter': 'ctubbsii'}, {'comment': ""Ya, that was the logic in the first commit, i updated it to QUALIFIER.isEmpty() in the second update. @ctubbsii  I'll update the PR, thank you for the review."", 'commenter': 'surnaik'}, {'comment': '@eolivelli and @ctubbsii I have made the change to include both the null check and the empty string check. Please let me know if this is alright. Thanks!', 'commenter': 'surnaik'}, {'comment': 'Thanks, will resolve the comments then.', 'commenter': 'surnaik'}]"
1478,zookeeper-server/src/main/java/org/apache/zookeeper/common/PathTrie.java,"@@ -344,4 +345,10 @@ public void clear() {
          }
      }
 
+     private String[] split(final String path){","[{'comment': 'Nit: static', 'commenter': 'eolivelli'}]"
1478,zookeeper-server/src/main/java/org/apache/zookeeper/common/PathTrie.java,"@@ -344,4 +345,10 @@ public void clear() {
          }
      }
 
+     private static String[] split(final String path){
+         return Stream.of(path.split(""/""))
+                 .filter(t -> (t != null && !t.trim().isEmpty()))","[{'comment': ""is this filter semantically different from commons-lang's `StringUtils.split`? IIRC validation has been done before passed into `PathTrie` or at least this method seems more than just split path but also validate and filter things."", 'commenter': 'tisonkun'}, {'comment': ""To get equivalent behavior, it looks like you could probably just do:\r\n```suggestion\r\n                 .filter(t -> !t.isEmpty())\r\n```\r\n\r\nThis is because `StringUtils.split` can't return a `null` element, and it removes truly empty elements (redundant delimiters). I don't think it normally does a trim on each element, though.\r\n\r\nTo me, it looks like the proposed changes include reasonable safeguards that are worth keeping. Do you really want elements that include only whitespace?"", 'commenter': 'ctubbsii'}, {'comment': '> is this filter semantically different from commons-lang\'s `StringUtils.split`? IIRC validation has been done before passed into `PathTrie` or at least this method seems more than just split path but also validate and filter things.\r\n\r\nIf we split a path like ""/node1/node2"" with StringUtils.split at ""/"" we get the following: [""node1"", ""node2""].\r\nIf we do the same with String.split we get ["""", ""node1"", ""node2""], because it recognizes an empty string before the first ""/"".\r\nThe filter provides a solution to not have the first empty string, only the rest of the elements.', 'commenter': 'tamaashu'}, {'comment': ""> To get equivalent behavior, it looks like you could probably just do:\r\n> \r\n> This is because `StringUtils.split` can't return a `null` element, and it removes truly empty elements (redundant delimiters). I don't think it normally does a trim on each element, though.\r\n> \r\n> To me, it looks like the proposed changes include reasonable safeguards that are worth keeping. Do you really want elements that include only whitespace?\r\n\r\nGood catch, thanks. Updated."", 'commenter': 'tamaashu'}, {'comment': 'Fine.', 'commenter': 'tisonkun'}]"
1498,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1670,7 +1673,8 @@ private void processSasl(ByteBuffer incomingBuffer, ServerCnxn cnxn, RequestHead
                 responseToken = saslServer.evaluateResponse(clientToken);
                 if (saslServer.isComplete()) {
                     String authorizationID = saslServer.getAuthorizationID();
-                    LOG.info(""adding SASL authorization for authorizationID: {}"", authorizationID);
+                    LOG.info(""Session 0x{}: adding SASL authorization for authorizationID: {}"",","[{'comment': '+1.\r\n\r\nI\'d like to have this in the tree, and was about to submit a patch with something like this.\r\n\r\n(Arguably, it\'d be sufficient to augment logging here and not on the other path of `ZooKeeperServer`, as the ""pluggable"" authentication providers can and should do their own, ""domain-specific,"" logging.)\r\n\r\n@Ghatage: are you planning to give this another go?\r\n', 'commenter': 'ztzg'}]"
1498,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1599,8 +1599,11 @@ public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOE
                 }
             }
             if (authReturn == KeeperException.Code.OK) {
+                ZooKeeperSaslServer saslServer = cnxn.zooKeeperSaslServer;
                 LOG.debug(""Authentication succeeded for scheme: {}"", scheme);
-                LOG.info(""auth success {}"", cnxn.getRemoteSocketAddress());
+                LOG.info(""Session 0x{}: auth success for authorizationID={}/{}"",
+                        Long.toHexString(cnxn.getSessionId()), saslServer.getAuthorizationID(),
+                        cnxn.getRemoteSocketAddress());","[{'comment': 'This is the ""traditional"" authentication path, used by providers others than SASL.  Unless I am missing something, `saslServer` is likely to be NULL here.\r\n\r\n(I suppose this is the reason for your ""Needs more work"" comment.)', 'commenter': 'ztzg'}, {'comment': ""That's right @ztzg.\r\nI was just helping clear out the backlog when I took this up but I think I'll need to add in more code so took a breather on this.\r\nI would still like to give it a shot till the weekend if you don't mind. Will tag you for updated codes' review :)"", 'commenter': 'Ghatage'}, {'comment': 'Sure; no hurry/pressure.  Was just checking as I was working in the same area…', 'commenter': 'ztzg'}, {'comment': '@ztzg I added some code to protect the use of sasl in the log statement only if its not null.\r\nNot sure if that is sufficient / appropriate.. please advise!', 'commenter': 'Ghatage'}, {'comment': 'Hi @Ghatage,\r\n\r\nNo, I don\'t think that\'s what we want—sorry for not being clearer in my previous comment.\r\n\r\nThis is the code path where ""traditional"" auth packets are being handled. While it is technically possible to send a `sasl` auth packet to a server, the [`handleAuthentication` method](https://github.com/apache/zookeeper/blob/fe940cdd8fb23ba09684cefb73233d570f4a20fa/zookeeper-server/src/main/java/org/apache/zookeeper/server/auth/SASLAuthenticationProvider.java#L34) of `SASLAuthenticationProvider` always returns `AUTHFAILED`.  So you\'ll *never* enter that block in response to SASL auth.\r\n\r\nNow, while I think it would be good to add at least the `sessionId` and `scheme` to that message, adding the ""user name"" corresponding to a traditional `AuthenticationProvider` is quite a bit more complicated—and doing it ""very cleanly"" would arguably require incompatible infrastructure changes.\r\n\r\n(For example, `DigestAuthenticationProvider` can add [up to two `Id`s](https://github.com/apache/zookeeper/blob/fe940cdd8fb23ba09684cefb73233d570f4a20fa/zookeeper-server/src/main/java/org/apache/zookeeper/server/auth/DigestAuthenticationProvider.java#L99-L102) to a connection, and the existing interface does not allow it to return them; you\'d have to ""diff"" the before and after `Id` sets to know what has changed.)\r\n\r\nSo I\'m not sure it\'s worth the effort, given that everybody is moving towards SASL and/or X509 anyway.  And even if one wants to keep using a traditional provider, it is usually more useful to let it do its own (domain-specific) logging.\r\n\r\nIn conclusion: I\'d just add the `sessionId` and `scheme` there, and ignore the actual `Id`(s).\r\n\r\nHope this helps, -D\r\n\r\nCc: @eolivelli & @symat.', 'commenter': 'ztzg'}, {'comment': ""> In conclusion: I'd just add the sessionId and scheme there, and ignore the actual Id(s).\r\n\r\nmake sense to me.\r\n(for SASL I think we already have log outputs about the authenticated principal names)"", 'commenter': 'symat'}]"
1498,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1599,8 +1599,10 @@ public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOE
                 }
             }
             if (authReturn == KeeperException.Code.OK) {
-                LOG.debug(""Authentication succeeded for scheme: {}"", scheme);
-                LOG.info(""auth success {}"", cnxn.getRemoteSocketAddress());
+                ZooKeeperSaslServer saslServer = cnxn.zooKeeperSaslServer;","[{'comment': ""Almost… but I'm afraid you still have a leftover `saslServer` variable here :)"", 'commenter': 'ztzg'}, {'comment': 'Sorry about that! Fixed it now.', 'commenter': 'Ghatage'}, {'comment': 'No problem!  LGTM.', 'commenter': 'ztzg'}]"
1503,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1627,6 +1628,22 @@ public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOE
         }
     }
 
+    private static boolean isSaslSuperUser(String id) {
+        String superUser = System.getProperty(SASL_SUPER_USER);
+
+        if (superUser == null || id == null || id.isEmpty()) {
+            return false;
+        }
+
+        for (String superId : superUser.split("","")) {","[{'comment': ""In order to be 100% compatible....what about using a list of properties \r\n- zookeeper.superUser=foo\r\n- zookeeper.superUser.1=foo2\r\n- zookeeper.superUser.2=foo3\r\n- zookeeper.superUser.3=foo4\r\n\r\nwe will also be supporting comma as we won't have any special character\r\n"", 'commenter': 'eolivelli'}, {'comment': 'I like this! (Particularly since there is a precedent.  Sorta.)', 'commenter': 'ztzg'}]"
1503,zookeeper-server/src/test/java/org/apache/zookeeper/test/SaslSuperUserTest.java,"@@ -56,42 +60,41 @@ public static void setupStatic() throws Exception {
         fwriter.write(""""
                               + ""Server {\n""
                               + ""          org.apache.zookeeper.server.auth.DigestLoginModule required\n""
-                              + ""          user_super_duper=\""test\"";\n""
+                              + ""          user_super_duper=\""test\""\n""
+                              + ""          user_other_super=\""test\"";\n""
                               + ""};\n""
                               + ""Client {\n""
                               + ""       org.apache.zookeeper.server.auth.DigestLoginModule required\n""
                               + ""       username=\""super_duper\""\n""
                               + ""       password=\""test\"";\n""
                               + ""};""
+                              + ""OtherClient {\n""
+                              + ""       org.apache.zookeeper.server.auth.DigestLoginModule required\n""
+                              + ""       username=\""other_super\""\n""
+                              + ""       password=\""test\"";\n""
+                              + ""};""
                               + ""\n"");
         fwriter.close();
         oldLoginConfig = System.setProperty(""java.security.auth.login.config"", saslConfFile.getAbsolutePath());
-        oldSuperUser = System.setProperty(""zookeeper.superUser"", ""super_duper"");
+        oldSuperUser = System.setProperty(ZooKeeperServer.SASL_SUPER_USER, ""super_duper"");
         otherDigestUser = new Id(""digest"", DigestAuthenticationProvider.generateDigest(""jack:jack""));
     }
 
     @AfterAll
     public static void cleanupStatic() {
-        if (oldAuthProvider != null) {
-            System.setProperty(""zookeeper.authProvider.1"", oldAuthProvider);
-        } else {
-            System.clearProperty(""zookeeper.authProvider.1"");
-        }
-        oldAuthProvider = null;
-
-        if (oldLoginConfig != null) {
-            System.setProperty(""java.security.auth.login.config"", oldLoginConfig);
-        } else {
-            System.clearProperty(""java.security.auth.login.config"");
-        }
-        oldLoginConfig = null;
+        oldAuthProvider = restoreProperty(""zookeeper.authProvider.1"", oldAuthProvider);
+        oldClientConfigSection = restoreProperty(ZKClientConfig.LOGIN_CONTEXT_NAME_KEY, oldClientConfigSection);
+        oldLoginConfig = restoreProperty(""java.security.auth.login.config"", oldLoginConfig);
+        oldSuperUser = restoreProperty(ZooKeeperServer.SASL_SUPER_USER, oldSuperUser);
+    }
 
-        if (oldSuperUser != null) {
-            System.setProperty(""zookeeper.superUser"", oldSuperUser);
+    private static String restoreProperty(String property, String oldValue) {
+        if (oldValue != null) {
+            System.setProperty(property, oldValue);
         } else {
-            System.clearProperty(""zookeeper.superUser"");
+            System.clearProperty(property);
         }
-        oldSuperUser = null;
+        return null;","[{'comment': ""nit: this function should be void. AFAICS you don't use the return value anywhere (only in the `@AfterAll` method, but I don't see why it is needed to set to all those static variables to null) Or maybe I'm missing something?"", 'commenter': 'symat'}, {'comment': ""No; you're right. I have cleaned that up."", 'commenter': 'ztzg'}]"
1503,zookeeper-server/src/test/java/org/apache/zookeeper/test/SaslSuperUserTest.java,"@@ -127,11 +128,35 @@ public void testSuperIsSuper() throws Exception {
             zk.delete(""/digest_read"", -1);
             zk.delete(""/sasl_read/sub"", -1);
             zk.delete(""/sasl_read"", -1);
-            //If the test failes it will most likely fail with a NoAuth exception before it ever gets to this assertion
-            assertEquals(authFailed.get(), 0);
         } finally {
             zk.close();
         }
     }
 
+    @Test
+    public void testSuperIsSuper() throws Exception {
+        connectAndPerformSuperOps();
+        //If the test fails it will most likely fail with a NoAuth exception before it ever gets to this assertion
+        assertEquals(authFailed.get(), 0);
+    }
+
+    @Test
+    public void testOtherSuperIsSuper() throws Exception {
+        String prevSection = System.setProperty(ZKClientConfig.LOGIN_CONTEXT_NAME_KEY, ""OtherClient"");
+
+        // KLUDGE: We do this quite late, as the server has been
+        // started at this point--but current the implementation looks","[{'comment': 'typo: ""but current the implementation looks""\r\n-> ""but the implementation currently looks""', 'commenter': 'eolivelli'}, {'comment': 'Fixed; thanks!', 'commenter': 'ztzg'}, {'comment': ""(I'll merge this if I get a green CI.)"", 'commenter': 'ztzg'}]"
1504,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -3070,4 +3071,19 @@ private void validateACL(List<ACL> acl) throws KeeperException.InvalidACLExcepti
         }
     }
 
+    /**
+     * Returns comma separated list of users authenticated in the current session
+     *
+     * @return users
+     * @throws InterruptedException when interrupted
+     */
+    public String whoAmI() throws InterruptedException {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.whoAmI);
+        WhoAmIResponse response = new WhoAmIResponse();
+        cnxn.submitRequest(h, null, response, null);","[{'comment': '*THREAD_SAFETY_VIOLATION:*  Unprotected write. Non-private method `ZooKeeper.whoAmI()` indirectly writes to field `this.cnxn.sendThread.clientCnxnSocket.lastHeard` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not.', 'commenter': 'sonatype-lift[bot]'}]"
1504,zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java,"@@ -565,6 +566,12 @@ public void processRequest(Request request) {
                 rsp = new GetEphemeralsResponse(ephemerals);
                 break;
             }
+            case OpCode.whoAmI: {
+                lastOp = ""HOMI"";
+                rsp = new WhoAmIResponse(request.getUsers(true));
+                break;
+            }
+","[{'comment': 'This is where the builds break; it wants a `default:` in this switch:\r\n\r\n> `[ERROR] Switch statement found in org.apache.zookeeper.server.FinalRequestProcessor.processRequest(Request) where default case is missing [org.apache.zookeeper.server.FinalRequestProcessor] At FinalRequestProcessor.java:[lines 212-571] SF_SWITCH_NO_DEFAULT`\r\n\r\n(Not something you introduced, AFAICT, but ""you touch it, you own it"" seems to be the policy :)\r\n\r\n', 'commenter': 'ztzg'}, {'comment': 'Handled', 'commenter': 'arshadmohammad'}]"
1504,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -3070,4 +3071,19 @@ private void validateACL(List<ACL> acl) throws KeeperException.InvalidACLExcepti
         }
     }
 
+    /**
+     * Returns comma separated list of users authenticated in the current session
+     *
+     * @return users
+     * @throws InterruptedException when interrupted
+     */
+    public String whoAmI() throws InterruptedException {","[{'comment': 'I note the absence of an asynchronous version of the operation, but I suppose we can live without it :)', 'commenter': 'ztzg'}, {'comment': 'What about returning a simple datastructure ?\r\nin the future we will be able to return more data probably.\r\n\r\nI would like to see something like:\r\nclass ClientInfo {\r\n    String[] users;\r\n    // auth scheme ?\r\n    // other relevant info ?\r\n}', 'commenter': 'eolivelli'}, {'comment': 'Good suggestion. \r\nAdded  below structure\r\n```\r\nclass ClientInfo {\r\n        ustring authScheme; // Authentication scheme\r\n        ustring user;       // user name or any other id(for example ip)\r\n    }\r\n```\r\nResponse changed to \r\n```\r\nclass WhoAmIResponse {\r\n        vector<org.apache.zookeeper.data.ClientInfo> clientInfo;\r\n    }\r\n```', 'commenter': 'arshadmohammad'}, {'comment': '> but I suppose we can live without it :)\r\nyes, not required as of now, Can be added whenever there is use case.', 'commenter': 'arshadmohammad'}]"
1504,zookeeper-server/src/main/java/org/apache/zookeeper/cli/WhoAmICommand.java,"@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.cli;
+
+import java.util.List;
+import org.apache.zookeeper.data.ClientInfo;
+
+/**
+ * WhoAmI command for cli
+ */
+public class WhoAmICommand extends CliCommand {
+
+    public WhoAmICommand() {
+        super(""whoami"", """");
+    }
+
+    @Override
+    public CliCommand parse(String[] cmdArgs) throws CliParseException {
+        return this;
+    }
+
+    @Override
+    public boolean exec() throws CliException {
+        try {
+            List<ClientInfo> clientInfos = zk.whoAmI();
+            out.println(""Auth scheme: User"");
+            clientInfos.forEach(clientInfo -> {","[{'comment': '*NULL_DEREFERENCE:*  object `clientInfos` last assigned on line 41 could be null and is dereferenced at line 43.', 'commenter': 'sonatype-lift[bot]'}, {'comment': 'Handled', 'commenter': 'arshadmohammad'}]"
1504,zookeeper-server/src/test/java/org/apache/zookeeper/ZooKeeperTest.java,"@@ -698,4 +700,55 @@ public void testInsufficientPermission() throws Exception {
         assertEquals(""Insufficient permission : "" + zNodeToBeCreated, errorMessage);
     }
 
+    @Test
+    public void testWhoAmIAPI() throws Exception {
+        final ZooKeeper zk = createClient();
+
+        // Check who ami without authentication/without any user into the session
+        List<ClientInfo> clientInfos = zk.whoAmI();
+        // By default server adds ip as the authentication info
+        assertEquals(1, clientInfos.size());
+        assertEquals(""ip"", clientInfos.get(0).getAuthScheme());
+
+        // Add one user into the session
+        zk.addAuthInfo(""digest"", ""user1:abcXYZ"".getBytes());
+        clientInfos = zk.whoAmI();
+        assertEquals(2, clientInfos.size());
+        ClientInfo user1 = getClientInfos(clientInfos, ""user1"");
+        assertEquals(""digest"", user1.getAuthScheme());
+
+        // Add one more user into the session
+        zk.addAuthInfo(""digest"", ""user2:xyzABC"".getBytes());
+        clientInfos = zk.whoAmI();
+        assertEquals(3, clientInfos.size());
+        user1 = getClientInfos(clientInfos, ""user1"");
+        assertEquals(""digest"", user1.getAuthScheme());
+        ClientInfo user2 = getClientInfos(clientInfos, ""user2"");
+        assertEquals(""digest"", user2.getAuthScheme());
+    }
+
+    private ClientInfo getClientInfos(List<ClientInfo> clientInfos, String user) {
+        for (ClientInfo clientInfo : clientInfos) {
+            if (clientInfo.getUser().equals(user)) {
+                return clientInfo;
+            }
+        }
+        throw new AssertionError(""User +"" + user + "" not found"");
+    }
+
+    @Test
+    public void testWhoAmICLICommand() throws Exception {
+        final ZooKeeper zk = createClient();
+        WhoAmICommand cmd = new WhoAmICommand();
+        cmd.setZk(zk);
+
+        // Check who ami without authentication/without any user into the session
+        cmd.parse(new String[] { ""whoami"" });
+        runCommandExpect(cmd, Arrays.asList(""Auth scheme: User"", ""ip: 127.0.0.1""));
+
+        // Add one user into the session
+        zk.addAuthInfo(""digest"", ""user1:abcXYZ"".getBytes());
+        runCommandExpect(cmd, Arrays.asList(""Auth scheme: User"", ""digest: user1"", ""ip: 127.0.0.1""));","[{'comment': ""I'm not sure one can expect this output to be stable across JVMs: the `List<Id>` used to build the response is [initialized from `ServerCnxn.authInfo`](https://github.com/apache/zookeeper/blob/c47ef905e077/zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerCnxn.java#L277), which is a `ConcurrentHashMap`-backed `Set`."", 'commenter': 'ztzg'}, {'comment': 'Very much valid point.\r\nCorrected it', 'commenter': 'arshadmohammad'}]"
1508,.github/workflows/ci.yaml,"@@ -0,0 +1,88 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+# This workflow will build a Java project with Maven
+# See also:
+#   https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven
+
+name: CI
+
+on:
+  push:
+    branches: [ '*' ]
+  pull_request:
+    branches: [ '*' ]
+
+jobs:
+  mvn:
+    strategy:
+      matrix:
+        profile:
+          - name: 'full-build-jdk8'
+            jdk: 8
+            args: '-Pfull-build apache-rat:check verify -DskipTests spotbugs:check checkstyle:check'
+          - name: 'full-build-jdk11'
+            jdk: 11
+            args: '-Pfull-build apache-rat:check verify -DskipTests spotbugs:check checkstyle:check'
+          - name: 'selected-tests'
+            jdk: 11
+            # these tests were somewhat arbitrarily selected to test basic
+            # functionality more tests should run, and possibly in parallel, as
+            # the testing situation improves in ZooKeeper
+            args: '-Pfull-build verify -Dsurefire-forkcount=1 -DskipCppUnit -DfailIfNoTests=false -Dtest=ClientCnxnSocketTest,ClientSSLTest,ClientTest,QuorumDigestAuthTest,QuorumKerberosAuthTest,QuorumPeerMainTest,QuorumPeerTest,QuorumServerTest,QuorumTest,QuorumZxidSyncTest,SaslAuthTest,SaslClientTest,StatCommandTest,StatTest,WatcherFuncTest,WatcherTest,ZKClientConfigTest,ZooKeeperServerMainTest,ZooKeeperServerTest,ZooKeeperTest'","[{'comment': 'can we run the whole suite ?\r\nWe must rely on PR validation in order to see that there is no regression, there is no ""minimum acceptance test""', 'commenter': 'eolivelli'}, {'comment': ""I was unable to get the full test suite to pass as it is today. This PR would lay the groundwork for getting all the tests to pass in GitHub Actions and eventually replace the Jenkins precommit job.\r\n\r\nHowever, today, it only replaces the `x86_64` architecture Linux builds in Travis CI (which didn't execute any tests).\r\n\r\nGetting all the tests to pass is too much for one PR, and will need to happen incrementally once this is in place and contributors can use it to watch for flaky or problematic tests."", 'commenter': 'ctubbsii'}, {'comment': ""Okay, it looks like we're closer to getting *all* tests to pass in GH Actions than I previously thought... I just tried to build all of them in a separate branch, and only had two test failures, and the entire build completed in 70 minutes (using `surefire-forkcount=1`), which is comparable to what I got on my laptop, where I got all tests to pass after 2 tries.\r\n\r\n* surefire Java test: `RequestThrottlerTest.testGlobalOutstandingRequestThrottlingWithRequestThrottlerDisabled:340 expected: <3> but was: <6>`\r\n* zktest-mt (C client): `TestReconfigServer::testNonIncrementalStarting zookeeper ... FAILED TO START`  \r\n  previous line was: ``zktest-mt: /home/runner/work/zookeeper/zookeeper/zookeeper-client/zookeeper-client-c/tests/ZooKeeperQuorumServer.cc:67: void ZooKeeperQuorumServer::start(): Assertion `system(command.c_str()) == 0' failed.``"", 'commenter': 'ctubbsii'}, {'comment': 'I will update this PR to run all the tests.', 'commenter': 'ctubbsii'}]"
1508,pom.xml,"@@ -780,15 +780,6 @@
             <includeTestResources>false</includeTestResources>
             <includeTestSourceDirectory>true</includeTestSourceDirectory>
           </configuration>
-          <executions>
-            <execution>
-              <id>checkstyle</id>
-              <phase>validate</phase>
-              <goals>
-                <goal>check</goal>
-              </goals>
-            </execution>
-          </executions>","[{'comment': 'I\'m trying to understand Maven a bit better, and am puzzled by this: could you explain how you came to the conclusion that it was not necessary?\r\n\r\nThe ""Checking for Violations as Part of the Build"" section of the [usage page](https://maven.apache.org/plugins/maven-checkstyle-plugin/usage.html) includes that stanza.  Did you have to dig into the plugin\'s source code?\r\n\r\n(I understand that the other dependency/configuration removals correspond to global defaults set in the `pluginManagement` section, but not this `executions` business.)\r\n\r\n(Oh, and the parts I understand LGTM :)', 'commenter': 'ztzg'}, {'comment': 'This was removed because it literally did nothing. It defined an execution inside the `build/pluginManagement/plugins` section, and was never activated in a `build/plugins` section. The `<pluginManagement />` element is a way of early binding configuration to a plugin that is specified later. But, since the only execution of this plugin is on the command-line and not in a `build/plugins` section elsewhere in the `pom.xml` file, this literally did nothing.\r\n\r\nThe reason I removed it as part of this PR, rather than as a separate issue, is because the execution of checkstyle is part of the CI workflow for ZooKeeper, which was the focus of this PR.\r\n\r\nNormally, you would specify it similarly to:\r\n\r\n```xml\r\n<build>\r\n  <pluginManagement>\r\n    <plugins>\r\n      <plugin>\r\n        <groupId>my.group</groupId>\r\n        <artifactId>my.plugin</artifactId>\r\n        <version />\r\n        <!-- configuration for all executions of this plugin -->\r\n        <configuration />\r\n      </plugin>\r\n    </plugins>\r\n  </pluginManagement>\r\n  <plugins>\r\n    <plugin>\r\n      <groupId>my.group</groupId>\r\n      <artifactId>my.plugin</artifactId>\r\n      <executions>\r\n        <execution>\r\n          <id />\r\n          <goals />\r\n          <!-- execution-specific configuration -->\r\n          <configuration />\r\n        </execution>\r\n      </executions>\r\n    </plugin>\r\n  </plugins>\r\n</build>\r\n```\r\n\r\nBut we had:\r\n\r\n```xml\r\n<build>\r\n  <pluginManagement>\r\n    <plugins>\r\n      <plugin>\r\n        <groupId>my.group</groupId>\r\n        <artifactId>my.plugin</artifactId>\r\n        <version />\r\n        <executions />\r\n      </plugin>\r\n    </plugins>\r\n  </pluginManagement>\r\n  <!-- this section was missing, so the execution in the above was never activated\r\n  <plugins>\r\n    <plugin>\r\n      <groupId>my.group</groupId>\r\n      <artifactId>my.plugin</artifactId>\r\n    </plugin>\r\n  </plugins>\r\n  -->\r\n</build>\r\n```\r\n\r\nI hope that helps explain it.', 'commenter': 'ctubbsii'}, {'comment': ""I'm happy to answer more Maven stuff... I've learned quite a bit about it and love sharing. Ask any time."", 'commenter': 'ctubbsii'}, {'comment': '@ctubbsii: Very clear explanation; thank you! And the zero remaining ""executions"" seem to be enough, indeed, if we continue triggering that plugin from the command-line.', 'commenter': 'ztzg'}, {'comment': 'If ZK ever decides to bake it in to the build lifecycle instead of executing it on the command-line, I can either help perform that work or review it. :smiley_cat: ', 'commenter': 'ctubbsii'}]"
1519,zookeeper-server/src/test/java/org/apache/zookeeper/test/DigestAuthDisabledTest.java,"@@ -0,0 +1,74 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import static org.junit.jupiter.api.Assertions.fail;
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.TestableZooKeeper;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.Watcher.Event.KeeperState;
+import org.apache.zookeeper.ZooKeeper;
+import org.junit.jupiter.api.Test;
+
+public class DigestAuthDisabledTest extends ClientBase {
+
+    static {","[{'comment': 'Currently this configuration escapes this test and can potentially cause intermittent failures in other test cases. Please set this system property in a `@BeforeAll` method and clean it `@AfterAll`.', 'commenter': 'symat'}, {'comment': 'Indeed!  Fixed.', 'commenter': 'ztzg'}]"
1519,zookeeper-server/src/main/java/org/apache/zookeeper/server/Request.java,"@@ -467,26 +467,7 @@ public void logLatency(SummarySet metric, String key) {
      * session
      */","[{'comment': 'also please extend the JavaDoc here, that not all users will be returned, only the users which are belonged to a scheme ""visible for auditing"". (as far as I can tell only audit logs used this method... maybe we could even rename it to `getUsersForAudit`)', 'commenter': 'symat'}, {'comment': 'I have extended the JavaDoc, but not mentioning any filtering as I have now removed it :)  ([Rationale](https://github.com/apache/zookeeper/pull/1519#issuecomment-725535273))', 'commenter': 'ztzg'}]"
1519,zookeeper-server/src/main/java/org/apache/zookeeper/server/auth/DigestAuthenticationProvider.java,"@@ -31,13 +31,26 @@
 
     private static final Logger LOG = LoggerFactory.getLogger(DigestAuthenticationProvider.class);
 
+    private static final String DIGEST_AUTH_ENABLED = ""zookeeper.DigestAuthenticationProvider.enabled"";
+
     /** specify a command line property with key of
      * ""zookeeper.DigestAuthenticationProvider.superDigest""
      * and value of ""super:&lt;base64encoded(SHA1(password))&gt;"" to enable
      * super user access (i.e. acls disabled)
      */
     private static final String superDigest = System.getProperty(""zookeeper.DigestAuthenticationProvider.superDigest"");
 
+    private static final boolean enabled;","[{'comment': ""there won't be an easy way to turn in off/on during tests.\r\ndo we need a static variable ?"", 'commenter': 'eolivelli'}, {'comment': 'Fixed.\r\n\r\n(I had cargo-culted that fragment from `ZooKeeperServer.java`, and wanted to keep the `{} = {}` log statement.  It\'s a bit bizarre to now have a log statement in an `isEnabled` method, but I suppose we can live with it as it\'s only called once at startup.  Other suggestions/pointers to ""best practices"" welcome!)', 'commenter': 'ztzg'}]"
1523,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServerMXBean.java,"@@ -167,6 +179,14 @@
      * Reset Fsync Threshold Exceed Count statistics only.
      */
     void resetFsyncThresholdExceedCount();
+    /**
+     * Reset NonMTLSRemoteConnCount statistics only.
+     */
+    void resetNonMTLSConnCount();","[{'comment': ""This method actually resets local + remote counts, doesn't it?"", 'commenter': 'ztzg'}]"
1523,zookeeper-server/src/test/java/org/apache/zookeeper/server/X509AuthFailureTest.java,"@@ -0,0 +1,95 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server;
+
+import static org.junit.Assert.assertTrue;","[{'comment': ""Shouldn't this be `import static org.junit.jupiter.api.Assertions.assertTrue`?"", 'commenter': 'ztzg'}]"
1523,zookeeper-server/src/test/java/org/apache/zookeeper/server/X509AuthFailureTest.java,"@@ -0,0 +1,95 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server;
+
+import static org.junit.Assert.assertTrue;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.client.ZKClientConfig;
+import org.apache.zookeeper.common.ClientX509Util;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class X509AuthFailureTest {
+    protected static final Logger LOG = LoggerFactory.getLogger(X509AuthFailureTest.class);
+
+    private static ClientX509Util clientX509Util;
+    public static final int TIMEOUT = 5000;
+    public static int CONNECTION_TIMEOUT = 30000;
+
+    @BeforeEach
+    public void setup() throws Exception{
+        clientX509Util = new ClientX509Util();
+        String testDataPath = System.getProperty(""test.data.dir"", ""src/test/resources/data"");
+        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, ""org.apache.zookeeper.server.NettyServerCnxnFactory"");
+        System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, ""org.apache.zookeeper.ClientCnxnSocketNetty"");
+        System.setProperty(ZKClientConfig.SECURE_CLIENT, ""true"");
+        System.setProperty(clientX509Util.getSslKeystoreLocationProperty(), testDataPath + ""/ssl/testKeyStore.jks"");
+        System.setProperty(clientX509Util.getSslKeystorePasswdProperty(), ""testpass"");
+        System.setProperty(clientX509Util.getSslTruststoreLocationProperty(), testDataPath + ""/ssl/testTrustStore.jks"");
+        System.setProperty(clientX509Util.getSslTruststorePasswdProperty(), ""testpass"");
+    }
+
+    @AfterEach
+    public void teardown() throws Exception {
+        System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);
+        System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);
+        System.clearProperty(ZKClientConfig.SECURE_CLIENT);
+        System.clearProperty(clientX509Util.getSslKeystoreLocationProperty());
+        System.clearProperty(clientX509Util.getSslKeystorePasswdProperty());
+        System.clearProperty(clientX509Util.getSslTruststoreLocationProperty());
+        System.clearProperty(clientX509Util.getSslTruststorePasswdProperty());
+        clientX509Util.close();
+    }
+
+    /**
+     * Developers might use standalone mode (which is the default for one server).
+     * This test checks metrics for authz failure in standalone server
+     */
+    @Test
+    public void testSecureStandaloneServerAuthZFailure() throws Exception {
+
+        final Integer CLIENT_PORT = PortAssignment.unique();
+        final Integer SECURE_CLIENT_PORT = PortAssignment.unique();
+        System.setProperty(""zookeeper.ssl.allowedRoles"", ""testauthz"");","[{'comment': 'This doesn\'t have a corresponding `System.clearProperty(""zookeeper.ssl.allowedRoles"")`; I suspect it should.', 'commenter': 'ztzg'}, {'comment': ""I'm going to modify this test as I didn't realize authz is not yet merged to the opensource code from sfdc. I'll modify this to replicate an authn failure instead. "", 'commenter': 'p-malik'}]"
1523,zookeeper-server/src/test/java/org/apache/zookeeper/server/X509AuthFailureTest.java,"@@ -0,0 +1,95 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server;
+
+import static org.junit.Assert.assertTrue;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.client.ZKClientConfig;
+import org.apache.zookeeper.common.ClientX509Util;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class X509AuthFailureTest {
+    protected static final Logger LOG = LoggerFactory.getLogger(X509AuthFailureTest.class);
+
+    private static ClientX509Util clientX509Util;
+    public static final int TIMEOUT = 5000;
+    public static int CONNECTION_TIMEOUT = 30000;
+
+    @BeforeEach
+    public void setup() throws Exception{
+        clientX509Util = new ClientX509Util();
+        String testDataPath = System.getProperty(""test.data.dir"", ""src/test/resources/data"");
+        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, ""org.apache.zookeeper.server.NettyServerCnxnFactory"");
+        System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, ""org.apache.zookeeper.ClientCnxnSocketNetty"");
+        System.setProperty(ZKClientConfig.SECURE_CLIENT, ""true"");
+        System.setProperty(clientX509Util.getSslKeystoreLocationProperty(), testDataPath + ""/ssl/testKeyStore.jks"");
+        System.setProperty(clientX509Util.getSslKeystorePasswdProperty(), ""testpass"");
+        System.setProperty(clientX509Util.getSslTruststoreLocationProperty(), testDataPath + ""/ssl/testTrustStore.jks"");
+        System.setProperty(clientX509Util.getSslTruststorePasswdProperty(), ""testpass"");
+    }
+
+    @AfterEach
+    public void teardown() throws Exception {
+        System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);
+        System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);
+        System.clearProperty(ZKClientConfig.SECURE_CLIENT);
+        System.clearProperty(clientX509Util.getSslKeystoreLocationProperty());
+        System.clearProperty(clientX509Util.getSslKeystorePasswdProperty());
+        System.clearProperty(clientX509Util.getSslTruststoreLocationProperty());
+        System.clearProperty(clientX509Util.getSslTruststorePasswdProperty());
+        clientX509Util.close();
+    }
+
+    /**
+     * Developers might use standalone mode (which is the default for one server).
+     * This test checks metrics for authz failure in standalone server
+     */
+    @Test
+    public void testSecureStandaloneServerAuthZFailure() throws Exception {
+
+        final Integer CLIENT_PORT = PortAssignment.unique();
+        final Integer SECURE_CLIENT_PORT = PortAssignment.unique();
+        System.setProperty(""zookeeper.ssl.allowedRoles"", ""testauthz"");
+
+        ZooKeeperServerMainTest.MainThread mt = new ZooKeeperServerMainTest.MainThread(CLIENT_PORT, SECURE_CLIENT_PORT, true, null);
+        mt.start();
+
+        try {
+            ZooKeeper zk = createZKClnt(""127.0.0.1:"" + SECURE_CLIENT_PORT);
+        } catch (Exception e){
+            ServerStats serverStats = mt.getSecureCnxnFactory().getZooKeeperServer().serverStats();
+            assertTrue(serverStats.getAuthFailedCount() >= 1);
+        }","[{'comment': 'I would suggest adding a `fail(""should not be reached"")` in the try block.  When I do, I observe that no exception is thrown, and the `catch` block is actually skipped.  How about something akin to:\r\n\r\n```java\r\ntry {\r\n    ZooKeeper zk = createZKClnt(""127.0.0.1:"" + SECURE_CLIENT_PORT);\r\n    fail(""should not be reached"");\r\n} catch (Exception e){\r\n    // Expected\r\n}\r\n\r\nServerStats serverStats = mt.getSecureCnxnFactory().getZooKeeperServer().serverStats();\r\nassertTrue(serverStats.getAuthFailedCount() >= 1);\r\n```\r\n', 'commenter': 'ztzg'}, {'comment': ""Good suggestion, i'll change this code. "", 'commenter': 'p-malik'}]"
1525,zookeeper-server/src/test/java/org/apache/zookeeper/server/ZooKeeperServerTest.java,"@@ -135,4 +138,32 @@ public void testInvalidSnapshot() {
         }
     }
 
+    @Test
+    public void testClientZxidAhead() {
+        ZooKeeperServer zooKeeperServer = new ZooKeeperServer();
+        final ZKDatabase zkDatabase = new ZKDatabase(mock(FileTxnSnapLog.class));
+        zooKeeperServer.setZKDatabase(zkDatabase);
+
+        final ByteBuffer output = ByteBuffer.allocate(30);
+        // serialize a connReq
+        output.putInt(1);
+        // lastZxid
+        output.putLong(99L);
+        output.putInt(500);
+        output.putLong(123L);
+        output.putInt(1);
+        output.put((byte) 1);
+        output.put((byte) 1);
+        output.flip();
+
+        try {
+            final NIOServerCnxn nioServerCnxn = mock(NIOServerCnxn.class);
+            zooKeeperServer.processConnectRequest(nioServerCnxn, output);
+        } catch (Exception e) {
+            // expect
+            assertTrue(TestServerCnxn.instanceofCloseRequestException(e));","[{'comment': 'Why do you need a subclass to access these methods?', 'commenter': 'anmolnar'}, {'comment': ""https://github.com/apache/zookeeper/pull/1518#issuecomment-722369988\r\n\r\nIt’s necessary to do that. \r\n'org.apache.zookeeper.server.ServerCnxn.CloseRequestException' has protected access in 'org.apache.zookeeper.server.ServerCnxn', so I can't use it in ReadOnlyZooKeeperServerTest.java.\r\nDo you have a better way to sovle this?"", 'commenter': 'nsnhuang'}, {'comment': ""If it's necessary for testing, feel free to make it public and annotate with `VisibleForTesting`. We do this every so often, it's neater than adding testing classes all over the place. Thoughts?"", 'commenter': 'anmolnar'}, {'comment': ""You could also extract the `CloseRequestException` class in a separate file. It doesn't have to be a nested class."", 'commenter': 'anmolnar'}, {'comment': '> If it\'s necessary for testing, feel free to make it public and annotate with `VisibleForTesting`. We do this every so often, it\'s neater than adding testing classes all over the place. Thoughts?\r\n\r\n@anmolnar Subclassing for testing is a valid strategy for testing that requires access to protected methods. The `VisibleForTesting` annotation isn\'t a great mitigation for unintentional API leakage and misuse, since the compiler won\'t catch improper uses of it, and neither will most IDEs. Also, it adds an additional dependency on wherever you\'re getting that annotation imported from (presumably Guava), when you might otherwise not need that dependency. I would encourage the use of subclassing to test protected methods, if it\'s simple enough to do so (as long as it\'s reasonable to put the subclass as an inner class inside the test itself). I would resort to increasing the visibility to public, only as a last resort. It is particularly important in ZooKeeper, to limit the public visibility on APIs, because of the fact that ZooKeeper doesn\'t declare specific packages or classes as ""public API"", so users of ZooKeeper must rely on the visibility and other factors to infer stability, and they may not notice an annotation that does not trigger any compiler or IDE warning, and incorrectly infer that it is stable when it isn\'t.', 'commenter': 'ctubbsii'}, {'comment': ""I don't agree with subclassing for testing is a good strategy. I saw people hundreds of times reusing each other's subclasses with some modification just because it's already present and convenient to add some things. The result is a complete mess in the testing code, so I highly discourage people using it. Especially introducing it in ZooKeeper at this point in time.\r\n\r\nA more preferred way is mocking: that's essentially subclassing and produces much neater code for testing. Maybe not as convenient as adding a new subclass, but it's all about getting the habit of using mocking libraries.\r\n\r\n`VisibleForTesting` annotation: I don't have much experience with that, but that must be a reason why projects of Hadoop are using it all over the place. There should be some mechanism on the client side to trigger a warning when somebody is trying to access such member. Either way, ZooKeeper code is heavily using it already, so there's not much harm using is here as well.\r\n\r\nIn this particular case I think the best would be to extract the exception in a separate file under the same package. I don't see value in nested exception classes anyway."", 'commenter': 'anmolnar'}, {'comment': ""As a tradeoff we can use e.getClass().getName() and make the assertion against the string\r\nthis why we don't have to add that trick and also we do not have to add a new public class\r\n\r\n@anmolnar  would it work for you ?"", 'commenter': 'eolivelli'}, {'comment': '@eolivelli Yep, sounds like a good compromise.', 'commenter': 'anmolnar'}, {'comment': ""> I don't agree with subclassing for testing is a good strategy.\r\n> A more preferred way is mocking\r\n\r\nTo be clear, I don't think it's necessarily a *good* strategy, just that in *some* circumstances it might be an appropriate way to test something that you don't otherwise want accessible with higher visibility. I agree mocking is better, whenever possible.\r\n\r\n> `VisibleForTesting` annotation: I don't have much experience with that, but that must be a reason why projects of Hadoop are using it all over the place.\r\n\r\nI would caution against the idea that popularity is a good measure of reason. :wink:\r\n\r\nMy 2 cents already having been provided, I don't see any serious problems with any of the discussed strategies. They all seem to have some pros and cons. :smiley_cat: "", 'commenter': 'ctubbsii'}, {'comment': '> As a tradeoff we can use e.getClass().getName() and make the assertion against the string\r\n> this why we don\'t have to add that trick and also we do not have to add a new public class\r\n> \r\n> @eolivelli It works for ""e instanceof NIOServerCnxn.CloseRequestException"", but can\'t know which disconnect reason is.\r\n\r\n', 'commenter': 'nsnhuang'}, {'comment': ""> If it's necessary for testing, feel free to make it public and annotate with `VisibleForTesting`. We do this every so often, it's neater than adding testing classes all over the place. Thoughts?\r\n\r\n@anmolnar I have a question, Which package is' VisibleForTesting '?\r\n"", 'commenter': 'nsnhuang'}]"
1525,zookeeper-server/src/test/java/org/apache/zookeeper/server/ZooKeeperServerTest.java,"@@ -135,4 +138,32 @@ public void testInvalidSnapshot() {
         }
     }
 
+    @Test
+    public void testClientZxidAhead() {
+        ZooKeeperServer zooKeeperServer = new ZooKeeperServer();
+        final ZKDatabase zkDatabase = new ZKDatabase(mock(FileTxnSnapLog.class));
+        zooKeeperServer.setZKDatabase(zkDatabase);
+
+        final ByteBuffer output = ByteBuffer.allocate(30);
+        // serialize a connReq
+        output.putInt(1);
+        // lastZxid
+        output.putLong(99L);
+        output.putInt(500);
+        output.putLong(123L);
+        output.putInt(1);
+        output.put((byte) 1);
+        output.put((byte) 1);
+        output.flip();
+
+        try {
+            final NIOServerCnxn nioServerCnxn = mock(NIOServerCnxn.class);
+            zooKeeperServer.processConnectRequest(nioServerCnxn, output);
+        } catch (Exception e) {
+            // expect
+            assertTrue(e instanceof NIOServerCnxn.CloseRequestException);
+            assertEquals(((NIOServerCnxn.CloseRequestException) e).getReason(), ServerCnxn.DisconnectReason.CLIENT_ZXID_AHEAD);
+        }","[{'comment': ""I believe there's an `assertThrows()` method that might be cleaner than try-catch, and which returns the exception thrown, so you can check additional state, like the `getReason()`. The try-catch syntax is fine, though."", 'commenter': 'ctubbsii'}, {'comment': 'Btw is look good to me even in this form :)', 'commenter': 'eolivelli'}, {'comment': ""> I believe there's an `assertThrows()` method that might be cleaner than try-catch, and which returns the exception thrown, so you can check additional state, like the `getReason()`. The try-catch syntax is fine, though.\r\n\r\nThank you for your advice. \r\nI have done as you suggested."", 'commenter': 'nsnhuang'}]"
1526,pom.xml,"@@ -425,6 +425,7 @@
     <surefire.version>2.22.1</surefire.version>
 
     <surefire-forkcount>8</surefire-forkcount>
+    <redirectTestOutputToFile>true</redirectTestOutputToFile>","[{'comment': 'this part of the change is not strictly needed, I will revert once I fixed test flakyness', 'commenter': 'eolivelli'}]"
1526,zookeeper-server/src/test/java/org/apache/zookeeper/server/embedded/ZookeeperServeInfo.java,"@@ -0,0 +1,297 @@
+package org.apache.zookeeper.server.embedded;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.management.ManagementFactory;
+import java.lang.reflect.UndeclaredThrowableException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.management.InstanceNotFoundException;
+import javax.management.MBeanServer;
+import javax.management.MBeanServerInvocationHandler;
+import javax.management.ObjectInstance;
+import javax.management.ObjectName;
+import org.apache.zookeeper.common.StringUtils;
+import org.apache.zookeeper.server.ConnectionMXBean;
+import org.apache.zookeeper.server.ZooKeeperServerBean;
+import org.apache.zookeeper.server.quorum.LocalPeerMXBean;
+import org.apache.zookeeper.server.quorum.QuorumBean;
+import org.apache.zookeeper.server.quorum.QuorumMXBean;
+import org.apache.zookeeper.server.quorum.RemotePeerMXBean;
+
+public class ZookeeperServeInfo {","[{'comment': 'this class is in test packages.\r\nWe are using it in production, it is quite convenient, I am not sure if it is worth to be moved to ""main"" packages', 'commenter': 'eolivelli'}]"
1526,zookeeper-server/src/main/java/org/apache/zookeeper/server/embedded/ZooKeeperServerEmbeddedImpl.java,"@@ -0,0 +1,164 @@
+package org.apache.zookeeper.server.embedded;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import java.io.OutputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Map;
+import java.util.Properties;
+import org.apache.zookeeper.server.DatadirCleanupManager;
+import org.apache.zookeeper.server.ExitCode;
+import org.apache.zookeeper.server.ServerConfig;
+import org.apache.zookeeper.server.ZooKeeperServerMain;
+import org.apache.zookeeper.server.quorum.QuorumPeer;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
+import org.apache.zookeeper.server.quorum.QuorumPeerMain;
+import org.apache.zookeeper.util.ServiceUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright
+ * ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the
+ * License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+ * implied. See the License for the specific language governing permissions and limitations under the License.
+ */
+/**
+ * Implementation
+ */
+@SuppressFBWarnings(""DM_EXIT"")
+class ZooKeeperServerEmbeddedImpl implements ZooKeeperServerEmbedded {
+
+    private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperServerEmbeddedImpl.class);
+
+    private final QuorumPeerConfig config;
+    private QuorumPeerMain maincluster;
+    private ZooKeeperServerMain mainsingle;
+    private Thread thread;
+    private DatadirCleanupManager purgeMgr;
+    private final ExitHandler exitHandler;
+    private volatile boolean stopping;
+
+    ZooKeeperServerEmbeddedImpl(Properties p, Path baseDir, ExitHandler exitHandler) throws Exception {
+        if (!p.containsKey(""dataDir"")) {
+            p.put(""dataDir"", baseDir.resolve(""data"").toAbsolutePath().toString());
+        }
+        Path configFile = Files.createTempFile(baseDir, ""zookeeper.configuration"", "".properties"");
+        try (OutputStream oo = Files.newOutputStream(configFile)) {
+            p.store(oo, ""Automatically generated at every-boot"");
+        }
+        this.exitHandler = exitHandler;
+        LOG.info(""Current configuration is at {}"", configFile.toAbsolutePath());
+        config = new QuorumPeerConfig();
+        config.parse(configFile.toAbsolutePath().toString());
+        LOG.info(""ServerID:"" + config.getServerId());
+        LOG.info(""DataDir:"" + config.getDataDir());
+        LOG.info(""Servers:"" + config.getServers());","[{'comment': '*NULL_DEREFERENCE:*  object `ZooKeeperServerEmbeddedImpl.config.quorumVerifier` last assigned on line 56 could be null and is dereferenced by call to `getServers()` at line 60.', 'commenter': 'sonatype-lift[bot]'}]"
1526,zookeeper-server/src/main/java/org/apache/zookeeper/server/embedded/ZooKeeperServerEmbeddedImpl.java,"@@ -0,0 +1,164 @@
+package org.apache.zookeeper.server.embedded;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import java.io.OutputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Map;
+import java.util.Properties;
+import org.apache.zookeeper.server.DatadirCleanupManager;
+import org.apache.zookeeper.server.ExitCode;
+import org.apache.zookeeper.server.ServerConfig;
+import org.apache.zookeeper.server.ZooKeeperServerMain;
+import org.apache.zookeeper.server.quorum.QuorumPeer;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
+import org.apache.zookeeper.server.quorum.QuorumPeerMain;
+import org.apache.zookeeper.util.ServiceUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright
+ * ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the
+ * License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+ * implied. See the License for the specific language governing permissions and limitations under the License.
+ */
+/**
+ * Implementation
+ */
+@SuppressFBWarnings(""DM_EXIT"")
+class ZooKeeperServerEmbeddedImpl implements ZooKeeperServerEmbedded {
+
+    private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperServerEmbeddedImpl.class);
+
+    private final QuorumPeerConfig config;
+    private QuorumPeerMain maincluster;
+    private ZooKeeperServerMain mainsingle;
+    private Thread thread;
+    private DatadirCleanupManager purgeMgr;
+    private final ExitHandler exitHandler;
+    private volatile boolean stopping;
+
+    ZooKeeperServerEmbeddedImpl(Properties p, Path baseDir, ExitHandler exitHandler) throws Exception {
+        if (!p.containsKey(""dataDir"")) {
+            p.put(""dataDir"", baseDir.resolve(""data"").toAbsolutePath().toString());
+        }
+        Path configFile = Files.createTempFile(baseDir, ""zookeeper.configuration"", "".properties"");
+        try (OutputStream oo = Files.newOutputStream(configFile)) {
+            p.store(oo, ""Automatically generated at every-boot"");
+        }
+        this.exitHandler = exitHandler;
+        LOG.info(""Current configuration is at {}"", configFile.toAbsolutePath());
+        config = new QuorumPeerConfig();
+        config.parse(configFile.toAbsolutePath().toString());","[{'comment': '*CRLF_INJECTION_LOGS:*  This use of org/slf4j/Logger.info(Ljava/lang/String;)V might be used to include CRLF characters into log messages [(details)](https://find-sec-bugs.github.io/bugs.htm#CRLF_INJECTION_LOGS)', 'commenter': 'sonatype-lift[bot]'}, {'comment': '*PATH_TRAVERSAL_IN:*  This API (java/io/File.<init>(Ljava/lang/String;)V) reads a file whose location might be specified by user input [(details)](https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN)', 'commenter': 'sonatype-lift[bot]'}]"
1526,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServerMain.java,"@@ -237,4 +237,26 @@ ServerCnxnFactory getCnxnFactory() {
         return cnxnFactory;
     }
 
+    /**
+     * Shutdowns properly the service, this method is not a public API.
+     */
+    public void close() {
+        ServerCnxnFactory primaryCnxnFactory = this.cnxnFactory;
+        if (primaryCnxnFactory == null) {
+            // in case of pure TLS we can hook into secureCnxnFactory
+            primaryCnxnFactory = secureCnxnFactory;
+        }
+        if (primaryCnxnFactory == null || primaryCnxnFactory.getZooKeeperServer() == null) {
+            return;
+        }
+        ZooKeeperServerShutdownHandler zkShutdownHandler = primaryCnxnFactory.getZooKeeperServer().getZkShutdownHandler();
+        zkShutdownHandler.handle(ZooKeeperServer.State.SHUTDOWN);","[{'comment': 'Just curious, and showing my ignorance here: why not:\r\n\r\n```java\r\nprimaryCnxnFactory.getZooKeeperServer().setState(ZooKeeperServer.State.SHUTDOWN);\r\n```\r\n\r\n?', 'commenter': 'ztzg'}, {'comment': 'ZooKeeperServerShutdownHandler contains a CountDownLatch, that is keeping alive the server itself.\r\nWe have to trigger that latch', 'commenter': 'eolivelli'}, {'comment': ""Interesting.  My initial point was that `ZooKeeperServer.setState` invokes `zkShutdownHandler`'s `handle` method—which itself decrements the latch—but I now see that `QuorumZooKeeperServer` and `ReadOnlyZooKeeperServer` override that method, and do not delegate to the superclass.  (Part of the backstory is at [ZOOKEEPER-2247](https://issues.apache.org/jira/browse/ZOOKEEPER-2247), but that's quite a long thread and I haven't deciphered it fully.)"", 'commenter': 'ztzg'}]"
1526,zookeeper-server/src/main/java/org/apache/zookeeper/server/embedded/ZooKeeperServerEmbedded.java,"@@ -0,0 +1,120 @@
+package org.apache.zookeeper.server.embedded;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.nio.file.Path;
+import java.util.Properties;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.yetus.audience.InterfaceStability;
+
+/**
+ * This API allows you to start a ZooKeeper server node from Java code <p>
+ * The server will run inside the same process.<p>
+ * Tipical usecases are:","[{'comment': 'Nit: ""Typical.""', 'commenter': 'ztzg'}, {'comment': 'done, thanks', 'commenter': 'eolivelli'}]"
1526,zookeeper-server/src/main/java/org/apache/zookeeper/server/embedded/ZooKeeperServerEmbedded.java,"@@ -0,0 +1,120 @@
+package org.apache.zookeeper.server.embedded;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.nio.file.Path;
+import java.util.Properties;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.yetus.audience.InterfaceStability;
+
+/**
+ * This API allows you to start a ZooKeeper server node from Java code <p>
+ * The server will run inside the same process.<p>
+ * Tipical usecases are:
+ * <ul>
+ * <li>Running automated tests</li>
+ * <li>Launch ZooKeeper server with a Java based service management system</li>
+ * </ul>
+ * <p>
+ * Please take into consideration that in production usually it is better to not run the client
+ * together with the server in order to avoid race conditions, especially around how ephemeral nodes work.
+ */
+@InterfaceAudience.Public
+@InterfaceStability.Evolving
+public interface ZooKeeperServerEmbedded extends AutoCloseable {
+    /**
+     * Builder for ZooKeeperServerEmbedded.
+     */
+    class ZookKeeperServerEmbeddedBuilder {
+
+        private Path baseDir;
+        private Properties configuration;
+        private ExitHandler exitHandler = ExitHandler.EXIT;
+
+        /**
+         * Base directory of the server.
+         * The system will create a temporary configuration file inside this directory.
+         * Please remember that dynamic configuration files wil be saved into this directory by default.
+         * <p>
+         * If you do not set a 'dataDir' configuration entry the system will use a subdirectory if baseDir.","[{'comment': 'Nit: ""of baseDir.""', 'commenter': 'ztzg'}, {'comment': 'done, thanks', 'commenter': 'eolivelli'}]"
1526,zookeeper-server/src/main/java/org/apache/zookeeper/server/embedded/ZooKeeperServerEmbedded.java,"@@ -0,0 +1,120 @@
+package org.apache.zookeeper.server.embedded;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.nio.file.Path;
+import java.util.Properties;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.yetus.audience.InterfaceStability;
+
+/**
+ * This API allows you to start a ZooKeeper server node from Java code <p>
+ * The server will run inside the same process.<p>
+ * Tipical usecases are:
+ * <ul>
+ * <li>Running automated tests</li>
+ * <li>Launch ZooKeeper server with a Java based service management system</li>
+ * </ul>
+ * <p>
+ * Please take into consideration that in production usually it is better to not run the client
+ * together with the server in order to avoid race conditions, especially around how ephemeral nodes work.
+ */
+@InterfaceAudience.Public
+@InterfaceStability.Evolving
+public interface ZooKeeperServerEmbedded extends AutoCloseable {
+    /**
+     * Builder for ZooKeeperServerEmbedded.
+     */
+    class ZookKeeperServerEmbeddedBuilder {
+
+        private Path baseDir;
+        private Properties configuration;
+        private ExitHandler exitHandler = ExitHandler.EXIT;
+
+        /**
+         * Base directory of the server.
+         * The system will create a temporary configuration file inside this directory.
+         * Please remember that dynamic configuration files wil be saved into this directory by default.
+         * <p>
+         * If you do not set a 'dataDir' configuration entry the system will use a subdirectory if baseDir.
+         * @param baseDir
+         * @return the builder
+         */
+        public ZookKeeperServerEmbeddedBuilder baseDir(Path baseDir) {
+            this.baseDir = baseDir;
+            return this;
+        }
+
+        /**
+         * Set the contents of the main configuration as it would be in zk_server.conf file.
+         * @param configuration the configuration
+         * @return the builder
+         */
+        public ZookKeeperServerEmbeddedBuilder configuration(Properties configuration) {
+            this.configuration = configuration;
+            return this;
+        }
+
+        /**
+         * Set the behaviour in case of hard system errors, see {@link ExitHandler}.
+         * @param exitHandler the handler
+         * @return the builder
+         */
+        public ZookKeeperServerEmbeddedBuilder exitHandler(ExitHandler exitHandler) {
+            this.exitHandler = exitHandler;
+            return this;
+        }
+
+        /**
+         * Validate the configuration and create the server, without starting it.
+         * @return the new server
+         * @throws Exception
+         * @see #start()
+         */
+        public ZooKeeperServerEmbedded build() throws Exception {
+            if (baseDir == null) {
+                throw new IllegalArgumentException();
+            }
+            if (configuration == null) {
+                throw new IllegalArgumentException();
+            }
+            if (exitHandler == null) {
+                throw new IllegalArgumentException();
+            }","[{'comment': ""Two small things bother me (very slightly) here:\r\n\r\n1. `IllegalArgumentException` in an argument-less method;\r\n2. No clear indication of which parameter was `null` in error logs.\r\n\r\nJoshua Bloch [seems to recommend](https://softwareengineering.stackexchange.com/a/241320) throwing `IllegalStateException`.  But perhaps just using `Objects.requireNonNull` in the buildee's constructor would be simpler/clearer?\r\n\r\n\r\n"", 'commenter': 'ztzg'}, {'comment': 'I have applied a mix of the two suggestions.\r\nAdded `Objects.requireNonNull` and moved to `IllegalStateException`\r\n`configuration` and `baseDir`may be null if the methods are not called at all', 'commenter': 'eolivelli'}]"
1526,zookeeper-server/src/main/java/org/apache/zookeeper/server/embedded/ZooKeeperServerEmbeddedImpl.java,"@@ -0,0 +1,164 @@
+package org.apache.zookeeper.server.embedded;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import java.io.OutputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Map;
+import java.util.Properties;
+import org.apache.zookeeper.server.DatadirCleanupManager;
+import org.apache.zookeeper.server.ExitCode;
+import org.apache.zookeeper.server.ServerConfig;
+import org.apache.zookeeper.server.ZooKeeperServerMain;
+import org.apache.zookeeper.server.quorum.QuorumPeer;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
+import org.apache.zookeeper.server.quorum.QuorumPeerMain;
+import org.apache.zookeeper.util.ServiceUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright
+ * ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the
+ * License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+ * implied. See the License for the specific language governing permissions and limitations under the License.
+ */","[{'comment': 'Nit: This shouldn\'t be a Javadoc comment.  Also: shouldn\'t such license banners be ""canonicalized"" to  match `ZooKeeper.java`, and be at the top?', 'commenter': 'ztzg'}, {'comment': 'good catch !\r\nI have moved these classes from another repo and package and I did a mess with license headers !', 'commenter': 'eolivelli'}]"
1526,zookeeper-server/src/main/java/org/apache/zookeeper/server/embedded/ZooKeeperServerEmbeddedImpl.java,"@@ -0,0 +1,164 @@
+package org.apache.zookeeper.server.embedded;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import java.io.OutputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Map;
+import java.util.Properties;
+import org.apache.zookeeper.server.DatadirCleanupManager;
+import org.apache.zookeeper.server.ExitCode;
+import org.apache.zookeeper.server.ServerConfig;
+import org.apache.zookeeper.server.ZooKeeperServerMain;
+import org.apache.zookeeper.server.quorum.QuorumPeer;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
+import org.apache.zookeeper.server.quorum.QuorumPeerMain;
+import org.apache.zookeeper.util.ServiceUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright
+ * ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the
+ * License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+ * implied. See the License for the specific language governing permissions and limitations under the License.
+ */
+/**
+ * Implementation
+ */
+@SuppressFBWarnings(""DM_EXIT"")","[{'comment': ""Is this annotation a leftover from a previous iteration? It doesn't seem to be needed."", 'commenter': 'ztzg'}, {'comment': 'yes, good catch', 'commenter': 'eolivelli'}]"
1526,zookeeper-server/src/test/java/org/apache/zookeeper/server/embedded/ZookeeperServeInfo.java,"@@ -0,0 +1,297 @@
+package org.apache.zookeeper.server.embedded;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.management.ManagementFactory;
+import java.lang.reflect.UndeclaredThrowableException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.management.InstanceNotFoundException;
+import javax.management.MBeanServer;
+import javax.management.MBeanServerInvocationHandler;
+import javax.management.ObjectInstance;
+import javax.management.ObjectName;
+import org.apache.zookeeper.common.StringUtils;
+import org.apache.zookeeper.server.ConnectionMXBean;
+import org.apache.zookeeper.server.ZooKeeperServerBean;
+import org.apache.zookeeper.server.quorum.LocalPeerMXBean;
+import org.apache.zookeeper.server.quorum.QuorumBean;
+import org.apache.zookeeper.server.quorum.QuorumMXBean;
+import org.apache.zookeeper.server.quorum.RemotePeerMXBean;
+
+public class ZookeeperServeInfo {
+
+    private static final MBeanServer localServer = ManagementFactory.getPlatformMBeanServer();
+
+    public static class PeerInfo {
+
+        private final String name;
+        private final String quorumAddress;
+        private final String state;
+        private final boolean leader;
+
+        public PeerInfo(String name, String quorumAddress, String state, boolean leader) {
+            this.name = name;
+            this.quorumAddress = quorumAddress;
+            this.state = state;
+            this.leader = leader;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public String getQuorumAddress() {
+            return quorumAddress;
+        }
+
+        public String getState() {
+            return state;
+        }
+
+        public boolean isLeader() {
+            return leader;
+        }
+
+        @Override
+        public String toString() {
+            return ""PeerInfo{"" + ""name="" + name + "", leader="" + leader + "", quorumAddress="" + quorumAddress
+                    + "", state="" + state + '}';
+        }
+    }
+
+    public static class ConnectionInfo {
+
+        private final String sourceip;
+        private final String sessionid;
+        private final String lastoperation;
+        private final String lastResponseTime;
+        private final String avgLatency;
+        private final String lastLatency;
+        private final String nodes;
+
+        public ConnectionInfo(String sourceip, String sessionid, String lastoperation, String lastResponseTime,
+                              String avgLatency, String lastLatency, String nodes) {
+            this.sourceip = sourceip;
+            this.sessionid = sessionid;
+            this.lastoperation = lastoperation;
+            this.lastResponseTime = lastResponseTime;
+            this.avgLatency = avgLatency;
+            this.lastLatency = lastLatency;
+            this.nodes = nodes;
+        }
+
+        public String getLastLatency() {
+            return lastLatency;
+        }
+
+        public String getSourceip() {
+            return sourceip;
+        }
+
+        public String getSessionid() {
+            return sessionid;
+        }
+
+        public String getLastoperation() {
+            return lastoperation;
+        }
+
+        public String getLastResponseTime() {
+            return lastResponseTime;
+        }
+
+        public String getAvgLatency() {
+            return avgLatency;
+        }
+
+        public String getNodes() {
+            return nodes;
+        }
+
+        @Override
+        public String toString() {
+            return ""ConnectionInfo{"" + ""sourceip="" + sourceip + "", sessionid="" + sessionid + "", lastoperation=""
+                    + lastoperation + "", lastResponseTime="" + lastResponseTime + "", avgLatency="" + avgLatency
+                    + "", nodes="" + nodes + '}';
+        }
+    }
+
+    public static class ServerInfo {
+
+        private final List<ConnectionInfo> connections = new ArrayList<>();
+        private boolean isleader;
+        private boolean standaloneMode;
+        public List<PeerInfo> peers = new ArrayList<>();
+
+        public boolean isStandaloneMode() {
+            return standaloneMode;
+        }
+
+        public List<ConnectionInfo> getConnections() {
+            return connections;
+        }
+
+        public boolean isIsleader() {
+            return isleader;
+        }","[{'comment': 'I suppose there is a good reason for this not to be called `isLeader`?  (Introspection or something?  But I did not see any in this context.)\r\n', 'commenter': 'ztzg'}, {'comment': 'good idea, I guess it was an old typo', 'commenter': 'eolivelli'}]"
1526,zookeeper-server/src/test/java/org/apache/zookeeper/server/embedded/ZookeeperServerClusterTest.java,"@@ -0,0 +1,124 @@
+package org.apache.zookeeper.server.embedded;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Properties;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.io.TempDir;
+
+public class ZookeeperServerClusterTest {
+
+    @BeforeAll
+    public static void setUpEnvironment() {
+        System.setProperty(""zookeeper.admin.enableServer"", ""false"");
+        System.setProperty(""zookeeper.4lw.commands.whitelist"", ""*"");
+    }
+
+    @AfterAll
+    public static void cleanUpEnvironment() throws InterruptedException, IOException {
+        System.clearProperty(""zookeeper.admin.enableServer"");
+        System.clearProperty(""zookeeper.4lw.commands.whitelist"");
+        System.clearProperty(""java.security.auth.login.config"");","[{'comment': 'Leftover?', 'commenter': 'ztzg'}, {'comment': 'yes', 'commenter': 'eolivelli'}]"
1526,zookeeper-server/src/test/java/org/apache/zookeeper/server/embedded/ZookeeperServerEmbeddedTest.java,"@@ -0,0 +1,69 @@
+package org.apache.zookeeper.server.embedded;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright
+ * ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the
+ * License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+ * implied. See the License for the specific language governing permissions and limitations under the License.
+ */
+
+import static org.junit.Assert.assertTrue;
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.Properties;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.io.TempDir;
+
+public class ZookeeperServerEmbeddedTest {
+
+    @BeforeAll
+    public static void setUpEnvironment() {
+        System.setProperty(""zookeeper.admin.enableServer"", ""false"");
+        System.setProperty(""zookeeper.4lw.commands.whitelist"", ""*"");
+    }
+
+    @AfterAll
+    public static void cleanUpEnvironment() throws InterruptedException, IOException {
+        System.clearProperty(""zookeeper.admin.enableServer"");","[{'comment': 'Missing `System.clearProperty(""zookeeper.4lw.commands.whitelist"")`?', 'commenter': 'ztzg'}]"
1526,zookeeper-server/src/test/java/org/apache/zookeeper/server/embedded/ZookeeperServerSslEmbeddedTest.java,"@@ -0,0 +1,117 @@
+package org.apache.zookeeper.server.embedded;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright
+ * ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the
+ * License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+ * implied. See the License for the specific language governing permissions and limitations under the License.
+ */
+
+import static org.junit.Assert.assertTrue;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.Properties;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.client.ZKClientConfig;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.io.TempDir;
+
+public class ZookeeperServerSslEmbeddedTest {
+
+    @BeforeAll
+    public static void setUpEnvironment() {
+        System.setProperty(""zookeeper.admin.enableServer"", ""false"");
+        System.setProperty(""zookeeper.4lw.commands.whitelist"", ""*"");
+    }
+
+    @AfterAll
+    public static void cleanUpEnvironment() throws InterruptedException, IOException {
+        System.clearProperty(""zookeeper.admin.enableServer"");
+        System.clearProperty(""zookeeper.4lw.commands.whitelist"");
+        System.clearProperty(""java.security.auth.login.config"");
+        System.clearProperty(""zookeeper.client.secure"");","[{'comment': 'Missing `System.clearProperty(""zookeeper.clientCnxnSocket"")`?', 'commenter': 'ztzg'}, {'comment': ""I don't think so, we are using ZKClientConfig and not system properties in this case"", 'commenter': 'eolivelli'}, {'comment': 'My bad.  (The question then becomes: why are we clearing `""zookeeper.client.secure""`?  :)', 'commenter': 'ztzg'}, {'comment': '@ztzg you are right, there is no need to clear it\r\nI have updated the patch\r\n\r\n', 'commenter': 'eolivelli'}]"
1526,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServerMain.java,"@@ -239,7 +239,28 @@ ServerCnxnFactory getCnxnFactory() {
 
     // VisibleForTesting
     ServerCnxnFactory getSecureCnxnFactory() {
-        return secureCnxnFactory;
+    }","[{'comment': 'The `return secureCnxnFactory;` somehow got swallowed here, causing CI errors.', 'commenter': 'ztzg'}, {'comment': '@ztzg I made  mess while resolving conflicts using the github UI :-) \r\nI have fixed the code', 'commenter': 'eolivelli'}]"
1526,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java,"@@ -611,14 +611,16 @@ public void rollLog() throws IOException {
      * @throws IOException
      */
     public void close() throws IOException {","[{'comment': ""what's the purpose of the changes to this `close` method? I don't quite get the motivation behind this change."", 'commenter': 'hanm'}]"
1530,zookeeper-it/src/main/java/org/apache/zookeeper/test/system/GenerateLoad.java,"@@ -713,7 +711,7 @@ private static String getMode(String hostPort) throws NumberFormatException, Unk
     }
 
     private static void doUsage() {
-        System.err.println(""USAGE: "" + GenerateLoad.class.getName()
+        LOG.info(""USAGE: "" + GenerateLoad.class.getName()","[{'comment': 'I would say that the usage synopsis should still go to `System.err`.  What do you think?', 'commenter': 'ztzg'}, {'comment': ""I do not have a strong opinion here\r\n@mino181295 what's your opinion ?"", 'commenter': 'eolivelli'}, {'comment': 'I agree with @ztzg do you think it should be `System.err.println` also line 673-676?  ', 'commenter': 'mino181295'}, {'comment': ""I'd say so.  (Sorry for missing it on the first round.)"", 'commenter': 'ztzg'}, {'comment': 'ah dang, i hit approve too quickly. i agree with this requested change as well.', 'commenter': 'breed'}, {'comment': 'oh and i see that it has been addressed :)', 'commenter': 'breed'}]"
1551,zookeeper-contrib/zookeeper-contrib-zooinspector/zooInspector.sh,"@@ -15,4 +15,11 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-java -cp ""zookeeper-dev-ZooInspector.jar:lib/*:lib"" org.apache.zookeeper.inspector.ZooInspector
+# Get the path to the directory containing this script
+SCRIPT_DIR=$(dirname ""$0"")
+
+# Get the path to the uber jar for this tool
+# (Requires ""mvn install"" or ""mvn package"" be run first)
+JAVA_LIB=`ls ${SCRIPT_DIR}/target/zookeeper-contrib-zooinspector-*-jar-with-dependencies.jar`","[{'comment': 'If we go his way then you can simply create an executable jar and call \r\njava   -jar   zooinspector-xxx.jar\r\n\r\n', 'commenter': 'eolivelli'}, {'comment': ""That is a good point.  If we're only going to have a single JAR on the CLASSPATH then we might as well execute that JAR directly.  Let me try to make that change and update the PR.  Thanks for looking!"", 'commenter': 'brentwritescode'}]"
1554,zookeeper-server/src/main/resources/lib/jetty-http-9.4.35.v20201120.LICENSE.txt,"@@ -1,8 +1,7 @@
 This program and the accompanying materials are made available under the
-terms of the Eclipse Public License 1.0 which is available at
-https://www.eclipse.org/org/documents/epl-1.0/EPL-1.0.txt
-or the Apache Software License 2.0 which is available at
-https://www.apache.org/licenses/LICENSE-2.0
+terms of the Eclipse Public License 2.0 which is available at","[{'comment': 'Please remove this license file as 3.5 no longer uses jetty-client. Thank you!', 'commenter': 'nkalmar'}, {'comment': 'I\'m seeing my comment on jetty-http on the main page, but on ""files"" page I commented on jetty-client. Strange. But it\'s the jetty-client that we don\'t need.', 'commenter': 'nkalmar'}, {'comment': '> Please remove this license file as 3.5 no longer uses jetty-client. Thank you!\r\n>\r\n> I\'m seeing my comment on jetty-http on the main page, but on ""files"" page I commented on jetty-client. Strange. But it\'s the jetty-client that we don\'t need.\r\n\r\nI had already removed `jetty-client` on this branch:\r\n\r\n```\r\n$ ls zookeeper-server/src/main/resources/lib/jetty-*\r\nzookeeper-server/src/main/resources/lib/jetty-http-9.4.35.v20201120.LICENSE.txt\r\nzookeeper-server/src/main/resources/lib/jetty-io-9.4.35.v20201120.LICENSE.txt\r\nzookeeper-server/src/main/resources/lib/jetty-security-9.4.35.v20201120.LICENSE.txt\r\nzookeeper-server/src/main/resources/lib/jetty-server-9.4.35.v20201120.LICENSE.txt\r\nzookeeper-server/src/main/resources/lib/jetty-servlet-9.4.35.v20201120.LICENSE.txt\r\nzookeeper-server/src/main/resources/lib/jetty-util-9.4.35.v20201120.LICENSE.txt\r\nzookeeper-server/src/main/resources/lib/jetty-util-ajax-9.4.35.v20201120.LICENSE.txt\r\n```\r\n\r\nThe reason you are observing a mix-up, and your comment landed in a strange place, is because Git thinks I have renamed `jetty-client-9.4.34` to `jetty-http-9.4.35`, etc., and that I have deleted `jetty-server-9.4.34`!  (Similar contents and different file names throw its rename detector off.)\r\n\r\nThe result is correct.  The Git commit is correct.  It\'s only the diff which *appears* wrong (it is actually correct, but overly convoluted).\r\n\r\nSo unless I\'m missing something else, I think we\'re good.\r\n\r\n', 'commenter': 'ztzg'}]"
1559,zookeeper-server/src/main/java/org/apache/zookeeper/MultiOperationRecord.java,"@@ -126,7 +127,10 @@ public void deserialize(InputArchive archive, String tag) throws IOException {
                 case ZooDefs.OpCode.createContainer:
                     CreateRequest cr = new CreateRequest();
                     cr.deserialize(archive, tag);
-                    add(Op.create(cr.getPath(), cr.getData(), cr.getAcl(), cr.getFlags()));
+                    EnumSet<Op.CreateFlags> createFlags = h.getType() == ZooDefs.OpCode.create2
+                        ? EnumSet.of(Op.CreateFlags.WANT_STAT)","[{'comment': 'Can we have a constant even for this case? We are going to reduce memory allocations ', 'commenter': 'eolivelli'}, {'comment': 'Done.\r\n\r\nAdding that odd case to the visible API felt a bit awkward, so I have attached it to the `MultiOperationRecord` implementation.  (Of course, the ""odd case""-ness is debatable since we only have a single flag :)  Let me know if you\'d prefer to have it in the enum.  (In which case I would also appreciate a suggestion for a non-clashing name!)\r\n\r\nI have also wrapped both `EnumSet`s with `Collections.unmodifiableSet`, as the former are in fact mutable.', 'commenter': 'ztzg'}]"
1559,zookeeper-server/src/test/java/org/apache/zookeeper/test/MultiOperationTest.java,"@@ -443,6 +444,22 @@ public void testCreate(boolean useAsync) throws Exception {
         zk.getData(""/multi2"", false, null);
     }
 
+
+    @ParameterizedTest
+    @ValueSource(booleans = {true, false})
+    public void testCreateWantStat(boolean useAsync) throws Exception {
+        List<OpResult> results = multi(zk, Arrays.asList(
+                Op.create(""/multi0"", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, Op.CreateFlags.DEFAULT),
+                Op.create(""/multi1"", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, EnumSet.of(Op.CreateFlags.WANT_STAT)),
+                Op.create(""/multi2"", new byte[0], Ids.OPEN_ACL_UNSAFE, 0, Op.CreateFlags.DEFAULT),
+                Op.create(""/multi3"", new byte[0], Ids.OPEN_ACL_UNSAFE, 0, EnumSet.of(Op.CreateFlags.WANT_STAT))),","[{'comment': 'Probably this looks like boilerplate\r\n`EnumSet.of(Op.CreateFlags.WANT_STAT))`\r\nCan  we create a constant like Op.CreateFlags.DEFAULT ?\r\n', 'commenter': 'eolivelli'}, {'comment': 'Done.', 'commenter': 'ztzg'}]"
1559,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -1001,6 +1001,7 @@ public ProcessTxnResult processTxn(TxnHeader header, Record txn, boolean isSubTx
                     Record record = null;
                     switch (subtxn.getType()) {
                     case OpCode.create:
+                    case OpCode.create2:","[{'comment': 'this change is interesting here, because it means that this feature will be supported only when the server is 3.7+\r\n\r\nwhich error will be reported to a 3.7 client that talks to a 3.6/3.5 server?', 'commenter': 'eolivelli'}, {'comment': 'I will double-check, but from the top of my head: no error, just missing stat data.  (Charles-Henri, who reported ZOOKEEPER-4026, discovered the problem while adding `multi` support to Kazoo.  The ""2"" in front of the request just fell off :)\r\n', 'commenter': 'ztzg'}, {'comment': 'I have double-checked this, and my recollection was correct: a new client requesting a `Stat` from 3.5, 3.6 or current `master` receives a response, but it is missing `Stat` data.', 'commenter': 'ztzg'}]"
1559,zookeeper-server/src/main/java/org/apache/zookeeper/Op.java,"@@ -146,10 +236,33 @@ public static Op create(String path, byte[] data, List<ACL> acl, CreateMode crea
      *                optional ttl or 0 (createMode must imply a TTL)
      */
     public static Op create(String path, byte[] data, List<ACL> acl, CreateMode createMode, long ttl) {
+        return create(path, data, acl, createMode, CreateFlags.DEFAULT, ttl);
+    }
+
+    /**
+     * Constructs a create operation.  Arguments are as for the ZooKeeper method of the same name
+     * but adding an optional ttl
+     * @see ZooKeeper#create(String, byte[], java.util.List, CreateMode)
+     *
+     * @param path
+     *                the path for the node
+     * @param data
+     *                the initial data for the node
+     * @param acl
+     *                the acl for the node
+     * @param createMode
+     *                specifying whether the node to be created is ephemeral
+     *                and/or sequential
+     * @param createFlags
+     *                the set of {@link CreateFlags} to apply
+     * @param ttl
+     *                optional ttl or 0 (createMode must imply a TTL)
+     */
+    public static Op create(String path, byte[] data, List<ACL> acl, CreateMode createMode, Set<CreateFlags> createFlags, long ttl) {","[{'comment': 'adding a new factory method is not very awesome from my point of view.\r\n\r\ncan we take the opportunity to add a fluent Builder for ""Op"" ?\r\nalso adding ""Deprecated"" to the other factory methods', 'commenter': 'eolivelli'}, {'comment': 'Added a note below: https://github.com/apache/zookeeper/pull/1559#issuecomment-759411279', 'commenter': 'ztzg'}, {'comment': 'I am leaning toward adding the Builder support without marking the methods as Deprecated (in order to not change tests, we have a few important big forks and changing lots of tests will be a pain for every one).\r\n\r\nSo adding the Builder and not adding this new overloaded method here.\r\n\r\nI am not sure that adding the Builder is about adding much code. \r\n\r\ncc @hanm @lvfangmin \r\n', 'commenter': 'eolivelli'}, {'comment': ""> I am leaning toward adding the Builder support without marking the methods as Deprecated (in order to not change tests, we have a few important big forks and changing lots of tests will be a pain for every one).\r\n> \r\n> So adding the Builder and not adding this new overloaded method here.\r\n\r\nRight.  That's what I did in this other branch:\r\n\r\nhttps://github.com/ztzg/zookeeper/commits/ZOOKEEPER-4026-multi-create2-fluent-builder\r\n\r\nIn particular, here is the builder for `Create` and `CreateTTL`:\r\n\r\nhttps://github.com/ztzg/zookeeper/commit/d7bab23d8faf2f364a8bbe32a2c15170030e4d40#diff-d6e7807a04d07a070ee3da75ccd793bd973b5af0ee5597f0969a0a7721d0200fR376\r\n\r\n> I am not sure that adding the Builder is about adding much code.\r\n\r\nThere are *six* direct subclasses of `Op`, though: https://javadoc.io/doc/org.apache.zookeeper/zookeeper/latest/org/apache/zookeeper/Op.html .  (The only indirect one is `CreateTTL`, and it is already handed.)\r\n\r\nBut looking closer, the others do not warrant introducing a `*Builder`, as they don't have the same variability in parameters.  Would you be okay with the asymmetry?  (I.e., only introducing a `CreateBuilder`, and leaving the rest as-is.)\r\n\r\n\r\n\r\n"", 'commenter': 'ztzg'}, {'comment': 'Okay—the version I just pushed implements the ""fluent builder"" pattern for `Create`, and only uses a simple `boolean` for the new feature, as pondered in https://github.com/apache/zookeeper/pull/1559#discussion_r556586446.\r\n\r\nI find the result simpler and easier to read.  What do you think?', 'commenter': 'ztzg'}]"
1559,zookeeper-server/src/main/java/org/apache/zookeeper/Op.java,"@@ -54,6 +56,29 @@
         READ
     }
 
+    /**
+     * Optional flags for the
+     * {@link Op#create(String, byte[], List, CreateMode, EnumSet)}
+     * and similar operations.
+     */
+    public enum CreateFlags {
+        /**
+         * Requests that a {@code Stat} object be included in the
+         * response.
+         *
+         * This is semantically equivalent to passing a non-{@code null}
+         * {@var stat} parameter to
+         * {@link ZooKeeper#create(String, byte[], List, CreateMode, Stat)}.
+         */
+        WANT_STAT;","[{'comment': 'I am not sure this is a good name.\r\nwhat about `RETURN_STAT` or `WITH_STAT`?', 'commenter': 'eolivelli'}, {'comment': 'Done.', 'commenter': 'ztzg'}]"
1559,zookeeper-server/src/main/java/org/apache/zookeeper/Op.java,"@@ -54,6 +56,35 @@
         READ
     }
 
+    /**
+     * Optional flags for the
+     * {@link Op#create(String, byte[], List, CreateMode, EnumSet)}
+     * and similar operations.
+     */
+    public enum CreateFlags {
+        /**
+         * Requests that a {@code Stat} object be included in the
+         * response.
+         *
+         * This is semantically equivalent to passing a non-{@code null}
+         * {@code stat} parameter to
+         * {@link ZooKeeper#create(String, byte[], List, CreateMode, Stat)}.
+         */
+        WITH_STAT;","[{'comment': 'RETURN_STAT ?', 'commenter': 'eolivelli'}, {'comment': ""You suggested `WITH_STAT` or `RETURN_STAT`, so… I used both :)\r\n\r\nMore seriously, there is already a `RETURN_STAT` a few lines below.  `WITH_STAT` is the enumeration value, and `RETURN_STAT` the constant `Set`.\r\n\r\nI'm not very happy with that.  But I suppose we actually don't need a set of flags if we use the builder approach; individual booleans are fine if the setters are named."", 'commenter': 'ztzg'}]"
1559,zookeeper-server/src/main/java/org/apache/zookeeper/Op.java,"@@ -253,6 +254,142 @@ void validate() throws KeeperException {
         PathUtils.validatePath(path);
     }
 
+    /**
+     * ""Fluent builder"" for {@link Create} operations.
+     */
+    public static class CreateBuilder {
+        private String path;
+        private byte[] data;
+        private List<ACL> acl;
+        private Integer createModeFlag;
+        private CreateMode createMode;
+        private boolean returnStat = false;
+        private Long ttl;
+
+        /**
+         * Sets the path for the node.  Must be set before calling
+         * {@link #build()}.
+         *
+         * @param path  the path for the node
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setPath(String path) {
+            this.path = path;
+            return this;
+        }
+
+        /**
+         * Sets the initial data for the node, or {@code null}.
+         *
+         * @param data  the initial data for the node
+         * @return the builder, for chaining.
+         */
+        @SuppressFBWarnings({""EI_EXPOSE_REP"", ""EI_EXPOSE_REP2""})
+        public CreateBuilder setData(byte[] data) {
+            this.data = data;
+            return this;
+        }
+
+        /**
+         * Sets the acl for the node.  Must be set before calling
+         * {@link #build()}.
+         *
+         * @param acl  the acl for the node
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setACL(List<ACL> acl) {
+            this.acl = acl;
+            return this;
+        }
+
+        /**
+         * Specifyies whether the node to be created is ephemeral,
+         * sequential, etc. using the integer encoding.  Either this
+         * or {@link #setCreateMode} must be used before calling
+         * {@link #build()}.
+         *
+         * @param createModeFlag  the create mode encoded as an integer
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setCreateModeFlag(Integer createModeFlag) {","[{'comment': 'why ""Integer"" ?\r\nis it expected to pass ""null"" ?\r\n\r\nI am fine with having `Integer` as internal value, but maybe here in this point we should have only `int`', 'commenter': 'eolivelli'}, {'comment': ""Yes, the intent was to allow (re)setting these properties to `null` (which is their default value), otherwise there is no way to put the object back into its default state.\r\n\r\n(As I suppose you have noticed, `null` is notably used as a marker for `createMode` and `createModeFlag`, which are exclusive.)\r\n\r\nBut I can switch it to `int`; I don't expect that many people will want to reuse `CreateBuilder` instances.\r\n"", 'commenter': 'ztzg'}, {'comment': 'Done.', 'commenter': 'ztzg'}]"
1559,zookeeper-server/src/main/java/org/apache/zookeeper/Op.java,"@@ -253,6 +254,142 @@ void validate() throws KeeperException {
         PathUtils.validatePath(path);
     }
 
+    /**
+     * ""Fluent builder"" for {@link Create} operations.
+     */
+    public static class CreateBuilder {
+        private String path;
+        private byte[] data;
+        private List<ACL> acl;
+        private Integer createModeFlag;
+        private CreateMode createMode;
+        private boolean returnStat = false;
+        private Long ttl;
+
+        /**
+         * Sets the path for the node.  Must be set before calling
+         * {@link #build()}.
+         *
+         * @param path  the path for the node
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setPath(String path) {
+            this.path = path;
+            return this;
+        }
+
+        /**
+         * Sets the initial data for the node, or {@code null}.
+         *
+         * @param data  the initial data for the node
+         * @return the builder, for chaining.
+         */
+        @SuppressFBWarnings({""EI_EXPOSE_REP"", ""EI_EXPOSE_REP2""})
+        public CreateBuilder setData(byte[] data) {
+            this.data = data;
+            return this;
+        }
+
+        /**
+         * Sets the acl for the node.  Must be set before calling
+         * {@link #build()}.
+         *
+         * @param acl  the acl for the node
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setACL(List<ACL> acl) {
+            this.acl = acl;
+            return this;
+        }
+
+        /**
+         * Specifyies whether the node to be created is ephemeral,
+         * sequential, etc. using the integer encoding.  Either this
+         * or {@link #setCreateMode} must be used before calling
+         * {@link #build()}.
+         *
+         * @param createModeFlag  the create mode encoded as an integer
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setCreateModeFlag(Integer createModeFlag) {
+            this.createModeFlag = createModeFlag;
+            return this;
+        }
+
+        /**
+         * Specifyies whether the node to be created is ephemeral,
+         * sequential, etc.  Either this or {@link #setCreateModeFlag}
+         * must be used before calling {@link #build()}.
+         *
+         * @param createMode  the create mode as an enum value
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setCreateMode(CreateMode createMode) {
+            this.createMode = createMode;
+            return this;
+        }
+
+        /**
+         * Configures whether to include a {@code Stat} object in the
+         * response.  Defaults to {@code false}.
+         *
+         * <p>Note that this flag has no effect for TTL or container
+         * nodes, as those always include a {@code Stat} at the
+         * protocol level.
+         *
+         * @param returnStat  whether node creation should produce a
+         *   {@code Stat} object
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setReturnStat(boolean returnStat) {
+            this.returnStat = returnStat;
+            return this;
+        }
+
+        /**
+         * Sets the TTL for the node.  Must be set before calling
+         * {@link #build()} when creating TTL nodes.
+         *
+         * @param ttl  the TTL for the node
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setTTL(Long ttl) {","[{'comment': 'the same here, we should have `long`', 'commenter': 'eolivelli'}, {'comment': 'Done.', 'commenter': 'ztzg'}]"
1559,zookeeper-server/src/main/java/org/apache/zookeeper/Op.java,"@@ -253,6 +254,142 @@ void validate() throws KeeperException {
         PathUtils.validatePath(path);
     }
 
+    /**
+     * ""Fluent builder"" for {@link Create} operations.
+     */
+    public static class CreateBuilder {
+        private String path;
+        private byte[] data;
+        private List<ACL> acl;
+        private Integer createModeFlag;
+        private CreateMode createMode;
+        private boolean returnStat = false;
+        private Long ttl;
+
+        /**
+         * Sets the path for the node.  Must be set before calling
+         * {@link #build()}.
+         *
+         * @param path  the path for the node
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setPath(String path) {
+            this.path = path;
+            return this;
+        }
+
+        /**
+         * Sets the initial data for the node, or {@code null}.
+         *
+         * @param data  the initial data for the node
+         * @return the builder, for chaining.
+         */
+        @SuppressFBWarnings({""EI_EXPOSE_REP"", ""EI_EXPOSE_REP2""})
+        public CreateBuilder setData(byte[] data) {
+            this.data = data;
+            return this;
+        }
+
+        /**
+         * Sets the acl for the node.  Must be set before calling
+         * {@link #build()}.
+         *
+         * @param acl  the acl for the node
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setACL(List<ACL> acl) {
+            this.acl = acl;","[{'comment': 'are we allowing a `null` value here ?', 'commenter': 'eolivelli'}, {'comment': 'The idea was to perform validation at `build()` time—but it is true that `path` and `acl` are not, in fact, validated by the `Create`/`CreateTTL` constructors.  I suppose that should be fixed.\r\n\r\nOr are you suggesting that a check should be added at *this* point?  (That would match your `int`/`long` comment, and correspond to a ""properties must be set once, and must be set right"" model—which is not what I was initially going for.)', 'commenter': 'ztzg'}, {'comment': 'It is better to perform validation on build() when possible ', 'commenter': 'eolivelli'}, {'comment': 'Done (checking `path` and `acl`).\r\n\r\nI had added the checks to the `Op.Create` constructor, but went back to checking at `build()` time, not to change the existing `create(...)` methods—which still do *not* check for `null`—as it may be that some programs accidentally do that.  (No error is thrown if the request is never submitted.)', 'commenter': 'ztzg'}]"
1559,zookeeper-server/src/main/java/org/apache/zookeeper/Op.java,"@@ -253,6 +254,142 @@ void validate() throws KeeperException {
         PathUtils.validatePath(path);
     }
 
+    /**
+     * ""Fluent builder"" for {@link Create} operations.
+     */
+    public static class CreateBuilder {
+        private String path;
+        private byte[] data;
+        private List<ACL> acl;
+        private Integer createModeFlag;
+        private CreateMode createMode;
+        private boolean returnStat = false;
+        private Long ttl;
+
+        /**
+         * Sets the path for the node.  Must be set before calling
+         * {@link #build()}.
+         *
+         * @param path  the path for the node
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setPath(String path) {
+            this.path = path;
+            return this;
+        }
+
+        /**
+         * Sets the initial data for the node, or {@code null}.
+         *
+         * @param data  the initial data for the node
+         * @return the builder, for chaining.
+         */
+        @SuppressFBWarnings({""EI_EXPOSE_REP"", ""EI_EXPOSE_REP2""})
+        public CreateBuilder setData(byte[] data) {
+            this.data = data;","[{'comment': 'are we allowing a `null` value here ?', 'commenter': 'eolivelli'}, {'comment': 'Yes, we do.\r\n\r\n(I mean, `data` can be `null` for create requests.  Would you suggest preventing setting a `null` data on the builder, forcing the caller to use an `if`?)', 'commenter': 'ztzg'}, {'comment': '*Not* changed, and explicitly documented as accepting `null`.', 'commenter': 'ztzg'}]"
1559,zookeeper-server/src/main/java/org/apache/zookeeper/Op.java,"@@ -253,6 +254,142 @@ void validate() throws KeeperException {
         PathUtils.validatePath(path);
     }
 
+    /**
+     * ""Fluent builder"" for {@link Create} operations.
+     */
+    public static class CreateBuilder {
+        private String path;
+        private byte[] data;
+        private List<ACL> acl;
+        private Integer createModeFlag;
+        private CreateMode createMode;
+        private boolean returnStat = false;
+        private Long ttl;
+
+        /**
+         * Sets the path for the node.  Must be set before calling
+         * {@link #build()}.
+         *
+         * @param path  the path for the node
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setPath(String path) {
+            this.path = path;","[{'comment': 'are we allowing a `null` value here ?', 'commenter': 'eolivelli'}]"
1559,zookeeper-server/src/main/java/org/apache/zookeeper/Op.java,"@@ -253,6 +254,142 @@ void validate() throws KeeperException {
         PathUtils.validatePath(path);
     }
 
+    /**
+     * ""Fluent builder"" for {@link Create} operations.
+     */
+    public static class CreateBuilder {
+        private String path;
+        private byte[] data;
+        private List<ACL> acl;
+        private Integer createModeFlag;
+        private CreateMode createMode;
+        private boolean returnStat = false;
+        private Long ttl;
+
+        /**
+         * Sets the path for the node.  Must be set before calling
+         * {@link #build()}.
+         *
+         * @param path  the path for the node
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setPath(String path) {
+            this.path = path;
+            return this;
+        }
+
+        /**
+         * Sets the initial data for the node, or {@code null}.
+         *
+         * @param data  the initial data for the node
+         * @return the builder, for chaining.
+         */
+        @SuppressFBWarnings({""EI_EXPOSE_REP"", ""EI_EXPOSE_REP2""})
+        public CreateBuilder setData(byte[] data) {
+            this.data = data;
+            return this;
+        }
+
+        /**
+         * Sets the acl for the node.  Must be set before calling
+         * {@link #build()}.
+         *
+         * @param acl  the acl for the node
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setACL(List<ACL> acl) {
+            this.acl = acl;
+            return this;
+        }
+
+        /**
+         * Specifyies whether the node to be created is ephemeral,
+         * sequential, etc. using the integer encoding.  Either this
+         * or {@link #setCreateMode} must be used before calling
+         * {@link #build()}.
+         *
+         * @param createModeFlag  the create mode encoded as an integer
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setCreateModeFlag(Integer createModeFlag) {
+            this.createModeFlag = createModeFlag;
+            return this;
+        }
+
+        /**
+         * Specifyies whether the node to be created is ephemeral,
+         * sequential, etc.  Either this or {@link #setCreateModeFlag}
+         * must be used before calling {@link #build()}.
+         *
+         * @param createMode  the create mode as an enum value
+         * @return the builder, for chaining.
+         */
+        public CreateBuilder setCreateMode(CreateMode createMode) {
+            this.createMode = createMode;","[{'comment': 'are we allowing a `null` value here ?', 'commenter': 'eolivelli'}]"
1562,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeerMain.java,"@@ -233,12 +233,10 @@ public void runFromConfig(QuorumPeerConfig config) throws IOException, AdminServ
             // warn, but generally this is ok
             LOG.warn(""Quorum Peer interrupted"", e);
         } finally {
-            if (metricsProvider != null) {
-                try {
-                    metricsProvider.stop();
-                } catch (Throwable error) {
-                    LOG.warn(""Error while stopping metrics"", error);
-                }
+            try {","[{'comment': 'Please make this variable *final*', 'commenter': 'eolivelli'}, {'comment': ""It's ok"", 'commenter': 'lanicc'}]"
1581,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -530,6 +530,10 @@ public void takeSnapshot(boolean syncSnap) {
         ServerMetrics.getMetrics().SNAPSHOT_TIME.add(elapsed);
     }
 
+    public boolean shouldForceWriteInitialSnapshotDuring34Migration() {","[{'comment': ""there is no need to add 'During34Migration', we can just leave a javadoc"", 'commenter': 'eolivelli'}, {'comment': 'Ok, will fix. How about `shouldForceWriteInitialSnapshotAfterLeaderElection`?', 'commenter': 'srdo'}]"
1581,zookeeper-server/src/test/java/org/apache/zookeeper/test/EmptiedSnapshotRecoveryTest.java,"@@ -143,6 +144,48 @@ public void testRestoreWithTrustedEmptySnapFiles() throws Exception {
         runTest(false, true);
     }
 
+    @Test
+    public void testRestoreWithTrustedEmptySnapFilesWhenFollowing() throws Exception {
+        QuorumUtil qu = new QuorumUtil(1);
+        try {
+            qu.startAll();
+            String connString = qu.getConnectionStringForServer(1);
+            try (ZooKeeper zk = new ZooKeeper(connString, CONNECTION_TIMEOUT, this)) {
+                for (int i = 0; i < N_TRANSACTIONS; i++) {
+                    zk.create(""/node-"" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+                }
+            }
+            int leaderIndex = qu.getLeaderServer();
+            //Shut down the cluster and delete the snapshots from the followers
+            for (int i = 1; i <= qu.ALL; i++) {
+                qu.shutdown(i);
+                if (i != leaderIndex) {
+                    FileTxnSnapLog txnLogFactory = qu.getPeer(i).peer.getTxnFactory();
+                    List<File> snapshots = txnLogFactory.findNRecentSnapshots(10);
+                    assertTrue(snapshots.size() > 0, ""We have a snapshot to corrupt"");
+                    for (File file : snapshots) {
+                        Files.deleteIfExists(file.toPath());","[{'comment': ""we are sure that the file exists, we can just use 'delete', correct ?"", 'commenter': 'eolivelli'}, {'comment': 'Yes, will fix', 'commenter': 'srdo'}]"
1581,zookeeper-server/src/test/java/org/apache/zookeeper/test/EmptiedSnapshotRecoveryTest.java,"@@ -143,6 +144,48 @@ public void testRestoreWithTrustedEmptySnapFiles() throws Exception {
         runTest(false, true);
     }
 
+    @Test
+    public void testRestoreWithTrustedEmptySnapFilesWhenFollowing() throws Exception {
+        QuorumUtil qu = new QuorumUtil(1);
+        try {
+            qu.startAll();
+            String connString = qu.getConnectionStringForServer(1);
+            try (ZooKeeper zk = new ZooKeeper(connString, CONNECTION_TIMEOUT, this)) {
+                for (int i = 0; i < N_TRANSACTIONS; i++) {
+                    zk.create(""/node-"" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+                }
+            }","[{'comment': ""This section creates transactions, ensuring a reasonable `xzid`, but might *not* result in a snapshot, as it doesn't lower the `snapCount` using `SyncRequestProcessor.setSnapCount`.  (The other tests do, and might run before.  Might be a good idea to be explicit if the goal of running `N_TRANSACTIONS` is to create one?)\r\n\r\nThis does *not* mean that the test is broken: a snapshot is present, but it is there because of the `initialize` file left behind by `ClientBase.createTmpDir`."", 'commenter': 'ztzg'}, {'comment': ""The goal here is not to make the nodes write a snapshot due to hitting the snapcount. I just want to put some data in Zookeeper, since if Zookeeper is empty, it will create a snapshot file on boot, even without this change.\r\n\r\nThe behavior this PR changes is that if Zookeeper is booted with the trust empty property set to true, and the cluster is not empty, then the follower nodes will write a snapshot file if they don't already have one.\r\n\r\nThe issue with the code as it is without this change is that if you have a 3.4 cluster with low traffic and you then enable ZOOKEEPER_SNAPSHOT_TRUST_EMPTY and upgrade to 3.5+, then it may take a very long time for follower nodes to write snapshots, since they only do it if they become leader, or if Zookeeper is empty, or if the snapcount is hit. That makes ZOOKEEPER_SNAPSHOT_TRUST_EMPTY pretty inconvenient, since you can't remove that property again until all nodes have at least one snapshot.\r\n\r\nI have added a few lines to the test to assert that the data created here is still there once the followers come up, that seems like a healthy thing to check."", 'commenter': 'srdo'}, {'comment': 'I guess I could use another number than N_TRANSACTIONS if it is misleading?', 'commenter': 'srdo'}, {'comment': ""> The goal here is not to make the nodes write a snapshot due to hitting the snapcount. I just want to put some data in Zookeeper, since if Zookeeper is empty, it will create a snapshot file on boot, even without this change.\r\n\r\nOkay.\r\n\r\n(I understand the rest of the PR, and don't have any objections.  I was just wondering if the `N_TRANSACTIONS` was because you were trying to hit `snapCount`, like other tests in that file seem to be doing.)\r\n\r\nThank you for the clarification!"", 'commenter': 'ztzg'}, {'comment': 'Just to summarize what this test is intended to do:\r\n\r\nIt is supposed to set up a quorum with some data in it. It then deletes the snapshots on all follower nodes. This simulates what a low-traffic cluster being upgraded from 3.4 might look like. The cluster is restarted with ZOOKEEPER_SNAPSHOT_TRUST_EMPTY=true, and the test verifies that all nodes get a snapshot written. This will allow the operator to remove ZOOKEEPER_SNAPSHOT_TRUST_EMPTY again and reboot the cluster shortly after, easing migration.', 'commenter': 'srdo'}, {'comment': 'Right; we are on the same page :)\r\n\r\nWould you mind rebasing this on top of the latest `master`, so that CI picks the new configuration and re-runs the test suite with a higher chance of success?', 'commenter': 'ztzg'}, {'comment': ""Sure. Rebased and squashed. FWIW I ran the two failing tests locally, and they passed, so am guessing it's just flakiness."", 'commenter': 'srdo'}, {'comment': ""Also just a note on rebasing on top of master, since the behavior surprised me, and I thought I'd share: GH Actions' checkout action does not check out the PR branch, it instead creates a merge commit between the PR branch and the target branch, which it then runs the rest of the CI workflow on. So likely the previous run did run with the config from master."", 'commenter': 'srdo'}]"
1584,pom.xml,"@@ -253,6 +253,36 @@
         <email>eolivelli@apache.org</email>
         <timezone>+1</timezone>
     </developer>
+    <developer>
+      <id>nkalmar</id>
+      <name>Norbert Kalmar</name>
+      <email>nkalmar@apache.org</email>
+      <timezone>+1</timezone>
+    </developer>
+    <developer>
+      <id>enixon</id>
+      <name>Brian Nixon</name>
+      <email>enixon@apache.org</email>
+      <timezone>-8</timezone>
+    </developer>
+    <developer>
+      <id>symat</id>
+      <name>Mate Szalay-Beko</name>
+      <email>symat@apache.org</email>
+      <timezone>+1</timezone>
+    </developer>
+    <developer>
+      <id>ddiederen</id>
+      <name>Damien Diederen</name>
+      <email>ddiederen@apache.org</email>
+      <timezone>+2</timezone>","[{'comment': ""Ah, time zones.  Never been a sticky topic in the history of computers (or the history of history), ever :)\r\n\r\nI'm afraid I'm +1 (currently living in Munich).  But that brought the question of DST (Daylight Saving Time), even if it's inactive right now.\r\n\r\nLooking at https://maven.apache.org/pom.html#developers, I see:\r\n\r\n> **timezone**: A valid time zone ID like `America/New_York` or `Europe/Berlin`, or a numerical offset in hours (and fraction) from UTC where the developer lives, e.g., `-5` or `+1`. Time zone IDs are highly preferred because they are not affected by DST and time zone shifts. […]\r\n\r\nSo: `<timezone>Europe/Berlin</timezone>`?"", 'commenter': 'ztzg'}, {'comment': 'Got it. Haha, I like this rigorous expression:)', 'commenter': 'maoling'}, {'comment': ':)', 'commenter': 'ztzg'}]"
1589,zookeeper-contrib/zookeeper-contrib-zooinspector/src/main/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java,"@@ -872,4 +881,26 @@ public Properties getLastConnectionProps() {
     public void setLastConnectionProps(Properties connectionProps) {
         this.lastConnectionProps = connectionProps;
     }
+
+    private static BufferedReader GetReaderForFile(File file) {","[{'comment': 'please use Java convention `getReaderForFile`', 'commenter': 'eolivelli'}, {'comment': 'Thanks for catching that.  My apologies.', 'commenter': 'brentwritescode'}]"
1589,zookeeper-contrib/zookeeper-contrib-zooinspector/src/main/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java,"@@ -713,55 +723,54 @@ public void stop() {
     public List<String> loadNodeViewersFile(File selectedFile)
             throws IOException {
         List<String> result = new ArrayList<String>();
-        if (defaultNodeViewersFile.exists()) {
-            FileReader reader = new FileReader(selectedFile);
-            try {
-                BufferedReader buff = new BufferedReader(reader);
-                try {
-                    while (buff.ready()) {
-                        String line = buff.readLine();
-                        if (line != null && line.length() > 0 && !line.startsWith(""#"")) {
-                            result.add(line);
-                        }
-                    }
-                } finally {
-                    buff.close();
+        BufferedReader reader = null;
+        try {
+            reader = GetReaderForFile(selectedFile);
+            if(reader == null) {
+                return result;
+            }
+
+            while (reader.ready()) {","[{'comment': 'usually you read from the `BufferedReader` until it returns a `null` line\r\n\r\n```\r\nString line = reader.readLine();\r\nwhile (line != null) {\r\n....\r\nline = reader.readLine();\r\n\r\n}\r\n```', 'commenter': 'eolivelli'}, {'comment': ""Nice catch.  Looks like that was a subtle bug in the original implementation.  It does do the null check for `readLine`, but it does it inside the loop where it does the `ready()` check.  Seems like the `ready()` check is unnecessary.  I'll remove it."", 'commenter': 'brentwritescode'}]"
1602,zookeeper-client/zookeeper-client-c/src/zookeeper.c,"@@ -3691,6 +3691,21 @@ static int Request_path_watch_init(zhandle_t *zh, int mode,
 /*---------------------------------------------------------------------------*
  * ASYNC API
  *---------------------------------------------------------------------------*/
+#define nonblocking_send(zh, rc) _nonblocking_send(zh, rc, __LINE__)
+static int _nonblocking_send(zhandle_t *zh, int rc, int line)
+{
+    if (rc < 0) {
+	rc = ZMARSHALLINGERROR;
+    } else {
+	rc = adaptor_send_queue(zh, 0);
+	if (rc < 0) {
+	    rc = handle_socket_error_msg(zh, line, rc, ""Socket error during nonblocking send"");","[{'comment': 'Passing an accurate `line` is nice, but I now realize that `handle_socket_error_msg` generates log lines such as `ZOO_ERROR@handle_socket_error_msg@1234` (I.e., correct line, wrong function).\r\n\r\n(Just a remark, not asking you to fix it in this PR.  Noted for later.)\r\n', 'commenter': 'ztzg'}, {'comment': 'I added a commit that addresses this, but it is incidental to the problem of connection loss, so it may be better to put that in a different PR.  Please advise.', 'commenter': 'smikes'}]"
1602,zookeeper-client/zookeeper-client-c/src/zookeeper.c,"@@ -3730,8 +3745,9 @@ int zoo_awget(zhandle_t *zh, const char *path,
 
     LOG_DEBUG(LOGCALLBACK(zh), ""Sending request xid=%#x for path [%s] to %s"",h.xid,path,
             zoo_get_current_server(zh));
+
     /* make a best (non-blocking) effort to send the requests asap */
-    adaptor_send_queue(zh, 0);
+    return nonblocking_send(zh, rc);
     return (rc < 0)?ZMARSHALLINGERROR:ZOK;","[{'comment': 'Leftover `return` statement.', 'commenter': 'ztzg'}, {'comment': 'Fixed, see new commits.', 'commenter': 'smikes'}]"
1602,zookeeper-client/zookeeper-client-c/src/zookeeper.c,"@@ -3961,6 +3961,23 @@ static int Request_path_watch_init(zhandle_t *zh, int mode,
 /*---------------------------------------------------------------------------*
  * ASYNC API
  *---------------------------------------------------------------------------*/
+#define nonblocking_send(zh, rc) _nonblocking_send(zh, rc, __LINE__)
+static int _nonblocking_send(zhandle_t *zh, int rc, int line)","[{'comment': 'this parameter `line ` is not used, why should we declare it ?', 'commenter': 'eolivelli'}, {'comment': 'Thanks for pointing this out.  Formerly this was used because the function called handle_socket_error_msg() on error.  Since this is no longer called, we can omit the macro and the argument.  Updated PR , force-pushed amended version f0539f292', 'commenter': 'smikes'}]"
1602,zookeeper-client/zookeeper-client-c/src/zookeeper.c,"@@ -3961,6 +3961,22 @@ static int Request_path_watch_init(zhandle_t *zh, int mode,
 /*---------------------------------------------------------------------------*
  * ASYNC API
  *---------------------------------------------------------------------------*/
+static int nonblocking_send(zhandle_t *zh, int rc)
+{
+    if (rc < 0) {
+        rc = ZMARSHALLINGERROR;
+    } else {
+        rc = adaptor_send_queue(zh, 0);","[{'comment': '(sorry I have one last question, I could have noticed it before).\r\n\r\nin the previous version of this code we were basically always calling `adaptor_send_queue`, now in case of previous error (rc < 0) we are not calling that function anymore.\r\n\r\ncan this have a behavioural impact ?', 'commenter': 'eolivelli'}, {'comment': 'Thanks, this is a good question.  I have reorganized the code to minimize the change; now adaptor_send_queue() will always be called.\r\n\r\nIf an error is returned from adaptor_send_queue(), check if we are in a connected state (`is_connected`) and only then, close the socket and set state to `ZOO_NOTCONNECTED_STATE`.\r\n\r\nAlso: removed the replicated comment and collapsed the ZMARSHALLINGERROR check in `aremove_watches`.', 'commenter': 'smikes'}]"
1602,zookeeper-client/zookeeper-client-c/src/zookeeper.c,"@@ -3961,6 +3961,19 @@ static int Request_path_watch_init(zhandle_t *zh, int mode,
 /*---------------------------------------------------------------------------*
  * ASYNC API
  *---------------------------------------------------------------------------*/
+
+/* make an attempt to send queued requests immediately without blocking */
+static int nonblocking_send(zhandle_t *zh, int rc)
+{
+    if (adaptor_send_queue(zh, 0) < 0) {
+        if (is_connected(zh)) {
+            close_zsock(zh->fd);
+            zh->state = ZOO_NOTCONNECTED_STATE;
+        }
+    }
+    return (rc < 0) ? ZMARSHALLINGERROR : ZOK;","[{'comment': ""@eolivelli wrote:\r\n\r\n> in the previous version of this code we were basically always calling `adaptor_send_queue`, now in case of previous error (rc < 0) we are not calling that function anymore.\r\n> \r\n> can this have a behavioural impact ?\r\n\r\nGood point, indeed.  I don't think we have a way to be sure, so I prefer this version.\r\n\r\nNow… sorry to be annoying, but:\r\n\r\nI'm not sure I like the `is_connected(zh)` condition.  You previously had `zh->fd->sock != -1` here, which seems to make more sense—as the client might *not* be connected when this function is called.  (That can happen, e.g., if the client is in the middle of a `prime_connection` or a SASL authentication sequence. Aplications do not always wait for a connection notification before they start issuing requests.)\r\n\r\nWDYT?\r\n\r\n(This would also align the test & logic with `destroy` and `update_addrs`.)"", 'commenter': 'ztzg'}, {'comment': 'Sounds reasonable.  Will return to using `zh->fd != -1` as the guard for calling `close_zsock()` ; new version 037a4f884 is pushed.', 'commenter': 'smikes'}]"
1620,zookeeper-contrib/zookeeper-contrib-rest/src/main/java/org/apache/zookeeper/server/jersey/RestMain.java,"@@ -53,7 +53,7 @@ public void start() throws IOException {
        System.out.println(""Starting grizzly ..."");
 
        boolean useSSL = cfg.useSSL();
-       gws = new GrizzlyWebServer(cfg.getPort(), ""/tmp/23cxv45345/2131xc2/"", useSSL);
+       gws = new GrizzlyWebServer(cfg.getPort(), System.getProperty(""java.io.tmpdir"",""/tmp"") + ""/23cxv45345/2131xc2/"", useSSL);","[{'comment': 'Can we use this utility function ?\r\nhttps://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#createTempDirectory%28java.nio.file.Path,%20java.lang.String,%20java.nio.file.attribute.FileAttribute...%29', 'commenter': 'eolivelli'}, {'comment': 'web resource path has to be a static path. createTempDirectory will make it dynamic which will break the functionality', 'commenter': 'MuktiKrishnan'}, {'comment': 'yes, seems functionality will change if directory is created dynamically. How someone will put web resources in that dynamically created directory. So lets not use createTempDirectory.\r\n\r\nWhat you say @eolivelli ', 'commenter': 'arshadmohammad'}, {'comment': ""Then I don't understand why we want to use tmpdir. It contains ephemeral files, that won't be present at the next execution of the program. \n\nI thought we just had to set some existing directory, without any particular meaning"", 'commenter': 'eolivelli'}, {'comment': ""` It contains ephemeral files, that won't be present at the next execution of the program.`\r\nMakes sense to use dynamically created files\r\n"", 'commenter': 'arshadmohammad'}, {'comment': ""Sp why can't we use the official method to create an unique temporary directory?"", 'commenter': 'eolivelli'}, {'comment': 'it can be used. ', 'commenter': 'arshadmohammad'}, {'comment': ""so I believe it is better to use `createTempDirectory`\r\nthe '/23cxv45345/2131xc2/' suffix is useless\r\n"", 'commenter': 'eolivelli'}]"
1644,zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerMetrics.java,"@@ -259,6 +260,8 @@ private ServerMetrics(MetricsProvider metricsProvider) {
         WATCH_BYTES = metricsContext.getCounter(""watch_bytes"");
 
         JVM_PAUSE_TIME = metricsContext.getSummary(""jvm_pause_time_ms"", DetailLevel.ADVANCED);
+
+        QUOTA_EXCEEDED_ERROR_PER_NAMESPACE = metricsContext.getSummarySet(QuotaMetricsUtils.QUOTA_EXCEEDED_ERROR_PER_NAMESPACE, DetailLevel.BASIC);","[{'comment': 'I suppose you used a `SummarySet` because we are missing a `CounterSet`, but this generates strange results with default endpoint as well as the Prometheus one. `cnt` and `sum` are effectively duplicate, whereas `min`, `max`, `avg` are just nonsensical:\r\n\r\n```\r\nzk_avg_ZOOKEEPER-4211_quota_exceeded_error_per_namespace\t1.0\r\nzk_min_ZOOKEEPER-4211_quota_exceeded_error_per_namespace\t1\r\nzk_max_ZOOKEEPER-4211_quota_exceeded_error_per_namespace\t1\r\nzk_cnt_ZOOKEEPER-4211_quota_exceeded_error_per_namespace\t5\r\nzk_sum_ZOOKEEPER-4211_quota_exceeded_error_per_namespace\t5\r\n```\r\n', 'commenter': 'ztzg'}, {'comment': 'SummarySet is used because it provides count (i.e. cnt) and the grouping capability.  Yes, you are right, in this case, since the count is always added by 1, the cnt and sum are the same with PrometheusMetricsProvider and the min/max/avg with DefaultMetricsProvider are always 1 in this case.  User can just use the cnt and ignore the others.\r\n\r\nIs any reason that CounterSet not supported? Do you think we need to add CounterSet in this PR?\r\n\r\nI added GaugeSet for other quota metrics, as SummarySet really can not be used for them. For \r\n\r\n\r\n', 'commenter': 'li4wang'}, {'comment': 'Added `CounterSet` and used it for `QUOTA_EXCEEDED_ERROR_PER_NAMESPACE` ', 'commenter': 'li4wang'}, {'comment': 'Okay!', 'commenter': 'ztzg'}]"
1644,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/QuotaMetricsUtils.java,"@@ -0,0 +1,158 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import org.apache.zookeeper.Quotas;
+import org.apache.zookeeper.StatsTrack;
+import org.apache.zookeeper.common.PathUtils;
+import org.apache.zookeeper.server.DataNode;
+import org.apache.zookeeper.server.DataTree;
+
+public final class QuotaMetricsUtils {
+    public static final String QUOTA_COUNT_LIMIT_PER_NAMESPACE = ""quota_count_limit_per_namespace"";
+    public static final String QUOTA_BYTES_LIMIT_PER_NAMESPACE = ""quota_bytes_limit_per_namespace"";
+    public static final String QUOTA_COUNT_USAGE_PER_NAMESPACE = ""quota_count_usage_per_namespace"";
+    public static final String QUOTA_BYTES_USAGE_PER_NAMESPACE = ""quota_bytes_usage_per_namespace"";
+    public static final String QUOTA_EXCEEDED_ERROR_PER_NAMESPACE = ""quota_exceeded_error_per_namespace"";
+
+    enum QUOTA_LIMIT_USAGE_METRIC_TYPE {QUOTA_COUNT_LIMIT, QUOTA_BYTES_LIMIT, QUOTA_COUNT_USAGE, QUOTA_BYTES_USAGE}
+    static final String LIMIT_END_STRING = ""/"" + Quotas.limitNode;
+    static final String STATS_END_STRING = ""/"" + Quotas.statNode;
+
+    private QuotaMetricsUtils() {
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota count limit
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota count limit as the value
+     *
+     */
+    public static Map<String, Number> getQuotaCountLimit(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_LIMIT);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota bytes limit
+     *`
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota bytes limit as the value
+     *
+     */
+    public static Map<String, Number> getQuotaBytesLimit(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_LIMIT);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota count usage
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota count usage as the value
+     *
+     */
+    public static Map<String, Number> getQuotaCountUsage(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_USAGE);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota bytes usage
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return  a map with top namespace as the key and quota bytes usage as the value
+     *
+     */
+    public static Map<String, Number> getQuotaBytesUsage(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_USAGE);
+    }
+
+    // traverse the quota subtree and read the quota limit or usage data
+    private static Map<String, Number> getQuotaLimitOrUsage(final DataTree dataTree,
+                                                            final QUOTA_LIMIT_USAGE_METRIC_TYPE type) {
+        final Map<String, Number> metricsMap = new ConcurrentHashMap<>();
+        if (dataTree != null) {
+            getQuotaLimitOrUsage(Quotas.quotaZookeeper, metricsMap, type, dataTree);
+        }
+        return metricsMap;
+    }
+
+    static void getQuotaLimitOrUsage(final String path,
+                                     final Map<String, Number> metricsMap,
+                                     final QUOTA_LIMIT_USAGE_METRIC_TYPE type,
+                                     final DataTree dataTree) {
+        final DataNode node = dataTree.getNode(path);
+        if (node == null) {
+            return;
+        }
+        final Set<String> children = node.getChildren();
+        if (children.isEmpty()) {
+            if (shouldCollect(path, type)) {
+                collectQuotaLimitOrUsage(path, node, metricsMap, type);
+            }
+            return;
+        }
+        for (final String child : children) {
+            getQuotaLimitOrUsage(path + ""/"" + child, metricsMap, type, dataTree);
+        }","[{'comment': 'I believe this is illegal: the `Set<String>` returned by `DataNode.getChildren()` is not synchronized, and other ZooKeeper operations could be adding or removing nodes while you are iterating on it.  You need something like:\r\n\r\n```java\r\nsynchronized(node) {\r\n    children = new ArrayList<>(node.getChildren())\r\n}\r\n```\r\n\r\n@eolivelli: do you agree, or am I missing something?', 'commenter': 'ztzg'}, {'comment': 'I thought about it as I saw the synchronized block is used when  DataNode.getChildren() is called in some other places, but I don\'t think synchronized is needed here because the getChildren() API is already synchronized on the DataNode instance object and it returns an UnmodifiableSet. \r\n\r\n`public synchronized Set<String> getChildren() {\r\n        if (children == null) {\r\n            return EMPTY_SET;\r\n        }\r\n\r\n        return Collections.unmodifiableSet(children);\r\n    }\r\n`\r\nWith UnmodifiableSet, the underneath ""children"" set can still be modified by other ZK operations while I am iterating on it, but I think this should be okay, as we are just reading not mutating data, so there is no race condition on write.  \r\n\r\nMetrics data is a snapshot. While iterating on it, nodes could be added or removed. If nodes are deleted, it is okay as both collectQuotaLimitOrUsage() API and getQuotaLimitOrUsage() API check whether a node exists or not before processing it.  If nodes are added, it is okay too because the updates will be reflected when the MetricsProvider collects data next time.\r\n\r\nWhat do you think?\r\n\r\n\r\n', 'commenter': 'li4wang'}, {'comment': 'Thank you for your updated PR. Still on my list of things to review! But regarding this point:\r\n\r\n> I thought about it as I saw the synchronized block is used when DataNode.getChildren() is called in some other places, but I don\\\'t think synchronized is needed here because the getChildren() API is already synchronized on the DataNode instance object and it returns an UnmodifiableSet.\r\n\r\nYes, `getChildren()` is synchronized. And the `EMPTY_SET` case is totally fine as that set is indeed immutable.\r\n\r\nThe problem is with `Collections.unmodifiableSet()`. This function creates a wrapper preventing **external** modifications to the set, but still delegates all of the allowed operations to the original object.\r\n\r\nIt **does not** provide a way of make the *inner* collection immutable nor synchronized (it has no way of doing that) and it does **not** lock the object when accessing it (a design decision).\r\n\r\nAs you mention:\r\n\r\n> With UnmodifiableSet, the underneath \\""children\\"" set can still be modified by other ZK operations while I am iterating on it, but I think this should be okay, as we are just reading not mutating data, so there is no race condition on write.\r\n\r\nYes, `DataTree` may very well continue modifying the (locked) object via `addChildren()`, and the code above does not honor that lock. `DataNode` is backed a `HashSet`, whose documentation clearly says:\r\n\r\n> **Note that this implementation is not synchronized.** If multiple threads access a hash set concurrently, and at least one of the threads modifies the set, it *must* be synchronized externally.\r\n\r\n<https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html>\r\n\r\nSo I still believe that code breaks its contract with the JDK.\r\n\r\n> Metrics data is a snapshot. While iterating on it, nodes could be added or removed. If nodes are deleted, it is okay as both collectQuotaLimitOrUsage() API and getQuotaLimitOrUsage() API check whether a node exists or not before processing it. If nodes are added, it is okay too because the updates will be reflected when the MetricsProvider collects data next time.\r\n\r\nRight: I agree that there is currently no way of atomically summing over the tree, and that it is not necessary from the metrics collection point of view.\r\n\r\nBut this is not where my objection lies. The JDK threading model and collection contracts are not honored, which will result---at best!---in seemingly random `ConcurrentModificationException` log messages.', 'commenter': 'ztzg'}, {'comment': 'Good point from the JDK threading model point of view. Let me add code to honor it to avoid the ConcurrentModificationException.', 'commenter': 'li4wang'}, {'comment': 'changed.', 'commenter': 'li4wang'}, {'comment': 'Okay!', 'commenter': 'ztzg'}]"
1644,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/QuotaMetricsUtils.java,"@@ -0,0 +1,158 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import org.apache.zookeeper.Quotas;
+import org.apache.zookeeper.StatsTrack;
+import org.apache.zookeeper.common.PathUtils;
+import org.apache.zookeeper.server.DataNode;
+import org.apache.zookeeper.server.DataTree;
+
+public final class QuotaMetricsUtils {
+    public static final String QUOTA_COUNT_LIMIT_PER_NAMESPACE = ""quota_count_limit_per_namespace"";
+    public static final String QUOTA_BYTES_LIMIT_PER_NAMESPACE = ""quota_bytes_limit_per_namespace"";
+    public static final String QUOTA_COUNT_USAGE_PER_NAMESPACE = ""quota_count_usage_per_namespace"";
+    public static final String QUOTA_BYTES_USAGE_PER_NAMESPACE = ""quota_bytes_usage_per_namespace"";
+    public static final String QUOTA_EXCEEDED_ERROR_PER_NAMESPACE = ""quota_exceeded_error_per_namespace"";
+
+    enum QUOTA_LIMIT_USAGE_METRIC_TYPE {QUOTA_COUNT_LIMIT, QUOTA_BYTES_LIMIT, QUOTA_COUNT_USAGE, QUOTA_BYTES_USAGE}
+    static final String LIMIT_END_STRING = ""/"" + Quotas.limitNode;
+    static final String STATS_END_STRING = ""/"" + Quotas.statNode;
+
+    private QuotaMetricsUtils() {
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota count limit
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota count limit as the value
+     *
+     */
+    public static Map<String, Number> getQuotaCountLimit(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_LIMIT);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota bytes limit
+     *`
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota bytes limit as the value
+     *
+     */
+    public static Map<String, Number> getQuotaBytesLimit(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_LIMIT);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota count usage
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota count usage as the value
+     *
+     */
+    public static Map<String, Number> getQuotaCountUsage(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_USAGE);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota bytes usage
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return  a map with top namespace as the key and quota bytes usage as the value
+     *
+     */
+    public static Map<String, Number> getQuotaBytesUsage(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_USAGE);
+    }
+
+    // traverse the quota subtree and read the quota limit or usage data
+    private static Map<String, Number> getQuotaLimitOrUsage(final DataTree dataTree,
+                                                            final QUOTA_LIMIT_USAGE_METRIC_TYPE type) {
+        final Map<String, Number> metricsMap = new ConcurrentHashMap<>();
+        if (dataTree != null) {
+            getQuotaLimitOrUsage(Quotas.quotaZookeeper, metricsMap, type, dataTree);
+        }
+        return metricsMap;
+    }
+
+    static void getQuotaLimitOrUsage(final String path,
+                                     final Map<String, Number> metricsMap,
+                                     final QUOTA_LIMIT_USAGE_METRIC_TYPE type,
+                                     final DataTree dataTree) {
+        final DataNode node = dataTree.getNode(path);
+        if (node == null) {
+            return;
+        }
+        final Set<String> children = node.getChildren();
+        if (children.isEmpty()) {
+            if (shouldCollect(path, type)) {
+                collectQuotaLimitOrUsage(path, node, metricsMap, type);
+            }
+            return;
+        }
+        for (final String child : children) {
+            getQuotaLimitOrUsage(path + ""/"" + child, metricsMap, type, dataTree);
+        }
+    }
+
+    static boolean shouldCollect(final String path, final QUOTA_LIMIT_USAGE_METRIC_TYPE type) {
+        return path.endsWith(LIMIT_END_STRING)
+                && (QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_LIMIT == type || QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_LIMIT == type)
+                || path.endsWith(STATS_END_STRING)
+                && (QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_USAGE == type || QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_USAGE == type);
+    }
+
+    static void collectQuotaLimitOrUsage(final String path,
+                                         final DataNode node,
+                                         final Map<String, Number> metricsMap,
+                                         final QUOTA_LIMIT_USAGE_METRIC_TYPE type) {
+        final String namespace = PathUtils.getTopNamespace(Quotas.trimQuotaPath(path));
+        if (namespace == null) {
+            return;
+        }
+        if (node.getData() == null) {
+            return;
+        }
+        final StatsTrack statsTrack = new StatsTrack(node.getData());","[{'comment': 'I believe you want this:\r\n\r\n```java\r\nfinal byte[] data = node.getData();\r\nif (data == null) { ... }\r\n...\r\n// use data\r\n```\r\n\r\nas unless I am missing something, the second call to `getData()` could return `null` even if the first did not.', 'commenter': 'ztzg'}, {'comment': ""yes, you are right. It's better this way. I will change it."", 'commenter': 'li4wang'}, {'comment': 'changed', 'commenter': 'li4wang'}]"
1644,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/QuotaMetricsUtils.java,"@@ -0,0 +1,158 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import org.apache.zookeeper.Quotas;
+import org.apache.zookeeper.StatsTrack;
+import org.apache.zookeeper.common.PathUtils;
+import org.apache.zookeeper.server.DataNode;
+import org.apache.zookeeper.server.DataTree;
+
+public final class QuotaMetricsUtils {
+    public static final String QUOTA_COUNT_LIMIT_PER_NAMESPACE = ""quota_count_limit_per_namespace"";
+    public static final String QUOTA_BYTES_LIMIT_PER_NAMESPACE = ""quota_bytes_limit_per_namespace"";
+    public static final String QUOTA_COUNT_USAGE_PER_NAMESPACE = ""quota_count_usage_per_namespace"";
+    public static final String QUOTA_BYTES_USAGE_PER_NAMESPACE = ""quota_bytes_usage_per_namespace"";
+    public static final String QUOTA_EXCEEDED_ERROR_PER_NAMESPACE = ""quota_exceeded_error_per_namespace"";
+
+    enum QUOTA_LIMIT_USAGE_METRIC_TYPE {QUOTA_COUNT_LIMIT, QUOTA_BYTES_LIMIT, QUOTA_COUNT_USAGE, QUOTA_BYTES_USAGE}
+    static final String LIMIT_END_STRING = ""/"" + Quotas.limitNode;
+    static final String STATS_END_STRING = ""/"" + Quotas.statNode;
+
+    private QuotaMetricsUtils() {
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota count limit
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota count limit as the value
+     *
+     */
+    public static Map<String, Number> getQuotaCountLimit(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_LIMIT);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota bytes limit
+     *`
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota bytes limit as the value
+     *
+     */
+    public static Map<String, Number> getQuotaBytesLimit(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_LIMIT);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota count usage
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota count usage as the value
+     *
+     */
+    public static Map<String, Number> getQuotaCountUsage(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_USAGE);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota bytes usage
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return  a map with top namespace as the key and quota bytes usage as the value
+     *
+     */
+    public static Map<String, Number> getQuotaBytesUsage(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_USAGE);
+    }
+
+    // traverse the quota subtree and read the quota limit or usage data
+    private static Map<String, Number> getQuotaLimitOrUsage(final DataTree dataTree,
+                                                            final QUOTA_LIMIT_USAGE_METRIC_TYPE type) {
+        final Map<String, Number> metricsMap = new ConcurrentHashMap<>();
+        if (dataTree != null) {
+            getQuotaLimitOrUsage(Quotas.quotaZookeeper, metricsMap, type, dataTree);
+        }
+        return metricsMap;
+    }
+
+    static void getQuotaLimitOrUsage(final String path,
+                                     final Map<String, Number> metricsMap,
+                                     final QUOTA_LIMIT_USAGE_METRIC_TYPE type,
+                                     final DataTree dataTree) {
+        final DataNode node = dataTree.getNode(path);
+        if (node == null) {
+            return;
+        }
+        final Set<String> children = node.getChildren();
+        if (children.isEmpty()) {
+            if (shouldCollect(path, type)) {
+                collectQuotaLimitOrUsage(path, node, metricsMap, type);
+            }
+            return;
+        }
+        for (final String child : children) {
+            getQuotaLimitOrUsage(path + ""/"" + child, metricsMap, type, dataTree);
+        }
+    }
+
+    static boolean shouldCollect(final String path, final QUOTA_LIMIT_USAGE_METRIC_TYPE type) {
+        return path.endsWith(LIMIT_END_STRING)
+                && (QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_LIMIT == type || QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_LIMIT == type)
+                || path.endsWith(STATS_END_STRING)
+                && (QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_USAGE == type || QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_USAGE == type);
+    }
+
+    static void collectQuotaLimitOrUsage(final String path,
+                                         final DataNode node,
+                                         final Map<String, Number> metricsMap,
+                                         final QUOTA_LIMIT_USAGE_METRIC_TYPE type) {
+        final String namespace = PathUtils.getTopNamespace(Quotas.trimQuotaPath(path));
+        if (namespace == null) {
+            return;
+        }
+        if (node.getData() == null) {
+            return;
+        }
+        final StatsTrack statsTrack = new StatsTrack(node.getData());
+        switch (type) {
+            case QUOTA_COUNT_LIMIT:
+                metricsMap.put(namespace, getQuotaLimit(statsTrack.getCountHardLimit(), statsTrack.getCount()));
+                break;
+            case QUOTA_BYTES_LIMIT:
+                metricsMap.put(namespace, getQuotaLimit(statsTrack.getByteHardLimit(), statsTrack.getBytes()));
+                break;
+            case QUOTA_COUNT_USAGE:
+                metricsMap.put(namespace, statsTrack.getCount());
+                break;
+            case QUOTA_BYTES_USAGE:
+                metricsMap.put(namespace, statsTrack.getBytes());
+                break;","[{'comment': 'There is a mismatch, in general, between the notions of quota path (which cover subtrees, potentially deep in the hierarchy) and that of ""top namespace.""  I know you did not introduce the latter, and I understand that splitting just below the root is convenient in most deployments—but that mismatch is bound to rear its ugly head at the most inopportune moments :)\r\n\r\nThe above suffers from it, as:\r\n\r\n```\r\ncreate /ZOOKEEPER-4211\r\ncreate /ZOOKEEPER-4211/a\r\ncreate /ZOOKEEPER-4211/a/b\r\nsetquota -B 32 /ZOOKEEPER-4211/a/b\r\n\r\ncreate /ZOOKEEPER-4211/a/z\r\nsetquota -B 128 /ZOOKEEPER-4211/a/z\r\n\r\nset /ZOOKEEPER-4211/a/b 012345678901234567890123456789\r\n```\r\n\r\ncauses the `/a/z` subtree to ""cover"" `/a/b` and report the wrong results:\r\n\r\n```\r\nquota_bytes_limit_per_namespace{key=""ZOOKEEPER-4211"",} 128.0\r\nquota_bytes_usage_per_namespace{key=""ZOOKEEPER-4211"",} 0.0\r\n```\r\n\r\nI would suggest *summing* the values found in multiple subtrees of a given ""namespace.""', 'commenter': 'ztzg'}, {'comment': 'Yes, good suggestion. In our case, we only set the quota on the top namespace, so no need to sum. But for general use case, we want to do sum. I will change it.', 'commenter': 'li4wang'}, {'comment': 'changed', 'commenter': 'li4wang'}, {'comment': 'Okay!', 'commenter': 'ztzg'}]"
1644,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/QuotaMetricsUtils.java,"@@ -0,0 +1,158 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import org.apache.zookeeper.Quotas;
+import org.apache.zookeeper.StatsTrack;
+import org.apache.zookeeper.common.PathUtils;
+import org.apache.zookeeper.server.DataNode;
+import org.apache.zookeeper.server.DataTree;
+
+public final class QuotaMetricsUtils {
+    public static final String QUOTA_COUNT_LIMIT_PER_NAMESPACE = ""quota_count_limit_per_namespace"";
+    public static final String QUOTA_BYTES_LIMIT_PER_NAMESPACE = ""quota_bytes_limit_per_namespace"";
+    public static final String QUOTA_COUNT_USAGE_PER_NAMESPACE = ""quota_count_usage_per_namespace"";
+    public static final String QUOTA_BYTES_USAGE_PER_NAMESPACE = ""quota_bytes_usage_per_namespace"";
+    public static final String QUOTA_EXCEEDED_ERROR_PER_NAMESPACE = ""quota_exceeded_error_per_namespace"";
+
+    enum QUOTA_LIMIT_USAGE_METRIC_TYPE {QUOTA_COUNT_LIMIT, QUOTA_BYTES_LIMIT, QUOTA_COUNT_USAGE, QUOTA_BYTES_USAGE}
+    static final String LIMIT_END_STRING = ""/"" + Quotas.limitNode;
+    static final String STATS_END_STRING = ""/"" + Quotas.statNode;
+
+    private QuotaMetricsUtils() {
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota count limit
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota count limit as the value
+     *
+     */
+    public static Map<String, Number> getQuotaCountLimit(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_LIMIT);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota bytes limit
+     *`
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota bytes limit as the value
+     *
+     */
+    public static Map<String, Number> getQuotaBytesLimit(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_LIMIT);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota count usage
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota count usage as the value
+     *
+     */
+    public static Map<String, Number> getQuotaCountUsage(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_USAGE);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota bytes usage
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return  a map with top namespace as the key and quota bytes usage as the value
+     *
+     */
+    public static Map<String, Number> getQuotaBytesUsage(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_USAGE);
+    }
+
+    // traverse the quota subtree and read the quota limit or usage data
+    private static Map<String, Number> getQuotaLimitOrUsage(final DataTree dataTree,
+                                                            final QUOTA_LIMIT_USAGE_METRIC_TYPE type) {
+        final Map<String, Number> metricsMap = new ConcurrentHashMap<>();
+        if (dataTree != null) {
+            getQuotaLimitOrUsage(Quotas.quotaZookeeper, metricsMap, type, dataTree);
+        }
+        return metricsMap;
+    }
+
+    static void getQuotaLimitOrUsage(final String path,
+                                     final Map<String, Number> metricsMap,
+                                     final QUOTA_LIMIT_USAGE_METRIC_TYPE type,
+                                     final DataTree dataTree) {
+        final DataNode node = dataTree.getNode(path);
+        if (node == null) {
+            return;
+        }
+        final Set<String> children = node.getChildren();
+        if (children.isEmpty()) {
+            if (shouldCollect(path, type)) {
+                collectQuotaLimitOrUsage(path, node, metricsMap, type);
+            }
+            return;
+        }
+        for (final String child : children) {
+            getQuotaLimitOrUsage(path + ""/"" + child, metricsMap, type, dataTree);
+        }
+    }
+
+    static boolean shouldCollect(final String path, final QUOTA_LIMIT_USAGE_METRIC_TYPE type) {
+        return path.endsWith(LIMIT_END_STRING)
+                && (QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_LIMIT == type || QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_LIMIT == type)
+                || path.endsWith(STATS_END_STRING)
+                && (QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_USAGE == type || QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_USAGE == type);
+    }
+
+    static void collectQuotaLimitOrUsage(final String path,
+                                         final DataNode node,
+                                         final Map<String, Number> metricsMap,
+                                         final QUOTA_LIMIT_USAGE_METRIC_TYPE type) {
+        final String namespace = PathUtils.getTopNamespace(Quotas.trimQuotaPath(path));
+        if (namespace == null) {
+            return;
+        }
+        if (node.getData() == null) {
+            return;
+        }
+        final StatsTrack statsTrack = new StatsTrack(node.getData());
+        switch (type) {
+            case QUOTA_COUNT_LIMIT:
+                metricsMap.put(namespace, getQuotaLimit(statsTrack.getCountHardLimit(), statsTrack.getCount()));
+                break;
+            case QUOTA_BYTES_LIMIT:
+                metricsMap.put(namespace, getQuotaLimit(statsTrack.getByteHardLimit(), statsTrack.getBytes()));
+                break;
+            case QUOTA_COUNT_USAGE:
+                metricsMap.put(namespace, statsTrack.getCount());
+                break;
+            case QUOTA_BYTES_USAGE:
+                metricsMap.put(namespace, statsTrack.getBytes());
+                break;
+            default:
+        }
+    }
+
+    // hard limit takes precedence if specified
+    static long getQuotaLimit(final long hardLimit, final long limit) {
+        return hardLimit > -1 ? hardLimit : limit;
+    }","[{'comment': 'This is another case of policy and mechanism getting mixed up; do we really want to prevent people from monitoring their soft quota errors?', 'commenter': 'ztzg'}, {'comment': 'Hmm, not sure what you meant. This is the limit used for both soft quota errors and hard quota errors.  If hardLimit is specified, then the client will get QuotaExceededException, otherwise it just log as WARN.  \r\n\r\nWe are not preventing people from monitoring  the soft quota errors. In fact, we publish the ""proper"" metric data so they can set up the alerts based on different usage level.  \r\n\r\nThe limit is published in this way because\r\n\r\n1. It matches up with what\'s been used in the checkQuota() logic, so user doesn\'t need to know how the soft limit and hard limit are used internally.  \r\n2. This is the limit used by the server to check quota and this is what they need to monitor and alert on. It can be soft limit or hard limit.\r\n3. In the future if the quota check logic is changed in term of how the soft limit and hard limit are used, we just need to change the server side code. User\'s monitoring and alert rule do not need to be changed.\r\n\r\n', 'commenter': 'li4wang'}, {'comment': 'Sorry---I was indeed too quick (and not very clear to boot).\r\n\r\n> We are not preventing people from monitoring the soft quota errors. In fact, we publish the \\""proper\\"" metric data so they can set up the alerts based on different usage level.\r\n>\r\n> The limit is published in this way because\r\n>\r\n> -   It matches up with what\\\'s been used in the checkQuota() logic, so user doesn\\\'t need to know how the soft limit and hard limit are used internally.\r\n> -   This is the limit used by the server to check quota and this is what they need to monitor and alert on. It can be soft limit or hard limit.\r\n> -   In the future if the quota check logic is changed in term of how the soft limit and hard limit are used, we just need to change the server side code. User\\\'s monitoring and alert rule do not need to be changed.\r\n\r\nYou are right.\r\n\r\nI had in mind that soft/hard quotas had the same semantics as, e.g., disk quotas under Unix---but that is not what is implemented as of today.\r\n\r\n(That being said: it is something I would like to see improved at some point—I believe the current semantics are accidental, and perhaps not as useful as they could be—but my wishes do no make reality.\r\n\r\nIMO, server administrators should be informed when a node is above the soft quota, even if no errors are generated. Similarly, clients should have a way of monitoring the \\""warnings\\"" which are being issued against them.\r\n\r\nSo it seems that published metrics will have to be updated when specifying both a soft and hard limit on a node becomes useful—e.g., by adding `quota_count_soft_limit_per_namespace` and `quota_bytes_soft_limit_per_namespace`—so that dashboards can show both watermarks as actually configured in the quota subsystem.)', 'commenter': 'ztzg'}, {'comment': ""Yes, if we change the semantics of soft and hard quotas in the future, we will update the the published metrics along with the changes.  Changing the semantics is a fundamental thing, so it makes sense to make all the changes that are impacted at that time.\r\n\r\nThere are two concerns for publishing both soft and hard limit at this point.\r\n\r\n1. It doesn't match with the current semantics of soft and hard quotas and make it harder for user t o use the metrics. \r\n2. Given the constraint we have with the current interface of metrics framework, it means the we need to iterate two more times on the /zookeeper/quota tree. IMO, we pay something up-to-front that doesn't give us too much benefits.\r\n"", 'commenter': 'li4wang'}, {'comment': 'I agree.', 'commenter': 'ztzg'}]"
1644,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/QuotaMetricsUtils.java,"@@ -0,0 +1,158 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import org.apache.zookeeper.Quotas;
+import org.apache.zookeeper.StatsTrack;
+import org.apache.zookeeper.common.PathUtils;
+import org.apache.zookeeper.server.DataNode;
+import org.apache.zookeeper.server.DataTree;
+
+public final class QuotaMetricsUtils {
+    public static final String QUOTA_COUNT_LIMIT_PER_NAMESPACE = ""quota_count_limit_per_namespace"";
+    public static final String QUOTA_BYTES_LIMIT_PER_NAMESPACE = ""quota_bytes_limit_per_namespace"";
+    public static final String QUOTA_COUNT_USAGE_PER_NAMESPACE = ""quota_count_usage_per_namespace"";
+    public static final String QUOTA_BYTES_USAGE_PER_NAMESPACE = ""quota_bytes_usage_per_namespace"";
+    public static final String QUOTA_EXCEEDED_ERROR_PER_NAMESPACE = ""quota_exceeded_error_per_namespace"";
+
+    enum QUOTA_LIMIT_USAGE_METRIC_TYPE {QUOTA_COUNT_LIMIT, QUOTA_BYTES_LIMIT, QUOTA_COUNT_USAGE, QUOTA_BYTES_USAGE}
+    static final String LIMIT_END_STRING = ""/"" + Quotas.limitNode;
+    static final String STATS_END_STRING = ""/"" + Quotas.statNode;
+
+    private QuotaMetricsUtils() {
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota count limit
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota count limit as the value
+     *
+     */
+    public static Map<String, Number> getQuotaCountLimit(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_LIMIT);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota bytes limit
+     *`
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota bytes limit as the value
+     *
+     */
+    public static Map<String, Number> getQuotaBytesLimit(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_LIMIT);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota count usage
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota count usage as the value
+     *
+     */
+    public static Map<String, Number> getQuotaCountUsage(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_USAGE);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota bytes usage
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return  a map with top namespace as the key and quota bytes usage as the value
+     *
+     */
+    public static Map<String, Number> getQuotaBytesUsage(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_USAGE);
+    }
+
+    // traverse the quota subtree and read the quota limit or usage data
+    private static Map<String, Number> getQuotaLimitOrUsage(final DataTree dataTree,
+                                                            final QUOTA_LIMIT_USAGE_METRIC_TYPE type) {
+        final Map<String, Number> metricsMap = new ConcurrentHashMap<>();
+        if (dataTree != null) {
+            getQuotaLimitOrUsage(Quotas.quotaZookeeper, metricsMap, type, dataTree);
+        }
+        return metricsMap;
+    }","[{'comment': 'Hmm… I understand that you are constrained by the current interface, but it also means we iterate four times on the `/zookeeper/quota` tree.  It also ""forces"" the implementation to report unset (count or byte) quotas as `-1` instead of just omitting them, as it cannot correlate limits and values without doing an even larger amount of duplicate work.', 'commenter': 'ztzg'}, {'comment': ""Yes, I tried to avoid iterating four times on the /zookeeper/quota tree, but constrained by the current interface. The callback is for each individual gauge. \r\n\r\nThe implementation is not the most optimal due to the above constraint, but I thought it's probably okay considering \r\n\r\n1. All the data stored in the memory and the quota tree should not too big in general (it's just the top namespace level in our use case) \r\n\r\n2) What it impacts is the latency of the metrics endpoint call. It doesn't impact the ZK client operations.\r\n\r\nWhat do you think?"", 'commenter': 'li4wang'}]"
1644,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/QuotaMetricsUtils.java,"@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import org.apache.zookeeper.Quotas;
+import org.apache.zookeeper.StatsTrack;
+import org.apache.zookeeper.common.PathUtils;
+import org.apache.zookeeper.server.DataNode;
+import org.apache.zookeeper.server.DataTree;
+
+public final class QuotaMetricsUtils {
+    public static final String QUOTA_COUNT_LIMIT_PER_NAMESPACE = ""quota_count_limit_per_namespace"";
+    public static final String QUOTA_BYTES_LIMIT_PER_NAMESPACE = ""quota_bytes_limit_per_namespace"";
+    public static final String QUOTA_COUNT_USAGE_PER_NAMESPACE = ""quota_count_usage_per_namespace"";
+    public static final String QUOTA_BYTES_USAGE_PER_NAMESPACE = ""quota_bytes_usage_per_namespace"";
+    public static final String QUOTA_EXCEEDED_ERROR_PER_NAMESPACE = ""quota_exceeded_error_per_namespace"";
+
+    enum QUOTA_LIMIT_USAGE_METRIC_TYPE {QUOTA_COUNT_LIMIT, QUOTA_BYTES_LIMIT, QUOTA_COUNT_USAGE, QUOTA_BYTES_USAGE}
+    static final String LIMIT_END_STRING = ""/"" + Quotas.limitNode;
+    static final String STATS_END_STRING = ""/"" + Quotas.statNode;
+
+    private QuotaMetricsUtils() {
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota count limit
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota count limit as the value
+     *
+     */
+    public static Map<String, Number> getQuotaCountLimit(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_LIMIT);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota bytes limit
+     *`
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota bytes limit as the value
+     *
+     */
+    public static Map<String, Number> getQuotaBytesLimit(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_LIMIT);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota count usage
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return a map with top namespace as the key and quota count usage as the value
+     *
+     */
+    public static Map<String, Number> getQuotaCountUsage(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_COUNT_USAGE);
+    }
+
+    /**
+     * Traverse the quota subtree and return per namespace quota bytes usage
+     *
+     * @param dataTree dataTree that contains the quota limit and usage data
+     * @return  a map with top namespace as the key and quota bytes usage as the value
+     *
+     */
+    public static Map<String, Number> getQuotaBytesUsage(final DataTree dataTree) {
+        return getQuotaLimitOrUsage(dataTree, QUOTA_LIMIT_USAGE_METRIC_TYPE.QUOTA_BYTES_USAGE);
+    }
+
+    // traverse the quota subtree and read the quota limit or usage data
+    private static Map<String, Number> getQuotaLimitOrUsage(final DataTree dataTree,
+                                                            final QUOTA_LIMIT_USAGE_METRIC_TYPE type) {
+        final Map<String, Number> metricsMap = new ConcurrentHashMap<>();
+        if (dataTree != null) {
+            getQuotaLimitOrUsage(Quotas.quotaZookeeper, metricsMap, type, dataTree);
+        }
+        return metricsMap;
+    }
+
+    static void getQuotaLimitOrUsage(final String path,
+                                     final Map<String, Number> metricsMap,
+                                     final QUOTA_LIMIT_USAGE_METRIC_TYPE type,
+                                     final DataTree dataTree) {
+        final DataNode node = dataTree.getNode(path);
+        if (node == null) {
+            return;
+        }
+        final List<String> children;
+        synchronized (node) {
+            children = new ArrayList<>(node.getChildren());
+        }
+        if (children.size() == 0) {
+            if (shouldCollect(path, type)) {
+                collectQuotaLimitOrUsage(path, node, metricsMap, type);","[{'comment': '*THREAD_SAFETY_VIOLATION:*  Unprotected write. Non-private method `QuotaMetricsUtils.getQuotaLimitOrUsage(...)` indirectly mutates container `metricsMap` via call to `Map.put(...)` outside of synchronization.\n Reporting because this access may occur on a background thread.\n(at-me [in a reply](https://docs.muse.dev/docs/talk-to-muse/) with `help` or `ignore`)', 'commenter': 'sonatype-lift[bot]'}, {'comment': ""getQuotaLimitOrUsage () is not a public API. The metricsMap passed is a ConcurrentHashMap and it's thread safe.\r\n\r\nI think this can be ignored."", 'commenter': 'li4wang'}, {'comment': 'Agree.  Nit: is there a reason the 4-argument overload is not `private`?', 'commenter': 'ztzg'}, {'comment': ""Good catch. It should have `private`. I probably planned to add unit test case for this API at that time nd changed the scope to 'package'.  \r\n\r\nAdded `private` back."", 'commenter': 'li4wang'}]"
1644,zookeeper-server/src/test/java/org/apache/zookeeper/test/EnforceQuotaTest.java,"@@ -54,14 +56,16 @@ public void tearDown() throws Exception {
 
     @Test
     public void testSetQuotaDisableWhenExceedBytesHardQuota() throws Exception {
-        final String path = ""/c1"";
+        final String namespace = UUID.randomUUID().toString();","[{'comment': 'Why not `namespace = ""c1""`?  Is there a specific reason to change from a static path to a dynamic/random one?\r\n\r\n(I haven\'t looked into the tests yet, so may be missing something obvious.)', 'commenter': 'ztzg'}, {'comment': 'Yes, the reason is that we added validation on the per-namespace quota exceeded count in the test cases. The namespace need to be dynamic/random to make sure the counter is not interfered by other test cases.\r\n\r\n`ZooKeeperQuotaTest.validateNoQuotaExceededMetrics(namespace);`', 'commenter': 'li4wang'}]"
1652,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/JettyAdminServer.java,"@@ -35,11 +35,7 @@
 import org.eclipse.jetty.http.HttpVersion;
 import org.eclipse.jetty.security.ConstraintMapping;
 import org.eclipse.jetty.security.ConstraintSecurityHandler;
-import org.eclipse.jetty.server.HttpConfiguration;
-import org.eclipse.jetty.server.HttpConnectionFactory;
-import org.eclipse.jetty.server.SecureRequestCustomizer;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.*;","[{'comment': 'Yeah, I see, gonna fix this', 'commenter': 'nkalmar'}]"
1652,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -2025,6 +2025,15 @@ Both subsystems need to have sufficient amount of threads to achieve peak read t
 
 #### AdminServer configuration
 
+**New in 3.7.1:** The following
+options are used to configure the [AdminServer](#sc_adminserver).
+
+* *admin.forceHTTPS* :
+  (Java system property: **zookeeper.admin.disableHTTP**)","[{'comment': 'typo, first I wanted to call it disableHTTP', 'commenter': 'nkalmar'}]"
1652,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/JettyAdminServer.java,"@@ -140,10 +143,16 @@ public JettyAdminServer(
                 sslContextFactory.setTrustStore(trustStore);
                 sslContextFactory.setTrustStorePassword(certAuthPassword);
 
-                connector = new ServerConnector(
-                    server,
-                    new UnifiedConnectionFactory(sslContextFactory, HttpVersion.fromVersion(httpVersion).asString()),
-                    new HttpConnectionFactory(config));
+                if(forceHTTPS) {","[{'comment': 'you have a checkstyle violation here', 'commenter': 'symat'}]"
1652,zookeeper-server/src/test/java/org/apache/zookeeper/server/admin/JettyAdminServerTest.java,"@@ -234,6 +236,35 @@ public void testQuorum() throws Exception {
                 ""waiting for server 2 down"");
     }
 
+    @Test
+    public void testForceHttpsPortUnificationEnabled() throws Exception {
+        testForceHttps(true);
+    }
+
+    @Test
+    public void testForceHttpsPortUnificationDisabled() throws Exception {
+        testForceHttps(false);
+    }
+
+    private void testForceHttps(boolean portUnification) throws Exception {
+        System.setProperty(""zookeeper.admin.forceHTTPS"", ""true"");
+        System.setProperty(""zookeeper.admin.portUnification"", String.valueOf(portUnification));
+        boolean httpsPassed = false;
+
+        JettyAdminServer server = new JettyAdminServer();
+        try {
+            server.start();
+            queryAdminServer(String.format(HTTPS_URL_FORMAT, jettyAdminPort), true);
+            httpsPassed = true;
+            queryAdminServer(String.format(URL_FORMAT, jettyAdminPort), false);","[{'comment': 'I think currently the test will pass always, even if the http call succeeds.\r\n\r\nI think you should add a line here (after the http call), like:\r\n`fail(""http call should have been failed when forceHTTPS=true"");` \r\nto actually assert that the http call fails, the https is enforced and we jumped to the `catch` block.', 'commenter': 'symat'}, {'comment': ""Thanks, true that, I had that fail but got lost after the refactor! Good catch (I even had a spotbugs failure of unused import of Assert.fail, and I didn't realize my mistake, removed the import instead. duh...)"", 'commenter': 'nkalmar'}]"
1664,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java,"@@ -1163,10 +1164,18 @@ private void loadDataBase() {
                 writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);
             }
             if (epochOfZxid > currentEpoch) {
-                throw new IOException(""The current epoch, ""
-                                      + ZxidUtils.zxidToString(currentEpoch)
-                                      + "", is older than the last zxid, ""
-                                      + lastProcessedZxid);
+                // acceptedEpoch.tmp file in snapshot directory
+                File currentTmp = new File(getTxnFactory().getSnapDir(),
+                    CURRENT_EPOCH_FILENAME + AtomicFileOutputStream.TMP_EXTENSION);
+                if (currentTmp.exists()) {
+                    long epochOfTmp = readLongFromFile(currentTmp.getName());","[{'comment': '*PATH_TRAVERSAL_IN:*  This API (java/io/File.<init>(Ljava/io/File;Ljava/lang/String;)V) reads a file whose location might be specified by user input [(details)](https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN)\n(at-me [in a reply](https://docs.muse.dev/docs/talk-to-muse/) with `help` or `ignore`)', 'commenter': 'sonatype-lift[bot]'}, {'comment': 'This is not user input file. It is system generate file so PATH_TRAVERSAL_IN is not applicable', 'commenter': 'arshadmohammad'}]"
1664,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/CurrentEpochWriteFailureTest.java,"@@ -0,0 +1,129 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server.quorum;
+
+import static org.apache.zookeeper.test.ClientBase.CONNECTION_TIMEOUT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.commons.io.FileUtils;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.common.AtomicFileOutputStream;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;","[{'comment': 'This compiles, but causes the test not to run when selected with `-Dtest=CurrentEpochWriteFailureTest`!  (I don\'t know if it runs when the full test suite is active.)\r\n\r\nI believe you want this:\r\n\r\n```diff\r\n--- a/zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/CurrentEpochWriteFailureTest.java\r\n+++ b/zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/CurrentEpochWriteFailureTest.java\r\n@@ -30,9 +30,9 @@\r\n import org.apache.zookeeper.ZooKeeper;\r\n import org.apache.zookeeper.common.AtomicFileOutputStream;\r\n import org.apache.zookeeper.test.ClientBase;\r\n-import org.junit.After;\r\n-import org.junit.Before;\r\n-import org.junit.Test;\r\n+import org.junit.jupiter.api.AfterEach;\r\n+import org.junit.jupiter.api.BeforeEach;\r\n+import org.junit.jupiter.api.Test;\r\n import org.slf4j.Logger;\r\n import org.slf4j.LoggerFactory;\r\n \r\n@@ -42,14 +42,14 @@\r\n     private int clientPort;\r\n     private Map<String, String> additionalProp;\r\n \r\n-    @Before\r\n+    @BeforeEach\r\n     public void setUp() {\r\n         additionalProp = new HashMap<>();\r\n         additionalProp.put(""admin.enableServer"", ""true"");\r\n         additionalProp.put(""4lw.commands.whitelist"", ""*"");\r\n     }\r\n \r\n-    @After\r\n+    @AfterEach\r\n     public void tearDown() throws InterruptedException {\r\n         if (servers != null) {\r\n             servers.shutDownAllServers();\r\n```', 'commenter': 'ztzg'}, {'comment': 'good suggestions, handled it', 'commenter': 'arshadmohammad'}, {'comment': 'After these changes, I run the test class with command ""mvn clean test -Dtest=CurrentEpochWriteFailureTest -DfailIfNoTests=false""\r\nIt run successfully.', 'commenter': 'arshadmohammad'}]"
1664,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/CurrentEpochWriteFailureTest.java,"@@ -0,0 +1,129 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server.quorum;
+
+import static org.apache.zookeeper.test.ClientBase.CONNECTION_TIMEOUT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.commons.io.FileUtils;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.common.AtomicFileOutputStream;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class CurrentEpochWriteFailureTest extends QuorumPeerTestBase {
+    protected static final Logger LOG = LoggerFactory.getLogger(CurrentEpochWriteFailureTest.class);
+    private Servers servers;
+    private int clientPort;
+    private Map<String, String> additionalProp;
+
+    @Before
+    public void setUp() {
+        additionalProp = new HashMap<>();
+        additionalProp.put(""admin.enableServer"", ""true"");
+        additionalProp.put(""4lw.commands.whitelist"", ""*"");","[{'comment': 'I was wondering why these two were necessary—but the test seems to run fine without them.  Did you add them for a specific purpose, or did you simply inherit them?  (Not that I expect them to hurt.)', 'commenter': 'ztzg'}, {'comment': 'admin.enableServer, I intended to set false. \r\nBut I checked these properties are already set in super class ZKTestCase. So not required. removed it', 'commenter': 'arshadmohammad'}]"
1664,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/CurrentEpochWriteFailureTest.java,"@@ -0,0 +1,129 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server.quorum;
+
+import static org.apache.zookeeper.test.ClientBase.CONNECTION_TIMEOUT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.commons.io.FileUtils;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.common.AtomicFileOutputStream;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class CurrentEpochWriteFailureTest extends QuorumPeerTestBase {
+    protected static final Logger LOG = LoggerFactory.getLogger(CurrentEpochWriteFailureTest.class);
+    private Servers servers;
+    private int clientPort;
+    private Map<String, String> additionalProp;
+
+    @Before
+    public void setUp() {
+        additionalProp = new HashMap<>();
+        additionalProp.put(""admin.enableServer"", ""true"");
+        additionalProp.put(""4lw.commands.whitelist"", ""*"");
+    }
+
+    @After
+    public void tearDown() throws InterruptedException {
+        if (servers != null) {
+            servers.shutDownAllServers();
+        }
+    }
+
+    /*
+     * ZOOKEEPER-4269:
+     * accepted epoch is first written to temporary file acceptedEpoch.tmp then this file is
+     * renamed to acceptedEpoch.
+     * Failure, either because of exception or power-off, in renaming the acceptedEpoch.tmp file
+     * will cause server startup error with message ""The current epoch, x, is older than the last
+     * zxid y""
+     * To handle this scenario we should read accepted epoch from this temp file as well.
+     */
+    @Test
+    public void testReadCurrentEpochFromAcceptedEpochTmpFile() throws Exception {
+        startServers(additionalProp);
+        writSomeData();
+
+        restartServers();
+        writSomeData();
+
+        MainThread firstServer = servers.mt[0];
+
+        // As started servers two times, current epoch must be two
+        long currentEpoch = firstServer.getQuorumPeer().getCurrentEpoch();
+        assertEquals(2, currentEpoch);
+
+        // Initialize files for later use
+        File snapDir = firstServer.getQuorumPeer().getTxnFactory().getSnapDir();
+        File currentEpochFile = new File(snapDir, QuorumPeer.CURRENT_EPOCH_FILENAME);
+        File currentEpochTempFile = new File(snapDir,
+            QuorumPeer.CURRENT_EPOCH_FILENAME + AtomicFileOutputStream.TMP_EXTENSION);
+
+        // Shutdown servers
+        servers.shutDownAllServers();
+        waitForAll(servers, ZooKeeper.States.CONNECTING);
+
+        // Create scenario of file currentEpoch.tmp rename to currentEpoch failure.
+        // In this case currentEpoch file will have old epoch and currentEpoch.tmp will have the latest epoch
+        FileUtils.write(currentEpochFile, Long.toString(currentEpoch - 1), ""UTF-8"");
+        FileUtils.write(currentEpochTempFile, Long.toString(currentEpoch), ""UTF-8"");
+
+        // Restart the serves, all serves should restart successfully.
+        servers.restartAllServersAndClients(this);
+
+        // Check the first server where problem was injected.
+        assertTrue(ClientBase
+                .waitForServerUp(""127.0.0.1:"" + firstServer.getClientPort(), CONNECTION_TIMEOUT),
+            ""server "" + firstServer.getMyid()
+                + "" is not up as file currentEpoch.tmp rename to currentEpoch file was failed""
+                + "" which lead current epoch inconsistent state."");
+    }
+
+    private void restartServers() throws InterruptedException, IOException {
+        servers.shutDownAllServers();
+        waitForAll(servers, ZooKeeper.States.CONNECTING);
+        servers.restartAllServersAndClients(this);
+        waitForAll(servers, ZooKeeper.States.CONNECTED);
+    }
+
+    private void writSomeData() throws Exception {","[{'comment': 'Nit: `writeSomeData`?', 'commenter': 'ztzg'}, {'comment': 'Corrected', 'commenter': 'arshadmohammad'}]"
1677,src/main/resources/markdown/releases.md,"@@ -42,18 +42,15 @@ Older releases are available.
 
 [Apache ZooKeeper 3.6.2 Source Release](https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.6.2/apache-zookeeper-3.6.2.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.6.2/apache-zookeeper-3.6.2.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.6.2/apache-zookeeper-3.6.2.tar.gz.sha512))
 
-### Apache ZooKeeper 3.6.1
-
-[Apache ZooKeeper 3.6.1](https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.6.1/apache-zookeeper-3.6.1-bin.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.6.1/apache-zookeeper-3.6.1-bin.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.6.1/apache-zookeeper-3.6.1-bin.tar.gz.sha512))
-
-[Apache ZooKeeper 3.6.1 Source Release](https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.6.1/apache-zookeeper-3.6.1.tar.gz)([asc](https://downloads.apache.org/zookeeper/zookeeper-3.6.1/apache-zookeeper-3.6.1.tar.gz.asc), [sha512](https://downloads.apache.org/zookeeper/zookeeper-3.6.1/apache-zookeeper-3.6.1.tar.gz.sha512))
+### Apache ZooKeeper 3.5.9
 
+ZooKeeper 3.5.9 is only downloadable from the archive as the 3.6 and 3.7 branches are now `stable` and `current`, respectively.","[{'comment': '>> the 3.6 and 3.7 branches are now `stable` and `current`, respectively.\r\n\r\nThis is correct.\r\n\r\nBut in the starting of this file it is written that ""Apache ZooKeeper 3.7.0 is our latest stable release"". is this statement just a carry forward from previous release or there is some thought behind declaring 3.7.0 as stable release\r\n\r\ndo you think ""Apache ZooKeeper 3.7.0 is our latest stable release"" should be changed to ""Apache ZooKeeper 3.7.0 is our current release"" and later based on usage and feedback of 3.7.0 we can change 3.7.x as stable release.\r\n', 'commenter': 'arshadmohammad'}, {'comment': 'Good point.  That sentence was just carried forward when I switched the versions in the release notes, and I certainly agree that it is a bit early to declare 3.7 stable compared to 3.6.  How about the updated patch?  (It implements your suggestion, but I have also moved 3.6 above the separator line.)', 'commenter': 'ztzg'}, {'comment': 'We have currently 3 active branches/release lines:\r\n- 3.5\r\n- 3.6\r\n- 3.7\r\n\r\nI am not sure we should say much here.\r\n\r\nwe just have to give the links to binary/sources for the latest release of 3.5,3.6 and 3.7, so 3.5.9, 3.6.2, 3.7.0\r\n\r\n', 'commenter': 'eolivelli'}, {'comment': 'I am not sure we should delete 3.5.9 from the ""dist"", it is an active release line.\r\nif we want to change this fact we should open a discussion on dev@\r\n\r\nGood catch and good points @ztzg @arshadmohammad ', 'commenter': 'eolivelli'}, {'comment': 'Well, I removed 3.5.9 from the ""dist"" (as per the instructions, not because I have something against it :) when I prepared 3.7.0.  I guess I should restore it in SVN, which will in turn cause it to be mirrored again?', 'commenter': 'ztzg'}]"
1682,zookeeper-metrics-providers/zookeeper-prometheus-metrics/src/test/java/org/apache/zookeeper/metrics/prometheus/PrometheusMetricsProviderTest.java,"@@ -57,7 +62,7 @@ public void setup() throws Exception {
         provider = new PrometheusMetricsProvider();
         Properties configuration = new Properties();
         configuration.setProperty(""httpHost"", ""127.0.0.1""); // local host for test
-        configuration.setProperty(""httpPort"", ""0""); // ephemeral port
+        configuration.setProperty(""httpPort"", String.valueOf(METRICS_PORT));","[{'comment': 'it is better to have an ephemeral port, \r\notherwise it is easy to break the execution of the test on an env in which port 7000 is already bound and also it prevents running concurrent tests', 'commenter': 'eolivelli'}, {'comment': 'I have modified the test so that it uses an ephemeral port.', 'commenter': 'doxsch'}]"
1698,zookeeper-metrics-providers/zookeeper-prometheus-metrics/src/main/java/org/apache/zookeeper/metrics/prometheus/PrometheusMetricsProvider.java,"@@ -70,6 +99,11 @@
     private Server server;
     private final MetricsServletImpl servlet = new MetricsServletImpl();
     private final Context rootContext = new Context();
+    private final int numWorkerThreads = Integer.getInteger(ZOOKEEPER_PROMETHEUS_NUM_WORKER_THREADS,","[{'comment': 'we should read these configuration parameters in the ""configure"" method\r\nthis way we are not depending on system properties\r\n', 'commenter': 'eolivelli'}, {'comment': 'I see. I will make the change so they will be read from configuration file just the other properties such as `httpHost`\r\n\r\nWe also need to document them in the zookeeperAdmin.md, right?', 'commenter': 'li4wang'}]"
1714,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -253,7 +253,7 @@ public static void setCloseSessionTxnEnabled(boolean enabled) {
         intBufferStartingSizeBytes = Integer.getInteger(INT_BUFFER_STARTING_SIZE_BYTES, DEFAULT_STARTING_BUFFER_SIZE);
 
         if (intBufferStartingSizeBytes < 32) {
-            String msg = ""Buffer starting size must be greater than or equal to 32.""
+            String msg = ""Buffer starting size ("" + intBufferStartingSizeBytes + "") must be greater than or equal to 32.""
                          + ""Configure with \""-Dzookeeper.intBufferStartingSizeBytes=<size>\"" "";","[{'comment': 'Nit: Need a space between ""32."" and ""Configure"".  Current prints: ""32.Configure""', 'commenter': 'belugabehr'}, {'comment': 'Fixed the space between ""32"" and ""Configure"".', 'commenter': 'rpinzon'}]"
1721,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooTrace.java,"@@ -33,8 +33,6 @@
 
     public static final long CLIENT_REQUEST_TRACE_MASK = 1 << 1;
 
-    public static final long CLIENT_DATA_PACKET_TRACE_MASK = 1 << 2;","[{'comment': 'it is better to keep this constant here.\r\nwe can add a comment and say that this is obsolete\r\n\r\nthe same applies to `JMX_TRACE_MASK`', 'commenter': 'eolivelli'}, {'comment': 'get', 'commenter': 'zhongxiongzeng'}]"
1724,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/QuorumSSLTest.java,"@@ -224,12 +228,24 @@ public OCSPHandler(X509Certificate revokedCert) {
         public void handle(com.sun.net.httpserver.HttpExchange httpExchange) throws IOException {
             byte[] responseBytes;
             try {
+                String uri = httpExchange.getRequestURI().toString();
+                LOG.info(""OCSP request: {} {} {}"", httpExchange.getRequestMethod(), uri, httpExchange.getRequestHeaders().entrySet());
+                httpExchange.getRequestHeaders().entrySet().forEach((e) -> {
+                    LOG.info(""OCSP request header: {} {}"", e.getKey(), e.getValue());
+                });","[{'comment': 'This logs each header twice: once at the end of the `OCSP request: ` line, in ""compressed form,"" and once per line in the rest.  We could perhaps drop the third format argument from the first line?', 'commenter': 'ztzg'}]"
1724,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/QuorumSSLTest.java,"@@ -224,12 +228,24 @@ public OCSPHandler(X509Certificate revokedCert) {
         public void handle(com.sun.net.httpserver.HttpExchange httpExchange) throws IOException {
             byte[] responseBytes;
             try {
+                String uri = httpExchange.getRequestURI().toString();
+                LOG.info(""OCSP request: {} {} {}"", httpExchange.getRequestMethod(), uri, httpExchange.getRequestHeaders().entrySet());
+                httpExchange.getRequestHeaders().entrySet().forEach((e) -> {
+                    LOG.info(""OCSP request header: {} {}"", e.getKey(), e.getValue());
+                });
                 InputStream request = httpExchange.getRequestBody();
                 byte[] requestBytes = new byte[10000];
-                request.read(requestBytes);
+                int len = request.read(requestBytes);
+                LOG.info(""OCSP request size {}: {}"", len, new String(requestBytes, StandardCharsets.UTF_8));","[{'comment': 'This dumps 10000 bytes of binary data in the log.  (Up to 10000 NUL bytes, if `len` is -1.)  May I suggest dropping the second format argument, as it is unreadable even when the OCSP request is passed in the body (the data does not seem to be UTF-8 encoded anyway)?', 'commenter': 'ztzg'}]"
1724,zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/QuorumSSLTest.java,"@@ -224,12 +228,24 @@ public OCSPHandler(X509Certificate revokedCert) {
         public void handle(com.sun.net.httpserver.HttpExchange httpExchange) throws IOException {
             byte[] responseBytes;
             try {
+                String uri = httpExchange.getRequestURI().toString();
+                LOG.info(""OCSP request: {} {} {}"", httpExchange.getRequestMethod(), uri, httpExchange.getRequestHeaders().entrySet());
+                httpExchange.getRequestHeaders().entrySet().forEach((e) -> {
+                    LOG.info(""OCSP request header: {} {}"", e.getKey(), e.getValue());
+                });
                 InputStream request = httpExchange.getRequestBody();
                 byte[] requestBytes = new byte[10000];
-                request.read(requestBytes);
+                int len = request.read(requestBytes);
+                LOG.info(""OCSP request size {}: {}"", len, new String(requestBytes, StandardCharsets.UTF_8));
 
+                if (len < 0) {
+                    String removedUriEncodiing = URLDecoder.decode(uri.substring(1), ""utf-8"");","[{'comment': 'Nit/typo: `removedUriEncoding`.', 'commenter': 'ztzg'}]"
1736,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -3031,6 +3031,13 @@ private ClientCnxnSocket getClientCnxnSocket() throws IOException {
         if (clientCnxnSocketName == null) {
             clientCnxnSocketName = ClientCnxnSocketNIO.class.getName();
         }
+
+        if (clientCnxnSocketName.equals(ClientCnxnSocketNetty.class.getSimpleName())) {","[{'comment': 'Why are you using getSimpleName ?\r\n\r\nCan you please explain how did you test this patch ?\r\nI am not sure it is worth to add an integration test but we should verify that this works well.\r\n', 'commenter': 'eolivelli'}, {'comment': 'thx for your review\r\n\r\ngetSimpleName returns the class name, excluding the package name.\r\n\r\nif jvm set `-Dzookeeper.clientCnxnSocket=ClientCnxnSocketNetty or ClientCnxnSocketNIO`，\r\nin zookeeper jar，clientCnxnSocketName is `org.apache.zookeeper.ClientCnxnSocketNetty`  or `org.apache.zookeeper.ClientCnxnSocketNIO`\r\nand in shaded zookeeper jar, clientCnxnSocketName is `${shaded.prefix}.org.apache.zookeeper.ClientCnxnSocketNetty` or `${shaded.prefix}.org.apache.zookeeper.ClientCnxnSocketNIO`\r\n**clientCnxnSocketName value is always correct.**', 'commenter': 'cuibo01'}, {'comment': 'If other components (like hbase, hdfs...) already use the `-Dzookeeper.clientCnxnSocket=org.apache.zookeeper.*`,  this patch has no effect on them.', 'commenter': 'cuibo01'}]"
1736,zookeeper-server/src/test/java/org/apache/zookeeper/test/ClientSSLTest.java,"@@ -84,6 +84,18 @@ public void testClientServerUnifiedPort() throws Exception {
         testClientServerSSL(false);
     }
 
+    @Test
+    public void testClientServerUnifiedPortWithCnxnClassName() throws Exception {
+        System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, ""ClientCnxnSocketNIO"");
+        testClientServerSSL(false);
+    }
+
+    @Test
+    public void testClientServerSSLWithCnxnClassName() throws Exception {
+        System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, ""ClientCnxnSocketNetty"");
+        testClientServerSSL(true);","[{'comment': 'please use System.clearProperty in a finally block in order to clean up the environment ', 'commenter': 'eolivelli'}, {'comment': 'the class has `@AfterEach public void teardown()`, so dont need System.clearProperty again?', 'commenter': 'cuibo01'}, {'comment': 'you are right I missed it.\r\n', 'commenter': 'eolivelli'}]"
1755,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -1486,6 +1490,9 @@ public void sendPacket(Packet p) throws IOException {
             clientCnxnSocket.sendPacket(p);
         }
 
+        public ZooKeeperSaslClient getZooKeeperSaslClient() {
+            return zooKeeperSaslClient;","[{'comment': '*THREAD_SAFETY_VIOLATION:*  Read/Write race. Non-private method `ClientCnxn$SendThread.getZooKeeperSaslClient()` reads without synchronization from `this.zooKeeperSaslClient`. Potentially races with write in method `ClientCnxn$SendThread.run()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not.\n(at-me [in a reply](https://help.sonatype.com/lift/talking-to-lift) with `help` or `ignore`)', 'commenter': 'sonatype-lift[bot]'}]"
1755,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -1313,6 +1313,10 @@ public void run() {
                 eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Disconnected, null));
             }
             eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Closed, null));
+
+            if (zooKeeperSaslClient != null) {","[{'comment': '*THREAD_SAFETY_VIOLATION:*  Read/Write race. Non-private method `ClientCnxn$SendThread.run()` reads without synchronization from `this.zooKeeperSaslClient`. Potentially races with write in method `ClientCnxn$SendThread.run()`.\n Reporting because this access may occur on a background thread.\n(at-me [in a reply](https://help.sonatype.com/lift/talking-to-lift) with `help` or `ignore`)', 'commenter': 'sonatype-lift[bot]'}]"
1755,zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java,"@@ -1313,6 +1313,10 @@ public void run() {
                 eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Disconnected, null));
             }
             eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Closed, null));
+
+            if (zooKeeperSaslClient != null) {
+                zooKeeperSaslClient.shutdown();","[{'comment': '*THREAD_SAFETY_VIOLATION:*  Unprotected write. Non-private method `ClientCnxn$SendThread.run()` indirectly writes to field `this.zooKeeperSaslClient.login` outside of synchronization.\n Reporting because this access may occur on a background thread.\n(at-me [in a reply](https://help.sonatype.com/lift/talking-to-lift) with `help` or `ignore`)', 'commenter': 'sonatype-lift[bot]'}]"
1770,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -521,11 +525,16 @@ private void receiveMessage(ByteBuf message) {
                             throw new IOException(""Len error "" + len);
                         }
                         ZooKeeperServer zks = this.zkServer;
-                        if (zks == null || !zks.isRunning()) {
-                            throw new IOException(""ZK down"");
+
+                        if (zks != null && !zks.isRunning()) {","[{'comment': ""Is the condition correct? I'd assume that the condition would be `zks.isRunning()`.\r\n```suggestion\r\n                        if (zks != null && zks.isRunning()) {\r\n```"", 'commenter': 'lhotari'}, {'comment': 'Thanks, I was not sure if this was needed and changed the condition.', 'commenter': 'andrekramer1'}]"
1770,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -521,11 +525,16 @@ private void receiveMessage(ByteBuf message) {
                             throw new IOException(""Len error "" + len);
                         }
                         ZooKeeperServer zks = this.zkServer;
-                        if (zks == null || !zks.isRunning()) {
-                            throw new IOException(""ZK down"");
+
+                        if (zks != null && !zks.isRunning()) {
+                            // checkRequestSize will throw IOException if request is rejected
+                            zks.checkRequestSizeWhenReceivingMessage(len);
+                        } else {
+                            LOG.debug(""Skip configurable check for max receive length"");
+                            if (len > 64 * 1024) {
+                                throw new IOException(""Received message size too large for uninitialized server"");
+                            }","[{'comment': ""This check looks unnecessary. \r\nThere's already https://github.com/apache/zookeeper/blob/c926b2f4d58ad08c33ff88ff6256347dab77ef60/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java#L524-L526"", 'commenter': 'lhotari'}]"
1770,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -225,15 +225,6 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
             NettyServerCnxn cnxn = new NettyServerCnxn(channel, zkServer, NettyServerCnxnFactory.this);
             ctx.channel().attr(CONNECTION_ATTRIBUTE).set(cnxn);
 
-            // Check the zkServer assigned to the cnxn is still running,
-            // close it before starting the heavy TLS handshake
-            if (!cnxn.isZKServerRunning()) {
-                LOG.warn(""Zookeeper server is not running, close the connection before starting the TLS handshake"");
-                ServerMetrics.getMetrics().CNXN_CLOSED_WITHOUT_ZK_SERVER_RUNNING.add(1);","[{'comment': 'I am re-reading the patch again.\r\nIt looks like we are no more updating this metric.\r\nand also we are dropping this case.\r\n\r\nMy understanding is that this check is here to prevent a flood of useless (but heavyweight) TLS handshakes after restarting the ZK node.\r\n\r\nI am not sure this is a good move to remove this. \r\nThis fix may work on a small cluster (with very few ZK clients I mean)\r\n\r\n@lvfangmin If I read correctly (from git blame) this improvement was part of ZOOKEEPER-3682 and the set of patches ported from Facebook ZooKeeper fork.\r\n\r\n', 'commenter': 'eolivelli'}]"
1773,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1636,6 +1636,12 @@ and [SASL authentication for ZooKeeper](https://cwiki.apache.org/confluence/disp
     Specifies the file path to a Java keystore containing the local
     credentials to be used for client and quorum TLS connections, and the
     password to unlock the file.
+    
+* *ssl.keyStore.passwordPath* and *ssl.quorum.keyStore.passwordPath* :
+    (Java system properties: **zookeeper.ssl.keyStore.passwordPath** and **zookeeper.ssl.quorum.keyStore.passwordPath**)","[{'comment': ""An alternative implementation to adding new properties would be to do something like what `openssl` does, and allow a passphrase to be passed in via a specific provider. From the `openssl` man page:\r\n\r\n```\r\n   Pass Phrase Options\r\n       Several commands accept password arguments, typically using -passin and -passout for input and output passwords respectively. These\r\n       allow the password to be obtained from a variety of sources. Both of these options take a single argument whose format is described\r\n       below. If no password argument is given and a password is required then the user is prompted to enter one: this will typically be read\r\n       from the current terminal with echoing turned off.\r\n\r\n       Note that character encoding may be relevant, please see passphrase-encoding(7).\r\n\r\n       pass:password\r\n           The actual password is password. Since the password is visible to utilities (like 'ps' under Unix) this form should only be used\r\n           where security is not important.\r\n\r\n       env:var\r\n           Obtain the password from the environment variable var. Since the environment of other processes is visible on certain platforms\r\n           (e.g. ps under certain Unix OSes) this option should be used with caution.\r\n\r\n       file:pathname\r\n           The first line of pathname is the password. If the same pathname argument is supplied to -passin and -passout arguments then the\r\n           first line will be used for the input password and the next line for the output password. pathname need not refer to a regular\r\n           file: it could for example refer to a device or named pipe.\r\n\r\n       fd:number\r\n           Read the password from the file descriptor number. This can be used to send the data via a pipe for example.\r\n\r\n       stdin\r\n           Read the password from standard input.\r\n```\r\n\r\nSupporting `file:`, `env:`, and `pass:` would go a long way towards giving users options, without needing to maintain lots of new properties whenever ZK wanted to support a new option. It doesn't have to be implemented exactly like `openssl`. For example, you could just add a `zookeeper.ssl.keyStore.passwordProvider`, which defaults to `pass`, but can also be set to `env` or `file`, and instructs ZK on how to interpret the `zookeeper.ssl.keyStore.password` value. That way, you only need to add one extra property per password to specify the provider, and it's still extensible to support `env` and potentially other providers in future."", 'commenter': 'ctubbsii'}, {'comment': ""@christ Thanks for the comment. Yep, the alternative implementation is more extensible and can reduce the number of properties if more options need to be supported.  Is there any reason that password handling didn't start that way?  \r\n\r\n@anmolnar @makubi @eolivelli @ztzg any thoughts on this? \r\n"", 'commenter': 'li4wang'}, {'comment': ""> Is there any reason that password handling didn't start that way?\r\n\r\nIt's just a guess, but the current properties seem modeled after [the JSSE properties](https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html#CustomizingStores).\r\n(also, note my username is `@ctubbsii` ; `@christ` is a different person)"", 'commenter': 'ctubbsii'}, {'comment': '@ctubbsii thanks for the additional info. I will update the PR to do something like what openssl does.', 'commenter': 'li4wang'}]"
1773,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1636,6 +1636,12 @@ and [SASL authentication for ZooKeeper](https://cwiki.apache.org/confluence/disp
     Specifies the file path to a Java keystore containing the local
     credentials to be used for client and quorum TLS connections, and the
     password to unlock the file.
+    
+* *ssl.keyStore.passwordPath* and *ssl.quorum.keyStore.passwordPath* :
+    (Java system properties: **zookeeper.ssl.keyStore.passwordPath** and **zookeeper.ssl.quorum.keyStore.passwordPath**)
+    **New in 3.7.1:**","[{'comment': 'Should new properties be added in a bugfix/patch release? It seems to me that this could be troublesome, because it would make 3.7.1 no longer forwards-compatible with 3.7.0 configuration. It may be best to add new user-facing features like this to the next minor release, 3.8.', 'commenter': 'ctubbsii'}, {'comment': ""These are additional properties for reading password from file. The properties for specifying plain text are still there. What forwards-compatibility issue do you see? \r\n\r\n We would like to include this functionality for our 3.7.1 production deployment, that's why it's added as 3.7.1 new properties. "", 'commenter': 'li4wang'}, {'comment': ""> What forwards-compatibility issue do you see?\r\n\r\nForwards-compatibility with 3.7.0 means that if you use a feature available in 3.7.1, and you have to downgrade back to 3.7.0 for some severe bug or something, you won't lose any functionality. Forwards-compatibility (and backwards-compatibility) is generally a goal for patch/bugfix versions under typical semantic versioning schemes. Backwards-compatibility is generally expected across minor versions, and major versions break compatibility. I don't think the ZooKeeper PMC has formally adopted any semantic versioning scheme, but it's generally useful guidelines to follow, because it helps clearly communicate breakages in the end user experience.\r\n\r\n> We would like to include this functionality for our 3.7.1 production deployment, that's why it's added as 3.7.1 new properties.\r\n\r\nFollowing semantic versioning strictly would generally prevent a new feature being added in a bugfix release. But, that release could just be named 3.8.0 when it is released. Or, don't follow it strictly. It's just a guide to help communicate compatibility expectations to users; it's never strictly necessary to communicate with users via this mechanism. The burden will just be on users to realize that they can't downgrade back to 3.7.0 without discontinuing use of this feature."", 'commenter': 'ctubbsii'}]"
1787,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/JsonOutputter.java,"@@ -19,10 +19,8 @@
 package org.apache.zookeeper.server.admin;
 
 import com.fasterxml.jackson.core.JsonGenerationException;
-import com.fasterxml.jackson.databind.JsonMappingException;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.fasterxml.jackson.databind.PropertyNamingStrategy;
-import com.fasterxml.jackson.databind.SerializationFeature;
+import com.fasterxml.jackson.databind.*;","[{'comment': 'please do not use star imports', 'commenter': 'eolivelli'}, {'comment': 'Sure. I will change accordingly. I believe the IDE made it automatically.', 'commenter': 'frederiko'}]"
1793,pom.xml,"@@ -608,11 +602,13 @@
         <groupId>org.junit.vintage</groupId>
         <artifactId>junit-vintage-engine</artifactId>
         <version>${junit.version}</version>
+        <scope>test</scope>
       </dependency>
       <dependency>
         <groupId>org.mockito</groupId>
         <artifactId>mockito-core</artifactId>
         <version>${mockito.version}</version>
+        <scope>test</scope>","[{'comment': ""It's not a good idea to put the `<scope>` in the `<dependencyManagement>` section of the POM, because that will propagate, and require the `<scope>compile</scope>` to be explicitly added (normally, it's not needed, because it's the default scope). It's better to just manage the version in the `<dependencyManagement>` section, and defer adding a scope until the dependency is actually used.\r\n\r\nIt is unlikely that these dependencies are going to be used in a scope other than `test`, but the only reason to put the scope here is to omit it later when it is used. However, omitting it later will make it *appear* as though the scope is used is the `compile` scope, so it doesn't really have any benefit to adding it here."", 'commenter': 'ctubbsii'}]"
1793,zookeeper-server/pom.xml,"@@ -75,8 +75,12 @@
       <artifactId>slf4j-api</artifactId>
     </dependency>
     <dependency>
-      <groupId>org.slf4j</groupId>
-      <artifactId>slf4j-log4j12</artifactId>
+      <groupId>ch.qos.logback</groupId>
+      <artifactId>logback-core</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>ch.qos.logback</groupId>
+      <artifactId>logback-classic</artifactId>","[{'comment': 'These really should be runtime scoped dependencies, since they should not actually be used anywhere in the code at compile time.', 'commenter': 'ctubbsii'}, {'comment': 'If they are needed for tests, they could use the `test` scope explicitly here.', 'commenter': 'ctubbsii'}, {'comment': ""I agree. @anmolnar is there a reason why these are not in 'test' scope?"", 'commenter': 'symat'}, {'comment': 'This one makes me confused: we didn\'t do this for the log4j1 reference. If you check it in this file, it\'s not ""test"" scoped. Also, if I make logback to ""test"" scoped, it won\'t be included in the binary distribution. Is that okay?', 'commenter': 'anmolnar'}, {'comment': ""Hmm... you are right. I didn't think this through. We still need to put logback to the binary distribution as we need some default log engine."", 'commenter': 'symat'}, {'comment': ""@anmolnar Yeah, it wasn't that way for log4j1, because log4j1 was used at compile time. However, part of this is to complete the migration to `slf4j-api` at compile time, so the runtime implementations can be chosen by users. So, no actual implementation jar should need to be `compile` scoped anymore. They can just be `runtime` (or `test` if it is only needed to compile the tests; `runtime` implies `test`). The main point is that they aren't needed at `compile` time, because `slf4j-api` is used at compile time instead."", 'commenter': 'ctubbsii'}, {'comment': ""`runtime` dependencies should still be included in the binary distribution... I'd have to check to see how you are constructing the binary distribution. But, you shouldn't put it on the `compile` class path just to put it in the binary distribution. There's better ways to include it in the distribution than changing the scope."", 'commenter': 'ctubbsii'}]"
1793,zookeeper-server/src/test/java/org/apache/zookeeper/test/LoggerTestTool.java,"@@ -0,0 +1,89 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import ch.qos.logback.classic.Level;
+import ch.qos.logback.classic.Logger;
+import ch.qos.logback.classic.LoggerContext;
+import ch.qos.logback.classic.spi.ILoggingEvent;
+import ch.qos.logback.core.Appender;
+import ch.qos.logback.core.Layout;
+import ch.qos.logback.core.OutputStreamAppender;
+import ch.qos.logback.core.encoder.LayoutWrappingEncoder;
+import org.slf4j.LoggerFactory;
+
+import java.io.ByteArrayOutputStream;
+
+public class LoggerTestTool<T> implements AutoCloseable {","[{'comment': 'Putting all the log capture test code in one place was a really nice decision. The implementation is pretty simple, too. Not sure what the equivalent in log4j2 or another slf4j binding would look like. So, logback here makes sense, if the alternatives would be substantially worse.\r\n\r\nAn alternative would be to make better use of mocking in the tests that use this. Capturing the logs is not usually an ideal way to do unit testing. But, this is a nice simple replacement for existing tests.', 'commenter': 'ctubbsii'}, {'comment': ""+1, this is nice!\r\n\r\nDo you think instead of parameterizing the type, it would make sense for the constructor to just accept `Class<?>` directly? It seems like all of the call sites just end up instantiating it as `LoggerTestTool<?>`, so they aren't getting much value from capturing the specific class type. The underlying SLF4J interface also operates on `Class<?>`."", 'commenter': 'cnauroth'}, {'comment': 'Good point. I removed the type parameter entirely.', 'commenter': 'anmolnar'}]"
1793,pom.xml,"@@ -459,6 +459,7 @@
 
     <!-- dependency versions -->
     <slf4j.version>1.7.30</slf4j.version>
+    <logback-version>1.2.7</logback-version>","[{'comment': '1.2.10 is the latest non-alpha release. Do you want to upgrade to that?', 'commenter': 'cnauroth'}]"
1793,zookeeper-metrics-providers/zookeeper-prometheus-metrics/src/test/resources/logback.xml,"@@ -0,0 +1,112 @@
+<!--
+ Copyright 2022 The Apache Software Foundation
+
+ Licensed to the Apache Software Foundation (ASF) under one
+ or more contributor license agreements.  See the NOTICE file
+ distributed with this work for additional information
+ regarding copyright ownership.  The ASF licenses this file
+ to you under the Apache License, Version 2.0 (the
+ ""License""); you may not use this file except in compliance
+ with the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an ""AS IS"" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+
+ Define some default values that can be overridden by system properties
+-->
+<configuration>","[{'comment': 'Optional: Maybe this file can be simplified by removing unused properties and commented-out lines, because the tests just end up using console anyway.', 'commenter': 'cnauroth'}, {'comment': 'Same comment here about potentially simplifying test logging configuration files.', 'commenter': 'cnauroth'}]"
1793,zookeeper-server/src/test/java/org/apache/zookeeper/audit/Log4jAuditLoggerTest.java,"@@ -48,33 +37,37 @@
 import org.apache.zookeeper.server.quorum.QuorumPeerTestBase;
 import org.apache.zookeeper.test.ClientBase;
 import org.apache.zookeeper.test.ClientBase.CountdownWatcher;
+import org.apache.zookeeper.test.LoggerTestTool;
 import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.LineNumberReader;
+import java.io.StringReader;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.List;
 
 public class Log4jAuditLoggerTest extends QuorumPeerTestBase {","[{'comment': 'Shall we rename this class to remove mention of Log4J?', 'commenter': 'cnauroth'}, {'comment': 'Yes, I should rename the class as well, not just the test.\r\nActually it should be `Slf4jAuditLogger` to be precise.', 'commenter': 'anmolnar'}]"
1793,LICENSE.txt,"@@ -200,3 +200,209 @@
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
+","[{'comment': ""Reading through this...\r\n\r\nhttps://infra.apache.org/licensing-howto.html#permissive-deps\r\n\r\n...I don't think we're supposed to put the entire text of the EPL in here. Instead, it's typically a pointer to the dependency's license."", 'commenter': 'cnauroth'}, {'comment': 'You can put the entire text in there, but more importantly, you should not include it in here, because you haven\'t bundled Logback into the source. You should only include LICENSE/NOTICE information for things actually distributing as a bundle. This means the LICENSE/NOTICE files can be different between the source tarball (official release) and the distribution tarball (AKA ""convenience binary"") that actually includes the logback jar bundled.\r\n\r\nSo, these are the wrong files to modify. I\'m not familiar enough with the ZK build to know how the convenience binaries are built, but there should be a separate mechanism to bundle LICENSE/NOTICE files into the convenience binary than these, which are for the source.', 'commenter': 'ctubbsii'}, {'comment': ""My assumption was based on this guide: https://infra.apache.org/licensing-howto.html\r\n> You must customize LICENSE and NOTICE files according to the content of the specific distribution they reside within. Do not add to LICENSE and NOTICE dependencies which are not in the distribution. **Only bundled bits matter.**\r\n\r\nEven though logback is not included in our source distribution, we also have a convenience binary distribution with first-level dependencies included. But. Jetty falls into this bucket too which also has EPL v1.0 license and we don't include it in top-level files. So, I ended up reverting these files and add the logback license only to the resource folder."", 'commenter': 'anmolnar'}, {'comment': ""@ctubbsii , great point about the different needs for source vs. binary distribution. Thank you.\r\n\r\nIt's fine to externalize license files to the resources folder (which land in the lib folder for the binary distribution). However, I think there still needs to be some kind of pointer from top-level to those separate licenses. It seems like zookeeper-server/src/main/resources/NOTICE.txt is trying to serve that purpose. I don't see this file actually showing up though when I build a binary distribution. It only has the same LICENSE.txt and NOTICE.txt from the root. (Additionally, my reading of the licensing how-to is that this stuff should be handled in LICENSE instead of NOTICE.)\r\n\r\nCan someone else double-check me by testing building a binary distribution? Maybe we have a separate build bug preventing inclusion of the right files in the binary distribution? If so, that could be a separate topic, but it should be addressed before our next release."", 'commenter': 'cnauroth'}, {'comment': ""@cnauroth I compared the binary and source distribution in terms of lincensing and I think we don't have a separate build process for that. They contain the same LICENSE and NOTICE files. Both the binary and source distribution also contains the per-jar lincense.txt files, but the binary distribution includes the jar files themselves. To be honest I don't plan making any changes in this build process. I believe this patch is already aligned with the current habit of releasing."", 'commenter': 'anmolnar'}, {'comment': ""Thank you. That confirms what I saw.\r\n\r\n> To be honest I don't plan making any changes in this build process.\r\n\r\nThat makes sense. If we need to address anything in this area for release, it can be handled as separate scope."", 'commenter': 'cnauroth'}]"
1793,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -504,22 +504,20 @@ The ZooKeeper service can be monitored in one of three primary ways:
 ### Logging
 
 ZooKeeper uses **[SLF4J](http://www.slf4j.org)**
-version 1.7.5 as its logging infrastructure. For backward compatibility it is bound to
-**LOG4J** but you can use
-**[LOGBack](http://logback.qos.ch/)**
-or any other supported logging framework of your choice.
-
-The ZooKeeper default *log4j.properties*
-file resides in the *conf* directory. Log4j requires that
-*log4j.properties* either be in the working directory
+version 1.7.5 as its logging infrastructure. By default ZooKeeper is shipped with","[{'comment': 'Should this be version 1.7.30?', 'commenter': 'craiglawson'}, {'comment': 'I\'d recommend being less tightly coupled to the current patch version in this document. Just ""1.7"" should suffice here.', 'commenter': 'ctubbsii'}, {'comment': 'This is done.\r\n', 'commenter': 'anmolnar'}]"
1799,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java,"@@ -522,7 +522,10 @@ private void receiveMessage(ByteBuf message) {
                         }
                         ZooKeeperServer zks = this.zkServer;
                         if (zks == null || !zks.isRunning()) {
-                            throw new IOException(""ZK down"");
+                            LOG.warn(""Closing connection to {} because the server is not ready"",
+                                    getRemoteSocketAddress());
+                            close(DisconnectReason.IO_EXCEPTION);","[{'comment': ""nit: I know we were throwing IOException before which resulted in DisconnectReason.IO_EXCEPTION, but now that we do proper close here, we might use some better DisconnectReason. I see e.g. DisconnectReason.SERVER_SHUTDOWN. Although I'm not sure when this part is triggered... I guess this can be triggered either during initialization or shutdown. Maybe DisconnectReason.IO_EXCEPTION is good enough.\r\n\r\nAlso: before this change we did log the 'getRemoteSocketAddress()' in line 534, which might be handy to add to this warning above. (if someone is trying to figure out in the ZK log why a session terminated) "", 'commenter': 'symat'}, {'comment': 'we have the same ""ZK down"" exception in line 477. Maybe the logic should be changed there as well?', 'commenter': 'symat'}, {'comment': ""this is the same behaviour as before.\r\nI would like to not change the behaviour with this patch if it is not strictly needed.\r\n\r\n> before this change we did log the 'getRemoteSocketAddress()' in line 534, which might be handy to add to this warning above\r\nwe are still printing it. I cannot get this comment"", 'commenter': 'eolivelli'}]"
1799,zookeeper-server/src/test/java/org/apache/zookeeper/server/NettyServerCnxnTest.java,"@@ -180,42 +181,70 @@ public void testNonMTLSRemoteConn() throws Exception {
         when(zks.isRunning()).thenReturn(true);
         ServerStats.Provider providerMock = mock(ServerStats.Provider.class);
         when(zks.serverStats()).thenReturn(new ServerStats(providerMock));
-        testNonMTLSRemoteConn(zks);
+        testNonMTLSRemoteConn(zks, false, false);
     }
 
     @Test
     public void testNonMTLSRemoteConnZookKeeperServerNotReady() throws Exception {
-        testNonMTLSRemoteConn(null);
+        testNonMTLSRemoteConn(null, false, false);
+    }
+
+    @Test
+    public void testNonMTLSRemoteConnZookKeeperServerNotReadyEarlyDropEnabled() throws Exception {
+        testNonMTLSRemoteConn(null, false, true);
+    }
+
+    @Test
+    public void testMTLSRemoteConnZookKeeperServerNotReadyEarlyDropEnabled() throws Exception {
+        testNonMTLSRemoteConn(null, true, true);
+    }
+
+    @Test
+    public void testMTLSRemoteConnZookKeeperServerNotReadyEarlyDropDisabled() throws Exception {
+        testNonMTLSRemoteConn(null, true, true);
     }
 
     @SuppressWarnings(""unchecked"")
-    private void testNonMTLSRemoteConn(ZooKeeperServer zks) throws Exception {
-        Channel channel = mock(Channel.class);
-        ChannelId id = mock(ChannelId.class);
-        ChannelFuture success = mock(ChannelFuture.class);
-        ChannelHandlerContext context = mock(ChannelHandlerContext.class);
-        ChannelPipeline channelPipeline = mock(ChannelPipeline.class);
-
-        when(context.channel()).thenReturn(channel);
-        when(channel.pipeline()).thenReturn(channelPipeline);
-        when(success.channel()).thenReturn(channel);
-        when(channel.closeFuture()).thenReturn(success);
-
-        InetSocketAddress address = new InetSocketAddress(0);
-        when(channel.remoteAddress()).thenReturn(address);
-        when(channel.id()).thenReturn(id);
-        NettyServerCnxnFactory factory = new NettyServerCnxnFactory();
-        factory.setZooKeeperServer(zks);
-        Attribute atr = mock(Attribute.class);
-        Mockito.doReturn(atr).when(channel).attr(
-                Mockito.any()
-        );
-        doNothing().when(atr).set(Mockito.any());
-        factory.channelHandler.channelActive(context);
-
-        if (zks != null) {
-            assertEquals(0, zks.serverStats().getNonMTLSLocalConnCount());
-            assertEquals(1, zks.serverStats().getNonMTLSRemoteConnCount());
+    private void testNonMTLSRemoteConn(ZooKeeperServer zks, boolean secure, boolean earlyDrop) throws Exception {
+        System.setProperty(NettyServerCnxnFactory.EARLY_DROP_SECURE_CONNECTION_HANDSHAKES, earlyDrop + """");
+        try {
+            Channel channel = mock(Channel.class);
+            ChannelId id = mock(ChannelId.class);
+            ChannelFuture success = mock(ChannelFuture.class);
+            ChannelHandlerContext context = mock(ChannelHandlerContext.class);
+            ChannelPipeline channelPipeline = mock(ChannelPipeline.class);
+
+            when(context.channel()).thenReturn(channel);
+            when(channel.pipeline()).thenReturn(channelPipeline);
+            when(success.channel()).thenReturn(channel);
+            when(channel.closeFuture()).thenReturn(success);
+
+            InetSocketAddress address = new InetSocketAddress(0);
+            when(channel.remoteAddress()).thenReturn(address);
+            when(channel.id()).thenReturn(id);
+            NettyServerCnxnFactory factory = new NettyServerCnxnFactory();
+            factory.setSecure(secure);
+            factory.setZooKeeperServer(zks);
+            Attribute atr = mock(Attribute.class);
+            Mockito.doReturn(atr).when(channel).attr(
+                    Mockito.any()
+            );
+            doNothing().when(atr).set(Mockito.any());
+            factory.channelHandler.channelActive(context);
+
+            if (zks != null)  {
+                assertEquals(0, zks.serverStats().getNonMTLSLocalConnCount());
+                assertEquals(1, zks.serverStats().getNonMTLSRemoteConnCount());
+            } else {
+                if (earlyDrop && secure) {
+                    // the channel must have been forcibly closed
+                    Mockito.verify(channel, times(1)).close();
+                } else {
+                    Mockito.verify(channel, times(0)).close();
+                }
+            }
+        } finally {
+            System.clearProperty(NettyServerCnxnFactory.EARLY_DROP_SECURE_CONNECTION_HANDSHAKES);","[{'comment': ""nit: if you clear this in the finally block, then let's move the setProperty call into the try block. (now if the test killed just before the try block, the property won't be cleared. - very-very unlikely, but still...)\r\n\r\nAlternatively I would be OK to put the clearProperty call to the afterEach() method and then you don't need the try-finally block.\r\n\r\nAlso just double-checking: we don't run multiple test classes (or methods in the same class) paralel in the same JVM, right? Let's make sure we avoid some flaky execution."", 'commenter': 'symat'}, {'comment': ""> we don't run multiple test classes (or methods in the same class)\r\nthis is correct, and as ZK uses System properties it wont't be possible in the short term"", 'commenter': 'eolivelli'}, {'comment': ""> then let's move the setProperty call into the try block\r\n@symat fixed"", 'commenter': 'eolivelli'}]"
1799,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -227,11 +228,14 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
 
             // Check the zkServer assigned to the cnxn is still running,
             // close it before starting the heavy TLS handshake
-            if (!cnxn.isZKServerRunning()) {
-                LOG.warn(""Zookeeper server is not running, close the connection before starting the TLS handshake"");
-                ServerMetrics.getMetrics().CNXN_CLOSED_WITHOUT_ZK_SERVER_RUNNING.add(1);
-                channel.close();
-                return;
+            if (secure && !cnxn.isZKServerRunning()) {
+                boolean earlyDropSecureConnectionHandshakes = Boolean.getBoolean(EARLY_DROP_SECURE_CONNECTION_HANDSHAKES);","[{'comment': 'nit: should we maybe use a final field initialized in a constructor of the NettyServerCnxnFactory instead of parsing the system property all the time? ', 'commenter': 'symat'}, {'comment': ""this is the common practice in ZooKeeper.\r\nit also helps testing.\r\nI don't like it, but this is how we are doing thru the rest of the codebase.\r\nIn this case we are not hitting an hot path so the cost is negligible and changing it will make harder testing\r\n\r\nSo I would keep it this way "", 'commenter': 'eolivelli'}, {'comment': 'OK', 'commenter': 'symat'}]"
1799,zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java,"@@ -227,11 +228,14 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
 
             // Check the zkServer assigned to the cnxn is still running,
             // close it before starting the heavy TLS handshake
-            if (!cnxn.isZKServerRunning()) {
-                LOG.warn(""Zookeeper server is not running, close the connection before starting the TLS handshake"");
-                ServerMetrics.getMetrics().CNXN_CLOSED_WITHOUT_ZK_SERVER_RUNNING.add(1);
-                channel.close();
-                return;
+            if (secure && !cnxn.isZKServerRunning()) {
+                boolean earlyDropSecureConnectionHandshakes = Boolean.getBoolean(EARLY_DROP_SECURE_CONNECTION_HANDSHAKES);
+                if (earlyDropSecureConnectionHandshakes) {
+                    LOG.warn(""Zookeeper server is not running, close the connection before starting the TLS handshake"");","[{'comment': 'nit: I know we had warning level before, but what do you think about INFO level instead? I like to have logs here, just not sure if this is really something the user should worry.', 'commenter': 'symat'}, {'comment': 'This is exactly the same thing we printed before in the ""catch"" block below, but without spamming the logs with a stacktrace and with a meaning less message.\r\n\r\nSo I did this way in order to not change the behaviour too much but at least removing the stacktrace', 'commenter': 'eolivelli'}, {'comment': 'changed to INFO', 'commenter': 'eolivelli'}]"
1799,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1163,6 +1163,12 @@ property, when available, is noted below.
     effect due to TLS handshake timeout when there are too many in-flight TLS
     handshakes. Set it to something like 250 is good enough to avoid herd effect.
 
+* *netty.server.earlyDropSecureConnectionHandshakes*","[{'comment': ""I like this to be false by default. However, AFACT this behaviour was enabled in 3.7.0 by default. Maybe we should mention it in the documentation. (and also in the release doc of 3.7.1 and 3.8.0 if we don't forget)"", 'commenter': 'symat'}, {'comment': 'that ""feature"" was enabled in 3.6. this is way Pulsar and Pravega users are not able to upgrade ZK.\r\n\r\nI can update the docs and explain the story.\r\nI would like this patch to land to 3.6. 3.7 and 3.8', 'commenter': 'eolivelli'}, {'comment': 'updated', 'commenter': 'eolivelli'}]"
1802,zookeeper-contrib/zookeeper-contrib-loggraph/pom.xml,"@@ -63,14 +63,9 @@
       </exclusions>
     </dependency>
     <dependency>
-      <groupId>log4j</groupId>
-      <artifactId>log4j</artifactId>
-      <exclusions>
-        <exclusion>
-          <groupId>*</groupId>
-          <artifactId>*</artifactId>
-        </exclusion>
-      </exclusions>
+      <groupId>ch.qos.reload4j</groupId>
+      <artifactId>reload4j</artifactId>
+    </dependency>","[{'comment': 'Extra `</dependency>` here\r\n\r\n```suggestion\r\n```', 'commenter': 'ctubbsii'}, {'comment': 'thanks', 'commenter': 'eolivelli'}]"
1802,zookeeper-contrib/zookeeper-contrib-fatjar/pom.xml,"@@ -91,9 +91,9 @@
       <artifactId>snappy-java</artifactId>
     </dependency>
     <dependency>
-      <groupId>log4j</groupId>
-      <artifactId>log4j</artifactId>
-    </dependency>
+      <groupId>ch.qos.reload4j</groupId>
+      <artifactId>reload4j</artifactId>
+     </dependency>","[{'comment': 'nit* proper alignment on closing `</dependency>` is missing', 'commenter': 'sudeepknair'}]"
1802,zookeeper-server/pom.xml,"@@ -77,6 +77,7 @@
     <dependency>
       <groupId>org.slf4j</groupId>
       <artifactId>slf4j-log4j12</artifactId>
+      <scope>test</scope>","[{'comment': 'slf4j-log4j12-1.7.35 maven coordinates automatically redirect to slf4j-reload4j-1.7.35\r\n\r\nSo, you could just use the slf4j-reload4j binding directly, if you update the slf4j version to the latest, 1.7.35 (which I would recommend). If you do this, I see this would be done in the root POM, plus the server, plus 3 of the contrib POMs.\r\n\r\nSee https://search.maven.org/artifact/org.slf4j/slf4j-log4j12/1.7.35/pom', 'commenter': 'ctubbsii'}, {'comment': 'After changing slf4j-log4j12 scope to test, logging is not working. I can see only following  information in log file\r\n\r\n`SLF4J: Failed to load class ""org.slf4j.impl.StaticLoggerBinder"".\r\nSLF4J: Defaulting to no-operation (NOP) logger implementation\r\nSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\r\nSLF4J: Failed to load class ""org.slf4j.impl.StaticMDCBinder"".\r\nSLF4J: Defaulting to no-operation MDCAdapter implementation.\r\nSLF4J: See http://www.slf4j.org/codes.html#no_static_mdc_binder for further details.\r\n`\r\n\r\nSo some how I think we should ensure presence of slf4j implementation lib in tar ball.\r\n', 'commenter': 'arshadmohammad'}]"
1802,zookeeper-assembly/pom.xml,"@@ -64,6 +64,14 @@
       <artifactId>zookeeper</artifactId>
       <version>${project.version}</version>
     </dependency>
+     <dependency>","[{'comment': '*Critical OSS Vulnerability:*\n### pkg:maven/org.slf4j/slf4j-log4j12@1.7.30\n2 Critical, 0 Severe, 1 Moderate, 0 Unknown vulnerabilities have been found across 1 dependencies\n\n<details>\n  <summary><b>Components</b></summary><br/>\n  <ul>\n      <details>\n        <summary><b>pkg:maven/log4j/log4j@1.2.17</b></summary>\n        <ul>\n  <details>\n    <summary><b>CRITICAL Vulnerabilities (2)</b></summary><br/>\n<ul>\n<details>\n            <summary>CVE-2019-17571</summary>\n\n> #### [CVE-2019-17571] Included in Log4j 1.2 is a SocketServer class that is vulnerable to deserializat...\n> Included in Log4j 1.2 is a SocketServer class that is vulnerable to deserialization of untrusted data which can be exploited to remotely execute arbitrary code when combined with a deserialization gadget when listening to untrusted network traffic for log data. This affects Log4j versions up to 1.2 up to 1.2.17.\n>\n> **CVSS Score:** 9.8\n>\n> **CVSS Vector:** CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H\n\n</details>\n<details>\n            <summary>CVE-2021-4104</summary>\n\n> #### [CVE-2021-4104] JMSAppender in Log4j 1.2 is vulnerable to deserialization of untrusted data when...\n> JMSAppender in Log4j 1.2 is vulnerable to deserialization of untrusted data when the attacker has write access to the Log4j configuration. The attacker can provide TopicBindingName and TopicConnectionFactoryBindingName configurations causing JMSAppender to perform JNDI requests that result in remote code execution in a similar fashion to CVE-2021-44228. Note this issue only affects Log4j 1.2 when specifically configured to use JMSAppender, which is not the default. Apache Log4j 1.2 reached end of life in August 2015. Users should upgrade to Log4j 2 as it addresses numerous other issues from the previous versions.\n\n\n===================================================\nThe following information is provided by Sonatype Nexus Intelligence. Nexus Intelligence is the only security research service that performs &quot;secondary expansion&quot; to determine if newly discovered vulnerabilities are also present in other components.\n\nLearn more about Nexus Intelligence -- https://www.sonatype.com/products/intelligence\n===================================================\n\n\nExplanation\n---------------------------------------------------\n\nThe `log4j:log4j` package is vulnerable to Deserialization of Untrusted Data. The `lookup()` and `activateOptions()` methods in the `JMSAppender` class allow `JNDI` lookup requests to be made when the `TopicBindingName` and `TopicConnectionFactoryBindingName` specify a trusted host. Lookups made to this host may be used by attackers to request a serialized malicious Java Object that can be deserialized and executed, leading to Remote Code Execution (RCE). \n\nNote that this vulnerability is different from CVE-2021-44228 and requires the attacker to be in control of the third party host that is specified in the configuration, or write access to the Log4j configuration file in order to specify a malicious lookup host directly. This vulnerability also only affects the 1.x.x component of `Log4j` released under the `log4j:log4j` group and artifact IDs.\n\n*Advisory Deviation Notice:* The Sonatype security research team discovered that the root cause of the vulnerability is in all versions of log4j:log4j, not just in the 1.2.x branch as the advisory states. \n\n\nDetection\n---------------------------------------------------\n\nThe application is vulnerable by using this component under the following circumstances:\n\n- The configuration file specifies an allowed third-party `JNDI` lookup host for the `JMSAppender`\n- the `javax.jms.*` API is included in the application&#39;s `CLASSPATH`\n\nReference: https://bugzilla.redhat.com/show_bug.cgi?id=2031667#c28\n\n\nRecommendation\n---------------------------------------------------\n\nThe 1.x.x component has reach `End of Life`, and users should upgrade to a non-vulnerable version of `org.apache.logging.log4j:log4j-core` as this component includes other security vulnerabilities that are not fixed.\n\nReferences:\n- https://github.com/apache/logging-log4j2/pull/608#issuecomment-990494126\n- https://logging.apache.org/log4j/1.2/\n\n>\n> **CVSS Score:** 8.1\n>\n> **CVSS Vector:** CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H\n\n</details>\n</ul>\n    </details>\n  <details>\n    <summary><b>MODERATE Vulnerabilities (1)</b></summary><br/>\n<ul>\n\n> #### [CVE-2020-9488] Improper validation of certificate with host mismatch in Apache Log4j SMTP appen...\n> Improper validation of certificate with host mismatch in Apache Log4j SMTP appender. This could allow an SMTPS connection to be intercepted by a man-in-the-middle attack which could leak any log messages sent through that appender.\n>\n> **CVSS Score:** 3.7\n>\n> **CVSS Vector:** CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N\n\n</ul>\n    </details>\n        </ul>\n      </details>\n  </ul>\n</details>\n(at-me [in a reply](https://help.sonatype.com/lift/talking-to-lift) with `help` or `ignore`)', 'commenter': 'sonatype-lift[bot]'}]"
1821,zookeeper-server/src/test/java/org/apache/zookeeper/server/RequestThrottlerTest.java,"@@ -277,34 +286,32 @@ public void testLargeRequestThrottling() throws Exception {
         resumeProcess = new CountDownLatch(1);
         // the connection will be close when large requests exceed the limit
         // we can't use the submitted latch because requests after close won't be submitted
-        disconnected = new CountDownLatch(TOTAL_REQUESTS);
-
-        // the total length of the request is about 170-180 bytes, so only two requests are allowed
-        byte[] data = new byte[100];
+        disconnected = new CountDownLatch(number_requests);
 
-        // send 5 requests asynchronously
-        for (int i = 0; i < TOTAL_REQUESTS; i++) {
+        // send requests asynchronously
+        for (int i = 0; i < number_requests; i++) {
             zk.create(""/request_throttle_test- "" + i , data,
                     ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, createCallback, null);
         }
 
-        // make sure the server received all 5 requests
-        disconnected.await(30, TimeUnit.SECONDS);
+        // make sure the server received all requests
+        assertTrue(disconnected.await(30, TimeUnit.SECONDS));
+
+        finished = new CountDownLatch(2);
+        // let the requests go through the pipeline
+        resumeProcess.countDown();
+        assertTrue(finished.await(5, TimeUnit.SECONDS));
+
+        // assert metrics after finished so metrics in no io threads are set also.
         Map<String, Object> metrics = MetricsUtils.currentServerMetrics();
 
         // but only two requests can get into the pipeline because they are large requests
         // the connection will be closed
         assertEquals(2L, (long) metrics.get(""prep_processor_request_queued""));
         assertEquals(1L, (long) metrics.get(""large_requests_rejected""));
-        assertEquals(5, connectionLossCount);
-
-        finished = new CountDownLatch(2);
-        // let the requests go through the pipeline
-        resumeProcess.countDown();
-        finished.await(5, TimeUnit.SECONDS);
+        assertEquals(number_requests, connectionLossCount);
 
         // when the two requests finish, they are stale because the connection is closed already
-        metrics = MetricsUtils.currentServerMetrics();","[{'comment': 'Why we are not collecting the metrics here?', 'commenter': 'eolivelli'}, {'comment': 'Before this pr, `metrics` are read twice, one before `finished.await`, one after that. In this pr, I move all after `finished.await`, so there is no need to read twice. I think it is ok as we are asserting post conditions not intermediate conditions, this way we will not struggling with concurrent issues.', 'commenter': 'kezhuw'}]"
1826,.github/workflows/e2e.yaml,"@@ -0,0 +1,106 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+name: End to End Tests
+
+on:
+  push:
+  pull_request:
+
+jobs:
+  connectivity:
+    strategy:
+      matrix:
+        jdk: [8, 11]
+      fail-fast: false
+    timeout-minutes: 360
+    runs-on: ubuntu-latest
+    steps:
+    - uses: actions/checkout@v2
+    - name: Set up JDK ${{ matrix.jdk }}
+      uses: actions/setup-java@v1
+      with:
+        java-version: ${{ matrix.jdk }}
+    - name: Cache local maven repository
+      uses: actions/cache@v2
+      with:
+        path: |
+          ~/.m2/repository/
+          !~/.m2/repository/org/apache/zookeeper
+        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
+        restore-keys: ${{ runner.os }}-m2
+    - name: Show the first log message
+      run: git log -n1
+    - name: Install C Dependencies
+      run: sudo apt-get install libcppunit-dev libsasl2-dev
+    - name: Build with Maven
+      run: mvn -B -V -e -ntp ""-Dstyle.color=always"" package -DskipTests
+      env:
+        MAVEN_OPTS: -Djansi.force=true
+    - name: Test ZooKeeper nightly server and client
+      run: |
+        cp conf/zoo_sample.cfg conf/zoo.cfg
+        bin/zkServer.sh start
+        bin/zkCli.sh sync /
+        bin/zkServer.sh stop
+
+  compatibility:
+    strategy:
+      matrix:
+        jdk: [8, 11]
+        zk: [3.5.9, 3.6.3, 3.7.0]
+      fail-fast: false
+    timeout-minutes: 360
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v2
+      - name: Set up JDK ${{ matrix.jdk }}
+        uses: actions/setup-java@v1
+        with:
+          java-version: ${{ matrix.jdk }}
+      - name: Cache local maven repository
+        uses: actions/cache@v2
+        with:
+          path: |
+            ~/.m2/repository/
+            !~/.m2/repository/org/apache/zookeeper
+          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
+          restore-keys: ${{ runner.os }}-m2
+      - name: Show the first log message
+        run: git log -n1
+      - name: Install C Dependencies
+        run: sudo apt-get install libcppunit-dev libsasl2-dev
+      - name: Build with Maven
+        run: mvn -B -V -e -ntp ""-Dstyle.color=always"" package -DskipTests
+        env:
+          MAVEN_OPTS: -Djansi.force=true
+      - name: Download ZooKeeper ${{ matrix.zk }} and prepare config
+        run: |
+          curl -O https://downloads.apache.org/zookeeper/zookeeper-${{ matrix.zk }}/apache-zookeeper-${{ matrix.zk }}-bin.tar.gz","[{'comment': 'Possibly use http://archive.apache.org/dist/zookeeper/ for stability?', 'commenter': 'tisonkun'}]"
1826,tools/ci/test-connectivity.py,"@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import argparse
+import subprocess","[{'comment': '*blacklist:*  Consider possible security implications associated with the subprocess module.\n(at-me [in a reply](https://help.sonatype.com/lift/talking-to-lift) with `help` or `ignore`)', 'commenter': 'sonatype-lift[bot]'}, {'comment': '@sonatype-lift help', 'commenter': 'tisonkun'}, {'comment': 'I’m LiftBot and I automatically analyze new code in code review, and comment when I find potential bugs. I also accept comments as commands. Just `@sonatype-lift` followed by the command: **ignore** to mark as false positive, **unignore** to undo, and **help** to see this message. [Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.', 'commenter': 'sonatype-lift[bot]'}, {'comment': '@sonatype-lift ignore', 'commenter': 'tisonkun'}, {'comment': ""I've recorded this as ignored for this pull request. If you change your mind, just comment `@sonatype-lift unignore`."", 'commenter': 'sonatype-lift[bot]'}]"
1826,tools/ci/test-connectivity.py,"@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import argparse
+import subprocess
+
+from pathlib import Path
+
+class Server():
+    def __init__(self, binpath):
+        self.binpath = binpath
+    def __enter__(self):
+        subprocess.run([f'{self.binpath}', 'start'], check=True)
+        return self
+    def __exit__(self, type, value, traceback):
+        subprocess.run([f'{self.binpath}', 'stop'], check=True)
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser()
+    parser.add_argument('--server', help=""basepath to zk server"", required=True)
+    parser.add_argument('--client', help=""basepath to zk client"", required=True)
+
+    args = parser.parse_args()
+    
+    server_basepath = Path(args.server).absolute()
+    server_binpath = server_basepath / ""bin"" / ""zkServer.sh""
+    assert server_binpath.exists(), f""server binpath not exist: {server_binpath}""
+    client_basepath = Path(args.client).absolute()
+    client_binpath = client_basepath / ""bin"" / ""zkCli.sh""
+    assert client_binpath.exists(), f""client binpath not exist: {client_binpath}""
+
+    with Server(server_binpath):
+        subprocess.run([f'{client_binpath}', 'sync', '/'], check=True)","[{'comment': '*subprocess_without_shell_equals_true:*  subprocess call - check for execution of untrusted input.\n(at-me [in a reply](https://help.sonatype.com/lift/talking-to-lift) with `help` or `ignore`)', 'commenter': 'sonatype-lift[bot]'}, {'comment': '@sonatype-lift help', 'commenter': 'tisonkun'}, {'comment': 'I’m LiftBot and I automatically analyze new code in code review, and comment when I find potential bugs. I also accept comments as commands. Just `@sonatype-lift` followed by the command: **ignore** to mark as false positive, **unignore** to undo, and **help** to see this message. [Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.', 'commenter': 'sonatype-lift[bot]'}, {'comment': '\r\n@sonatype-lift ignore', 'commenter': 'tisonkun'}, {'comment': ""I've recorded this as ignored for this pull request. If you change your mind, just comment `@sonatype-lift unignore`."", 'commenter': 'sonatype-lift[bot]'}]"
1828,zookeeper-server/src/test/java/org/apache/zookeeper/KerberosTicketRenewalTest.java,"@@ -0,0 +1,271 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper;
+
+import static org.apache.zookeeper.server.quorum.auth.MiniKdc.MAX_TICKET_LIFETIME;
+import static org.apache.zookeeper.server.quorum.auth.MiniKdc.MIN_TICKET_LIFETIME;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTimeout;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.security.Principal;
+import java.time.Duration;
+import java.util.Properties;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Supplier;
+import javax.security.auth.login.Configuration;
+import javax.security.auth.login.LoginException;
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.FilenameUtils;
+import org.apache.zookeeper.common.ZKConfig;
+import org.apache.zookeeper.server.quorum.auth.KerberosTestUtils;
+import org.apache.zookeeper.server.quorum.auth.MiniKdc;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * This test class is mainly testing the TGT renewal logic implemented in the org.apache.zookeeper.Login class.
+ */
+public class KerberosTicketRenewalTest {
+
+
+  private static final Logger LOG = LoggerFactory.getLogger(KerberosTicketRenewalTest.class);
+  private static final String JAAS_CONFIG_SECTION = ""ClientUsingKerberos"";
+  public static final String TICKET_LIFETIME = ""2000"";
+  private static File testTempDir;
+  private static MiniKdc kdc;
+  private static File kdcWorkDir;
+  private static String PRINCIPAL = KerberosTestUtils.getClientPrincipal();
+
+  TestableKerberosLogin login;
+
+  @BeforeAll
+  public static void setupClass() throws Exception {
+    // by default, we should wait at least 1 minute between subsequent TGT renewals.
+    // changing it to 500ms.
+    System.setProperty(Login.MIN_TIME_BEFORE_RELOGIN_CONFIG_KEY, ""500"");
+
+    testTempDir = ClientBase.createTmpDir();
+    startMiniKdcAndAddPrincipal();
+
+    String keytabFilePath = FilenameUtils.normalize(KerberosTestUtils.getKeytabFile(), true);
+
+    // note: we use ""refreshKrb5Config=true"" to refresh the kerberos config in the JVM,
+    // making sure that we use the latest config even if other tests already have been executed
+    // and initialized the kerberos client configs before)
+    String jaasEntries = """"
+      + ""ClientUsingKerberos {\n""
+      + ""  com.sun.security.auth.module.Krb5LoginModule required\n""
+      + ""  storeKey=\""false\""\n""
+      + ""  useTicketCache=\""false\""\n""
+      + ""  useKeyTab=\""true\""\n""
+      + ""  doNotPrompt=\""true\""\n""
+      + ""  debug=\""true\""\n""
+      + ""  refreshKrb5Config=\""true\""\n""
+      + ""  keyTab=\"""" + keytabFilePath + ""\""\n""
+      + ""  principal=\"""" + PRINCIPAL + ""\"";\n""
+      + ""};\n"";
+    setupJaasConfig(jaasEntries);
+  }
+
+  @AfterAll
+  public static void tearDownClass() {","[{'comment': 'We are missing to clear the Jaas system properties ', 'commenter': 'eolivelli'}, {'comment': 'yes, we clear the whole ""testTempDir"", which contains the jaas config file and also a subfolder for the current KDC cluster. I\'ll add a comment to clarify.\r\n(and the testTempDir is created with the standard ""ClientBase.createTmpDir();"" method)', 'commenter': 'symat'}]"
1828,zookeeper-server/src/test/java/org/apache/zookeeper/KerberosTicketRenewalTest.java,"@@ -0,0 +1,273 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper;
+
+import static org.apache.zookeeper.server.quorum.auth.MiniKdc.MAX_TICKET_LIFETIME;
+import static org.apache.zookeeper.server.quorum.auth.MiniKdc.MIN_TICKET_LIFETIME;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTimeout;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.security.Principal;
+import java.time.Duration;
+import java.util.Properties;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Supplier;
+import javax.security.auth.login.Configuration;
+import javax.security.auth.login.LoginException;
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.FilenameUtils;
+import org.apache.zookeeper.common.ZKConfig;
+import org.apache.zookeeper.server.quorum.auth.KerberosTestUtils;
+import org.apache.zookeeper.server.quorum.auth.MiniKdc;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * This test class is mainly testing the TGT renewal logic implemented
+ * in the org.apache.zookeeper.Login class.
+ */
+public class KerberosTicketRenewalTest {
+
+
+  private static final Logger LOG = LoggerFactory.getLogger(KerberosTicketRenewalTest.class);
+  private static final String JAAS_CONFIG_SECTION = ""ClientUsingKerberos"";
+  private static final String TICKET_LIFETIME = ""2000"";
+  private static File testTempDir;
+  private static MiniKdc kdc;
+  private static File kdcWorkDir;
+  private static String PRINCIPAL = KerberosTestUtils.getClientPrincipal();
+
+  TestableKerberosLogin login;
+
+  @BeforeAll
+  public static void setupClass() throws Exception {
+    // by default, we should wait at least 1 minute between subsequent TGT renewals.
+    // changing it to 500ms.
+    System.setProperty(Login.MIN_TIME_BEFORE_RELOGIN_CONFIG_KEY, ""500"");
+
+    testTempDir = ClientBase.createTmpDir();
+    startMiniKdcAndAddPrincipal();
+
+    String keytabFilePath = FilenameUtils.normalize(KerberosTestUtils.getKeytabFile(), true);
+
+    // note: we use ""refreshKrb5Config=true"" to refresh the kerberos config in the JVM,
+    // making sure that we use the latest config even if other tests already have been executed
+    // and initialized the kerberos client configs before)
+    String jaasEntries = """"
+      + ""ClientUsingKerberos {\n""
+      + ""  com.sun.security.auth.module.Krb5LoginModule required\n""
+      + ""  storeKey=\""false\""\n""
+      + ""  useTicketCache=\""false\""\n""
+      + ""  useKeyTab=\""true\""\n""
+      + ""  doNotPrompt=\""true\""\n""
+      + ""  debug=\""true\""\n""
+      + ""  refreshKrb5Config=\""true\""\n""
+      + ""  keyTab=\"""" + keytabFilePath + ""\""\n""
+      + ""  principal=\"""" + PRINCIPAL + ""\"";\n""
+      + ""};\n"";
+    setupJaasConfig(jaasEntries);
+  }
+
+  @AfterAll
+  public static void tearDownClass() {
+    System.clearProperty(Login.MIN_TIME_BEFORE_RELOGIN_CONFIG_KEY);
+    stopMiniKdc();
+    if (testTempDir != null) {
+      // the testTempDir contains the jaas config file and also the
+      // working folder of the currently running KDC server
+      FileUtils.deleteQuietly(testTempDir);
+    }
+  }
+
+  @AfterEach
+  public void tearDownTest() throws Exception {
+    if (login != null) {
+      login.shutdown();
+      login.logout();
+    }
+  }
+
+
+  /**
+   * We extend the regular Login class to be able to properly control the
+   * ""sleeping"" between the retry attempts of ticket refresh actions.
+   */
+  private static class TestableKerberosLogin extends Login {
+
+    private AtomicBoolean refreshFailed = new AtomicBoolean(false);
+    private CountDownLatch continueRefreshThread = new CountDownLatch(1);
+
+    public TestableKerberosLogin() throws LoginException {
+      super(JAAS_CONFIG_SECTION, (callbacks) -> {}, new ZKConfig());
+    }
+
+    @Override
+    protected void sleepBeforeRetryFailedRefresh() throws InterruptedException {
+      refreshFailed.set(true);
+      continueRefreshThread.await(10, TimeUnit.SECONDS);
+    }
+
+    public void assertRefreshFailsEventually(Duration timeout) {
+      assertEventually(timeout, () -> refreshFailed.get());
+    }
+
+    public void continueWithRetryAfterFailedRefresh() {
+      continueRefreshThread.countDown();
+    }
+  }
+
+
+  @Test
+  public void shouldLoginUsingKerberos() throws Exception {
+    login = new TestableKerberosLogin();
+    login.startThreadIfNeeded();
+
+    assertPrincipalLoggedIn();
+  }
+
+
+  @Test
+  public void shouldRenewTicketUsingKerberos() throws Exception {
+    login = new TestableKerberosLogin();
+    login.startThreadIfNeeded();
+
+    long initialLoginTime = login.getLastLogin();
+
+    // ticket lifetime is 2sec, so we will trigger ticket renewal in each ~1.5 sec
+    assertTicketRefreshHappenedUntil(Duration.ofSeconds(5));
+
+    assertPrincipalLoggedIn();
+    assertTrue(initialLoginTime < login.getLastLogin());
+  }
+
+
+  @Test
+  public void shouldRecoverIfKerberosNotAvailableForSomeTime() throws Exception {
+    login = new TestableKerberosLogin();
+    login.startThreadIfNeeded();
+
+    assertTicketRefreshHappenedUntil(Duration.ofSeconds(5));
+
+    stopMiniKdc();
+
+    // ticket lifetime is 2sec, so we will trigger ticket renewal in each ~1.5 sec
+    // the very next ticket renewal should fail (as KDC is offline)
+    login.assertRefreshFailsEventually(Duration.ofSeconds(5));
+
+    // now the ticket thread is ""sleeping"", it will retry the refresh later
+
+    // we restart KDC, then terminate the ""sleeping"" and expecting
+    // that the next retry should succeed
+    startMiniKdcAndAddPrincipal();
+    login.continueWithRetryAfterFailedRefresh();
+    assertTicketRefreshHappenedUntil(Duration.ofSeconds(5));
+
+    assertPrincipalLoggedIn();
+  }
+
+
+  private void assertPrincipalLoggedIn() {
+    assertEquals(PRINCIPAL, login.getUserName());
+    assertNotNull(login.getSubject());
+    assertEquals(1, login.getSubject().getPrincipals().size());
+    Principal actualPrincipal = login.getSubject().getPrincipals().iterator().next();
+    assertEquals(PRINCIPAL, actualPrincipal.getName());
+  }
+
+  private void assertTicketRefreshHappenedUntil(Duration timeout) {
+    long lastLoginTime = login.getLastLogin();
+    assertEventually(timeout, () -> login.getLastLogin() != lastLoginTime);
+  }
+
+  private static void assertEventually(Duration timeout, Supplier<Boolean> test) {
+    assertTimeout(timeout, () -> {
+      while (true) {
+        if (test.get()) {
+          return;
+        }
+        Thread.sleep(100);
+      }
+    });
+  }
+
+  public static void startMiniKdcAndAddPrincipal() throws Exception {
+    kdcWorkDir = createTmpDirInside(testTempDir);
+
+    Properties conf = MiniKdc.createConf();
+    conf.setProperty(MAX_TICKET_LIFETIME, TICKET_LIFETIME);
+    conf.setProperty(MIN_TICKET_LIFETIME, TICKET_LIFETIME);
+
+    kdc = new MiniKdc(conf, kdcWorkDir);
+    kdc.start();
+
+    String principalName = PRINCIPAL.substring(0, PRINCIPAL.lastIndexOf(""@""));
+    kdc.createPrincipal(new File(KerberosTestUtils.getKeytabFile()), principalName);
+  }
+
+  private static void stopMiniKdc() {
+    if (kdc != null) {
+      kdc.stop();
+      kdc = null;
+    }
+    if (kdcWorkDir != null) {
+      FileUtils.deleteQuietly(kdcWorkDir);
+      kdcWorkDir = null;
+    }
+  }
+
+  private static File createTmpDirInside(File parentDir) throws IOException {
+    File tmpFile = File.createTempFile(""test"", "".junit"", parentDir);
+    // don't delete tmpFile - this ensures we don't attempt to create
+    // a tmpDir with a duplicate name
+    File tmpDir = new File(tmpFile + "".dir"");
+    // never true if tmpfile does it's job
+    assertFalse(tmpDir.exists());
+    assertTrue(tmpDir.mkdirs());
+    return tmpDir;
+  }
+
+  private static void setupJaasConfig(String jaasEntries) {
+    try {
+      File saslConfFile = new File(testTempDir, ""jaas.conf"");
+      FileWriter fwriter = new FileWriter(saslConfFile);
+      fwriter.write(jaasEntries);
+      fwriter.close();
+      System.setProperty(""java.security.auth.login.config"", saslConfFile.getAbsolutePath());","[{'comment': ""Sorry I wasn't clear.\r\nIt looks to me we are not clearing this system property "", 'commenter': 'eolivelli'}, {'comment': ""Oh, I see. Nice catch, thanks!\r\n(you were clear, I just didn't get it ;) )"", 'commenter': 'symat'}]"
1835,pom.xml,"@@ -445,6 +445,97 @@
         <maven.compiler.release>8</maven.compiler.release>
       </properties>
     </profile>
+    <profile>
+      <id>clover</id>
+      <activation>
+        <activeByDefault>false</activeByDefault>
+        <property>
+          <name>clover</name>
+        </property>
+      </activation>
+      <properties>
+        <cloverDatabase>${project.build.directory}/clover/zookeeper-coverage.db</cloverDatabase>
+      </properties>
+      <build>
+        <plugins>
+          <plugin>
+            <groupId>org.openclover</groupId>
+            <artifactId>clover-maven-plugin</artifactId>
+            <configuration>
+              <includesAllSourceRoots>false</includesAllSourceRoots>
+              <includesTestSourceRoots>true</includesTestSourceRoots>
+              <cloverDatabase>${cloverDatabase}</cloverDatabase>
+              <targetPercentage>50%</targetPercentage>
+              <outputDirectory>${project.build.directory}/clover</outputDirectory>
+              <alwaysReport>true</alwaysReport>
+              <generateHistorical>false</generateHistorical>
+              <cloverDatabase>${project.build.directory}/clover/zookeeper-coverage.db</cloverDatabase>
+              <cloverMergeDatabase>${project.build.directory}/clover/zookeeper-coverage.db</cloverMergeDatabase>
+              <outputDirectory>${project.build.directory}/clover</outputDirectory>
+              <generateHtml>true</generateHtml>
+              <generateXml>true</generateXml>
+              <includesAllSourceRoots>false</includesAllSourceRoots>
+              <includesTestSourceRoots>true</includesTestSourceRoots>
+              <includes>
+                <include>org/apache/zookeeper/**/*</include>
+              </includes>
+              <excludes>
+                <exclude>org/apache/zookeeper/version/**/*</exclude>
+                  <exclude>**/ReadOnlyModeTest.java</exclude>","[{'comment': 'why are we exclude these (and only these) tests below?', 'commenter': 'symat'}, {'comment': 'These tests have methods that contain deprecation SuppressWarnings and if I do not exclude them the build fails.', 'commenter': 'horvathdora'}, {'comment': ""interesting... I'm not really sure why are these annotations present (or what happens if we remove them). Would be good to figure out and make it possible to include these tests to the coverage analysis. But that can be a separate story / PR later. "", 'commenter': 'symat'}]"
1835,pom.xml,"@@ -445,6 +445,97 @@
         <maven.compiler.release>8</maven.compiler.release>
       </properties>
     </profile>
+    <profile>
+      <id>clover</id>
+      <activation>
+        <activeByDefault>false</activeByDefault>
+        <property>
+          <name>clover</name>
+        </property>
+      </activation>
+      <properties>
+        <cloverDatabase>${project.build.directory}/clover/zookeeper-coverage.db</cloverDatabase>
+      </properties>
+      <build>
+        <plugins>
+          <plugin>
+            <groupId>org.openclover</groupId>
+            <artifactId>clover-maven-plugin</artifactId>
+            <configuration>
+              <includesAllSourceRoots>false</includesAllSourceRoots>
+              <includesTestSourceRoots>true</includesTestSourceRoots>
+              <cloverDatabase>${cloverDatabase}</cloverDatabase>
+              <targetPercentage>50%</targetPercentage>
+              <outputDirectory>${project.build.directory}/clover</outputDirectory>
+              <alwaysReport>true</alwaysReport>
+              <generateHistorical>false</generateHistorical>
+              <cloverDatabase>${project.build.directory}/clover/zookeeper-coverage.db</cloverDatabase>
+              <cloverMergeDatabase>${project.build.directory}/clover/zookeeper-coverage.db</cloverMergeDatabase>
+              <outputDirectory>${project.build.directory}/clover</outputDirectory>
+              <generateHtml>true</generateHtml>
+              <generateXml>true</generateXml>
+              <includesAllSourceRoots>false</includesAllSourceRoots>
+              <includesTestSourceRoots>true</includesTestSourceRoots>
+              <includes>
+                <include>org/apache/zookeeper/**/*</include>
+              </includes>
+              <excludes>
+                <exclude>org/apache/zookeeper/version/**/*</exclude>
+                  <exclude>**/ReadOnlyModeTest.java</exclude>
+                  <exclude>**/KeeperStateTest.java</exclude>
+              </excludes>
+            </configuration>
+            <executions>
+              <execution>
+                <id>clover-setup</id>
+                <phase>process-sources</phase>
+                <goals>
+                  <goal>setup</goal>
+                </goals>
+              </execution>
+              <execution>
+                <id>clover</id>
+                <phase>test</phase>
+                <goals>
+                  <goal>clover</goal>
+                </goals>
+              </execution>
+            </executions>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+    <profile>
+      <id>sonar</id>
+      <properties>
+        <sonar.php.coverage.reportPaths>${project.build.directory}/clover/clover.xml</sonar.php.coverage.reportPaths>
+      </properties>
+      <build>
+        <plugins>
+          <plugin>
+            <groupId>org.sonarsource.scanner.maven</groupId>
+            <artifactId>sonar-maven-plugin</artifactId>
+          </plugin>
+        </plugins>
+        <pluginManagement>
+          <plugins>
+            <plugin>
+              <groupId>org.sonarsource.scanner.maven</groupId>
+              <artifactId>sonar-maven-plugin</artifactId>
+              <version>3.7.0.1746</version>","[{'comment': 'could make a property for the sonar maven plugin version? (similar to the clover maven plugin version)', 'commenter': 'symat'}, {'comment': 'cool, thanks!', 'commenter': 'symat'}]"
1839,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1740,6 +1740,16 @@ and [SASL authentication for ZooKeeper](https://cwiki.apache.org/confluence/disp
     **New in 3.5.5:**
     TBD
 
+* *sslQuorumReloadCertFiles* :
+    (No Java system property)
+    **New in  3.5.5, 3.6.0:**
+    Allows Quorum SSL keyStore and trustStore reloading when the certificates on the filesystem change without having to restart the ZK process. Default: false
+
+* *client.certReload* :
+    (Java system property: **zookeeper.client.certReload**)
+    **New in 3.5.9:**","[{'comment': 'sorry \xa0@mathew-manu , I asked you to document this as ""new in 3.5.9"", it should be 3.9.0. Can you change it? I can merge after that.', 'commenter': 'symat'}, {'comment': 'Updated the version to 3.9.0', 'commenter': 'mathew-manu'}]"
1839,zookeeper-server/src/main/java/org/apache/zookeeper/server/auth/ProviderRegistry.java,"@@ -55,21 +55,27 @@ public static void initialize() {
             Enumeration<Object> en = System.getProperties().keys();
             while (en.hasMoreElements()) {
                 String k = (String) en.nextElement();
-                if (k.startsWith(AUTHPROVIDER_PROPERTY_PREFIX)) {
-                    String className = System.getProperty(k);
-                    try {
-                        Class<?> c = ZooKeeperServer.class.getClassLoader().loadClass(className);
-                        AuthenticationProvider ap = (AuthenticationProvider) c.getDeclaredConstructor().newInstance();
-                        authenticationProviders.put(ap.getScheme(), ap);
-                    } catch (Exception e) {
-                        LOG.warn(""Problems loading {}"", className, e);
-                    }
-                }
+                addOrUpdateProvider(k);
             }
             initialized = true;
         }
     }
 
+    public static void addOrUpdateProvider(String authKey) {
+        synchronized (ProviderRegistry.class) {
+            if (authKey.startsWith(AUTHPROVIDER_PROPERTY_PREFIX)) {
+                String className = System.getProperty(authKey);
+                try {
+                    Class<?> c = ZooKeeperServer.class.getClassLoader().loadClass(className);
+                    AuthenticationProvider ap = (AuthenticationProvider) c.getDeclaredConstructor().newInstance();
+                    authenticationProviders.put(ap.getScheme(), ap);
+                } catch (Exception e) {
+                    LOG.warn(""Problems loading {}"", className, e);
+                }
+            }
+        }
+    }
+
     public static ServerAuthenticationProvider getServerProvider(String scheme) {
         return WrappedAuthenticationProvider.wrap(getProvider(scheme));","[{'comment': ""*THREAD_SAFETY_VIOLATION:*  Read/Write race. Non-private method `ProviderRegistry.getServerProvider(...)` indirectly reads without synchronization from `auth.ProviderRegistry.initialized`. Potentially races with write in method `ProviderRegistry.reset()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not.\n\n(at-me [in a reply](https://help.sonatype.com/lift/talking-to-lift) with `help` or `ignore`)\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=205172643&lift_comment_rating=1) ] - [ [😕 Won't fix](https://www.sonatype.com/lift-comment-rating?comment=205172643&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=205172643&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=205172643&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=205172643&lift_comment_rating=5) ]"", 'commenter': 'sonatype-lift[bot]'}, {'comment': 'ProviderRegistry.reset() is only called from test. ', 'commenter': 'mathew-manu'}]"
1859,zookeeper-server/src/main/java/org/apache/zookeeper/server/watch/WatchManager.java,"@@ -305,13 +322,12 @@ public synchronized WatchesSummary getWatchesSummary() {
     @Override
     public void shutdown() { /* do nothing */ }
 
-    @Override
-    public int getRecursiveWatchQty() {
-        return watcherModeManager.getRecursiveQty();
+    int getRecursiveWatchQty() {
+        return recursiveWatchQty;","[{'comment': '*THREAD_SAFETY_VIOLATION:*  Read/Write race. Non-private method `WatchManager.getRecursiveWatchQty()` reads without synchronization from `this.recursiveWatchQty`. Potentially races with write in method `WatchManager.addWatch(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not.\n\n(at-me [in a reply](https://help.sonatype.com/lift/talking-to-lift) with `help` or `ignore`)', 'commenter': 'sonatype-lift[bot]'}]"
1859,zookeeper-server/src/main/java/org/apache/zookeeper/server/watch/WatchManager.java,"@@ -305,13 +322,12 @@ public synchronized WatchesSummary getWatchesSummary() {
     @Override
     public void shutdown() { /* do nothing */ }
 
-    @Override
-    public int getRecursiveWatchQty() {
-        return watcherModeManager.getRecursiveQty();
+    int getRecursiveWatchQty() {","[{'comment': 'Missing synchronised here', 'commenter': 'eolivelli'}, {'comment': 'Done. But I think it is not necessary as it is visible for testing. It is only accessed in `getPathParentIterator` which has been moved under `synchronized`. Anyway, it is not harm.', 'commenter': 'kezhuw'}]"
1859,zookeeper-server/src/main/java/org/apache/zookeeper/server/watch/WatchStats.java,"@@ -0,0 +1,105 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.watch;
+
+/**
+ * Statistics for multiple different watches on one node.
+ */
+public class WatchStats {","[{'comment': 'final?', 'commenter': 'eolivelli'}, {'comment': 'Done.', 'commenter': 'kezhuw'}]"
1859,zookeeper-server/src/main/java/org/apache/zookeeper/server/watch/WatchStats.java,"@@ -0,0 +1,105 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.watch;
+
+/**
+ * Statistics for multiple different watches on one node.
+ */
+public class WatchStats {
+    /**
+     * Stats that have no watchers attached.
+     *
+     * <p>This could be used as start point to compute new stats using {@link #addMode(WatcherMode)}.
+     */
+    public static final WatchStats NONE = new WatchStats(0);
+
+    static final WatchStats[] WATCH_STATS;","[{'comment': 'Using static variables makes it vary hard to write tests that start multiple nodes.\r\n\r\nCan we get rid of this static variable? Maybe you can create a wrapper class that contains the array', 'commenter': 'eolivelli'}, {'comment': 'Not sure whether I have got what you mean.\r\n\r\nBut both `WatchStats.flag` and `WatchStats.WATCH_STATS` are final. I tried to make `WatchStats` immutable and create all possible combinations upfront to avoid potential massive equal objects in case of large number of watches. Old implementation uses single `WatcherMode`. Not sure whether it is worth or not. But I think we have two options:\r\n* Use fixed number(aka. eight) of `WatchStats` objects.\r\n* Make `WatchStats` mutable and create one per session path.\r\n\r\nI am ok with either.', 'commenter': 'kezhuw'}, {'comment': ""sorry, I misunderstood the meaning of this class.\r\nit really looks like a enum.\r\n\r\nI believe that the current design works.\r\n\r\nbut, why aren'y you using a enum ?"", 'commenter': 'eolivelli'}, {'comment': '* The enum names might look like a mess. `StandardAndPersistentAndPersistentRecursive` and so on.\r\n* There is not direct access to some mebers from outside. For example `StandardAndPersistent` should only be generated from `WatchStats.addMode` or `WatchStats.removeMode` but not outside.', 'commenter': 'kezhuw'}, {'comment': 'Makes sense.\r\nThanks\r\n\r\nYour proposal sounds like a good design', 'commenter': 'eolivelli'}]"
1859,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -684,7 +684,9 @@ public String getMaxPrefixWithQuota(String path) {
     public void addWatch(String basePath, Watcher watcher, int mode) {
         WatcherMode watcherMode = WatcherMode.fromZooDef(mode);
         dataWatches.addWatch(basePath, watcher, watcherMode);
-        childWatches.addWatch(basePath, watcher, watcherMode);
+        if (watcherMode != WatcherMode.PERSISTENT_RECURSIVE) {
+            childWatches.addWatch(basePath, watcher, watcherMode);
+        }","[{'comment': 'IIRC we filter out child watch events for PRESISTENT_RECURSIVE in https://github.com/apache/zookeeper/pull/1820.\r\n\r\nDo changes in this file optimize the server-side logic while it\'s not user-visible and has nothing to do with ""Support different watch modes on same path""?', 'commenter': 'tisonkun'}, {'comment': 'No. For sole `WatcherMode.PERSISTENT_RECURSIVE`, there is no `EventType.NodeChildrenChanged` delivered as old code do filter in `WatcherManager#triggerWatch`.\r\n\r\nhttps://github.com/apache/zookeeper/blob/de8768807fc7a3fcabc9762b033cf59e695cf14b/zookeeper-server/src/main/java/org/apache/zookeeper/server/watch/WatchManager.java#L137-L141\r\n\r\nThe above changes do such filter in first place to reduce coding burden in `triggerWatch` phase.', 'commenter': 'kezhuw'}]"
1859,zookeeper-server/src/main/java/org/apache/zookeeper/server/watch/WatchManager.java,"@@ -232,49 +249,49 @@ public synchronized void dumpWatches(PrintWriter pwriter, boolean byPath) {
 
     @Override
     public synchronized boolean containsWatcher(String path, Watcher watcher) {
-        WatcherMode watcherMode = watcherModeManager.getWatcherMode(watcher, path);
-        PathParentIterator pathParentIterator = getPathParentIterator(path);
-        for (String localPath : pathParentIterator.asIterable()) {
-            Set<Watcher> watchers = watchTable.get(localPath);
-            if (!pathParentIterator.atParentPath()) {
-                if (watchers != null) {
-                    return true;    // at the leaf node, all watcher types match
-                }
-            }
-            if (watcherMode.isRecursive()) {
-                return true;
-            }
-        }
-        return false;
+        Set<Watcher> list = watchTable.get(path);","[{'comment': '@kezhuw Can you explain a bit why this change is correct?\r\n\r\nIt seems that previously, `containsWatcher (path, watcher)` will be `true` if any parent of the path has a persistent recursive watch.', 'commenter': 'tisonkun'}, {'comment': '> It seems that previously, containsWatcher (path, watcher) will be true if any parent of the path has a persistent recursive watch.\r\n\r\nIt is no true though it might intend to do so. Two cases for old code:\r\n* If there is a watch for (watcher, path), the first `return true` will hold.\r\n* If there is no watch for (watcher, path), `watcherMode` will be `WatcherMode.STANDARD`, no `return true` will hold:\r\n   * First `return true` will not hold as it only apply for leaf node where there is no such watch.\r\n   * Second `return true` will not hold as `WatcherMode.STANDARD` is no recursive.\r\n\r\nSo my change has same behavior as old code and also same to when it was introduced. I think this behavior meets what [`OpCode.checkWatches`](https://issues.apache.org/jira/browse/ZOOKEEPER-1910) expects which is the [sole client visible call to this method](https://github.com/apache/zookeeper/blob/de8768807fc7a3fcabc9762b033cf59e695cf14b/zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java#L507). Disregard [cheating behaviour of `ZooKeeper.removeWatches`](https://issues.apache.org/jira/browse/ZOOKEEPER-4625), removing sub nodes from recursive watching sounds quirk as similar one I saw in [ZOOKEEPER-4471](https://issues.apache.org/jira/browse/ZOOKEEPER-4471).\r\n\r\n', 'commenter': 'kezhuw'}, {'comment': 'Thanks for your explanation! I get it now :)', 'commenter': 'tisonkun'}]"
1867,pom.xml,"@@ -355,7 +355,7 @@
     <mockito.version>2.27.0</mockito.version>
     <hamcrest.version>1.3</hamcrest.version>
     <commons-cli.version>1.2</commons-cli.version>
-    <netty.version>4.1.73.Final</netty.version>
+    <netty.version>4.1.75.Final</netty.version>","[{'comment': 'Please raise PR first on master,\r\nnewer version is already available, lets upgrade to 4.1.76.Final', 'commenter': 'arshadmohammad'}, {'comment': '+1', 'commenter': 'shoothzj'}]"
1902,zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotSumFormatter.java,"@@ -0,0 +1,124 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.InputArchive;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.zookeeper.server.persistence.FileSnap;
+
+import java.io.BufferedInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.zip.Adler32;
+import java.util.zip.CheckedInputStream;
+
+/**
+ * Recursively processes a snapshot file collecting child node count and summarizes the data size
+ * below each node.
+ * ""starting_node"" defines the node where the recursion starts
+ * ""max_depth"" defines the depth where the tool still writes to the output.
+ * 0 means there is no depth limit, every node's stats will be displayed, 1 means it will
+ * only contain the starting node's and it's children's stats, 2 ads another level and so on.
+ * This ONLY affects the level of details displayed, NOT the calculation.
+ */
+@InterfaceAudience.Public public class SnapshotSumFormatter {
+
+  /**
+   * USAGE: SnapshotSumFormatter snapshot_file starting_node max_depth
+   *
+   */
+  public static void main(String[] args) throws Exception {
+    if (args.length != 3) {
+      System.err.println(""USAGE: SnapshotSumFormatter snapshot_file starting_node max_depth"");
+      System.exit(2);
+    }
+    int maxDepth = 0;
+    try {
+      maxDepth = Integer.valueOf(args[2]).intValue();
+    } catch (NumberFormatException e) {
+      System.err.println(""USAGE: SnapshotSumFormatter snapshot_file starting_node max_depth"");
+      System.exit(2);
+    }
+
+    new SnapshotSumFormatter().run(args[0], args[1], maxDepth);
+  }
+
+  public void run(String snapshotFileName, String startingNode, int maxDepth) throws IOException {
+    InputStream is =","[{'comment': '*[PATH_TRAVERSAL_IN](https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN):*  This API (java/io/FileInputStream.<init>(Ljava/lang/String;)V) reads a file whose location might be specified by user input\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=288734858&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=288734858&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=288734858&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=288734858&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=288734858&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}]"
1902,zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotSumFormatter.java,"@@ -0,0 +1,124 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.InputArchive;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.zookeeper.server.persistence.FileSnap;
+
+import java.io.BufferedInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.zip.Adler32;
+import java.util.zip.CheckedInputStream;
+
+/**
+ * Recursively processes a snapshot file collecting child node count and summarizes the data size
+ * below each node.
+ * ""starting_node"" defines the node where the recursion starts
+ * ""max_depth"" defines the depth where the tool still writes to the output.
+ * 0 means there is no depth limit, every node's stats will be displayed, 1 means it will
+ * only contain the starting node's and it's children's stats, 2 ads another level and so on.
+ * This ONLY affects the level of details displayed, NOT the calculation.
+ */
+@InterfaceAudience.Public public class SnapshotSumFormatter {
+
+  /**
+   * USAGE: SnapshotSumFormatter snapshot_file starting_node max_depth
+   *
+   */
+  public static void main(String[] args) throws Exception {
+    if (args.length != 3) {
+      System.err.println(""USAGE: SnapshotSumFormatter snapshot_file starting_node max_depth"");
+      System.exit(2);
+    }
+    int maxDepth = 0;
+    try {
+      maxDepth = Integer.valueOf(args[2]).intValue();
+    } catch (NumberFormatException e) {
+      System.err.println(""USAGE: SnapshotSumFormatter snapshot_file starting_node max_depth"");
+      System.exit(2);
+    }
+
+    new SnapshotSumFormatter().run(args[0], args[1], maxDepth);
+  }
+
+  public void run(String snapshotFileName, String startingNode, int maxDepth) throws IOException {
+    InputStream is =
+        new CheckedInputStream(new BufferedInputStream(new FileInputStream(snapshotFileName)),
+            new Adler32());
+    InputArchive ia = BinaryInputArchive.getArchive(is);","[{'comment': '*RESOURCE_LEAK:*  resource of type `java.util.zip.CheckedInputStream` acquired by call to `new()` at line 69 is not released after line 72.\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=288735234&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=288735234&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=288735234&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=288735234&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=288735234&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}]"
1902,zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotSumFormatter.java,"@@ -0,0 +1,124 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.InputArchive;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.zookeeper.server.persistence.FileSnap;
+
+import java.io.BufferedInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.zip.Adler32;
+import java.util.zip.CheckedInputStream;
+
+/**
+ * Recursively processes a snapshot file collecting child node count and summarizes the data size
+ * below each node.
+ * ""starting_node"" defines the node where the recursion starts
+ * ""max_depth"" defines the depth where the tool still writes to the output.
+ * 0 means there is no depth limit, every node's stats will be displayed, 1 means it will
+ * only contain the starting node's and it's children's stats, 2 ads another level and so on.
+ * This ONLY affects the level of details displayed, NOT the calculation.
+ */
+@InterfaceAudience.Public public class SnapshotSumFormatter {
+
+  /**
+   * USAGE: SnapshotSumFormatter snapshot_file starting_node max_depth
+   *
+   */
+  public static void main(String[] args) throws Exception {
+    if (args.length != 3) {
+      System.err.println(""USAGE: SnapshotSumFormatter snapshot_file starting_node max_depth"");
+      System.exit(2);
+    }
+    int maxDepth = 0;
+    try {
+      maxDepth = Integer.valueOf(args[2]).intValue();
+    } catch (NumberFormatException e) {
+      System.err.println(""USAGE: SnapshotSumFormatter snapshot_file starting_node max_depth"");
+      System.exit(2);
+    }
+
+    new SnapshotSumFormatter().run(args[0], args[1], maxDepth);
+  }
+
+  public void run(String snapshotFileName, String startingNode, int maxDepth) throws IOException {
+    InputStream is =
+        new CheckedInputStream(new BufferedInputStream(new FileInputStream(snapshotFileName)),
+            new Adler32());
+    InputArchive ia = BinaryInputArchive.getArchive(is);
+
+    FileSnap fileSnap = new FileSnap(null);
+
+    DataTree dataTree = new DataTree();
+    Map<Long,Integer> sessions = new HashMap<Long,Integer>();
+
+    fileSnap.deserialize(dataTree, sessions, ia);","[{'comment': '*RESOURCE_LEAK:*  resource of type `java.io.DataInputStream` acquired by call to `getArchive(...)` at line 72 is not released after line 79.\n**Note**: potential exception at line 79\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=288735472&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=288735472&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=288735472&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=288735472&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=288735472&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}]"
1902,bin/zkSnapShotSumToolkit.sh,"@@ -0,0 +1,38 @@
+#!/usr/bin/env bash
+
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#
+# If this scripted is run out of /usr/bin or some other system bin directory
+# it should be linked to and not copied. Things like java jar files are found
+# relative to the canonical path of this script.
+#
+
+# use POSIX interface, symlink is followed automatically
+ZOOBIN=""${BASH_SOURCE-$0}""
+ZOOBIN=""$(dirname ""${ZOOBIN}"")""
+ZOOBINDIR=""$(cd ""${ZOOBIN}""; pwd)""","[{'comment': '*[SC2164](https://github.com/koalaman/shellcheck/wiki/SC2164):*  Use \'cd ... || exit\' or \'cd ... || return\' in case cd fails.\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=288735989&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=288735989&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=288735989&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=288735989&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=288735989&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}, {'comment': '*[SC2164](https://github.com/koalaman/shellcheck/wiki/SC2164):*  Use \'cd ... || exit\' or \'cd ... || return\' in case cd fails.\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=289523767&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=289523767&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=289523767&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=289523767&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=289523767&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}, {'comment': 'I think you can ignore this.', 'commenter': 'anmolnar'}]"
1902,bin/zkSnapShotSumToolkit.sh,"@@ -0,0 +1,38 @@
+#!/usr/bin/env bash
+
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#
+# If this scripted is run out of /usr/bin or some other system bin directory
+# it should be linked to and not copied. Things like java jar files are found
+# relative to the canonical path of this script.
+#
+
+# use POSIX interface, symlink is followed automatically
+ZOOBIN=""${BASH_SOURCE-$0}""
+ZOOBIN=""$(dirname ""${ZOOBIN}"")""
+ZOOBINDIR=""$(cd ""${ZOOBIN}""; pwd)""
+
+if [ -e ""$ZOOBIN/../libexec/zkEnv.sh"" ]; then
+  . ""$ZOOBINDIR""/../libexec/zkEnv.sh
+else
+  . ""$ZOOBINDIR""/zkEnv.sh","[{'comment': '*[SC1091](https://github.com/koalaman/shellcheck/wiki/SC1091):*  Not following: ./zkEnv.sh was not specified as input (see shellcheck -x).\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=288735991&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=288735991&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=288735991&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=288735991&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=288735991&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}, {'comment': '*[SC1091](https://github.com/koalaman/shellcheck/wiki/SC1091):*  Not following: ./zkEnv.sh was not specified as input (see shellcheck -x).\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=289523769&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=289523769&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=289523769&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=289523769&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=289523769&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}, {'comment': 'Same here.', 'commenter': 'anmolnar'}]"
1902,bin/zkSnapShotSumToolkit.sh,"@@ -0,0 +1,38 @@
+#!/usr/bin/env bash
+
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#
+# If this scripted is run out of /usr/bin or some other system bin directory
+# it should be linked to and not copied. Things like java jar files are found
+# relative to the canonical path of this script.
+#
+
+# use POSIX interface, symlink is followed automatically
+ZOOBIN=""${BASH_SOURCE-$0}""
+ZOOBIN=""$(dirname ""${ZOOBIN}"")""
+ZOOBINDIR=""$(cd ""${ZOOBIN}""; pwd)""
+
+if [ -e ""$ZOOBIN/../libexec/zkEnv.sh"" ]; then
+  . ""$ZOOBINDIR""/../libexec/zkEnv.sh","[{'comment': '*[SC1091](https://github.com/koalaman/shellcheck/wiki/SC1091):*  Not following: ./../libexec/zkEnv.sh was not specified as input (see shellcheck -x).\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=288735990&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=288735990&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=288735990&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=288735990&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=288735990&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}, {'comment': '*[SC1091](https://github.com/koalaman/shellcheck/wiki/SC1091):*  Not following: ./../libexec/zkEnv.sh was not specified as input (see shellcheck -x).\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=289523768&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=289523768&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=289523768&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=289523768&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=289523768&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}, {'comment': 'Maybe you could try adding:\r\n```\r\n# shellcheck source=somefile\r\n```\r\nBased on: https://github.com/koalaman/shellcheck/wiki/SC1091\r\n\r\nOtherwise feel free to ignore this one too.', 'commenter': 'anmolnar'}, {'comment': ""@anmolnar I'm not sure adding shellcheck is helpful here. The `libexec` folder does not exist at this point so we can not verify if it has the file. I could add `# shellcheck source=/dev/null` but that basically circumvents the shellcheck and at that point I would prefer not to touch the script at all."", 'commenter': 'BukrosSzabolcs'}, {'comment': ""I mean\r\n```\r\n# shellcheck source=/bin/zkEnv.sh\r\n```\r\nDon't waste too much time on this, feel free to ignore the comment."", 'commenter': 'anmolnar'}]"
1902,bin/zkSnapShotSumToolkit.sh,"@@ -0,0 +1,38 @@
+#!/usr/bin/env bash
+
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#
+# If this scripted is run out of /usr/bin or some other system bin directory
+# it should be linked to and not copied. Things like java jar files are found
+# relative to the canonical path of this script.
+#
+
+# use POSIX interface, symlink is followed automatically
+ZOOBIN=""${BASH_SOURCE-$0}""
+ZOOBIN=""$(dirname ""${ZOOBIN}"")""
+ZOOBINDIR=""$(cd ""${ZOOBIN}""; pwd)""
+
+if [ -e ""$ZOOBIN/../libexec/zkEnv.sh"" ]; then
+  . ""$ZOOBINDIR""/../libexec/zkEnv.sh
+else
+  . ""$ZOOBINDIR""/zkEnv.sh
+fi
+
+""$JAVA"" -cp ""$CLASSPATH"" $JVMFLAGS \","[{'comment': '*[SC2086](https://github.com/koalaman/shellcheck/wiki/SC2086):*  Double quote to prevent globbing and word splitting.\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=288735992&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=288735992&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=288735992&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=288735992&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=288735992&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}, {'comment': '*[SC2086](https://github.com/koalaman/shellcheck/wiki/SC2086):*  Double quote to prevent globbing and word splitting.\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=289523770&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=289523770&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=289523770&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=289523770&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=289523770&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}, {'comment': '@sonatype-lift ignoreall', 'commenter': 'BukrosSzabolcs'}, {'comment': 'The **ignoreall** command is active on this PR, all the existing Lift issues are ignored.', 'commenter': 'sonatype-lift[bot]'}, {'comment': 'Why not adding double-quotes to `$JVMFLAGS` instead?', 'commenter': 'anmolnar'}, {'comment': 'Fixing this', 'commenter': 'BukrosSzabolcs'}]"
1902,zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotSumFormatter.java,"@@ -0,0 +1,124 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.InputArchive;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.zookeeper.server.persistence.FileSnap;
+
+import java.io.BufferedInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.zip.Adler32;
+import java.util.zip.CheckedInputStream;
+
+/**
+ * Recursively processes a snapshot file collecting child node count and summarizes the data size
+ * below each node.
+ * ""starting_node"" defines the node where the recursion starts
+ * ""max_depth"" defines the depth where the tool still writes to the output.
+ * 0 means there is no depth limit, every node's stats will be displayed, 1 means it will
+ * only contain the starting node's and it's children's stats, 2 ads another level and so on.
+ * This ONLY affects the level of details displayed, NOT the calculation.
+ */
+@InterfaceAudience.Public public class SnapshotSumFormatter {
+
+  /**
+   * USAGE: SnapshotSumFormatter snapshot_file starting_node max_depth
+   *
+   */
+  public static void main(String[] args) throws Exception {
+    if (args.length != 3) {
+      System.err.println(""USAGE: SnapshotSumFormatter snapshot_file starting_node max_depth"");","[{'comment': 'could you be a bit more ""helpful"" :) here? like:\r\n```\r\nSnapshotSumFormatter is a tool traversing the whole snapshot and summing up the data in the subtrees.\r\n\r\nUSAGE:   \r\n\r\nSnapshotSumFormatter  <snapshot_file>  <starting_node>  <max_depth>\r\n\r\n    snapshot_file:    path to the zookeeper snapshot\r\n    starting_node:    the path in the zookeeper tree where the traversal should begin\r\n    max_depth:        the depth where you would like to get the output (data in paths longer than the depth will be still summed up, but won\'t be printed out)\r\n```\r\n\r\nOr something like this...', 'commenter': 'symat'}, {'comment': 'I just saw your documentation in the code above the class, that might be even better...', 'commenter': 'symat'}, {'comment': ""@symat Thank you for your feedback!\r\nI'm trying to follow the patterns in SnapshotFormatter and will apply or ignore sonatypes based on that. If that is acceptable for you.\r\nI have extended the Tools documentation with a section on the new tool. Renamed it to SnapshotRecursiveSummar / zkSnapshotRecursiveSummaryToolkit.sh and added an extended usage based on your suggestion.\r\n\r\n> what about also printing the number of the children ZNodes?\r\n\r\nThat is already printed. Please check the example output in the jira ticket. Or you would like it presented in some other way?"", 'commenter': 'BukrosSzabolcs'}]"
1902,zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotRecursiveSummary.java,"@@ -0,0 +1,138 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.InputArchive;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.zookeeper.server.persistence.FileSnap;
+import org.apache.zookeeper.server.persistence.SnapStream;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Recursively processes a snapshot file collecting child node count and summarizes the data size
+ * below each node.
+ * ""starting_node"" defines the node where the recursion starts
+ * ""max_depth"" defines the depth where the tool still writes to the output.
+ * 0 means there is no depth limit, every non-leaf node's stats will be displayed, 1 means it will
+ * only contain the starting node's and it's children's stats, 2 ads another level and so on.
+ * This ONLY affects the level of details displayed, NOT the calculation.
+ */
+@InterfaceAudience.Public public class SnapshotRecursiveSummary {
+
+  /**
+   * USAGE: SnapsotRecursiveSummary snapshot_file starting_node max_depth
+   *
+   */
+  public static void main(String[] args) throws Exception {
+    if (args.length != 3) {
+      System.err.println(getUsage());
+      System.exit(2);
+    }
+    int maxDepth = 0;
+    try {
+      maxDepth = Integer.valueOf(args[2]).intValue();
+    } catch (NumberFormatException e) {
+      System.err.println(getUsage());
+      System.exit(2);
+    }
+
+    new SnapshotRecursiveSummary().run(args[0], args[1], maxDepth);
+  }
+
+  public void run(String snapshotFileName, String startingNode, int maxDepth) throws IOException {
+    File snapshotFile = new File(snapshotFileName);","[{'comment': '*[PATH_TRAVERSAL_IN](https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN):*  This API (java/io/File.<init>(Ljava/lang/String;)V) reads a file whose location might be specified by user input\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=289522632&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=289522632&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=289522632&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=289522632&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=289522632&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}, {'comment': '@sonatype-lift ignore', 'commenter': 'BukrosSzabolcs'}, {'comment': ""I've recorded this as ignored for this pull request. If you change your mind, just comment `@sonatype-lift unignore`."", 'commenter': 'sonatype-lift[bot]'}]"
1902,zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotRecursiveSummary.java,"@@ -0,0 +1,138 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.InputArchive;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.zookeeper.server.persistence.FileSnap;
+import org.apache.zookeeper.server.persistence.SnapStream;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Recursively processes a snapshot file collecting child node count and summarizes the data size
+ * below each node.
+ * ""starting_node"" defines the node where the recursion starts
+ * ""max_depth"" defines the depth where the tool still writes to the output.
+ * 0 means there is no depth limit, every non-leaf node's stats will be displayed, 1 means it will
+ * only contain the starting node's and it's children's stats, 2 ads another level and so on.
+ * This ONLY affects the level of details displayed, NOT the calculation.
+ */
+@InterfaceAudience.Public public class SnapshotRecursiveSummary {
+
+  /**
+   * USAGE: SnapsotRecursiveSummary snapshot_file starting_node max_depth
+   *
+   */
+  public static void main(String[] args) throws Exception {
+    if (args.length != 3) {
+      System.err.println(getUsage());
+      System.exit(2);
+    }
+    int maxDepth = 0;
+    try {
+      maxDepth = Integer.valueOf(args[2]).intValue();
+    } catch (NumberFormatException e) {
+      System.err.println(getUsage());
+      System.exit(2);
+    }
+
+    new SnapshotRecursiveSummary().run(args[0], args[1], maxDepth);
+  }
+
+  public void run(String snapshotFileName, String startingNode, int maxDepth) throws IOException {
+    File snapshotFile = new File(snapshotFileName);
+    try (InputStream is = SnapStream.getInputStream(snapshotFile)) {
+      InputArchive ia = BinaryInputArchive.getArchive(is);
+
+      FileSnap fileSnap = new FileSnap(null);
+
+      DataTree dataTree = new DataTree();
+      Map<Long,Integer> sessions = new HashMap<Long,Integer>();
+
+      fileSnap.deserialize(dataTree, sessions, ia);","[{'comment': '*RESOURCE_LEAK:*  resource of type `java.io.DataInputStream` acquired by call to `getArchive(...)` at line 69 is not released after line 76.\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=289522818&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=289522818&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=289522818&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=289522818&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=289522818&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}, {'comment': ""I don't get this warning message: the `inputStream` is defined in the `try()` clause which means it will be automatically released at the end of the block. What's wrong?"", 'commenter': 'anmolnar'}, {'comment': '`BinaryInputArchive.getArchive(is)` creates a new DataInputStream based on the inputStream. The `try()` only closes the inputStream, the DataInputStream is technically never closed. I see this as a non-issue and this is how SnapshotFormatter is written too, so it should be fine like this.', 'commenter': 'BukrosSzabolcs'}, {'comment': ""Yes, because it's a standalone tool. You can ignore that."", 'commenter': 'anmolnar'}]"
1905,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -328,11 +322,12 @@ protected void pRequest2Txn(int type, long zxid, Request request, Record record,
         case OpCode.create2:
         case OpCode.createTTL:
         case OpCode.createContainer: {
-            pRequest2TxnCreate(type, request, record, deserialize);
+            pRequest2TxnCreate(type, request, record);","[{'comment': '*THREAD_SAFETY_VIOLATION:*  Unprotected write. Non-private method `PrepRequestProcessor.pRequest2Txn(...)` indirectly writes to field `server.ZooKeeperServer.RATE_LOGGER.count` outside of synchronization.\n Reporting because this access may occur on a background thread.\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=299351388&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=299351388&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=299351388&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=299351388&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=299351388&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}]"
1905,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -387,9 +379,6 @@ protected void pRequest2Txn(int type, long zxid, Request request, Record record,","[{'comment': '*THREAD_SAFETY_VIOLATION:*  Read/Write race. Non-private method `PrepRequestProcessor.pRequest2Txn(...)` indirectly reads without synchronization from `auth.ProviderRegistry.initialized`. Potentially races with write in method `PrepRequestProcessor.pRequest2Txn(...)`.\n Reporting because this access may occur on a background thread.\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=299351395&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=299351395&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=299351395&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=299351395&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=299351395&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}]"
1905,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -311,13 +310,8 @@ private String validatePathForCreate(String path, long sessionId) throws BadArgu
     /**
      * This method will be called inside the ProcessRequestThread, which is a
      * singleton, so there will be a single thread calling this code.
-     *
-     * @param type
-     * @param zxid
-     * @param request
-     * @param record
      */
-    protected void pRequest2Txn(int type, long zxid, Request request, Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException {
+    protected void pRequest2Txn(int type, long zxid, Request request, Record record) throws KeeperException, IOException, RequestProcessorException {
         if (request.getHdr() == null) {
             request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,","[{'comment': '*THREAD_SAFETY_VIOLATION:*  Unprotected write. Non-private method `PrepRequestProcessor.pRequest2Txn(...)` indirectly writes to field `request.hdr` outside of synchronization.\n Reporting because this access may occur on a background thread.\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=299352045&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=299352045&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=299352045&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=299352045&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=299352045&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}]"
1905,zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java,"@@ -116,9 +115,8 @@ private Request makeUpgradeRequest(long sessionId) {
         synchronized (upgradeableSessionTracker) {","[{'comment': '*[SynchronizeOnNonFinalField](https://errorprone.info/bugpattern/SynchronizeOnNonFinalField):*  Synchronizing on non-final fields is not safe: if the field is ever updated, different threads may end up locking on different objects.\n\nReply with *""**@sonatype-lift help**""* for info about LiftBot commands.\nReply with *""**@sonatype-lift ignore**""* to tell LiftBot to leave out the above finding from this PR.\nReply with *""**@sonatype-lift ignoreall**""* to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.\n\nWhen talking to LiftBot, you need to **refresh** the page to see its response. [Click here](https://help.sonatype.com/lift/talking-to-lift) to get to know more about LiftBot commands.\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=299364090&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=299364090&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=299364090&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=299364090&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=299364090&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}]"
1905,zookeeper-server/src/main/java/org/apache/zookeeper/server/ContainerManager.java,"@@ -129,8 +128,8 @@ public void checkContainers() throws InterruptedException {
         for (String containerPath : getCandidates()) {
             long startMs = Time.currentElapsedTime();
 
-            ByteBuffer path = ByteBuffer.wrap(containerPath.getBytes(UTF_8));
-            Request request = new Request(null, 0, 0, ZooDefs.OpCode.deleteContainer, path, null);
+            DeleteTxn txn = new DeleteTxn(containerPath);
+            Request request = new Request(null, 0, 0, ZooDefs.OpCode.deleteContainer, RequestRecord.fromRecord(txn), null);","[{'comment': ""Well. The serialization logics are different from Jute's string and UTF-8 string. This can make it impossible rolling update as new server send new DeleteTxn but old server cannot recognize it.\r\n\r\nPending to revert."", 'commenter': 'tisonkun'}, {'comment': 'Reverted at a3ca9c41cbfc50ad08473c62ca3bfb2070de9269', 'commenter': 'tisonkun'}]"
1905,zookeeper-server/src/main/java/org/apache/zookeeper/server/ByteBufferRequestRecord.java,"@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *uuuuu
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""/RequuuAS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import org.apache.jute.Record;
+
+public class ByteBufferRequestRecord implements RequestRecord {
+
+    private final ByteBuffer request;
+
+    private volatile Record record;
+
+    public ByteBufferRequestRecord(ByteBuffer request) {
+        this.request = request;
+    }
+
+    @Override
+    public <T extends Record> T readRecord(Class<T> clazz) throws IOException {
+        if (record != null) {
+            try {
+                return clazz.cast(record);","[{'comment': '`return (T) record`\r\nit should be more efficient.', 'commenter': 'eolivelli'}, {'comment': 'resolved at 03b16e330ddd4c0bee2d8b1591ca74b2a35748af', 'commenter': 'tisonkun'}]"
1905,zookeeper-server/src/main/java/org/apache/zookeeper/server/ByteBufferRequestRecord.java,"@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *uuuuu
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""/RequuuAS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import org.apache.jute.Record;
+
+public class ByteBufferRequestRecord implements RequestRecord {
+
+    private final ByteBuffer request;
+
+    private volatile Record record;
+
+    public ByteBufferRequestRecord(ByteBuffer request) {
+        this.request = request;
+    }
+
+    @Override
+    public <T extends Record> T readRecord(Class<T> clazz) throws IOException {
+        if (record != null) {
+            try {
+                return clazz.cast(record);
+            } catch (Exception e) {
+                throw new IOException(e);
+            }
+        }
+
+        try {
+            record = clazz.getDeclaredConstructor().newInstance();","[{'comment': ""we shouldn't use reflection here in a hot path (while processing requests) reflection is really slow\r\n"", 'commenter': 'eolivelli'}, {'comment': 'Make sense. I think a `Supplier<T>` as `T::new` can help here. ', 'commenter': 'tisonkun'}, {'comment': 'resolved at 03b16e330ddd4c0bee2d8b1591ca74b2a35748af', 'commenter': 'tisonkun'}]"
1905,zookeeper-server/src/main/java/org/apache/zookeeper/server/ByteBufferRequestRecord.java,"@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *uuuuu
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""/RequuuAS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import org.apache.jute.Record;
+
+public class ByteBufferRequestRecord implements RequestRecord {
+
+    private final ByteBuffer request;
+
+    private volatile Record record;
+
+    public ByteBufferRequestRecord(ByteBuffer request) {
+        this.request = request;
+    }
+
+    @Override
+    public <T extends Record> T readRecord(Class<T> clazz) throws IOException {","[{'comment': 'we should avoid reflection at all.\r\nthe list of PDUs is known, we can have a static map', 'commenter': 'eolivelli'}, {'comment': 'resolved at 03b16e330ddd4c0bee2d8b1591ca74b2a35748af', 'commenter': 'tisonkun'}]"
1905,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -359,9 +355,6 @@ protected void pRequest2Txn(int type, long zxid, Request request, Record record,
         case OpCode.delete:
             zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
             DeleteRequest deleteRequest = (DeleteRequest) record;
-            if (deserialize) {","[{'comment': 'is this a behaviour change ? were is the deserialisation happening ?\r\nare we doing it more times now ?', 'commenter': 'eolivelli'}, {'comment': 'No. Previously we need this boolean flag because, after deserializing `MultiOperationRecord`, the subrequest is an in-memory data structure - there are no more bytes in the request to be deserialized.\r\n\r\nNow, we always deserialize in `pRequestHelper`, no serialization happens in `pRequest2Txn`. Besides, we always serialize at most once in `RequestRecord`:\r\n\r\n```java\r\npublic class ByteBufferRequestRecord {\r\n    @Override\r\n    public <T extends Record> T readRecord(Supplier<T> constructor) throws IOException {\r\n        if (record != null) {\r\n            return (T) record;\r\n        }\r\n        // deserialization\r\n    }\r\n}\r\n\r\npublic class SimpleRequestRecord {\r\n    @Override\r\n    public <T extends Record> T readRecord(Supplier<T> constructor) {\r\n        return (T) record;\r\n    }\r\n}\r\n```', 'commenter': 'tisonkun'}]"
1905,zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java,"@@ -387,9 +380,6 @@ protected void pRequest2Txn(int type, long zxid, Request request, Record record,","[{'comment': '💬 2 similar findings have been found in this PR\n\n---\n\n*THREAD_SAFETY_VIOLATION:*  Read/Write race. Non-private method `PrepRequestProcessor.pRequest2Txn(...)` indirectly reads without synchronization from `auth.ProviderRegistry.initialized`. Potentially races with write in method `PrepRequestProcessor.pRequest2Txn(...)`.\n Reporting because this access may occur on a background thread.\n\n---\n\n<details><summary><b>🔎 Expand here to view all instances of this finding</b></summary><br/>\n\n<div align=""center"">\n\n| **File Path** | **Line Number** |\n| ------------- | ------------- |\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java | [326](https://github.com/tisonkun/zookeeper/blob/4cc0467b4dd03420937beb4861b531e4e34d700a/zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java#L326)|\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java | [317](https://github.com/tisonkun/zookeeper/blob/4cc0467b4dd03420937beb4861b531e4e34d700a/zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java#L317)|\n<p><a href=""https://lift.sonatype.com/results/github.com/apache/zookeeper/01GEGTVXP855YRJPBYZE6FX2D1?t=Infer|THREAD_SAFETY_VIOLATION"" target=""_blank"">Visit the Lift Web Console</a> to find more details in your report.</p></div></details>\n\n\n\n---\n\n<details><summary><b>ℹ️ Learn about @sonatype-lift commands</b></summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=341779767&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=341779767&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=341779767&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=341779767&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=341779767&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}]"
1943,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -535,23 +541,46 @@ public void loadData() throws IOException, InterruptedException {
         takeSnapshot();","[{'comment': '💬 2 similar findings have been found in this PR\n\n---\n\n*THREAD_SAFETY_VIOLATION:*  Unprotected write. Non-private method `ZooKeeperServer.loadData()` indirectly writes to field `this.zkDb.dataTree.RATE_LOGGER.count` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not.\n\n---\n\n<details><summary><b>🔎 Expand here to view all instances of this finding</b></summary><br/>\n\n<div align=""center"">\n\n| **File Path** | **Line Number** |\n| ------------- | ------------- |\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java | [567](https://github.com/li4wang/zookeeper/blob/a71842e8ded132c092c94a6e064d4714503cb108/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java#L567)|\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java | [549](https://github.com/li4wang/zookeeper/blob/a71842e8ded132c092c94a6e064d4714503cb108/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java#L549)|\n<p><a href=""https://lift.sonatype.com/results/github.com/apache/zookeeper/01GHCQ07666B32ET7QXDPQDD9Y?t=Infer|THREAD_SAFETY_VIOLATION"" target=""_blank"">Visit the Lift Web Console</a> to find more details in your report.</p></div></details>\n\n\n\n---\n\n<details><summary><b>ℹ️ Learn about @sonatype-lift commands</b></summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=351724297&lift_comment_rating=1) ] - [ [😕 Won\'t fix](https://www.sonatype.com/lift-comment-rating?comment=351724297&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=351724297&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=351724297&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=351724297&lift_comment_rating=5) ]', 'commenter': 'sonatype-lift[bot]'}]"
1943,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/StreamOutputter.java,"@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.admin;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import org.apache.zookeeper.common.IOUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A class for streaming data out.
+ */
+public class StreamOutputter implements CommandOutputter{
+    private static final Logger LOG = LoggerFactory.getLogger(StreamOutputter.class);
+
+    public StreamOutputter() {
+    }
+
+    @Override
+    public String getContentType() {
+        return ""application/octet-stream"";
+    }
+
+    @Override
+    public void output(final CommandResponse response, final OutputStream os) {
+        try (final InputStream is = response.getInputStream()){
+            IOUtils.copyBytes(is, os, 1024, true);
+        } catch (final IOException e) {
+            LOG.error(""Exception occurred when streaming out data"", e);","[{'comment': 'follow up enhancement: we could print the remote address of the client, it will help troubleshooting problems, for instance when the client shuts down the connection too early', 'commenter': 'eolivelli'}, {'comment': 'Good point. Enhanced.', 'commenter': 'li4wang'}]"
1943,zookeeper-server/src/test/java/org/apache/zookeeper/server/admin/SnapshotCommandTest.java,"@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.admin;
+
+import static org.apache.zookeeper.server.admin.Commands.SnapshotCommand.ADMIN_SNAPSHOT_ENABLED;
+import static org.apache.zookeeper.server.admin.Commands.SnapshotCommand.ADMIN_SNAPSHOT_INTERVAL;
+import static org.apache.zookeeper.server.admin.Commands.SnapshotCommand.REQUEST_QUERY_PARAM_STREAMING;
+import static org.apache.zookeeper.server.admin.JettyAdminServerTest.URL_FORMAT;
+import static org.apache.zookeeper.server.admin.JettyAdminServerTest.jettyAdminPort;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.UnsupportedEncodingException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.net.URLEncoder;
+import java.nio.file.Files;
+import java.util.HashMap;
+import java.util.Map;
+import javax.servlet.http.HttpServletResponse;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.common.IOUtils;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.apache.zookeeper.server.ZooKeeperServer;
+import org.apache.zookeeper.test.ClientBase;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInstance;
+import org.junit.jupiter.api.io.TempDir;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@TestInstance(TestInstance.Lifecycle.PER_CLASS)
+public class SnapshotCommandTest extends ZKTestCase {
+    private static final Logger LOG = LoggerFactory.getLogger(SnapshotCommandTest.class);
+
+    private static final String PATH = ""/snapshot_test"";
+    private static final int NODE_COUNT = 10;
+
+    private final String hostPort =  ""127.0.0.1:"" + PortAssignment.unique();
+    private ServerCnxnFactory cnxnFactory;
+    private JettyAdminServer adminServer;
+    private ZooKeeperServer zks;
+    private ZooKeeper zk;
+
+    @TempDir
+    static File dataDir;
+
+    @TempDir
+    static File logDir;
+
+    @BeforeAll
+    public void setup() throws Exception {
+        // start ZookeeperServer
+        System.setProperty(""zookeeper.4lw.commands.whitelist"", ""*"");","[{'comment': 'please ""clear"" all the system properties you set in this method in the ´teardown` method', 'commenter': 'eolivelli'}, {'comment': 'Yes, all the system properties are cleared.', 'commenter': 'li4wang'}]"
1943,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -1208,7 +1208,32 @@ property, when available, is noted below.
 
     The default value is false.
 
-
+* *serializeLastProcessedZxid.enabled*
+  (Jave system property: **zookeeper.serializeLastProcessedZxid.enabled**)","[{'comment': 'If this option is backward and forward compatible, is there any reason why somebody wanted to turn it off?', 'commenter': 'anmolnar'}, {'comment': ""No, I don't see anyone wants to turn it off unless we run into unexpected issue, and I think it doesn't hurt to have the option available for now."", 'commenter': 'li4wang'}, {'comment': ""Yeah, it probably doesn't hurt, but we should not implement something just because it doesn't hurt. Also don't need to prepare feature flags for unexcpeted issues. These are not valid reasons. \r\n\r\nEither way, you can leave it as it is. One more thing: the doc mentions that this option is required for the Admin's snapshot command to work properly. If that's the case the Admin command should check whether this option is enabled, but I don't see the check there, right?"", 'commenter': 'anmolnar'}, {'comment': 'Yes, you are right. Added the check and also the unit test.', 'commenter': 'li4wang'}]"
1943,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/Commands.java,"@@ -496,6 +506,87 @@ public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
 
     }
 
+    /**
+     * Take a snapshot of current server and stream out the data.
+     *
+     *  Argument:
+     *   - ""streaming"": optional String to indicate whether streaming out data
+     *
+     *  Returned snapshot as stream if streaming is true and metadata of the snapshot
+     *   - ""last_zxid"": String
+     *   - ""snapshot_size"": String
+     */
+    public static class SnapshotCommand extends CommandBase {
+        static final String REQUEST_QUERY_PARAM_STREAMING = ""streaming"";
+
+        static final String RESPONSE_HEADER_LAST_ZXID = ""last_zxid"";
+        static final String RESPONSE_HEADER_SNAPSHOT_SIZE = ""snapshot_size"";
+
+        static final String ADMIN_SNAPSHOT_ENABLED = ""zookeeper.admin.snapshot.enabled"";
+        static final String ADMIN_SNAPSHOT_INTERVAL = ""zookeeper.admin.snapshot.intervalInMS"";
+
+        private static final long snapshotInterval = Integer.parseInt(System.getProperty(ADMIN_SNAPSHOT_INTERVAL, ""300000""));
+
+        private final RateLimiter rateLimiter;
+
+        public SnapshotCommand() {
+            super(Arrays.asList(""snapshot"", ""snap""));
+            rateLimiter = new RateLimiter(1, snapshotInterval, TimeUnit.MICROSECONDS);
+        }
+
+        @SuppressFBWarnings(value = ""OBL_UNSATISFIED_OBLIGATION"",
+                            justification = ""FileInputStream is passed to CommandResponse and closed in StreamOutputter"")
+        @Override
+        public CommandResponse run(final ZooKeeperServer zkServer, final Map<String, String> kwargs) {
+            final CommandResponse response = initializeResponse();
+
+            // check feature flag
+            final boolean snapshotEnabled = Boolean.parseBoolean(System.getProperty(ADMIN_SNAPSHOT_ENABLED, ""false""));
+            if (!snapshotEnabled) {
+                response.setStatusCode(HttpServletResponse.SC_SERVICE_UNAVAILABLE);
+                LOG.warn(""Snapshot command is disabled"");
+                return response;
+            }
+
+            // check rate limiting
+            if (!rateLimiter.allow()) {
+                response.setStatusCode(429);","[{'comment': ""You can use here:\r\n```java\r\norg.eclipse.jetty.http.HttpStatus.TOO_MANY_REQUESTS_429\r\n```\r\nI see you prefer to use `HttpServletResponse` constants, but since the response code is a standard int, I think it doesn't matter."", 'commenter': 'anmolnar'}, {'comment': 'Yes, changed.', 'commenter': 'li4wang'}]"
1943,zookeeper-server/src/main/java/org/apache/zookeeper/server/auth/IPAuthenticationProvider.java,"@@ -128,4 +131,18 @@ public boolean isValid(String id) {
         return true;
     }
 
+    /**
+     * Returns the HTTP(s) client IP address
+     * @param request HttpServletRequest
+     * @return IP address
+     */
+    public static String getClientIPAddress(final HttpServletRequest request) {
+        // to handle the case that a HTTP(s) client connects via a proxy or load balancer
+        final String xForwardedForHeader = request.getHeader(X_FORWARDED_FOR_HEADER_NAME);
+        if (xForwardedForHeader == null) {
+            return request.getRemoteAddr();
+        }
+        // the format of the field is: X-Forwarded-For: client, proxy1, proxy2 ...
+        return new StringTokenizer(xForwardedForHeader, "","").nextToken().trim();
+    }","[{'comment': ""I don't think this method belongs to this class. `IPAuthenticationProvider` is responsible for authenticating ZooKeeper client by the client IP address. You don't use any member of the class, neither instantiate it (static method), so please move it where the usage is (StreamOutputter.java)."", 'commenter': 'anmolnar'}, {'comment': 'This method is in `IPAuthenticationProvider `as it will be used by `IPAuthenticationProvider` when providing IP auth support for admin server APIs. \r\n\r\n`IPAuthenticationProvider` will be enhanced for authenticating both Zookeeper client and Admin Server APIs by the client IP address.\r\n', 'commenter': 'li4wang'}, {'comment': 'Fine. Next time please add a refactoring to the upcoming patch instead. Looking at this patch alone means that you break the encapsulation principle.', 'commenter': 'anmolnar'}, {'comment': 'Yep', 'commenter': 'li4wang'}]"
1943,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/StreamOutputter.java,"@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.admin;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import org.apache.zookeeper.common.IOUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A class for streaming data out.
+ */
+public class StreamOutputter implements CommandOutputter{
+    private static final Logger LOG = LoggerFactory.getLogger(StreamOutputter.class);
+    private final String clientIP;
+
+    public StreamOutputter(final String clientIP) {
+        this.clientIP = clientIP;
+    }
+
+    @Override
+    public String getContentType() {
+        return ""application/octet-stream"";
+    }
+
+    @Override
+    public void output(final CommandResponse response, final OutputStream os) {
+        try (final InputStream is = response.getInputStream()){
+            IOUtils.copyBytes(is, os, 1024, true);
+        } catch (final IOException e) {
+            LOG.error(""Exception occurred when streaming out data to {}"", clientIP, e);","[{'comment': 'Logging the IP address is a useful addition to the error message. Have you considered adding to the `JsonOutputter` too?', 'commenter': 'anmolnar'}, {'comment': ""Yeah, I think it's useful to add it to `JsonOutputter` too. Added."", 'commenter': 'li4wang'}]"
1943,zookeeper-server/src/main/java/org/apache/zookeeper/server/util/RateLimiter.java,"@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * A class that provides simple interval-based rate limiting implementation.
+ */
+public class RateLimiter {
+    private final int rate;
+    private final long intervalInMs;
+    private long lastTimeReset;
+    private final AtomicInteger remained;
+
+    public RateLimiter(final int rate, final long interval, final TimeUnit unit) {
+        this.rate = rate;
+        this.intervalInMs = unit.toMillis(interval);
+        this.lastTimeReset = System.currentTimeMillis();","[{'comment': 'Please use ZooKeeper `Time.java` class for tracking elapsed time. It uses System.nanoTime() internally which is more reliable.', 'commenter': 'anmolnar'}, {'comment': 'Good idea. Changed.', 'commenter': 'li4wang'}]"
1943,zookeeper-server/src/test/java/org/apache/zookeeper/server/util/RateLimiterTest.java,"@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.Test;
+
+public class RateLimiterTest {
+
+    @Test
+    public void testAllow_withinInterval() {
+        final int rate = 2;
+        final RateLimiter rateLimiter = new RateLimiter(rate, 5, TimeUnit.SECONDS);
+        for (int i = 0; i < rate; i++) {
+            assertTrue(rateLimiter.allow());
+        }
+        assertFalse(rateLimiter.allow());
+    }
+
+    @Test
+    public void testAllow_exceedInterval() throws Exception {
+        final int interval = 1;
+
+        final RateLimiter rateLimiter = new RateLimiter(1, interval, TimeUnit.SECONDS);
+        assertTrue(rateLimiter.allow());
+        assertFalse(rateLimiter.allow());
+        Thread.sleep(TimeUnit.SECONDS.toMillis(interval) + 1);","[{'comment': 'Please wait 2 seconds at least. Thread.sleep() in tests could easly lead to flaky test.\r\nAdditonally I think it would be nice to have a multithreaded test as well: start 10 worker in an executor to grab the numbers and verify that the 11th is disallowed within the time interval.', 'commenter': 'anmolnar'}, {'comment': '> Please wait 2 seconds at least. Thread.sleep() in tests could easly lead to flaky test.\r\nchanged to wait for 3 seconds\r\n\r\n\r\n> Additonally I think it would be nice to have a multithreaded test as well: start 10 worker in an executor to grab the numbers and verify that the 11th is disallowed within the time interval.\r\n\r\nadded multithreaded test\r\n\r\n', 'commenter': 'li4wang'}]"
1943,zookeeper-server/src/test/java/org/apache/zookeeper/server/util/RateLimiterTest.java,"@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.Test;
+
+public class RateLimiterTest {
+
+    @Test
+    public void testAllow_withinInterval() {
+        final int rate = 2;
+        final RateLimiter rateLimiter = new RateLimiter(rate, 5, TimeUnit.SECONDS);
+        for (int i = 0; i < rate; i++) {
+            assertTrue(rateLimiter.allow());
+        }
+        assertFalse(rateLimiter.allow());
+    }
+
+    @Test
+    public void testAllow_withinInterval_multiThreaded() {
+        final int rate = 10;
+
+        final RateLimiter rateLimiter = new RateLimiter(rate, 5, TimeUnit.SECONDS);
+        final ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(rate + 1);
+        for (int i = 0; i < rate; i++) {
+            executor.execute(() -> assertTrue(rateLimiter.allow()));
+        }
+        executor.execute(() -> assertFalse(rateLimiter.allow()));
+    }
+
+    @Test
+    public void testAllow_exceedInterval() throws Exception {
+        final int interval = 1;
+
+        final RateLimiter rateLimiter = new RateLimiter(1, interval, TimeUnit.SECONDS);
+        assertTrue(rateLimiter.allow());
+        assertFalse(rateLimiter.allow());
+        Thread.sleep(TimeUnit.SECONDS.toMillis(interval) + 3);","[{'comment': 'Wait 2 seconds (internal + 1), not 2 milliseconds more.', 'commenter': 'anmolnar'}, {'comment': ""Good catch!  I didn't realize the original issue was 1 ms more instead of 1 second more.  Fixed."", 'commenter': 'li4wang'}]"
1943,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -1744,6 +1744,42 @@ public boolean deserializeZxidDigest(InputArchive ia, long startZxidOfSnapshot)
         }
     }
 
+    /**
+     * Serializes the lastProcessedZxid so we can get it from snapshot instead the snapshot file name.
+     * This is needed for performing snapshot and restore via admin server commands.
+     *
+     * @param oa the output stream to write to
+     * @return true if the lastProcessedZxid is serialized successfully, otherwise false
+     * @throws IOException
+     */
+    public boolean serializeLastProcessedZxid(final OutputArchive oa) throws IOException {
+        if (!ZooKeeperServer.isSerializeLastProcessedZxidEnabled()) {
+            return false;
+        }
+        oa.writeLong(lastProcessedZxid, ""lastZxid"");
+        return true;
+    }
+
+    /**
+     * Deserializes the lastProcessedZxid from the input stream and updates the lastProcessedZxid field.
+     *
+     * @param ia the input stream to read from
+     * @return true if lastProcessedZxid is deserialized successfully, otherwise false
+     * @throws IOException","[{'comment': ""*[EmptyBlockTag](https://google.github.io/styleguide/javaguide.html#s7.1.3-javadoc-block-tags):*  A block tag (@param, @return, @throws, @deprecated) has an empty description. Block tags without descriptions don't add much value for future readers of the code; consider removing the tag entirely or adding a description.\n\n---\n\n\n```suggestion\n     *\n```\n\n\n\n---\n\n<details><summary><b>ℹ️ Learn about @sonatype-lift commands</b></summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=358311377&lift_comment_rating=1) ] - [ [😕 Won't fix](https://www.sonatype.com/lift-comment-rating?comment=358311377&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=358311377&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=358311377&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=358311377&lift_comment_rating=5) ]"", 'commenter': 'sonatype-lift[bot]'}]"
1943,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -1744,6 +1744,42 @@ public boolean deserializeZxidDigest(InputArchive ia, long startZxidOfSnapshot)
         }
     }
 
+    /**
+     * Serializes the lastProcessedZxid so we can get it from snapshot instead the snapshot file name.
+     * This is needed for performing snapshot and restore via admin server commands.
+     *
+     * @param oa the output stream to write to
+     * @return true if the lastProcessedZxid is serialized successfully, otherwise false
+     * @throws IOException","[{'comment': ""*[EmptyBlockTag](https://google.github.io/styleguide/javaguide.html#s7.1.3-javadoc-block-tags):*  A block tag (@param, @return, @throws, @deprecated) has an empty description. Block tags without descriptions don't add much value for future readers of the code; consider removing the tag entirely or adding a description.\n\n---\n\n\n```suggestion\n     *\n```\n\n\n\n---\n\n<details><summary><b>ℹ️ Learn about @sonatype-lift commands</b></summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=358311402&lift_comment_rating=1) ] - [ [😕 Won't fix](https://www.sonatype.com/lift-comment-rating?comment=358311402&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=358311402&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=358311402&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=358311402&lift_comment_rating=5) ]"", 'commenter': 'sonatype-lift[bot]'}]"
1950,zookeeper-server/src/main/java/org/apache/zookeeper/WatchedEvent.java,"@@ -66,9 +78,44 @@ public String getPath() {
         return path;
     }
 
+    /**
+     * Returns the zxid of the transaction that triggered this watch if it is
+     * of one of the following types:<ul>
+     *   <li>{@link EventType#NodeCreated}</li>
+     *   <li>{@link EventType#NodeDeleted}</li>
+     *   <li>{@link EventType#NodeDataChanged}</li>
+     *   <li>{@link EventType#NodeChildrenChanged}</li>
+     * </ul>
+     * Otherwise, returns {@value #NO_ZXID}. Note that {@value #NO_ZXID} is also
+     * returned by old servers that do not support this feature.
+     */
+    public long getZxid() {
+        return zxid;
+    }
+
     @Override
     public String toString() {
-        return ""WatchedEvent state:"" + keeperState + "" type:"" + eventType + "" path:"" + path;
+        return ""WatchedEvent state:"" + keeperState + "" type:"" + eventType + "" path:"" + path + "" zxid: "" + zxid;
+    }
+
+    @Override
+    public boolean equals(Object o) {","[{'comment': 'This could break codes. If we are intend to do so, it might be better a separated jira.', 'commenter': 'kezhuw'}, {'comment': ""You're right, let me double check whether it's actually necessary to have this"", 'commenter': 'PapaCharlie'}, {'comment': 'I updated the code and left a TODO', 'commenter': 'PapaCharlie'}]"
1950,zookeeper-server/src/test/java/org/apache/zookeeper/server/watch/WatchManagerTest.java,"@@ -430,28 +434,37 @@ public void testWatcherMetrics(String className) throws IOException {
 
         final String path3 = ""/path3"";
 
-        //both wather1 and wather2 are watching path1
+        //both watcher1 and watcher2 are watching path1
         manager.addWatch(path1, watcher1);
         manager.addWatch(path1, watcher2);
 
         //path2 is watched by watcher1
         manager.addWatch(path2, watcher1);
 
-        manager.triggerWatch(path3, EventType.NodeCreated);
+        manager.triggerWatch(path3, EventType.NodeCreated, 1);
         //path3 is not being watched so metric is 0
         checkMetrics(""node_created_watch_count"", 0L, 0L, 0D, 0L, 0L);
+        // Watchers shouldn't have received any events yet so the zxid should be -1.
+        checkWatchedZxid(watcher1, -1);
+        checkWatchedZxid(watcher2, -1);
 
         //path1 is watched by two watchers so two fired
-        manager.triggerWatch(path1, EventType.NodeCreated);
+        manager.triggerWatch(path1, EventType.NodeCreated, 2);
         checkMetrics(""node_created_watch_count"", 2L, 2L, 2D, 1L, 2L);
+        checkWatchedZxid(watcher1, 2);
+        checkWatchedZxid(watcher2, 2);
 
         //path2 is watched by one watcher so one fired now total is 3
-        manager.triggerWatch(path2, EventType.NodeCreated);
+        manager.triggerWatch(path2, EventType.NodeCreated, 3);
         checkMetrics(""node_created_watch_count"", 1L, 2L, 1.5D, 2L, 3L);
+        checkWatchedZxid(watcher1, 3);
+        checkWatchedZxid(watcher2, 2);
 
         //watches on path1 are no longer there so zero fired
-        manager.triggerWatch(path1, EventType.NodeDataChanged);
+        manager.triggerWatch(path1, EventType.NodeDataChanged, 4);
         checkMetrics(""node_changed_watch_count"", 0L, 0L, 0D, 0L, 0L);
+        checkWatchedZxid(watcher1, 3);
+        checkWatchedZxid(watcher2, 2);
 
         //both wather1 and wather2 are watching path1","[{'comment': 'Typos too.', 'commenter': 'kezhuw'}, {'comment': 'Whoops, nice catch', 'commenter': 'PapaCharlie'}]"
1950,zookeeper-server/src/test/java/org/apache/zookeeper/server/watch/WatchManagerTest.java,"@@ -416,6 +416,10 @@ private void checkMetrics(String metricName, long min, long max, double avg, lon
         assertEquals(sum, values.get(""sum_"" + metricName));
     }
 
+    private void checkWatchedZxid(DumbWatcher watcher, long expectedZxid) {
+        assertEquals(expectedZxid, watcher.getWatchedZxid());
+    }
+
     @ParameterizedTest
     @MethodSource(""data"")
     public void testWatcherMetrics(String className) throws IOException {","[{'comment': 'We are testing more than metrics now. If you are testing zxid, then how about whole event as did in client side tests ? I saw no such assertions in server side for `WatchManager`.', 'commenter': 'kezhuw'}, {'comment': ""You're right, this is worth testing. I've updated it, let me know what you think!"", 'commenter': 'PapaCharlie'}]"
1950,zookeeper-server/src/main/java/org/apache/zookeeper/WatchedEvent.java,"@@ -31,27 +31,38 @@
  */
 @InterfaceAudience.Public
 public class WatchedEvent {
+    public static final long NO_ZXID = -1L;
 
     private final KeeperState keeperState;
     private final EventType eventType;
-    private String path;
+    private final String path;
+    private final long zxid;
 
     /**
-     * Create a WatchedEvent with specified type, state and path
+     * Create a WatchedEvent with specified type, state, path and zxid
      */
-    public WatchedEvent(EventType eventType, KeeperState keeperState, String path) {
+    public WatchedEvent(EventType eventType, KeeperState keeperState, String path, long zxid) {","[{'comment': 'This is public API, we should keep the original constructors, maybe you can mark them ""@Deprecated""', 'commenter': 'eolivelli'}, {'comment': ""This is preserved below, it's just not marked as @deprecated because there are many uses of WatchedEvent that correctly do not have a zxid."", 'commenter': 'PapaCharlie'}]"
1957,pom.xml,"@@ -347,26 +347,26 @@
     <surefire-forkcount>8</surefire-forkcount>
 
     <!-- dependency versions -->
-    <slf4j.version>1.7.35</slf4j.version>
-    <audience-annotations.version>0.5.0</audience-annotations.version>
+    <slf4j.version>1.7.36</slf4j.version>
+    <audience-annotations.version>0.12.0</audience-annotations.version>","[{'comment': 'Can this go to the newest version: 0.14.1?', 'commenter': 'cnauroth'}, {'comment': 'Thanks, good idea. I tried, but 0.14.1 seems to work only with java11+\r\n(build error: `class file has wrong version 55.0, should be 52.0`)\r\nBut I can upgrade to 0.13.0. I see (according to maven central) that 0.13.0 is a widely used version, I upgraded to it.', 'commenter': 'symat'}]"
1957,zookeeper-server/src/main/resources/NOTICE.txt,"@@ -10,11 +10,14 @@ licensed under the Apache 2.0 license. The licensing terms
 for Airlift code can be found at:
 https://github.com/airlift/airlift/blob/master/LICENSE
 
+","[{'comment': 'Unnecessary blank line?', 'commenter': 'cnauroth'}]"
1957,zookeeper-server/src/main/resources/NOTICE.txt,"@@ -32,29 +35,112 @@ Base64 Encoder and Decoder, which can be obtained at:
   * HOMEPAGE:
     * http://iharder.sourceforge.net/current/java/base64/
 
-This product contains a modified version of 'JZlib', a re-implementation of
-zlib in pure Java, which can be obtained at:
+This product contains a modified portion of 'Webbit', an event based
+WebSocket and HTTP server, which can be obtained at:
+
+  * LICENSE:
+    * license/LICENSE.webbit.txt (BSD License)
+  * HOMEPAGE:
+    * https://github.com/joewalnes/webbit
+
+This product contains a modified portion of 'SLF4J', a simple logging
+facade for Java, which can be obtained at:
+
+  * LICENSE:
+    * license/LICENSE.slf4j.txt (MIT License)
+  * HOMEPAGE:
+    * https://www.slf4j.org/
 
+This product contains a modified portion of 'Apache Harmony', an open source","[{'comment': ""Can you please describe how you reviewed and decided what to add in NOTICE.txt? From a quick look, I'm unclear on how to draw the connection to some of these."", 'commenter': 'cnauroth'}, {'comment': ""good question... honestly, I haven't dug deeply into this, I usually just update the content of the license / notice files we have before I cut a release. (updating the versions and double-checking the license types for updated third parties). \r\n\r\nAFAIU, our practice is:\r\n- copy the license files of all directly included runtime 3pp libraries to `zookeeper-server/src/main/resources/lib`\r\n- update the  `zookeeper-server/src/main/resources/LICENSE.txt`, where we have the Apache 2.0 license, and we also mention all the third parties which has a different license (other than Apache 2)\r\n- update the NOTICE.txt file with all other contributions / sources (which are mainly come from the netty project, so we have the netty NOTICE file copy-pasted some time there... but I just updated that, as netty NOTICE file changed a lot during the years)\r\n\r\nAfter some googling, I also found this page: https://infra.apache.org/licensing-howto.html\r\n\r\nI never spent time on assessing if this practice we have in ZooKeeper is OK or not. I hope that someone with better knowledge checks this during the VOTE... But anyway, I don't think we need to change our approach in a bugfix release. But if we are afraid that we don't follow some Apache policy here precisely enough, then maybe someone can take the time and review this more deeply for the next minor (3.9) release."", 'commenter': 'symat'}, {'comment': 'Thanks for the information! The updates coming from Netty make sense to me now.\r\n\r\nI recall a conversation a few months ago concluding that this process is fine.', 'commenter': 'cnauroth'}]"
1961,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/JettyAdminServer.java,"@@ -259,15 +261,81 @@ protected void doGet(
             }
 
             // Run the command
-            CommandResponse cmdResponse = Commands.runCommand(cmd, zkServer, kwargs);
+            final CommandResponse cmdResponse = Commands.runCommand(cmd, zkServer, kwargs, null);
+            response.setStatus(cmdResponse.getStatusCode());
 
-            // Format and print the output of the command
-            CommandOutputter outputter = new JsonOutputter();
-            response.setStatus(HttpServletResponse.SC_OK);
+            final Map<String, String> headers = cmdResponse.getHeaders();
+            for (final Map.Entry<String, String> header : headers.entrySet()) {
+                response.addHeader(header.getKey(), header.getValue());
+            }
+            final String clientIP = IPAuthenticationProvider.getClientIPAddress(request);
+            if (cmdResponse.getInputStream() == null) {
+                // Format and print the output of the command
+                CommandOutputter outputter = new JsonOutputter(clientIP);
+                response.setContentType(outputter.getContentType());
+                outputter.output(cmdResponse, response.getWriter());
+            } else {
+                // Stream out the output of the command
+                CommandOutputter outputter = new StreamOutputter(clientIP);
+                response.setContentType(outputter.getContentType());
+                outputter.output(cmdResponse, response.getOutputStream());
+            }
+        }
+
+        /**
+         * Serves HTTP POST requests. It reads request payload as raw data.
+         * It's up to each command to process the payload accordingly.
+         * For example, RestoreCommand uses the payload InputStream directly
+         * to read snapshot data.
+         */
+        @Override
+        protected void doPost(final HttpServletRequest request,
+                              final HttpServletResponse response) throws ServletException, IOException {
+            final String cmdName = extractCommandNameFromURL(request, response);
+            if (cmdName != null) {
+                // Run the command
+                final CommandResponse cmdResponse = Commands.runCommand(cmdName, zkServer, null, request.getInputStream());
+                final String clientIP = IPAuthenticationProvider.getClientIPAddress(request);
+                sendJSONResponse(response, cmdResponse, clientIP);
+            }
+        }
+
+        /**
+         * Extracts the command name from URL if it exists otherwise null
+         */
+        private String extractCommandNameFromURL(final HttpServletRequest request,
+                                                 final HttpServletResponse response) throws IOException {
+            String cmd = request.getPathInfo();
+            if (cmd == null || cmd.equals(""/"")) {
+                printCommandLinks(response);
+                return null;
+            }
+            // Strip leading ""/""
+            return cmd.substring(1);
+        }
+
+        /**
+         * Prints the list of URLs to each registered command as response.
+         */
+        private void printCommandLinks(final HttpServletResponse response) throws IOException {
+            for (final String link : commandLinks()) {
+                response.getWriter().println(link);","[{'comment': ""*[XSS_SERVLET](https://find-sec-bugs.github.io/bugs.htm#XSS_SERVLET):*  This use of java/io/PrintWriter.println(Ljava/lang/String;)V could be vulnerable to XSS in the Servlet\n\n---\n\n<details><summary><b>ℹ️ Learn about @sonatype-lift commands</b></summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=360445073&lift_comment_rating=1) ] - [ [😕 Won't fix](https://www.sonatype.com/lift-comment-rating?comment=360445073&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=360445073&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=360445073&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=360445073&lift_comment_rating=5) ]"", 'commenter': 'sonatype-lift[bot]'}, {'comment': '@sonatype-lift ignore', 'commenter': 'li4wang'}, {'comment': ""I've recorded this as ignored for this pull request.\nIf you change your mind, just comment `@sonatype-lift unignore`."", 'commenter': 'sonatype-lift[bot]'}]"
1961,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZKDatabase.java,"@@ -620,6 +623,48 @@ public void deserializeSnapshot(InputArchive ia) throws IOException {
         initialized = true;
     }
 
+    /**
+     * Deserialize a snapshot that contains FileHeader from an input archive. It is used by
+     * the admin restore command.
+     *
+     * @param ia the input archive to deserialize from
+     * @param is the CheckInputStream to check integrity
+     *
+     * @throws IOException
+     */
+    public void deserializeSnapshot(final InputArchive ia, final CheckedInputStream is) throws IOException {
+        // clear the zkDatabase
+        clear();","[{'comment': ""*THREAD_SAFETY_VIOLATION:*  Unprotected write. Non-private method `ZKDatabase.deserializeSnapshot(...)` indirectly writes to field `this.dataTree` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not.\n\n---\n\n<details><summary><b>ℹ️ Learn about @sonatype-lift commands</b></summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=360445341&lift_comment_rating=1) ] - [ [😕 Won't fix](https://www.sonatype.com/lift-comment-rating?comment=360445341&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=360445341&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=360445341&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=360445341&lift_comment_rating=5) ]"", 'commenter': 'sonatype-lift[bot]'}]"
1961,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZKDatabase.java,"@@ -620,6 +623,48 @@ public void deserializeSnapshot(InputArchive ia) throws IOException {
         initialized = true;
     }
 
+    /**
+     * Deserialize a snapshot that contains FileHeader from an input archive. It is used by
+     * the admin restore command.
+     *
+     * @param ia the input archive to deserialize from
+     * @param is the CheckInputStream to check integrity
+     *
+     * @throws IOException
+     */
+    public synchronized void deserializeSnapshot(final InputArchive ia, final CheckedInputStream is) throws IOException {
+        // clear the zkDatabase
+        clear();","[{'comment': ""*THREAD_SAFETY_VIOLATION:*  Read/Write race. Non-private method `ZKDatabase.deserializeSnapshot(...)` indirectly reads with synchronization from `this.dataTree`. Potentially races with unsynchronized write in method `ZKDatabase.clear()`.\n Reporting because this access may occur on a background thread.\n\n---\n\n<details><summary><b>ℹ️ Learn about @sonatype-lift commands</b></summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n\n\n---\n\nWas this a good recommendation?\n[ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=360842486&lift_comment_rating=1) ] - [ [😕 Won't fix](https://www.sonatype.com/lift-comment-rating?comment=360842486&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=360842486&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=360842486&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=360842486&lift_comment_rating=5) ]"", 'commenter': 'sonatype-lift[bot]'}, {'comment': ""I've recorded this as ignored for this pull request.\nIf you change your mind, just comment `@sonatype-lift unignore`."", 'commenter': 'sonatype-lift[bot]'}, {'comment': ""I've recorded this as ignored for this pull request.\nIf you change your mind, just comment `@sonatype-lift unignore`."", 'commenter': 'sonatype-lift[bot]'}]"
1961,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -2126,6 +2126,17 @@ options are used to configure the [AdminServer](#sc_adminserver).
   The time interval for rate limiting snapshot command to protect the server.
   Defaults to 5 mins.
 
+* *admin.restore.enabled* :
+  (Java system property: **zookeeper.admin.restore.enabled**)
+  The flag for enabling the restore command. Defaults to false.
+  It will be enabled by default once the auth support for admin server commands
+  is available.
+
+* *admin.restore.intervalInMS* :
+  (Java system property: **zookeeper.admin.restore.intervalInMS**)
+  The time interval for rate limiting restore command to protect the server.
+  Defaults to 5 mins.","[{'comment': ""Do we need this setting separately for all admin commands?\r\nShouldn't we just introduce a new general setting for the admin interface which would rate limit all admin requests coming in? \r\nI don't think anybody would like to set this individually for commands."", 'commenter': 'anmolnar'}, {'comment': ""I don't see a real need to configure the interval differently for the snapshot and restore command at this point.\r\n\r\nYes, we can keep it simple and have just one general setting for all the admin commands that need to be rate limited."", 'commenter': 'li4wang'}]"
1961,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -1151,6 +1213,9 @@ protected void setLocalSessionFlag(Request si) {
     }
 
     public void submitRequest(Request si) {
+        if (state == State.MAINTENANCE) {
+            throw new IllegalStateException(""Zookeeper server is in maintenance state"");
+        }","[{'comment': ""If you throw an exception here, the request will fail on the client side. I haven't tried it myself, have you valdiated that the client is able to seemlessly retry the command without bothering the user?\r\nIf not, I suggest another solution: create a semaphore which is closed while the maintenace is happening and block this thread until it's finished. The request will suffer some additionaly latency, but otherwise cannot be noticed. Thoughts?"", 'commenter': 'anmolnar'}, {'comment': 'blocking here is probably not a good idea, we risk to block the pipeline, with unpredictable consequences probably', 'commenter': 'eolivelli'}, {'comment': 'What are you thinking of exactly?\r\nWe already block the thread when RequestThrottler or first processor is not yet initialized with the following logic:\r\n```java\r\nwhile (state == State.INITIAL) {\r\n    wait(1000);\r\n}\r\n```\r\nWe could add similar logic here _or_ which I think is better waiting for a semaphore to be released with timeout.', 'commenter': 'anmolnar'}, {'comment': 'Moreover, request throttler does the throttling mechanism by blocking this thread.', 'commenter': 'anmolnar'}, {'comment': 'you are right @anmolnar \r\nthanks for your clarification.\r\n\r\nwe could have a similar loop here\r\n\r\n```\r\nwhile (state == State.MAINTENANCE) {\r\n    wait(1000);\r\n}\r\n```', 'commenter': 'eolivelli'}, {'comment': 'Thanks for the inputs. I will  look into this.', 'commenter': 'li4wang'}, {'comment': ""Yeah, be aware that you have to do `notifyAll()` after changing the state back to RUNNING to notify the waiting threads. I'll add another comment at the right place.\r\n\r\nAdditionally, I don't get this `check-wait(timeout)-check-wait(timeout)-...` logic. It doesn't make sense to me, there's no additional fail-safe logic inside the loop, why don't just `wait()`? \r\n\r\nInstead, it takes back the lock in every second probably without any benefit. I don't say we have to change that, I just don't understand."", 'commenter': 'anmolnar'}, {'comment': ""> If you throw an exception here, the request will fail on the client side. I haven't tried it myself, have you valdiated that the client is able to seemlessly retry the command without bothering the user?\r\n\r\nI checked the scenario of sending client request while zk is in maintenance state. Here is what I found.\r\n\r\n1. Connection/session creation will be retried but read/write operation will not.\r\n2. The read/write request will fail even no exception is thrown here, because the request fails before sending to ZookeeperServer. Here is what happens:\r\n\r\na)  `ServerCnxn` detects that ZK server is not running and close the socket/channel. \r\nb) `ClientSocketCnxn.doTransport()` then detects that socket/channel is closed and throws IOException\r\nc)  'SendThread' catches the Exception, adds `ConnectionLoss` error reply header, clears up the outgoingQueue ann pendingQueue, and attempts to re-connect to server\r\nd)  Zookeeper check the header and sends ConnectionLoss to user\r\n\r\n"", 'commenter': 'li4wang'}, {'comment': ""> `If not, I suggest another solution: create a semaphore which is closed while the maintenace is happening and block this thread until it's finished. The request will suffer some additionaly latency, but otherwise cannot be noticed. Thoughts?`\r\n\r\nBlocking the thread doesn't change the behavior as the request fails before being sent to the server. In addition, as pointed out, it can potentially increase the latency. \r\n\r\nSince the restore feature is really designed for recovering from rarely happed disaster failure (i.e. quorum lost), Not accepting any client requests in that scenario should be ok, right?   WDYT?\r\n\r\n"", 'commenter': 'li4wang'}, {'comment': 'Makes sense to me.', 'commenter': 'eolivelli'}, {'comment': ""Got you. There're 2 things that crossed my mind to resolve this:\r\n1. Add MAINTENANCE as a running state to `ZooKeeperServer.isRunning()` method.\r\n2. Do not alter the state of ZooKeeperServer, but use a separate volatile variable in this class to block requests temporarly."", 'commenter': 'anmolnar'}, {'comment': 'Thanks for the feedback and inputs, @eolivelli  and @anmolnar ', 'commenter': 'li4wang'}, {'comment': '> Add MAINTENANCE as a running state to ZooKeeperServer.isRunning() method.\r\n\r\nAdding MAINTENANCE to ZooKeeperServer.isRunning() will change the semantics of ""running"" state and has bigger impact, we would want to avoid it if it\'s possible.\r\n\r\n> Do not alter the state of ZooKeeperServer, but use a separate volatile variable in this class to block requests temporarly.\r\n\r\nGood idea. Yes, we don\'t have to alter the state of ZooKeeper if we don\'t think we need a generic MAINTENANCE state. \r\n\r\nInstead of using volatile variable,  how about adding a `CountDownLatch` to more efficiently coordinate/sync between threads and utilize system resources?\r\n\r\nThe `restoreFromSnapshot()` API  will instantiate a `CountDownLatch` with 1 count  when restore starts and count it down when restore is completed. The `submitRequest()` API  will check and wait on the `CountDownLatch`, so requests will be blocked if a restore is in progress.  \r\n', 'commenter': 'li4wang'}, {'comment': 'Makes sense to me.\r\nMaybe  before starting to way you can log at INFO level a line like ""MAINTEINANCE in progress, blocking the request processing""', 'commenter': 'eolivelli'}, {'comment': ""+1 for the logging suggestion of @eolivelli .\r\n\r\nI also like the Latch approach @li4wang . I think you have to use `AtomicReference<CountDownLatch>` for that, because you create a new instance every time ZK enters into Maintenance mode. In `submitRequest()` you'll try grabbing the reference by `get()` and if it's not null, await for it."", 'commenter': 'anmolnar'}, {'comment': ""How about using `volatile` instead of `AtomicReference` to keep it simple and lightweight? In this case, we only need to take care of visibility issue. Only one thread writes the value, so no need for the additional power (i.e. atomicity/CAS) provided by AtomicReference.\r\n\r\nWith `volatile`,  we can ensure  once the restore thread creates a new instance, the instance value will be immediately visible to threads that check if it's null.\r\n"", 'commenter': 'li4wang'}, {'comment': 'Sounds good to me.', 'commenter': 'anmolnar'}, {'comment': 'updated', 'commenter': 'li4wang'}]"
1961,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -583,6 +590,58 @@ public synchronized File takeSnapshot(boolean syncSnap, boolean isSevere, boolea
         return snapFile;
     }
 
+    /**
+     * Restores database from a snapshot. It is used by the restore admin server command.
+     *
+     * @param inputStream input stream of snapshot
+     * @Return last processed zxid
+     * @throws IOException
+     */
+    public synchronized long restoreFromSnapshot(final InputStream inputStream) throws IOException {
+        if (inputStream == null) {
+            throw new IllegalArgumentException(""InputStream can not be null when restoring from snapshot"");
+        }
+
+        long start = Time.currentElapsedTime();
+        LOG.info(""Before restore database. lastProcessedZxid={}, nodeCount={}，sessionCount={}"",
+            getZKDatabase().getDataTreeLastProcessedZxid(),
+            getZKDatabase().dataTree.getNodeCount(),
+            getZKDatabase().getSessionCount());
+
+        // restore to a new zkDatabase
+        final ZKDatabase newZKDatabase = new ZKDatabase(this.txnLogFactory);
+        final CheckedInputStream cis = new CheckedInputStream(new BufferedInputStream(inputStream), new Adler32());
+        final InputArchive ia = BinaryInputArchive.getArchive(cis);
+        newZKDatabase.deserializeSnapshot(ia, cis);
+        LOG.info(""Restored to a new database. lastProcessedZxid={}, nodeCount={}, sessionCount={}"",
+            newZKDatabase.getDataTreeLastProcessedZxid(),
+            newZKDatabase.dataTree.getNodeCount(),
+            newZKDatabase.getSessionCount());
+
+        // set the state to MAINTENANCE to stop taking incoming requests
+        setState(State.MAINTENANCE);
+
+        // set to the new zkDatabase
+        setZKDatabase(newZKDatabase);
+
+        // re-create SessionTrack
+        createSessionTracker();
+
+        LOG.info(""After restore database. lastProcessedZxid={}, nodeCount={}, sessionCount={}"",
+                getZKDatabase().getDataTreeLastProcessedZxid(),
+                getZKDatabase().dataTree.getNodeCount(),
+                getZKDatabase().getSessionCount());
+
+        // set the state back to RUNNING
+        setState(State.RUNNING);","[{'comment': 'After this you have to `notifyAll()`.', 'commenter': 'anmolnar'}]"
1961,zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java,"@@ -583,6 +590,58 @@ public synchronized File takeSnapshot(boolean syncSnap, boolean isSevere, boolea
         return snapFile;
     }
 
+    /**
+     * Restores database from a snapshot. It is used by the restore admin server command.
+     *
+     * @param inputStream input stream of snapshot
+     * @Return last processed zxid
+     * @throws IOException
+     */
+    public synchronized long restoreFromSnapshot(final InputStream inputStream) throws IOException {
+        if (inputStream == null) {
+            throw new IllegalArgumentException(""InputStream can not be null when restoring from snapshot"");
+        }
+
+        long start = Time.currentElapsedTime();
+        LOG.info(""Before restore database. lastProcessedZxid={}, nodeCount={}，sessionCount={}"",
+            getZKDatabase().getDataTreeLastProcessedZxid(),
+            getZKDatabase().dataTree.getNodeCount(),
+            getZKDatabase().getSessionCount());
+
+        // restore to a new zkDatabase
+        final ZKDatabase newZKDatabase = new ZKDatabase(this.txnLogFactory);
+        final CheckedInputStream cis = new CheckedInputStream(new BufferedInputStream(inputStream), new Adler32());
+        final InputArchive ia = BinaryInputArchive.getArchive(cis);
+        newZKDatabase.deserializeSnapshot(ia, cis);
+        LOG.info(""Restored to a new database. lastProcessedZxid={}, nodeCount={}, sessionCount={}"",
+            newZKDatabase.getDataTreeLastProcessedZxid(),
+            newZKDatabase.dataTree.getNodeCount(),
+            newZKDatabase.getSessionCount());
+
+        // set the state to MAINTENANCE to stop taking incoming requests
+        setState(State.MAINTENANCE);","[{'comment': ""I don't think we have to `notifyAll()` here, because there shouldn't be any thread to release while doing maintenance."", 'commenter': 'anmolnar'}, {'comment': 'yes, agree.', 'commenter': 'li4wang'}]"
2001,zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java,"@@ -1025,20 +1028,71 @@ public ZooKeeper(
         boolean canBeReadOnly,
         HostProvider hostProvider,
         ZKClientConfig clientConfig) throws IOException {
-        LOG.info(
-            ""Initiating client connection, connectString={} ""
-                + ""sessionTimeout={} watcher={} sessionId=0x{} sessionPasswd={}"",
-            connectString,
-            sessionTimeout,
-            watcher,
-            Long.toHexString(sessionId),
-            (sessionPasswd == null ? ""<null>"" : ""<hidden>""));
+        this(new ZooKeeperBuilder(connectString, sessionTimeout)
+            .withSession(sessionId, sessionPasswd)
+            .withDefaultWatcher(watcher)
+            .withCanBeReadOnly(canBeReadOnly)
+            .withHostProvider(ignored -> hostProvider)
+            .withClientConfig(clientConfig)
+            .toOptions());
+    }
 
+    /**
+     * Create a ZooKeeper client and establish session asynchronously.
+     *
+     * <p>This constructor will initiate connection to the server and return
+     * immediately - potentially (usually) before the session is fully established.
+     * The watcher from options will be notified of any changes in state. This
+     * notification can come at any point before or after the constructor call
+     * has returned.
+     *
+     * <p>The instantiated ZooKeeper client object will pick an arbitrary server
+     * from the connect string and attempt to connect to it. If establishment of
+     * the connection fails, another server in the connect string will be tried
+     * (the order is non-deterministic, as we random shuffle the list), until a
+     * connection is established. The client will continue attempts until the
+     * session is explicitly closed (or the session is expired by the server).
+     *
+     * @param options options for ZooKeeper client
+     * @throws IOException in cases of IO failure
+     */
+    public ZooKeeper(ZooKeeperOptions options) throws IOException {
+        String connectString = options.getConnectString();
+        int sessionTimeout = options.getSessionTimeout();
+        long sessionId = options.getSessionId();
+        byte[] sessionPasswd = sessionId == 0 ? new byte[16] : options.getSessionPasswd();
+        Watcher watcher = options.getDefaultWatcher();
+        boolean canBeReadOnly = options.isCanBeReadOnly();
+
+        if (sessionId == 0) {
+            LOG.info(
+                ""Initiating client connection, connectString={} sessionTimeout={} watcher={}"",
+                connectString,
+                sessionTimeout,
+                watcher);
+        } else {
+            LOG.info(
+                ""Initiating client connection, connectString={} ""
+                    + ""sessionTimeout={} watcher={} sessionId=0x{} sessionPasswd={}"",
+                connectString,
+                sessionTimeout,
+                watcher,
+                Long.toHexString(sessionId),
+                (sessionPasswd == null ? ""<null>"" : ""<hidden>""));
+        }
+
+        ZKClientConfig clientConfig = options.getClientConfig();
         this.clientConfig = clientConfig != null ? clientConfig : new ZKClientConfig();
         ConnectStringParser connectStringParser = new ConnectStringParser(connectString);
+        HostProvider hostProvider;
+        if (options.getHostProvider() != null) {
+            hostProvider = options.getHostProvider().apply(connectStringParser.getServerAddresses());
+        } else {
+            hostProvider = new StaticHostProvider(connectStringParser.getServerAddresses());","[{'comment': '<picture><img alt=""15% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/15/display.svg""></picture>\n\n<b>*NULL_DEREFERENCE:</b>*  object returned by `getServerAddresses(connectStringParser)` could be null and is dereferenced by call to `StaticHostProvider(...)` at line 1091.\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}, {'comment': 'This is false negative. `ConnectStringParser.serverAddresses` is never `null` so does `connectStringParser.getServerAddresses()`.\r\n\r\n@sonatype-lift ignore', 'commenter': 'kezhuw'}]"
2001,zookeeper-server/src/main/java/org/apache/zookeeper/client/ZooKeeperBuilder.java,"@@ -0,0 +1,207 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.client;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.net.InetSocketAddress;
+import java.util.Collection;
+import java.util.function.Function;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.yetus.audience.InterfaceStability;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.admin.ZooKeeperAdmin;
+
+/**
+ * Builder to construct {@link ZooKeeper} and its derivations.
+ *
+ * <p>Derivations should export a constructor with same signature to {@link ZooKeeper#ZooKeeper(ZooKeeperOptions)}.
+ */
+@InterfaceAudience.Public
+@InterfaceStability.Evolving
+public class ZooKeeperBuilder {
+    private final String connectString;
+    private final int sessionTimeout;
+    private Function<Collection<InetSocketAddress>, HostProvider> hostProvider;
+    private Watcher defaultWatcher;
+    private boolean canBeReadOnly = false;
+    private long sessionId = 0;
+    private byte[] sessionPasswd;
+    private ZKClientConfig clientConfig;
+
+    /**
+     * Creates a builder with given connect string and session timeout.
+     *
+     * @param connectString
+     *            comma separated host:port pairs, each corresponding to a zk
+     *            server. e.g. ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002""
+     *            If the optional chroot suffix is used the example would look
+     *            like: ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a""
+     *            where the client would be rooted at ""/app/a"" and all paths
+     *            would be relative to this root - ie getting/setting/etc...
+     *            ""/foo/bar"" would result in operations being run on
+     *            ""/app/a/foo/bar"" (from the server perspective).
+     * @param sessionTimeoutMs
+     *            session timeout in milliseconds
+     */
+    public ZooKeeperBuilder(String connectString, int sessionTimeoutMs) {
+        this.connectString = connectString;
+        this.sessionTimeout = sessionTimeoutMs;
+    }
+
+    /**
+     * Specified watcher to receive state changes, and node events if attached later.
+     *
+     * @param watcher
+     *            a watcher object which will be notified of state changes, may
+     *            also be notified for node events
+     * @return this
+     */
+    public ZooKeeperBuilder withDefaultWatcher(Watcher watcher) {
+        this.defaultWatcher = watcher;
+        return this;
+    }
+
+    /**
+     * Specifies a function to construct a {@link HostProvider} with initial server addresses from connect string.
+     *
+     * @param hostProvider
+     *            use this as HostProvider to enable custom behaviour.
+     * @return this
+     */
+    public ZooKeeperBuilder withHostProvider(Function<Collection<InetSocketAddress>, HostProvider> hostProvider) {
+        this.hostProvider = hostProvider;
+        return this;
+    }
+
+    /**
+     * Specifies whether the created client is allowed to go to read-only mode in case of partitioning.
+     *
+     * @param canBeReadOnly
+     *            whether the created client is allowed to go to
+     *            read-only mode in case of partitioning. Read-only mode
+     *            basically means that if the client can't find any majority
+     *            servers but there's partitioned server it could reach, it
+     *            connects to one in read-only mode, i.e. read requests are
+     *            allowed while write requests are not. It continues seeking for
+     *            majority in the background.
+     * @return this
+     * @since 3.4
+     */
+    public ZooKeeperBuilder withCanBeReadOnly(boolean canBeReadOnly) {
+        this.canBeReadOnly = canBeReadOnly;
+        return this;
+    }
+
+    /**
+     * Specifies session id and password in session reestablishment.
+     *
+     * @param sessionId
+     *            session id to use if reconnecting, otherwise 0 to open new session
+     * @param sessionPasswd
+     *            password for this session
+     * @return this
+     * @see ZooKeeper#getSessionId()
+     * @see ZooKeeper#getSessionPasswd()
+     */
+    @SuppressFBWarnings({""EI_EXPOSE_REP"", ""EI_EXPOSE_REP2""})
+    public ZooKeeperBuilder withSession(long sessionId, byte[] sessionPasswd) {
+        this.sessionId = sessionId;
+        this.sessionPasswd = sessionPasswd;
+        return this;
+    }
+
+    /**
+     * Specifies the client config used to construct ZooKeeper instances.
+     *
+     * @param clientConfig
+     *            passing this conf object gives each client the flexibility of
+     *            configuring properties differently compared to other instances
+     * @return this
+     * @since 3.5.2
+     */
+    public ZooKeeperBuilder withClientConfig(ZKClientConfig clientConfig) {
+        this.clientConfig = clientConfig;
+        return this;
+    }
+
+    /**
+     * Creates a {@link ZooKeeperOptions} with configured options.
+     */
+    public ZooKeeperOptions toOptions() {
+        return new ZooKeeperOptions(
+            connectString,
+            sessionTimeout,
+            defaultWatcher,
+            hostProvider,
+            canBeReadOnly,
+            sessionId,
+            sessionPasswd,
+            clientConfig
+        );
+    }
+
+    /**
+     * Constructs an instance of {@link ZooKeeper}.
+     *
+     * @return an instance of {@link ZooKeeper}
+     * @throws IOException from constructor of {@link ZooKeeper}
+     */
+    public ZooKeeper build() throws IOException {
+        return new ZooKeeper(toOptions());
+    }
+
+    /**
+     * Constructs ZooKeeper instance using constructor of given class.
+     *
+     * @param clazz class of target ZooKeeper instance
+     * @return ZooKeeper instance
+     * @param <T> type of ZooKeeper instance
+     * @throws IllegalArgumentException if given class does not export required constructor
+     * @throws RuntimeException from constructor of ZooKeeper instance
+     * @throws IOException from constructor of ZooKeeper instance or wrapper of no IO exception
+     */
+    @SuppressWarnings(""unchecked"")
+    public <T extends ZooKeeper> T build(Class<T> clazz) throws IOException {","[{'comment': ""Please don't go this way.\r\n\r\nThis is totally out of our control.\r\nIf developers know the class they can instantiate it explicitly.\r\n\r\nIt it fine to add a  buildZooKeeperAdmin() method "", 'commenter': 'eolivelli'}, {'comment': 'I felt similar(multiple ways to construct). I think there are candidates for us to go:\r\n\r\n1. Only `build` and `buildAdmin` for `ZooKeeper` and `ZooKeeperAdmin`. For other derivations, they should resort to `ZooKeeperBuilder.toOptions` and `CustomZooKeeper(ZooKeeperOptions)` for full options customization.\r\n2. Restrict `ZooKeeperBuilder.toOptions` to some level of private, so `CustomZooKeeper(ZooKeeperOptions)` is a simple hook for `ZooKeeperBuilder`. This way clients are encouraged(or forced) to use `ZooKeeperBuilder::build(Class<T> class)` to construct `CustomZooKeeper`.\r\n3. Combine above two and support only `ZooKeeper` and `ZooKeeperAdmin`. No third party derivations are supported or encouraged.\r\n\r\nMaybe we can go 3 and unleash restriction in future if requested ? Currently, all other derivations are test purpose.\r\n\r\nFor ""some level of private"", I means `@InterfaceAudience.Private` or moving to package where `ZooKeeper` resides in.', 'commenter': 'kezhuw'}, {'comment': 'I have added a follow up commit to build only `ZooKeeper` and `ZooKeeperAdmin`(e.g. candidate 3 from above).\r\n\r\nI limited `ZooKeeper(ZooKeeperOptions options)`, `ZooKeeperAdmin(ZooKeeperOptions options)` and `ZooKeeperOptions` to private using `InterfaceAudience.Private` now. `ZooKeeperAdmin` resides in different package than `ZooKeeper`, so I have resorted to `InterfaceAudience.Private` somewhere.\r\n', 'commenter': 'kezhuw'}, {'comment': ""> No third party derivations are supported or encouraged\r\n\r\nAnyone inherits `ZooKeeper` should be fine to build their own constructing method. And yes, we don't encourage that. If it's a common use case, it can go to upstream; if it's not, the upstream can be refactored to accept combination over inheritance. `ZooKeeper` is one of the key abstractions we deliver to users."", 'commenter': 'tisonkun'}]"
2002,zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotRecursiveSummary.java,"@@ -0,0 +1,134 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.InputArchive;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.zookeeper.server.persistence.FileSnap;
+import org.apache.zookeeper.server.persistence.SnapStream;
+
+/**
+ * Recursively processes a snapshot file collecting child node count and summarizes the data size
+ * below each node.
+ * ""starting_node"" defines the node where the recursion starts
+ * ""max_depth"" defines the depth where the tool still writes to the output.
+ * 0 means there is no depth limit, every non-leaf node's stats will be displayed, 1 means it will
+ * only contain the starting node's and it's children's stats, 2 ads another level and so on.
+ * This ONLY affects the level of details displayed, NOT the calculation.
+ */
+@InterfaceAudience.Public public class SnapshotRecursiveSummary {
+
+  /**
+   * USAGE: SnapsotRecursiveSummary snapshot_file starting_node max_depth
+   *
+   */
+  public static void main(String[] args) throws Exception {
+    if (args.length != 3) {
+      System.err.println(getUsage());
+      System.exit(2);
+    }
+    int maxDepth = 0;
+    try {
+      maxDepth = Integer.parseInt(args[2]);
+    } catch (NumberFormatException e) {
+      System.err.println(getUsage());
+      System.exit(2);
+    }
+
+    new SnapshotRecursiveSummary().run(args[0], args[1], maxDepth);
+  }
+
+  public void run(String snapshotFileName, String startingNode, int maxDepth) throws IOException {
+    File snapshotFile = new File(snapshotFileName);
+    try (InputStream is = SnapStream.getInputStream(snapshotFile)) {
+      InputArchive ia = BinaryInputArchive.getArchive(is);
+
+      DataTree dataTree = new DataTree();
+      Map<Long, Integer> sessions = new HashMap<>();
+      FileSnap.deserialize(dataTree, sessions, ia);","[{'comment': '<picture><img alt=""14% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/14/display.svg""></picture>\n\n<b>*RESOURCE_LEAK:</b>*  resource of type `java.io.DataInputStream` acquired by call to `getArchive(...)` at line 68 is not released after line 72.\n\n❗❗ <b>5 similar findings have been found in this PR</b>\n\n<details><summary>🔎 Expand here to view all instances of this finding</summary><br/>\n  \n  \n<div align=\\""center\\"">\n\n\n| **File Path** | **Line Number** |\n| ------------- | ------------- |\n| zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxnSocket.java | [143](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxnSocket.java#L143) |\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotFormatter.java | [102](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotFormatter.java#L102) |\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/NIOServerCnxn.java | [440](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/zookeeper-server/src/main/java/org/apache/zookeeper/server/NIOServerCnxn.java#L440) |\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/NIOServerCnxn.java | [439](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/zookeeper-server/src/main/java/org/apache/zookeeper/server/NIOServerCnxn.java#L439) |\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotComparer.java | [268](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotComparer.java#L268) |\n<p><a href=""https://lift.sonatype.com/results/github.com/apache/zookeeper/01H2QBJ7D0JVSBB9367JMDYSEK?t=Infer|RESOURCE_LEAK"" target=""_blank"">Visit the Lift Web Console</a> to find more details in your report.</p></div></details>\n\n\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}]"
2002,zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotRecursiveSummary.java,"@@ -0,0 +1,134 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.InputArchive;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.zookeeper.server.persistence.FileSnap;
+import org.apache.zookeeper.server.persistence.SnapStream;
+
+/**
+ * Recursively processes a snapshot file collecting child node count and summarizes the data size
+ * below each node.
+ * ""starting_node"" defines the node where the recursion starts
+ * ""max_depth"" defines the depth where the tool still writes to the output.
+ * 0 means there is no depth limit, every non-leaf node's stats will be displayed, 1 means it will
+ * only contain the starting node's and it's children's stats, 2 ads another level and so on.
+ * This ONLY affects the level of details displayed, NOT the calculation.
+ */
+@InterfaceAudience.Public public class SnapshotRecursiveSummary {
+
+  /**
+   * USAGE: SnapsotRecursiveSummary snapshot_file starting_node max_depth
+   *
+   */
+  public static void main(String[] args) throws Exception {
+    if (args.length != 3) {
+      System.err.println(getUsage());
+      System.exit(2);
+    }
+    int maxDepth = 0;
+    try {
+      maxDepth = Integer.parseInt(args[2]);
+    } catch (NumberFormatException e) {
+      System.err.println(getUsage());
+      System.exit(2);
+    }
+
+    new SnapshotRecursiveSummary().run(args[0], args[1], maxDepth);
+  }
+
+  public void run(String snapshotFileName, String startingNode, int maxDepth) throws IOException {
+    File snapshotFile = new File(snapshotFileName);","[{'comment': '<picture><img alt=""9% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/9/display.svg""></picture>\n\n<b>*[PATH_TRAVERSAL_IN](https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN):</b>*  This API (java/io/File.<init>(Ljava/lang/String;)V) reads a file whose location might be specified by user input\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}]"
2002,zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/JettyAdminServer.java,"@@ -253,21 +259,88 @@ protected void doGet(
 
             // Extract keyword arguments to command from request parameters
             @SuppressWarnings(""unchecked"") Map<String, String[]> parameterMap = request.getParameterMap();
-            Map<String, String> kwargs = new HashMap<String, String>();
+            Map<String, String> kwargs = new HashMap<>();
             for (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {
                 kwargs.put(entry.getKey(), entry.getValue()[0]);
             }
+            final String authInfo = request.getHeader(HttpHeader.AUTHORIZATION.asString());
 
             // Run the command
-            CommandResponse cmdResponse = Commands.runCommand(cmd, zkServer, kwargs);
+            final CommandResponse cmdResponse = Commands.runGetCommand(cmd, zkServer, kwargs, authInfo, request);
+            response.setStatus(cmdResponse.getStatusCode());
 
-            // Format and print the output of the command
-            CommandOutputter outputter = new JsonOutputter();
-            response.setStatus(HttpServletResponse.SC_OK);
+            final Map<String, String> headers = cmdResponse.getHeaders();
+            for (final Map.Entry<String, String> header : headers.entrySet()) {
+                response.addHeader(header.getKey(), header.getValue());
+            }
+            final String clientIP = IPAuthenticationProvider.getClientIPAddress(request);
+            if (cmdResponse.getInputStream() == null) {
+                // Format and print the output of the command
+                CommandOutputter outputter = new JsonOutputter(clientIP);
+                response.setContentType(outputter.getContentType());
+                outputter.output(cmdResponse, response.getWriter());
+            } else {
+                // Stream out the output of the command
+                CommandOutputter outputter = new StreamOutputter(clientIP);
+                response.setContentType(outputter.getContentType());
+                outputter.output(cmdResponse, response.getOutputStream());
+            }
+        }
+
+        /**
+         * Serves HTTP POST requests. It reads request payload as raw data.
+         * It's up to each command to process the payload accordingly.
+         * For example, RestoreCommand uses the payload InputStream directly
+         * to read snapshot data.
+         */
+        @Override
+        protected void doPost(final HttpServletRequest request,
+                              final HttpServletResponse response) throws ServletException, IOException {
+            final String cmdName = extractCommandNameFromURL(request, response);
+            if (cmdName != null) {
+                final String authInfo = request.getHeader(HttpHeader.AUTHORIZATION.asString());
+                final CommandResponse cmdResponse = Commands.runPostCommand(cmdName, zkServer, request.getInputStream(), authInfo, request);
+                final String clientIP = IPAuthenticationProvider.getClientIPAddress(request);
+                sendJSONResponse(response, cmdResponse, clientIP);
+            }
+        }
+
+        /**
+         * Extracts the command name from URL if it exists otherwise null
+         */
+        private String extractCommandNameFromURL(final HttpServletRequest request,
+                                                 final HttpServletResponse response) throws IOException {
+            String cmd = request.getPathInfo();
+            if (cmd == null || cmd.equals(""/"")) {
+                printCommandLinks(response);
+                return null;
+            }
+            // Strip leading ""/""
+            return cmd.substring(1);
+        }
+
+        /**
+         * Prints the list of URLs to each registered command as response.
+         */
+        private void printCommandLinks(final HttpServletResponse response) throws IOException {
+            for (final String link : commandLinks()) {
+                response.getWriter().println(link);","[{'comment': '<picture><img alt=""18% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/18/display.svg""></picture>\n\n<b>*[XSS_SERVLET](https://find-sec-bugs.github.io/bugs.htm#XSS_SERVLET):</b>*  This use of java/io/PrintWriter.println(Ljava/lang/String;)V could be vulnerable to XSS in the Servlet\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}]"
2002,zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java,"@@ -772,16 +765,16 @@ public Stat setACL(String path, List<ACL> acl, int version) throws KeeperExcepti
         }
     }
 
-    public List<ACL> getACL(String path, Stat stat) throws KeeperException.NoNodeException {
+    public List<ACL> getACL(String path, Stat stat) throws NoNodeException {
         DataNode n = nodes.get(path);
         if (n == null) {
-            throw new KeeperException.NoNodeException();
+            throw new NoNodeException();
         }
         synchronized (n) {
             if (stat != null) {
                 n.copyStat(stat);
             }
-            return new ArrayList<ACL>(aclCache.convertLong(n.acl));
+            return new ArrayList<>(aclCache.convertLong(n.acl));","[{'comment': '<picture><img alt=""7% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/7/display.svg""></picture>\n\n<b>*THREAD_SAFETY_VIOLATION:</b>*  Read/Write race. Non-private method `DataTree.getACL(...)` indirectly reads with synchronization from container `this.aclCache.longKeyMap` via call to `Map.get(...)`. Potentially races with unsynchronized write in method `DataTree.deserialize(...)`.\n Reporting because this access may occur on a background thread.\n\n❗❗ <b>8 similar findings have been found in this PR</b>\n\n<details><summary>🔎 Expand here to view all instances of this finding</summary><br/>\n  \n  \n<div align=\\""center\\"">\n\n\n| **File Path** | **Line Number** |\n| ------------- | ------------- |\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java | [1515](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java#L1515) |\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java | [317](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java#L317) |\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java | [326](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java#L326) |\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java | [1488](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java#L1488) |\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java | [331](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java#L331) |\n| zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxnSocketNetty.java | [247](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxnSocketNetty.java#L247) |\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/ZKDatabase.java | [636](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZKDatabase.java#L636) |\n| zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java | [460](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java#L460) |\n<p><a href=""https://lift.sonatype.com/results/github.com/apache/zookeeper/01H2QBJ7D0JVSBB9367JMDYSEK?t=Infer|THREAD_SAFETY_VIOLATION"" target=""_blank"">Visit the Lift Web Console</a> to find more details in your report.</p></div></details>\n\n\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}]"
2002,tools/ci/test-connectivity.py,"@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import argparse
+import subprocess
+
+from pathlib import Path
+
+class Server():
+    def __init__(self, binpath):
+        self.binpath = binpath
+    def __enter__(self):
+        subprocess.run([f'{self.binpath}', 'start'], check=True)","[{'comment': '<picture><img alt=""6% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/6/display.svg""></picture>\n\n<b>*[B603](https://bandit.readthedocs.io/en/1.7.4/plugins/b603_subprocess_without_shell_equals_true.html):</b>*  subprocess call - check for execution of untrusted input.\n\n❗❗ <b>2 similar findings have been found in this PR</b>\n\n<details><summary>🔎 Expand here to view all instances of this finding</summary><br/>\n  \n  \n<div align=\\""center\\"">\n\n\n| **File Path** | **Line Number** |\n| ------------- | ------------- |\n| tools/ci/test-connectivity.py | [31](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/tools/ci/test-connectivity.py#L31) |\n| tools/ci/test-connectivity.py | [48](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/tools/ci/test-connectivity.py#L48) |\n<p><a href=""https://lift.sonatype.com/results/github.com/apache/zookeeper/01H2QBJ7D0JVSBB9367JMDYSEK?t=Bandit|B603"" target=""_blank"">Visit the Lift Web Console</a> to find more details in your report.</p></div></details>\n\n\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}]"
2002,tools/ci/test-connectivity.py,"@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import argparse
+import subprocess
+
+from pathlib import Path
+
+class Server():","[{'comment': '<picture><img alt=""8% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/8/display.svg""></picture>\n\n<b>*E302:</b>*  expected 2 blank lines, found 1\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}]"
2002,tools/ci/test-connectivity.py,"@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import argparse
+import subprocess
+
+from pathlib import Path
+
+class Server():
+    def __init__(self, binpath):
+        self.binpath = binpath
+    def __enter__(self):","[{'comment': '<picture><img alt=""11% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/11/display.svg""></picture>\n\n<b>*E301:</b>*  expected 1 blank line, found 0\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}]"
2002,tools/ci/test-connectivity.py,"@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import argparse
+import subprocess
+
+from pathlib import Path
+
+class Server():
+    def __init__(self, binpath):
+        self.binpath = binpath
+    def __enter__(self):
+        subprocess.run([f'{self.binpath}', 'start'], check=True)
+        return self
+    def __exit__(self, type, value, traceback):","[{'comment': '<picture><img alt=""11% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/11/display.svg""></picture>\n\n<b>*E301:</b>*  expected 1 blank line, found 0\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}, {'comment': '<picture><img alt=""16% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/16/display.svg""></picture>\n\n<b>*vulture-100:</b>*  unused variable \'traceback\'\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}]"
2002,tools/ci/test-connectivity.py,"@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import argparse
+import subprocess
+
+from pathlib import Path
+
+class Server():
+    def __init__(self, binpath):
+        self.binpath = binpath
+    def __enter__(self):
+        subprocess.run([f'{self.binpath}', 'start'], check=True)
+        return self
+    def __exit__(self, type, value, traceback):
+        subprocess.run([f'{self.binpath}', 'stop'], check=True)
+
+if __name__ == '__main__':","[{'comment': '<picture><img alt=""7% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/7/display.svg""></picture>\n\n<b>*E305:</b>*  expected 2 blank lines after class or function definition, found 1\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}]"
2002,tools/ci/test-connectivity.py,"@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import argparse
+import subprocess
+
+from pathlib import Path
+
+class Server():
+    def __init__(self, binpath):
+        self.binpath = binpath
+    def __enter__(self):
+        subprocess.run([f'{self.binpath}', 'start'], check=True)
+        return self
+    def __exit__(self, type, value, traceback):
+        subprocess.run([f'{self.binpath}', 'stop'], check=True)
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser()
+    parser.add_argument('--server', help=""basepath to zk server"", required=True)","[{'comment': '<picture><img alt=""6% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/6/display.svg""></picture>\n\n<b>*E501:</b>*  line too long (80 > 79 characters)\n\n❗❗ <b>3 similar findings have been found in this PR</b>\n\n<details><summary>🔎 Expand here to view all instances of this finding</summary><br/>\n  \n  \n<div align=\\""center\\"">\n\n\n| **File Path** | **Line Number** |\n| ------------- | ------------- |\n| tools/ci/test-connectivity.py | [36](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/tools/ci/test-connectivity.py#L36) |\n| tools/ci/test-connectivity.py | [42](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/tools/ci/test-connectivity.py#L42) |\n| tools/ci/test-connectivity.py | [45](https://github.com/apache/zookeeper/blob/e18effa279d8787adf91e796f2fdc4a27c958f1e/tools/ci/test-connectivity.py#L45) |\n<p><a href=""https://lift.sonatype.com/results/github.com/apache/zookeeper/01H2QBJ7D0JVSBB9367JMDYSEK?t=Flake8|E501"" target=""_blank"">Visit the Lift Web Console</a> to find more details in your report.</p></div></details>\n\n\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}]"
2002,tools/ci/test-connectivity.py,"@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import argparse
+import subprocess
+
+from pathlib import Path
+
+class Server():
+    def __init__(self, binpath):
+        self.binpath = binpath
+    def __enter__(self):
+        subprocess.run([f'{self.binpath}', 'start'], check=True)
+        return self
+    def __exit__(self, type, value, traceback):
+        subprocess.run([f'{self.binpath}', 'stop'], check=True)
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser()
+    parser.add_argument('--server', help=""basepath to zk server"", required=True)
+    parser.add_argument('--client', help=""basepath to zk client"", required=True)
+
+    args = parser.parse_args()
+    ","[{'comment': '<picture><img alt=""12% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/12/display.svg""></picture>\n\n<b>*W293:</b>*  blank line contains whitespace\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}]"
2002,zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotRecursiveSummary.java,"@@ -0,0 +1,134 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.InputArchive;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.zookeeper.server.persistence.FileSnap;
+import org.apache.zookeeper.server.persistence.SnapStream;
+
+/**
+ * Recursively processes a snapshot file collecting child node count and summarizes the data size
+ * below each node.
+ * ""starting_node"" defines the node where the recursion starts
+ * ""max_depth"" defines the depth where the tool still writes to the output.
+ * 0 means there is no depth limit, every non-leaf node's stats will be displayed, 1 means it will
+ * only contain the starting node's and it's children's stats, 2 ads another level and so on.
+ * This ONLY affects the level of details displayed, NOT the calculation.
+ */
+@InterfaceAudience.Public public class SnapshotRecursiveSummary {
+
+  /**
+   * USAGE: SnapsotRecursiveSummary snapshot_file starting_node max_depth
+   *
+   */
+  public static void main(String[] args) throws Exception {
+    if (args.length != 3) {
+      System.err.println(getUsage());
+      System.exit(2);
+    }
+    int maxDepth = 0;
+    try {
+      maxDepth = Integer.parseInt(args[2]);
+    } catch (NumberFormatException e) {
+      System.err.println(getUsage());
+      System.exit(2);
+    }
+
+    new SnapshotRecursiveSummary().run(args[0], args[1], maxDepth);
+  }
+
+  public void run(String snapshotFileName, String startingNode, int maxDepth) throws IOException {
+    File snapshotFile = new File(snapshotFileName);
+    try (InputStream is = SnapStream.getInputStream(snapshotFile)) {","[{'comment': '<picture><img alt=""3% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/3/display.svg""></picture>\n\n<b>*PULSE_RESOURCE_LEAK:</b>*  Resource dynamically allocated by constructor java.io.DataInputStream(), indirectly via call to `BinaryInputArchive.getArchive(...)` on line 68 is not closed after the last access at line 67.\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}]"
2002,bin/zkSnapshotRecursiveSummaryToolkit.sh,"@@ -0,0 +1,39 @@
+#!/usr/bin/env bash
+
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#
+# If this scripted is run out of /usr/bin or some other system bin directory
+# it should be linked to and not copied. Things like java jar files are found
+# relative to the canonical path of this script.
+#
+
+# use POSIX interface, symlink is followed automatically
+ZOOBIN=""${BASH_SOURCE-$0}""
+ZOOBIN=""$(dirname ""${ZOOBIN}"")""
+ZOOBINDIR=""$(cd ""${ZOOBIN}""; pwd)""","[{'comment': '<picture><img alt=""23% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/23/display.svg""></picture>\n\n<b>*[SC2164](https://github.com/koalaman/shellcheck/wiki/SC2164):</b>*  Use \'cd ... || exit\' or \'cd ... || return\' in case cd fails.\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}]"
2002,bin/zkSnapshotRecursiveSummaryToolkit.sh,"@@ -0,0 +1,39 @@
+#!/usr/bin/env bash
+
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#
+# If this scripted is run out of /usr/bin or some other system bin directory
+# it should be linked to and not copied. Things like java jar files are found
+# relative to the canonical path of this script.
+#
+
+# use POSIX interface, symlink is followed automatically
+ZOOBIN=""${BASH_SOURCE-$0}""
+ZOOBIN=""$(dirname ""${ZOOBIN}"")""
+ZOOBINDIR=""$(cd ""${ZOOBIN}""; pwd)""
+
+if [ -e ""$ZOOBIN/../libexec/zkEnv.sh"" ]; then
+  # shellcheck source=/bin/zkEnv.sh
+  . ""$ZOOBINDIR""/../libexec/zkEnv.sh
+else
+  . ""$ZOOBINDIR""/zkEnv.sh","[{'comment': '<picture><img alt=""23% of developers fix this issue"" src=""https://lift.sonatype.com/api/commentimage/fixrate/23/display.svg""></picture>\n\n<b>*[SC1091](https://github.com/koalaman/shellcheck/wiki/SC1091):</b>*  Not following: ./zkEnv.sh was not specified as input (see shellcheck -x).\n\n---\n\n<details><summary>ℹ️ Expand to see all <b>@sonatype-lift</b> commands</summary>\n\nYou can reply with the following commands. For example, reply with ***@sonatype-lift ignoreall*** to leave out all findings.\n| **Command** | **Usage** |\n| ------------- | ------------- |\n| `@sonatype-lift ignore` | Leave out the above finding from this PR |\n| `@sonatype-lift ignoreall` | Leave out all the existing findings from this PR |\n| `@sonatype-lift exclude <file\\|issue\\|path\\|tool>` | Exclude specified `file\\|issue\\|path\\|tool` from Lift findings by updating your config.toml file |\n\n**Note:** When talking to LiftBot, you need to **refresh** the page to see its response.\n<sub>[Click here](https://github.com/apps/sonatype-lift/installations/new) to add LiftBot to another repo.</sub></details>\n\n', 'commenter': 'sonatype-lift[bot]'}]"
2009,zookeeper-server/src/main/java/org/apache/zookeeper/common/X509Util.java,"@@ -627,6 +631,113 @@ public void enableCertFileReloading() throws IOException {
         }
     }
 
+    public SslContext createNettySslContextForClient(ZKConfig config)
+        throws KeyManagerException, TrustManagerException, SSLException {
+        String keyStoreLocation = config.getProperty(sslKeystoreLocationProperty, """");
+        String keyStorePassword = getPasswordFromConfigPropertyOrFile(config, sslKeystorePasswdProperty, sslKeystorePasswdPathProperty);
+        String keyStoreType = config.getProperty(sslKeystoreTypeProperty);
+
+        SslContextBuilder sslContextBuilder = SslContextBuilder.forClient();
+
+        if (keyStoreLocation.isEmpty()) {
+            LOG.warn(""{} not specified"", getSslKeystoreLocationProperty());
+        } else {
+            sslContextBuilder.keyManager(createKeyManager(keyStoreLocation, keyStorePassword, keyStoreType));
+        }
+
+        String trustStoreLocation = config.getProperty(sslTruststoreLocationProperty, """");
+        String trustStorePassword = getPasswordFromConfigPropertyOrFile(config, sslTruststorePasswdProperty, sslTruststorePasswdPathProperty);
+        String trustStoreType = config.getProperty(sslTruststoreTypeProperty);
+
+        boolean sslCrlEnabled = config.getBoolean(this.sslCrlEnabledProperty);
+        boolean sslOcspEnabled = config.getBoolean(this.sslOcspEnabledProperty);
+        boolean sslServerHostnameVerificationEnabled = config.getBoolean(this.getSslHostnameVerificationEnabledProperty(), true);
+        boolean sslClientHostnameVerificationEnabled = sslServerHostnameVerificationEnabled && shouldVerifyClientHostname();
+
+        if (trustStoreLocation.isEmpty()) {
+            LOG.warn(""{} not specified"", getSslTruststoreLocationProperty());
+        } else {
+            sslContextBuilder.trustManager(createTrustManager(trustStoreLocation, trustStorePassword, trustStoreType,
+                sslCrlEnabled, sslOcspEnabled, sslServerHostnameVerificationEnabled, sslClientHostnameVerificationEnabled));
+        }
+
+        sslContextBuilder.enableOcsp(sslOcspEnabled);
+        sslContextBuilder.protocols(getEnabledProtocols(config));
+        sslContextBuilder.ciphers(getCipherSuites(config));
+
+        return sslContextBuilder.build();
+    }
+
+    public SslContext createNettySslContextForServer(ZKConfig config)","[{'comment': 'Give the option to force SSL providers like JDK or OpenSSL. There can be cases when the user has OpenSSL configured but still wants to use the JDK provider.', 'commenter': 'hyperxpro'}, {'comment': 'Also the tcnative library may not be available on all the platforms ', 'commenter': 'eolivelli'}, {'comment': ""Good catch, I'll add the option to force the provider. \r\n\r\n@eolivelli \r\n> Also the tcnative library may not be available on all the platforms\r\n\r\nWith or without forcing the provider, Netty will always fallback to JDK if native provider cannot be found. What do you mean by the above statement?"", 'commenter': 'anmolnar'}, {'comment': ""Maybe recent versions of tcnative cover all the platforms, I haven't checked.\r\n\r\nWe should bundle the library at least for linux and it would be really nice to have it for mac on x86 and arm (M1)\r\n\r\n\r\n"", 'commenter': 'eolivelli'}, {'comment': ""Do you mean the convenient jar?\r\n\r\nBecause officially, as an Apache product, we don't ship anything in binary form. My suggestion was only about making it easier for the user to _build_ the product with native support. I think whatever we include in the convenient jar, it doesn't have to be complete for every single platform.\r\n\r\nIncluding only the Linux bits (which platform x86_64? which distro fedora, ubuntu?) is more than enough I believe."", 'commenter': 'anmolnar'}]"
2009,zookeeper-server/src/main/java/org/apache/zookeeper/common/ClientX509Util.java,"@@ -36,4 +55,149 @@ public String getSslAuthProviderProperty() {
         return sslAuthProviderProperty;
     }
 
+    public String getSslProviderProperty() {
+        return sslProviderProperty;
+    }
+
+    public SslContext createNettySslContextForClient(ZKConfig config)
+        throws X509Exception.KeyManagerException, X509Exception.TrustManagerException, SSLException {
+        String keyStoreLocation = config.getProperty(getSslKeystoreLocationProperty(), """");
+        String keyStorePassword = getPasswordFromConfigPropertyOrFile(config, getSslKeystorePasswdProperty(),
+            getSslKeystorePasswdPathProperty());
+        String keyStoreType = config.getProperty(getSslKeystoreTypeProperty());
+
+        SslContextBuilder sslContextBuilder = SslContextBuilder.forClient();
+
+        if (keyStoreLocation.isEmpty()) {
+            LOG.warn(""{} not specified"", getSslKeystoreLocationProperty());
+        } else {
+            sslContextBuilder.keyManager(createKeyManager(keyStoreLocation, keyStorePassword, keyStoreType));
+        }
+
+        TrustManager tm = getTrustManager(config);
+        if (tm != null) {
+            sslContextBuilder.trustManager(tm);
+        }
+
+        sslContextBuilder.enableOcsp(config.getBoolean(getSslOcspEnabledProperty()));
+        sslContextBuilder.protocols(getEnabledProtocols(config));
+        Iterable<String> enabledCiphers = getCipherSuites(config);
+        if (enabledCiphers != null) {
+            sslContextBuilder.ciphers(enabledCiphers);
+        }
+        sslContextBuilder.sslProvider(getSslProvider(config));
+
+        SslContext sslContext1 = sslContextBuilder.build();
+
+        if (getFipsMode(config) && isServerHostnameVerificationEnabled(config)) {
+            return addHostnameVerification(sslContext1, ""Server"");
+        } else {
+            return sslContext1;
+        }
+    }
+
+    public SslContext createNettySslContextForServer(ZKConfig config)
+        throws X509Exception.SSLContextException, X509Exception.KeyManagerException, X509Exception.TrustManagerException, SSLException {
+        String keyStoreLocation = config.getProperty(getSslKeystoreLocationProperty(), """");
+        String keyStorePassword = getPasswordFromConfigPropertyOrFile(config, getSslKeystorePasswdProperty(),
+            getSslKeystorePasswdPathProperty());
+        String keyStoreType = config.getProperty(getSslKeystoreTypeProperty());
+
+        if (keyStoreLocation.isEmpty()) {
+            throw new X509Exception.SSLContextException(
+                ""Keystore is required for SSL server: "" + getSslKeystoreLocationProperty());
+        }
+
+        KeyManager km = createKeyManager(keyStoreLocation, keyStorePassword, keyStoreType);
+
+        return createNettySslContextForServer(config, km, getTrustManager(config));
+    }
+
+    public SslContext createNettySslContextForServer(ZKConfig config, KeyManager keyManager, TrustManager trustManager) throws SSLException {
+        SslContextBuilder sslContextBuilder = SslContextBuilder.forServer(keyManager);
+
+        if (trustManager != null) {
+            sslContextBuilder.trustManager(trustManager);
+        }
+
+        sslContextBuilder.enableOcsp(config.getBoolean(getSslOcspEnabledProperty()));
+        sslContextBuilder.protocols(getEnabledProtocols(config));
+        sslContextBuilder.clientAuth(getClientAuth(config).toNettyClientAuth());
+        Iterable<String> enabledCiphers = getCipherSuites(config);
+        if (enabledCiphers != null) {
+            sslContextBuilder.ciphers(enabledCiphers);
+        }
+        sslContextBuilder.sslProvider(getSslProvider(config));
+
+        SslContext sslContext1 = sslContextBuilder.build();
+
+        if (getFipsMode(config) && isClientHostnameVerificationEnabled(config)) {
+            return addHostnameVerification(sslContext1, ""Client"");
+        } else {
+            return sslContext1;
+        }
+    }
+
+    private SslContext addHostnameVerification(SslContext sslContext, String clientOrServer) {
+        return new DelegatingSslContext(sslContext) {
+            @Override
+            protected void initEngine(SSLEngine sslEngine) {
+                SSLParameters sslParameters = sslEngine.getSSLParameters();
+                sslParameters.setEndpointIdentificationAlgorithm(""HTTPS"");
+                sslEngine.setSSLParameters(sslParameters);
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""{} hostname verification: enabled HTTPS style endpoint identification algorithm"", clientOrServer);
+                }
+            }
+        };
+    }
+
+    private String[] getEnabledProtocols(final ZKConfig config) {
+        String enabledProtocolsInput = config.getProperty(getSslEnabledProtocolsProperty());
+        if (enabledProtocolsInput == null) {
+            return new String[]{ config.getProperty(getSslProtocolProperty(), DEFAULT_PROTOCOL) };
+        }
+        return enabledProtocolsInput.split("","");
+    }
+
+    private X509Util.ClientAuth getClientAuth(final ZKConfig config) {
+        return X509Util.ClientAuth.fromPropertyValue(config.getProperty(getSslClientAuthProperty()));
+    }
+
+    private Iterable<String> getCipherSuites(final ZKConfig config) {
+        String cipherSuitesInput = config.getProperty(getSslCipherSuitesProperty());
+        if (cipherSuitesInput == null) {
+            if (getSslProvider(config) != SslProvider.JDK) {","[{'comment': ""This doesn't seem right honestly. Only BoringSSL with TLS v1.3 doesn't allow you to set custom cipher suites, but TLS v1.2 and TLS v1.1 allows that. Also, OpenSSL static and dynamic allows custom cipher suites for all TLS versions.\r\n\r\nSee: https://github.com/netty/netty/issues/10172"", 'commenter': 'hyperxpro'}, {'comment': ""You can still use custom ciphers. This will return the list of ciphers in the config if it's found in the right property. I only removed the optimized cipher selection that we did previously, because looks like they're mostly only supported in JDK. I don't have bandwidth now to test and benchmark them with OpenSSL and create new specific lists."", 'commenter': 'anmolnar'}, {'comment': '@hyperxpro Did you check my answer above?', 'commenter': 'anmolnar'}, {'comment': 'Yeah, looks fine.', 'commenter': 'hyperxpro'}]"
2024,zookeeper-jute/src/main/java/org/apache/jute/BinaryOutputArchive.java,"@@ -108,18 +116,22 @@ public void writeString(String s, String tag) throws IOException {
             return;
         }
         ByteBuffer bb = stringToByteBuffer(s);
-        writeInt(bb.remaining(), ""len"");
+        int strLen = bb.remaining();
+        writeInt(strLen, ""len"");
         out.write(bb.array(), bb.position(), bb.limit());
+        dataSize += strLen;","[{'comment': 'Since we write an int first, share we `+4` here? Ditto `writeBuffer`. ', 'commenter': 'tisonkun'}, {'comment': 'line_120. It will `+4` in `writeInt`.', 'commenter': 'horizonzy'}, {'comment': ""You're right 😆 "", 'commenter': 'tisonkun'}]"
2024,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -289,22 +297,25 @@ public synchronized boolean append(TxnHeader hdr, Record txn, TxnDigest digest)
             logStream = new BufferedOutputStream(fos);
             oa = BinaryOutputArchive.getArchive(logStream);
             FileHeader fhdr = new FileHeader(TXNLOG_MAGIC, VERSION, dbId);
+            long dataSize = oa.getDataSize();
             fhdr.serialize(oa, ""fileheader"");
             // Make sure that the magic number is written before padding.
             logStream.flush();
-            filePadding.setCurrentSize(fos.getChannel().position());
+            filePosition += oa.getDataSize() - dataSize;","[{'comment': 'Can you describe a bit how this calculation is correct?', 'commenter': 'tisonkun'}, {'comment': 'FilePosition: The position of the file which has already been flushed to file.\r\n\r\nIn this case, we initial the OutputArchive, and write the file header to it, then invoke `logStream.flush()`. \r\nBefore writing the header, we record the dataSize. After writing the header, we use the current dataSize minus the before dataSize, to get the position.\r\n', 'commenter': 'horizonzy'}, {'comment': 'can you please add a comment in the code @horizonzy  ?', 'commenter': 'eolivelli'}]"
2024,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -289,22 +297,25 @@ public synchronized boolean append(TxnHeader hdr, Record txn, TxnDigest digest)
             logStream = new BufferedOutputStream(fos);
             oa = BinaryOutputArchive.getArchive(logStream);
             FileHeader fhdr = new FileHeader(TXNLOG_MAGIC, VERSION, dbId);
+            long dataSize = oa.getDataSize();
             fhdr.serialize(oa, ""fileheader"");
             // Make sure that the magic number is written before padding.
             logStream.flush();
-            filePadding.setCurrentSize(fos.getChannel().position());
+            filePosition += oa.getDataSize() - dataSize;
+            filePadding.setCurrentSize(filePosition);
             streamsToFlush.add(fos);
         }
-        filePadding.padFile(fos.getChannel());
+        fileSize = filePadding.padFile(fos.getChannel(), filePosition);
         byte[] buf = Util.marshallTxnEntry(hdr, txn, digest);
         if (buf == null || buf.length == 0) {
             throw new IOException(""Faulty serialization for header "" + ""and txn"");
         }
+        long dataSize = oa.getDataSize();
         Checksum crc = makeChecksumAlgorithm();
         crc.update(buf, 0, buf.length);
         oa.writeLong(crc.getValue(), ""txnEntryCRC"");
         Util.writeTxnBytes(oa, buf);
-
+        unFlushedSize += oa.getDataSize() - dataSize;","[{'comment': 'Can you describe a bit how this calculation is correct?', 'commenter': 'tisonkun'}, {'comment': ""UnFlushedSize: The position of the file which already write to the channel, but not flush to the channel.\r\n\r\nIn this case, we record the dataSize before writing data. Then write `CRC`, `serializeData`, but we didn't flush. So we use the current dataSize minus the before dataSize, to get the unFlushedSize.\r\n\r\nIn the commit, we will add the unFlushedSize to the filePosition.\r\n\r\n"", 'commenter': 'horizonzy'}, {'comment': 'please add a comment in the code, it is not straightforward', 'commenter': 'eolivelli'}, {'comment': 'addressed', 'commenter': 'horizonzy'}]"
2024,zookeeper-jute/src/main/java/org/apache/jute/BinaryOutputArchive.java,"@@ -34,6 +34,8 @@ public class BinaryOutputArchive implements OutputArchive {
 
     private DataOutput out;
 
+    private long dataSize;","[{'comment': 'We need to initialize the `dataSize` to 0', 'commenter': 'hangc0276'}]"
2024,zookeeper-jute/src/main/java/org/apache/jute/ToStringOutputArchive.java,"@@ -32,6 +32,7 @@ public class ToStringOutputArchive implements OutputArchive {
 
     private PrintStream stream;
     private boolean isFirst = true;
+    private long dataSize;","[{'comment': 'Need initialize to 0', 'commenter': 'hangc0276'}, {'comment': ""I don't understand this comment @hangc0276 \r\nthe default value of a long is always 0"", 'commenter': 'eolivelli'}]"
2024,zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnLog.java,"@@ -376,6 +387,12 @@ public long getLastLoggedZxid() {
     public synchronized void commit() throws IOException {
         if (logStream != null) {
             logStream.flush();
+            filePosition += unFlushedSize;
+            //It is the same as the FilePadding.calculateFileSizeWithPadding line_106.","[{'comment': 'unfortunately ""line_106"" will move in the future, please remove this word.\r\n\r\nyou can add a javadoc with a {@link } comment to the method', 'commenter': 'eolivelli'}, {'comment': 'addressed.', 'commenter': 'horizonzy'}]"
2024,zookeeper-server/src/main/java/org/apache/zookeeper/server/Request.java,"@@ -181,8 +182,7 @@ public byte[] getSerializeData() {
             try {
                 this.serializeData = Util.marshallTxnEntry(this.hdr, this.txn, this.txnDigest);
             } catch (IOException e) {
-                LOG.error(""This really should be impossible."", e);
-                this.serializeData = new byte[32];
+                throw new UncheckedIOException(e);","[{'comment': ""I'd prefer to include this change in another PR so that if it causes issues, we can confidently revert that one instead of coupled with other changes in this patch.\r\n\r\nSince we have a lazy consensus on this change, I don't think another PR will block it's review and merge process."", 'commenter': 'tisonkun'}, {'comment': 'Fine. I will push another pr to fix it.', 'commenter': 'horizonzy'}]"
2038,Jenkinsfile-s390x,"@@ -48,7 +48,7 @@ pipeline {
                 stage('BuildAndTest') {
                     steps {
                         sh ""git clean -fxd""
-                        sh ""mvn verify spotbugs:check checkstyle:check -Pfull-build -Dsurefire-forkcount=4""
+                        sh ""mvn verify spotbugs:check checkstyle:check -Pfull-build -Dsurefire-forkcount=4 -Dtest=\!ClientSSLTest -DfailIfNoTests=false""","[{'comment': 'Thinking about this a bit more, I think you actually shouldn\'t skip the test here. Instead, do it in JUnit. In the ClientSSLTest, you can add:\r\n\r\n```java\r\n    Assumptions.assumeFalse(System.getProperty(""os.arch"").contains(""s390x""), ""Test cannot run for s390x because ..."").\r\n```\r\n\r\nIf you add something like that to the top of a test case, JUnit will not only happily skip the test, but it will also helpfully print out an explanation of why the test was skipped. Keeping the exclusion close to the test case itself is better than writing the exclusion into the Jenkinsfile.\r\n\r\nAlso, it\'s not even clear that this is a good pattern to use... as it will try to execute any utility classes as test classes, in addition to the default pattern of `*Test,Test*`.\r\n\r\nI think this should be changed to use the JUnit Assumption instead.', 'commenter': 'ctubbsii'}, {'comment': 'Thanks @ctubbsii for the detailed review. Yes, I agree that skipping the test case in ClientSSLTest.java would be better than skipping it in Jenkinsfile. I will test and push the changes.', 'commenter': 'vibhutisawant'}, {'comment': 'Hi @ctubbsii, could you please take a look at the latest changes?', 'commenter': 'vibhutisawant'}]"
2038,zookeeper-server/src/test/java/org/apache/zookeeper/test/ClientSSLTest.java,"@@ -147,6 +148,8 @@ public void testClientServerSSLWithCnxnClassName() throws Exception {
     @ParameterizedTest(name = ""sslProvider={0}, fipsEnabled={1}, hostnameVerification={2}"")
     @MethodSource(""positiveTestData"")
     public void testClientServerSSL_positive(SslProvider sslProvider, String fipsEnabled, String hostnameVerification) throws Exception {
+        //Skipping this test for s390x arch as netty-tc-native is not supported
+        assumeFalse(System.getProperty(""os.arch"").contains(""s390x""), "" Skipping for s390x arch as netty-tcnative is not yet supported."");","[{'comment': 'this change is not related to this patch\r\ncan you move it to another patch please ?', 'commenter': 'eolivelli'}, {'comment': 'Sure @eolivelli, I will create another PR to handle this change. Should I create a separate JIRA issue as well? Thanks ', 'commenter': 'vibhutisawant'}, {'comment': 'yes, it is required for each PRs, thanks', 'commenter': 'eolivelli'}, {'comment': 'Hi @eolivelli, I have raised a separate PR to address the above file changes. https://github.com/apache/zookeeper/pull/2057. Could you please have a look? Thank you.', 'commenter': 'vibhutisawant'}]"
2074,zookeeper-server/src/main/resources/lib/jetty-util-ajax-9.4.52.v20230823.LICENSE.txt,,"[{'comment': 'Why do we need a new license file?', 'commenter': 'anmolnar'}, {'comment': 'Interesting. This seems a historical issue that we can improve alongside or in another thread - we don\'t need to upgrade license file with ""version"".', 'commenter': 'tisonkun'}, {'comment': 'We were missing the license file for `jetty-client`.  (Rename detection makes this confusing.)', 'commenter': 'ztzg'}, {'comment': 'oh, I see that.', 'commenter': 'anmolnar'}, {'comment': '> Interesting. This seems a historical issue that we can improve alongside or in another thread - we don\'t need to upgrade license file with ""version"".\r\n\r\nThe churn is annoying, but my understanding is that we have to check that the license text has not been updated.  Perhaps we could avoid the version suffix to generate cleaner diffs...  For the record, each `jetty-*.jar` file contains the text in `META-INF/LICENSE`, but I suppose that is not discoverable enough.', 'commenter': 'ztzg'}]"
2076,bin/zkServer.sh,"@@ -151,6 +151,8 @@ fi
 
 ZOO_LOG_FILE=${ZOO_LOG_FILE:-zookeeper-$USER-server-$HOSTNAME.log}
 _ZOO_DAEMON_OUT=""$ZOO_LOG_DIR/zookeeper-$USER-server-$HOSTNAME.out""
+ZOO_LOG_FORMAT=${ZOO_LOG_FORMAT:-pattern}
+ZOO_VERSION=$($JAVA -cp ""$CLASSPATH"" org.apache.zookeeper.version.VersionInfoShortMain)","[{'comment': ""I don't think that this is a good idea, why  do you need it ?\r\nyou are bootstrapping a JVM here"", 'commenter': 'eolivelli'}, {'comment': ""I'm aware of that, it was a hack since I could not find another var. However I'll try to initialize `zookeeper.version` statically instead."", 'commenter': 'janhoy'}]"
2077,conf/logback.xml,"@@ -109,6 +125,6 @@
   </logger-->
 
   <root level=""INFO"">
-    <appender-ref ref=""CONSOLE"" />","[{'comment': 'Dynamically controlling the config file seems like a complicated way of customizing the config file. It would be better to use `logback.configurationFile` system property to specify a different config file, rather than make this reference one more complicated.', 'commenter': 'ctubbsii'}]"
2077,zookeeper-docs/src/main/resources/markdown/zookeeperAdmin.md,"@@ -519,6 +519,13 @@ For more information about SLF4J, see
 For more information about Logback, see
 [Logback website](http://logback.qos.ch/).
 
+#### Logging in JSON format
+
+Through its pluggable and flexible log framework, Zookeeper can easily be configured to log in JSON format.
+An example of JSON logging using the popular [ECS schema](https://doc.wikimedia.org/ecs/) is provided as a logback appender in `logback.xml`.
+You can test it by enabling the `CONSOLE-JSON` appender, e.g. by starting Zookeeper with
+the system property: `-Dzookeeper.log.appender=CONSOLE-JSON`.","[{'comment': ""JSON formatting is a niche use case. This is one of millions of possible ways of configuring logging. I'm not sure it warrants a special call out in the ZK docs. The previous paragraph already links to the logback website, if people want to do something custom with logback."", 'commenter': 'ctubbsii'}]"
2077,zookeeper-server/pom.xml,"@@ -87,6 +87,10 @@
       <groupId>ch.qos.logback</groupId>
       <artifactId>logback-classic</artifactId>
     </dependency>
+    <dependency>
+      <groupId>co.elastic.logging</groupId>
+      <artifactId>logback-ecs-encoder</artifactId>
+    </dependency>","[{'comment': ""While this might be useful for some... most people are probably not going to use this. It doesn't make sense to add this optional dependency to the class path for everybody. Some people may want a more minimal approach, for a smaller security footprint, and to save space in their downstream environment."", 'commenter': 'ctubbsii'}]"
