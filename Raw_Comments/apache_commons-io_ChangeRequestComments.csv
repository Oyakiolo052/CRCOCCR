Pull,Path,Diff_hunk,Comment
21,src/main/java/org/apache/commons/io/FileSystemUtils.java,"@@ -292,10 +292,15 @@ long freeSpaceOS(final String path, final int os, final boolean kb, final long t
      * @param timeout The timeout amount in milliseconds or no timeout if the value
      *  is zero or less
      * @return the amount of free drive space on the drive
-     * @throws IOException if an error occurs
+     * @throws IOException if an error occurs, NullPointerException if path cannot be parsed by FilenameUtils.normalize()
      */
-    long freeSpaceWindows(String path, final long timeout) throws IOException {
+    long freeSpaceWindows(String path, final long timeout) throws IOException, NullPointerException {","[{'comment': '`NullPointerException` is a `RuntimeException` so it should be part of the method signature.', 'commenter': 'PascalSchumacher'}]"
21,src/main/java/org/apache/commons/io/FileSystemUtils.java,"@@ -292,10 +292,15 @@ long freeSpaceOS(final String path, final int os, final boolean kb, final long t
      * @param timeout The timeout amount in milliseconds or no timeout if the value
      *  is zero or less
      * @return the amount of free drive space on the drive
-     * @throws IOException if an error occurs
+     * @throws IOException if an error occurs, NullPointerException if path cannot be parsed by FilenameUtils.normalize()","[{'comment': 'this should be a separate `throws` declaration', 'commenter': 'PascalSchumacher'}]"
31,src/main/java/org/apache/commons/io/DirectoryUtils.java,"@@ -0,0 +1,149 @@
+package org.apache.commons.io;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+/**
+ * General directory manipulation utilities.
+ * <p>
+ * Facilities are provided in the following areas:
+ * <ul>
+ * <li>comparing directories
+ * </ul>
+ * <p>
+ * ","[{'comment': 'Closing of `p` tag is not correct.', 'commenter': 'garydgregory'}]"
31,src/main/java/org/apache/commons/io/DirectoryUtils.java,"@@ -0,0 +1,149 @@
+package org.apache.commons.io;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+/**
+ * General directory manipulation utilities.
+ * <p>
+ * Facilities are provided in the following areas:
+ * <ul>
+ * <li>comparing directories
+ * </ul>
+ * <p>
+ * 
+ * Original code: http://stackoverflow.com/questions/14522239/test-two-directory-trees-for-equality
+ *
+ */
+public class DirectoryUtils {
+
+    /**
+     * checks if the directory file lists are equal.","[{'comment': 'Start a sentence with a capital letter.', 'commenter': 'garydgregory'}]"
31,src/main/java/org/apache/commons/io/DirectoryUtils.java,"@@ -0,0 +1,149 @@
+package org.apache.commons.io;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+/**
+ * General directory manipulation utilities.
+ * <p>
+ * Facilities are provided in the following areas:
+ * <ul>
+ * <li>comparing directories
+ * </ul>
+ * <p>
+ * 
+ * Original code: http://stackoverflow.com/questions/14522239/test-two-directory-trees-for-equality
+ *
+ */
+public class DirectoryUtils {
+
+    /**
+     * checks if the directory file lists are equal.
+     * 
+     * If checkFileContent is true, then also if the file content is equal","[{'comment': 'End a sentence with a period.', 'commenter': 'garydgregory'}]"
31,src/main/java/org/apache/commons/io/DirectoryUtils.java,"@@ -0,0 +1,149 @@
+package org.apache.commons.io;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+/**
+ * General directory manipulation utilities.
+ * <p>
+ * Facilities are provided in the following areas:
+ * <ul>
+ * <li>comparing directories
+ * </ul>
+ * <p>
+ * 
+ * Original code: http://stackoverflow.com/questions/14522239/test-two-directory-trees-for-equality
+ *
+ */
+public class DirectoryUtils {
+
+    /**
+     * checks if the directory file lists are equal.
+     * 
+     * If checkFileContent is true, then also if the file content is equal
+     * 
+     * @param directory
+     *            the directory
+     * @param compareDirectory
+     *            the directory to compare with
+     * @param checkFileContent
+     *            also compare file content
+     * @return true if directory and compareDirectory are equal
+     * @throws IOException
+     */
+    public static boolean isEqual(Path directory, Path compareDirectory, boolean checkFileContent)","[{'comment': 'TL;DR: Use `final` where possible; IMO https://garygregory.wordpress.com/2013/01/26/the-final-kiss-in-java/', 'commenter': 'garydgregory'}]"
31,src/test/java/org/apache/commons/io/DirectoryUtilsTestCase_Nested.java,"@@ -0,0 +1,66 @@
+package org.apache.commons.io;
+
+import static org.junit.Assert.*;","[{'comment': 'Do not use `*` imports.', 'commenter': 'garydgregory'}, {'comment': 'Also based your PR on the HEAD of master. This does not compile since we now use JUnit 5.', 'commenter': 'garydgregory'}]"
31,src/test/java/org/apache/commons/io/DirectoryUtilsTestCase_Simple.java,"@@ -0,0 +1,66 @@
+package org.apache.commons.io;
+
+import static org.junit.Assert.*;
+
+import java.io.IOException;
+import java.nio.file.FileSystems;
+import java.nio.file.Path;
+
+import org.junit.Test;
+
+/**
+ * This is used to test DirectoryUtils for correctness with flat directories
+ *
+ * @see DirectoryUtils
+ */
+public class DirectoryUtilsTestCase_Simple {
+
+    String basePath = ""src/test/resources/DirectoryUtils_equal/simple/"";
+
+    @Test
+    public void compare_self() throws IOException {
+        boolean checkFileContent = false;
+        Path directory = FileSystems.getDefault().getPath(basePath + ""directory"");
+        Path compareDirectory = FileSystems.getDefault().getPath(basePath + ""directory"");
+
+        assertTrue(DirectoryUtils.isEqual(directory, compareDirectory, checkFileContent));","[{'comment': 'All tests method are incomplete and should be something like:\r\n```\r\n        assertTrue(DirectoryUtils.isEqual(directory, compareDirectory, checkFileContent));\r\n        assertTrue(DirectoryUtils.isEqual(directory, directory, checkFileContent));\r\n        assertTrue(DirectoryUtils.isEqual(compareDirectory, directory, checkFileContent));\r\n        assertTrue(DirectoryUtils.isEqual(compareDirectory, compareDirectory, checkFileContent));\r\n```', 'commenter': 'garydgregory'}]"
31,src/main/java/org/apache/commons/io/DirectoryUtils.java,"@@ -0,0 +1,149 @@
+package org.apache.commons.io;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+/**
+ * General directory manipulation utilities.
+ * <p>
+ * Facilities are provided in the following areas:
+ * <ul>
+ * <li>comparing directories
+ * </ul>
+ * <p>
+ * 
+ * Original code: http://stackoverflow.com/questions/14522239/test-two-directory-trees-for-equality
+ *
+ */
+public class DirectoryUtils {
+
+    /**
+     * checks if the directory file lists are equal.
+     * 
+     * If checkFileContent is true, then also if the file content is equal
+     * 
+     * @param directory
+     *            the directory
+     * @param compareDirectory
+     *            the directory to compare with
+     * @param checkFileContent
+     *            also compare file content
+     * @return true if directory and compareDirectory are equal
+     * @throws IOException
+     */
+    public static boolean isEqual(Path directory, Path compareDirectory, boolean checkFileContent)
+            throws IOException {
+
+        boolean check = isEverythingInCompareDirectory(directory, compareDirectory, checkFileContent);
+
+        // we only need to check file content in on direction.
+        boolean checkOppositeFileContent = false;
+
+        boolean checkOpposite = check
+                && isEverythingInCompareDirectory(compareDirectory, directory, checkOppositeFileContent);
+        return check && checkOpposite;
+
+    }
+
+    /**
+     * checks if the directory file lists and file content is equal
+     * 
+     * @param directory
+     *            the directory
+     * @param compareDirectory
+     *            the directory to compare with
+     * @param checkFileContent
+     *            also compare file content
+     * @return true if directory and compareDirectory are equal
+     * @throws IOException
+     */
+    private static boolean isEverythingInCompareDirectory(Path directory, Path compareDirectory,
+            boolean checkFileContent) throws IOException {
+
+        if (directory != null && compareDirectory != null) {
+            // LOGGER.info(""checking directory "" + directory);
+            // LOGGER.info(""checking compareDirectory "" + compareDirectory);
+
+            File directoryFile = directory.toFile();
+            File compareFile = compareDirectory.toFile();
+
+            // check, if there is the same number of files/subdirectories
+            File[] directoryFiles = directoryFile.listFiles();","[{'comment': ""Don't use `listFiles()`, this will kill performance on large file trees. Use Java's streaming APIs."", 'commenter': 'garydgregory'}]"
31,src/main/java/org/apache/commons/io/DirectoryUtils.java,"@@ -0,0 +1,149 @@
+package org.apache.commons.io;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+/**
+ * General directory manipulation utilities.
+ * <p>
+ * Facilities are provided in the following areas:
+ * <ul>
+ * <li>comparing directories
+ * </ul>
+ * <p>
+ * 
+ * Original code: http://stackoverflow.com/questions/14522239/test-two-directory-trees-for-equality
+ *
+ */
+public class DirectoryUtils {
+
+    /**
+     * checks if the directory file lists are equal.
+     * 
+     * If checkFileContent is true, then also if the file content is equal
+     * 
+     * @param directory
+     *            the directory
+     * @param compareDirectory
+     *            the directory to compare with
+     * @param checkFileContent
+     *            also compare file content
+     * @return true if directory and compareDirectory are equal
+     * @throws IOException
+     */
+    public static boolean isEqual(Path directory, Path compareDirectory, boolean checkFileContent)
+            throws IOException {
+
+        boolean check = isEverythingInCompareDirectory(directory, compareDirectory, checkFileContent);
+
+        // we only need to check file content in on direction.
+        boolean checkOppositeFileContent = false;
+
+        boolean checkOpposite = check
+                && isEverythingInCompareDirectory(compareDirectory, directory, checkOppositeFileContent);
+        return check && checkOpposite;
+
+    }
+
+    /**
+     * checks if the directory file lists and file content is equal
+     * 
+     * @param directory
+     *            the directory
+     * @param compareDirectory
+     *            the directory to compare with
+     * @param checkFileContent
+     *            also compare file content
+     * @return true if directory and compareDirectory are equal
+     * @throws IOException
+     */
+    private static boolean isEverythingInCompareDirectory(Path directory, Path compareDirectory,
+            boolean checkFileContent) throws IOException {
+
+        if (directory != null && compareDirectory != null) {
+            // LOGGER.info(""checking directory "" + directory);
+            // LOGGER.info(""checking compareDirectory "" + compareDirectory);
+
+            File directoryFile = directory.toFile();
+            File compareFile = compareDirectory.toFile();
+
+            // check, if there is the same number of files/subdirectories
+            File[] directoryFiles = directoryFile.listFiles();
+            File[] compareFiles = compareFile.listFiles();
+
+            if (directoryFiles != null && compareFiles != null) {
+                //LOGGER.info(""directoryFiles: "" + directoryFiles.length + "" vs compareFiles: "" + compareFiles.length);
+                if (directoryFiles.length == compareFiles.length) {
+                    return compareDirectoryContents(directory, compareDirectory, checkFileContent);
+
+                } else {
+                    //LOGGER.info(""number of files in directory are different "" + directoryFiles.length + "" vs compareDirectory: "" + compareFiles.length);
+                    return false;
+                }
+            } else {
+                return checkForNulls(directoryFiles, compareFiles);
+            }
+
+        } else {
+            // one of the directories is null
+            return checkForNulls(directory, compareDirectory);
+        }
+
+
+    }
+
+    private static boolean checkForNulls(Object directory, Object compareDirectory) {
+        if (directory == null && compareDirectory == null) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private static boolean compareDirectoryContents(Path directory, Path compareDirectory, boolean checkFileContent)
+            throws IOException {
+
+        // LOGGER.info(""compareDirectoryContents: "" + directory);
+        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directory)) {
+
+            for (Path directoryFilePath : directoryStream) {
+                // LOGGER.info(""processing "" + directoryFilePath);
+                // search for directoryFile in the compareDirectory
+                Path compareFilePath = compareDirectory.resolve(directoryFilePath.getFileName());
+
+                if (compareFilePath != null) {","[{'comment': 'When does `Path#resolve()` ever return `null`?', 'commenter': 'garydgregory'}]"
31,src/main/java/org/apache/commons/io/DirectoryUtils.java,"@@ -0,0 +1,149 @@
+package org.apache.commons.io;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+/**
+ * General directory manipulation utilities.
+ * <p>
+ * Facilities are provided in the following areas:
+ * <ul>
+ * <li>comparing directories
+ * </ul>
+ * <p>
+ * 
+ * Original code: http://stackoverflow.com/questions/14522239/test-two-directory-trees-for-equality
+ *
+ */
+public class DirectoryUtils {
+
+    /**
+     * checks if the directory file lists are equal.
+     * 
+     * If checkFileContent is true, then also if the file content is equal
+     * 
+     * @param directory
+     *            the directory
+     * @param compareDirectory
+     *            the directory to compare with
+     * @param checkFileContent
+     *            also compare file content
+     * @return true if directory and compareDirectory are equal
+     * @throws IOException
+     */
+    public static boolean isEqual(Path directory, Path compareDirectory, boolean checkFileContent)
+            throws IOException {
+
+        boolean check = isEverythingInCompareDirectory(directory, compareDirectory, checkFileContent);
+
+        // we only need to check file content in on direction.
+        boolean checkOppositeFileContent = false;
+
+        boolean checkOpposite = check
+                && isEverythingInCompareDirectory(compareDirectory, directory, checkOppositeFileContent);
+        return check && checkOpposite;
+
+    }
+
+    /**
+     * checks if the directory file lists and file content is equal
+     * 
+     * @param directory
+     *            the directory
+     * @param compareDirectory
+     *            the directory to compare with
+     * @param checkFileContent
+     *            also compare file content
+     * @return true if directory and compareDirectory are equal
+     * @throws IOException
+     */
+    private static boolean isEverythingInCompareDirectory(Path directory, Path compareDirectory,
+            boolean checkFileContent) throws IOException {
+
+        if (directory != null && compareDirectory != null) {
+            // LOGGER.info(""checking directory "" + directory);
+            // LOGGER.info(""checking compareDirectory "" + compareDirectory);
+
+            File directoryFile = directory.toFile();
+            File compareFile = compareDirectory.toFile();
+
+            // check, if there is the same number of files/subdirectories
+            File[] directoryFiles = directoryFile.listFiles();
+            File[] compareFiles = compareFile.listFiles();
+
+            if (directoryFiles != null && compareFiles != null) {
+                //LOGGER.info(""directoryFiles: "" + directoryFiles.length + "" vs compareFiles: "" + compareFiles.length);
+                if (directoryFiles.length == compareFiles.length) {
+                    return compareDirectoryContents(directory, compareDirectory, checkFileContent);
+
+                } else {
+                    //LOGGER.info(""number of files in directory are different "" + directoryFiles.length + "" vs compareDirectory: "" + compareFiles.length);
+                    return false;
+                }
+            } else {
+                return checkForNulls(directoryFiles, compareFiles);
+            }
+
+        } else {
+            // one of the directories is null
+            return checkForNulls(directory, compareDirectory);
+        }
+
+
+    }
+
+    private static boolean checkForNulls(Object directory, Object compareDirectory) {
+        if (directory == null && compareDirectory == null) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private static boolean compareDirectoryContents(Path directory, Path compareDirectory, boolean checkFileContent)
+            throws IOException {
+
+        // LOGGER.info(""compareDirectoryContents: "" + directory);
+        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directory)) {","[{'comment': ""How does this implementation account for file and directories present in `compareDirectory` but not in `directory`? Seems quite broken. You'd be better off with names like `directory1` and `directory2` IMO."", 'commenter': 'garydgregory'}]"
32,src/main/java/org/apache/commons/io/input/Tailer.java,"@@ -556,4 +784,181 @@ private long readLines(final RandomAccessFile reader) throws IOException {
             return rePos;
         }
     }
+
+    /**
+     * Abstraction on {@link java.io.File} which allows substitution of remote files for example using jCIFS
+     *
+     * @since 2.12.0
+     */
+    public interface Tailable {
+        /**
+         * @return  The name of the file denoted by this tailable
+         */
+        String getName();
+
+        /**
+         * @return  The full path of this tailable
+         */
+        String getPath();
+
+        /**
+         * Returns the length of this tailable
+         *
+         * @return  The length, in bytes, of this tailable, or <code>0L</code>
+         *          if the file does not exist.  Some operating systems may
+         *          return <code>0L</code> for pathnames denoting system-dependent
+         *          entities such as devices or pipes.
+         */
+        long length();
+
+        /**
+         * Returns the time that this tailable was last modified.
+         *
+         * @return  A <code>long</code> value representing the time this tailable
+         *          was last modified, measured in milliseconds since the epoch
+         *          (00:00:00 GMT, January 1, 1970), or <code>0L</code> if the
+         *          tailable does not exist or if an I/O error occurs
+         */
+        long lastModified() throws IOException;
+
+        /**
+         * Tests whether this tailable exists.
+         *
+         * @return  <code>true</code> if and only if the tailable exists;
+         *          <code>false</code> otherwise
+         */
+        boolean exists();
+
+        /**
+         * Tests if this tailable is newer than the specified time reference.
+         *
+         * @param timeMillis the time reference measured in milliseconds since the
+         *                   epoch (00:00:00 GMT, January 1, 1970).
+         * @return true if this tailable has been modified after the given time reference.
+         */
+        boolean isFileNewer(final long timeMillis);
+
+        /**
+         * @param mode the access mode {@link RandomAccessFile}","[{'comment': 'The 1st sentence is missing for this method.', 'commenter': 'garydgregory'}]"
32,src/main/java/org/apache/commons/io/input/Tailer.java,"@@ -556,4 +784,181 @@ private long readLines(final RandomAccessFile reader) throws IOException {
             return rePos;
         }
     }
+
+    /**
+     * Abstraction on {@link java.io.File} which allows substitution of remote files for example using jCIFS
+     *
+     * @since 2.12.0
+     */
+    public interface Tailable {
+        /**
+         * @return  The name of the file denoted by this tailable","[{'comment': 'The 1st sentence is missing for this method.', 'commenter': 'garydgregory'}]"
32,src/main/java/org/apache/commons/io/input/Tailer.java,"@@ -556,4 +784,181 @@ private long readLines(final RandomAccessFile reader) throws IOException {
             return rePos;
         }
     }
+
+    /**
+     * Abstraction on {@link java.io.File} which allows substitution of remote files for example using jCIFS
+     *
+     * @since 2.12.0
+     */
+    public interface Tailable {
+        /**
+         * @return  The name of the file denoted by this tailable
+         */
+        String getName();
+
+        /**
+         * @return  The full path of this tailable
+         */
+        String getPath();
+
+        /**
+         * Returns the length of this tailable
+         *
+         * @return  The length, in bytes, of this tailable, or <code>0L</code>
+         *          if the file does not exist.  Some operating systems may
+         *          return <code>0L</code> for pathnames denoting system-dependent
+         *          entities such as devices or pipes.
+         */
+        long length();
+
+        /**
+         * Returns the time that this tailable was last modified.
+         *
+         * @return  A <code>long</code> value representing the time this tailable
+         *          was last modified, measured in milliseconds since the epoch
+         *          (00:00:00 GMT, January 1, 1970), or <code>0L</code> if the
+         *          tailable does not exist or if an I/O error occurs
+         */
+        long lastModified() throws IOException;
+
+        /**
+         * Tests whether this tailable exists.
+         *
+         * @return  <code>true</code> if and only if the tailable exists;
+         *          <code>false</code> otherwise
+         */
+        boolean exists();
+
+        /**
+         * Tests if this tailable is newer than the specified time reference.
+         *
+         * @param timeMillis the time reference measured in milliseconds since the
+         *                   epoch (00:00:00 GMT, January 1, 1970).
+         * @return true if this tailable has been modified after the given time reference.
+         */
+        boolean isFileNewer(final long timeMillis);
+
+        /**
+         * @param mode the access mode {@link RandomAccessFile}
+         * @return a random access file stream to read from
+         * @throws FileNotFoundException if the tailable object does not exist
+         */
+        RandomAccessTailable getRandomAccess(final String mode) throws FileNotFoundException;
+    }
+
+    /**
+     * Abstraction on {@link java.io.RandomAccessFile} which allows substitution of remote files for example using jCIFS
+     *
+     * @since 2.12.0
+     */
+    public interface RandomAccessTailable extends Closeable {
+        /**
+         * Returns the current offset in this tailable.","[{'comment': '""Returns"" -> ""Gets""\r\n', 'commenter': 'garydgregory'}]"
32,src/main/java/org/apache/commons/io/input/Tailer.java,"@@ -556,4 +784,181 @@ private long readLines(final RandomAccessFile reader) throws IOException {
             return rePos;
         }
     }
+
+    /**
+     * Abstraction on {@link java.io.File} which allows substitution of remote files for example using jCIFS
+     *
+     * @since 2.12.0
+     */
+    public interface Tailable {
+        /**
+         * @return  The name of the file denoted by this tailable
+         */
+        String getName();
+
+        /**
+         * @return  The full path of this tailable
+         */
+        String getPath();
+
+        /**
+         * Returns the length of this tailable
+         *
+         * @return  The length, in bytes, of this tailable, or <code>0L</code>
+         *          if the file does not exist.  Some operating systems may
+         *          return <code>0L</code> for pathnames denoting system-dependent
+         *          entities such as devices or pipes.
+         */
+        long length();
+
+        /**
+         * Returns the time that this tailable was last modified.
+         *
+         * @return  A <code>long</code> value representing the time this tailable
+         *          was last modified, measured in milliseconds since the epoch
+         *          (00:00:00 GMT, January 1, 1970), or <code>0L</code> if the
+         *          tailable does not exist or if an I/O error occurs
+         */
+        long lastModified() throws IOException;
+
+        /**
+         * Tests whether this tailable exists.
+         *
+         * @return  <code>true</code> if and only if the tailable exists;
+         *          <code>false</code> otherwise
+         */
+        boolean exists();
+
+        /**
+         * Tests if this tailable is newer than the specified time reference.
+         *
+         * @param timeMillis the time reference measured in milliseconds since the
+         *                   epoch (00:00:00 GMT, January 1, 1970).
+         * @return true if this tailable has been modified after the given time reference.
+         */
+        boolean isFileNewer(final long timeMillis);
+
+        /**
+         * @param mode the access mode {@link RandomAccessFile}
+         * @return a random access file stream to read from
+         * @throws FileNotFoundException if the tailable object does not exist
+         */
+        RandomAccessTailable getRandomAccess(final String mode) throws FileNotFoundException;
+    }
+
+    /**
+     * Abstraction on {@link java.io.RandomAccessFile} which allows substitution of remote files for example using jCIFS
+     *
+     * @since 2.12.0
+     */
+    public interface RandomAccessTailable extends Closeable {
+        /**
+         * Returns the current offset in this tailable.
+         *
+         * @return     the offset from the beginning of the tailable, in bytes,
+         *             at which the next read or write occurs.
+         * @exception  IOException  if an I/O error occurs.
+         */
+        long getFilePointer() throws IOException;
+
+        /**
+         * Sets the file-pointer offset, measured from the beginning of this
+         * tailable, at which the next read or write occurs.  The offset may be
+         * set beyond the end of the tailable. Setting the offset beyond the end
+         * of the tailable does not change the tailable length.  The tailable
+         * length will change only by writing after the offset has been set beyond
+         * the end of the tailable.
+         *
+         * @param      pos   the offset position, measured in bytes from the
+         *                   beginning of the tailable, at which to set the
+         *                   tailable pointer.
+         * @exception  IOException  if {@code pos} is less than","[{'comment': '""@exception"" -> ""@throws""', 'commenter': 'garydgregory'}]"
32,src/main/java/org/apache/commons/io/input/Tailer.java,"@@ -556,4 +784,181 @@ private long readLines(final RandomAccessFile reader) throws IOException {
             return rePos;
         }
     }
+
+    /**
+     * Abstraction on {@link java.io.File} which allows substitution of remote files for example using jCIFS
+     *
+     * @since 2.12.0
+     */
+    public interface Tailable {
+        /**
+         * @return  The name of the file denoted by this tailable
+         */
+        String getName();
+
+        /**
+         * @return  The full path of this tailable
+         */
+        String getPath();
+
+        /**
+         * Returns the length of this tailable
+         *
+         * @return  The length, in bytes, of this tailable, or <code>0L</code>","[{'comment': '<code>foo</code> -> {@code foo}\r\n', 'commenter': 'garydgregory'}]"
32,src/main/java/org/apache/commons/io/input/Tailer.java,"@@ -556,4 +784,181 @@ private long readLines(final RandomAccessFile reader) throws IOException {
             return rePos;
         }
     }
+
+    /**
+     * Abstraction on {@link java.io.File} which allows substitution of remote files for example using jCIFS
+     *
+     * @since 2.12.0
+     */
+    public interface Tailable {
+        /**
+         * @return  The name of the file denoted by this tailable
+         */
+        String getName();
+
+        /**
+         * @return  The full path of this tailable
+         */
+        String getPath();
+
+        /**
+         * Returns the length of this tailable
+         *
+         * @return  The length, in bytes, of this tailable, or <code>0L</code>
+         *          if the file does not exist.  Some operating systems may
+         *          return <code>0L</code> for pathnames denoting system-dependent
+         *          entities such as devices or pipes.
+         */
+        long length();
+
+        /**
+         * Returns the time that this tailable was last modified.
+         *
+         * @return  A <code>long</code> value representing the time this tailable
+         *          was last modified, measured in milliseconds since the epoch
+         *          (00:00:00 GMT, January 1, 1970), or <code>0L</code> if the
+         *          tailable does not exist or if an I/O error occurs
+         */
+        long lastModified() throws IOException;
+
+        /**
+         * Tests whether this tailable exists.
+         *
+         * @return  <code>true</code> if and only if the tailable exists;
+         *          <code>false</code> otherwise
+         */
+        boolean exists();
+
+        /**
+         * Tests if this tailable is newer than the specified time reference.
+         *
+         * @param timeMillis the time reference measured in milliseconds since the
+         *                   epoch (00:00:00 GMT, January 1, 1970).
+         * @return true if this tailable has been modified after the given time reference.
+         */
+        boolean isFileNewer(final long timeMillis);
+
+        /**
+         * @param mode the access mode {@link RandomAccessFile}
+         * @return a random access file stream to read from
+         * @throws FileNotFoundException if the tailable object does not exist
+         */
+        RandomAccessTailable getRandomAccess(final String mode) throws FileNotFoundException;
+    }
+
+    /**
+     * Abstraction on {@link java.io.RandomAccessFile} which allows substitution of remote files for example using jCIFS","[{'comment': 'Sentences should end in a period.\r\n', 'commenter': 'garydgregory'}]"
32,src/main/java/org/apache/commons/io/input/Tailer.java,"@@ -556,4 +784,181 @@ private long readLines(final RandomAccessFile reader) throws IOException {
             return rePos;
         }
     }
+
+    /**
+     * Abstraction on {@link java.io.File} which allows substitution of remote files for example using jCIFS
+     *
+     * @since 2.12.0
+     */
+    public interface Tailable {
+        /**
+         * @return  The name of the file denoted by this tailable
+         */
+        String getName();
+
+        /**
+         * @return  The full path of this tailable
+         */
+        String getPath();","[{'comment': 'Confusing API name because it does not return a `Path`; either rename the API or make it return a `Path`.', 'commenter': 'garydgregory'}, {'comment': ""I've renamed this to `getPathName` more descriptive but now inconsistent with `java.io.File#getPath`"", 'commenter': 'jonfreedman'}]"
32,src/main/java/org/apache/commons/io/input/Tailer.java,"@@ -556,4 +784,181 @@ private long readLines(final RandomAccessFile reader) throws IOException {
             return rePos;
         }
     }
+
+    /**
+     * Abstraction on {@link java.io.File} which allows substitution of remote files for example using jCIFS
+     *
+     * @since 2.12.0
+     */
+    public interface Tailable {
+        /**
+         * @return  The name of the file denoted by this tailable
+         */
+        String getName();","[{'comment': 'The name of... what? the base file name? The full file name?', 'commenter': 'garydgregory'}, {'comment': ""I've renamed this to `getFileName` more descriptive but now inconsistent with `java.io.File#getName`"", 'commenter': 'jonfreedman'}]"
32,src/main/java/org/apache/commons/io/input/Tailer.java,"@@ -191,6 +203,18 @@ public Tailer(final File file, final TailerListener listener, final long delayMi
         this(file, listener, delayMillis, false);
     }
 
+    /**","[{'comment': ""There are way too many new factory APIs here IMO. For the first cut, let's add one and see what other use-cases require in the future. If a delay is provided, please make that a `Duration`, not a `long`. I'll redo the internals after this PR comes in to use a Duration instead of a `long`. If you add a constructor, make it private or package private."", 'commenter': 'garydgregory'}]"
39,src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java,"@@ -134,17 +133,35 @@ public ReversedLinesFileReader(final File file, final int blockSize, final Chars
         // Open file
         randomAccessFile = new RandomAccessFile(file, ""r"");
         totalByteLength = randomAccessFile.length();
-        int lastBlockLength = (int) (totalByteLength % blockSize);
-        if (lastBlockLength > 0) {
-            totalBlockCount = totalByteLength / blockSize + 1;
+        seek (totalByteLength);
+
+    }
+    /**","[{'comment': 'All new public and protected method should have complete Javadoc. Here the first sentence is missing as is the since tag.', 'commenter': 'garydgregory'}]"
39,src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java,"@@ -361,6 +383,13 @@ private int getNewLineMatchByteCount(final byte[] data, final int i) {
             }
             return 0;
         }
+
+        /**
+         * @return Returns the current offset in this file
+         */
+        public long getFilePointer(){","[{'comment': 'Formatting is missing a space.', 'commenter': 'garydgregory'}]"
39,src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java,"@@ -211,6 +228,8 @@ private class FilePart {
         private byte[] leftOver;
 
         private int currentLastBytePos;
+        private int mappedFilePointer; // store file pointer position according to currentLastBytePos but take","[{'comment': 'Just a Javadoc comment instead.', 'commenter': 'garydgregory'}]"
39,src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java,"@@ -303,6 +323,7 @@ private String readLine() throws IOException {
                     line = new String(lineData, encoding);
 
                     currentLastBytePos = i - newLineMatchByteCount;
+                    mappedFilePointer=i;","[{'comment': 'Fix formatting.', 'commenter': 'garydgregory'}]"
39,src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java,"@@ -339,6 +360,7 @@ private void createLeftOver() {
                 leftOver = null;
             }
             currentLastBytePos = -1;
+            mappedFilePointer=0;","[{'comment': 'Fix formatting', 'commenter': 'garydgregory'}]"
39,src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java,"@@ -467,4 +467,25 @@ public String toString(final int lineCount) throws IOException {
         return lines.isEmpty() ? EMPTY_STRING : String.join(System.lineSeparator(), lines) + System.lineSeparator();
     }
 
-}
+    /**
+     * Returns the current offset in this file
+     * @return the current offset
+     * @throws IOException if an I/O error occurs.
+     */","[{'comment': 'New public and protected APIs need an `@since` tag.', 'commenter': 'garydgregory'}]"
39,src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java,"@@ -467,4 +467,25 @@ public String toString(final int lineCount) throws IOException {
         return lines.isEmpty() ? EMPTY_STRING : String.join(System.lineSeparator(), lines) + System.lineSeparator();
     }
 
-}
+    /**
+     * Returns the current offset in this file
+     * @return the current offset
+     * @throws IOException if an I/O error occurs.
+     */
+    public long getFilePointer() throws IOException {","[{'comment': 'Why not call the new method `position` since (1) there are no pointers in Java and (2) it reflects the underlying operation?', 'commenter': 'garydgregory'}]"
39,src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java,"@@ -467,4 +467,25 @@ public String toString(final int lineCount) throws IOException {
         return lines.isEmpty() ? EMPTY_STRING : String.join(System.lineSeparator(), lines) + System.lineSeparator();
     }
 
-}
+    /**
+     * Returns the current offset in this file
+     * @return the current offset
+     * @throws IOException if an I/O error occurs.
+     */
+    public long getFilePointer() throws IOException {
+        return channel.position();
+    }
+
+    /**
+     * Sets the file-pointer offset, measured from the beginning of this file, at which the next read occurs.
+     * @param pos the offset value to be set
+     * @throws IOException if an I/O error occurs.","[{'comment': 'New public and protected APIs need an @since tag.', 'commenter': 'garydgregory'}]"
39,src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java,"@@ -467,4 +467,25 @@ public String toString(final int lineCount) throws IOException {
         return lines.isEmpty() ? EMPTY_STRING : String.join(System.lineSeparator(), lines) + System.lineSeparator();
     }
 
-}
+    /**
+     * Returns the current offset in this file
+     * @return the current offset
+     * @throws IOException if an I/O error occurs.
+     */
+    public long getFilePointer() throws IOException {
+        return channel.position();
+    }
+
+    /**
+     * Sets the file-pointer offset, measured from the beginning of this file, at which the next read occurs.
+     * @param pos the offset value to be set
+     * @throws IOException if an I/O error occurs.
+     */
+    public void seek (long pos) throws IOException {","[{'comment': 'No space after the method name. Use final where you can.', 'commenter': 'garydgregory'}]"
39,src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java,"@@ -467,4 +467,25 @@ public String toString(final int lineCount) throws IOException {
         return lines.isEmpty() ? EMPTY_STRING : String.join(System.lineSeparator(), lines) + System.lineSeparator();
     }
 
-}
+    /**
+     * Returns the current offset in this file
+     * @return the current offset
+     * @throws IOException if an I/O error occurs.
+     */
+    public long getFilePointer() throws IOException {
+        return channel.position();
+    }
+
+    /**
+     * Sets the file-pointer offset, measured from the beginning of this file, at which the next read occurs.
+     * @param pos the offset value to be set
+     * @throws IOException if an I/O error occurs.
+     */
+    public void seek (long pos) throws IOException {
+        final long block = pos / blockSize + 1;
+        final int blockLength = (int) (pos % blockSize);
+        channel.position(pos);
+        this.currentFilePart = new FilePart(block, blockLength, null);
+
+    }
+}","[{'comment': 'Files should end in a blank line.', 'commenter': 'garydgregory'}]"
39,src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestRandomAccess.java,"@@ -0,0 +1,151 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.input.ReversedLinesFileReaderTestParamBlockSize.assertEqualsAndNoLineBreaks;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URISyntaxException;
+import java.nio.charset.StandardCharsets;
+
+import org.apache.commons.io.TestResources;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Test;
+
+public class ReversedLinesFileReaderTestRandomAccess {
+
+  private ReversedLinesFileReader reversedLinesFileReader;
+  private static final String testLine1 =
+          ""A Test Line. Special chars: ""
+                  .concat(""\u00C4\u00E4\u00DC\u00FC\u00D6\u00F6\u00DF "")
+                  .concat(""\u00C3\u00E1\u00E9\u00ED\u00EF\u00E7\u00F1\u00C2 "")
+                  .concat(""\u00A9\u00B5\u00A5\u00A3"");
+  private static final String testLine2 = testLine1 +""\u00B1"";
+  private static final String testLine3 = testLine2 +""\u00B2"";
+  private static final String testLine4 = testLine3 +""\u00AE"";
+
+  @AfterEach
+  public void closeReader() {
+      try {
+          reversedLinesFileReader.close();","[{'comment': 'Use `IOUtils.closeQuietly()` instead.', 'commenter': 'garydgregory'}, {'comment': ""Thank you for your feedbacks @garydgregory \r\nI won't be able to take them before two weeks, but will do it ASAP."", 'commenter': 'Jean-Pierre-Portier'}]"
46,src/main/java/org/apache/commons/io/ByteOrderParser.java,"@@ -25,38 +25,26 @@
  *
  * @since 2.6
  */
-public final class ByteOrderUtils {
-
-    private static final Locale ComparisonLocale = Locale.ROOT;
-
-    /**
-     * Big endian.
-     */
-    public static final String BIG_ENDIAN = ""Big"";
-
-    /**
-     * Little endian.
-     */
-    public static final String LITTLE_ENDIAN = ""Little"";
+public final class ByteOrderParser {
 
     /**
      * ByteOrderUtils is a static utility class, so prevent construction with a private constructor.
      */
-    private ByteOrderUtils() {
+    private ByteOrderParser() {
     }
 
     /**
      * Parses the String argument as a {@link ByteOrder}, ignoring case.","[{'comment': ""I think the pull request changes this, or I'm I wrong? Maybe we should keep the case insensitivity?"", 'commenter': 'PascalSchumacher'}, {'comment': ""You're right. I've changed the documentation. Let's make it restrictive and see if users want to have a more relaxed handling."", 'commenter': 'britter'}]"
75,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1176,20 +1178,20 @@ private static void doCopyFile(final File srcFile, final File destFile, final bo
      * @param srcDir  an existing directory to copy, must not be {@code null}
      * @param destDir the directory to place the copy in, must not be {@code null}
      *
-     * @throws NullPointerException if source or destination is {@code null}
+     * @throws IllegalArgumentException if source or destination is {@code null}
      * @throws IOException          if source or destination is invalid
      * @throws IOException          if an IO error occurs during copying
      * @since 1.2
      */
     public static void copyDirectoryToDirectory(final File srcDir, final File destDir) throws IOException {
         if (srcDir == null) {
-            throw new NullPointerException(""Source must not be null"");
+            throw new IllegalArgumentException(""Source must not be null"");","[{'comment': 'Do not change these please. Since Java 8 and the broad use of [java.util.Objects.requireNonNull(T, String)](https://docs.oracle.com/javase/8/docs/api/java/util/Objects.html#requireNonNull-T-java.lang.String-), any edits to current throws of NPE should use the aforementioned API.\r\n', 'commenter': 'garydgregory'}]"
89,src/main/java/org/apache/commons/io/input/TeeReader.java,"@@ -0,0 +1,180 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.Writer;
+import java.nio.CharBuffer;
+
+/**
+ * Reader proxy that transparently writes a copy of all characters read
+ * from the proxied reader to a given Reader. Using {@link #skip(long)}
+ * or {@link #mark(int)}/{@link #reset()} on the reader will result on some
+ * characters from the reader being skipped or duplicated in the writer.
+ * <p>
+ * The proxied reader is closed when the {@link #close()} method is
+ * called on this proxy. It is configurable whether the associated writer
+ * will also closed.
+ *","[{'comment': 'Please close HTML tags. IOW </p>', 'commenter': 'garydgregory'}, {'comment': 'Fixed, also in TeeInputStream where I copied the text from.', 'commenter': 'robtimus'}]"
89,src/main/java/org/apache/commons/io/input/TeeReader.java,"@@ -0,0 +1,180 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.Writer;
+import java.nio.CharBuffer;
+
+/**
+ * Reader proxy that transparently writes a copy of all characters read
+ * from the proxied reader to a given Reader. Using {@link #skip(long)}
+ * or {@link #mark(int)}/{@link #reset()} on the reader will result on some
+ * characters from the reader being skipped or duplicated in the writer.
+ * <p>
+ * The proxied reader is closed when the {@link #close()} method is
+ * called on this proxy. It is configurable whether the associated writer
+ * will also closed.","[{'comment': 'Replace:\r\n\r\n It is configurable whether the associated writer\r\n\t\t * will also closed.\r\n\r\nWith:\r\n\r\nYou may configure whether the reader closes the writer.\r\n', 'commenter': 'garydgregory'}, {'comment': 'Fixed, also in TeeInputStream where I copied the text from.', 'commenter': 'robtimus'}]"
89,src/main/java/org/apache/commons/io/input/TeeReader.java,"@@ -0,0 +1,180 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.Writer;
+import java.nio.CharBuffer;
+
+/**
+ * Reader proxy that transparently writes a copy of all characters read
+ * from the proxied reader to a given Reader. Using {@link #skip(long)}
+ * or {@link #mark(int)}/{@link #reset()} on the reader will result on some
+ * characters from the reader being skipped or duplicated in the writer.
+ * <p>
+ * The proxied reader is closed when the {@link #close()} method is
+ * called on this proxy. It is configurable whether the associated writer
+ * will also closed.
+ *
+ * @since 2.7
+ */
+public class TeeReader extends ProxyReader {
+
+    /**
+     * The writer that will receive a copy of all characters read from the
+     * proxied reader.
+     */
+    private final Writer branch;
+
+    /**
+     * Flag for closing also the associated writer when this","[{'comment': 'Remove ""also""', 'commenter': 'garydgregory'}, {'comment': 'Fixed, also in TeeInputStream where I copied the text from.', 'commenter': 'robtimus'}]"
89,src/main/java/org/apache/commons/io/input/TeeReader.java,"@@ -0,0 +1,180 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.Writer;
+import java.nio.CharBuffer;
+
+/**
+ * Reader proxy that transparently writes a copy of all characters read
+ * from the proxied reader to a given Reader. Using {@link #skip(long)}
+ * or {@link #mark(int)}/{@link #reset()} on the reader will result on some
+ * characters from the reader being skipped or duplicated in the writer.
+ * <p>
+ * The proxied reader is closed when the {@link #close()} method is
+ * called on this proxy. It is configurable whether the associated writer
+ * will also closed.
+ *
+ * @since 2.7
+ */
+public class TeeReader extends ProxyReader {
+
+    /**
+     * The writer that will receive a copy of all characters read from the
+     * proxied reader.
+     */
+    private final Writer branch;
+
+    /**
+     * Flag for closing also the associated writer when this
+     * reader is closed.
+     */
+    private final boolean closeBranch;
+
+    /**
+     * Creates a TeeReader that proxies the given {@link Reader}
+     * and copies all read characters to the given {@link Writer}. The given
+     * writer will not be closed when this reader gets closed.
+     *
+     * @param input reader to be proxied
+     * @param branch writer that will receive a copy of all characters read
+     */
+    public TeeReader(final Reader input, final Writer branch) {
+        this(input, branch, false);
+    }
+
+    /**
+     * Creates a TeeReader that proxies the given {@link Reader}
+     * and copies all read characters to the given {@link Writer}. The given
+     * writer will be closed when this reader gets closed if the
+     * closeBranch parameter is {@code true}.
+     *
+     * @param input reader to be proxied
+     * @param branch writer that will receive a copy of all characters read
+     * @param closeBranch flag for closing also the writer when this
+     *                    reader is closed
+     */
+    public TeeReader(
+            final Reader input, final Writer branch, final boolean closeBranch) {
+        super(input);
+        this.branch = branch;
+        this.closeBranch = closeBranch;
+    }
+
+    /**
+     * Closes the proxied reader and, if so configured, the associated
+     * writer. An exception thrown from the reader will not prevent
+     * closing of the writer.
+     *
+     * @throws IOException if either the reader or writer could not be closed
+     */
+    @Override
+    public void close() throws IOException {
+        try {
+            super.close();
+        } finally {
+            if (closeBranch) {
+                branch.close();
+            }
+        }
+    }
+
+    /**
+     * Reads a single chracter from the proxied reader and writes it to
+     * the associated writer.
+     *
+     * @return next character from the reader, or -1 if the reader has ended
+     * @throws IOException if the reader could not be read (or written)
+     */
+    @Override
+    public int read() throws IOException {
+        final int ch = super.read();
+        if (ch != EOF) {
+            branch.write(ch);
+        }
+        return ch;
+    }
+
+    /**
+     * Reads characters from the proxied reader and writes the read characters
+     * to the associated writer.
+     *
+     * @param chr character buffer
+     * @param st start offset within the buffer
+     * @param end maximum number of characters to read
+     * @return number of characters read, or -1 if the reader has ended
+     * @throws IOException if the reader could not be read (or written)
+     */
+    @Override
+    public int read(final char[] chr, final int st, final int end) throws IOException {
+        final int n = super.read(chr, st, end);
+        if (n != -1) {
+            branch.write(chr, st, n);","[{'comment': 'Use EOF in the test.', 'commenter': 'garydgregory'}, {'comment': 'Fixed, also in TeeInputStream where I copied the text from.', 'commenter': 'robtimus'}]"
89,src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java,"@@ -30,6 +32,52 @@
  */
 public class TeeInputStreamTest  {
 
+    private static class ExceptionOnCloseByteArrayInputStream extends ByteArrayInputStream {","[{'comment': '@robtimus ,\r\n\r\nInstead of creating these one-off classes, you should reuse and/or possibly refactor `YellOnFlushAndCloseOutputStream`, `ClosedOutputStream`, or `CloseShieldOutputStream`.\r\n\r\nMay you please give that a try?\r\n\r\nGary', 'commenter': 'garydgregory'}, {'comment': ""These classes are based on similar classes in `TeeOutputStreamTest`. While I could change the code to use `YellOnFlushAndCloseOutputStream`, I don't think that `ClosedOutputStream` or `CloseShieldOutputStream` is feasible, as these don't give access to its state; the test becomes more difficult to read because the check on whether or not `close()` has been called would require a try-fail-catch statement."", 'commenter': 'robtimus'}]"
89,src/test/java/org/apache/commons/io/input/TeeReaderTest.java,"@@ -30,6 +34,54 @@
  */
 public class TeeReaderTest  {
 
+    // Cannot use StringReader or CharSequenceReader as super class because these removed the throws clause from close()","[{'comment': '@robtimus \r\nSame kind of comment as above, maybe classes these can be made as ""Reader"" versions of the ""OutputStream"" classes mentioned above for reuse.', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/io/input/CharSequenceReader.java,"@@ -36,22 +36,105 @@
     private int idx;
     private int mark;
 
+    /*
+     * end is an Integer instead of int because of backwards compatibility.
+     * When de-serializing a CharSequenceReader that was serialized before
+     * these two fields were added, they will be initialized to 0 and null
+     * respectively. If end was an int, it would be initialized to 0 as well.
+     * That would cause all de-serialized CharSequenceReaders to be empty.
+     */
+    private final int start;
+    private final Integer end;
+
     /**
      * Construct a new instance with the specified character sequence.
      *
      * @param charSequence The character sequence, may be {@code null}
      */
     public CharSequenceReader(final CharSequence charSequence) {
+        this(charSequence, 0);
+    }
+
+    /**
+     * Construct a new instance with a portion of the specified character sequence.
+     * <p>
+     * The start index is not strictly enforced to be within the bounds of the
+     * character sequence. This allows the character sequence to grow or shrink
+     * in size without risking any {@link IndexOutOfBoundsException} to be thrown.
+     * Instead, if the character sequence grows smaller than the start index, this
+     * instance will act as if all characters have been read.
+     * </p>
+     *","[{'comment': 'Please add `@since` tags for new `public` and `protected` methods.', 'commenter': 'garydgregory'}, {'comment': 'I remembered I forgot those. I was already planning on adding them, you just beat me to it.', 'commenter': 'robtimus'}]"
91,src/main/java/org/apache/commons/io/input/CharSequenceReader.java,"@@ -37,22 +37,107 @@
     private int idx;
     private int mark;
 
+    /*
+     * end is an Integer instead of int because of backwards compatibility.
+     * When de-serializing a CharSequenceReader that was serialized before
+     * these two fields were added, they will be initialized to 0 and null
+     * respectively. If end was an int, it would be initialized to 0 as well.
+     * That would cause all de-serialized CharSequenceReaders to be empty.
+     */
+    private final int start;
+    private final Integer end;
+
     /**
      * Construct a new instance with the specified character sequence.
      *
      * @param charSequence The character sequence, may be {@code null}
      */
     public CharSequenceReader(final CharSequence charSequence) {
+        this(charSequence, 0);
+    }
+
+    /**
+     * Construct a new instance with a portion of the specified character sequence.
+     * <p>
+     * The start index is not strictly enforced to be within the bounds of the
+     * character sequence. This allows the character sequence to grow or shrink
+     * in size without risking any {@link IndexOutOfBoundsException} to be thrown.
+     * Instead, if the character sequence grows smaller than the start index, this
+     * instance will act as if all characters have been read.
+     * </p>
+     *
+     * @param charSequence The character sequence, may be {@code null}
+     * @param start The start index in the character sequence, inclusive
+     * @throws IllegalArgumentException if the start index is negative
+     * @since 2.7
+     */
+    public CharSequenceReader(final CharSequence charSequence, int start) {","[{'comment': '`int start` -> `final int start`', 'commenter': 'garydgregory'}, {'comment': 'Fixed', 'commenter': 'robtimus'}]"
91,src/main/java/org/apache/commons/io/input/CharSequenceReader.java,"@@ -37,22 +37,107 @@
     private int idx;
     private int mark;
 
+    /*
+     * end is an Integer instead of int because of backwards compatibility.
+     * When de-serializing a CharSequenceReader that was serialized before
+     * these two fields were added, they will be initialized to 0 and null
+     * respectively. If end was an int, it would be initialized to 0 as well.
+     * That would cause all de-serialized CharSequenceReaders to be empty.
+     */
+    private final int start;
+    private final Integer end;
+
     /**
      * Construct a new instance with the specified character sequence.
      *
      * @param charSequence The character sequence, may be {@code null}
      */
     public CharSequenceReader(final CharSequence charSequence) {
+        this(charSequence, 0);
+    }
+
+    /**
+     * Construct a new instance with a portion of the specified character sequence.
+     * <p>
+     * The start index is not strictly enforced to be within the bounds of the
+     * character sequence. This allows the character sequence to grow or shrink
+     * in size without risking any {@link IndexOutOfBoundsException} to be thrown.
+     * Instead, if the character sequence grows smaller than the start index, this
+     * instance will act as if all characters have been read.
+     * </p>
+     *
+     * @param charSequence The character sequence, may be {@code null}
+     * @param start The start index in the character sequence, inclusive
+     * @throws IllegalArgumentException if the start index is negative
+     * @since 2.7
+     */
+    public CharSequenceReader(final CharSequence charSequence, int start) {
+        this(charSequence, start, Integer.MAX_VALUE);
+    }
+
+    /**
+     * Construct a new instance with a portion of the specified character sequence.
+     * <p>
+     * The start and end indexes are not strictly enforced to be within the bounds
+     * of the character sequence. This allows the character sequence to grow or shrink
+     * in size without risking any {@link IndexOutOfBoundsException} to be thrown.
+     * Instead, if the character sequence grows smaller than the start index, this
+     * instance will act as if all characters have been read; if the character sequence
+     * grows smaller than the end, this instance will use the actual character sequence
+     * length.
+     * </p>
+     *
+     * @param charSequence The character sequence, may be {@code null}
+     * @param start The start index in the character sequence, inclusive
+     * @param end The start index in the character sequence, exclusive
+     * @throws IllegalArgumentException if the start index is negative, or if the end index is smaller than the start index
+     * @since 2.7
+     */
+    public CharSequenceReader(final CharSequence charSequence, int start, int end) {","[{'comment': 'Missing `final`', 'commenter': 'garydgregory'}, {'comment': 'Fixed', 'commenter': 'robtimus'}]"
91,src/main/java/org/apache/commons/io/input/CharSequenceReader.java,"@@ -37,22 +37,107 @@
     private int idx;
     private int mark;
 
+    /*
+     * end is an Integer instead of int because of backwards compatibility.
+     * When de-serializing a CharSequenceReader that was serialized before
+     * these two fields were added, they will be initialized to 0 and null
+     * respectively. If end was an int, it would be initialized to 0 as well.
+     * That would cause all de-serialized CharSequenceReaders to be empty.
+     */
+    private final int start;
+    private final Integer end;
+
     /**
      * Construct a new instance with the specified character sequence.
      *
      * @param charSequence The character sequence, may be {@code null}
      */
     public CharSequenceReader(final CharSequence charSequence) {
+        this(charSequence, 0);
+    }
+
+    /**
+     * Construct a new instance with a portion of the specified character sequence.
+     * <p>
+     * The start index is not strictly enforced to be within the bounds of the
+     * character sequence. This allows the character sequence to grow or shrink
+     * in size without risking any {@link IndexOutOfBoundsException} to be thrown.
+     * Instead, if the character sequence grows smaller than the start index, this
+     * instance will act as if all characters have been read.
+     * </p>
+     *
+     * @param charSequence The character sequence, may be {@code null}
+     * @param start The start index in the character sequence, inclusive
+     * @throws IllegalArgumentException if the start index is negative
+     * @since 2.7
+     */
+    public CharSequenceReader(final CharSequence charSequence, int start) {
+        this(charSequence, start, Integer.MAX_VALUE);
+    }
+
+    /**
+     * Construct a new instance with a portion of the specified character sequence.
+     * <p>
+     * The start and end indexes are not strictly enforced to be within the bounds
+     * of the character sequence. This allows the character sequence to grow or shrink
+     * in size without risking any {@link IndexOutOfBoundsException} to be thrown.
+     * Instead, if the character sequence grows smaller than the start index, this
+     * instance will act as if all characters have been read; if the character sequence
+     * grows smaller than the end, this instance will use the actual character sequence
+     * length.
+     * </p>
+     *
+     * @param charSequence The character sequence, may be {@code null}
+     * @param start The start index in the character sequence, inclusive
+     * @param end The start index in the character sequence, exclusive
+     * @throws IllegalArgumentException if the start index is negative, or if the end index is smaller than the start index
+     * @since 2.7
+     */
+    public CharSequenceReader(final CharSequence charSequence, int start, int end) {
+        if (start < 0) {
+            throw new IllegalArgumentException(
+                    ""Start index is less than zero: "" + start);
+        }
+        if (end < start) {
+            throw new IllegalArgumentException(
+                    ""End index is less than start "" + start + "": "" + end);
+        }
+        // Don't check the start and end indexes against the CharSequence,
+        // to let it grow and shrink without breaking existing behavior.
+
         this.charSequence = charSequence != null ? charSequence : """";
+        this.start = start;
+        this.end = end;
+
+        this.idx = start;
+        this.mark = start;
+    }
+
+    /**
+     * @return The start index in the character sequence, taking into account its length.","[{'comment': 'Missing Javadoc: ""Starts...""', 'commenter': 'garydgregory'}, {'comment': ""I've added a different comment as the method doesn't start anything, making it clearer what the method returns."", 'commenter': 'robtimus'}]"
91,src/main/java/org/apache/commons/io/input/CharSequenceReader.java,"@@ -37,22 +37,107 @@
     private int idx;
     private int mark;
 
+    /*
+     * end is an Integer instead of int because of backwards compatibility.
+     * When de-serializing a CharSequenceReader that was serialized before
+     * these two fields were added, they will be initialized to 0 and null
+     * respectively. If end was an int, it would be initialized to 0 as well.
+     * That would cause all de-serialized CharSequenceReaders to be empty.
+     */
+    private final int start;
+    private final Integer end;
+
     /**
      * Construct a new instance with the specified character sequence.
      *
      * @param charSequence The character sequence, may be {@code null}
      */
     public CharSequenceReader(final CharSequence charSequence) {
+        this(charSequence, 0);
+    }
+
+    /**
+     * Construct a new instance with a portion of the specified character sequence.
+     * <p>
+     * The start index is not strictly enforced to be within the bounds of the
+     * character sequence. This allows the character sequence to grow or shrink
+     * in size without risking any {@link IndexOutOfBoundsException} to be thrown.
+     * Instead, if the character sequence grows smaller than the start index, this
+     * instance will act as if all characters have been read.
+     * </p>
+     *
+     * @param charSequence The character sequence, may be {@code null}
+     * @param start The start index in the character sequence, inclusive
+     * @throws IllegalArgumentException if the start index is negative
+     * @since 2.7
+     */
+    public CharSequenceReader(final CharSequence charSequence, int start) {
+        this(charSequence, start, Integer.MAX_VALUE);
+    }
+
+    /**
+     * Construct a new instance with a portion of the specified character sequence.
+     * <p>
+     * The start and end indexes are not strictly enforced to be within the bounds
+     * of the character sequence. This allows the character sequence to grow or shrink
+     * in size without risking any {@link IndexOutOfBoundsException} to be thrown.
+     * Instead, if the character sequence grows smaller than the start index, this
+     * instance will act as if all characters have been read; if the character sequence
+     * grows smaller than the end, this instance will use the actual character sequence
+     * length.
+     * </p>
+     *
+     * @param charSequence The character sequence, may be {@code null}
+     * @param start The start index in the character sequence, inclusive
+     * @param end The start index in the character sequence, exclusive
+     * @throws IllegalArgumentException if the start index is negative, or if the end index is smaller than the start index
+     * @since 2.7
+     */
+    public CharSequenceReader(final CharSequence charSequence, int start, int end) {
+        if (start < 0) {
+            throw new IllegalArgumentException(
+                    ""Start index is less than zero: "" + start);
+        }
+        if (end < start) {
+            throw new IllegalArgumentException(
+                    ""End index is less than start "" + start + "": "" + end);
+        }
+        // Don't check the start and end indexes against the CharSequence,
+        // to let it grow and shrink without breaking existing behavior.
+
         this.charSequence = charSequence != null ? charSequence : """";
+        this.start = start;
+        this.end = end;
+
+        this.idx = start;
+        this.mark = start;
+    }
+
+    /**
+     * @return The start index in the character sequence, taking into account its length.
+     */
+    private int start() {
+        return Math.min(charSequence.length(), start);
+    }
+
+    /**
+     * @return The end index in the character sequence, taking into account its length.","[{'comment': 'Missing Javadoc: ""Ends...""', 'commenter': 'garydgregory'}, {'comment': ""I've added a different comment as the method doesn't end anything, making it clearer what the method returns."", 'commenter': 'robtimus'}]"
91,src/main/java/org/apache/commons/io/input/CharSequenceReader.java,"@@ -37,22 +37,111 @@
     private int idx;
     private int mark;
 
+    /*","[{'comment': 'Move this Javadoc to#end and add @since 2.7', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/io/input/CharSequenceReader.java,"@@ -37,22 +37,111 @@
     private int idx;
     private int mark;
 
+    /*
+     * end is an Integer instead of int because of backwards compatibility.
+     * When de-serializing a CharSequenceReader that was serialized before
+     * these two fields were added, they will be initialized to 0 and null
+     * respectively. If end was an int, it would be initialized to 0 as well.
+     * That would cause all de-serialized CharSequenceReaders to be empty.
+     */
+    private final int start;","[{'comment': 'Give #start its own Javadoc and add @since 2.7.', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/io/input/CharSequenceReader.java,"@@ -37,22 +37,111 @@
     private int idx;
     private int mark;
 
+    /*
+     * end is an Integer instead of int because of backwards compatibility.
+     * When de-serializing a CharSequenceReader that was serialized before
+     * these two fields were added, they will be initialized to 0 and null
+     * respectively. If end was an int, it would be initialized to 0 as well.
+     * That would cause all de-serialized CharSequenceReaders to be empty.
+     */
+    private final int start;
+    private final Integer end;
+
     /**
      * Construct a new instance with the specified character sequence.
      *
      * @param charSequence The character sequence, may be {@code null}
      */
     public CharSequenceReader(final CharSequence charSequence) {
+        this(charSequence, 0);
+    }
+
+    /**
+     * Construct a new instance with a portion of the specified character sequence.","[{'comment': '""Construct"" -> ""Constructs""', 'commenter': 'garydgregory'}]"
91,src/main/java/org/apache/commons/io/input/CharSequenceReader.java,"@@ -37,22 +37,111 @@
     private int idx;
     private int mark;
 
+    /*
+     * end is an Integer instead of int because of backwards compatibility.
+     * When de-serializing a CharSequenceReader that was serialized before
+     * these two fields were added, they will be initialized to 0 and null
+     * respectively. If end was an int, it would be initialized to 0 as well.
+     * That would cause all de-serialized CharSequenceReaders to be empty.
+     */
+    private final int start;
+    private final Integer end;
+
     /**
      * Construct a new instance with the specified character sequence.
      *
      * @param charSequence The character sequence, may be {@code null}
      */
     public CharSequenceReader(final CharSequence charSequence) {
+        this(charSequence, 0);
+    }
+
+    /**
+     * Construct a new instance with a portion of the specified character sequence.
+     * <p>
+     * The start index is not strictly enforced to be within the bounds of the
+     * character sequence. This allows the character sequence to grow or shrink
+     * in size without risking any {@link IndexOutOfBoundsException} to be thrown.
+     * Instead, if the character sequence grows smaller than the start index, this
+     * instance will act as if all characters have been read.
+     * </p>
+     *
+     * @param charSequence The character sequence, may be {@code null}
+     * @param start The start index in the character sequence, inclusive
+     * @throws IllegalArgumentException if the start index is negative
+     * @since 2.7
+     */
+    public CharSequenceReader(final CharSequence charSequence, final int start) {
+        this(charSequence, start, Integer.MAX_VALUE);
+    }
+
+    /**
+     * Construct a new instance with a portion of the specified character sequence.","[{'comment': '""Construct"" -> ""Constructs""', 'commenter': 'garydgregory'}]"
95,src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTestCase.java,"@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import java.io.File;
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+/**
+ * This class ensure the correctness of {@link FileUtils#copyDirectoryToDirectory(File, File)} (File,File)}.","[{'comment': 'I think the `@link` formatting is messed up here.', 'commenter': 'garydgregory'}, {'comment': 'Fixed in https://github.com/apache/commons-io/pull/95/commits/a3a0bfa102f7b304c067d670a7bf32aa45863a6e', 'commenter': 'mikkomaunu'}]"
95,src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTestCase.java,"@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import java.io.File;
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+/**
+ * This class ensure the correctness of {@link FileUtils#copyDirectoryToDirectory(File, File)} (File,File)}.
+ * TODO: currently does not cover happy cases
+ *
+ * @see FileUtils#copyDirectoryToDirectory(File, File)
+ */
+public class FileUtilsCopyDirectoryToDirectoryTestCase {
+
+    @Rule
+    public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
+    @Test
+    public void copyDirectoryToDirectoryThrowsIllegalExceptionWithCorrectMessageWhenSrcDirIsNotDirectory() throws IOException {
+        File srcDir = temporaryFolder.newFile(""notadirectory"");","[{'comment': 'Use `final` where possible.', 'commenter': 'garydgregory'}, {'comment': 'Fixed in https://github.com/apache/commons-io/pull/95/commits/a3a0bfa102f7b304c067d670a7bf32aa45863a6e', 'commenter': 'mikkomaunu'}]"
95,src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTestCase.java,"@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import java.io.File;
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+/**
+ * This class ensure the correctness of {@link FileUtils#copyDirectoryToDirectory(File, File)} (File,File)}.
+ * TODO: currently does not cover happy cases
+ *
+ * @see FileUtils#copyDirectoryToDirectory(File, File)
+ */
+public class FileUtilsCopyDirectoryToDirectoryTestCase {
+
+    @Rule
+    public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
+    @Test
+    public void copyDirectoryToDirectoryThrowsIllegalExceptionWithCorrectMessageWhenSrcDirIsNotDirectory() throws IOException {
+        File srcDir = temporaryFolder.newFile(""notadirectory"");
+        File destDir = temporaryFolder.newFolder(""destinationDirectory"");
+        String expectedMessage = String.format(""Source '%s' is not a directory"", srcDir);
+        assertExceptionTypeAndMessage(srcDir, destDir, IllegalArgumentException.class, expectedMessage);
+    }
+
+    @Test
+    public void copyDirectoryToDirectoryThrowsIllegalArgumentExceptionWithCorrectMessageWhenDstDirIsNotDirectory() throws IOException {
+        File srcDir = temporaryFolder.newFolder(""sourceDirectory"");
+        File destDir =  temporaryFolder.newFile(""notadirectory"");
+        String expectedMessage = String.format(""Destination '%s' is not a directory"", destDir);
+        assertExceptionTypeAndMessage(srcDir, destDir, IllegalArgumentException.class, expectedMessage);
+    }
+
+    @Test
+    public void copyDirectoryToDirectoryThrowsNullPointerExceptionWithCorrectMessageWhenSrcDirIsNull() throws IOException {
+        File srcDir = null;
+        File destinationDirectory =  temporaryFolder.newFolder(""destinationDirectory"");
+        String expectedMessage = ""Source must not be null"";
+        assertExceptionTypeAndMessage(srcDir, destinationDirectory, NullPointerException.class,  expectedMessage);
+    }
+
+    @Test
+    public void copyDirectoryToDirectoryThrowsNullPointerExceptionWithCorrectMessageWhenDstDirIsNull() throws IOException {
+        File srcDir = temporaryFolder.newFolder(""sourceDirectory"");
+        File destDir =  null;
+        String expectedMessage = ""Destination must not be null"";
+        assertExceptionTypeAndMessage(srcDir, destDir, NullPointerException.class, expectedMessage);
+    }
+
+    private static void assertExceptionTypeAndMessage(File srcDir, File destDir, Class expectedExceptionType, String expectedMessage) {
+        try {
+            FileUtils.copyDirectoryToDirectory(srcDir, destDir);
+        } catch (Exception e) {
+            String msg = e.getMessage();
+            assertEquals(expectedExceptionType, e.getClass());
+            assertEquals(expectedMessage, msg);
+            return;
+        }
+        fail();
+","[{'comment': 'Remove extra line.', 'commenter': 'garydgregory'}, {'comment': 'Fixed in https://github.com/apache/commons-io/pull/95/commits/a3a0bfa102f7b304c067d670a7bf32aa45863a6e', 'commenter': 'mikkomaunu'}]"
96,src/changes/changes.xml,"@@ -134,6 +134,9 @@ The <action> type attribute can be add,update,fix,remove.
       <action issue=""IO-625"" dev=""ggregory"" type=""fix"" due-to=""Mikko Maunu"">
         Corrected misleading exception message for FileUtils.copyDirectoryToDirectory.
       </action>
+      <action issue=""IO-626"" dev=""Yuji Konishi"" type=""fix"" due-to=""Yuji Konishi"">","[{'comment': 'Normally the **dev** is a committer, and **due-to** is the PR contributor name/alias.', 'commenter': 'Stzx'}, {'comment': 'Sorry.\r\n\r\nI thought that a committer and the PR contributor are me.\r\nWhich is my mistake, a committer or the PR contributor?\r\n', 'commenter': 'yuji-k64613'}]"
99,src/main/java/org/apache/commons/io/input/SequenceReader.java,"@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.util.List;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+/**
+ * Provides the contents of multiple Readers in sequence.
+ *
+ * @since 2.7
+ */
+public class SequenceReader extends Reader {
+    private Reader[] fReaders;
+    private int fReadersOffset;
+
+    /**
+     * @param readers the readers from which to read
+     */
+    public SequenceReader(List<? extends Reader> readers) {","[{'comment': '@RobberPhex \r\nIf you make the input a `Collection`, then you can take a `Set` as input.\r\n\r\nYou should also consider using a List internally instead of an array. It might make the above simpler.', 'commenter': 'garydgregory'}]"
99,src/main/java/org/apache/commons/io/input/SequenceReader.java,"@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.util.List;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+/**
+ * Provides the contents of multiple Readers in sequence.
+ *
+ * @since 2.7
+ */
+public class SequenceReader extends Reader {
+    private Reader[] fReaders;
+    private int fReadersOffset;
+
+    /**
+     * @param readers the readers from which to read","[{'comment': 'Incomplete Javadoc.', 'commenter': 'garydgregory'}]"
99,src/main/java/org/apache/commons/io/input/SequenceReader.java,"@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.util.List;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+/**
+ * Provides the contents of multiple Readers in sequence.
+ *
+ * @since 2.7
+ */
+public class SequenceReader extends Reader {
+    private Reader[] fReaders;
+    private int fReadersOffset;
+
+    /**
+     * @param readers the readers from which to read
+     */
+    public SequenceReader(List<? extends Reader> readers) {
+        int size = readers.size();
+        fReaders = new Reader[size];
+        for (int i = 0; i < size; i++) {
+            fReaders[i] = readers.get(i);
+        }
+    }
+
+    /**
+     * @param readers the readers from which to read","[{'comment': 'Incomplete Javadoc.', 'commenter': 'garydgregory'}]"
99,src/main/java/org/apache/commons/io/input/SequenceReader.java,"@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.util.List;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+/**
+ * Provides the contents of multiple Readers in sequence.
+ *
+ * @since 2.7
+ */
+public class SequenceReader extends Reader {
+    private Reader[] fReaders;
+    private int fReadersOffset;","[{'comment': 'No need for the ""f"" prefix which would means what? ""field""?', 'commenter': 'garydgregory'}]"
99,src/main/java/org/apache/commons/io/input/SequenceReader.java,"@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.util.List;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+/**
+ * Provides the contents of multiple Readers in sequence.
+ *
+ * @since 2.7
+ */
+public class SequenceReader extends Reader {
+    private Reader[] fReaders;
+    private int fReadersOffset;
+
+    /**
+     * @param readers the readers from which to read
+     */
+    public SequenceReader(List<? extends Reader> readers) {
+        int size = readers.size();","[{'comment': 'make `size` final.', 'commenter': 'garydgregory'}]"
99,src/test/java/org/apache/commons/io/input/SequenceReaderTest.java,"@@ -0,0 +1,140 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import org.junit.jupiter.api.Test;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+/**
+ * Test case for {@link SequenceReader}.
+ */
+public class SequenceReaderTest {
+    private static final char NONE = (new char[1])[0];
+
+    @Test
+    public void testClose() throws IOException {
+        final Reader reader = new CharSequenceReader(""FooBar"");
+        checkRead(reader, ""Foo"");
+        reader.close();
+        checkRead(reader, ""Foo"");","[{'comment': 'What does this test?', 'commenter': 'garydgregory'}]"
99,src/test/java/org/apache/commons/io/input/SequenceReaderTest.java,"@@ -0,0 +1,140 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import org.junit.jupiter.api.Test;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+/**
+ * Test case for {@link SequenceReader}.
+ */
+public class SequenceReaderTest {
+    private static final char NONE = (new char[1])[0];
+
+    @Test
+    public void testClose() throws IOException {
+        final Reader reader = new CharSequenceReader(""FooBar"");
+        checkRead(reader, ""Foo"");
+        reader.close();
+        checkRead(reader, ""Foo"");
+    }
+
+    @Test
+    public void testMarkSupported() throws Exception {","[{'comment': 'What does this test?', 'commenter': 'garydgregory'}]"
101,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -708,31 +706,79 @@ public static void closeQuietly(final Writer output) {
     @SuppressWarnings(""resource"")
     public static boolean contentEquals(final InputStream input1, final InputStream input2)
             throws IOException {
+        return contentEquals(input1, input2, DEFAULT_BUFFER_SIZE);
+    }
+
+    /**
+     * Compares the contents of two Streams to determine if they are equal or not.
+     * <p>
+     * This method buffers the input internally.
+     *
+     * @param input1 the first stream
+     * @param input2 the second stream
+     * @param bufferSize the size of the internal buffer to use.
+     * @return true if the content of the streams are equal or they both don't
+     * exist, false otherwise
+     * @throws NullPointerException if either input is null
+     * @throws IOException          if an I/O error occurs
+     */
+    @SuppressWarnings(""resource"")
+    public static boolean contentEquals(final InputStream input1, final InputStream input2, final int bufferSize)
+            throws IOException {
+        if (bufferSize <= 0) {
+            throw new IllegalArgumentException(""Buffer size must be positive: "" + bufferSize);","[{'comment': 'This one is not documented.', 'commenter': 'michael-o'}, {'comment': 'Fixed and updated.  Done for both methods that throw an IllegalArgumentException.', 'commenter': 'brettlounsbury'}]"
101,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -708,31 +706,79 @@ public static void closeQuietly(final Writer output) {
     @SuppressWarnings(""resource"")
     public static boolean contentEquals(final InputStream input1, final InputStream input2)
             throws IOException {
+        return contentEquals(input1, input2, DEFAULT_BUFFER_SIZE);
+    }
+
+    /**
+     * Compares the contents of two Streams to determine if they are equal or not.
+     * <p>
+     * This method buffers the input internally.
+     *
+     * @param input1 the first stream
+     * @param input2 the second stream
+     * @param bufferSize the size of the internal buffer to use.
+     * @return true if the content of the streams are equal or they both don't
+     * exist, false otherwise
+     * @throws NullPointerException if either input is null","[{'comment': 'I fail to see where this one is thrown.', 'commenter': 'michael-o'}, {'comment': ""This documentation is a clone/mutate from the original method's javadoc (the one without the bufferSize).  This doesn't look to be explicitly thrown, but if either InputStream is null it throws due to the stream being dereferenced.\r\n\r\nCheck the javadoc for the `public static boolean contentEquals(final InputStream input1, final InputStream input2)` method.\r\n\r\nHappy to either (a) explicitly throw a NullPointerException up front, (b) remove the comment from both places, or (c) do nothing."", 'commenter': 'brettlounsbury'}, {'comment': 'I would rather see an explicit NPE up front.', 'commenter': 'michael-o'}, {'comment': 'I looked at the beginning of each method again.  Both contentEquals methods start with the following statements.  This can never throw a NullPointerException.  If both streams are null they will be equal and therefore always return true.  If one stream is null and the other is not it will always return false based on the XOR logic.  Only if both streams are non-null and not the same object will the actual logic of the method execute.  I pushed a new version without the `@throws NullPointerException` in the javadoc.\r\n\r\n```\r\nif (input1 == input2) {\r\n            return true;\r\n}\r\nif (input1 == null ^ input2 == null) {\r\n            return false;\r\n}\r\n```', 'commenter': 'brettlounsbury'}]"
101,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -746,25 +792,74 @@ public static boolean contentEquals(final InputStream input1, final InputStream
     @SuppressWarnings(""resource"")
     public static boolean contentEquals(final Reader input1, final Reader input2)
             throws IOException {
+        return contentEquals(input1, input2, DEFAULT_BUFFER_SIZE);
+    }
+
+    /**
+     * Compares the contents of two Readers to determine if they are equal or not.
+     * <p>
+     * This method buffers the input internally.
+     * </p>
+     *
+     * @param input1 the first reader
+     * @param input2 the second reader
+     * @param bufferSize the size of the internal buffer to use.
+     * @return true if the content of the readers are equal or they both don't
+     * exist, false otherwise
+     * @throws NullPointerException if either input is null","[{'comment': 'Same here.', 'commenter': 'michael-o'}, {'comment': 'Same answer as above :-)', 'commenter': 'brettlounsbury'}]"
101,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -691,80 +692,173 @@ public static void closeQuietly(final Writer output) {
     }
 
     /**
-     * Compares the contents of two Streams to determine if they are equal or
-     * not.
+     * Compares the contents of two Streams to determine if they are equal or not.
      * <p>
-     * This method buffers the input internally using
-     * <code>BufferedInputStream</code> if they are not already buffered.
-     * </p>
+     * This method buffers the input internally using {@link #DEFAULT_BUFFER_SIZE} sized buffers.
      *
      * @param input1 the first stream
      * @param input2 the second stream
      * @return true if the content of the streams are equal or they both don't
      * exist, false otherwise
-     * @throws NullPointerException if either input is null
      * @throws IOException          if an I/O error occurs
      */
     @SuppressWarnings(""resource"")
     public static boolean contentEquals(final InputStream input1, final InputStream input2)
             throws IOException {
+        return contentEquals(input1, input2, DEFAULT_BUFFER_SIZE);
+    }
+
+    /**
+     * Compares the contents of two Streams to determine if they are equal or not.","[{'comment': ""For now, let's keep this private. I'd rather avoid, for now, having bufferSize variants of the seven APIs that use DEFAULT_BUFFER_SIZE, and this would be opening the door."", 'commenter': 'garydgregory'}, {'comment': 'Done.', 'commenter': 'brettlounsbury'}]"
101,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -691,80 +692,173 @@ public static void closeQuietly(final Writer output) {
     }
 
     /**
-     * Compares the contents of two Streams to determine if they are equal or
-     * not.
+     * Compares the contents of two Streams to determine if they are equal or not.
      * <p>
-     * This method buffers the input internally using
-     * <code>BufferedInputStream</code> if they are not already buffered.
-     * </p>
+     * This method buffers the input internally using {@link #DEFAULT_BUFFER_SIZE} sized buffers.
      *
      * @param input1 the first stream
      * @param input2 the second stream
      * @return true if the content of the streams are equal or they both don't
      * exist, false otherwise
-     * @throws NullPointerException if either input is null
      * @throws IOException          if an I/O error occurs
      */
     @SuppressWarnings(""resource"")
     public static boolean contentEquals(final InputStream input1, final InputStream input2)
             throws IOException {
+        return contentEquals(input1, input2, DEFAULT_BUFFER_SIZE);
+    }
+
+    /**
+     * Compares the contents of two Streams to determine if they are equal or not.
+     * <p>
+     * This method buffers the input internally.
+     *
+     * @param input1 the first stream
+     * @param input2 the second stream
+     * @param bufferSize the size of the internal buffer to use.
+     * @return true if the content of the streams are equal or they both don't
+     * exist, false otherwise
+     * @throws IllegalArgumentException if bufferSize is less than or equal to zero.
+     * @throws IOException              if an I/O error occurs
+     * @since 2.6","[{'comment': 'The next version will be 2.7, not 2.6.', 'commenter': 'garydgregory'}, {'comment': 'Done', 'commenter': 'brettlounsbury'}]"
101,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -691,80 +692,173 @@ public static void closeQuietly(final Writer output) {
     }
 
     /**
-     * Compares the contents of two Streams to determine if they are equal or
-     * not.
+     * Compares the contents of two Streams to determine if they are equal or not.
      * <p>
-     * This method buffers the input internally using
-     * <code>BufferedInputStream</code> if they are not already buffered.
-     * </p>
+     * This method buffers the input internally using {@link #DEFAULT_BUFFER_SIZE} sized buffers.
      *
      * @param input1 the first stream
      * @param input2 the second stream
      * @return true if the content of the streams are equal or they both don't
      * exist, false otherwise
-     * @throws NullPointerException if either input is null
      * @throws IOException          if an I/O error occurs
      */
     @SuppressWarnings(""resource"")
     public static boolean contentEquals(final InputStream input1, final InputStream input2)
             throws IOException {
+        return contentEquals(input1, input2, DEFAULT_BUFFER_SIZE);
+    }
+
+    /**
+     * Compares the contents of two Streams to determine if they are equal or not.
+     * <p>
+     * This method buffers the input internally.
+     *
+     * @param input1 the first stream
+     * @param input2 the second stream
+     * @param bufferSize the size of the internal buffer to use.
+     * @return true if the content of the streams are equal or they both don't
+     * exist, false otherwise
+     * @throws IllegalArgumentException if bufferSize is less than or equal to zero.
+     * @throws IOException              if an I/O error occurs
+     * @since 2.6
+     */
+    @SuppressWarnings(""resource"")
+    public static boolean contentEquals(final InputStream input1, final InputStream input2, final int bufferSize)
+            throws IOException {
+        if (bufferSize <= 0) {
+            throw new IllegalArgumentException(""Buffer size must be positive: "" + bufferSize);
+        }
+
         if (input1 == input2) {
             return true;
         }
         if (input1 == null ^ input2 == null) {
             return false;
         }
-        final BufferedInputStream bufferedInput1 = buffer(input1);
-        final BufferedInputStream bufferedInput2 = buffer(input2);
-        int ch = bufferedInput1.read();
-        while (EOF != ch) {
-            final int ch2 = bufferedInput2.read();
-            if (ch != ch2) {
+
+        int input1NumBytesRead = 0;
+        int input2NumBytesRead = 0;
+        final byte[] input1Buffer = new byte[bufferSize];
+        final byte[] input2Buffer = new byte[bufferSize];
+        do {
+            input1NumBytesRead = fillBuffer(input1, input1Buffer);
+            input2NumBytesRead = fillBuffer(input2, input2Buffer);
+
+            if (input2NumBytesRead != input1NumBytesRead || !Arrays.equals(input1Buffer, input2Buffer)) {
                 return false;
             }
-            ch = bufferedInput1.read();
-        }
-        return bufferedInput2.read() == EOF;
+        } while (input1NumBytesRead == bufferSize && input2NumBytesRead == bufferSize);
+
+        return input1.read() == EOF && input2.read() == EOF;
     }
 
+
     /**
-     * Compares the contents of two Readers to determine if they are equal or
-     * not.
+     * This method fills the provided byte array buffer from the provided <code>InputStream</code>.  When this method
+     * returns the buffer will either be full or the InputStream will be fully consumed.
+     *
+     * @param inputStream the InputStream from which to read
+     * @param buffer the buffer to fill
+     * @return the number of bytes placed in the buffer.  If this is equal to <code>buffer.length</code> then the
+     * buffer was completely filled.  If it is less than <code>buffer.length</code>, then the InputStream has been
+     * fully consumed.
+     * @throws IOException if an I/O error occurs.
+     */
+    private static int fillBuffer(final InputStream inputStream, final byte[] buffer) throws IOException {
+        int totalBytesRead = 0;
+        int bytesRead = 0;
+        do {
+            totalBytesRead += bytesRead;
+            bytesRead = inputStream.read(buffer, totalBytesRead, buffer.length - totalBytesRead);
+        } while (bytesRead != -1 && totalBytesRead < buffer.length);","[{'comment': 'Avoid using magic numbers; we have a constant called EOF for this purpose.\r\n', 'commenter': 'garydgregory'}, {'comment': ""Good catch.  I've used it elsewhere but somehow missed it in the loops.  Its somewhat moot, however, since the two fillBuffer methods have been deleted."", 'commenter': 'brettlounsbury'}]"
101,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -691,80 +692,173 @@ public static void closeQuietly(final Writer output) {
     }
 
     /**
-     * Compares the contents of two Streams to determine if they are equal or
-     * not.
+     * Compares the contents of two Streams to determine if they are equal or not.
      * <p>
-     * This method buffers the input internally using
-     * <code>BufferedInputStream</code> if they are not already buffered.
-     * </p>
+     * This method buffers the input internally using {@link #DEFAULT_BUFFER_SIZE} sized buffers.
      *
      * @param input1 the first stream
      * @param input2 the second stream
      * @return true if the content of the streams are equal or they both don't
      * exist, false otherwise
-     * @throws NullPointerException if either input is null
      * @throws IOException          if an I/O error occurs
      */
     @SuppressWarnings(""resource"")
     public static boolean contentEquals(final InputStream input1, final InputStream input2)
             throws IOException {
+        return contentEquals(input1, input2, DEFAULT_BUFFER_SIZE);
+    }
+
+    /**
+     * Compares the contents of two Streams to determine if they are equal or not.
+     * <p>
+     * This method buffers the input internally.
+     *
+     * @param input1 the first stream
+     * @param input2 the second stream
+     * @param bufferSize the size of the internal buffer to use.
+     * @return true if the content of the streams are equal or they both don't
+     * exist, false otherwise
+     * @throws IllegalArgumentException if bufferSize is less than or equal to zero.
+     * @throws IOException              if an I/O error occurs
+     * @since 2.6
+     */
+    @SuppressWarnings(""resource"")
+    public static boolean contentEquals(final InputStream input1, final InputStream input2, final int bufferSize)
+            throws IOException {
+        if (bufferSize <= 0) {
+            throw new IllegalArgumentException(""Buffer size must be positive: "" + bufferSize);
+        }
+
         if (input1 == input2) {
             return true;
         }
         if (input1 == null ^ input2 == null) {
             return false;
         }
-        final BufferedInputStream bufferedInput1 = buffer(input1);
-        final BufferedInputStream bufferedInput2 = buffer(input2);
-        int ch = bufferedInput1.read();
-        while (EOF != ch) {
-            final int ch2 = bufferedInput2.read();
-            if (ch != ch2) {
+
+        int input1NumBytesRead = 0;
+        int input2NumBytesRead = 0;
+        final byte[] input1Buffer = new byte[bufferSize];
+        final byte[] input2Buffer = new byte[bufferSize];
+        do {
+            input1NumBytesRead = fillBuffer(input1, input1Buffer);
+            input2NumBytesRead = fillBuffer(input2, input2Buffer);
+
+            if (input2NumBytesRead != input1NumBytesRead || !Arrays.equals(input1Buffer, input2Buffer)) {
                 return false;
             }
-            ch = bufferedInput1.read();
-        }
-        return bufferedInput2.read() == EOF;
+        } while (input1NumBytesRead == bufferSize && input2NumBytesRead == bufferSize);
+
+        return input1.read() == EOF && input2.read() == EOF;
     }
 
+
     /**
-     * Compares the contents of two Readers to determine if they are equal or
-     * not.
+     * This method fills the provided byte array buffer from the provided <code>InputStream</code>.  When this method
+     * returns the buffer will either be full or the InputStream will be fully consumed.
+     *
+     * @param inputStream the InputStream from which to read
+     * @param buffer the buffer to fill
+     * @return the number of bytes placed in the buffer.  If this is equal to <code>buffer.length</code> then the
+     * buffer was completely filled.  If it is less than <code>buffer.length</code>, then the InputStream has been
+     * fully consumed.
+     * @throws IOException if an I/O error occurs.
+     */
+    private static int fillBuffer(final InputStream inputStream, final byte[] buffer) throws IOException {
+        int totalBytesRead = 0;
+        int bytesRead = 0;
+        do {
+            totalBytesRead += bytesRead;
+            bytesRead = inputStream.read(buffer, totalBytesRead, buffer.length - totalBytesRead);
+        } while (bytesRead != -1 && totalBytesRead < buffer.length);
+
+        return totalBytesRead;
+    }
+
+    /**
+     * Compares the contents of two Readers to determine if they are equal or not.
      * <p>
-     * This method buffers the input internally using
-     * <code>BufferedReader</code> if they are not already buffered.
+     * This method buffers the input internally using {@link #DEFAULT_BUFFER_SIZE} sized buffers.
      * </p>
      *
      * @param input1 the first reader
      * @param input2 the second reader
      * @return true if the content of the readers are equal or they both don't
      * exist, false otherwise
-     * @throws NullPointerException if either input is null
      * @throws IOException          if an I/O error occurs
      * @since 1.1
      */
     @SuppressWarnings(""resource"")
     public static boolean contentEquals(final Reader input1, final Reader input2)
             throws IOException {
+        return contentEquals(input1, input2, DEFAULT_BUFFER_SIZE);
+    }
+
+    /**
+     * Compares the contents of two Readers to determine if they are equal or not.
+     * <p>
+     * This method buffers the input internally.
+     * </p>
+     *
+     * @param input1 the first reader
+     * @param input2 the second reader
+     * @param bufferSize the size of the internal buffer to use.
+     * @return true if the content of the readers are equal or they both don't
+     * exist, false otherwise
+     * @throws IllegalArgumentException if bufferSize is less than or equal to zero.
+     * @throws IOException              if an I/O error occurs
+     * @since 2.6
+     */
+    @SuppressWarnings(""resource"")
+    public static boolean contentEquals(final Reader input1, final Reader input2, final int bufferSize)
+            throws IOException {
+        if (bufferSize <= 0) {
+            throw new IllegalArgumentException(""Buffer size must be positive: "" + bufferSize);
+        }
+
         if (input1 == input2) {
             return true;
         }
         if (input1 == null ^ input2 == null) {
             return false;
         }
-        final BufferedReader bufferedInput1 = toBufferedReader(input1);
-        final BufferedReader bufferedInput2 = toBufferedReader(input2);
 
-        int ch = bufferedInput1.read();
-        while (EOF != ch) {
-            final int ch2 = bufferedInput2.read();
-            if (ch != ch2) {
+        int input1NumCharsRead = 0;
+        int input2NumCharsRead = 0;
+        final char[] input1Buffer = new char[bufferSize];
+        final char[] input2Buffer = new char[bufferSize];
+        do {
+            input1NumCharsRead = fillBuffer(input1, input1Buffer);
+            input2NumCharsRead = fillBuffer(input2, input2Buffer);
+
+            if (input2NumCharsRead != input1NumCharsRead || !Arrays.equals(input1Buffer, input2Buffer)) {
                 return false;
             }
-            ch = bufferedInput1.read();
-        }
+        } while (input1NumCharsRead == bufferSize && input2NumCharsRead == bufferSize);
+
+        return input1.read() == EOF && input2.read() == EOF;
+    }
+
+    /**
+     * This method fills the provided byte array buffer from the provided <code>Reader</code>.  When this method
+     * returns the buffer will either be full or the InputStream will be fully consumed.
+     *
+     * @param reader the Reader from which to read
+     * @param buffer the buffer to fill
+     * @return the number of chars placed in the buffer.  If this is equal to <code>buffer.length</code> then the
+     * buffer was completely filled.  If it is less than <code>buffer.length</code>, then the Reader has been
+     * fully consumed.
+     * @throws IOException if an I/O error occurs.
+     */
+    private static int fillBuffer(final Reader reader, final char[] buffer) throws IOException {
+        int totalBytesRead = 0;
+        int bytesRead = 0;
+        do {
+            totalBytesRead += bytesRead;
+            bytesRead = reader.read(buffer, totalBytesRead, buffer.length - totalBytesRead);
+        } while (bytesRead != -1 && totalBytesRead < buffer.length);","[{'comment': 'Magic number; use EOF.', 'commenter': 'garydgregory'}, {'comment': 'Same as above :-)', 'commenter': 'brettlounsbury'}]"
101,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -691,80 +692,173 @@ public static void closeQuietly(final Writer output) {
     }
 
     /**
-     * Compares the contents of two Streams to determine if they are equal or
-     * not.
+     * Compares the contents of two Streams to determine if they are equal or not.
      * <p>
-     * This method buffers the input internally using
-     * <code>BufferedInputStream</code> if they are not already buffered.
-     * </p>
+     * This method buffers the input internally using {@link #DEFAULT_BUFFER_SIZE} sized buffers.
      *
      * @param input1 the first stream
      * @param input2 the second stream
      * @return true if the content of the streams are equal or they both don't
      * exist, false otherwise
-     * @throws NullPointerException if either input is null
      * @throws IOException          if an I/O error occurs
      */
     @SuppressWarnings(""resource"")
     public static boolean contentEquals(final InputStream input1, final InputStream input2)
             throws IOException {
+        return contentEquals(input1, input2, DEFAULT_BUFFER_SIZE);
+    }
+
+    /**
+     * Compares the contents of two Streams to determine if they are equal or not.
+     * <p>
+     * This method buffers the input internally.
+     *
+     * @param input1 the first stream
+     * @param input2 the second stream
+     * @param bufferSize the size of the internal buffer to use.
+     * @return true if the content of the streams are equal or they both don't
+     * exist, false otherwise
+     * @throws IllegalArgumentException if bufferSize is less than or equal to zero.
+     * @throws IOException              if an I/O error occurs
+     * @since 2.6
+     */
+    @SuppressWarnings(""resource"")
+    public static boolean contentEquals(final InputStream input1, final InputStream input2, final int bufferSize)
+            throws IOException {
+        if (bufferSize <= 0) {
+            throw new IllegalArgumentException(""Buffer size must be positive: "" + bufferSize);
+        }
+
         if (input1 == input2) {
             return true;
         }
         if (input1 == null ^ input2 == null) {
             return false;
         }
-        final BufferedInputStream bufferedInput1 = buffer(input1);
-        final BufferedInputStream bufferedInput2 = buffer(input2);
-        int ch = bufferedInput1.read();
-        while (EOF != ch) {
-            final int ch2 = bufferedInput2.read();
-            if (ch != ch2) {
+
+        int input1NumBytesRead = 0;
+        int input2NumBytesRead = 0;
+        final byte[] input1Buffer = new byte[bufferSize];
+        final byte[] input2Buffer = new byte[bufferSize];
+        do {
+            input1NumBytesRead = fillBuffer(input1, input1Buffer);
+            input2NumBytesRead = fillBuffer(input2, input2Buffer);
+
+            if (input2NumBytesRead != input1NumBytesRead || !Arrays.equals(input1Buffer, input2Buffer)) {
                 return false;
             }
-            ch = bufferedInput1.read();
-        }
-        return bufferedInput2.read() == EOF;
+        } while (input1NumBytesRead == bufferSize && input2NumBytesRead == bufferSize);
+
+        return input1.read() == EOF && input2.read() == EOF;
     }
 
+
     /**
-     * Compares the contents of two Readers to determine if they are equal or
-     * not.
+     * This method fills the provided byte array buffer from the provided <code>InputStream</code>.  When this method
+     * returns the buffer will either be full or the InputStream will be fully consumed.
+     *
+     * @param inputStream the InputStream from which to read
+     * @param buffer the buffer to fill
+     * @return the number of bytes placed in the buffer.  If this is equal to <code>buffer.length</code> then the
+     * buffer was completely filled.  If it is less than <code>buffer.length</code>, then the InputStream has been
+     * fully consumed.
+     * @throws IOException if an I/O error occurs.
+     */
+    private static int fillBuffer(final InputStream inputStream, final byte[] buffer) throws IOException {","[{'comment': 'I think we can avoid adding these kinds of method by reusing `org.apache.commons.io.IOUtils.read(InputStream, byte[], int, int)` and `org.apache.commons.io.IOUtils.read(Reader, char[], int, int)`.', 'commenter': 'garydgregory'}, {'comment': ""Yes, it looks like IOUtils.read(InputStream, byte[]) and IOUtils.read(Reader, char[]) (without the optional arguments) should do exactly what I want.\r\n\r\nThanks for the call out, I didn't realize those methods existed."", 'commenter': 'brettlounsbury'}]"
102,src/test/java/org/apache/commons/io/FileUtilsTestCase.java,"@@ -244,6 +244,19 @@ public void test_openInputStream_notExists() throws Exception {
         }
     }
 
+    @Test
+    public void openInputStreamCannotReadFile() throws IOException {
+        final File file = new File(temporaryFolder, ""test.txt"") {","[{'comment': 'Use Mockito for this type of test fixture.', 'commenter': 'garydgregory'}]"
102,src/test/java/org/apache/commons/io/FileUtilsTestCase.java,"@@ -321,6 +334,19 @@ public void test_openOutputStream_notExistsCannotCreate() throws Exception {
         }
     }
 
+    @Test
+    public void openOutputStreamCannotWriteFile() throws Exception {
+        final File file = new File(temporaryFolder, ""test.txt"") {","[{'comment': 'Use Mockito for this type of test fixture.', 'commenter': 'garydgregory'}]"
102,src/test/java/org/apache/commons/io/FileUtilsTestCase.java,"@@ -1237,6 +1263,50 @@ public void testCopyFile2WithoutFileDatePreservation() throws Exception {
             testFile1.lastModified() != destination.lastModified());*/
     }
 
+    @Test
+    public void copyFileFailedWhenSourceIsDirectory() {
+        final File source = new File(temporaryFolder, ""testCopyFileWhenSourceIsDirectory"");
+        if (!source.exists()) {
+            source.mkdirs();
+        }
+        final File destination = new File(temporaryFolder, ""destination"");
+
+        assertThrows(IOException.class, () -> FileUtils.copyFile(source, destination, false));
+    }
+
+    @Test
+    public void copyFileFailedWhenDestinationParentDirectoryCannotBeCreated() {
+        final File destination = new File(temporaryFolder, ""destination/drop.txt"") {
+            @Override
+            public File getParentFile() {
+                final File parentFile = new File(String.valueOf(super.getParentFile())) {
+                    @Override","[{'comment': 'Use Mockito for this type of test fixture.', 'commenter': 'garydgregory'}]"
102,src/test/java/org/apache/commons/io/FileUtilsTestCase.java,"@@ -1237,6 +1263,50 @@ public void testCopyFile2WithoutFileDatePreservation() throws Exception {
             testFile1.lastModified() != destination.lastModified());*/
     }
 
+    @Test
+    public void copyFileFailedWhenSourceIsDirectory() {
+        final File source = new File(temporaryFolder, ""testCopyFileWhenSourceIsDirectory"");
+        if (!source.exists()) {
+            source.mkdirs();
+        }
+        final File destination = new File(temporaryFolder, ""destination"");
+
+        assertThrows(IOException.class, () -> FileUtils.copyFile(source, destination, false));
+    }
+
+    @Test
+    public void copyFileFailedWhenDestinationParentDirectoryCannotBeCreated() {
+        final File destination = new File(temporaryFolder, ""destination/drop.txt"") {
+            @Override
+            public File getParentFile() {
+                final File parentFile = new File(String.valueOf(super.getParentFile())) {
+                    @Override
+                    public boolean mkdirs() {
+                        return false;
+                    }
+                };
+                return parentFile;
+            }
+        };
+
+        assertThrows(IOException.class, () -> FileUtils.copyFile(testFile1, destination, false));
+    }
+
+    @Test
+    public void copyFileFailedWhenDestinationExistsButIsReadyOnly() {
+        final File destination = new File(temporaryFolder, ""destination/drop.txt"") {
+            @Override","[{'comment': 'Use Mockito for this type of test fixture.', 'commenter': 'garydgregory'}]"
102,src/test/java/org/apache/commons/io/FileUtilsTestCase.java,"@@ -2507,6 +2597,21 @@ public void testDeleteDirectoryWithNonDirectory() throws Exception {
         }
     }
 
+    @Test
+    public void deleteDirectoryFailed() {
+        File directoryToDelete = new File(temporaryFolder, ""directoryToDelete"") {","[{'comment': 'Use final where posssible,\r\nUse Mockito for this type of test fixture.', 'commenter': 'garydgregory'}]"
108,pom.xml,"@@ -226,6 +230,11 @@ file comparators, endian transformation classes, and much more.
   </contributors>
 
   <dependencies>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>","[{'comment': ""Is this just to bring in the @javax.annotation.concurrent.ThreadSafe annotation? I don't think this necessary since you already document the thread safety in the javadoc. Nothing else in the code base uses this non-standard annotation support."", 'commenter': 'aherbert'}, {'comment': 'Well yes it is to bring in the annotation... but these annotations can also be used by various tools like FindBugs and others to detect issues.\r\n\r\nI think it adds value, and jsr305 is tiny (19KB). I can remove it if people prefer? It also adds useful annotations like `@Nullable` and `@NotNull` for similar purposes.\r\n\r\nI can remove it though if that is preferred. Should I do that?', 'commenter': 'adamretter'}, {'comment': ""I would remove it from this PR. Adding an annotation dependency should be in another PR that perhaps then makes more use of it than a single location. The Guava codebase uses these throughout and in that case they have value for a bug detection tool. I don't think a single annotation of `@ThreadSafe` is likely to detect many (any?) bugs given that synchronized code should be less of a problem than unsynchronized code. If you do have a bug detection tool that flags this class as a problem when used in a concurrent scenario a brief look at the javadoc (which notes this is safe for concurrent use) will allow you to mark the bug as false positive."", 'commenter': 'aherbert'}, {'comment': 'Okie dokie. Done.', 'commenter': 'adamretter'}]"
108,src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTestCase.java,"@@ -211,13 +217,30 @@ public void testStream() throws Exception {
 
         //Make sure that empty ByteArrayOutputStreams really don't create garbage
         //on toByteArray()
-        final ByteArrayOutputStream baos1 = new ByteArrayOutputStream();
-        final ByteArrayOutputStream baos2 = new ByteArrayOutputStream();
+        final AbstractByteArrayOutputStream baos1 = baosFactory.instance();
+        final AbstractByteArrayOutputStream baos2 = baosFactory.instance();
         assertSame(baos1.toByteArray(), baos2.toByteArray());
         baos1.close();
         baos2.close();
         baout.close();
         baout1.close();
     }
+
+    private static Stream<Arguments> baosFactories() {
+        final BAOSFactory syncBaosFactory = size -> new ByteArrayOutputStream(size);
+        final BAOSFactory nonSyncBaos = size -> new FastByteArrayOutputStream(size);","[{'comment': 'rename nonSyncBaosFactory', 'commenter': 'aherbert'}, {'comment': 'Done.', 'commenter': 'adamretter'}]"
108,src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java,"@@ -0,0 +1,391 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import org.apache.commons.io.input.ClosedInputStream;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.SequenceInputStream;
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+/**
+ * This is the base class for implementing an output stream in which the data
+ * is written into a byte array. The buffer automatically grows as data
+ * is written to it.
+ * <p>
+ * The data can be retrieved using <code>toByteArray()</code> and
+ * <code>toString()</code>.
+ * <p>
+ * Closing an {@code AbstractByteArrayOutputStream} has no effect. The methods in
+ * this class can be called after the stream has been closed without
+ * generating an {@code IOException}.
+ * <p>
+ * This is the base for an alternative implementation of the
+ * {@link java.io.ByteArrayOutputStream} class. The original implementation
+ * only allocates 32 bytes at the beginning. As this class is designed for
+ * heavy duty it starts at 1024 bytes. In contrast to the original it doesn't
+ * reallocate the whole memory block but allocates additional buffers. This
+ * way no buffers need to be garbage collected and the contents don't have
+ * to be copied to the new buffer. This class is designed to behave exactly
+ * like the original. The only exception is the deprecated
+ * {@link java.io.ByteArrayOutputStream#toString(int)} method that has been
+ * ignored.
+ */","[{'comment': 'Please Add `@since 2.7`.', 'commenter': 'garydgregory'}]"
108,src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java,"@@ -0,0 +1,391 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import org.apache.commons.io.input.ClosedInputStream;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.SequenceInputStream;
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+/**
+ * This is the base class for implementing an output stream in which the data
+ * is written into a byte array. The buffer automatically grows as data
+ * is written to it.
+ * <p>
+ * The data can be retrieved using <code>toByteArray()</code> and
+ * <code>toString()</code>.
+ * <p>","[{'comment': 'Please close HTML tags.', 'commenter': 'garydgregory'}]"
108,src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java,"@@ -0,0 +1,391 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import org.apache.commons.io.input.ClosedInputStream;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.SequenceInputStream;
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+/**
+ * This is the base class for implementing an output stream in which the data
+ * is written into a byte array. The buffer automatically grows as data
+ * is written to it.
+ * <p>
+ * The data can be retrieved using <code>toByteArray()</code> and
+ * <code>toString()</code>.
+ * <p>
+ * Closing an {@code AbstractByteArrayOutputStream} has no effect. The methods in
+ * this class can be called after the stream has been closed without
+ * generating an {@code IOException}.
+ * <p>
+ * This is the base for an alternative implementation of the
+ * {@link java.io.ByteArrayOutputStream} class. The original implementation
+ * only allocates 32 bytes at the beginning. As this class is designed for
+ * heavy duty it starts at 1024 bytes. In contrast to the original it doesn't
+ * reallocate the whole memory block but allocates additional buffers. This
+ * way no buffers need to be garbage collected and the contents don't have
+ * to be copied to the new buffer. This class is designed to behave exactly
+ * like the original. The only exception is the deprecated
+ * {@link java.io.ByteArrayOutputStream#toString(int)} method that has been
+ * ignored.
+ */
+public abstract class AbstractByteArrayOutputStream extends OutputStream {
+
+    static final int DEFAULT_SIZE = 1024;
+
+    /** A singleton empty byte array. */
+    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+
+    /** The list of buffers, which grows and never reduces. */
+    private final List<byte[]> buffers = new ArrayList<>();
+    /** The index of the current buffer. */
+    private int currentBufferIndex;
+    /** The total count of bytes in all the filled buffers. */
+    private int filledBufferSum;
+    /** The current buffer. */
+    private byte[] currentBuffer;
+    /** The total count of bytes written. */
+    protected int count;
+    /** Flag to indicate if the buffers can be reused after reset */
+    private boolean reuseBuffers = true;
+
+    /**
+     * Makes a new buffer available either by allocating
+     * a new one or re-cycling an existing one.
+     *
+     * @param newcount  the size of the buffer if one is created
+     */
+    protected void needNewBuffer(final int newcount) {
+        if (currentBufferIndex < buffers.size() - 1) {
+            //Recycling old buffer
+            filledBufferSum += currentBuffer.length;
+
+            currentBufferIndex++;
+            currentBuffer = buffers.get(currentBufferIndex);
+        } else {
+            //Creating new buffer
+            int newBufferSize;
+            if (currentBuffer == null) {
+                newBufferSize = newcount;
+                filledBufferSum = 0;
+            } else {
+                newBufferSize = Math.max(
+                    currentBuffer.length << 1,
+                    newcount - filledBufferSum);
+                filledBufferSum += currentBuffer.length;
+            }
+
+            currentBufferIndex++;
+            currentBuffer = new byte[newBufferSize];
+            buffers.add(currentBuffer);
+        }
+    }
+
+    /**
+     * Write the bytes to byte array.","[{'comment': '""Write"" -> ""Writes"".', 'commenter': 'garydgregory'}]"
108,src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java,"@@ -0,0 +1,391 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import org.apache.commons.io.input.ClosedInputStream;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.SequenceInputStream;
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+/**
+ * This is the base class for implementing an output stream in which the data
+ * is written into a byte array. The buffer automatically grows as data
+ * is written to it.
+ * <p>
+ * The data can be retrieved using <code>toByteArray()</code> and
+ * <code>toString()</code>.
+ * <p>
+ * Closing an {@code AbstractByteArrayOutputStream} has no effect. The methods in
+ * this class can be called after the stream has been closed without
+ * generating an {@code IOException}.
+ * <p>
+ * This is the base for an alternative implementation of the
+ * {@link java.io.ByteArrayOutputStream} class. The original implementation
+ * only allocates 32 bytes at the beginning. As this class is designed for
+ * heavy duty it starts at 1024 bytes. In contrast to the original it doesn't
+ * reallocate the whole memory block but allocates additional buffers. This
+ * way no buffers need to be garbage collected and the contents don't have
+ * to be copied to the new buffer. This class is designed to behave exactly
+ * like the original. The only exception is the deprecated
+ * {@link java.io.ByteArrayOutputStream#toString(int)} method that has been
+ * ignored.
+ */
+public abstract class AbstractByteArrayOutputStream extends OutputStream {
+
+    static final int DEFAULT_SIZE = 1024;
+
+    /** A singleton empty byte array. */
+    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+
+    /** The list of buffers, which grows and never reduces. */
+    private final List<byte[]> buffers = new ArrayList<>();
+    /** The index of the current buffer. */
+    private int currentBufferIndex;
+    /** The total count of bytes in all the filled buffers. */
+    private int filledBufferSum;
+    /** The current buffer. */
+    private byte[] currentBuffer;
+    /** The total count of bytes written. */
+    protected int count;
+    /** Flag to indicate if the buffers can be reused after reset */
+    private boolean reuseBuffers = true;
+
+    /**
+     * Makes a new buffer available either by allocating
+     * a new one or re-cycling an existing one.
+     *
+     * @param newcount  the size of the buffer if one is created
+     */
+    protected void needNewBuffer(final int newcount) {
+        if (currentBufferIndex < buffers.size() - 1) {
+            //Recycling old buffer
+            filledBufferSum += currentBuffer.length;
+
+            currentBufferIndex++;
+            currentBuffer = buffers.get(currentBufferIndex);
+        } else {
+            //Creating new buffer
+            int newBufferSize;
+            if (currentBuffer == null) {
+                newBufferSize = newcount;
+                filledBufferSum = 0;
+            } else {
+                newBufferSize = Math.max(
+                    currentBuffer.length << 1,
+                    newcount - filledBufferSum);
+                filledBufferSum += currentBuffer.length;
+            }
+
+            currentBufferIndex++;
+            currentBuffer = new byte[newBufferSize];
+            buffers.add(currentBuffer);
+        }
+    }
+
+    /**
+     * Write the bytes to byte array.
+     * @param b the bytes to write
+     * @param off The start offset
+     * @param len The number of bytes to write
+     */
+    @Override
+    public abstract void write(final byte[] b, final int off, final int len);
+
+    /**
+     * Write the bytes to byte array.
+     * @param b the bytes to write
+     * @param off The start offset
+     * @param len The number of bytes to write
+     */
+    protected void writeImpl(final byte[] b, final int off, final int len) {
+        final int newcount = count + len;
+        int remaining = len;
+        int inBufferPos = count - filledBufferSum;
+        while (remaining > 0) {
+            final int part = Math.min(remaining, currentBuffer.length - inBufferPos);
+            System.arraycopy(b, off + len - remaining, currentBuffer, inBufferPos, part);
+            remaining -= part;
+            if (remaining > 0) {
+                needNewBuffer(newcount);
+                inBufferPos = 0;
+            }
+        }
+        count = newcount;
+    }
+
+    /**
+     * Write a byte to byte array.
+     * @param b the byte to write
+     */
+    @Override
+    public abstract void write(final int b);
+
+    /**
+     * Write a byte to byte array.
+     * @param b the byte to write
+     */
+    protected void writeImpl(final int b) {
+        int inBufferPos = count - filledBufferSum;
+        if (inBufferPos == currentBuffer.length) {
+            needNewBuffer(count + 1);
+            inBufferPos = 0;
+        }
+        currentBuffer[inBufferPos] = (byte) b;
+        count++;
+    }
+
+
+    /**
+     * Writes the entire contents of the specified input stream to this
+     * byte stream. Bytes from the input stream are read directly into the
+     * internal buffers of this streams.
+     *
+     * @param in the input stream to read from
+     * @return total number of bytes read from the input stream
+     *         (and written to this stream)
+     * @throws IOException if an I/O error occurs while reading the input stream
+     * @since 1.4
+     */
+    public abstract int write(final InputStream in) throws IOException;
+
+    /**
+     * Writes the entire contents of the specified input stream to this
+     * byte stream. Bytes from the input stream are read directly into the
+     * internal buffers of this streams.
+     *
+     * @param in the input stream to read from
+     * @return total number of bytes read from the input stream
+     *         (and written to this stream)
+     * @throws IOException if an I/O error occurs while reading the input stream
+     * @since 2.7
+     */
+    protected int writeImpl(final InputStream in) throws IOException {
+        int readCount = 0;
+        int inBufferPos = count - filledBufferSum;
+        int n = in.read(currentBuffer, inBufferPos, currentBuffer.length - inBufferPos);
+        while (n != EOF) {
+            readCount += n;
+            inBufferPos += n;
+            count += n;
+            if (inBufferPos == currentBuffer.length) {
+                needNewBuffer(currentBuffer.length);
+                inBufferPos = 0;
+            }
+            n = in.read(currentBuffer, inBufferPos, currentBuffer.length - inBufferPos);
+        }
+        return readCount;
+    }
+
+    /**
+     * Return the current size of the byte array.","[{'comment': '""Return"" -> ""Returns"".', 'commenter': 'garydgregory'}]"
108,src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java,"@@ -0,0 +1,391 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import org.apache.commons.io.input.ClosedInputStream;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.SequenceInputStream;
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+/**
+ * This is the base class for implementing an output stream in which the data
+ * is written into a byte array. The buffer automatically grows as data
+ * is written to it.
+ * <p>
+ * The data can be retrieved using <code>toByteArray()</code> and
+ * <code>toString()</code>.
+ * <p>
+ * Closing an {@code AbstractByteArrayOutputStream} has no effect. The methods in
+ * this class can be called after the stream has been closed without
+ * generating an {@code IOException}.
+ * <p>
+ * This is the base for an alternative implementation of the
+ * {@link java.io.ByteArrayOutputStream} class. The original implementation
+ * only allocates 32 bytes at the beginning. As this class is designed for
+ * heavy duty it starts at 1024 bytes. In contrast to the original it doesn't
+ * reallocate the whole memory block but allocates additional buffers. This
+ * way no buffers need to be garbage collected and the contents don't have
+ * to be copied to the new buffer. This class is designed to behave exactly
+ * like the original. The only exception is the deprecated
+ * {@link java.io.ByteArrayOutputStream#toString(int)} method that has been
+ * ignored.
+ */
+public abstract class AbstractByteArrayOutputStream extends OutputStream {
+
+    static final int DEFAULT_SIZE = 1024;
+
+    /** A singleton empty byte array. */
+    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+
+    /** The list of buffers, which grows and never reduces. */
+    private final List<byte[]> buffers = new ArrayList<>();
+    /** The index of the current buffer. */
+    private int currentBufferIndex;
+    /** The total count of bytes in all the filled buffers. */
+    private int filledBufferSum;
+    /** The current buffer. */
+    private byte[] currentBuffer;
+    /** The total count of bytes written. */
+    protected int count;
+    /** Flag to indicate if the buffers can be reused after reset */
+    private boolean reuseBuffers = true;
+
+    /**
+     * Makes a new buffer available either by allocating
+     * a new one or re-cycling an existing one.
+     *
+     * @param newcount  the size of the buffer if one is created
+     */
+    protected void needNewBuffer(final int newcount) {
+        if (currentBufferIndex < buffers.size() - 1) {
+            //Recycling old buffer
+            filledBufferSum += currentBuffer.length;
+
+            currentBufferIndex++;
+            currentBuffer = buffers.get(currentBufferIndex);
+        } else {
+            //Creating new buffer
+            int newBufferSize;
+            if (currentBuffer == null) {
+                newBufferSize = newcount;
+                filledBufferSum = 0;
+            } else {
+                newBufferSize = Math.max(
+                    currentBuffer.length << 1,
+                    newcount - filledBufferSum);
+                filledBufferSum += currentBuffer.length;
+            }
+
+            currentBufferIndex++;
+            currentBuffer = new byte[newBufferSize];
+            buffers.add(currentBuffer);
+        }
+    }
+
+    /**
+     * Write the bytes to byte array.
+     * @param b the bytes to write
+     * @param off The start offset
+     * @param len The number of bytes to write
+     */
+    @Override
+    public abstract void write(final byte[] b, final int off, final int len);
+
+    /**
+     * Write the bytes to byte array.
+     * @param b the bytes to write
+     * @param off The start offset
+     * @param len The number of bytes to write
+     */
+    protected void writeImpl(final byte[] b, final int off, final int len) {
+        final int newcount = count + len;
+        int remaining = len;
+        int inBufferPos = count - filledBufferSum;
+        while (remaining > 0) {
+            final int part = Math.min(remaining, currentBuffer.length - inBufferPos);
+            System.arraycopy(b, off + len - remaining, currentBuffer, inBufferPos, part);
+            remaining -= part;
+            if (remaining > 0) {
+                needNewBuffer(newcount);
+                inBufferPos = 0;
+            }
+        }
+        count = newcount;
+    }
+
+    /**
+     * Write a byte to byte array.
+     * @param b the byte to write
+     */
+    @Override
+    public abstract void write(final int b);
+
+    /**
+     * Write a byte to byte array.
+     * @param b the byte to write
+     */
+    protected void writeImpl(final int b) {
+        int inBufferPos = count - filledBufferSum;
+        if (inBufferPos == currentBuffer.length) {
+            needNewBuffer(count + 1);
+            inBufferPos = 0;
+        }
+        currentBuffer[inBufferPos] = (byte) b;
+        count++;
+    }
+
+
+    /**
+     * Writes the entire contents of the specified input stream to this
+     * byte stream. Bytes from the input stream are read directly into the
+     * internal buffers of this streams.
+     *
+     * @param in the input stream to read from
+     * @return total number of bytes read from the input stream
+     *         (and written to this stream)
+     * @throws IOException if an I/O error occurs while reading the input stream
+     * @since 1.4
+     */
+    public abstract int write(final InputStream in) throws IOException;
+
+    /**
+     * Writes the entire contents of the specified input stream to this
+     * byte stream. Bytes from the input stream are read directly into the
+     * internal buffers of this streams.
+     *
+     * @param in the input stream to read from
+     * @return total number of bytes read from the input stream
+     *         (and written to this stream)
+     * @throws IOException if an I/O error occurs while reading the input stream
+     * @since 2.7
+     */
+    protected int writeImpl(final InputStream in) throws IOException {
+        int readCount = 0;
+        int inBufferPos = count - filledBufferSum;
+        int n = in.read(currentBuffer, inBufferPos, currentBuffer.length - inBufferPos);
+        while (n != EOF) {
+            readCount += n;
+            inBufferPos += n;
+            count += n;
+            if (inBufferPos == currentBuffer.length) {
+                needNewBuffer(currentBuffer.length);
+                inBufferPos = 0;
+            }
+            n = in.read(currentBuffer, inBufferPos, currentBuffer.length - inBufferPos);
+        }
+        return readCount;
+    }
+
+    /**
+     * Return the current size of the byte array.
+     * @return the current size of the byte array
+     */
+    public abstract int size();
+
+    /**
+     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in
+     * this class can be called after the stream has been closed without
+     * generating an {@code IOException}.
+     *
+     * @throws IOException never (this method should not declare this exception
+     * but it has to now due to backwards compatibility)
+     */
+    @Override
+    public void close() throws IOException {
+        //nop
+    }
+
+    /**
+     * @see java.io.ByteArrayOutputStream#reset()
+     */
+    public abstract void reset();
+
+    /**
+     * @see java.io.ByteArrayOutputStream#reset()
+     */
+    protected void resetImpl() {
+        count = 0;
+        filledBufferSum = 0;
+        currentBufferIndex = 0;
+        if (reuseBuffers) {
+            currentBuffer = buffers.get(currentBufferIndex);
+        } else {
+            //Throw away old buffers
+            currentBuffer = null;
+            final int size = buffers.get(0).length;
+            buffers.clear();
+            needNewBuffer(size);
+            reuseBuffers = true;
+        }
+    }
+
+    /**
+     * Writes the entire contents of this byte stream to the
+     * specified output stream.
+     *
+     * @param out  the output stream to write to
+     * @throws IOException if an I/O error occurs, such as if the stream is closed
+     * @see java.io.ByteArrayOutputStream#writeTo(OutputStream)
+     */
+    public abstract void writeTo(final OutputStream out) throws IOException;
+
+    /**
+     * Writes the entire contents of this byte stream to the
+     * specified output stream.
+     *
+     * @param out  the output stream to write to
+     * @throws IOException if an I/O error occurs, such as if the stream is closed
+     * @see java.io.ByteArrayOutputStream#writeTo(OutputStream)
+     */
+    protected void writeToImpl(final OutputStream out) throws IOException {
+        int remaining = count;
+        for (final byte[] buf : buffers) {
+            final int c = Math.min(buf.length, remaining);
+            out.write(buf, 0, c);
+            remaining -= c;
+            if (remaining == 0) {
+                break;
+            }
+        }
+    }
+
+    /**
+     * Gets the current contents of this byte stream as a Input Stream. The
+     * returned stream is backed by buffers of <code>this</code> stream,
+     * avoiding memory allocation and copy, thus saving space and time.<br>
+     *
+     * @return the current contents of this output stream.
+     * @see java.io.ByteArrayOutputStream#toByteArray()
+     * @see #reset()
+     * @since 2.5
+     */
+    public abstract InputStream toInputStream();
+
+    /**
+     * Gets the current contents of this byte stream as a Input Stream. The
+     * returned stream is backed by buffers of <code>this</code> stream,
+     * avoiding memory allocation and copy, thus saving space and time.<br>
+     *
+     * @return the current contents of this output stream.
+     * @see java.io.ByteArrayOutputStream#toByteArray()
+     * @see #reset()
+     * @since 2.7
+     */
+    protected InputStream toInputStreamImpl() {
+        int remaining = count;
+        if (remaining == 0) {
+            return new ClosedInputStream();
+        }
+        final List<ByteArrayInputStream> list = new ArrayList<>(buffers.size());
+        for (final byte[] buf : buffers) {
+            final int c = Math.min(buf.length, remaining);
+            list.add(new ByteArrayInputStream(buf, 0, c));
+            remaining -= c;
+            if (remaining == 0) {
+                break;
+            }
+        }
+        reuseBuffers = false;
+        return new SequenceInputStream(Collections.enumeration(list));
+    }
+
+    /**
+     * Gets the current contents of this byte stream as a byte array.
+     * The result is independent of this stream.
+     *
+     * @return the current contents of this output stream, as a byte array
+     * @see java.io.ByteArrayOutputStream#toByteArray()
+     */
+    public abstract byte[] toByteArray();
+
+    /**
+     * Gets the current contents of this byte stream as a byte array.
+     * The result is independent of this stream.
+     *
+     * @return the current contents of this output stream, as a byte array
+     * @see java.io.ByteArrayOutputStream#toByteArray()
+     */
+    protected byte[] toByteArrayImpl() {
+        int remaining = count;
+        if (remaining == 0) {
+            return EMPTY_BYTE_ARRAY;
+        }
+        final byte newbuf[] = new byte[remaining];
+        int pos = 0;
+        for (final byte[] buf : buffers) {
+            final int c = Math.min(buf.length, remaining);
+            System.arraycopy(buf, 0, newbuf, pos, c);
+            pos += c;
+            remaining -= c;
+            if (remaining == 0) {
+                break;
+            }
+        }
+        return newbuf;
+    }
+
+    /**
+     * Gets the current contents of this byte stream as a string
+     * using the platform default charset.
+     * @return the contents of the byte array as a String
+     * @see java.io.ByteArrayOutputStream#toString()
+     * @deprecated 2.5 use {@link #toString(String)} instead","[{'comment': 'I do not think it makes sense to deprecate `toString()` since it is such a basic JRE method that will never go away.', 'commenter': 'garydgregory'}, {'comment': 'This was how it was previously in `ByteArrayOutputStream`. I just left it as I found it!', 'commenter': 'adamretter'}]"
108,src/main/java/org/apache/commons/io/output/UnsynchronizedByteArrayOutputStream.java,"@@ -0,0 +1,161 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * This class implements a version of {@link AbstractByteArrayOutputStream}","[{'comment': '""This class implements..."" -> ""Implements...""', 'commenter': 'garydgregory'}]"
109,src/main/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStream.java,"@@ -0,0 +1,177 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.io.InputStream;
+import java.util.Objects;
+
+import static java.lang.Math.min;
+
+/**
+ * This is an alternative to {@link java.io.ByteArrayInputStream}
+ * which removes the synchronization overhead for non-concurrent
+ * access; as such this class is not thread-safe.
+ *
+ * @since 2.7
+ */
+//@NotThreadSafe
+public class UnsynchronizedByteArrayInputStream extends InputStream {
+
+    public static final int END_OF_STREAM = -1;
+
+    /**
+     * The underlying data buffer.
+     */
+    private final byte[] data;
+
+    /**
+     * End Of Data.
+     *
+     * Similar to data.length,
+     * i.e. the last readable offset + 1.
+     */
+    private final int eod;
+
+    /**
+     * Current offset in the data buffer.
+     */
+    private int offset;
+
+    /**
+     * The current mark (if any).
+     */
+    private int markedOffset;
+
+    /**
+     * @param data the buffer","[{'comment': 'You are missing a comment here.', 'commenter': 'garydgregory'}]"
109,src/main/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStream.java,"@@ -0,0 +1,177 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.io.InputStream;
+import java.util.Objects;
+
+import static java.lang.Math.min;
+
+/**
+ * This is an alternative to {@link java.io.ByteArrayInputStream}
+ * which removes the synchronization overhead for non-concurrent
+ * access; as such this class is not thread-safe.
+ *
+ * @since 2.7
+ */
+//@NotThreadSafe
+public class UnsynchronizedByteArrayInputStream extends InputStream {
+
+    public static final int END_OF_STREAM = -1;
+
+    /**
+     * The underlying data buffer.
+     */
+    private final byte[] data;
+
+    /**
+     * End Of Data.
+     *
+     * Similar to data.length,
+     * i.e. the last readable offset + 1.
+     */
+    private final int eod;
+
+    /**
+     * Current offset in the data buffer.
+     */
+    private int offset;
+
+    /**
+     * The current mark (if any).
+     */
+    private int markedOffset;
+
+    /**
+     * @param data the buffer
+     */
+    public UnsynchronizedByteArrayInputStream(final byte[] data) {
+        Objects.requireNonNull(data);
+        this.data = data;
+        this.offset = 0;
+        this.eod = data.length;
+        this.markedOffset = this.offset;
+    }
+
+    /**
+     * @param data the buffer","[{'comment': 'You are missing a comment here.', 'commenter': 'garydgregory'}]"
109,src/main/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStream.java,"@@ -0,0 +1,177 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.io.InputStream;
+import java.util.Objects;
+
+import static java.lang.Math.min;
+
+/**
+ * This is an alternative to {@link java.io.ByteArrayInputStream}
+ * which removes the synchronization overhead for non-concurrent
+ * access; as such this class is not thread-safe.
+ *
+ * @since 2.7
+ */
+//@NotThreadSafe
+public class UnsynchronizedByteArrayInputStream extends InputStream {
+
+    public static final int END_OF_STREAM = -1;
+
+    /**
+     * The underlying data buffer.
+     */
+    private final byte[] data;
+
+    /**
+     * End Of Data.
+     *
+     * Similar to data.length,
+     * i.e. the last readable offset + 1.
+     */
+    private final int eod;
+
+    /**
+     * Current offset in the data buffer.
+     */
+    private int offset;
+
+    /**
+     * The current mark (if any).
+     */
+    private int markedOffset;
+
+    /**
+     * @param data the buffer
+     */
+    public UnsynchronizedByteArrayInputStream(final byte[] data) {
+        Objects.requireNonNull(data);
+        this.data = data;
+        this.offset = 0;
+        this.eod = data.length;
+        this.markedOffset = this.offset;
+    }
+
+    /**
+     * @param data the buffer
+     * @param offset the offset into the buffer
+     *
+     * @throws IllegalArgumentException if the offset is less than zero
+     */
+    public UnsynchronizedByteArrayInputStream(final byte[] data, final int offset) {
+        Objects.requireNonNull(data);
+        if (offset < 0) {
+            throw new IllegalArgumentException(""offset cannot be negative"");
+        }
+        this.data = data;
+        this.offset = min(offset, data.length > 0 ? data.length: offset);
+        this.eod = data.length;
+        this.markedOffset = this.offset;
+    }
+
+
+    /**
+     * @param data the buffer","[{'comment': 'You are missing a comment here.', 'commenter': 'garydgregory'}]"
109,src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java,"@@ -0,0 +1,341 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import org.junit.jupiter.api.Test;
+
+import static org.apache.commons.io.input.UnsynchronizedByteArrayInputStream.END_OF_STREAM;
+import static org.junit.jupiter.api.Assertions.*;","[{'comment': 'Please avoid * imports.', 'commenter': 'garydgregory'}]"
109,src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java,"@@ -0,0 +1,341 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import org.junit.jupiter.api.Test;
+
+import static org.apache.commons.io.input.UnsynchronizedByteArrayInputStream.END_OF_STREAM;
+import static org.junit.jupiter.api.Assertions.*;
+
+/**
+ * Basic unit tests for the alternative ByteArrayInputStream implementation.
+ */
+public class UnsynchronizedByteArrayInputStreamTest {","[{'comment': 'For new files, I like to keep method in alphabetical order, it makes it easier to find stuff.', 'commenter': 'garydgregory'}]"
112,src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java,"@@ -78,6 +82,26 @@ protected void _testRawNoBomInvalid(final String encoding) throws Exception {
         }
     }
 
+    @Test
+    protected void testNullFileInput() throws IOException {
+        assertThrows(NullPointerException.class, ()-> new XmlStreamReader((File)null));","[{'comment': 'Hi @ottobackwards \r\nThe spacing in ""() ->"" is inconsistent, it should be ""() ->"" everywhere.\r\n', 'commenter': 'garydgregory'}]"
112,src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java,"@@ -78,6 +82,26 @@ protected void _testRawNoBomInvalid(final String encoding) throws Exception {
         }
     }
 
+    @Test
+    protected void testNullFileInput() throws IOException {
+        assertThrows(NullPointerException.class, () -> new XmlStreamReader((File)null));","[{'comment': 'Has commons-io decided to move  Java 8 minimum? Maven still requires Java 7 and could not upgrade to this.', 'commenter': 'elharo'}, {'comment': '```xml\r\n  <properties>\r\n    <maven.compiler.source>1.8</maven.compiler.source>\r\n    <maven.compiler.target>1.8</maven.compiler.target>\r\n    <commons.componentid>io</commons.componentid>\r\n    <commons.module.name>org.apache.commons.io</commons.module.name>\r\n    <commons.rc.version>RC1</commons.rc.version>\r\n    <commons.bc.version>2.6</commons.bc.version>\r\n    <commons.release.version>2.7</commons.release.version>\r\n    <commons.release.desc>(requires Java 8)</commons.release.desc>\r\n```', 'commenter': 'ottobackwards'}]"
115,src/main/java/org/apache/commons/io/file/Counters.java,"@@ -92,8 +92,8 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return String.format(""%,d files, %,d directories, %,d bytes"", Long.valueOf(fileCounter.get()),
-                    Long.valueOf(directoryCounter.get()), Long.valueOf(byteCounter.get()));
+            return String.format(""%,d files, %,d directories, %,d bytes"", fileCounter.get(),
+                    directoryCounter.get(), byteCounter.get());","[{'comment': ""Same comment as in your other PR. Let's leave boxing and unboxing as obvious since we are in a low level library and I prefer to see where this happens so we can think about consequences of creating objects.\r\n"", 'commenter': 'garydgregory'}, {'comment': 'OK, will not happen next time :-)', 'commenter': 'XenoAmess'}]"
115,src/main/java/org/apache/commons/io/file/Counters.java,"@@ -135,7 +135,7 @@ public BigInteger getBigInteger() {
 
         @Override
         public Long getLong() {
-            return Long.valueOf(value.longValueExact());
+            return value.longValueExact();","[{'comment': 'See other comment.', 'commenter': 'garydgregory'}, {'comment': 'done.', 'commenter': 'XenoAmess'}]"
115,src/main/java/org/apache/commons/io/file/Counters.java,"@@ -245,7 +245,7 @@ public BigInteger getBigInteger() {
 
         @Override
         public Long getLong() {
-            return Long.valueOf(value);
+            return value;","[{'comment': 'See other comment.', 'commenter': 'garydgregory'}, {'comment': 'done.', 'commenter': 'XenoAmess'}]"
115,src/test/java/org/apache/commons/io/filefilter/FileFilterTestCase.java,"@@ -1406,7 +1406,7 @@ public void testFilterListNullParameters() {
 
         final IOFileFilter filter = FileFilterUtils.trueFileFilter();
         try {
-            FileFilterUtils.filterList(filter, Arrays.asList((File) null));
+            FileFilterUtils.filterList(filter, Collections.singletonList((File) null));","[{'comment': 'It is worth testing both kinds?', 'commenter': 'garydgregory'}, {'comment': '@garydgregory it is only used as a Iterable there thus I think it has no actual difference IMO, exluding running speed.', 'commenter': 'XenoAmess'}]"
117,src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java,"@@ -66,6 +67,10 @@ public void testUnsupportedEncodingBig5() throws URISyntaxException {
                 () -> new ReversedLinesFileReader(testFileEncodingBig5, IOUtils.DEFAULT_BUFFER_SIZE, ""Big5"").close());
     }
 
-
+    @Test
+    public void testNullEncoding() throws IOException, URISyntaxException {
+        new ReversedLinesFileReader(new File(this.getClass().getResource(""/test-file-empty.bin"").toURI()),
+                                    (Charset) null);
+    }","[{'comment': 'Hi @mernst,\r\n\r\nThank you for your update to this PR.\r\n\r\nThe new unit test indeed tests that the ctor does not blow on a null Charset but it does not test that the default Charset kicks in.\r\n\r\nAnother update would be great.\r\n', 'commenter': 'garydgregory'}, {'comment': ""@garydgregory I agree that would be a useful test, even though it is not directly related to this bug fix.\r\n\r\nI've made my best guess at how to test for the default Charset in a system-independent way.\r\n\r\nI'm not sure whether this is what you had in mind.  If not, could point me at documentation about how Commons IO prefers to test that the default Charset is being used?\r\n\r\nThanks."", 'commenter': 'mernst'}, {'comment': ""Hi @mernst,\r\n \r\nA better way to test would be to write to the temp file with `Charset.defaultCharset()` and still read with a `null` `Charset`. \r\n\r\nFrom a black-box perspective, writing with a `null` `Charset` does not prove anything since you're relying on the fact that another API does the right thing with a `null` `Charset`. This would really match the test with expectations.\r\n"", 'commenter': 'garydgregory'}, {'comment': 'I agree these tests are useful to improve code coverage.  But they are not directly related to the change, and previous changes to this code were permitted without adding these missing tests.  Could we create a new pull request or issue to improve the coverage of the test suite, to avoid blocking this pull request?', 'commenter': 'mernst'}]"
117,src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java,"@@ -66,6 +74,14 @@ public void testUnsupportedEncodingBig5() throws URISyntaxException {
                 () -> new ReversedLinesFileReader(testFileEncodingBig5, IOUtils.DEFAULT_BUFFER_SIZE, ""Big5"").close());
     }
 
-
+    @Test
+    public void testNullEncoding() throws IOException, URISyntaxException {
+        final File file = new File(temporaryFolder, ""write.txt"");
+        final String text = ""Hello /u1234"";","[{'comment': 'What is `/u1234` supposed to be?', 'commenter': 'garydgregory'}, {'comment': ""Ping. Why is the weird Unicode escape needed here? If it is needed, please add a comment, otherwise, we don't need it right?"", 'commenter': 'garydgregory'}]"
120,src/main/java/org/apache/commons/io/Charsets.java,"@@ -59,6 +59,17 @@
     // correctly and without delay on all Java platforms.
     //
 
+    private static final TreeMap<String, Charset> REQUIRED_CHARSETS = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);","[{'comment': 'Use the interface name', 'commenter': 'michael-o'}]"
120,src/main/java/org/apache/commons/io/Charsets.java,"@@ -72,15 +83,7 @@
      * @since 2.5
      */
     public static SortedMap<String, Charset> requiredCharsets() {","[{'comment': 'Why sorted map? TreeMap is sorted already?!', 'commenter': 'michael-o'}]"
120,src/main/java/org/apache/commons/io/Charsets.java,"@@ -71,16 +83,8 @@
      * @see Charset#availableCharsets()
      * @since 2.5
      */
-    public static SortedMap<String, Charset> requiredCharsets() {
-        // maybe cache?
-        final TreeMap<String, Charset> m = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
-        m.put(StandardCharsets.ISO_8859_1.name(), StandardCharsets.ISO_8859_1);
-        m.put(StandardCharsets.US_ASCII.name(), StandardCharsets.US_ASCII);
-        m.put(StandardCharsets.UTF_16.name(), StandardCharsets.UTF_16);
-        m.put(StandardCharsets.UTF_16BE.name(), StandardCharsets.UTF_16BE);
-        m.put(StandardCharsets.UTF_16LE.name(), StandardCharsets.UTF_16LE);
-        m.put(StandardCharsets.UTF_8.name(), StandardCharsets.UTF_8);
-        return Collections.unmodifiableSortedMap(m);
+    public static Map<String, Charset> requiredCharsets() {
+        return Collections.unmodifiableSortedMap(REQUIRED_CHARSETS);","[{'comment': 'Is there a reason why `REQUIRED_CHARSETS` is modifiable but not the value returned by this method?', 'commenter': 'garydgregory'}, {'comment': ""Oh, I forgot. I've changed it now."", 'commenter': 'JeromeWolff'}]"
120,src/main/java/org/apache/commons/io/Charsets.java,"@@ -71,16 +85,8 @@
      * @see Charset#availableCharsets()
      * @since 2.5
      */
-    public static SortedMap<String, Charset> requiredCharsets() {
-        // maybe cache?
-        final TreeMap<String, Charset> m = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
-        m.put(StandardCharsets.ISO_8859_1.name(), StandardCharsets.ISO_8859_1);
-        m.put(StandardCharsets.US_ASCII.name(), StandardCharsets.US_ASCII);
-        m.put(StandardCharsets.UTF_16.name(), StandardCharsets.UTF_16);
-        m.put(StandardCharsets.UTF_16BE.name(), StandardCharsets.UTF_16BE);
-        m.put(StandardCharsets.UTF_16LE.name(), StandardCharsets.UTF_16LE);
-        m.put(StandardCharsets.UTF_8.name(), StandardCharsets.UTF_8);
-        return Collections.unmodifiableSortedMap(m);
+    public static Map<String, Charset> requiredCharsets() {","[{'comment': '@LinuxClient \r\nYou cannot change the return type in this manner as it breaks binary compatibility,', 'commenter': 'garydgregory'}, {'comment': 'Yeah, I saw it on the Travis CI Log. But it was mentioned by @michael-o above.', 'commenter': 'JeromeWolff'}]"
124,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1690,6 +1810,119 @@ public static boolean isFileOlder(final File file, final long timeMillis) {
         return file.lastModified() < timeMillis;
     }
 
+    /**
+     * Tests if the specified <code>File</code> is older than the specified
+     * <code>Instant</code>.
+     *
+     * @param file    the <code>File</code> of which the modification date
+     *                must be compared, must not be {@code null}
+     * @param instant the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * before the given <code>Instant</code>.
+     * @throws IllegalArgumentException if the file or instant is {@code null}
+     */
+    public static boolean isFileOlder(final File file, final Instant instant) {
+        if (instant == null) {","[{'comment': 'Null checks should use one of:\r\n\r\n- java.util.Objects.requireNonNull(T, String)\r\n- java.util.Objects.requireNonNull(T, Supplier<String>)', 'commenter': 'garydgregory'}, {'comment': 'Maybe the other methods could be updated to use `Objects.requireNonNull` as well in a separate PR?', 'commenter': 'Isira-Seneviratne'}]"
124,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1624,6 +1631,119 @@ public static boolean isFileNewer(final File file, final long timeMillis) {
         return file.lastModified() > timeMillis;
     }
 
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * <code>Instant</code>.
+     *
+     * @param file    the <code>File</code> of which the modification date
+     *                must be compared, must not be {@code null}
+     * @param instant the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * after the given <code>Instant</code>.
+     * @throws IllegalArgumentException if the file or instant is {@code null}
+     */","[{'comment': 'New public APIs need `@since` tags.', 'commenter': 'garydgregory'}]"
124,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -83,6 +88,8 @@
  * </p>
  */
 public class FileUtils {
+    private static final String NO_SPECIFIED_LOCALDATE = ""No specified localDate"";","[{'comment': 'No need for these, just use the parameter name as the message to one of:\r\n\r\n- java.util.Objects.requireNonNull(T, String)\r\n- java.util.Objects.requireNonNull(T, Supplier<String>)\r\n\r\n', 'commenter': 'garydgregory'}]"
124,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1624,6 +1631,119 @@ public static boolean isFileNewer(final File file, final long timeMillis) {
         return file.lastModified() > timeMillis;
     }
 
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * <code>Instant</code>.
+     *
+     * @param file    the <code>File</code> of which the modification date
+     *                must be compared, must not be {@code null}
+     * @param instant the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * after the given <code>Instant</code>.
+     * @throws IllegalArgumentException if the file or instant is {@code null}
+     */
+    public static boolean isFileNewer(final File file, final Instant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException(""No specified instant"");
+        }
+        return isFileNewer(file, instant.toEpochMilli());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * <code>ZonedDateTime</code>.
+     *
+     * @param file          the <code>File</code> of which the modification date
+     *                      must be compared, must not be {@code null}
+     * @param zonedDateTime the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * after the given <code>ZonedDateTime</code>.
+     * @throws IllegalArgumentException if the file or zoned date time is {@code null}
+     */
+    public static boolean isFileNewer(final File file, final ZonedDateTime zonedDateTime) {","[{'comment': 'Why is this API typed to a `ZonedDateTime` instead of `ChronoZonedDateTime`?', 'commenter': 'garydgregory'}, {'comment': 'The Javadoc for `ChronoZonedDateTime` includes this statement: ""Most applications should declare method signatures, fields and variables as `ZonedDateTime`, not this interface.""', 'commenter': 'Isira-Seneviratne'}]"
124,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1624,6 +1631,119 @@ public static boolean isFileNewer(final File file, final long timeMillis) {
         return file.lastModified() > timeMillis;
     }
 
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * <code>Instant</code>.
+     *
+     * @param file    the <code>File</code> of which the modification date
+     *                must be compared, must not be {@code null}
+     * @param instant the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * after the given <code>Instant</code>.
+     * @throws IllegalArgumentException if the file or instant is {@code null}
+     */
+    public static boolean isFileNewer(final File file, final Instant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException(""No specified instant"");
+        }
+        return isFileNewer(file, instant.toEpochMilli());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * <code>ZonedDateTime</code>.
+     *
+     * @param file          the <code>File</code> of which the modification date
+     *                      must be compared, must not be {@code null}
+     * @param zonedDateTime the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * after the given <code>ZonedDateTime</code>.
+     * @throws IllegalArgumentException if the file or zoned date time is {@code null}
+     */
+    public static boolean isFileNewer(final File file, final ZonedDateTime zonedDateTime) {
+        if (zonedDateTime == null) {
+            throw new IllegalArgumentException(""No specified zonedDateTime"");
+        }
+        return isFileNewer(file, zonedDateTime.toInstant());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * <code>LocalDateTime</code> at the system-default time zone.
+     *
+     * @param file          the <code>File</code> of which the modification date
+     *                      must be compared, must not be {@code null}
+     * @param localDateTime the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * after the given <code>LocalDateTime</code> at the system-default time zone.
+     * @throws IllegalArgumentException if the file or local date time is {@code null}
+     */
+    public static boolean isFileNewer(final File file, final LocalDateTime localDateTime) {
+        return isFileNewer(file, localDateTime, ZoneId.systemDefault());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * <code>LocalDateTime</code> at the specified <code>ZoneId</code>.
+     *
+     * @param file          the <code>File</code> of which the modification date
+     *                      must be compared, must not be {@code null}
+     * @param localDateTime the date reference, must not be {@code null}
+     * @param zoneId        the time zone, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * after the given <code>LocalDateTime</code> at the given <code>ZoneId</code>.
+     * @throws IllegalArgumentException if the file, local date time or zone ID is {@code null}
+     */
+    public static boolean isFileNewer(final File file, final LocalDateTime localDateTime, final ZoneId zoneId) {","[{'comment': 'Why is this API typed to a `LocalDateTime` instead of `ChronoLocalDateTime`?', 'commenter': 'garydgregory'}, {'comment': 'The Javadoc for `ChronoLocalDateTime` includes this statement: ""Most applications should declare method signatures, fields and variables as `LocalDateTime`, not this interface.""', 'commenter': 'Isira-Seneviratne'}, {'comment': 'What happens if I want to use a `JapaneseDate`, `HijrahDate`, `MinguoDate`, or `ThaiBuddhistDate`?', 'commenter': 'garydgregory'}, {'comment': ""Ah, I see what you mean. I'll update the method to use `ChronoLocalDateTime` :)"", 'commenter': 'Isira-Seneviratne'}, {'comment': ""Actually, those classes implement the `ChronoLocalDate` interface, so I'll use that instead."", 'commenter': 'Isira-Seneviratne'}]"
124,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1624,6 +1631,119 @@ public static boolean isFileNewer(final File file, final long timeMillis) {
         return file.lastModified() > timeMillis;
     }
 
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * <code>Instant</code>.
+     *
+     * @param file    the <code>File</code> of which the modification date
+     *                must be compared, must not be {@code null}
+     * @param instant the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * after the given <code>Instant</code>.
+     * @throws IllegalArgumentException if the file or instant is {@code null}
+     */
+    public static boolean isFileNewer(final File file, final Instant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException(""No specified instant"");
+        }
+        return isFileNewer(file, instant.toEpochMilli());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * <code>ZonedDateTime</code>.
+     *
+     * @param file          the <code>File</code> of which the modification date
+     *                      must be compared, must not be {@code null}
+     * @param zonedDateTime the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * after the given <code>ZonedDateTime</code>.
+     * @throws IllegalArgumentException if the file or zoned date time is {@code null}
+     */
+    public static boolean isFileNewer(final File file, final ZonedDateTime zonedDateTime) {
+        if (zonedDateTime == null) {
+            throw new IllegalArgumentException(""No specified zonedDateTime"");
+        }
+        return isFileNewer(file, zonedDateTime.toInstant());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * <code>LocalDateTime</code> at the system-default time zone.
+     *
+     * @param file          the <code>File</code> of which the modification date
+     *                      must be compared, must not be {@code null}
+     * @param localDateTime the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * after the given <code>LocalDateTime</code> at the system-default time zone.
+     * @throws IllegalArgumentException if the file or local date time is {@code null}
+     */
+    public static boolean isFileNewer(final File file, final LocalDateTime localDateTime) {
+        return isFileNewer(file, localDateTime, ZoneId.systemDefault());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * <code>LocalDateTime</code> at the specified <code>ZoneId</code>.
+     *
+     * @param file          the <code>File</code> of which the modification date
+     *                      must be compared, must not be {@code null}
+     * @param localDateTime the date reference, must not be {@code null}
+     * @param zoneId        the time zone, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * after the given <code>LocalDateTime</code> at the given <code>ZoneId</code>.
+     * @throws IllegalArgumentException if the file, local date time or zone ID is {@code null}
+     */
+    public static boolean isFileNewer(final File file, final LocalDateTime localDateTime, final ZoneId zoneId) {
+        if (localDateTime == null) {
+            throw new IllegalArgumentException(""No specified localDateTime"");
+        }
+        if (zoneId == null) {
+            throw new IllegalArgumentException(NO_SPECIFIED_ZONEID);
+        }
+        return isFileNewer(file, localDateTime.atZone(zoneId));
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * <code>LocalDate</code> at the system-default time zone.
+     *
+     * @param file      the <code>File</code> of which the modification date
+     *                  must be compared, must not be {@code null}
+     * @param localDate the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * after the given <code>LocalDate</code> at the system-default time zone.
+     * @throws IllegalArgumentException if the file or local date is {@code null}
+     */
+    public static boolean isFileNewer(final File file, final LocalDate localDate) {
+        if (localDate == null) {
+            throw new IllegalArgumentException(NO_SPECIFIED_LOCALDATE);
+        }
+        return isFileNewer(file, localDate.atStartOfDay());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is newer than the specified
+     * <code>LocalDate</code> at the specified <code>ZoneId</code>.","[{'comment': 'Use `{@code Foo}` instead of `<code>Foo</code>` for these kinds of simple styles.', 'commenter': 'garydgregory'}, {'comment': 'Okay.', 'commenter': 'Isira-Seneviratne'}]"
124,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1690,6 +1810,119 @@ public static boolean isFileOlder(final File file, final long timeMillis) {
         return file.lastModified() < timeMillis;
     }
 
+    /**
+     * Tests if the specified <code>File</code> is older than the specified
+     * <code>Instant</code>.
+     *
+     * @param file    the <code>File</code> of which the modification date
+     *                must be compared, must not be {@code null}
+     * @param instant the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * before the given <code>Instant</code>.
+     * @throws IllegalArgumentException if the file or instant is {@code null}
+     */
+    public static boolean isFileOlder(final File file, final Instant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException(""No specified instant"");
+        }
+        return isFileOlder(file, instant.toEpochMilli());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is older than the specified
+     * <code>ZonedDateTime</code>.
+     *
+     * @param file          the <code>File</code> of which the modification date
+     *                      must be compared, must not be {@code null}
+     * @param zonedDateTime the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * before the given <code>ZonedDateTime</code>.
+     * @throws IllegalArgumentException if the file or zoned date time is {@code null}
+     */
+    public static boolean isFileOlder(final File file, final ZonedDateTime zonedDateTime) {
+        if (zonedDateTime == null) {
+            throw new IllegalArgumentException(""No specified zonedDateTime"");
+        }
+        return isFileOlder(file, zonedDateTime.toInstant());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is older than the specified
+     * <code>LocalDateTime</code> at the system-default time zone.
+     *
+     * @param file          the <code>File</code> of which the modification date
+     *                      must be compared, must not be {@code null}
+     * @param localDateTime the date reference, must not be {@code null}
+     * @return true if the <code>File</code> exists and has been modified
+     * before the given <code>LocalDateTime</code> at the system-default time zone.
+     * @throws IllegalArgumentException if the file or local date time is {@code null}
+     */
+    public static boolean isFileOlder(final File file, final LocalDateTime localDateTime) {
+        return isFileOlder(file, localDateTime, ZoneId.systemDefault());
+    }
+
+    /**
+     * Tests if the specified <code>File</code> is older than the specified
+     * <code>LocalDateTime</code> at the specified <code>ZoneId</code>.
+     *
+     * @param file          the <code>File</code> of which the modification date
+     *                      must be compared, must not be {@code null}
+     * @param localDateTime the date reference, must not be {@code null}
+     * @param zoneId        the time zone, must not be {@code null}","[{'comment': 'IMO, either:\r\n- Say nothing instead of ""must not be {@code null}"" since this information duplicates @throws, or\r\n- Be specific: ""the time zone,  or throws {@code NullPointerException} if {@code null}.""', 'commenter': 'garydgregory'}, {'comment': 'I was sticking to the style of the existing methods.\r\n\r\nMaybe those methods could have the same modifications applied as well?', 'commenter': 'Isira-Seneviratne'}]"
124,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1603,93 +1598,272 @@ public static boolean isFileNewer(final File file, final File reference) {
     }
 
     /**
-     * Tests if the specified <code>File</code> is newer than the specified
-     * time reference.
+     * Tests if the specified {@code File} is newer than the specified time reference.
      *
-     * @param file       the <code>File</code> of which the modification date must
-     *                   be compared, must not be {@code null}
+     * @param file       the {@code File} of which the modification date must be compared
      * @param timeMillis the time reference measured in milliseconds since the
      *                   epoch (00:00:00 GMT, January 1, 1970)
-     * @return true if the <code>File</code> exists and has been modified after
-     * the given time reference.
-     * @throws IllegalArgumentException if the file is {@code null}
+     * @return true if the {@code File} exists and has been modified after the given time reference.
+     * @throws NullPointerException if the file is {@code null}
      */
     public static boolean isFileNewer(final File file, final long timeMillis) {
-        if (file == null) {
-            throw new IllegalArgumentException(""No specified file"");
-        }
+        Objects.requireNonNull(file, ""file"");
         if (!file.exists()) {
             return false;
         }
         return file.lastModified() > timeMillis;
     }
 
     /**
-     * Tests if the specified <code>File</code> is older than the specified
-     * <code>Date</code>.
+     * Tests if the specified {@code File} is newer than the specified {@code Instant}.
+     *
+     * @param file    the {@code File} of which the modification date must be compared
+     * @param instant the date reference
+     * @return true if the {@code File} exists and has been modified after the given {@code Instant}.
+     * @throws NullPointerException if the file or instant is {@code null}
+     *
+     * @since 2.8
+     */
+    public static boolean isFileNewer(final File file, final Instant instant) {
+        Objects.requireNonNull(instant, ""instant"");
+        return isFileNewer(file, instant.toEpochMilli());
+    }
+
+    /**
+     * Tests if the specified {@code File} is newer than the specified {@code ChronoZonedDateTime}.
+     *
+     * @param file                the {@code File} of which the modification date must be compared
+     * @param chronoZonedDateTime the date reference
+     * @return true if the {@code File} exists and has been modified after the given
+     * {@code ChronoZonedDateTime}.
+     * @throws NullPointerException if the file or zoned date time is {@code null}
+     *
+     * @since 2.8
+     */
+    public static boolean isFileNewer(final File file, final ChronoZonedDateTime<? extends ChronoLocalDate> chronoZonedDateTime) {","[{'comment': 'You can replace `? extends ChronoLocalDate` with `?` since `ChronoZonedDateTime` is already defined with a generic that extends `ChronoLocalDate`. Same for other APIs I think.', 'commenter': 'garydgregory'}]"
124,src/test/java/org/apache/commons/io/FileUtilsTestCase.java,"@@ -1015,6 +1021,12 @@ public void testIsFileNewerOlder() throws Exception {
 
         final Date date = new Date();","[{'comment': ""In general, you want to use hard coded dates in tests in order to avoid tests failing on the two times a year the build runs in a locale that happens to perform a daylight-saving-time switch. Yes, I've actually seen this happen (at work.)"", 'commenter': 'garydgregory'}, {'comment': ""> In general, you want to use hard coded dates in tests\r\n\r\nThe files being tested seem to be created at the moment the test is run, so how should it be handled?\r\n\r\n> Yes, I've actually seen this happen (at work.)\r\n\r\nWow."", 'commenter': 'Isira-Seneviratne'}]"
124,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1603,93 +1598,272 @@ public static boolean isFileNewer(final File file, final File reference) {
     }
 
     /**
-     * Tests if the specified <code>File</code> is newer than the specified
-     * time reference.
+     * Tests if the specified {@code File} is newer than the specified time reference.
      *
-     * @param file       the <code>File</code> of which the modification date must
-     *                   be compared, must not be {@code null}
+     * @param file       the {@code File} of which the modification date must be compared
      * @param timeMillis the time reference measured in milliseconds since the
      *                   epoch (00:00:00 GMT, January 1, 1970)
-     * @return true if the <code>File</code> exists and has been modified after
-     * the given time reference.
-     * @throws IllegalArgumentException if the file is {@code null}
+     * @return true if the {@code File} exists and has been modified after the given time reference.
+     * @throws NullPointerException if the file is {@code null}
      */
     public static boolean isFileNewer(final File file, final long timeMillis) {
-        if (file == null) {
-            throw new IllegalArgumentException(""No specified file"");
-        }
+        Objects.requireNonNull(file, ""file"");
         if (!file.exists()) {
             return false;
         }
         return file.lastModified() > timeMillis;
     }
 
     /**
-     * Tests if the specified <code>File</code> is older than the specified
-     * <code>Date</code>.
+     * Tests if the specified {@code File} is newer than the specified {@code Instant}.
+     *
+     * @param file    the {@code File} of which the modification date must be compared
+     * @param instant the date reference
+     * @return true if the {@code File} exists and has been modified after the given {@code Instant}.
+     * @throws NullPointerException if the file or instant is {@code null}
+     *
+     * @since 2.8
+     */
+    public static boolean isFileNewer(final File file, final Instant instant) {","[{'comment': 'Curious here...what do you think happens if the TimeZone of the local datetime of the machine on which the code is running differs from the `TimeZone` embedded in the Instant. I worry that `instant.toEpochMilli();` might return the `Epoch` from the timezone of the instant which could be off by multiples of 30 minutes, and thus could yield differing results depending upon a user error here. Maybe we should convert the instant to the TimeZone of the machine before running `instant.toEpochMilli();`??', 'commenter': 'chtompki'}, {'comment': '@Isira-Seneviratne Would you please reply to @chtompki ?', 'commenter': 'garydgregory'}, {'comment': ""@garydgregory My bad, I'll do so now.\r\n\r\n@chtompki Thanks for the suggestion, I'll update the code."", 'commenter': 'Isira-Seneviratne'}, {'comment': 'This is not true, an Instant never has a timezone. Unfortunately this method now goes on the forbiddenAPI list of Lucene because of this.\r\nInstant is by definition not related to any time zone. toEpochMillies returns a UNIX timestamp.', 'commenter': 'uschindler'}, {'comment': ""The big risk of this forward/backward transformation is now that at the DST changes hour, the calculation is wrong: During DST change the same local date time exists 2 times. When you convert the instant to a local time (after local time went backwards due to DST change) and then you convert the local time back, you're off by an hour.\r\nThe correct way here is to just call toEpochMillies(). PLEASE DO NOT CONVERT FORWARD BACKWARDS from to/local time."", 'commenter': 'uschindler'}, {'comment': 'Because of this the whole methods added here are not useable in international application, except the one taking an explicit ZoneId. The one which would have been correct (the one taking an Instant) was corrupted by this forward/backward transformation.', 'commenter': 'uschindler'}]"
131,src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTestCase.java,"@@ -35,6 +40,11 @@
 
     @TempDir
     public File temporaryFolder;
+    ","[{'comment': 'Delete extra blank line.', 'commenter': 'garydgregory'}]"
131,src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTestCase.java,"@@ -73,6 +83,48 @@ public void copyDirectoryToDirectoryThrowsNullPointerExceptionWithCorrectMessage
         assertExceptionTypeAndMessage(srcDir, destDir, NullPointerException.class, ""destinationDir"");
     }
 
+
+    @Test
+    public void copyFileWrongPermissions() throws IOException {
+        ","[{'comment': 'Delete extra blank lines.', 'commenter': 'garydgregory'}]"
131,src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTestCase.java,"@@ -73,6 +83,48 @@ public void copyDirectoryToDirectoryThrowsNullPointerExceptionWithCorrectMessage
         assertExceptionTypeAndMessage(srcDir, destDir, NullPointerException.class, ""destinationDir"");
     }
 
+
+    @Test
+    public void copyFileWrongPermissions() throws IOException {
+        
+    	 
+        final File destDir = createTemporaryFolderIn(null);
+        final  Path srcFile = Files.createTempFile(""tmp-output"", "".xml"");
+        final Path path = Paths.get(destDir.getAbsolutePath(), ""newFile.xml"");
+
+        try {
+            FileUtils.copyFile(srcFile.toFile(), path.toFile());
+        } catch (IllegalArgumentException iae) {
+        	iae.printStackTrace();","[{'comment': ""Don't catch and log to sys err. Just let the exception percolate up."", 'commenter': 'garydgregory'}]"
131,src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTestCase.java,"@@ -73,6 +83,48 @@ public void copyDirectoryToDirectoryThrowsNullPointerExceptionWithCorrectMessage
         assertExceptionTypeAndMessage(srcDir, destDir, NullPointerException.class, ""destinationDir"");
     }
 
+
+    @Test
+    public void copyFileWrongPermissions() throws IOException {
+        
+    	 
+        final File destDir = createTemporaryFolderIn(null);
+        final  Path srcFile = Files.createTempFile(""tmp-output"", "".xml"");
+        final Path path = Paths.get(destDir.getAbsolutePath(), ""newFile.xml"");
+
+        try {
+            FileUtils.copyFile(srcFile.toFile(), path.toFile());
+        } catch (IllegalArgumentException iae) {
+        	iae.printStackTrace();
+        }
+        
+        assertTrue(Files.getPosixFilePermissions(path).contains(PosixFilePermission.OTHERS_READ), Files.getPosixFilePermissions(path).toString());
+
+    }
+    
+    
+    
+    private File createTemporaryFolderIn(File parentFolder) throws IOException {","[{'comment': 'What is this all about? Since we are testing `FileUtils.copyFile()`, why do we need an extra level of temp folder beyond what the existing `temporaryFolder` provide?', 'commenter': 'garydgregory'}]"
131,src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTestCase.java,"@@ -73,6 +83,48 @@ public void copyDirectoryToDirectoryThrowsNullPointerExceptionWithCorrectMessage
         assertExceptionTypeAndMessage(srcDir, destDir, NullPointerException.class, ""destinationDir"");
     }
 
+
+    @Test
+    public void copyFileWrongPermissions() throws IOException {
+        
+    	 
+        final File destDir = createTemporaryFolderIn(null);
+        final  Path srcFile = Files.createTempFile(""tmp-output"", "".xml"");
+        final Path path = Paths.get(destDir.getAbsolutePath(), ""newFile.xml"");
+
+        try {
+            FileUtils.copyFile(srcFile.toFile(), path.toFile());
+        } catch (IllegalArgumentException iae) {
+        	iae.printStackTrace();
+        }
+        
+        assertTrue(Files.getPosixFilePermissions(path).contains(PosixFilePermission.OTHERS_READ), Files.getPosixFilePermissions(path).toString());","[{'comment': '@cosmoJFH \r\nHere you are testing that a target path has a certain attribute but you are not checking that this attribute was in fact present in the source.\r\n', 'commenter': 'garydgregory'}]"
171,src/main/java/org/apache/commons/io/output/QueueOutputStream.java,"@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import org.apache.commons.io.input.QueueInputStream;
+
+import java.io.InterruptedIOException;
+import java.io.OutputStream;
+import java.io.PipedInputStream;
+import java.io.PipedOutputStream;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import static java.util.Objects.requireNonNull;","[{'comment': ""We don't use static imports for this kind of call in the rest of the main code base. In unit tests, we use statics for JUnit methods."", 'commenter': 'garydgregory'}]"
171,src/main/java/org/apache/commons/io/output/QueueOutputStream.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import org.apache.commons.io.input.QueueInputStream;
+
+import java.io.InterruptedIOException;
+import java.io.OutputStream;
+import java.io.PipedInputStream;
+import java.io.PipedOutputStream;
+import java.util.Objects;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+
+/**
+ * Simple alternative to JDK {@link java.io.PipedOutputStream}; queue input stream provides what's
+ * written in queue output stream.
+ * 
+ * Example usage:
+ * <pre>
+ * QueueOutputStream outputStream = new QueueOutputStream();
+ * QueueInputStream inputStream = outputStream.newPipeInputStream();
+ * 
+ * outputStream.write(""hello world"".getBytes(UTF_8));
+ * inputStream.read();
+ * </pre>
+ * 
+ * Unlike JDK {@link PipedInputStream} and {@link PipedOutputStream}, queue input/output streams may be
+ * used safely in a single thread or multiple threads. Also, unlike JDK classes, no special meaning is
+ * attached to initial or current thread. Instances can be used longer after initial threads exited.
+ * 
+ * Closing a {@code QueueOutputStream} has no effect. The methods in this class can be called after
+ * the stream has been closed without generating an {@code IOException}.
+ * 
+ * @see QueueInputStream
+ * @since 2.9.0
+ */
+public class QueueOutputStream extends OutputStream {
+
+    private final BlockingQueue<Integer> queue;
+
+    /**
+     * Create a {@link QueueOutputStream} with no limit to internal buffer size
+     */
+    public QueueOutputStream() {
+        this(new LinkedBlockingQueue<>());
+    }
+
+    /**
+     * Create a {@link QueueOutputStream} with given buffer
+     * 
+     * @param queue backing queue for the stream
+     */
+    public QueueOutputStream(final BlockingQueue<Integer> queue) {
+        this.queue = Objects.requireNonNull(queue, ""queue is required"");
+    }
+
+    /**
+     * Create an QueueInputStream connected to this. Writes to this output stream will be visible to the input stream.
+     * 
+     * @return QueueInputStream connected to this stream
+     */
+    public QueueInputStream newQueueInputStream() {
+        return new QueueInputStream(queue);
+    }
+
+    /**
+     * Write a single byte.
+     *
+     * @throws InterruptedIOException if the thread is interrupted while writing to the queue.
+     */
+    @Override
+    public void write(final int b) throws InterruptedIOException {
+        try {
+            queue.put(0xFF & b);
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            throw new InterruptedIOException();","[{'comment': 'Is there a reason, the catch block creates a new exception instead of rethrowing the one it caught? ', 'commenter': 'garydgregory'}, {'comment': 'InterruptedException does not extend IOException but InterruptedIOException does.', 'commenter': 'maxxedev'}, {'comment': ""Then we shouldn't we still preserve the original exception by calling `initCause()` on the new exception?"", 'commenter': 'garydgregory'}]"
171,src/main/java/org/apache/commons/io/input/QueueInputStream.java,"@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import org.apache.commons.io.output.QueueOutputStream;
+
+import java.io.InputStream;
+import java.io.PipedInputStream;
+import java.io.PipedOutputStream;
+import java.util.Objects;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+
+/**
+ * Simple alternative to JDK {@link java.io.PipedInputStream}; queue input stream provides what's written in queue output stream.
+ * 
+ * Example usage:
+ * <pre>
+ * QueueInputStream inputStream = new QueueInputStream();
+ * QueueOutputStream outputStream = inputStream.newQueueOutputStream();
+ * 
+ * outputStream.write(""hello world"".getBytes(UTF_8));
+ * inputStream.read();
+ * </pre>
+ * 
+ * Unlike JDK {@link PipedInputStream} and {@link PipedOutputStream}, queue input/output streams may be
+ * used safely in a single thread or multiple threads. Also, unlike JDK classes, no special meaning is
+ * attached to initial or current thread. Instances can be used longer after initial threads exited.
+ * 
+ * Closing a {@code QueueInputStream} has no effect. The methods in this class can be called after
+ * the stream has been closed without generating an {@code IOException}.
+ * 
+ * @see QueueOutputStream
+ * @since 2.9.0
+ */
+public class QueueInputStream extends InputStream {
+
+    private final BlockingQueue<Integer> queue;
+
+    /**
+     * Create a {@link QueueInputStream} with no limit to internal buffer size
+     */
+    public QueueInputStream() {
+        this(new LinkedBlockingQueue<>());
+    }
+
+    /**
+     * Create a {@link QueueInputStream} with given buffer
+     * 
+     * @param queue backing queue for the stream
+     */
+    public QueueInputStream(final BlockingQueue<Integer> queue) {
+        this.queue = Objects.requireNonNull(queue, ""queue is required"");
+    }
+
+    /**
+     * Create an QueueOutputStream connected to this. Writes to the output stream will be visible to this input stream.
+     * 
+     * @return QueueOutputStream connected to this stream
+     */
+    public QueueOutputStream newQueueOutputStream() {
+        return new QueueOutputStream(queue);
+    }
+
+    /**
+     * Read a single byte.
+     *
+     * @return either the byte read or <code>-1</code> if the end of the stream has been reached","[{'comment': 'You can abbreviate ` <code>-1</code>` as `{@code -1}`.\r\nYou could also avoid using a magic number and do a static import of `IOUtils.EOF` in the code.', 'commenter': 'garydgregory'}, {'comment': ""-1 as magic number comes from [InputStream::read](https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html#read--). I think it'd better to keep it that way to be consistent with super method documentation."", 'commenter': 'maxxedev'}]"
171,src/main/java/org/apache/commons/io/input/QueueInputStream.java,"@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import org.apache.commons.io.output.QueueOutputStream;
+
+import java.io.InputStream;
+import java.io.PipedInputStream;
+import java.io.PipedOutputStream;
+import java.util.Objects;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+
+/**
+ * Simple alternative to JDK {@link java.io.PipedInputStream}; queue input stream provides what's written in queue output stream.
+ * 
+ * Example usage:
+ * <pre>
+ * QueueInputStream inputStream = new QueueInputStream();
+ * QueueOutputStream outputStream = inputStream.newQueueOutputStream();
+ * 
+ * outputStream.write(""hello world"".getBytes(UTF_8));
+ * inputStream.read();
+ * </pre>
+ * 
+ * Unlike JDK {@link PipedInputStream} and {@link PipedOutputStream}, queue input/output streams may be
+ * used safely in a single thread or multiple threads. Also, unlike JDK classes, no special meaning is
+ * attached to initial or current thread. Instances can be used longer after initial threads exited.
+ * 
+ * Closing a {@code QueueInputStream} has no effect. The methods in this class can be called after
+ * the stream has been closed without generating an {@code IOException}.
+ * 
+ * @see QueueOutputStream
+ * @since 2.9.0
+ */
+public class QueueInputStream extends InputStream {
+
+    private final BlockingQueue<Integer> queue;
+
+    /**
+     * Create a {@link QueueInputStream} with no limit to internal buffer size","[{'comment': '`Create` -> `Constructs` since a constructor constructs ;-)', 'commenter': 'garydgregory'}]"
171,src/main/java/org/apache/commons/io/input/QueueInputStream.java,"@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import org.apache.commons.io.output.QueueOutputStream;
+
+import java.io.InputStream;
+import java.io.PipedInputStream;
+import java.io.PipedOutputStream;
+import java.util.Objects;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+
+/**
+ * Simple alternative to JDK {@link java.io.PipedInputStream}; queue input stream provides what's written in queue output stream.
+ * 
+ * Example usage:
+ * <pre>
+ * QueueInputStream inputStream = new QueueInputStream();
+ * QueueOutputStream outputStream = inputStream.newQueueOutputStream();
+ * 
+ * outputStream.write(""hello world"".getBytes(UTF_8));
+ * inputStream.read();
+ * </pre>
+ * 
+ * Unlike JDK {@link PipedInputStream} and {@link PipedOutputStream}, queue input/output streams may be
+ * used safely in a single thread or multiple threads. Also, unlike JDK classes, no special meaning is
+ * attached to initial or current thread. Instances can be used longer after initial threads exited.
+ * 
+ * Closing a {@code QueueInputStream} has no effect. The methods in this class can be called after
+ * the stream has been closed without generating an {@code IOException}.
+ * 
+ * @see QueueOutputStream
+ * @since 2.9.0
+ */
+public class QueueInputStream extends InputStream {
+
+    private final BlockingQueue<Integer> queue;
+
+    /**
+     * Create a {@link QueueInputStream} with no limit to internal buffer size
+     */
+    public QueueInputStream() {
+        this(new LinkedBlockingQueue<>());
+    }
+
+    /**
+     * Create a {@link QueueInputStream} with given buffer
+     * 
+     * @param queue backing queue for the stream
+     */
+    public QueueInputStream(final BlockingQueue<Integer> queue) {
+        this.queue = Objects.requireNonNull(queue, ""queue is required"");
+    }
+
+    /**
+     * Create an QueueOutputStream connected to this. Writes to the output stream will be visible to this input stream.","[{'comment': '`an QueueOutputStream` -> `an instance`.', 'commenter': 'garydgregory'}, {'comment': 'This Queue**Input**Stream method creates a Queue**Output**Stream instance. Just saying ""an instance"" might be confusing?', 'commenter': 'maxxedev'}, {'comment': 'Ah, yes of course!', 'commenter': 'garydgregory'}]"
171,src/main/java/org/apache/commons/io/input/QueueInputStream.java,"@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import org.apache.commons.io.output.QueueOutputStream;
+
+import java.io.InputStream;
+import java.io.PipedInputStream;
+import java.io.PipedOutputStream;
+import java.util.Objects;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+
+/**
+ * Simple alternative to JDK {@link java.io.PipedInputStream}; queue input stream provides what's written in queue output stream.
+ * 
+ * Example usage:
+ * <pre>
+ * QueueInputStream inputStream = new QueueInputStream();
+ * QueueOutputStream outputStream = inputStream.newQueueOutputStream();
+ * 
+ * outputStream.write(""hello world"".getBytes(UTF_8));
+ * inputStream.read();
+ * </pre>
+ * 
+ * Unlike JDK {@link PipedInputStream} and {@link PipedOutputStream}, queue input/output streams may be
+ * used safely in a single thread or multiple threads. Also, unlike JDK classes, no special meaning is
+ * attached to initial or current thread. Instances can be used longer after initial threads exited.
+ * 
+ * Closing a {@code QueueInputStream} has no effect. The methods in this class can be called after
+ * the stream has been closed without generating an {@code IOException}.
+ * 
+ * @see QueueOutputStream
+ * @since 2.9.0
+ */
+public class QueueInputStream extends InputStream {
+
+    private final BlockingQueue<Integer> queue;
+
+    /**
+     * Create a {@link QueueInputStream} with no limit to internal buffer size
+     */
+    public QueueInputStream() {
+        this(new LinkedBlockingQueue<>());
+    }
+
+    /**
+     * Create a {@link QueueInputStream} with given buffer
+     * 
+     * @param queue backing queue for the stream
+     */
+    public QueueInputStream(final BlockingQueue<Integer> queue) {
+        this.queue = Objects.requireNonNull(queue, ""queue is required"");
+    }
+
+    /**
+     * Create an QueueOutputStream connected to this. Writes to the output stream will be visible to this input stream.
+     * 
+     * @return QueueOutputStream connected to this stream
+     */
+    public QueueOutputStream newQueueOutputStream() {
+        return new QueueOutputStream(queue);
+    }
+
+    /**
+     * Read a single byte.","[{'comment': '`Read` -> `Reads`.', 'commenter': 'garydgregory'}]"
171,src/main/java/org/apache/commons/io/output/QueueOutputStream.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import org.apache.commons.io.input.QueueInputStream;
+
+import java.io.InterruptedIOException;
+import java.io.OutputStream;
+import java.io.PipedInputStream;
+import java.io.PipedOutputStream;
+import java.util.Objects;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+
+/**
+ * Simple alternative to JDK {@link java.io.PipedOutputStream}; queue input stream provides what's
+ * written in queue output stream.
+ * 
+ * Example usage:
+ * <pre>
+ * QueueOutputStream outputStream = new QueueOutputStream();
+ * QueueInputStream inputStream = outputStream.newPipeInputStream();
+ * 
+ * outputStream.write(""hello world"".getBytes(UTF_8));
+ * inputStream.read();
+ * </pre>
+ * 
+ * Unlike JDK {@link PipedInputStream} and {@link PipedOutputStream}, queue input/output streams may be
+ * used safely in a single thread or multiple threads. Also, unlike JDK classes, no special meaning is
+ * attached to initial or current thread. Instances can be used longer after initial threads exited.
+ * 
+ * Closing a {@code QueueOutputStream} has no effect. The methods in this class can be called after
+ * the stream has been closed without generating an {@code IOException}.
+ * 
+ * @see QueueInputStream
+ * @since 2.9.0
+ */
+public class QueueOutputStream extends OutputStream {
+
+    private final BlockingQueue<Integer> queue;
+
+    /**
+     * Create a {@link QueueOutputStream} with no limit to internal buffer size","[{'comment': '-> `Creates a new instance...` \r\n\r\nI am not a fan of creating a hyperlink to the class we are already in, it feels misleading, like we are sending someone elsewhere, when we are not.\r\n', 'commenter': 'garydgregory'}]"
173,src/main/java/org/apache/commons/io/input/CloseShieldInputStream.java,"@@ -35,7 +35,11 @@
      * closed.
      *
      * @param in underlying input stream
+     * @deprecated Using this constructor prevents IDEs from warning if
+     *             the underlying input stream is never closed.
+     *             Use {@link #wrap(InputStream)} instead.
      */
+    @Deprecated","[{'comment': ""I don't agree with deprecating these APIs, different versions of different IDEs raise different warnings depending on your preferred configuration of said IDE. Let's keep this PR simpler and lighter, we can always add deprecation later if it is truly warranted.\r\n"", 'commenter': 'garydgregory'}, {'comment': ""I feel that without deprecating the constructors, this PR adds no real value. People that currently use the constructors will keep doing so because they see no reason to change their code, and new users of the classes may only get confused if there are two ways to do the same thing. They'll probably end up using the constructors too because that's a character shorter (`new` vs `.wrap`).\r\n\r\nMy thought was that deprecating the constructors will make current users think about whether or not they have closed the underlying streams, even if their IDEs don't warn them. New users will chose the wrapper method because the alternative is deprecated.\r\n\r\nThe only downside to deprecating the constructors that I can see is that current users that don't have their IDEs setup to warn about unclosed streams will get warnings where there were none first, but as I said, perhaps they will think about whether or not their streams are properly closed somewhere else."", 'commenter': 'robtimus'}]"
173,src/main/java/org/apache/commons/io/input/CloseShieldInputStream.java,"@@ -50,4 +54,16 @@ public void close() {
         in = ClosedInputStream.CLOSED_INPUT_STREAM;
     }
 
+    /**
+     * Creates a proxy that shields the given input stream from being
+     * closed.
+     *
+     * @param in underlying input stream","[{'comment': '`@param in underlying input stream` -> `@param inputStream the input stream to wrap`', 'commenter': 'garydgregory'}, {'comment': 'Changed as suggested', 'commenter': 'robtimus'}]"
173,src/main/java/org/apache/commons/io/input/CloseShieldReader.java,"@@ -50,4 +54,16 @@ public void close() {
         in = ClosedReader.CLOSED_READER;
     }
 
+    /**
+     * Creates a proxy that shields the given reader from being
+     * closed.
+     *
+     * @param in underlying reader
+     * @return the created proxy
+     * @since 2.9.0
+     */
+    public static CloseShieldReader wrap(final Reader in) {","[{'comment': 'as see other Javadoc comments, in this case `in` -> `reader`', 'commenter': 'garydgregory'}, {'comment': 'Changed as suggested', 'commenter': 'robtimus'}]"
173,src/test/java/org/apache/commons/io/output/CloseShieldWriterTest.java,"@@ -40,19 +40,14 @@
     @BeforeEach
     public void setUp() {
         original = spy(new StringBuilderWriter());
-        shielded = new CloseShieldWriter(original);
+        shielded = CloseShieldWriter.wrap(original);
     }
 
     @Test
     public void testClose() throws IOException {
         shielded.close();
         verify(original, never()).close();
-        try {
-            shielded.write('x');
-            fail(""write(c)"");
-        } catch (final IOException ignore) {
-            // expected
-        }
+        assertThrows(IOException.class, () -> shielded.write('x'), ""write(c)"");","[{'comment': 'Nice use of a new JUnit 5 API! 👍 ', 'commenter': 'garydgregory'}]"
175,pom.xml,"@@ -384,7 +384,7 @@ file comparators, endian transformation classes, and much more.
           <forkCount>1</forkCount>
           <reuseForks>false</reuseForks>
           <!-- limit memory size see IO-161 -->
-          <argLine>${argLine} -Xmx25M</argLine>
+          <argLine>${argLine} -Xmx4223M</argLine>","[{'comment': 'Not acceptable, leave as is for now.', 'commenter': 'garydgregory'}, {'comment': 'Left unchanged in https://github.com/apache/commons-io/pull/175/commits/cc28d3daccafad190c3002f0a74baabd4c234edc.', 'commenter': 'leskin-in'}, {'comment': '[`IOUtilsTestCase` fails on lack of memory](https://travis-ci.com/github/apache/commons-io/jobs/505247713#L549).', 'commenter': 'leskin-in'}]"
175,src/test/java/org/apache/commons/io/IOUtilsTestCase.java,"@@ -1331,6 +1332,15 @@ public void testCopyLarge_SkipWithInvalidOffset() throws IOException {
         }
     }
 
+    @Test public void testToByteArray_InputStreamTooLong() throws Exception {
+        try (CircularInputStream cin = new CircularInputStream(new byte[]{65, 65, 65}, ((long)Integer.MAX_VALUE) + 1L)) {
+            IOUtils.toByteArray(cin);
+            fail(""IllegalArgumentException expected"");
+        } catch (final IllegalArgumentException exc) {","[{'comment': 'Use assertThrows()', 'commenter': 'garydgregory'}, {'comment': 'Thanks. Fixed in https://github.com/apache/commons-io/pull/175/commits/cc28d3daccafad190c3002f0a74baabd4c234edc.', 'commenter': 'leskin-in'}]"
175,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -2243,10 +2243,13 @@ public static BufferedReader toBufferedReader(final Reader reader, final int siz
      * @param input the <code>InputStream</code> to read from
      * @return the requested byte array
      * @throws IOException          if an I/O error occurs
+     * @throws IllegalArgumentException if input is longer than the maximum Java array length
      */
     public static byte[] toByteArray(final InputStream input) throws IOException {
         try (final ByteArrayOutputStream output = new ByteArrayOutputStream()) {
-            copy(input, output);
+            if (copy(input, output) == -1) {
+                throw new IllegalArgumentException(""Stream cannot be longer than Integer max value bytes"");","[{'comment': ""@leskin-in \r\nThis condition will not happen for a `ByteArrayInputStream`, instead of you'll get a `IndexOutOfBoundsException` or am I missing something?"", 'commenter': 'garydgregory'}, {'comment': 'That is correct if an `InputStream` is a `ByteArrayInputStream`. However, this method accepts generic `InputStream`, which may wrap more data. In that case, the implementation of [`copy()`](https://github.com/apache/commons-io/blob/4dc7b2462ef0b6345828a13d358e34bfc9309ce2/src/main/java/org/apache/commons/io/IOUtils.java#L842-L869) would return `-1`.\r\n\r\nHowever, `ByteArrayOutputStream`, which is created in this method as an intermediate buffer, does not check for its *underlying* buffer overflow at [`write()`](https://github.com/apache/commons-io/blob/b2165b7b8888be8500768b6e27e090f89a621510/src/main/java/org/apache/commons/io/output/ByteArrayOutputStream.java#L54-L68). The checks in `write()` only ensure sanity of arguments passed to it; they are valid in case of [`copyLarge()`](https://github.com/apache/commons-io/blob/4dc7b2462ef0b6345828a13d358e34bfc9309ce2/src/main/java/org/apache/commons/io/IOUtils.java#L1148-L1174) (ultimately called by `copy()` mentioned above).\r\n\r\nThe `ByteArrayOutputStream`, however, can store more than `Integer.MAX_VALUE` bytes because it [can use multiple underlying byte arrays](https://github.com/apache/commons-io/blob/401d17349e7ec52d8fa866c35efd24103f332c29/src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java#L79-L109).', 'commenter': 'leskin-in'}]"
185,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -2172,12 +2177,39 @@ public static void moveDirectoryToDirectory(final File src, final File destDir,
      * @since 1.4
      */
     public static void moveFile(final File srcFile, final File destFile) throws IOException {
+        moveFile(srcFile, destFile, true);
+    }
+
+    /**
+     * Moves a file.
+     * <p>
+     * When the destination file is on another file system, do a ""copy and delete"".
+     * </p>
+     * <p>
+     * <strong>Note:</strong> Setting <code>preserveFileDate</code> to {@code true} tries to preserve the files' last
+     * modified date/times using {@link File#setLastModified(long)} when destination is another file system, however it
+     * is not guaranteed that those operations will succeed. If the modification operation fails, the methods throws
+     * IOException.
+     * </p>
+     *
+     * @param srcFile the file to be moved.
+     * @param destFile the destination file.
+     * @param preserveFileDate true if the file date of the ""copy and delete"" should be the same as the original when
+     *            destination is on another file system. Param is not used if destination is on same file system.
+     * @throws NullPointerException if any of the given {@code File}s are {@code null}.
+     * @throws FileExistsException if the destination file exists.
+     * @throws IOException if source or destination is invalid.
+     * @throws IOException if an error occurs or setting the last-modified time didn't succeeded.
+     * @since 1.4","[{'comment': 'This is a new method for 2.9.0, please adjust the since tag.', 'commenter': 'garydgregory'}, {'comment': 'Rebased and fixed since tag.', 'commenter': 'tza'}]"
193,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1838,6 +1841,36 @@ public static boolean isSymlink(final File file) {
         return file != null ? Files.isSymbolicLink(file.toPath()) : false;
     }
 
+    /**
+     * Tests whether the specified file is an actual file.
+     * <p>
+     * This method delegates to {@link Files#isRegularFile(Path, LinkOption...)}
+     * </p>
+     *
+     * @param file the file to test.
+     * @return true if the file is a regular file, see {@link Files#isRegularFile(Path, LinkOption...)}.
+     * @since 2.9
+     * @see Files#isRegularFile(Path, LinkOption...)
+     */
+    public static boolean isRegularFile(final File file) {","[{'comment': 'IMO you could have a separate PR that only add ""is"" methods that cover the Files.is() APIs.', 'commenter': 'garydgregory'}]"
195,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1232,12 +1233,16 @@ public static boolean deleteQuietly(final File file) {
             if (file.isDirectory()) {
                 cleanDirectory(file);
             }
+        } catch (final SecurityException sec) {","[{'comment': 'I am -1 to this as it defeats the simple purpose off the method. \r\n\r\nAs an aside, and what makes it worse is that the change is not even documented in the Javadoc.\r\n\r\nI suppose the Javadoc could be improved to say that no `Exception`s are thrown as opposed to ""exceptions"".', 'commenter': 'garydgregory'}, {'comment': ""@garydgregory This is a important one.\r\nIn general: A single JavaDoc should not override global design principles. The SecurityManager has cross functional purpose. [Edit:] I agree that the missing documentation to throw a SecurityExcpetion is necessary. My fault, will correct that.\r\n\r\nUseCase A: One wants to configure the SecurityManager and grant permissions. Part of the application is to delete a file. If the permission is missing, cleaning does not work. The missing exception does not allow to recognize that.\r\nUseCase B: One has activated the SecurityManager. An attacker abuses the deleteQuietly method. The missing SecurityException hides this attempt, you're IDS can't alarm.\r\nUseCase C: One utilizes the SecurityManager to test the system, to ensure every property (like file location) is set properly. The missing SecurityException does not support this UseCase."", 'commenter': 'boris-unckel'}]"
196,src/main/java/org/apache/commons/io/FileDeleteStrategy.java,"@@ -144,6 +147,7 @@ public boolean deleteQuietly(final File fileToDelete) {
      * @throws IOException if an error occurs during file deletion
      */
     protected boolean doDelete(final File file) throws IOException {
+        Objects.requireNonNull(file,""file"");","[{'comment': 'Fix formatting.\r\n', 'commenter': 'garydgregory'}]"
196,src/main/java/org/apache/commons/io/FileSystemUtils.java,"@@ -271,9 +272,8 @@ public static long freeSpaceKb(final long timeout) throws IOException {
      * @throws IOException if an error occurs when finding the free space
      */
     long freeSpaceOS(final String path, final int os, final boolean kb, final long timeout) throws IOException {
-        if (path == null) {
-            throw new IllegalArgumentException(""Path must not be null"");
-        }
+        Objects.requireNonNull(path,""path"");","[{'comment': 'Fix formatting.', 'commenter': 'garydgregory'}]"
196,src/main/java/org/apache/commons/io/FileSystemUtils.java,"@@ -396,6 +396,7 @@ long parseDir(final String line, final String path) throws IOException {
      */
     long freeSpaceUnix(final String path, final boolean kb, final boolean posix, final long timeout)
             throws IOException {
+        Objects.requireNonNull(path,""path"");","[{'comment': 'Fix formatting.', 'commenter': 'garydgregory'}]"
196,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -314,6 +314,7 @@ public static long checksumCRC32(final File file) throws IOException {
      * @see #forceDelete(File)
      */
     public static void cleanDirectory(final File directory) throws IOException {
+        Objects.requireNonNull(directory, ""directory"");","[{'comment': '-1: no need, already done on the next line in `listFiles`.', 'commenter': 'garydgregory'}]"
196,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -340,6 +341,7 @@ public static void cleanDirectory(final File directory) throws IOException {
      * @see #forceDeleteOnExit(File)
      */
     private static void cleanDirectoryOnExit(final File directory) throws IOException {
+        Objects.requireNonNull(directory, ""directory"");","[{'comment': '-1: no need, already done on the next line in `listFiles`.', 'commenter': 'garydgregory'}]"
196,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -866,6 +868,8 @@ public static void copyFile(final File srcFile, final File destFile, final CopyO
      * @since 2.1
      */
     public static long copyFile(final File input, final OutputStream output) throws IOException {
+        Objects.requireNonNull(input, ""input"");
+        Objects.requireNonNull(output, ""output"");","[{'comment': ""-1: no need to check on `output`, this already done in `copyLarge`.\r\n\r\nI'll stop this type of comment since these checks over the top in this PR. IOW, let's not check for NPEs when we do not need to.\r\n"", 'commenter': 'garydgregory'}, {'comment': '@garydgregory The other cases before I understood the pattern behind ""-1"". In this case a FileInputStream is created, afterwards copyLarge calls copy calls copyLarge which then does the check.\r\nI\'ll fix the former cases and wait with removal for cases like this on your comment.', 'commenter': 'boris-unckel'}]"
196,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1200,6 +1210,7 @@ public static void deleteDirectory(final File directory) throws IOException {
      * @throws IOException          in case deletion is unsuccessful
      */
     private static void deleteDirectoryOnExit(final File directory) throws IOException {
+        Objects.requireNonNull(directory,""directory"");","[{'comment': 'Fix formatting.', 'commenter': 'garydgregory'}]"
196,src/main/java/org/apache/commons/io/FilenameUtils.java,"@@ -1510,6 +1510,9 @@ public static boolean wildcardMatch(final String fileName, final String wildcard
      * @return true if the given name is a valid host name
      */
     private static boolean isValidHostName(final String name) {
+        if(Objects.isNull(name)) {","[{'comment': 'Fix formatting and no need to call an API meant for use in lambdas when `name == null` would do.\r\n', 'commenter': 'garydgregory'}]"
196,src/main/java/org/apache/commons/io/monitor/FileAlterationObserver.java,"@@ -200,12 +201,9 @@ public FileAlterationObserver(final File directory, final FileFilter fileFilter,
      */
     protected FileAlterationObserver(final FileEntry rootEntry, final FileFilter fileFilter,
                                      final IOCase caseSensitivity) {
-        if (rootEntry == null) {
-            throw new IllegalArgumentException(""Root entry is missing"");
-        }
-        if (rootEntry.getFile() == null) {
-            throw new IllegalArgumentException(""Root directory is missing"");
-        }
+        Objects.requireNonNull(rootEntry, ""rootEntry"");
+        Objects.requireNonNull(rootEntry.getFile(),""rootDirectory"");","[{'comment': 'Fix formatting.\r\n', 'commenter': 'garydgregory'}]"
197,src/main/java/org/apache/commons/io/FileSystem.java,"@@ -146,27 +146,16 @@ private static boolean getOsMatchesName(final String osNamePrefix) {
     }
 
     /**
-     * <p>
-     * Gets a System property, defaulting to {@code null} if the property cannot be read.
-     * </p>
-     * <p>
-     * If a {@code SecurityException} is caught, the return value is {@code null} and a message is written to
-     * {@code System.err}.
-     * </p>
+     * Gets a System property, defaulting to {@code null} if the property cannot be read,
+     * except for {@code SecurityException}.
      *
      * @param property
      *            the system property name
-     * @return the system property value or {@code null} if a security problem occurs
+     * @return the system property value or {@code null} if a problem occurs
+     * @throws SecurityException if underlying calls fail due to missing permissions.
      */
     private static String getSystemProperty(final String property) {
-        try {
-            return System.getProperty(property);
-        } catch (final SecurityException ex) {
-            // we are not allowed to look at this property
-            System.err.println(""Caught a SecurityException reading the system property '"" + property
-                    + ""'; the SystemUtils property value will default to null."");
-            return null;
-        }
+        return System.getProperty(property);","[{'comment': ""This is a special case. The whole purpose of this API is to never blow up. I am not sure how useful this method really is in practice though. If you are running under JAAS and this call returns null because you can't read a sys prop and the rest of your app runs (or not), then you must have a very specific set of JAAS permissions set. But... I can see that one might want to write out or log sys props on start up, and then, writing 'null' instead of blowing up provides... what? I'm not sure. All of this rambling to say that in this case we should not change the behavior IMO.\r\n\r\nWriting to the console is a no-no so we should get rid of that for sure."", 'commenter': 'garydgregory'}, {'comment': 'I have already commented on the use case, but I\'ll try again with a impact analysis of the change:\r\na) The absolute majority: The Java Security Manager is not active, before and after change zero impact.\r\nb) The absolute minority: One has the ability to upgrade the library, but not to change the permissions.xml or xyz.policy file. But the security manager is in use. This is very unlikely but in this case you\'re stuck on the old version. People activating the JSM without ability to grant permissions?\r\nc) The happy case: One has the ability to upgrade the library and to grant permissions. With the clear message what is is missing one can grant the single permission to the updated single library.\r\nd) JavaEE users will have no impact with the container itself, permissions are granted by the container. For their apps, they utilize not single permissions, but permissions.xml for the whole app. Means the grant is for all classes in the ear or war, not only for a single jar. In example Spring requires a * [PropertyPermission](https://docs.oracle.com/javase/8/docs/technotes/guides/security/permissions.html#PropertyPermission) calling [System.getProperties](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getProperties--).\r\n\r\nIf a user does need to read a property without grant there is a way: [https://docs.oracle.com/javase/8/docs/technotes/guides/security/doprivileged.html](https://docs.oracle.com/javase/8/docs/technotes/guides/security/doprivileged.html)\r\nThis way should never be used in a utility method. See chapters ""Least Privilege"", ""More Privilege"", ""Reflection"".', 'commenter': 'boris-unckel'}]"
203,src/main/java/org/apache/commons/io/file/CopyDirectoryVisitor.java,"@@ -144,7 +144,7 @@ public int hashCode() {
     @Override
     public FileVisitResult preVisitDirectory(final Path directory, final BasicFileAttributes attributes)
         throws IOException {
-        final Path newTargetDir = targetDirectory.resolve(sourceDirectory.relativize(directory));
+        final Path newTargetDir = targetDirectory.resolve(sourceDirectory.relativize(directory).toString());","[{'comment': 'Hi @ashcheglov \r\nI think we need a comment as to why toString() is _required_.', 'commenter': 'garydgregory'}]"
203,src/main/java/org/apache/commons/io/file/CopyDirectoryVisitor.java,"@@ -153,7 +155,7 @@ public FileVisitResult preVisitDirectory(final Path directory, final BasicFileAt
 
     @Override
     public FileVisitResult visitFile(final Path sourceFile, final BasicFileAttributes attributes) throws IOException {
-        final Path targetFile = targetDirectory.resolve(sourceDirectory.relativize(sourceFile));
+        final Path targetFile = targetDirectory.resolve(sourceDirectory.relativize(sourceFile).toString());","[{'comment': 'As above...', 'commenter': 'garydgregory'}]"
206,src/main/java/org/apache/commons/io/output/DeferredFileOutputStream.java,"@@ -272,4 +274,27 @@ public void writeTo(final OutputStream outputStream) throws IOException {
             }
         }
     }
+
+    /**
+     * Gets the current contents of this byte stream as an {@link InputStream}.
+     * If the data for this output stream has been retained in memory, the
+     * returned stream is backed by buffers of {@code this} stream,
+     * avoiding memory allocation and copy, thus saving space and time.<br>
+     * Otherwise, the returned stream will be one that is created from the data
+     * that has been committed to disk.
+     *
+     * @return the current contents of this output stream.
+     * @see org.apache.commons.io.output.ByteArrayOutputStream.toInputStream()","[{'comment': '```@see org.apache.commons.io.output.ByteArrayOutputStream#toInputStream()```', 'commenter': 'XenoAmess'}, {'comment': ""Ok, I see it now. I needed to run the `javadoc:javadoc` goal. I haven't used maven default goals before, so I was just running `package` and `test` manually. \r\nIt should be fixed now. Sorry for the confusion."", 'commenter': 'Unknown'}]"
206,src/main/java/org/apache/commons/io/output/DeferredFileOutputStream.java,"@@ -272,4 +274,31 @@ public void writeTo(final OutputStream outputStream) throws IOException {
             }
         }
     }
+
+    /**
+     * Gets the current contents of this byte stream as an {@link InputStream}.
+     * If the data for this output stream has been retained in memory, the
+     * returned stream is backed by buffers of {@code this} stream,
+     * avoiding memory allocation and copy, thus saving space and time.<br>
+     * Otherwise, the returned stream will be one that is created from the data
+     * that has been committed to disk.
+     *
+     * @return the current contents of this output stream.
+     * @throws IOException if this stream is not yet closed or an error occurs.
+     * @see org.apache.commons.io.output.ByteArrayOutputStream#toInputStream()","[{'comment': 'Needs a Javadoc since tag.', 'commenter': 'garydgregory'}, {'comment': ""Ping. FYI, you should run the _default_ Maven build: 'mvn'.\r\n"", 'commenter': 'garydgregory'}, {'comment': 'Added `@since`.\r\n\r\nI tried running the default maven build, but it doesn\'t work for me. It always dies in the middle with a ""killed"" message on the terminal. I did run all the individual goal that are part of the default build and they all complete successfully.', 'commenter': 'Unknown'}]"
206,src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java,"@@ -365,4 +370,55 @@ private void verifyResultFile(final File testFile) {
             fail(""Unexpected IOException"");
         }
     }
+
+    /**
+     * Tests the case where the amount of data falls below the threshold, and is therefore confined to memory.
+     * Testing the getInputStream() method.
+     */
+    @ParameterizedTest(name = ""initialBufferSize = {0}"")
+    @MethodSource(""data"")
+    public void testBelowThresholdGetInputStream(final int initialBufferSize) throws IOException {
+        final DeferredFileOutputStream dfos = new DeferredFileOutputStream(testBytes.length + 42, initialBufferSize,
+            null);
+        try {
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+        } catch (final IOException e) {
+            fail(""Unexpected IOException"");
+        }
+        assertTrue(dfos.isInMemory());
+
+        try(InputStream is = dfos.toInputStream()) {","[{'comment': 'Missing space after ""try"".', 'commenter': 'garydgregory'}, {'comment': 'Fixed.', 'commenter': 'Unknown'}]"
206,src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java,"@@ -365,4 +370,55 @@ private void verifyResultFile(final File testFile) {
             fail(""Unexpected IOException"");
         }
     }
+
+    /**
+     * Tests the case where the amount of data falls below the threshold, and is therefore confined to memory.
+     * Testing the getInputStream() method.
+     */
+    @ParameterizedTest(name = ""initialBufferSize = {0}"")
+    @MethodSource(""data"")
+    public void testBelowThresholdGetInputStream(final int initialBufferSize) throws IOException {
+        final DeferredFileOutputStream dfos = new DeferredFileOutputStream(testBytes.length + 42, initialBufferSize,
+            null);
+        try {
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+        } catch (final IOException e) {
+            fail(""Unexpected IOException"");
+        }
+        assertTrue(dfos.isInMemory());
+
+        try(InputStream is = dfos.toInputStream()) {
+            final byte[] resultBytes = IOUtils.toByteArray(is);
+            assertArrayEquals(testBytes, resultBytes);
+        }
+    }
+
+    /**
+     * Tests the case where the amount of data exceeds the threshold, and is therefore written to disk. The actual data
+     * written to disk is verified, as is the file itself.
+     * Testing the getInputStream() method.
+     */
+    @ParameterizedTest(name = ""initialBufferSize = {0}"")
+    @MethodSource(""data"")
+    public void testAboveThresholdGetInputStream(final int initialBufferSize, @TempDir Path tempDir) throws IOException {
+        final File testFile = tempDir.resolve(""testAboveThreshold.dat"").toFile();
+
+        final DeferredFileOutputStream dfos = new DeferredFileOutputStream(testBytes.length - 5, initialBufferSize,
+            testFile);
+        try {
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+        } catch (final IOException e) {
+            fail(""Unexpected IOException"");
+        }
+        assertFalse(dfos.isInMemory());
+
+        try(InputStream is = dfos.toInputStream()) {","[{'comment': 'Missing space after ""try"".', 'commenter': 'garydgregory'}, {'comment': 'Fixed.', 'commenter': 'Unknown'}]"
206,src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java,"@@ -365,4 +370,55 @@ private void verifyResultFile(final File testFile) {
             fail(""Unexpected IOException"");
         }
     }
+
+    /**
+     * Tests the case where the amount of data falls below the threshold, and is therefore confined to memory.
+     * Testing the getInputStream() method.
+     */
+    @ParameterizedTest(name = ""initialBufferSize = {0}"")
+    @MethodSource(""data"")
+    public void testBelowThresholdGetInputStream(final int initialBufferSize) throws IOException {
+        final DeferredFileOutputStream dfos = new DeferredFileOutputStream(testBytes.length + 42, initialBufferSize,
+            null);
+        try {
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+        } catch (final IOException e) {
+            fail(""Unexpected IOException"");
+        }
+        assertTrue(dfos.isInMemory());
+
+        try(InputStream is = dfos.toInputStream()) {
+            final byte[] resultBytes = IOUtils.toByteArray(is);
+            assertArrayEquals(testBytes, resultBytes);
+        }
+    }
+
+    /**
+     * Tests the case where the amount of data exceeds the threshold, and is therefore written to disk. The actual data
+     * written to disk is verified, as is the file itself.
+     * Testing the getInputStream() method.
+     */
+    @ParameterizedTest(name = ""initialBufferSize = {0}"")
+    @MethodSource(""data"")
+    public void testAboveThresholdGetInputStream(final int initialBufferSize, @TempDir Path tempDir) throws IOException {
+        final File testFile = tempDir.resolve(""testAboveThreshold.dat"").toFile();
+
+        final DeferredFileOutputStream dfos = new DeferredFileOutputStream(testBytes.length - 5, initialBufferSize,
+            testFile);
+        try {
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+        } catch (final IOException e) {
+            fail(""Unexpected IOException"");
+        }
+        assertFalse(dfos.isInMemory());
+
+        try(InputStream is = dfos.toInputStream()) {
+            final byte[] resultBytes = IOUtils.toByteArray(is);
+            assertArrayEquals(testBytes, resultBytes);","[{'comment': 'No need for intermediary local variable.\r\n', 'commenter': 'garydgregory'}, {'comment': 'Removed.\r\nNote, I was just following the pattern of the existing test.', 'commenter': 'Unknown'}]"
206,src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java,"@@ -365,4 +370,55 @@ private void verifyResultFile(final File testFile) {
             fail(""Unexpected IOException"");
         }
     }
+
+    /**
+     * Tests the case where the amount of data falls below the threshold, and is therefore confined to memory.
+     * Testing the getInputStream() method.
+     */
+    @ParameterizedTest(name = ""initialBufferSize = {0}"")
+    @MethodSource(""data"")
+    public void testBelowThresholdGetInputStream(final int initialBufferSize) throws IOException {
+        final DeferredFileOutputStream dfos = new DeferredFileOutputStream(testBytes.length + 42, initialBufferSize,","[{'comment': 'Use try-with-resources.', 'commenter': 'garydgregory'}, {'comment': ""Won't work here since the `DeferredFileOutputStream` needs to be closed while it is still in scope in order to execute `toInputStream()`"", 'commenter': 'Unknown'}]"
206,src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java,"@@ -365,4 +370,55 @@ private void verifyResultFile(final File testFile) {
             fail(""Unexpected IOException"");
         }
     }
+
+    /**
+     * Tests the case where the amount of data falls below the threshold, and is therefore confined to memory.
+     * Testing the getInputStream() method.
+     */
+    @ParameterizedTest(name = ""initialBufferSize = {0}"")
+    @MethodSource(""data"")
+    public void testBelowThresholdGetInputStream(final int initialBufferSize) throws IOException {
+        final DeferredFileOutputStream dfos = new DeferredFileOutputStream(testBytes.length + 42, initialBufferSize,
+            null);
+        try {
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+        } catch (final IOException e) {
+            fail(""Unexpected IOException"");","[{'comment': 'Useless catch. ', 'commenter': 'garydgregory'}, {'comment': 'Removed.\r\n\r\nWas following pattern of existing test.', 'commenter': 'Unknown'}]"
206,src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java,"@@ -365,4 +370,55 @@ private void verifyResultFile(final File testFile) {
             fail(""Unexpected IOException"");
         }
     }
+
+    /**
+     * Tests the case where the amount of data falls below the threshold, and is therefore confined to memory.
+     * Testing the getInputStream() method.
+     */
+    @ParameterizedTest(name = ""initialBufferSize = {0}"")
+    @MethodSource(""data"")
+    public void testBelowThresholdGetInputStream(final int initialBufferSize) throws IOException {
+        final DeferredFileOutputStream dfos = new DeferredFileOutputStream(testBytes.length + 42, initialBufferSize,
+            null);
+        try {
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+        } catch (final IOException e) {
+            fail(""Unexpected IOException"");
+        }
+        assertTrue(dfos.isInMemory());
+
+        try(InputStream is = dfos.toInputStream()) {
+            final byte[] resultBytes = IOUtils.toByteArray(is);
+            assertArrayEquals(testBytes, resultBytes);
+        }
+    }
+
+    /**
+     * Tests the case where the amount of data exceeds the threshold, and is therefore written to disk. The actual data
+     * written to disk is verified, as is the file itself.
+     * Testing the getInputStream() method.
+     */
+    @ParameterizedTest(name = ""initialBufferSize = {0}"")
+    @MethodSource(""data"")","[{'comment': 'See other comments, which apply here as well. Use final in method parmeter.', 'commenter': 'garydgregory'}, {'comment': 'Done.', 'commenter': 'Unknown'}]"
215,src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java,"@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.channels.FileChannel.MapMode;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
+
+import org.apache.commons.io.ByteBufferCleaner;
+
+/**
+ * An {@link InputStream} that utilizes memory mapped files to improve
+ * performance. A sliding window of the file is mapped to memory to avoid
+ * mapping the entire file to memory at one time. The size of the sliding buffer
+ * is user configurable.
+ * 
+ * For most operating systems, mapping a file into memory is more expensive than
+ * reading or writing a few tens of kilobytes of data. From the standpoint of
+ * performance it is generally only worth mapping relatively large files into
+ * memory. Use of this class can provide approximately a 25% increase in
+ * throughput when reading large files. <br>","[{'comment': 'Close all HTML tags. You might as well use a paragraph here.\r\n', 'commenter': 'garydgregory'}, {'comment': 'I would not make any performance claims without backing it up with evidence like a test anyone can run on their combination of OS/JRE/file. IOW, provide a test where the user can specify the file size in a sys prop or command line for example.', 'commenter': 'garydgregory'}, {'comment': ""The number given is based on one use case where I used this code.\r\nI will remove the performance claim since I don't have time to spend developing benchmarks."", 'commenter': 'shollander'}, {'comment': 'Done', 'commenter': 'shollander'}]"
215,src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java,"@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.channels.FileChannel.MapMode;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
+
+import org.apache.commons.io.ByteBufferCleaner;
+
+/**
+ * An {@link InputStream} that utilizes memory mapped files to improve
+ * performance. A sliding window of the file is mapped to memory to avoid
+ * mapping the entire file to memory at one time. The size of the sliding buffer
+ * is user configurable.
+ * 
+ * For most operating systems, mapping a file into memory is more expensive than
+ * reading or writing a few tens of kilobytes of data. From the standpoint of
+ * performance it is generally only worth mapping relatively large files into
+ * memory. Use of this class can provide approximately a 25% increase in
+ * throughput when reading large files. <br>
+ * Note: Use of this class does not necessarily obviate the need to use a
+ * {@link BufferedInputStream}. Depending on the use case, the use of buffering
+ * may still further improve performance. For example:
+ * 
+ * <pre>
+ * new BufferedInputStream(new GzipInputStream(new MemoryMappedFileInputStream(path))))
+ * </pre>
+ * 
+ * will greatly outperform:
+ * 
+ * <pre>
+ * new GzipInputStream(new MemoryMappedFileInputStream(path))","[{'comment': 'This comparison does not make sense. You should compare using this class with a code fragment that does not use it.', 'commenter': 'garydgregory'}, {'comment': ""This comment has nothing to do with the performance of this class. It is just noting that user's shouldn't think there is no need for buffering after using this class. In the example given, buffering is needed to improve the performance of the gzip compression in memory."", 'commenter': 'shollander'}]"
215,src/main/java/org/apache/commons/io/ByteBufferCleaner.java,"@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.nio.ByteBuffer;
+
+/**
+ * Utility to manually clean a direct {@link ByteBuffer}. Without manual","[{'comment': 'Move this class to the input package and make it package private to reduce the public API surface, we can make it public later.', 'commenter': 'garydgregory'}, {'comment': 'Done', 'commenter': 'shollander'}]"
215,src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java,"@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.channels.FileChannel.MapMode;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
+
+import org.apache.commons.io.ByteBufferCleaner;
+
+/**
+ * An {@link InputStream} that utilizes memory mapped files to improve
+ * performance. A sliding window of the file is mapped to memory to avoid
+ * mapping the entire file to memory at one time. The size of the sliding buffer
+ * is user configurable.
+ * 
+ * For most operating systems, mapping a file into memory is more expensive than
+ * reading or writing a few tens of kilobytes of data. From the standpoint of
+ * performance it is generally only worth mapping relatively large files into
+ * memory. Use of this class can provide approximately a 25% increase in
+ * throughput when reading large files. <br>
+ * Note: Use of this class does not necessarily obviate the need to use a
+ * {@link BufferedInputStream}. Depending on the use case, the use of buffering
+ * may still further improve performance. For example:
+ * 
+ * <pre>
+ * new BufferedInputStream(new GzipInputStream(new MemoryMappedFileInputStream(path))))
+ * </pre>
+ * 
+ * will greatly outperform:
+ * 
+ * <pre>
+ * new GzipInputStream(new MemoryMappedFileInputStream(path))
+ * </pre>
+ * 
+ * @since 2.9.0
+ */","[{'comment': 'We are up to 2.10.0 now 😉', 'commenter': 'garydgregory'}, {'comment': 'Fixed.', 'commenter': 'shollander'}]"
215,src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java,"@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.channels.FileChannel.MapMode;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
+
+import org.apache.commons.io.ByteBufferCleaner;
+
+/**
+ * An {@link InputStream} that utilizes memory mapped files to improve
+ * performance. A sliding window of the file is mapped to memory to avoid
+ * mapping the entire file to memory at one time. The size of the sliding buffer
+ * is user configurable.
+ * 
+ * For most operating systems, mapping a file into memory is more expensive than
+ * reading or writing a few tens of kilobytes of data. From the standpoint of
+ * performance it is generally only worth mapping relatively large files into
+ * memory. Use of this class can provide approximately a 25% increase in
+ * throughput when reading large files. <br>
+ * Note: Use of this class does not necessarily obviate the need to use a
+ * {@link BufferedInputStream}. Depending on the use case, the use of buffering
+ * may still further improve performance. For example:
+ * 
+ * <pre>
+ * new BufferedInputStream(new GzipInputStream(new MemoryMappedFileInputStream(path))))
+ * </pre>
+ * 
+ * will greatly outperform:
+ * 
+ * <pre>
+ * new GzipInputStream(new MemoryMappedFileInputStream(path))
+ * </pre>
+ * 
+ * @since 2.9.0
+ */
+public class MemoryMappedFileInputStream extends InputStream {
+    /**
+     * Default size of the sliding memory mapped buffer. We use 256K, equal to 65536
+     * pages (given a 4K page size). Increasing the value beyond the default size
+     * will generally not provide any increase in throughput.
+     */
+    private static final int DEFAULT_BUFFER_SIZE = 256 * 1024;
+    private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.wrap(new byte[0]).asReadOnlyBuffer();
+    private static final boolean IS_CLEANING_SUPPORTED = ByteBufferCleaner.isSupported();
+    private final int bufferSize;
+    private final FileChannel channel;
+    private ByteBuffer buffer = EMPTY_BUFFER;
+    private boolean closed = false;
+    /**
+     * The starting position (within the file) of the next sliding buffer.
+     */
+    private long nextBufferPosition = 0;
+
+    public MemoryMappedFileInputStream(final Path file) throws IOException {
+        this(file, DEFAULT_BUFFER_SIZE);
+    }
+
+    public MemoryMappedFileInputStream(final Path file, final int bufferSize) throws IOException {
+        this.bufferSize = bufferSize;
+        this.channel = FileChannel.open(file, StandardOpenOption.READ);
+    }
+
+    @Override
+    public int read() throws IOException {
+        ensureOpen();
+        if (!buffer.hasRemaining()) {
+            nextBuffer();
+            if (!buffer.hasRemaining()) {
+                return EOF;
+            }
+        }
+        return Short.toUnsignedInt(buffer.get());
+    }
+
+    @Override
+    public int read(byte[] b, int off, int len) throws IOException {","[{'comment': 'Use final where you can.', 'commenter': 'garydgregory'}, {'comment': 'Done.', 'commenter': 'shollander'}]"
215,src/test/java/org/apache/commons/io/ByteBufferCleanerTest.java,"@@ -0,0 +1,49 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+import java.nio.ByteBuffer;
+
+import org.apache.commons.lang3.RandomUtils;
+import org.junit.jupiter.api.Test;
+
+class ByteBufferCleanerTest {","[{'comment': 'The style of this component is to make test classes and methods public.', 'commenter': 'garydgregory'}, {'comment': ""Seems like a holdover from legacy JUnit. Why bother when JUnit doesn't require it anymore?"", 'commenter': 'shollander'}, {'comment': '@shollander\r\n Because you want to match the existing style we use.\r\n', 'commenter': 'garydgregory'}, {'comment': 'Fixed.', 'commenter': 'shollander'}]"
215,src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java,"@@ -0,0 +1,248 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Arrays;
+
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.lang3.RandomUtils;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.io.TempDir;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
+
+class MemoryMappedFileInputStreamTest {","[{'comment': 'Make public.', 'commenter': 'garydgregory'}, {'comment': 'Done.', 'commenter': 'shollander'}]"
215,src/main/java/org/apache/commons/io/input/ByteBufferCleaner.java,"@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.nio.ByteBuffer;
+
+/**
+ * Utility to manually clean a direct {@link ByteBuffer}. Without manual
+ * intervention, direct ByteBuffers will be cleaned eventually upon garbage
+ * collection. However, this should be be relied upon since it may not occur in","[{'comment': '""this should be be relied""  -> ""this should NOT be relied""', 'commenter': 'garydgregory'}, {'comment': 'fixed.', 'commenter': 'shollander'}]"
215,src/main/java/org/apache/commons/io/input/ByteBufferCleaner.java,"@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.nio.ByteBuffer;
+
+/**
+ * Utility to manually clean a direct {@link ByteBuffer}. Without manual
+ * intervention, direct ByteBuffers will be cleaned eventually upon garbage
+ * collection. However, this should be be relied upon since it may not occur in
+ * a timely fashion - especially since off heap ByeBuffers don't put pressure on
+ * the garbage collector.
+ * 
+ * <p>
+ * <b>Warning:</b> Do not attempt to use a direct {@link ByteBuffer} that has
+ * been cleaned or bad things will happen. Don't use this class unless you can
+ * ensure that the cleaned buffer will not be accessed anymore.
+ * </p>
+ * <p>
+ * See <a href=https://bugs.openjdk.java.net/browse/JDK-4724038>JDK-4724038</a>
+ * </p>
+ * 
+ * @since 2.10.0","[{'comment': 'You do need a since tag since this is package private. Also new public and protected elements should be since 2.12.0 ;-)', 'commenter': 'garydgregory'}, {'comment': 'fixed.', 'commenter': 'shollander'}]"
215,src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java,"@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.channels.FileChannel.MapMode;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
+
+/**
+ * <p>
+ * An {@link InputStream} that utilizes memory mapped files to improve
+ * performance. A sliding window of the file is mapped to memory to avoid
+ * mapping the entire file to memory at one time. The size of the sliding buffer
+ * is user configurable.
+ * </p>
+ * <p>
+ * For most operating systems, mapping a file into memory is more expensive than
+ * reading or writing a few tens of kilobytes of data. From the standpoint of
+ * performance it is generally only worth mapping relatively large files into
+ * memory.
+ * </p>
+ * Note: Use of this class does not necessarily obviate the need to use a
+ * {@link BufferedInputStream}. Depending on the use case, the use of buffering
+ * may still further improve performance. For example:
+ * 
+ * <pre>
+ * new BufferedInputStream(new GzipInputStream(new MemoryMappedFileInputStream(path))))
+ * </pre>
+ * 
+ * will greatly outperform:
+ * 
+ * <pre>
+ * new GzipInputStream(new MemoryMappedFileInputStream(path))
+ * </pre>
+ * 
+ * @since 2.10.0","[{'comment': '""2.10.0"" -> ""2.12.0""', 'commenter': 'garydgregory'}, {'comment': 'fixed.', 'commenter': 'shollander'}]"
215,src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java,"@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.channels.FileChannel.MapMode;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
+
+/**
+ * <p>
+ * An {@link InputStream} that utilizes memory mapped files to improve
+ * performance. A sliding window of the file is mapped to memory to avoid
+ * mapping the entire file to memory at one time. The size of the sliding buffer
+ * is user configurable.
+ * </p>
+ * <p>
+ * For most operating systems, mapping a file into memory is more expensive than
+ * reading or writing a few tens of kilobytes of data. From the standpoint of
+ * performance it is generally only worth mapping relatively large files into
+ * memory.
+ * </p>
+ * Note: Use of this class does not necessarily obviate the need to use a
+ * {@link BufferedInputStream}. Depending on the use case, the use of buffering
+ * may still further improve performance. For example:
+ * 
+ * <pre>
+ * new BufferedInputStream(new GzipInputStream(new MemoryMappedFileInputStream(path))))
+ * </pre>
+ * 
+ * will greatly outperform:
+ * 
+ * <pre>
+ * new GzipInputStream(new MemoryMappedFileInputStream(path))
+ * </pre>
+ * 
+ * @since 2.10.0
+ */
+public class MemoryMappedFileInputStream extends InputStream {
+    /**
+     * Default size of the sliding memory mapped buffer. We use 256K, equal to 65536
+     * pages (given a 4K page size). Increasing the value beyond the default size
+     * will generally not provide any increase in throughput.
+     */
+    private static final int DEFAULT_BUFFER_SIZE = 256 * 1024;
+    private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.wrap(new byte[0]).asReadOnlyBuffer();
+    private static final boolean IS_CLEANING_SUPPORTED = ByteBufferCleaner.isSupported();
+    private final int bufferSize;
+    private final FileChannel channel;
+    private ByteBuffer buffer = EMPTY_BUFFER;
+    private boolean closed = false;
+    /**
+     * The starting position (within the file) of the next sliding buffer.
+     */
+    private long nextBufferPosition = 0;
+
+    public MemoryMappedFileInputStream(final Path file) throws IOException {","[{'comment': 'Please add a Javadoc comment: ""Constructs...""', 'commenter': 'garydgregory'}, {'comment': 'fixed', 'commenter': 'shollander'}]"
215,src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java,"@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import static org.apache.commons.io.IOUtils.EOF;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.channels.FileChannel.MapMode;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
+
+/**
+ * <p>
+ * An {@link InputStream} that utilizes memory mapped files to improve
+ * performance. A sliding window of the file is mapped to memory to avoid
+ * mapping the entire file to memory at one time. The size of the sliding buffer
+ * is user configurable.
+ * </p>
+ * <p>
+ * For most operating systems, mapping a file into memory is more expensive than
+ * reading or writing a few tens of kilobytes of data. From the standpoint of
+ * performance it is generally only worth mapping relatively large files into
+ * memory.
+ * </p>
+ * Note: Use of this class does not necessarily obviate the need to use a
+ * {@link BufferedInputStream}. Depending on the use case, the use of buffering
+ * may still further improve performance. For example:
+ * 
+ * <pre>
+ * new BufferedInputStream(new GzipInputStream(new MemoryMappedFileInputStream(path))))
+ * </pre>
+ * 
+ * will greatly outperform:
+ * 
+ * <pre>
+ * new GzipInputStream(new MemoryMappedFileInputStream(path))
+ * </pre>
+ * 
+ * @since 2.10.0
+ */
+public class MemoryMappedFileInputStream extends InputStream {
+    /**
+     * Default size of the sliding memory mapped buffer. We use 256K, equal to 65536
+     * pages (given a 4K page size). Increasing the value beyond the default size
+     * will generally not provide any increase in throughput.
+     */
+    private static final int DEFAULT_BUFFER_SIZE = 256 * 1024;
+    private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.wrap(new byte[0]).asReadOnlyBuffer();
+    private static final boolean IS_CLEANING_SUPPORTED = ByteBufferCleaner.isSupported();
+    private final int bufferSize;
+    private final FileChannel channel;
+    private ByteBuffer buffer = EMPTY_BUFFER;
+    private boolean closed = false;
+    /**
+     * The starting position (within the file) of the next sliding buffer.
+     */
+    private long nextBufferPosition = 0;
+
+    public MemoryMappedFileInputStream(final Path file) throws IOException {
+        this(file, DEFAULT_BUFFER_SIZE);
+    }
+
+    public MemoryMappedFileInputStream(final Path file, final int bufferSize) throws IOException {","[{'comment': 'Please add a Javadoc comment: ""Constructs...""', 'commenter': 'garydgregory'}]"
278,src/main/java/org/apache/commons/io/output/BrokenWriter.java,"@@ -54,7 +55,17 @@ public BrokenWriter() {
      * @param exception the exception to be thrown
      */
     public BrokenWriter(final IOException exception) {
-        this.exception = exception;
+        this(() -> exception);
+    }
+
+    /**
+     * Creates a new writer that always throws an {@link IOException}.
+     *
+     * @param exceptionSupplier a supplier for the exception to be thrown","[{'comment': 'End sentences in a period.\r\n', 'commenter': 'garydgregory'}]"
278,src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java,"@@ -67,4 +67,18 @@ public void testSkip() {
         assertEquals(exception, assertThrows(IOException.class, () -> stream.skip(1)));
     }
 
+    @Test
+    public void testTryWithResources() {
+        IOException thrown = assertThrows(IOException.class, () -> {","[{'comment': 'Use final where you can.', 'commenter': 'garydgregory'}]"
278,src/test/java/org/apache/commons/io/input/BrokenReaderTest.java,"@@ -86,4 +86,19 @@ public void testSkip() {
         assertEquals(exception, assertThrows(IOException.class, () -> brokenReader.skip(1)));
     }
 
+    @Test
+    public void testTryWithResources() {
+        IOException thrown = assertThrows(IOException.class, () -> {
+            try (Reader newReader = new BrokenReader()) {
+                newReader.read();
+            }
+        });
+        assertEquals(""Broken reader"", thrown.getMessage());
+
+        Throwable[] suppressed = thrown.getSuppressed();","[{'comment': 'Use final where you can.', 'commenter': 'garydgregory'}]"
281,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -979,6 +981,39 @@ public static int copy(final InputStream inputStream, final OutputStream outputS
         return (int) count;
     }
 
+    /**
+     * Copies bytes from a {@link java.io.ByteArrayOutputStream} to a {@code QueueInputStream}.
+     * <p>
+     * Unlike using JDK {@link PipedInputStream} and {@link PipedOutputStream} for this, this solution works safely in a single thread
+     * environment.","[{'comment': 'The p HTML tag is still not closed.', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'SebastianDietrich'}]"
281,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -979,6 +981,40 @@ public static int copy(final InputStream inputStream, final OutputStream outputS
         return (int) count;
     }
 
+    /**
+     * Copies bytes from a {@link java.io.ByteArrayOutputStream} to a {@code QueueInputStream}.
+     * <p>
+     * Unlike using JDK {@link java.io.PipedInputStream} and {@link java.io.PipedOutputStream} for this, this
+     * solution works safely in a single thread environment.
+     * </p>
+     * <p>
+     * Example usage:
+     * </p>
+     *
+     * <pre>
+     * ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+     * outputStream.writeBytes(""hello world"".getBytes(UTF_8));
+     *
+     * InputStream inputStream = IOUtils.copy(outputStream);
+     * </pre>
+     *
+     * @param outputStream the {@link java.io.ByteArrayOutputStream} to read.
+     * @return the {@code QueueInputStream} filled with the content of the outputStream.
+     * @throws NullPointerException if the {@link java.io.ByteArrayOutputStream} is {@code null}.
+     * @throws IOException if an I/O error occurs.
+     * @since 2.12
+     */
+    @SuppressWarnings(""resource"") // streams are closed by the caller.
+    public static QueueInputStream copy(final java.io.ByteArrayOutputStream outputStream) throws IOException {
+        Objects.requireNonNull(outputStream, ""outputStream"");","[{'comment': 'This PR should test this path with an `assertThrows()`.', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'SebastianDietrich'}]"
281,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -979,6 +981,40 @@ public static int copy(final InputStream inputStream, final OutputStream outputS
         return (int) count;
     }
 
+    /**
+     * Copies bytes from a {@link java.io.ByteArrayOutputStream} to a {@code QueueInputStream}.
+     * <p>
+     * Unlike using JDK {@link java.io.PipedInputStream} and {@link java.io.PipedOutputStream} for this, this
+     * solution works safely in a single thread environment.
+     * </p>
+     * <p>
+     * Example usage:
+     * </p>
+     *
+     * <pre>
+     * ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+     * outputStream.writeBytes(""hello world"".getBytes(UTF_8));
+     *
+     * InputStream inputStream = IOUtils.copy(outputStream);
+     * </pre>
+     *
+     * @param outputStream the {@link java.io.ByteArrayOutputStream} to read.
+     * @return the {@code QueueInputStream} filled with the content of the outputStream.
+     * @throws NullPointerException if the {@link java.io.ByteArrayOutputStream} is {@code null}.
+     * @throws IOException if an I/O error occurs.
+     * @since 2.12
+     */
+    @SuppressWarnings(""resource"") // streams are closed by the caller.
+    public static QueueInputStream copy(final java.io.ByteArrayOutputStream outputStream) throws IOException {
+        Objects.requireNonNull(outputStream, ""outputStream"");
+
+        final QueueInputStream in = new QueueInputStream();
+        final QueueOutputStream out = in.newQueueOutputStream();","[{'comment': 'The `out` variable is not needed IMO.', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'SebastianDietrich'}]"
281,src/test/java/org/apache/commons/io/IOUtilsCopyTest.java,"@@ -80,6 +80,22 @@ public void testCopy_inputStreamToOutputStream() throws Exception {
         assertEquals(inData.length,count);
     }
 
+    @SuppressWarnings(""resource"") // 'in' is deliberately not closed
+    @Test
+    public void testCopy_byteArrayOutputStreamToInputStream() throws Exception {
+        final java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream();
+        out.write(inData);
+
+        final InputStream in = IOUtils.copy(out);
+
+        final byte[] inData2 = new byte[FILE_SIZE];
+        final int insize = in.read(inData2);
+
+        assertEquals(0, in.available(), ""Not all bytes were read"");
+        assertEquals(inData.length, insize, ""Sizes differ"");
+        assertArrayEquals(inData, inData2, ""Content differs"");
+    }","[{'comment': 'See above, missing test for null input using `assertThrows()`.\r\n', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'SebastianDietrich'}]"
281,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -979,6 +981,40 @@ public static int copy(final InputStream inputStream, final OutputStream outputS
         return (int) count;
     }
 
+    /**
+     * Copies bytes from a {@link java.io.ByteArrayOutputStream} to a {@code QueueInputStream}.
+     * <p>
+     * Unlike using JDK {@link java.io.PipedInputStream} and {@link java.io.PipedOutputStream} for this, this
+     * solution works safely in a single thread environment.
+     * </p>
+     * <p>
+     * Example usage:
+     * </p>
+     *
+     * <pre>
+     * ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+     * outputStream.writeBytes(""hello world"".getBytes(UTF_8));","[{'comment': 'Undefined constant: in example `UTF_8` -> `StandardCharsets.UTF_8`.', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'SebastianDietrich'}]"
281,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -979,6 +981,40 @@ public static int copy(final InputStream inputStream, final OutputStream outputS
         return (int) count;
     }
 
+    /**
+     * Copies bytes from a {@link java.io.ByteArrayOutputStream} to a {@code QueueInputStream}.
+     * <p>
+     * Unlike using JDK {@link java.io.PipedInputStream} and {@link java.io.PipedOutputStream} for this, this
+     * solution works safely in a single thread environment.
+     * </p>
+     * <p>
+     * Example usage:
+     * </p>
+     *
+     * <pre>
+     * ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+     * outputStream.writeBytes(""hello world"".getBytes(UTF_8));
+     *
+     * InputStream inputStream = IOUtils.copy(outputStream);
+     * </pre>
+     *
+     * @param outputStream the {@link java.io.ByteArrayOutputStream} to read.
+     * @return the {@code QueueInputStream} filled with the content of the outputStream.
+     * @throws NullPointerException if the {@link java.io.ByteArrayOutputStream} is {@code null}.
+     * @throws IOException if an I/O error occurs.
+     * @since 2.12
+     */
+    @SuppressWarnings(""resource"") // streams are closed by the caller.
+    public static QueueInputStream copy(final java.io.ByteArrayOutputStream outputStream) throws IOException {","[{'comment': 'Import ByteArrayOutputStream instead of using a FQCN.', 'commenter': 'garydgregory'}, {'comment': 'That is not possible, since org.apache.commons.io.output.ByteArrayOutputStream is imported and used throughout IOUtils', 'commenter': 'SebastianDietrich'}]"
281,src/test/java/org/apache/commons/io/IOUtilsCopyTest.java,"@@ -80,6 +80,22 @@ public void testCopy_inputStreamToOutputStream() throws Exception {
         assertEquals(inData.length,count);
     }
 
+    @SuppressWarnings(""resource"") // 'in' is deliberately not closed
+    @Test
+    public void testCopy_byteArrayOutputStreamToInputStream() throws Exception {
+        final java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream();","[{'comment': 'Here, using the FQCN is required since this test class imports `org.apache.commons.io.output.ByteArrayOutputStream`.', 'commenter': 'garydgregory'}, {'comment': 'Gotcha, please see the other comments.', 'commenter': 'garydgregory'}]"
291,src/main/java/org/apache/commons/io/input/ReaderInputStream.java,"@@ -129,6 +128,9 @@ public ReaderInputStream(final Reader reader) {
      * Constructs a new {@link ReaderInputStream} with a default input buffer size of {@value #DEFAULT_BUFFER_SIZE}
      * characters.
      *
+     * <p>The encoder created for the specified charset will use {@link CodingErrorAction#REPLACE} for malformed input
+     * and unmappable characters.
+     *","[{'comment': 'Close HTML tags.', 'commenter': 'garydgregory'}, {'comment': 'Have also moved the `<p>` on a separate line to match the style used above for the class documentation.', 'commenter': 'Marcono1234'}]"
291,src/main/java/org/apache/commons/io/input/ReaderInputStream.java,"@@ -156,6 +161,9 @@ public ReaderInputStream(final Reader reader, final Charset charset, final int b
     /**
      * Constructs a new {@link ReaderInputStream}.
      *
+     * <p>This constructor does not call {@link CharsetEncoder#reset() reset} on the provided encoder. The caller
+     * of this constructor should do this when providing an encoder which had already been in use.
+     *","[{'comment': 'Close HTML tags.', 'commenter': 'garydgregory'}]"
291,src/main/java/org/apache/commons/io/input/ReaderInputStream.java,"@@ -185,6 +196,9 @@ public ReaderInputStream(final Reader reader, final CharsetEncoder charsetEncode
      * Constructs a new {@link ReaderInputStream} with a default input buffer size of {@value #DEFAULT_BUFFER_SIZE}
      * characters.
      *
+     * <p>The encoder created for the specified charset will use {@link CodingErrorAction#REPLACE} for malformed input
+     * and unmappable characters.
+     *","[{'comment': 'Close HTML tags.', 'commenter': 'garydgregory'}]"
291,src/main/java/org/apache/commons/io/input/ReaderInputStream.java,"@@ -213,6 +230,16 @@ public void close() throws IOException {
         reader.close();
     }
 
+    /**
+     * The implementation by {@link ReaderInputStream} always returns 0.
+     */
+    @Override
+    public int available() throws IOException {
+        // Could implement this using Reader.ready(), but would be rather cumbersome
+        // and probably not very efficient
+        return 0;
+    }
+","[{'comment': 'This PR is only supposed to be about docs as stated in the PR title. Furthermore this change is not matched with a unit test.', 'commenter': 'garydgregory'}, {'comment': 'This class directly extends `InputStream` and the [`InputStream.available()` documentation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html#available()) says:\r\n> The available method of InputStream always returns 0.\r\n\r\nI could have used `return super.available();` instead, but then it would be less obvious to the reader why the documentation of this method here says that it always returns 0 but calls `super.available()`. So I wanted to avoid requiring them to look up the super implementation to verify that this method behaves correctly.', 'commenter': 'Marcono1234'}, {'comment': ""Please drop this method, it duplicates the superclass' implementation.\r\n"", 'commenter': 'garydgregory'}, {'comment': 'ping.', 'commenter': 'garydgregory'}, {'comment': 'Sorry; have removed this method again now in the latest commit.', 'commenter': 'Marcono1234'}]"
291,src/main/java/org/apache/commons/io/input/ReaderInputStream.java,"@@ -195,6 +209,9 @@ public ReaderInputStream(final Reader reader, final String charsetName) {
     /**
      * Constructs a new {@link ReaderInputStream}.
      *
+     * <p>The encoder created for the specified charset will use {@link CodingErrorAction#REPLACE} for malformed input
+     * and unmappable characters.
+     *","[{'comment': 'Close HTML tags.', 'commenter': 'garydgregory'}]"
295,src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java,"@@ -39,9 +43,9 @@
  * By default, the file will be overwritten, but this may be changed to append.
  * </p>
  * <p>
- * The encoding must be specified using either the name of the {@link Charset}, the {@link Charset}, or a
- * {@link CharsetEncoder}. If the default encoding is required then use the {@link java.io.FileWriter} directly, rather
- * than this implementation.
+ * The encoding should be specified using either the name of the {@link Charset}, the {@link Charset}, or a
+ * {@link CharsetEncoder}. Otherwise, the default {@link Charset} will be used, but if this is required then","[{'comment': '"" but if this is required then"" when I read this got confused as to what ""this"" is and it is only by reading the original text that I understood. So either make it clear or make it extra clear: Either use FileWriter or Charset.defaultCharset().', 'commenter': 'garydgregory'}]"
295,src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java,"@@ -53,25 +57,34 @@
     /**
      * Initializes the wrapped file writer. Ensure that a cleanup occurs if the writer creation fails.
      *
-     * @param file the file to be accessed
-     * @param encoding the encoding to use - may be Charset, CharsetEncoder or String, null uses the default Charset.
-     * @param append true to append
-     * @return the initialized writer
-     * @throws IOException if an error occurs
+     * @param file the file to be accessed.
+     * @param encoding the encoding to use - may be Charset, CharsetEncoder or String, null or unrecognized uses the default Charset.","[{'comment': '""null or unrecognized uses the default Charset"": What does ""unrecognized"" mean? This change is confusing to me.', 'commenter': 'garydgregory'}]"
295,src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java,"@@ -81,20 +94,46 @@ private static Writer initWriter(final File file, final Object encoding, final b
             if (!fileExistedAlready) {
                 FileUtils.deleteQuietly(file);
             }
-            throw ex;
+            if (ex instanceof UnsupportedCharsetException) {
+                throw new IOException(ex);","[{'comment': 'Why make this more complicated?', 'commenter': 'garydgregory'}, {'comment': 'Closing, no reply since November of last year.\r\n', 'commenter': 'garydgregory'}]"
296,src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java,"@@ -46,9 +46,53 @@
  *
  * @since 1.4
  */
-public class FileWriterWithEncoding extends Writer {
-    // Cannot extend ProxyWriter, as requires writer to be
-    // known when super() is called
+public class FileWriterWithEncoding extends ProxyWriter {
+
+    private static final Writer NULL_WRITER = new Writer() {","[{'comment': ""Not sure if it's handling `null`s, or being used when some value is `null`. But maybe `NOOP_WRITER` would be a better name?"", 'commenter': 'kinow'}, {'comment': ""Just saw your comment about the `Writer.nullWriter()`, I guess that's where you got the name from :+1: no need to change it."", 'commenter': 'kinow'}]"
296,src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java,"@@ -160,7 +209,11 @@ public FileWriterWithEncoding(final File file, final String charsetName) throws
      * @throws IOException in case of an I/O error.
      */
     public FileWriterWithEncoding(final File file, final String charsetName, final boolean append) throws IOException {
-        this.out = initWriter(file, charsetName, append);
+        super(NULL_WRITER);
+
+        super.out = initWriter(file, charsetName, append);","[{'comment': 'Ah, I think now I understand this pull request.\r\n\r\n@wodencafe I think we pass the `NULL_WRITER` to the parent `ProxyWriter` as a way to give it a valid object. But in reality, that `NULL_WRITER` is then replaced here when we call `super.out = ....`.\r\n\r\nWhile I guess that would work, but not sure if modifying setting `super.out` twice (once after the `super(NULL_WRITER)`, then here :point_up: ) would be the best approach.', 'commenter': 'kinow'}]"
296,src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java,"@@ -245,7 +240,7 @@ public FileWriterWithEncoding(final String fileName, final String charsetName, f
      */","[{'comment': '@wodencafe do we need to override the methods below? Could we just use the parent methods directly?', 'commenter': 'kinow'}, {'comment': 'Good point, we should just let the super class handle it.', 'commenter': 'wodencafe'}]"
296,src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java,"@@ -59,7 +57,7 @@
      * @return the initialized writer
      * @throws IOException if an error occurs
      */
-    private static Writer initWriter(final File file, final Object encoding, final boolean append) throws IOException {
+    private static final Writer initWriter(final File file, final Object encoding, final boolean append) throws IOException {","[{'comment': ""This one is not really necessary @wodencafe ? `initWriter` is already private, so making it `final` won't change much for internal/external devs?"", 'commenter': 'kinow'}, {'comment': 'I usually do this out of habit, but after doing some research it seems that there is no functional difference for adding the `final` modifier to a private static nested class. It has been removed.', 'commenter': 'wodencafe'}]"
343,src/test/java/org/apache/commons/io/IOUtilsTest.java,"@@ -1643,5 +1644,19 @@ public void testToString_URL_CharsetName() throws Exception {
     public void testToString_URL_CharsetNameNull() throws Exception {
         testToString_URL(null);
     }
+    
+    @Test
+    public void testBigString() throws IOException {
+       String foo = StringUtils.repeat(""\uD83D"", (Integer.MAX_VALUE)/2-1);
+       
+       OutputStream dummyStream = new OutputStream() {","[{'comment': '- Use final where you can.\r\n- Use NullOutputStream instead of custom code\r\n- Use CountingOutputStream to at least validate that we wrote the proper amount of data.\r\n- Try to use mocking to insure the right thing happened\r\n- Even try to use mocking (Mockito and/or Powermock) to see if you can mock the string test fixture.', 'commenter': 'garydgregory'}]"
343,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -3362,7 +3364,12 @@ public static void write(final String data, final OutputStream output)
      */
     public static void write(final String data, final OutputStream output, final Charset charset) throws IOException {
         if (data != null) {
-            output.write(data.getBytes(Charsets.toCharset(charset)));
+            Charset usableCharset = Charsets.toCharset(charset);","[{'comment': '- Needs comments as to why the implementation changed and is what it is since we do not want someone else to come and ""simplify"" the code. In-line locals.', 'commenter': 'garydgregory'}]"
343,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -3362,7 +3364,12 @@ public static void write(final String data, final OutputStream output)
      */
     public static void write(final String data, final OutputStream output, final Charset charset) throws IOException {
         if (data != null) {
-            output.write(data.getBytes(Charsets.toCharset(charset)));
+            Charset usableCharset = Charsets.toCharset(charset);
+            ByteBuffer bytebuffer = usableCharset.encode(data);
+            
+            try (WritableByteChannel channel = Channels.newChannel(output)){
+               channel.write(bytebuffer);
+            }","[{'comment': 'This incorrectly closes the output stream. Run a full build or just `IOUtilsWriteTest`:\r\n```\r\nIOUtilsWriteTest\r\norg.apache.commons.io.IOUtilsWriteTest\r\ntestWrite_charSequenceToOutputStream_nullEncoding(org.apache.commons.io.IOUtilsWriteTest)\r\norg.opentest4j.AssertionFailedError: ThrowOnFlushAndCloseOutputStream.close() called.\r\n\tat org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:39)\r\n\tat org.junit.jupiter.api.Assertions.fail(Assertions.java:134)\r\n\tat org.apache.commons.io.test.ThrowOnFlushAndCloseOutputStream.close(ThrowOnFlushAndCloseOutputStream.java:50)\r\n\tat java.nio.channels.Channels$WritableByteChannelImpl.implCloseChannel(Channels.java:469)\r\n\tat java.nio.channels.spi.AbstractInterruptibleChannel.close(AbstractInterruptibleChannel.java:115)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3372)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3285)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3311)\r\n\tat org.apache.commons.io.IOUtilsWriteTest.testWrite_charSequenceToOutputStream_nullEncoding(IOUtilsWriteTest.java:348)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725)\r\n\tat org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1259)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1259)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:95)\r\n\tat org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:91)\r\n\tat org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:60)\r\n\tat org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:98)\r\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:40)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:529)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:756)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:452)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210)\r\n\r\ntestWrite_charSequenceToOutputStream(org.apache.commons.io.IOUtilsWriteTest)\r\norg.opentest4j.AssertionFailedError: ThrowOnFlushAndCloseOutputStream.close() called.\r\n\tat org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:39)\r\n\tat org.junit.jupiter.api.Assertions.fail(Assertions.java:134)\r\n\tat org.apache.commons.io.test.ThrowOnFlushAndCloseOutputStream.close(ThrowOnFlushAndCloseOutputStream.java:50)\r\n\tat java.nio.channels.Channels$WritableByteChannelImpl.implCloseChannel(Channels.java:469)\r\n\tat java.nio.channels.spi.AbstractInterruptibleChannel.close(AbstractInterruptibleChannel.java:115)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3372)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3285)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3265)\r\n\tat org.apache.commons.io.IOUtilsWriteTest.testWrite_charSequenceToOutputStream(IOUtilsWriteTest.java:287)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725)\r\n\tat org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1259)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1259)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:95)\r\n\tat org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:91)\r\n\tat org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:60)\r\n\tat org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:98)\r\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:40)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:529)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:756)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:452)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210)\r\n\r\ntestWrite_charSequenceToOutputStream_Encoding(org.apache.commons.io.IOUtilsWriteTest)\r\norg.opentest4j.AssertionFailedError: ThrowOnFlushAndCloseOutputStream.close() called.\r\n\tat org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:39)\r\n\tat org.junit.jupiter.api.Assertions.fail(Assertions.java:134)\r\n\tat org.apache.commons.io.test.ThrowOnFlushAndCloseOutputStream.close(ThrowOnFlushAndCloseOutputStream.java:50)\r\n\tat java.nio.channels.Channels$WritableByteChannelImpl.implCloseChannel(Channels.java:469)\r\n\tat java.nio.channels.spi.AbstractInterruptibleChannel.close(AbstractInterruptibleChannel.java:115)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3372)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3285)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3311)\r\n\tat org.apache.commons.io.IOUtilsWriteTest.testWrite_charSequenceToOutputStream_Encoding(IOUtilsWriteTest.java:302)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725)\r\n\tat org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1259)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1259)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:95)\r\n\tat org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:91)\r\n\tat org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:60)\r\n\tat org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:98)\r\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:40)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:529)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:756)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:452)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210)\r\n\r\ntestWrite_stringToOutputStream_nullEncoding(org.apache.commons.io.IOUtilsWriteTest)\r\norg.opentest4j.AssertionFailedError: ThrowOnFlushAndCloseOutputStream.close() called.\r\n\tat org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:39)\r\n\tat org.junit.jupiter.api.Assertions.fail(Assertions.java:134)\r\n\tat org.apache.commons.io.test.ThrowOnFlushAndCloseOutputStream.close(ThrowOnFlushAndCloseOutputStream.java:50)\r\n\tat java.nio.channels.Channels$WritableByteChannelImpl.implCloseChannel(Channels.java:469)\r\n\tat java.nio.channels.spi.AbstractInterruptibleChannel.close(AbstractInterruptibleChannel.java:115)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3372)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3398)\r\n\tat org.apache.commons.io.IOUtilsWriteTest.testWrite_stringToOutputStream_nullEncoding(IOUtilsWriteTest.java:467)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725)\r\n\tat org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1259)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1259)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:95)\r\n\tat org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:91)\r\n\tat org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:60)\r\n\tat org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:98)\r\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:40)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:529)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:756)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:452)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210)\r\n\r\ntestWrite_stringToOutputStream_Encoding(org.apache.commons.io.IOUtilsWriteTest)\r\norg.opentest4j.AssertionFailedError: ThrowOnFlushAndCloseOutputStream.close() called.\r\n\tat org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:39)\r\n\tat org.junit.jupiter.api.Assertions.fail(Assertions.java:134)\r\n\tat org.apache.commons.io.test.ThrowOnFlushAndCloseOutputStream.close(ThrowOnFlushAndCloseOutputStream.java:50)\r\n\tat java.nio.channels.Channels$WritableByteChannelImpl.implCloseChannel(Channels.java:469)\r\n\tat java.nio.channels.spi.AbstractInterruptibleChannel.close(AbstractInterruptibleChannel.java:115)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3372)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3398)\r\n\tat org.apache.commons.io.IOUtilsWriteTest.testWrite_stringToOutputStream_Encoding(IOUtilsWriteTest.java:421)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725)\r\n\tat org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1259)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1259)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:95)\r\n\tat org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:91)\r\n\tat org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:60)\r\n\tat org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:98)\r\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:40)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:529)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:756)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:452)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210)\r\n\r\ntestWrite_stringToOutputStream(org.apache.commons.io.IOUtilsWriteTest)\r\norg.opentest4j.AssertionFailedError: ThrowOnFlushAndCloseOutputStream.close() called.\r\n\tat org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:39)\r\n\tat org.junit.jupiter.api.Assertions.fail(Assertions.java:134)\r\n\tat org.apache.commons.io.test.ThrowOnFlushAndCloseOutputStream.close(ThrowOnFlushAndCloseOutputStream.java:50)\r\n\tat java.nio.channels.Channels$WritableByteChannelImpl.implCloseChannel(Channels.java:469)\r\n\tat java.nio.channels.spi.AbstractInterruptibleChannel.close(AbstractInterruptibleChannel.java:115)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3372)\r\n\tat org.apache.commons.io.IOUtils.write(IOUtils.java:3348)\r\n\tat org.apache.commons.io.IOUtilsWriteTest.testWrite_stringToOutputStream(IOUtilsWriteTest.java:406)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725)\r\n\tat org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)\r\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)\r\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1259)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1259)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)\r\n\tat org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:95)\r\n\tat org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:91)\r\n\tat org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:60)\r\n\tat org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:98)\r\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:40)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:529)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:756)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:452)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210)\r\n\r\n\r\n```', 'commenter': 'garydgregory'}]"
343,src/test/java/org/apache/commons/io/IOUtilsTest.java,"@@ -1643,5 +1644,19 @@ public void testToString_URL_CharsetName() throws Exception {
     public void testToString_URL_CharsetNameNull() throws Exception {
         testToString_URL(null);
     }
+    
+    @Test
+    public void testBigString() throws IOException {
+       String foo = StringUtils.repeat(""\uD83D"", (Integer.MAX_VALUE)/2-1);","[{'comment': 'No shared CI will provide you these resources.', 'commenter': 'michael-o'}, {'comment': '> No shared CI will provide you these resources.\r\n\r\nHi @michael-o \r\nI wrote a different version of the test that is less resource-intensive and more lenient. See git master. The main code is still broken though.', 'commenter': 'garydgregory'}]"
358,src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java,"@@ -350,6 +360,22 @@ public void testWriteZero(final String baosName, final BAOSFactory<?> baosFactor
         }
     }
 
+    private static final int FILE_SIZE = (1024 * 4) + 1;
+    private final byte[] inData = TestUtils.generateTestData(FILE_SIZE);","[{'comment': 'These data do not need to be tracked for all tests. Move them inside the one method that use them.', 'commenter': 'garydgregory'}]"
358,src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java,"@@ -350,6 +360,22 @@ public void testWriteZero(final String baosName, final BAOSFactory<?> baosFactor
         }
     }
 
+    private static final int FILE_SIZE = (1024 * 4) + 1;
+    private final byte[] inData = TestUtils.generateTestData(FILE_SIZE);
+
+    @Test
+    public void testToByteArrayImplAndResetImpl() throws Exception {
+        InputStream in = new ByteArrayInputStream(inData);","[{'comment': 'Use try with resources when possible.\r\n', 'commenter': 'garydgregory'}]"
358,src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java,"@@ -350,6 +358,22 @@ public void testWriteZero(final String baosName, final BAOSFactory<?> baosFactor
         }
     }
 
+    @Test
+    public void testToByteArrayImplAndResetImpl() throws Exception {
+        final int file_size = (1024 * 4) + 1;","[{'comment': '- No underscore in local variable names. \r\n- No need for spelling out 4097 in an expression.', 'commenter': 'garydgregory'}]"
358,src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java,"@@ -350,6 +358,22 @@ public void testWriteZero(final String baosName, final BAOSFactory<?> baosFactor
         }
     }
 
+    @Test
+    public void testToByteArrayImplAndResetImpl() throws Exception {
+        final int file_size = (1024 * 4) + 1;
+        final byte[] inData = TestUtils.generateTestData(file_size);
+        try (InputStream in = new ByteArrayInputStream(inData)) {
+            try (ByteArrayOutputStream baout = new ByteArrayOutputStream()) {
+                try (Writer writer = new OutputStreamWriter(baout, StandardCharsets.US_ASCII)) {
+                    CopyUtils.copy(in, writer);
+                    writer.flush();
+                }
+                baout.reset();
+                Assertions.assertEquals("""", baout.toString());","[{'comment': 'No need for Assertions prefix static in a test method. Use the other methods in this file as a style guide.', 'commenter': 'garydgregory'}]"
367,src/main/java/org/apache/commons/io/StandardLineSeparator.java,"@@ -28,7 +28,7 @@
 public enum StandardLineSeparator {
 
     /**
-     * Carriage return. This is the line ending used on Macos 9 and earlier.
+     * Carriage return. This is the line ending used on Mac OS 9 and earlier.","[{'comment': 'The proper spelling per Apple is ""macOS""', 'commenter': 'garydgregory'}, {'comment': 'It is now, but it was not when Mac OS 9 was released (cf. https://en.wikipedia.org/wiki/Mac_OS_9).', 'commenter': 'marcwrobel'}]"
367,src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java,"@@ -404,7 +404,7 @@ public String readLine() throws IOException {
         while (line == null) {
             currentFilePart = currentFilePart.rollOver();
             if (currentFilePart == null) {
-                // no more fileparts: we're done, leave line set to null
+                // no more fileParts: we're done, leave line set to null","[{'comment': 'This is still wrong: The type name is `FilePart`.', 'commenter': 'garydgregory'}, {'comment': 'Done.', 'commenter': 'marcwrobel'}]"
374,src/test/java/org/apache/commons/io/IOUtilsTest.java,"@@ -1716,4 +1716,18 @@ public void testWriteLittleString() throws IOException {
         }
     }
 
+    @Test
+    public void testByteArrayWithIllegalSize() {
+        try {
+            int size = -1;
+            byte[] bytes = IOUtils.byteArray(size);
+
+            size = 0;
+            bytes = IOUtils.byteArray(size);
+        }catch (Exception e) {
+            assertEquals(e.getClass().getName(), IllegalArgumentException.class.getName());
+        }","[{'comment': ""I think instead it could use JUnit's `@Test(expected=IllegalArgumentException.class)`, or `assertThrows`."", 'commenter': 'kinow'}, {'comment': 'And I think when the first exception happens, the second is part of the test is never executed? Probably needs to be broken down into two separate tests, maybe with `@ParameterizedTest` too.', 'commenter': 'kinow'}, {'comment': 'ok, I changed IOUtilsTest.testByteArrayWithIllegalSize() with @ParameterizedTest.\r\nyou can review the code.', 'commenter': 'ArdenL-Liu'}, {'comment': 'Why would we trade a more vague exception when the JVM throws a more precise and quite specific exception? Maybe this issue can be simplified with better Javadoc? This PR would also introduce an inconsistency since other places would throw the JVM exception. ', 'commenter': 'garydgregory'}, {'comment': 'Hi garydgregory,\r\n    Thank you for your good suggestion, I updated the doc and changed the unittest, you can review it again.\r\n', 'commenter': 'ArdenL-Liu'}, {'comment': 'In order to improve my work efficiency，I will study github workflow in the next week.', 'commenter': 'ArdenL-Liu'}]"
374,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -346,9 +346,15 @@ public static byte[] byteArray() {
      *
      * @param size array size.
      * @return a new byte array of the given size.
+     *
+     * @exception  IllegalArgumentException  If {@code size <= 0}","[{'comment': '`@throws` instead of `@exception`', 'commenter': 'kinow'}, {'comment': 'Thx, update it with @throws ', 'commenter': 'ArdenL-Liu'}]"
374,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -3724,7 +3724,9 @@ public static Writer writer(final Appendable appendable) {
 
     /**
      * Instances should NOT be constructed in standard programming.
+     * @deprecated Will be private in 3.0.
      */
+    @Deprecated","[{'comment': ""This is doing more than what's described in the PR title. Maybe worth moving to a separate PR to make it easier to track in the changelog."", 'commenter': 'kinow'}, {'comment': 'Thx, I will rollback it', 'commenter': 'ArdenL-Liu'}, {'comment': 'Can you remove this deprecation as @kinow requested?', 'commenter': 'pjfanning'}, {'comment': ""Wait... this deprecation is fine. It's slightly out of scope for the PR but it's fine."", 'commenter': 'garydgregory'}]"
374,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -3537,9 +3537,7 @@ public static void writeStringToFile(final File file, final String data, final S
 
     /**
      * Instances should NOT be constructed in standard programming.
-     * @deprecated Will be private in 3.0.
      */
-    @Deprecated","[{'comment': 'Should this `@Deprecated` be removed? There was a comment to remove a different `@Deprecated` but this one should be kept.', 'commenter': 'pjfanning'}, {'comment': 'rollback it', 'commenter': 'ArdenL-Liu'}, {'comment': ""-1: Don't remove this tag,"", 'commenter': 'garydgregory'}, {'comment': 'this is not resolved - you have still removed a comment that was in the code before - can you put it back?', 'commenter': 'pjfanning'}, {'comment': 'The `@deprecated` tag should NOT be removed.', 'commenter': 'garydgregory'}, {'comment': 'Hi All,\r\n     sorry for my error operation, I fixed the doc and add @deprecated tag about FileUtils.\r\n', 'commenter': 'ArdenL-Liu'}]"
374,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -341,6 +341,7 @@ public static byte[] byteArray() {
 
     /**
      * Returns a new byte array of the given size.
+     * Throws java.lang.NegativeArraySizeException if the size is negative.","[{'comment': 'This is in the wrong place, use a throws tag.', 'commenter': 'garydgregory'}, {'comment': 'Hi garydgregory,\r\n   I fixed it with @throws, you can review it again. ', 'commenter': 'ArdenL-Liu'}]"
374,src/test/java/org/apache/commons/io/IOUtilsTest.java,"@@ -1716,4 +1718,12 @@ public void testWriteLittleString() throws IOException {
         }
     }
 
+    @Test
+    public void testByteArrayWithNegativeSize() {
+        int size = -1;
+        assertThrows(NegativeArraySizeException.class,() -> {","[{'comment': 'You can just say `assertThrows(NegativeArraySizeException.class,() -> IOUtils.byteArray(-1));` but I am not even sure we should have this test since it does not improve our code coverage, it just test what the JVM does. @kinow , any thoughts?', 'commenter': 'garydgregory'}, {'comment': 'Hi garydgregory,\r\n    from your comments, I checked the code and fixed again, you can review it again.\r\nThanks.\r\n', 'commenter': 'ArdenL-Liu'}]"
374,src/test/java/org/apache/commons/io/IOUtilsTest.java,"@@ -79,6 +79,8 @@
 import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.io.TempDir;
+import org.junit.jupiter.params.ParameterizedTest;","[{'comment': '-1: Unused. Run `mvn` from the command line before pushing a PR to catch these issues.', 'commenter': 'garydgregory'}]"
374,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -346,6 +346,7 @@ public static byte[] byteArray() {
      *
      * @param size array size.
      * @return a new byte array of the given size.
+     * @throws NegativeArraySizeException if the size is negative.","[{'comment': 'This PR seems ok to me now except for this addition. We do not document this type of JVM exception anywhere else IIRC. If we were to doc this, then it would make sense to doc all callers as well, then this would touch almost everything which would not help anyone IMO.', 'commenter': 'garydgregory'}, {'comment': ""As yours, this is why I want to add throws NegativeArraySizeException tag to this method,  In fact, in order to help  users to use and understand these methods,  I think we should add it to the doc of  all the methods like it. \r\nOf course , we can add the parameters validation  to the head position of the method's logic.  some methods do it, such as : read(...., int), skip(... ,int).  \r\n"", 'commenter': 'ArdenL-Liu'}]"
374,src/test/java/org/apache/commons/io/IOUtilsTest.java,"@@ -16,40 +16,20 @@
  */
 package org.apache.commons.io;
 
-import static org.junit.jupiter.api.Assertions.assertArrayEquals;","[{'comment': 'Remove noise in the PR: There is no need to update these imports.', 'commenter': 'garydgregory'}]"
374,src/test/java/org/apache/commons/io/IOUtilsTest.java,"@@ -60,25 +40,7 @@
 import java.util.List;
 import java.util.stream.Stream;
 
-import org.apache.commons.io.function.IOConsumer;
-import org.apache.commons.io.input.BrokenInputStream;
-import org.apache.commons.io.input.CircularInputStream;
-import org.apache.commons.io.input.NullInputStream;
-import org.apache.commons.io.input.NullReader;
-import org.apache.commons.io.input.StringInputStream;
-import org.apache.commons.io.output.AppendableWriter;
-import org.apache.commons.io.output.BrokenOutputStream;
-import org.apache.commons.io.output.CountingOutputStream;
-import org.apache.commons.io.output.NullOutputStream;
-import org.apache.commons.io.output.NullWriter;
-import org.apache.commons.io.output.StringBuilderWriter;
-import org.apache.commons.io.test.TestUtils;
-import org.apache.commons.io.test.ThrowOnCloseReader;
-import org.apache.commons.lang3.StringUtils;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Disabled;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.io.TempDir;
+import static org.junit.jupiter.api.Assertions.*;","[{'comment': '""*"" imports are a no go', 'commenter': 'garydgregory'}, {'comment': 'fixed', 'commenter': 'ArdenL-Liu'}]"
391,src/main/java/org/apache/commons/io/input/SequenceReader.java,"@@ -16,13 +16,13 @@
  */
 package org.apache.commons.io.input;
 
-import static org.apache.commons.io.IOUtils.EOF;
+import org.apache.commons.io.IOExceptionList;
 
 import java.io.IOException;
 import java.io.Reader;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.Objects;
+import java.util.*;
+
+import static org.apache.commons.io.IOUtils.EOF;","[{'comment': 'Do not reorder the imports please.', 'commenter': 'garydgregory'}]"
391,src/main/java/org/apache/commons/io/input/SequenceReader.java,"@@ -33,19 +36,21 @@ public class SequenceReader extends Reader {
 
     private Reader reader;
     private Iterator<? extends Reader> readers;
+    private Iterable<? extends Reader> readersIterable;
 
     /**
-     * Constructs a new instance with readers
+     * Construct a new instance with readers","[{'comment': ""Don't change the style of the Javadoc please. In general, don't change the style of anything when a PR is supposed to fix a bug.\r\n"", 'commenter': 'garydgregory'}]"
391,src/test/java/org/apache/commons/io/input/SequenceReaderTest.java,"@@ -56,14 +60,86 @@ private void checkReadEof(final Reader reader) throws IOException {
     }
 
     @Test
-    public void testClose() throws IOException {
+    public void testAutoClose() throws IOException {
         try (Reader reader = new SequenceReader(new CharSequenceReader(""FooBar""))) {
             checkRead(reader, ""Foo"");
             reader.close();
             checkReadEof(reader);
         }
     }
 
+    @Test
+    public void testClose() throws IOException {
+        final Reader reader = new SequenceReader(new CharSequenceReader(""FooBar""));
+        checkRead(reader, ""Foo"");
+        reader.close();
+        checkReadEof(reader);
+    }
+
+    @Test
+    public void testCloseReaders() {
+        final AtomicBoolean closeEmptyReader = new AtomicBoolean(false);
+        final Reader emptyReader = new Reader() {
+            @Override
+            public int read(char[] cbuf, int off, int len) throws IOException {
+                if (closeEmptyReader.get()) {
+                    throw new IOException(""emptyReader already closed"");
+                }
+
+                return EOF;
+            }
+
+            @Override
+            public void close() throws IOException {
+                closeEmptyReader.set(true);
+            }
+        };
+
+        final AtomicBoolean closeReader1 = new AtomicBoolean(false);
+        final Reader reader1 = new Reader() {
+            private final char[] content = new char[]{'A'};
+            private int position = 0;
+
+            @Override
+            public int read(char[] cbuf, int off, int len) throws IOException {
+                if (closeReader1.get()) {
+                    throw new IOException(""reader1 already closed"");
+                }
+
+                if (off < 0) {
+                    throw new IndexOutOfBoundsException(""off is negative"");
+                } else if (len < 0) {
+                    throw new IndexOutOfBoundsException(""len is negative"");
+                } else if (len > cbuf.length - off) {
+                    throw new IndexOutOfBoundsException(""len is greater than cbuf.length - off"");
+                }
+
+                if (position > 0) {
+                    return EOF;
+                }
+
+                cbuf[off] = content[0];
+                position++;
+                return 1;
+            }
+
+            @Override
+            public void close() throws IOException {
+                closeReader1.set(true);
+            }
+        };
+
+        try (SequenceReader sequenceReader = new SequenceReader(reader1, emptyReader)) {
+            assertEquals('A', sequenceReader.read());
+            assertEquals(EOF, sequenceReader.read());
+        } catch (IOException e) {
+            fail(""No IOException expected"");","[{'comment': 'Why not just let the exception percolate to fail the test?', 'commenter': 'garydgregory'}, {'comment': ""That's another option, it was just to have a meaningful message on fail"", 'commenter': 'digiovinazzo'}, {'comment': ""Simpler is better:\r\n```\r\n        try (SequenceReader sequenceReader = new SequenceReader(reader1, emptyReader)) {\r\n            assertEquals('A', sequenceReader.read());\r\n            assertEquals(EOF, sequenceReader.read());\r\n        } finally {\r\n            assertTrue(closeEmptyReader.get());\r\n            assertTrue(closeReader1.get());\r\n        }\r\n```"", 'commenter': 'garydgregory'}]"
391,src/main/java/org/apache/commons/io/input/SequenceReader.java,"@@ -33,19 +36,21 @@ public class SequenceReader extends Reader {
 
     private Reader reader;
     private Iterator<? extends Reader> readers;
+    private Iterable<? extends Reader> readersIterable;
 
     /**
      * Constructs a new instance with readers
      *
      * @param readers the readers to read
      */
     public SequenceReader(final Iterable<? extends Reader> readers) {
-        this.readers = Objects.requireNonNull(readers, ""readers"").iterator();
+        this.readersIterable = Objects.requireNonNull(readers, ""readers"");
+        this.readers = readers.iterator();
         this.reader = nextReader();
     }
 
     /**
-     * Constructs a new instance with readers
+     * Construct a new instance with readers","[{'comment': ""Don't change the Javadoc style please."", 'commenter': 'garydgregory'}]"
391,src/main/java/org/apache/commons/io/input/SequenceReader.java,"@@ -60,8 +65,26 @@ public SequenceReader(final Reader... readers) {
      */
     @Override
     public void close() throws IOException {
+        if (readersIterable == null) {
+            // already closed
+            return;
+        }
+
+        final List<IOException> ioExceptionList = new ArrayList<>();
+        for (Reader reader : readersIterable) {
+            try {
+                reader.close();
+            } catch (IOException e) {
+                ioExceptionList.add(e);","[{'comment': ""I'm not sure about the semantics here, which are completely different from `SequenceInputStream`. For good or bad, I think it would be better for the closing logic of this class to match `SequenceInputStream`."", 'commenter': 'garydgregory'}]"
391,src/main/java/org/apache/commons/io/input/SequenceReader.java,"@@ -33,14 +36,16 @@ public class SequenceReader extends Reader {
 
     private Reader reader;
     private Iterator<? extends Reader> readers;
+    private Iterable<? extends Reader> readersIterable;","[{'comment': 'No need to change the name, it makes the PR noisier.', 'commenter': 'garydgregory'}]"
391,src/test/java/org/apache/commons/io/input/SequenceReaderTest.java,"@@ -56,14 +60,86 @@ private void checkReadEof(final Reader reader) throws IOException {
     }
 
     @Test
-    public void testClose() throws IOException {
+    public void testAutoClose() throws IOException {
         try (Reader reader = new SequenceReader(new CharSequenceReader(""FooBar""))) {
             checkRead(reader, ""Foo"");
             reader.close();
             checkReadEof(reader);
         }
     }
 
+    @Test
+    public void testClose() throws IOException {
+        final Reader reader = new SequenceReader(new CharSequenceReader(""FooBar""));
+        checkRead(reader, ""Foo"");
+        reader.close();
+        checkReadEof(reader);
+    }
+
+    @Test
+    public void testCloseReaders() {
+        final AtomicBoolean closeEmptyReader = new AtomicBoolean(false);
+        final Reader emptyReader = new Reader() {
+            @Override
+            public int read(char[] cbuf, int off, int len) throws IOException {","[{'comment': 'Use `final` where you can.', 'commenter': 'garydgregory'}]"
391,src/test/java/org/apache/commons/io/input/SequenceReaderTest.java,"@@ -56,14 +60,86 @@ private void checkReadEof(final Reader reader) throws IOException {
     }
 
     @Test
-    public void testClose() throws IOException {
+    public void testAutoClose() throws IOException {
         try (Reader reader = new SequenceReader(new CharSequenceReader(""FooBar""))) {
             checkRead(reader, ""Foo"");
             reader.close();
             checkReadEof(reader);
         }
     }
 
+    @Test
+    public void testClose() throws IOException {
+        final Reader reader = new SequenceReader(new CharSequenceReader(""FooBar""));
+        checkRead(reader, ""Foo"");
+        reader.close();
+        checkReadEof(reader);
+    }
+
+    @Test
+    public void testCloseReaders() {
+        final AtomicBoolean closeEmptyReader = new AtomicBoolean(false);
+        final Reader emptyReader = new Reader() {
+            @Override
+            public int read(char[] cbuf, int off, int len) throws IOException {
+                if (closeEmptyReader.get()) {
+                    throw new IOException(""emptyReader already closed"");
+                }
+
+                return EOF;
+            }
+
+            @Override
+            public void close() throws IOException {
+                closeEmptyReader.set(true);
+            }
+        };
+
+        final AtomicBoolean closeReader1 = new AtomicBoolean(false);
+        final Reader reader1 = new Reader() {
+            private final char[] content = new char[]{'A'};","[{'comment': ""Use abbreviated notation, IOW `... = {'A'};`"", 'commenter': 'garydgregory'}]"
391,src/test/java/org/apache/commons/io/input/SequenceReaderTest.java,"@@ -56,14 +60,86 @@ private void checkReadEof(final Reader reader) throws IOException {
     }
 
     @Test
-    public void testClose() throws IOException {
+    public void testAutoClose() throws IOException {
         try (Reader reader = new SequenceReader(new CharSequenceReader(""FooBar""))) {
             checkRead(reader, ""Foo"");
             reader.close();
             checkReadEof(reader);
         }
     }
 
+    @Test
+    public void testClose() throws IOException {
+        final Reader reader = new SequenceReader(new CharSequenceReader(""FooBar""));
+        checkRead(reader, ""Foo"");
+        reader.close();
+        checkReadEof(reader);
+    }
+
+    @Test
+    public void testCloseReaders() {
+        final AtomicBoolean closeEmptyReader = new AtomicBoolean(false);
+        final Reader emptyReader = new Reader() {
+            @Override
+            public int read(char[] cbuf, int off, int len) throws IOException {
+                if (closeEmptyReader.get()) {
+                    throw new IOException(""emptyReader already closed"");
+                }
+
+                return EOF;
+            }
+
+            @Override
+            public void close() throws IOException {
+                closeEmptyReader.set(true);
+            }
+        };
+
+        final AtomicBoolean closeReader1 = new AtomicBoolean(false);
+        final Reader reader1 = new Reader() {
+            private final char[] content = new char[]{'A'};
+            private int position = 0;
+
+            @Override
+            public int read(char[] cbuf, int off, int len) throws IOException {","[{'comment': 'Use `final` where you can.', 'commenter': 'garydgregory'}]"
391,src/test/java/org/apache/commons/io/input/SequenceReaderTest.java,"@@ -56,14 +60,86 @@ private void checkReadEof(final Reader reader) throws IOException {
     }
 
     @Test
-    public void testClose() throws IOException {
+    public void testAutoClose() throws IOException {
         try (Reader reader = new SequenceReader(new CharSequenceReader(""FooBar""))) {
             checkRead(reader, ""Foo"");
             reader.close();
             checkReadEof(reader);
         }
     }
 
+    @Test
+    public void testClose() throws IOException {
+        final Reader reader = new SequenceReader(new CharSequenceReader(""FooBar""));
+        checkRead(reader, ""Foo"");
+        reader.close();
+        checkReadEof(reader);
+    }
+
+    @Test
+    public void testCloseReaders() {
+        final AtomicBoolean closeEmptyReader = new AtomicBoolean(false);
+        final Reader emptyReader = new Reader() {
+            @Override
+            public int read(char[] cbuf, int off, int len) throws IOException {
+                if (closeEmptyReader.get()) {
+                    throw new IOException(""emptyReader already closed"");
+                }
+
+                return EOF;
+            }
+
+            @Override
+            public void close() throws IOException {
+                closeEmptyReader.set(true);
+            }
+        };
+
+        final AtomicBoolean closeReader1 = new AtomicBoolean(false);","[{'comment': ""No need to initialize an `AtomicBoolean` to `false`, that's the default, IOW -> `new AtomicBoolean();`"", 'commenter': 'garydgregory'}]"
418,src/main/java/org/apache/commons/io/HexDump.java,"@@ -53,7 +56,26 @@ public class HexDump {
             };
 
     /**
-     * Dumps an array of bytes to an OutputStream. The output is formatted
+     * Dumps an array of bytes to an Appendable. The output is formatted
+     * for human inspection, with a hexadecimal offset followed by the
+     * hexadecimal values of the next 16 bytes of data and the printable ASCII
+     * characters (if any) that those bytes represent printed per each line
+     * of output.
+     *
+     * @param data  the byte array to be dumped
+     * @param out  the Appendable to which the data is to be written
+     *
+     * @throws IOException is thrown if anything goes wrong writing
+     *         the data to appendable
+     */
+","[{'comment': 'Remove whitespace between Javadoc and code.', 'commenter': 'garydgregory'}, {'comment': 'Add Javadoc since tag to new public and protected elements. ', 'commenter': 'garydgregory'}, {'comment': ""@garydgregory Thanks for reviewing. I've fixed both."", 'commenter': 'fkjellberg'}]"
418,src/main/java/org/apache/commons/io/HexDump.java,"@@ -118,14 +144,55 @@ public static void dump(final byte[] data, final long offset,
                 }
             }
             buffer.append(System.lineSeparator());
-            // make explicit the dependency on the default encoding
-            stream.write(buffer.toString().getBytes(Charset.defaultCharset()));
-            stream.flush();
+            out.append(buffer);
             buffer.setLength(0);
             display_offset += chars_read;
         }
     }
 
+    /**
+     * Dumps an array of bytes to an OutputStream. The output is formatted
+     * for human inspection, with a hexadecimal offset followed by the
+     * hexadecimal values of the next 16 bytes of data and the printable ASCII
+     * characters (if any) that those bytes represent printed per each line
+     * of output.
+     * <p>
+     * The offset argument specifies the start offset of the data array
+     * within a larger entity like a file or an incoming stream. For example,
+     * if the data array contains the third kibibyte of a file, then the
+     * offset argument should be set to 2048. The offset value printed
+     * at the beginning of each line indicates where in that larger entity
+     * the first byte on that line is located.
+     * </p>
+     * <p>
+     * All bytes between the given index (inclusive) and the end of the
+     * data array are dumped.
+     * </p>
+     *
+     * @param data  the byte array to be dumped
+     * @param offset  offset of the byte array within a larger entity
+     * @param stream  the OutputStream to which the data is to be
+     *               written
+     * @param index initial index into the byte array
+     *
+     * @throws IOException is thrown if anything goes wrong writing
+     *         the data to stream
+     * @throws ArrayIndexOutOfBoundsException if the index is
+     *         outside the data array's bounds
+     * @throws NullPointerException if the output stream is null
+     */
+    public static void dump(final byte[] data, final long offset,
+                            final OutputStream stream, final int index)
+            throws IOException, ArrayIndexOutOfBoundsException {
+        Objects.requireNonNull(stream, ""stream"");
+
+        // make explicit the dependency on the default encoding","[{'comment': 'This comment is not needed: ""make explicit the dependency on the default encoding""', 'commenter': 'garydgregory'}, {'comment': ""This comment came from the original code. I've removed it now."", 'commenter': 'fkjellberg'}]"
418,src/main/java/org/apache/commons/io/HexDump.java,"@@ -53,7 +56,26 @@ public class HexDump {
             };
 
     /**
-     * Dumps an array of bytes to an OutputStream. The output is formatted
+     * Dumps an array of bytes to an Appendable. The output is formatted
+     * for human inspection, with a hexadecimal offset followed by the
+     * hexadecimal values of the next 16 bytes of data and the printable ASCII
+     * characters (if any) that those bytes represent printed per each line
+     * of output.
+     *
+     * @param data  the byte array to be dumped
+     * @param out  the Appendable to which the data is to be written
+     *
+     * @throws IOException is thrown if anything goes wrong writing
+     *         the data to appendable
+     */
+
+    public static void dump(final byte[] data, final Appendable out)","[{'comment': 'Rename `out` to `appendable` so it has no chance of being confused with an Output* class.', 'commenter': 'garydgregory'}, {'comment': 'Fixed', 'commenter': 'fkjellberg'}]"
418,src/main/java/org/apache/commons/io/HexDump.java,"@@ -118,14 +148,54 @@ public static void dump(final byte[] data, final long offset,
                 }
             }
             buffer.append(System.lineSeparator());
-            // make explicit the dependency on the default encoding
-            stream.write(buffer.toString().getBytes(Charset.defaultCharset()));
-            stream.flush();
+            appendable.append(buffer);
             buffer.setLength(0);
             display_offset += chars_read;
         }
     }
 
+    /**
+     * Dumps an array of bytes to an OutputStream. The output is formatted
+     * for human inspection, with a hexadecimal offset followed by the
+     * hexadecimal values of the next 16 bytes of data and the printable ASCII
+     * characters (if any) that those bytes represent printed per each line
+     * of output.
+     * <p>
+     * The offset argument specifies the start offset of the data array
+     * within a larger entity like a file or an incoming stream. For example,
+     * if the data array contains the third kibibyte of a file, then the
+     * offset argument should be set to 2048. The offset value printed
+     * at the beginning of each line indicates where in that larger entity
+     * the first byte on that line is located.
+     * </p>
+     * <p>
+     * All bytes between the given index (inclusive) and the end of the
+     * data array are dumped.
+     * </p>
+     *
+     * @param data  the byte array to be dumped
+     * @param offset  offset of the byte array within a larger entity
+     * @param stream  the OutputStream to which the data is to be
+     *               written
+     * @param index initial index into the byte array
+     *
+     * @throws IOException is thrown if anything goes wrong writing
+     *         the data to stream
+     * @throws ArrayIndexOutOfBoundsException if the index is
+     *         outside the data array's bounds
+     * @throws NullPointerException if the output stream is null
+     */
+    public static void dump(final byte[] data, final long offset,
+                            final OutputStream stream, final int index)
+            throws IOException, ArrayIndexOutOfBoundsException {
+        Objects.requireNonNull(stream, ""stream"");
+
+        try (OutputStreamWriter out = new OutputStreamWriter(CloseShieldOutputStream.wrap(stream), Charset.defaultCharset())) {","[{'comment': 'No need for `CloseShieldOutputStream`.', 'commenter': 'garydgregory'}]"
418,src/main/java/org/apache/commons/io/HexDump.java,"@@ -118,14 +148,54 @@ public static void dump(final byte[] data, final long offset,
                 }
             }
             buffer.append(System.lineSeparator());
-            // make explicit the dependency on the default encoding
-            stream.write(buffer.toString().getBytes(Charset.defaultCharset()));
-            stream.flush();
+            appendable.append(buffer);
             buffer.setLength(0);
             display_offset += chars_read;
         }
     }
 
+    /**
+     * Dumps an array of bytes to an OutputStream. The output is formatted
+     * for human inspection, with a hexadecimal offset followed by the
+     * hexadecimal values of the next 16 bytes of data and the printable ASCII
+     * characters (if any) that those bytes represent printed per each line
+     * of output.
+     * <p>
+     * The offset argument specifies the start offset of the data array
+     * within a larger entity like a file or an incoming stream. For example,
+     * if the data array contains the third kibibyte of a file, then the
+     * offset argument should be set to 2048. The offset value printed
+     * at the beginning of each line indicates where in that larger entity
+     * the first byte on that line is located.
+     * </p>
+     * <p>
+     * All bytes between the given index (inclusive) and the end of the
+     * data array are dumped.
+     * </p>
+     *
+     * @param data  the byte array to be dumped
+     * @param offset  offset of the byte array within a larger entity
+     * @param stream  the OutputStream to which the data is to be
+     *               written
+     * @param index initial index into the byte array
+     *
+     * @throws IOException is thrown if anything goes wrong writing
+     *         the data to stream
+     * @throws ArrayIndexOutOfBoundsException if the index is
+     *         outside the data array's bounds
+     * @throws NullPointerException if the output stream is null
+     */
+    public static void dump(final byte[] data, final long offset,
+                            final OutputStream stream, final int index)
+            throws IOException, ArrayIndexOutOfBoundsException {
+        Objects.requireNonNull(stream, ""stream"");
+
+        try (OutputStreamWriter out = new OutputStreamWriter(CloseShieldOutputStream.wrap(stream), Charset.defaultCharset())) {
+            dump(data, offset, out, index, data.length - index);
+            out.flush();","[{'comment': 'Let the caller decide when to flush and/or close.', 'commenter': 'garydgregory'}, {'comment': ""Commenting both on the `CloseShieldOutputStream` comment above and this comment.\r\n\r\nThe original implementation flushed the underlying stream. It actually flushed at every row written. Since the `OutputStreamWriter` will be automatically closed within the try-with-resources block and looking at the source code for `StreamEncoder` within the `OutputStreamWriter`, I now notice that the `StreamEncoder` will flush before closing the stream. I will remove the explicit flush in a follow up commit.\r\n\r\nThe original implementation left the `OutputStream` open after the call. Since I wrap the `OutputStream` in an `OutputStreamWriter` that is closed, it will propagate that close call to the underlying stream as well. I'm using the `CloseShieldOutputStream` to protect it from being closed and preserve the same behavior as before.\r\n\r\nI think we should preserve the same behavior as the original code when it comes to keeping the `OutputStream` open after the call."", 'commenter': 'fkjellberg'}]"
418,src/test/java/org/apache/commons/io/HexDumpTest.java,"@@ -253,6 +253,16 @@ public void testDumpOutputStream() throws IOException {
 
         // verify proper behavior with null stream
         assertThrows(NullPointerException.class, () -> HexDump.dump(testArray, 0x10000000, null, 0));
+","[{'comment': 'How about reusing `ThrowOnCloseInputStream`?', 'commenter': 'garydgregory'}, {'comment': '@garydgregory Thanks for the pointer. I was not aware of this test utility class. Code updated.', 'commenter': 'fkjellberg'}]"
457,src/test/java/org/apache/commons/io/FileUtilsTest.java,"@@ -2446,6 +2447,57 @@ public void testReadFileToByteArray() throws Exception {
         assertEquals(31, data[2]);
     }
 
+    @Test
+    public void testReadFileToByteArrayOffsetAndLength() throws Exception {
+        final File file = new File(tempDirFile, ""read.txt"");
+        final byte[] arr = new byte[] {10, 20, 30, 40 ,50, 60, 70};
+        Files.write(file.toPath(), arr);
+
+        final byte[] data = FileUtils.readFileToByteArray(file, 2, 5);
+        assertEquals(4, data.length);
+        assertEquals(30, data[0]); // arrayOffSet
+        assertEquals(60, data[3]); // arrayLength
+    }
+
+    @Test
+    public void testReadFileToByteArrayOffsetAndLengthSameValue() throws Exception {
+        final File file = new File(tempDirFile, ""read.txt"");
+        final byte[] arr = new byte[] {10, 20, 30, 40 ,50, 60, 70};
+        Files.write(file.toPath(), arr);
+
+        final byte[] data = FileUtils.readFileToByteArray(file, 2, 2);
+        assertEquals(1, data.length);
+        assertEquals(30, data[0]); // return one byte
+    }
+
+    @Test
+    public void testReadFileToByteArrayOffsetAndLengthZero() throws Exception {
+        final File file = new File(tempDirFile, ""read.txt"");
+        final byte[] arr = new byte[] {10, 20, 30, 40 ,50, 60, 70};
+        Files.write(file.toPath(), arr);
+
+        final byte[] data = FileUtils.readFileToByteArray(file, 0, 0);","[{'comment': 'The resulting arrays are off by 1 in length, if I ask to read a length of 0, i should get back a byte array of length 0.', 'commenter': 'garydgregory'}]"
457,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -2581,6 +2581,29 @@ public static byte[] readFileToByteArray(final File file) throws IOException {
         return Files.readAllBytes(file.toPath());
     }
 
+    /**
+     * Reads the contents of a file into a byte[]. Start reading from offSet in file index to specific length.
+     *
+     * @param file the file to read, nust not be {@code null}
+     * @param arrayOffset read from an offset in the file","[{'comment': 'Parameters are misnamed: This is the index in the source file.', 'commenter': 'garydgregory'}]"
457,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -2581,6 +2581,29 @@ public static byte[] readFileToByteArray(final File file) throws IOException {
         return Files.readAllBytes(file.toPath());
     }
 
+    /**
+     * Reads the contents of a file into a byte[]. Start reading from offSet in file index to specific length.
+     *
+     * @param file the file to read, nust not be {@code null}
+     * @param arrayOffset read from an offset in the file
+     * @param arrayLength read file up to certain length based on index","[{'comment': 'This is how much to read from the file.', 'commenter': 'garydgregory'}]"
457,src/main/java/org/apache/commons/io/IOUtils.java,"@@ -2664,6 +2664,50 @@ public static byte[] toByteArray(final InputStream input, final int size) throws
         return data;
     }
 
+
+    /**
+     *
+     * Gets the contents of an {@link InputStream} as a {@code byte[]}.Use this method when you want to specify the
+     * indexes that you want to read from the InputStream.
+     *
+     * @param input
+     * @param offset The offset from the start of the InputStream to start ready - index based
+     * @param length The end of the InputStream to stop reading - index based
+     * @return byte[]
+     * @throws IOException if an I/O error occurs or {@link InputStream} length is smaller than parameter {@code size}.
+     * @throws NullPointerException if offset is greater than length or array index is out of bounds
+     * @throws IllegalArgumentException if {@code size} is less than zero.
+     * @since 2.12.0
+     */
+    public static byte[] toByteArray(final InputStream input, final int offset, final int length) throws IOException {
+
+        if (length < 0) {
+            throw new IllegalArgumentException(""Size must be equal or greater than zero: "" + length);
+        }
+        if (offset < 0 ) {
+            throw new IllegalArgumentException(""Offset must be grater than or equal to zero: "" + offset);
+        }
+        if (length < offset) {","[{'comment': 'The index and length are unrelated, the length is the length of the desired result. The question is what should happen if there is not enough file data.', 'commenter': 'garydgregory'}]"
457,src/test/java/org/apache/commons/io/FileUtilsTest.java,"@@ -2446,6 +2447,56 @@ public void testReadFileToByteArray() throws Exception {
         assertEquals(31, data[2]);
     }
 
+    @Test
+    public void testReadFileToByteArrayOffsetAndLength() throws Exception {
+        final File file = new File(tempDirFile, ""read.txt"");
+        final byte[] arr = new byte[] {10, 20, 30, 40 ,50, 60, 70};
+        Files.write(file.toPath(), arr);
+
+        final byte[] data = FileUtils.readFileToByteArray(file, 2, 5);
+        assertEquals(4, data.length);
+        assertEquals(30, data[0]); // arrayOffSet
+        assertEquals(60, data[3]); // arrayLength
+    }
+
+    @Test
+    public void testReadFileToByteArrayOffsetAndLengthSameValue() throws Exception {
+        final File file = new File(tempDirFile, ""read.txt"");
+        final byte[] arr = new byte[] {10, 20, 30, 40 ,50, 60, 70};
+        Files.write(file.toPath(), arr);
+
+        final byte[] data = FileUtils.readFileToByteArray(file, 2, 2);
+        assertEquals(1, data.length);
+        assertEquals(30, data[0]); // return one byte
+    }
+
+    @Test
+    public void testReadFileToByteArrayOffsetAndLengthZero() throws Exception {
+        final File file = new File(tempDirFile, ""read.txt"");
+        final byte[] arr = new byte[] {10, 20, 30, 40 ,50, 60, 70};
+        Files.write(file.toPath(), arr);
+
+        final byte[] data = FileUtils.readFileToByteArray(file, 0, 0);
+        assertEquals(0, data.length);// return one byte","[{'comment': 'The comment is wrong: How is length zero equal to one byte?', 'commenter': 'garydgregory'}]"
457,src/test/java/org/apache/commons/io/FileUtilsTest.java,"@@ -2446,6 +2447,56 @@ public void testReadFileToByteArray() throws Exception {
         assertEquals(31, data[2]);
     }
 
+    @Test
+    public void testReadFileToByteArrayOffsetAndLength() throws Exception {
+        final File file = new File(tempDirFile, ""read.txt"");
+        final byte[] arr = new byte[] {10, 20, 30, 40 ,50, 60, 70};
+        Files.write(file.toPath(), arr);
+
+        final byte[] data = FileUtils.readFileToByteArray(file, 2, 5);
+        assertEquals(4, data.length);
+        assertEquals(30, data[0]); // arrayOffSet
+        assertEquals(60, data[3]); // arrayLength
+    }
+
+    @Test
+    public void testReadFileToByteArrayOffsetAndLengthSameValue() throws Exception {
+        final File file = new File(tempDirFile, ""read.txt"");
+        final byte[] arr = new byte[] {10, 20, 30, 40 ,50, 60, 70};
+        Files.write(file.toPath(), arr);
+
+        final byte[] data = FileUtils.readFileToByteArray(file, 2, 2);
+        assertEquals(1, data.length);
+        assertEquals(30, data[0]); // return one byte
+    }
+
+    @Test
+    public void testReadFileToByteArrayOffsetAndLengthZero() throws Exception {
+        final File file = new File(tempDirFile, ""read.txt"");
+        final byte[] arr = new byte[] {10, 20, 30, 40 ,50, 60, 70};
+        Files.write(file.toPath(), arr);
+
+        final byte[] data = FileUtils.readFileToByteArray(file, 0, 0);
+        assertEquals(0, data.length);// return one byte
+    }
+
+
+    @Test()
+    public void testReadFileToByteArrayOffsetAndLengthException() {
+
+        final File file = new File(tempDirFile, ""read.txt"");
+        final byte[] arr = new byte[] {10, 20, 30, 40, 50, 60, 70};
+
+        try {
+            Files.write(file.toPath(), arr);
+            FileUtils.readFileToByteArray(file, 2, 1);
+        } catch (IOException | IllegalArgumentException ex) {
+            assertEquals(""Length must be greater than or equal to offset: "" + 2, ex.getMessage());","[{'comment': 'This makes no sense to me: the position and length should not be related; ""2, 1"" should mean, starting at 0-based position 2, read one byte. IOW, I am describing the same semantics as \'java.io.InputStream.read(byte[], int, int)\'. In this test, the file is 7 bytes in length, so ""2, 1"", should return the third byte value of ""30"".', 'commenter': 'garydgregory'}]"
468,src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java,"@@ -410,11 +410,11 @@ public void test_reset_Exception() throws IOException {
     @Test
     public void test_reset_scenario1() throws IOException {
         final byte[] input = ""12345678900"".getBytes();
-        final BufferedInputStream buffis = new BufferedInputStream(new ByteArrayInputStream(input));
-        buffis.read();
-        buffis.mark(5);
-        buffis.skip(5);
-        buffis.reset();
+        final BufferedInputStream bufin = new BufferedInputStream(new ByteArrayInputStream(input));
+        bufin.read();
+        bufin.mark(5);
+        bufin.skip(5);
+        bufin.reset();","[{'comment': ""This file has a whole bunch of different local variables used for `new BufferedInputStream(...)`. There does not appear to be a remotely good reason for so many different ways to spell the same variable name in a single file, but only this one bothered me enough to change it.\r\n\r\nhttps://github.com/apache/commons-io/blob/318645fd97d6c31cfbce6f5a7fa83d5350e87708/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java#L94\r\nhttps://github.com/apache/commons-io/blob/318645fd97d6c31cfbce6f5a7fa83d5350e87708/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java#L112\r\nhttps://github.com/apache/commons-io/blob/318645fd97d6c31cfbce6f5a7fa83d5350e87708/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java#L143\r\nhttps://github.com/apache/commons-io/blob/318645fd97d6c31cfbce6f5a7fa83d5350e87708/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java#L162\r\nhttps://github.com/apache/commons-io/blob/318645fd97d6c31cfbce6f5a7fa83d5350e87708/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java#L172\r\nhttps://github.com/apache/commons-io/blob/318645fd97d6c31cfbce6f5a7fa83d5350e87708/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java#L216\r\nhttps://github.com/apache/commons-io/blob/318645fd97d6c31cfbce6f5a7fa83d5350e87708/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java#L230\r\n-- this is in the same scope as the previous one, but the previous one is effectively dead, so there's no reason not to recycle it as the next two sites do...\r\nhttps://github.com/apache/commons-io/blob/318645fd97d6c31cfbce6f5a7fa83d5350e87708/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java#L281\r\nhttps://github.com/apache/commons-io/blob/318645fd97d6c31cfbce6f5a7fa83d5350e87708/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java#L302\r\nhttps://github.com/apache/commons-io/blob/318645fd97d6c31cfbce6f5a7fa83d5350e87708/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java#L347\r\nhttps://github.com/apache/commons-io/blob/318645fd97d6c31cfbce6f5a7fa83d5350e87708/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java#L390\r\nhttps://github.com/apache/commons-io/blob/318645fd97d6c31cfbce6f5a7fa83d5350e87708/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java#L428\r\nhttps://github.com/apache/commons-io/blob/318645fd97d6c31cfbce6f5a7fa83d5350e87708/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java#L441\r\nhttps://github.com/apache/commons-io/blob/318645fd97d6c31cfbce6f5a7fa83d5350e87708/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java#L461"", 'commenter': 'jsoref'}]"
468,src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java,"@@ -44,7 +44,7 @@ private String getName() {
 
     @Test
     public void testDirectoryAndFileContentEquals() throws Exception {
-        // Non-existent files
+        // Nonexistent files","[{'comment': ""Let's not change this please, this is not a spelling error, both spellings are acceptable, one is clearer due to the hyphen."", 'commenter': 'garydgregory'}, {'comment': ""Sure, but do note that you're already using it in [\u200esrc/main/java/org/apache/commons/io/FileUtils.java](https://github.com/apache/commons-io/blob/06fde31494c279ad940149e1a3d4944040c73c0d/src/main/java/org/apache/commons/io/FileUtils.java#L1091) per https://github.com/search?q=repo%3Aapache%2Fcommons-io%20nonexistent&type=code"", 'commenter': 'jsoref'}, {'comment': ""I've dropped those changes, but I've thrown in some more `existant` -> `existent` changes."", 'commenter': 'jsoref'}, {'comment': ""Thank you. I'd rather normalize that word on the hyphenated variant."", 'commenter': 'garydgregory'}, {'comment': 'Sorry, how would you do that? consider https://github.com/apache/commons-io/compare/318645fd97d6c31cfbce6f5a7fa83d5350e87708..810cf30344db9d3e5fffc8ea074d50fae136e558\r\n\r\nhttps://github.com/apache/commons-io/blob/810cf30344db9d3e5fffc8ea074d50fae136e558/src/test/java/org/apache/commons/io/file/PathUtilsTest.java#L102', 'commenter': 'jsoref'}, {'comment': 'Err... this is a PR, you edit the files? Use the hyphenated variant in comments and camel-case in code.', 'commenter': 'garydgregory'}, {'comment': 'Then I think this PR has what you want. ', 'commenter': 'jsoref'}, {'comment': 'It is not. Local vars should be ""nonexistentFoo"" -> ""nonExistentFoo"".', 'commenter': 'garydgregory'}, {'comment': 'ok, I think this addresses your request', 'commenter': 'jsoref'}]"
486,src/test/java/org/apache/commons/io/FileUtilsTest.java,"@@ -2463,18 +2485,56 @@ public void testReadFileToStringWithEncoding() throws Exception {
         assertEquals(""Hello /u1234"", data);
     }
 
+    @Test
+    public void testReadFileToString_Errors() {
+        assertThrows(NullPointerException.class, () -> FileUtils.readFileToString(null));
+        assertThrows(NoSuchFileException.class, () -> FileUtils.readFileToString(new File(""non-exsistent"")));
+
+        Exception exception = assertThrows(IOException.class, () -> FileUtils.readFileToString(tempDirFile));
+        assertEquals(""Is a directory"", exception.getMessage());
+
+        assertThrows(UnsupportedCharsetException.class, () -> FileUtils.readFileToString(tempDirFile, ""unsupported-charset""));
+    }
+
+    @Test
+    @EnabledIf(""isPosixFilePermissionsSupported"")
+    public void testReadFileToString_AccessDeniedExceptionOnPosixFileSystem() throws Exception {
+        final File file = TestUtils.newFile(tempDirFile, ""cant-read.txt"");
+        TestUtils.createFile(file, 100);
+        Files.setPosixFilePermissions(file.toPath(), PosixFilePermissions.fromString(""---------""));
+
+        assertThrows(AccessDeniedException.class, () -> FileUtils.readFileToString(file));
+    }
+
     @Test
     public void testReadLines() throws Exception {
         final File file = TestUtils.newFile(tempDirFile, ""lines.txt"");
-        try {
-            final String[] data = {""hello"", ""/u1234"", """", ""this is"", ""some text""};
-            TestUtils.createLineBasedFile(file, data);
+        final String[] data = {""hello"", ""/u1234"", """", ""this is"", ""some text""};
+        TestUtils.createLineBasedFile(file, data);
 
-            final List<String> lines = FileUtils.readLines(file, UTF_8);
-            assertEquals(Arrays.asList(data), lines);
-        } finally {
-            TestUtils.deleteFile(file);","[{'comment': ""The file is created in the tempDir, so deleting it explicitly isn't necessary."", 'commenter': 'chkpnt'}, {'comment': 'Please revert and let the test clean itself up as soon as it can. There is no sense in letting temp files pile up and up and up. The super class clean up is a back-stop. IOW, you allocate, you release.', 'commenter': 'garydgregory'}, {'comment': 'NP, your repo, your decision ;-)\r\n\r\nDo you want me to add the deletion in the `*_AccessDeniedExceptionOnPosixFileSystem`, too? I took my cue from the `testWriteString*` tests, where the cleanup relies on the tempDir.', 'commenter': 'chkpnt'}]"
486,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -2698,7 +2691,7 @@ private static void requireAbsent(final File file, final String name) throws Fil
      *
      * @param file1 The first file to compare.
      * @param file2 The second file to compare.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException              if an I/O error occurs.","[{'comment': ""Ups... auto-formatting. I'll revert the whitespace changes from methods which are not part of IO-810."", 'commenter': 'chkpnt'}]"
486,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -2618,15 +2615,14 @@ public static String readFileToString(final File file, final Charset charsetName
     /**
      * Reads the contents of a file into a String. The file is always closed.
      *
-     * @param file     the file to read, must not be {@code null}
+     * @param file the file to read, must not be {@code null}
      * @param charsetName the name of the requested charset, {@code null} means platform default
      * @return the file contents, never {@code null}
      * @throws NullPointerException if file is {@code null}.
-     * @throws FileNotFoundException if the file does not exist, is a directory rather than a regular file, or for some
-     *         other reason cannot be opened for reading.
-     * @throws IOException if an I/O error occurs.
+     * @throws IOException if an I/O error occurs, including when the file does not exist, is a directory rather than a
+     *         regular file, or for some other reason why the file cannot be opened for reading.
      * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
-     * .UnsupportedEncodingException} in version 2.2 if the named charset is unavailable.
+     *                                                      .UnsupportedEncodingException} in version 2.2 if the named charset is unavailable.","[{'comment': ""Hi @chkpnt \r\nThank you for your PR.\r\nPlease don't change the formatting, it makes it harder to review the actual changes."", 'commenter': 'garydgregory'}, {'comment': ""Tried to apply the boys scouting rule for the sake of consistency... (sometimes the javadocs are aligned, sometimes not). But yes, it was an unsolicited change, sorry for that!\r\n\r\n(IHMO formatting shouldn't be something handled manually, I can recommend the integration of something like spotless in the build chain. An other issue I had was that my IDE added the new imports with an wildcard. As I didn't saw any other wildcard imports, I thought that might be undesired, so I had to change the import to single imports manually.)"", 'commenter': 'chkpnt'}]"
486,src/test/java/org/apache/commons/io/FileUtilsTest.java,"@@ -2463,18 +2487,56 @@ public void testReadFileToStringWithEncoding() throws Exception {
         assertEquals(""Hello /u1234"", data);
     }
 
+    @Test
+    public void testReadFileToString_Errors() {
+        assertThrows(NullPointerException.class, () -> FileUtils.readFileToString(null));
+        assertThrows(NoSuchFileException.class, () -> FileUtils.readFileToString(new File(""non-exsistent"")));
+
+        Exception exception = assertThrows(IOException.class, () -> FileUtils.readFileToString(tempDirFile));
+        assertEquals(""Is a directory"", exception.getMessage());
+
+        assertThrows(UnsupportedCharsetException.class, () -> FileUtils.readFileToString(tempDirFile, ""unsupported-charset""));
+    }
+
+    @Test
+    @EnabledIf(""isPosixFilePermissionsSupported"")
+    public void testReadFileToString_AccessDeniedExceptionOnPosixFileSystem() throws Exception {
+        final File file = TestUtils.newFile(tempDirFile, ""cant-read.txt"");
+        TestUtils.createFile(file, 100);
+        Files.setPosixFilePermissions(file.toPath(), PosixFilePermissions.fromString(""---------""));
+
+        assertThrows(AccessDeniedException.class, () -> FileUtils.readFileToString(file));
+    }
+
     @Test
     public void testReadLines() throws Exception {
         final File file = TestUtils.newFile(tempDirFile, ""lines.txt"");
-        try {
-            final String[] data = {""hello"", ""/u1234"", """", ""this is"", ""some text""};
-            TestUtils.createLineBasedFile(file, data);
+        final String[] data = {""hello"", ""/u1234"", """", ""this is"", ""some text""};
+        TestUtils.createLineBasedFile(file, data);
 
-            final List<String> lines = FileUtils.readLines(file, UTF_8);
-            assertEquals(Arrays.asList(data), lines);
-        } finally {
-            TestUtils.deleteFile(file);
-        }
+        final List<String> lines = FileUtils.readLines(file, UTF_8);
+        assertEquals(Arrays.asList(data), lines);
+    }
+
+    @Test
+    public void testReadLines_Errors() {
+        assertThrows(NullPointerException.class, () -> FileUtils.readLines(null));
+        assertThrows(NoSuchFileException.class, () -> FileUtils.readLines(new File(""non-exsistent"")));
+
+        Exception exception = assertThrows(IOException.class, () -> FileUtils.readLines(tempDirFile));
+        assertEquals(""Is a directory"", exception.getMessage());","[{'comment': ""Let's not do this kind of asserting, we need flexibility in adjusting messages without breaking tests."", 'commenter': 'garydgregory'}, {'comment': ""The message isn't coming from common-io, that's the reason why I added this assert. There is no more concrete exception class in this case, and the message would be the feature to detect unwanted changes. But yes, it's going beyond the Javadoc-specification, so I'm removing it."", 'commenter': 'chkpnt'}]"
486,src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java,"@@ -19,8 +19,11 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.nio.file.FileSystems;
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;","[{'comment': 'Remove unused imports.', 'commenter': 'garydgregory'}]"
486,src/test/java/org/apache/commons/io/FileUtilsTest.java,"@@ -2463,18 +2487,56 @@ public void testReadFileToStringWithEncoding() throws Exception {
         assertEquals(""Hello /u1234"", data);
     }
 
+    @Test
+    public void testReadFileToString_Errors() {
+        assertThrows(NullPointerException.class, () -> FileUtils.readFileToString(null));
+        assertThrows(NoSuchFileException.class, () -> FileUtils.readFileToString(new File(""non-exsistent"")));
+
+        Exception exception = assertThrows(IOException.class, () -> FileUtils.readFileToString(tempDirFile));
+        assertEquals(""Is a directory"", exception.getMessage());
+
+        assertThrows(UnsupportedCharsetException.class, () -> FileUtils.readFileToString(tempDirFile, ""unsupported-charset""));
+    }
+
+    @Test
+    @EnabledIf(""isPosixFilePermissionsSupported"")
+    public void testReadFileToString_AccessDeniedExceptionOnPosixFileSystem() throws Exception {
+        final File file = TestUtils.newFile(tempDirFile, ""cant-read.txt"");
+        TestUtils.createFile(file, 100);
+        Files.setPosixFilePermissions(file.toPath(), PosixFilePermissions.fromString(""---------""));
+
+        assertThrows(AccessDeniedException.class, () -> FileUtils.readFileToString(file));
+    }
+
     @Test
     public void testReadLines() throws Exception {
         final File file = TestUtils.newFile(tempDirFile, ""lines.txt"");
-        try {
-            final String[] data = {""hello"", ""/u1234"", """", ""this is"", ""some text""};
-            TestUtils.createLineBasedFile(file, data);
+        final String[] data = {""hello"", ""/u1234"", """", ""this is"", ""some text""};
+        TestUtils.createLineBasedFile(file, data);
 
-            final List<String> lines = FileUtils.readLines(file, UTF_8);
-            assertEquals(Arrays.asList(data), lines);
-        } finally {
-            TestUtils.deleteFile(file);
-        }
+        final List<String> lines = FileUtils.readLines(file, UTF_8);
+        assertEquals(Arrays.asList(data), lines);
+    }
+
+    @Test
+    public void testReadLines_Errors() {
+        assertThrows(NullPointerException.class, () -> FileUtils.readLines(null));
+        assertThrows(NoSuchFileException.class, () -> FileUtils.readLines(new File(""non-exsistent"")));","[{'comment': ""This the the opposite of what the Javadoc changes are all about. This PR changes the documentation to say we throw IOException, so let's test that. Let's NOT test what we do NOT document."", 'commenter': 'garydgregory'}, {'comment': 'My thoughts were the following:\r\n- the Javadoc is specifying the API to the users of the library\r\n- the tests can be more detailed, so that the common-io-developers know which concrete exception is thrown.\r\n- if the implementation changes, so that another exception is thrown, the developer get noticed and can consider about the consequences (e.g. writing a simple hint to the changelog).\r\n\r\nBut of course, if you see the tests as the specification, then yes.', 'commenter': 'chkpnt'}, {'comment': '> My thoughts were the following:\r\n> \r\n>     * the Javadoc is specifying the API to the users of the library\r\n> \r\n>     * the tests can be more detailed, so that the common-io-developers know which concrete exception is thrown.\r\n> \r\n>     * if the implementation changes, so that another exception is thrown, the developer get noticed and can consider about the consequences (e.g. writing a simple hint to the changelog).\r\n> \r\n> \r\n> But of course, if you see the tests as the specification, then yes.\r\n\r\nIf we give ourselves more flexibility by documenting the more general exception, I do indeed feel that we should afford ourselves the same in the tests.\r\n\r\nUsing tests as specification is a bit strong but I do want the flexibility for now.', 'commenter': 'garydgregory'}, {'comment': 'NP, both views are valid.', 'commenter': 'chkpnt'}]"
486,src/test/java/org/apache/commons/io/FileUtilsTest.java,"@@ -2463,6 +2482,24 @@ public void testReadFileToStringWithEncoding() throws Exception {
         assertEquals(""Hello /u1234"", data);
     }
 
+    @Test
+    public void testReadFileToString_Errors() {
+        assertThrows(NullPointerException.class, () -> FileUtils.readFileToString(null));
+        assertThrows(IOException.class, () -> FileUtils.readFileToString(new File(""non-exsistent"")));
+        assertThrows(IOException.class, () -> FileUtils.readFileToString(tempDirFile));
+        assertThrows(IOException.class, () -> FileUtils.readFileToString(tempDirFile, ""unsupported-charset""));
+    }
+
+    @Test
+    @EnabledIf(""isPosixFilePermissionsSupported"")
+    public void testReadFileToString_IOExceptionOnPosixFileSystem() throws Exception {","[{'comment': ""Just stumbled over\r\n\r\n```\r\n        if (!SystemUtils.IS_OS_WINDOWS) {\r\n            final Set<PosixFilePermission> parentPerms = Files.getPosixFilePermissions(target.getParentFile().toPath());\r\n            final Set<PosixFilePermission> targetPerms = Files.getPosixFilePermissions(target.toPath());\r\n            assertEquals(parentPerms, targetPerms);\r\n        }\r\n```\r\n\r\nin line 862. So do you prefer such an condition in `testReadFileToByteArray_Errors()` instead of this conditional test? (But I'm not experienced enough in regards of filesystems: Is `!SystemUtils.IS_OS_WINDOWS` enough to rely on for the usage of `PosixFilePermissions`? `isPosixFilePermissionsSupported()` might be safer?) "", 'commenter': 'chkpnt'}, {'comment': 'Hi @chkpnt \r\nI prefer fewer changes in this PR because it is supposed to be about Javadoc, not code. The use of `@EnabledIf(""isPosixFilePermissionsSupported"")` is fine.', 'commenter': 'garydgregory'}]"
489,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1996,7 +1996,28 @@ public static Iterator<File> iterateFiles(final File directory, final IOFileFilt
      * @since 1.2
      */
     public static Iterator<File> iterateFiles(final File directory, final String[] extensions, final boolean recursive) {
-        return Uncheck.apply(d -> streamFiles(d, recursive, extensions).iterator(), directory);
+        return Uncheck.apply(d -> {
+            Stream<File> stream = streamFiles(d, recursive, extensions);
+            Iterator<File> iter = stream.iterator();
+
+            // Wrap the iterator to allow closing the stream after consumption
+            return new Iterator<File>(){
+                @Override
+                public boolean hasNext() {
+                    boolean ret = iter.hasNext();
+
+                    if (!ret)","[{'comment': 'Always use blocks -> { }', 'commenter': 'garydgregory'}, {'comment': 'Done', 'commenter': 'labkey-adam'}]"
489,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1996,7 +1996,28 @@ public static Iterator<File> iterateFiles(final File directory, final IOFileFilt
      * @since 1.2
      */
     public static Iterator<File> iterateFiles(final File directory, final String[] extensions, final boolean recursive) {
-        return Uncheck.apply(d -> streamFiles(d, recursive, extensions).iterator(), directory);
+        return Uncheck.apply(d -> {
+            Stream<File> stream = streamFiles(d, recursive, extensions);
+            Iterator<File> iter = stream.iterator();
+
+            // Wrap the iterator to allow closing the stream after consumption
+            return new Iterator<File>(){","[{'comment': 'Missing space.', 'commenter': 'garydgregory'}, {'comment': 'Done', 'commenter': 'labkey-adam'}]"
489,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -2238,7 +2260,11 @@ public static Collection<File> listFiles(final File directory, final IOFileFilte
      * @return a collection of java.io.File with the matching files
      */
     public static Collection<File> listFiles(final File directory, final String[] extensions, final boolean recursive) {
-        return Uncheck.apply(d -> toList(streamFiles(d, recursive, extensions)), directory);
+        return Uncheck.apply(d -> {","[{'comment': ""I've adopted a variant of this fix in git master. You are credited in `changes.xml` :-)"", 'commenter': 'garydgregory'}]"
489,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1996,7 +1996,29 @@ public static Iterator<File> iterateFiles(final File directory, final IOFileFilt
      * @since 1.2
      */
     public static Iterator<File> iterateFiles(final File directory, final String[] extensions, final boolean recursive) {
-        return Uncheck.apply(d -> streamFiles(d, recursive, extensions).iterator(), directory);
+        return Uncheck.apply(d -> {
+            Stream<File> stream = streamFiles(d, recursive, extensions);
+            Iterator<File> iter = stream.iterator();
+
+            // Wrap the iterator to allow closing the stream after consumption
+            return new Iterator<File>() {
+                @Override
+                public boolean hasNext() {
+                    boolean ret = iter.hasNext();
+
+                    if (!ret) {
+                        stream.close();
+                    }
+
+                    return ret;
+                }
+
+                @Override
+                public File next() {
+                    return iter.next();
+                }
+            };
+        }, directory);","[{'comment': 'No need for an anonymous class:\r\n```\r\nreturn StreamIterator.iterator(Uncheck.get(() -> streamFiles(directory, recursive, extensions)));\r\n```\r\n', 'commenter': 'garydgregory'}]"
500,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1444,7 +1444,7 @@ private static File getParentFile(final File file) {
 
     /**
      * Returns a {@link File} representing the system temporary directory.
-     *
+     * ","[{'comment': 'Spurious change; please remove from PR', 'commenter': 'sebbASF'}]"
500,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1453,8 +1453,38 @@ public static File getTempDirectory() {
     }
 
     /**
-     * Returns the path to the system temporary directory.
+     * Returns the path to the system temporary directory with the option to include or disinclude the trailing 
+     * file separator. 
      *
+     * @param includeTrailingSeparator switch indicating whether or not you want the returned path to include a 
+     * trailing file separator. 
+     * @return the path to the system temporary directory with or without the trailing file separator as per 
+     * caller supplied argument.
+     * @since 2.14.1
+     */
+    public static String getTempDirectoryPathConsistent(boolean includeTrailingSeparator) {
+        String tempDir = System.getProperty(""java.io.tmpdir"");
+        String tempDirLastChar = tempDir.substring(tempDir.length() - 1);
+        String systemFileSeparator = System.getProperty(""file.separator"");
+        if (includeTrailingSeparator) {
+            tempDir = tempDirLastChar.equals(systemFileSeparator) 
+                            ? tempDir 
+                            : tempDir + systemFileSeparator;
+        } else {
+            tempDir = tempDirLastChar.equals(systemFileSeparator) 
+                            ? tempDir.substring(0, tempDir.length() - 1) 
+                            : tempDir;
+        }
+
+        return tempDir;
+    }
+
+    /**
+     * Returns the path to the system temporary directory.
+     * 
+     * @apiNote this method relies on Java system property 'java.io.tmpdir' which may or may not return a path with 
+     * a trailing file separator, depending on the OS Java is running in. If you need the temp directory reported in a","[{'comment': 'java.io.tmpdir can also be set by the user, so it is not strictly correct to say that the trailing character depends on the OS that Java is using. It would be more accurate to say that it depends on the OS environment.', 'commenter': 'sebbASF'}]"
500,src/test/java/org/apache/commons/io/FileUtilsTest.java,"@@ -1587,13 +1587,29 @@ public void testGetFile_Parent() {
     public void testGetTempDirectory() {
         final File tempDirectory = new File(FileUtils.getTempDirectoryPath());
         assertEquals(tempDirectory, FileUtils.getTempDirectory());
-    }
+    }  ","[{'comment': 'Trailing space', 'commenter': 'sebbASF'}]"
500,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1452,9 +1452,39 @@ public static File getTempDirectory() {
         return new File(getTempDirectoryPath());
     }
 
+    /**
+     * Returns the path to the system temporary directory with the option to include or disinclude the trailing 
+     * file separator. 
+     *
+     * @param includeTrailingSeparator switch indicating whether or not you want the returned path to include a 
+     * trailing file separator. 
+     * @return the path to the system temporary directory with or without the trailing file separator as per 
+     * caller supplied argument.
+     * @since 2.14.1
+     */
+    public static String getTempDirectoryPathConsistent(boolean includeTrailingSeparator) {
+        String tempDir = System.getProperty(""java.io.tmpdir"");
+        String tempDirLastChar = tempDir.substring(tempDir.length() - 1);
+        String systemFileSeparator = System.getProperty(""file.separator"");","[{'comment': 'Just a thought, but is it possible to use `tempDir.charAt(tempDir.length() - 1)` and `File.separatorChar`?', 'commenter': 'robtimus'}, {'comment': 'what do you mean? you want  ln1468 changed to use `File.separatorChar` ? what would be the difference?', 'commenter': 'david-patchfox'}, {'comment': ""It would use `char` instead of `String` for the comparison, which would save some memory. Perhaps it's premature optimization, but whenever I can use primitives instead of objects I go for it."", 'commenter': 'robtimus'}, {'comment': ""> what do you mean? you want ln1468 changed to use `File.separatorChar` ? what would be the difference?\r\n\r\nIt's better to use an API than a magic string."", 'commenter': 'garydgregory'}, {'comment': 'I agree - that feels like a premature optimization :smile: ', 'commenter': 'david-patchfox'}]"
500,src/test/java/org/apache/commons/io/FileUtilsTest.java,"@@ -1594,6 +1594,22 @@ public void testGetTempDirectoryPath() {
         assertEquals(System.getProperty(""java.io.tmpdir""), FileUtils.getTempDirectoryPath());
     }
 
+    @Test
+    public void testGetTempDirectoryPathConsistentNoTrailingSeparator() {
+        String tempDirectoryPath = FileUtils.getTempDirectoryPathConsistent(false);","[{'comment': 'This test is not valid: It does not assert the actual path is correct. For example, if the new API returns a ""C:\\Some\\Odd\\Dir"" that is not the Java temp dir, then the test would pass.', 'commenter': 'garydgregory'}, {'comment': ""eh ok. I think that's overkill but I can change that. the method being tested is a wrapper for a different method that is already covered by the test you're looking for. that being said - wait one and I'll push an update to the test"", 'commenter': 'david-patchfox'}, {'comment': ""done and done. I've added assertions to both tests that ensure the root path is the same as is reported by property `java.io.tmpdir`"", 'commenter': 'david-patchfox'}]"
500,src/main/java/org/apache/commons/io/FileUtils.java,"@@ -1452,9 +1452,39 @@ public static File getTempDirectory() {
         return new File(getTempDirectoryPath());
     }
 
+    /**
+     * Returns the path to the system temporary directory with the option to include or disinclude the trailing ","[{'comment': 'disinclude => exclude', 'commenter': 'sebbASF'}, {'comment': 'done', 'commenter': 'david-patchfox'}]"
500,src/test/java/org/apache/commons/io/FileUtilsTest.java,"@@ -1594,6 +1594,24 @@ public void testGetTempDirectoryPath() {
         assertEquals(System.getProperty(""java.io.tmpdir""), FileUtils.getTempDirectoryPath());
     }
 
+    @Test
+    public void testGetTempDirectoryPathConsistentNoTrailingSeparator() {
+        String tempDirectoryPath = FileUtils.getTempDirectoryPathConsistent(false);
+        assertTrue(tempDirectoryPath.startsWith(System.getProperty(""java.io.tmpdir"")));","[{'comment': ""If tmpdir = '/tmp/a/' then surely tempDirectoryPath => '/tmp/a' and the assertion fails?\r\nMaybe the arguments should be the other way round?\r\n\r\nAlso if tempDirectoryPath is mis-calculated as '/tmp/a/b/c/d', then the assertion does not fail.\r\n\r\ntmpdir.length() - tempDirectoryPath.length() should be 0 or 1"", 'commenter': 'sebbASF'}]"
500,src/test/java/org/apache/commons/io/FileUtilsTest.java,"@@ -1594,6 +1594,24 @@ public void testGetTempDirectoryPath() {
         assertEquals(System.getProperty(""java.io.tmpdir""), FileUtils.getTempDirectoryPath());
     }
 
+    @Test
+    public void testGetTempDirectoryPathConsistentNoTrailingSeparator() {
+        String tempDirectoryPath = FileUtils.getTempDirectoryPathConsistent(false);
+        assertTrue(tempDirectoryPath.startsWith(System.getProperty(""java.io.tmpdir"")));
+        String systemFileSeparator = System.getProperty(""file.separator"");
+        String lastCharOfTempDirectoryPath = tempDirectoryPath.substring(tempDirectoryPath.length() - 1);
+        assertNotEquals(lastCharOfTempDirectoryPath, systemFileSeparator);","[{'comment': 'This assumes that tmpdir cannot end with two consecutive separators', 'commenter': 'sebbASF'}]"
500,src/test/java/org/apache/commons/io/FileUtilsTest.java,"@@ -1594,6 +1594,24 @@ public void testGetTempDirectoryPath() {
         assertEquals(System.getProperty(""java.io.tmpdir""), FileUtils.getTempDirectoryPath());
     }
 
+    @Test
+    public void testGetTempDirectoryPathConsistentNoTrailingSeparator() {
+        String tempDirectoryPath = FileUtils.getTempDirectoryPathConsistent(false);
+        assertTrue(tempDirectoryPath.startsWith(System.getProperty(""java.io.tmpdir"")));
+        String systemFileSeparator = System.getProperty(""file.separator"");
+        String lastCharOfTempDirectoryPath = tempDirectoryPath.substring(tempDirectoryPath.length() - 1);
+        assertNotEquals(lastCharOfTempDirectoryPath, systemFileSeparator);
+    }
+
+    @Test
+    public void testGetTempDirectoryPathConsistentWithTrailingSeparator() {
+        String tempDirectoryPath = FileUtils.getTempDirectoryPathConsistent(true);
+        assertTrue(tempDirectoryPath.startsWith(System.getProperty(""java.io.tmpdir"")));","[{'comment': 'Does not allow for spurious trailing content.', 'commenter': 'sebbASF'}, {'comment': ""same as above - what's the reasonable concern here? "", 'commenter': 'david-patchfox'}, {'comment': 'That the method does not generate the correct result at some time in the future due to code changes.\r\n\r\nWhen writing these tests, they have to be done without assuming any knowledge of how the code is written.\r\nSo one cannot assume that the only error might be incorrect treatment of a trailing separator.\r\nYou have to assume that the code might generate arbitrary output.', 'commenter': 'sebbASF'}]"
507,src/test/java/org/apache/commons/io/input/TailerTest.java,"@@ -425,7 +453,7 @@ public void testMultiByteBreak() throws Exception {
             thread.start();
 
             try (Writer out = new OutputStreamWriter(Files.newOutputStream(file.toPath()), charsetUTF8);
-                BufferedReader reader = new BufferedReader(new InputStreamReader(Files.newInputStream(origin.toPath()), charsetUTF8))) {
+                 BufferedReader reader = new BufferedReader(new InputStreamReader(Files.newInputStream(origin.toPath()), charsetUTF8))) {","[{'comment': ""Spurious change - please don't change unrelated code"", 'commenter': 'sebbASF'}, {'comment': 'shawanyi', 'commenter': 'monster12137'}]"
507,src/test/java/org/apache/commons/io/input/TailerTest.java,"@@ -711,7 +739,9 @@ private void validateTailer(final TestTailerListener listener, final File file)
         assertEquals(listener.getLines(), Arrays.asList(""foo""), ""lines"");
     }
 
-    /** Appends lines to a file */
+    /**
+     * Appends lines to a file
+     */","[{'comment': ""Please don't change unrelated code"", 'commenter': 'sebbASF'}]"
507,src/test/java/org/apache/commons/io/input/TailerTest.java,"@@ -720,7 +750,9 @@ private void write(final File file, final String... lines) throws IOException {
         }
     }
 
-    /** Appends strings to a file */
+    /**
+     * Appends strings to a file
+     */","[{'comment': 'Unrelated code should be left alone', 'commenter': 'sebbASF'}]"
515,src/main/java/org/apache/commons/io/FileSizeUnit.java,"@@ -0,0 +1,234 @@
+package org.apache.commons.io;
+
+import java.text.DecimalFormat;
+
+/**
+ * File size conversion tool, supporting mutual conversion of TB, GB, MB, KB, Byte, etc.,
+ * as well as converting the size of numeric types into human-readable strings.
+ * @author hellozrh
+ * @date 2023-11-19
+ */
+public enum FileSizeUnit {
+    /**Byte*/
+    BYTE {
+        @Override
+        public long toByte(long duration) {","[{'comment': 'Duration?', 'commenter': 'michael-o'}, {'comment': 'It should be length', 'commenter': 'hellozrh'}]"
