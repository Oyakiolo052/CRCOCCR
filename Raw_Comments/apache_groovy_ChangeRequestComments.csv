Pull,Path,Diff_hunk,Comment
472,subprojects/groovy-macro/src/main/groovy/org/codehaus/groovy/macro/runtime/Macro.java,"@@ -0,0 +1,36 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  ""License""); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.macro.runtime;
+
+import org.apache.groovy.lang.annotation.Incubating;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * @author Sergei Egorov <bsideup@gmail.com>
+ */
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.METHOD})
+@Incubating
+public @interface Macro {","[{'comment': 'Missing `@since`.', 'commenter': 'melix'}]"
472,subprojects/groovy-macro/src/main/groovy/org/codehaus/groovy/macro/runtime/MacroStub.java,"@@ -0,0 +1,32 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  ""License""); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.macro.runtime;
+
+/**
+ * Stub for macro calls.","[{'comment': 'Would you mind giving more context on this? It might be hard for newcomers to figure out.', 'commenter': 'melix'}]"
472,subprojects/groovy-macro/src/main/groovy/org/codehaus/groovy/macro/transform/MacroClassTransformation.java,"@@ -0,0 +1,114 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  ""License""); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.macro.transform;
+
+import org.codehaus.groovy.ast.*;
+import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.ast.tools.GeneralUtils;
+import org.codehaus.groovy.control.CompilePhase;
+import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.macro.methods.MacroGroovyMethods;
+import org.codehaus.groovy.macro.runtime.MacroBuilder;
+import org.codehaus.groovy.transform.GroovyASTTransformation;
+
+import java.util.Iterator;
+import java.util.List;
+
+import static org.codehaus.groovy.ast.tools.GeneralUtils.*;
+
+@GroovyASTTransformation(phase = CompilePhase.CONVERSION)
+public class MacroClassTransformation extends MethodCallTransformation {
+
+    private static final String MACRO_METHOD = ""macro"";
+    private static final ClassNode MACROCLASS_TYPE = ClassHelper.make(MacroClass.class);
+
+    @Override
+    protected GroovyCodeVisitor getTransformer(final ASTNode[] nodes, final SourceUnit sourceUnit) {
+        ClassCodeExpressionTransformer transformer = new ClassCodeExpressionTransformer() {","[{'comment': ""I think this would benefit from being a static inner class. There's no clear interest in keeping a reference back to the transformation itself."", 'commenter': 'melix'}]"
472,subprojects/groovy-macro/src/main/groovy/org/codehaus/groovy/macro/transform/MacroClassTransformation.java,"@@ -0,0 +1,114 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  ""License""); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.macro.transform;
+
+import org.codehaus.groovy.ast.*;
+import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.ast.tools.GeneralUtils;
+import org.codehaus.groovy.control.CompilePhase;
+import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.macro.methods.MacroGroovyMethods;
+import org.codehaus.groovy.macro.runtime.MacroBuilder;
+import org.codehaus.groovy.transform.GroovyASTTransformation;
+
+import java.util.Iterator;
+import java.util.List;
+
+import static org.codehaus.groovy.ast.tools.GeneralUtils.*;
+
+@GroovyASTTransformation(phase = CompilePhase.CONVERSION)
+public class MacroClassTransformation extends MethodCallTransformation {
+
+    private static final String MACRO_METHOD = ""macro"";
+    private static final ClassNode MACROCLASS_TYPE = ClassHelper.make(MacroClass.class);
+
+    @Override
+    protected GroovyCodeVisitor getTransformer(final ASTNode[] nodes, final SourceUnit sourceUnit) {
+        ClassCodeExpressionTransformer transformer = new ClassCodeExpressionTransformer() {
+            @Override
+            protected SourceUnit getSourceUnit() {
+                return sourceUnit;
+            }
+
+            @Override
+            public Expression transform(final Expression exp) {
+                if (exp instanceof ConstructorCallExpression) {
+                    MethodCallExpression call = exp.getNodeMetaData(MacroTransformation.class);
+                    if (call != null) {
+                        return call;
+                    }
+                }
+                return super.transform(exp);
+            }
+        };
+
+        return new TransformingCodeVisitor(transformer) {","[{'comment': 'Same here. Could you extract a class for this?', 'commenter': 'melix'}]"
472,subprojects/groovy-macro/src/main/groovy/org/codehaus/groovy/macro/transform/MacroTransformation.java,"@@ -18,42 +18,113 @@
  */
 package org.codehaus.groovy.macro.transform;
 
+import groovy.transform.CompilationUnitAware;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.classgen.asm.InvocationWriter;
+import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.macro.runtime.MacroContext;
+import org.codehaus.groovy.macro.runtime.MacroStub;
+import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.transform.GroovyASTTransformation;
+import org.codehaus.groovy.transform.stc.ExtensionMethodNode;
+import org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport;
+
+import java.util.ArrayList;
+import java.util.List;
 
 /**
- *
  * @author Sergei Egorov <bsideup@gmail.com>
  */
 
 @GroovyASTTransformation(phase = CompilePhase.CONVERSION)
-public class MacroTransformation extends MethodCallTransformation {
+public class MacroTransformation extends MethodCallTransformation implements CompilationUnitAware {
+
+    private static final ClassNode MACRO_CONTEXT_CLASS_NODE = ClassHelper.make(MacroContext.class);
+
+    private static final ClassNode MACRO_STUB_CLASS_NODE = ClassHelper.make(MacroStub.class);
+
+    private static final PropertyExpression MACRO_STUB_INSTANCE = new PropertyExpression(new ClassExpression(MACRO_STUB_CLASS_NODE), ""INSTANCE"");
+
+    private static final String MACRO_STUB_METHOD_NAME = ""macroMethod"";
+
+    protected CompilationUnit unit;
 
-    public static final String DOLLAR_VALUE = ""$v"";
-    public static final String MACRO_METHOD = ""macro"";
+    @Override
+    public void setCompilationUnit(CompilationUnit unit) {
+        this.unit = unit;
+    }
 
     @Override
-    protected GroovyCodeVisitor getTransformer(final ASTNode[] nodes, final SourceUnit sourceUnit) {
-        final ClassCodeExpressionTransformer trn = new ClassCodeExpressionTransformer() {
+    protected GroovyCodeVisitor getTransformer(ASTNode[] nodes, final SourceUnit sourceUnit) {
+        // Macro methods should on a classpath of the compiler because we invoke them during the compilation
+        final ClassLoader classLoader = this.getClass().getClassLoader();
+        return new ClassCodeVisitorSupport() {
+
             @Override
             protected SourceUnit getSourceUnit() {
                 return sourceUnit;
             }
 
             @Override
-            public Expression transform(final Expression exp) {
-                if (exp instanceof ConstructorCallExpression) {
-                    MethodCallExpression call = exp.getNodeMetaData(MacroTransformation.class);
-                    if (call!=null) {
-                        return call;
+            public void visitMethodCallExpression(MethodCallExpression call) {
+                super.visitMethodCallExpression(call);
+
+                List<MethodNode> methods = MacroMethodsCache.get(classLoader).get(call.getMethodAsString());
+
+                if (methods == null) {
+                    // Not a macro call
+                    return;
+                }
+
+                List<Expression> callArguments = InvocationWriter.makeArgumentList(call.getArguments()).getExpressions();
+
+                ClassNode[] argumentsList = new ClassNode[callArguments.size()];
+
+                for (int i = 0; i < callArguments.size(); i++) {
+                    argumentsList[i] = ClassHelper.make(callArguments.get(i).getClass());
+                }
+
+                methods = StaticTypeCheckingSupport.chooseBestMethod(MACRO_CONTEXT_CLASS_NODE, methods, argumentsList);
+
+                for (MethodNode macroMethodNode : methods) {
+                    if (!(macroMethodNode instanceof ExtensionMethodNode)) {
+                        // TODO is it even possible?","[{'comment': ""If you don't know if it's possible, it's probably better to throw an error. Then if the case appears we know we need to fix it."", 'commenter': 'melix'}]"
472,subprojects/groovy-macro/src/main/groovy/org/codehaus/groovy/macro/transform/MacroTransformation.java,"@@ -18,42 +18,113 @@
  */
 package org.codehaus.groovy.macro.transform;
 
+import groovy.transform.CompilationUnitAware;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.classgen.asm.InvocationWriter;
+import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.macro.runtime.MacroContext;
+import org.codehaus.groovy.macro.runtime.MacroStub;
+import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.transform.GroovyASTTransformation;
+import org.codehaus.groovy.transform.stc.ExtensionMethodNode;
+import org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport;
+
+import java.util.ArrayList;
+import java.util.List;
 
 /**
- *
  * @author Sergei Egorov <bsideup@gmail.com>
  */
 
 @GroovyASTTransformation(phase = CompilePhase.CONVERSION)
-public class MacroTransformation extends MethodCallTransformation {
+public class MacroTransformation extends MethodCallTransformation implements CompilationUnitAware {
+
+    private static final ClassNode MACRO_CONTEXT_CLASS_NODE = ClassHelper.make(MacroContext.class);
+
+    private static final ClassNode MACRO_STUB_CLASS_NODE = ClassHelper.make(MacroStub.class);
+
+    private static final PropertyExpression MACRO_STUB_INSTANCE = new PropertyExpression(new ClassExpression(MACRO_STUB_CLASS_NODE), ""INSTANCE"");
+
+    private static final String MACRO_STUB_METHOD_NAME = ""macroMethod"";
+
+    protected CompilationUnit unit;
 
-    public static final String DOLLAR_VALUE = ""$v"";
-    public static final String MACRO_METHOD = ""macro"";
+    @Override
+    public void setCompilationUnit(CompilationUnit unit) {
+        this.unit = unit;
+    }
 
     @Override
-    protected GroovyCodeVisitor getTransformer(final ASTNode[] nodes, final SourceUnit sourceUnit) {
-        final ClassCodeExpressionTransformer trn = new ClassCodeExpressionTransformer() {
+    protected GroovyCodeVisitor getTransformer(ASTNode[] nodes, final SourceUnit sourceUnit) {
+        // Macro methods should on a classpath of the compiler because we invoke them during the compilation
+        final ClassLoader classLoader = this.getClass().getClassLoader();
+        return new ClassCodeVisitorSupport() {
+
             @Override
             protected SourceUnit getSourceUnit() {
                 return sourceUnit;
             }
 
             @Override
-            public Expression transform(final Expression exp) {
-                if (exp instanceof ConstructorCallExpression) {
-                    MethodCallExpression call = exp.getNodeMetaData(MacroTransformation.class);
-                    if (call!=null) {
-                        return call;
+            public void visitMethodCallExpression(MethodCallExpression call) {","[{'comment': 'This method is very long. Could you split it into smaller focused pieces?', 'commenter': 'melix'}]"
472,subprojects/groovy-macro/src/main/groovy/org/codehaus/groovy/macro/transform/MacroMethodsCache.java,"@@ -0,0 +1,144 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  ""License""); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.macro.transform;
+
+import org.codehaus.groovy.ast.ClassHelper;
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.MethodNode;
+import org.codehaus.groovy.ast.Parameter;
+import org.codehaus.groovy.macro.runtime.Macro;
+import org.codehaus.groovy.runtime.m12n.ExtensionModule;
+import org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner;
+import org.codehaus.groovy.runtime.m12n.MetaInfExtensionModule;
+import org.codehaus.groovy.transform.stc.ExtensionMethodNode;
+
+import java.util.*;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * TODO share some code with {@link org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.ExtensionMethodCache}
+ * @author Sergei Egorov <bsideup@gmail.com>
+ * @since 2.5.0
+ */
+class MacroMethodsCache {","[{'comment': 'Maybe you can reuse LRU cache in the parrot branch: https://issues.apache.org/jira/browse/GROOVY-7977', 'commenter': 'daniellansun'}, {'comment': 'We could once parrot is merged to master :) ', 'commenter': 'bsideup'}]"
523,src/main/org/codehaus/groovy/vmplugin/VMPluginFactory.java,"@@ -26,39 +28,10 @@
  */
 public class VMPluginFactory {
 
-    private static final String JDK5_CLASSNAME_CHECK = ""java.lang.annotation.Annotation"";
-    private static final String JDK6_CLASSNAME_CHECK = ""javax.script.ScriptEngine"";
-    private static final String JDK7_CLASSNAME_CHECK = ""java.util.Objects"";
-
-    private static final String JDK5_PLUGIN_NAME = ""org.codehaus.groovy.vmplugin.v5.Java5"";
-    private static final String JDK6_PLUGIN_NAME = ""org.codehaus.groovy.vmplugin.v6.Java6"";
-    private static final String JDK7_PLUGIN_NAME = ""org.codehaus.groovy.vmplugin.v7.Java7"";
-
-    private static VMPlugin plugin;
-
-    static {
-        plugin = createPlugin(JDK7_CLASSNAME_CHECK, JDK7_PLUGIN_NAME);
-        if (plugin == null) {
-            // v6 plugin is the same as v5 but with some scripting stuff
-            // so check below is good enough for now (can be true for JVM 5)
-            plugin = createPlugin(JDK6_CLASSNAME_CHECK, JDK6_PLUGIN_NAME);
-        }
-        if (plugin == null) {
-            plugin = createPlugin(JDK5_CLASSNAME_CHECK, JDK5_PLUGIN_NAME);
-        }
-    }
+    private static final VMPlugin plugin = new Java7();
 
     public static VMPlugin getPlugin() {
         return plugin;
     }
 
-    private static VMPlugin createPlugin(String classNameCheck, String pluginName) {","[{'comment': 'we will still need this for the JDK9 plugin', 'commenter': 'blackdrag'}]"
811,src/main/java/org/codehaus/groovy/vmplugin/v9/Java9.java,"@@ -18,14 +18,78 @@
  */
 package org.codehaus.groovy.vmplugin.v9;
 
+import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.vmplugin.v8.Java8;
 
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
 /**
- * Java 9 based functions will be added here if needed.
+ * Additional Java 9 based functions will be added here as needed.
  */
 public class Java9 extends Java8 {
+
+    private static class LookupHolder {
+        private static final Method PRIVATE_LOOKUP;
+        private static final Constructor<MethodHandles.Lookup> LOOKUP_Constructor;
+        static {
+            Constructor<MethodHandles.Lookup> lookup = null;
+            Method privateLookup = null;
+            try { // java 9
+                privateLookup = MethodHandles.class.getMethod(""privateLookupIn"", Class.class, MethodHandles.Lookup.class);","[{'comment': 'why do we do a reflective lookup here for a method that is public static? This is already the Java 9 module, so pre Java 9 code is of no concern... especially the NoSuchMethodException is supposed to never happen here', 'commenter': 'blackdrag'}, {'comment': ""We don't eventually, I was just letting the build be built from Java 8 (with current warnings) until we get more things in place."", 'commenter': 'paulk-asert'}]"
811,src/main/java/org/codehaus/groovy/vmplugin/v9/Java9.java,"@@ -18,14 +18,78 @@
  */
 package org.codehaus.groovy.vmplugin.v9;
 
+import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.vmplugin.v8.Java8;
 
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
 /**
- * Java 9 based functions will be added here if needed.
+ * Additional Java 9 based functions will be added here as needed.
  */
 public class Java9 extends Java8 {
+
+    private static class LookupHolder {
+        private static final Method PRIVATE_LOOKUP;
+        private static final Constructor<MethodHandles.Lookup> LOOKUP_Constructor;
+        static {
+            Constructor<MethodHandles.Lookup> lookup = null;
+            Method privateLookup = null;
+            try { // java 9
+                privateLookup = MethodHandles.class.getMethod(""privateLookupIn"", Class.class, MethodHandles.Lookup.class);
+            } catch (final NoSuchMethodException e) { // java 8
+                try {
+                    lookup = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class, Integer.TYPE);
+                    if (!lookup.isAccessible()) {","[{'comment': 'we can actually not rely on this being accessible... I am missing the IllegalAccessException and InaccessibleObjectException handling here... ', 'commenter': 'blackdrag'}]"
811,src/main/java/org/codehaus/groovy/vmplugin/v9/Java9.java,"@@ -18,14 +18,78 @@
  */
 package org.codehaus.groovy.vmplugin.v9;
 
+import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.vmplugin.v8.Java8;
 
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
 /**
- * Java 9 based functions will be added here if needed.
+ * Additional Java 9 based functions will be added here as needed.
  */
 public class Java9 extends Java8 {
+
+    private static class LookupHolder {
+        private static final Method PRIVATE_LOOKUP;
+        private static final Constructor<MethodHandles.Lookup> LOOKUP_Constructor;
+        static {
+            Constructor<MethodHandles.Lookup> lookup = null;
+            Method privateLookup = null;
+            try { // java 9
+                privateLookup = MethodHandles.class.getMethod(""privateLookupIn"", Class.class, MethodHandles.Lookup.class);
+            } catch (final NoSuchMethodException e) { // java 8
+                try {
+                    lookup = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class, Integer.TYPE);
+                    if (!lookup.isAccessible()) {
+                        lookup.setAccessible(true);
+                    }
+                } catch (final NoSuchMethodException ex) {
+                    throw new IllegalStateException(""Incompatible JVM"", e);
+                }
+            }
+            PRIVATE_LOOKUP = privateLookup;
+            LOOKUP_Constructor = lookup;
+        }
+    }
+
+    private static Constructor<MethodHandles.Lookup> getLookupConstructor() {
+        return LookupHolder.LOOKUP_Constructor;
+    }
+
+    private static Method getPrivateLookup() {
+        return LookupHolder.PRIVATE_LOOKUP;
+    }
+
+    public static MethodHandles.Lookup of(final Class<?> declaringClass) {
+        try {
+            if (getPrivateLookup() != null) {
+                return MethodHandles.Lookup.class.cast(getPrivateLookup().invoke(null, declaringClass, MethodHandles.lookup()));
+            }
+            return getLookupConstructor().newInstance(declaringClass, MethodHandles.Lookup.PRIVATE).in(declaringClass);","[{'comment': 'If PRIVATE_LOOKUP lookup never fails as I think, then LOOKUP_Constructor will be always the same. Not sure if ""in"" (https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-) then can still do something useful.', 'commenter': 'blackdrag'}]"
870,src/main/java/org/codehaus/groovy/control/DefaultImportedClassCollectorHelper.java,"@@ -0,0 +1,226 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  ""License""); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.control;
+
+import groovy.lang.GroovySystem;
+import org.codehaus.groovy.runtime.DefaultGroovyMethods;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.logging.Logger;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+
+/**
+ * Represents the helper for DefaultImportedClassCollector
+ *
+ * Note: `DefaultImportedClassCollector` relies on the 3rd-party lib ClassGraph, as a result, it is not always able to be loaded,
+ *        so the class is necessary to keep common info and provide util methods
+ *
+ * @since 3.0.0
+ */
+public class DefaultImportedClassCollectorHelper {
+    public static final String[] DEFAULT_IMPORTS = { ""java.lang."", ""java.util."", ""java.io."", ""java.net."", ""groovy.lang."", ""groovy.util."" };
+    private static final String DEFAULTIMPORTEDCLASSCOLLECTOR_CLASSNAME = ""org.codehaus.groovy.control.DefaultImportedClassCollector"";
+    private static final Logger LOGGER = Logger.getLogger(DefaultImportedClassCollectorHelper.class.getName());
+
+    public static Map<String, Set<String>> getClassNameToPackageMap() {
+        Map<String, Set<String>> result = null;
+        File classesInfoFile = LazyInfoHolder.CLASSES_INFO_FILE;
+        boolean exists = classesInfoFile.exists();
+        boolean same = false;
+        boolean errOccurred = false;
+        String javaVersion = LazyInfoHolder.JAVA_VERSION;
+        String groovyVersion = LazyInfoHolder.GROOVY_VERSION;
+
+        if (exists) {
+            try (ObjectInputStream ois =
+                         new ObjectInputStream(
+                                 new GZIPInputStream(
+                                         new BufferedInputStream(
+                                                 new FileInputStream(classesInfoFile))))) {
+                DefaultImportedClassesInfo classesInfo = (DefaultImportedClassesInfo) ois.readObject();
+
+                same = Objects.equals(javaVersion, classesInfo.getJavaVersion())
+                        && Objects.equals(groovyVersion, classesInfo.getGroovyVersion())
+                        && Arrays.equals(DEFAULT_IMPORTS, classesInfo.getPackageNames());
+
+                result = classesInfo.getClassNameToPackageMap();
+            } catch (Exception e) {
+                LOGGER.warning(""Failed to read "" + classesInfoFile.getAbsolutePath() + "".\n"" + DefaultGroovyMethods.asString(e));
+                errOccurred = true;
+            }
+        }
+
+        if (null == result || !same) {
+            result = doGetClassNameToPackageMap();
+        }
+
+        if ((null != result) && (!exists || !same)) {
+            File cachesDir = classesInfoFile.getParentFile();
+            if (!cachesDir.exists()) {
+                cachesDir.mkdirs();
+            }
+
+            try (ObjectOutputStream oos =
+                         new ObjectOutputStream(
+                                 new GZIPOutputStream(
+                                         new BufferedOutputStream(
+                                                 new FileOutputStream(classesInfoFile))))) {
+                DefaultImportedClassesInfo classesInfo = new DefaultImportedClassesInfo(javaVersion, groovyVersion, DEFAULT_IMPORTS, result);
+                oos.writeObject(classesInfo);
+            } catch (Exception e) {
+                LOGGER.warning(""Failed to generate "" + classesInfoFile.getAbsolutePath() + "".\n"" + DefaultGroovyMethods.asString(e));
+                errOccurred = true;
+            }
+        }
+
+        if (errOccurred) {
+            classesInfoFile.delete();
+        }
+
+        return result;
+    }
+
+    @SuppressWarnings(""unchecked"")
+    private static Map<String, Set<String>> doGetClassNameToPackageMap() {
+        Map<String, Set<String>> result = null;
+        try {
+            Class defaultImportedClassCollectorClazz = Class.forName(DEFAULTIMPORTEDCLASSCOLLECTOR_CLASSNAME);
+
+            Object defaultImportedClassCollector = defaultImportedClassCollectorClazz.getField(""INSTANCE"").get(null);
+            result = (Map<String, Set<String>>) defaultImportedClassCollectorClazz.getDeclaredMethod(""getClassNameToPackageMap"").invoke(defaultImportedClassCollector);
+        } catch (ClassNotFoundException | NoClassDefFoundError e) {
+            LOGGER.severe(""Runtime dependency classgraph(io.github.classgraph:classgraph) not found.\n"" + DefaultGroovyMethods.asString(e));
+        } catch (Throwable t) {
+            LOGGER.severe(""Failed to collect default imported class info.\n"" + DefaultGroovyMethods.asString(t));
+        }
+
+        return result;
+    }
+
+    private static class DefaultImportedClassesInfo implements Serializable {
+        private static final long serialVersionUID = 9017949572933849622L;
+        private String javaVersion;
+        private String groovyVersion;
+        private String[] packageNames;
+        private Map<String, Set<String>> classNameToPackageMap;
+
+        public DefaultImportedClassesInfo(String javaVersion, String groovyVersion, String[] packageNames, Map<String, Set<String>> classNameToPackageMap) {
+            this.javaVersion = javaVersion;
+            this.groovyVersion = groovyVersion;
+            this.packageNames = packageNames;
+            this.classNameToPackageMap = classNameToPackageMap;
+        }
+
+        public static long getSerialVersionUID() {
+            return serialVersionUID;
+        }
+
+        public String getJavaVersion() {
+            return javaVersion;
+        }
+
+        public void setJavaVersion(String javaVersion) {
+            this.javaVersion = javaVersion;
+        }
+
+        public String getGroovyVersion() {
+            return groovyVersion;
+        }
+
+        public void setGroovyVersion(String groovyVersion) {
+            this.groovyVersion = groovyVersion;
+        }
+
+        public String[] getPackageNames() {
+            return packageNames;
+        }
+
+        public void setPackageNames(String[] packageNames) {
+            this.packageNames = packageNames;
+        }
+
+        public Map<String, Set<String>> getClassNameToPackageMap() {
+            return classNameToPackageMap;
+        }
+
+        public void setClassNameToPackageMap(Map<String, Set<String>> classNameToPackageMap) {
+            this.classNameToPackageMap = classNameToPackageMap;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof DefaultImportedClassesInfo)) return false;
+            DefaultImportedClassesInfo that = (DefaultImportedClassesInfo) o;
+            return Objects.equals(javaVersion, that.javaVersion) &&
+                    Objects.equals(groovyVersion, that.groovyVersion) &&
+                    Arrays.equals(packageNames, that.packageNames);
+        }
+
+        @Override
+        public int hashCode() {
+            int result = Objects.hash(javaVersion, groovyVersion);
+            result = 31 * result + Arrays.hashCode(packageNames);
+            return result;
+        }
+
+        @Override
+        public String toString() {
+            return ""DefaultImportedClassesInfo{"" +
+                    ""javaVersion='"" + javaVersion + '\'' +
+                    "", groovyVersion='"" + groovyVersion + '\'' +
+                    "", packageNames="" + Arrays.toString(packageNames) +
+                    "", classNameToPackageMap="" + classNameToPackageMap +
+                    '}';
+        }
+    }
+
+    private static class LazyInfoHolder {
+        private static final String SNAPSHOT = ""SNAPSHOT"";
+        private static final File CLASSES_INFO_FILE = new File(new File(GroovySystem.getGroovyRoot(), ""caches""), ""default_imported_classes"");
+        private static final String JAVA_VERSION = System.getProperty(""java.version"");
+        private static final String GROOVY_VERSION = getGroovyVersion();
+
+        private static String getGroovyVersion() {
+            String version = GroovySystem.getVersion();
+            version = (null == version || version.trim().isEmpty()) ? SNAPSHOT : version;
+
+            // if using SNAPSHOT version(e.g. 3.0.0-SNAPSHOT), cache for only 1 hour because default imported classes may change when developing
+            return version.contains(SNAPSHOT) ? version + new SimpleDateFormat(""-yyyyMMdd.HH"").format(new Date()) : version;","[{'comment': "":x: I think this is problematic. We shouldn't bake in a rule like this. Ideally this should be a hash of the Groovy runtime."", 'commenter': 'melix'}, {'comment': '""Ideally this should be a hash of the Groovy runtime."" -- could you provide me more details about Groovy runtime? In other words, what information can help us identify the Groovy runtime?', 'commenter': 'daniellansun'}]"
993,src/main/java/groovy/ui/GroovyMain.java,"@@ -121,15 +120,24 @@ public static void main(String args[]) {
     static void processArgs(String[] args, final PrintStream out) {
         processArgs(args, out, out);
     }
+
     // package-level visibility for testing purposes (just usage/errors at this stage)
     static void processArgs(String[] args, final PrintStream out, final PrintStream err) {
         GroovyCommand groovyCommand = new GroovyCommand();
-        CommandLine parser = new CommandLine(groovyCommand).setUnmatchedArgumentsAllowed(true).setStopAtUnmatched(true);
+
+        CommandLine parser = new CommandLine(groovyCommand)
+                .setOut(new PrintWriter(out))
+                .setErr(new PrintWriter(err))
+                .setUnmatchedArgumentsAllowed(true)
+                .setStopAtUnmatched(true);
+
         try {
-            List<CommandLine> result = parser.parse(args);
-            if (CommandLine.printHelpIfRequested(result, out, err, Help.Ansi.AUTO)) {
+            ParseResult result = parser.parseArgs(args);
+
+            if (CommandLine.printHelpIfRequested(result)) {","[{'comment': 'Thanks for updating from the deprecated methods to the newer API. ', 'commenter': 'remkop'}]"
993,src/main/java/groovy/ui/GroovyMain.java,"@@ -223,8 +231,14 @@ static void processArgs(String[] args, final PrintStream out, final PrintStream
         @Option(names = {""-v"", ""--version""}, versionHelp = true, description = ""Print version information and exit"")
         private boolean versionRequested;
 
+        @Option(names = {""-cs"", ""--compile-static""}, description = ""Use CompileStatic"")","[{'comment': ""It's better to have a single-character short option if possible.\r\nThat allows picocli to treat it as a POSIX short option, with benefits for parsing and the usage help message layout."", 'commenter': 'remkop'}, {'comment': 'Ok, I think it is better to leave only full option names.', 'commenter': 'kohutd'}]"
993,src/main/java/groovy/ui/GroovyMain.java,"@@ -223,8 +231,14 @@ static void processArgs(String[] args, final PrintStream out, final PrintStream
         @Option(names = {""-v"", ""--version""}, versionHelp = true, description = ""Print version information and exit"")
         private boolean versionRequested;
 
+        @Option(names = {""-cs"", ""--compile-static""}, description = ""Use CompileStatic"")
+        private boolean compileStatic;
+
+        @Option(names = {""-tc"", ""--type-checked""}, description = ""Use TypeChecked"")","[{'comment': 'Here also, it would be better to have a single-character short option.', 'commenter': 'remkop'}]"
993,src/main/java/groovy/ui/GroovyMain.java,"@@ -289,37 +304,82 @@ boolean process(CommandLine parser) throws ParameterException, IOException {
                 main.conf.setScriptBaseClass(scriptBaseClass);
             }
 
+            final List<String> transformations = new ArrayList<>();
+            if (compileStatic) {
+                transformations.add(""ast(groovy.transform.CompileStatic)"");
+            }
+            if (typeChecked) {
+                transformations.add(""ast(groovy.transform.TypeChecked)"");
+            }
+            processConfigScriptText(buildConfigScriptText(transformations), main.conf);
+
             processConfigScripts(getConfigScripts(), main.conf);
 
             main.args = arguments;
+
             return main.run();
         }
 
         private List<String> getConfigScripts() {
             List<String> scripts = new ArrayList<String>();
+
             if (this.configscript != null) {
                 scripts.add(this.configscript);
             }
+
             String configScripts = System.getProperty(""groovy.starter.configscripts"", null);
+
             if (configScripts != null && !configScripts.isEmpty()) {
-                scripts.addAll(StringGroovyMethods.tokenize((CharSequence) configScripts, ','));
+                scripts.addAll(StringGroovyMethods.tokenize(configScripts, ','));
             }
+
             return scripts;
         }
     }
 
     public static void processConfigScripts(List<String> scripts, CompilerConfiguration conf) throws IOException {
         if (scripts.isEmpty()) return;
+
+        GroovyShell shell = createConfigScriptsShell(conf);
+
+        for (String script : scripts) {
+            shell.evaluate(new File(script));
+        }
+    }
+
+    public static void processConfigScriptText(final String scriptText, final CompilerConfiguration conf) {","[{'comment': 'Maybe no need for the `final` keyword here. Better to keep the coding style consistent with the rest of the file.', 'commenter': 'remkop'}]"
993,src/main/java/org/codehaus/groovy/tools/FileSystemCompiler.java,"@@ -359,9 +393,15 @@ public URL loadGroovySource(String filename) throws MalformedURLException {
         private boolean versionRequested;
 
         @Parameters(description = ""The groovy source files to compile, or @-files containing a list of source files to compile"",
-                    paramLabel = ""<source-files>"")
+                paramLabel = ""<source-files>"")
         private List<String> files;
 
+        @Option(names = {""-cs"", ""--compile-static""}, description = ""Use CompileStatic"")","[{'comment': 'Same as above, can we use single-character short options?', 'commenter': 'remkop'}]"
1053,src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java,"@@ -29,6 +29,7 @@
 import groovy.transform.stc.ClosureParams;
 import groovy.transform.stc.ClosureSignatureConflictResolver;
 import groovy.transform.stc.ClosureSignatureHint;
+import jdk.internal.org.objectweb.asm.Opcodes;","[{'comment': 'We should use `org.objectweb.asm.Opcodes` instead of `jdk.internal.org.objectweb.asm.Opcodes`', 'commenter': 'daniellansun'}, {'comment': 'oh, i see, thanks.', 'commenter': 'Unknown'}]"
1202,src/main/java/groovy/util/GroovyCollections.java,"@@ -18,16 +18,19 @@
  */
 package groovy.util;
 
+import org.codehaus.groovy.runtime.ArrayUtil;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
 import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
+import java.util.*;","[{'comment': 'We prefer importing qualified classes and avoid using `*`', 'commenter': 'daniellansun'}, {'comment': 'I agree, i usually prefer it too but this it was my mistake because i had not adjusted the settings in my ide and it dit the * automatically. Feel free to CTRL + O to adjust the imports', 'commenter': 'DarioArena87'}]"
1202,gradle/wrapper/gradle-wrapper.properties,"@@ -1,5 +1,6 @@
+#Sun Mar 22 12:55:51 CET 2020
+distributionUrl=https\://services.gradle.org/distributions/gradle-6.3-rc-4-all.zip
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-6.3-rc-4-bin.zip","[{'comment': ""We use `gradle -b wrapper.gradle wrapper` to generate gradle wrapper, which results in `gradle-xxxx-bin.zip`, so it's better to align with the existing rule ;-)"", 'commenter': 'daniellansun'}, {'comment': 'Sorry, feel free to remove it!', 'commenter': 'DarioArena87'}]"
1202,src/main/java/groovy/util/GroovyCollections.java,"@@ -123,6 +124,15 @@ public static List combinations(Iterable collections) {
         return collectedCombos;
     }
 
+    private static <T> List<T> newArrayList(T... elements) {
+        if (elements == null || elements.length == 0) {
+            return emptyList();
+        }
+        List<T> ret = new ArrayList<>(elements.length);
+        ret.addAll(Arrays.asList(elements));","[{'comment': 'Maybe the following code is a bit more efficient ;-)\r\n```java\r\nArrays.stream(elements).collect(Collectors.toList())\r\n```', 'commenter': 'daniellansun'}, {'comment': 'I agree, 100X times better!', 'commenter': 'DarioArena87'}]"
1202,src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java,"@@ -2996,15 +2998,6 @@ public static Number count(Iterator self, Object value) {
         return answer;
     }
 
-    /**
-     * @deprecated use count(Iterable, Closure)
-     * @since 1.0
-     */
-    @Deprecated
-    public static Number count(Collection self, Object value) {","[{'comment': ""We could remove the method in 4.0.0, but it's better to remain it in the released 3.0.x for binary compatibility"", 'commenter': 'daniellansun'}]"
1202,src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java,"@@ -3022,15 +3015,6 @@ public static Number count(Iterable self, Object value) {
         return count(self.iterator(), value);
     }
 
-    /**
-     * @deprecated use count(Iterable, Closure)
-     * @since 1.8.0
-     */
-    @Deprecated
-    public static Number count(Collection self, Closure closure) {","[{'comment': 'Ditto', 'commenter': 'daniellansun'}]"
1202,src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java,"@@ -3210,18 +3194,6 @@ public static Number count(byte[] self, Object value) {
         return count(InvokerHelper.asIterator(self), value);
     }
 
-    /**
-     * @deprecated Use the Iterable version of toList instead
-     * @see #toList(Iterable)
-     * @since 1.0
-     */
-    @Deprecated
-    public static <T> List<T> toList(Collection<T> self) {","[{'comment': 'Ditto', 'commenter': 'daniellansun'}]"
1202,src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java,"@@ -3299,16 +3272,6 @@ public static Number count(byte[] self, Object value) {
         return collate((Iterable)Arrays.asList(self), size, true);
     }
 
-    /**
-     * @deprecated use the Iterable variant instead
-     * @see #collate(Iterable, int)
-     * @since 1.8.6
-     */
-    @Deprecated
-    public static <T> List<List<T>> collate( List<T> self, int size ) {","[{'comment': 'Ditto', 'commenter': 'daniellansun'}]"
1202,src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java,"@@ -3341,16 +3304,6 @@ public static Number count(byte[] self, Object value) {
         return collate((Iterable)Arrays.asList(self), size, step, true);
     }
 
-    /**
-     * @deprecated use the Iterable variant instead
-     * @see #collate(Iterable, int, int)
-     * @since 1.8.6
-     */
-    @Deprecated
-    public static <T> List<List<T>> collate( List<T> self, int size, int step ) {","[{'comment': 'Ditto', 'commenter': 'daniellansun'}]"
1202,src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java,"@@ -3383,16 +3336,6 @@ public static Number count(byte[] self, Object value) {
         return collate((Iterable)Arrays.asList(self), size, size, keepRemainder);
     }
 
-    /**
-     * @deprecated use the Iterable variant instead
-     * @see #collate(Iterable, int, boolean)
-     * @since 1.8.6
-     */
-    @Deprecated
-    public static <T> List<List<T>> collate( List<T> self, int size, boolean keepRemainder ) {","[{'comment': 'Ditto', 'commenter': 'daniellansun'}]"
1202,src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java,"@@ -3448,16 +3391,6 @@ public static Number count(byte[] self, Object value) {
         return collate((Iterable)Arrays.asList(self), size, step, keepRemainder);
     }
 
-    /**
-     * @deprecated use the Iterable variant instead
-     * @see #collate(Iterable, int, int, boolean)
-     * @since 1.8.6
-     */
-    @Deprecated
-    public static <T> List<List<T>> collate( List<T> self, int size, int step, boolean keepRemainder ) {","[{'comment': 'Ditto', 'commenter': 'daniellansun'}]"
1202,src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java,"@@ -3566,60 +3499,6 @@ public static Collection collect(Object self) {
         return collector;
     }
 
-    /**
-     * Iterates through this collection transforming each entry into a new value using Closure.IDENTITY
-     * as a transformer, basically returning a list of items copied from the original collection.
-     * <pre class=""groovyTestCase"">assert [1,2,3] == [1,2,3].collect()</pre>
-     *
-     * @param self a collection
-     * @return a List of the transformed values
-     * @see Closure#IDENTITY
-     * @since 1.8.5
-     * @deprecated use the Iterable version instead
-     */
-    @Deprecated
-    public static <T> List<T> collect(Collection<T> self) {","[{'comment': 'Ditto', 'commenter': 'daniellansun'}]"
1202,src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java,"@@ -6644,6 +6286,18 @@ public static Object sum(Collection self, Object initialValue, Closure closure)
         }
         return result;
     }
+    /**
+     * Sums all the items in a stream. This is equivalent to invoking the
+     * ""plus"" method on all items in the stream.
+     * <pre class=""groovyTestCase"">assert 1+2+3+4 == [1,2,3,4].stream().sum()</pre>
+     *
+     * @param stream The stream containing the values to add together
+     * @param <T> The type of the values in the stream
+     * @return The sum of all of the items
+     */
+    public static <T> T sum(Stream<T> stream) {","[{'comment': ""It's better to create JIRA ticket to track the improvement"", 'commenter': 'daniellansun'}, {'comment': 'Sorry this was my first pull request to the groovy repository, can you explain to me how to do it?', 'commenter': 'DarioArena87'}, {'comment': 'Here is the link to JIRA ;-)\r\nhttps://issues.apache.org/jira/projects/GROOVY/summary', 'commenter': 'daniellansun'}]"
1203,src/antlr/GroovyLexer.g4,"@@ -948,7 +948,7 @@ SL_COMMENT
 // Script-header comments.
 // The very first characters of the file may be ""#!"".  If so, ignore the first line.
 SH_COMMENT
-    :   '#!' { require(0 == this.tokenIndex, ""Shebang comment should appear at the first line"", -2, true); } ~[\r\n\uFFFF]* -> skip
+    : '#!' { require(0 == this.tokenIndex, ""Shebang comment should appear at the first line"", -2, true); } ~[\r\n\uFFFF]* LineTerminator ('#!' ~[\r\n\uFFFF]* LineTerminator)* -> skip","[{'comment': ""`LineTerminator ('#!' ~[\\r\\n\\uFFFF]* LineTerminator)*`\r\nI am not sure if the tailing `LineTerminator` is needed, maybe we could simplify the above code as:\r\n`(LineTerminator '#!' ~[\\r\\n\\uFFFF]* )*`"", 'commenter': 'daniellansun'}, {'comment': 'This change worked for antlr4 but I\'m having trouble with antlr2.\r\n\r\n```\r\nSH_COMMENT\r\noptions {\r\n    paraphrase=""a script header"";\r\n}\r\n    :   {getLine() == 1 && getColumn() == 1}?  ""#!""\r\n        (\r\n            options {  greedy = true;  }:\r\n            // \'\\uffff\' means the EOF character.\r\n            // This will fix the issue GROOVY-766 (infinite loop).\r\n            ~(\'\\n\'|\'\\r\'|\'\\uffff\')\r\n        )*\r\n        (ONE_NL[true] ""#!""\r\n          (\r\n              options {  greedy = true;  }:\r\n              // \'\\uffff\' means the EOF character.\r\n              // This will fix the issue GROOVY-766 (infinite loop).\r\n              ~(\'\\n\'|\'\\r\'|\'\\uffff\')\r\n          )*\r\n        )*\r\n        { if (!whitespaceIncluded)  $setType(Token.SKIP); }\r\n    ;\r\n```\r\n\r\nI\'m getting this error in the test\r\n\r\n```\r\norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:\r\nsubprojects/parser-antlr4/src/test/resources/core/Comments_03.groovy: 4: expecting \'#\', found \'/\' @ line 4, column 1.\r\n   /*\r\n   ^\r\n\r\n1 error\r\n```', 'commenter': 'moaxcp'}, {'comment': '@eric-milles ping ;-)', 'commenter': 'daniellansun'}, {'comment': 'I think for Antlr4 I would go with:\r\n```\r\n    : \'#!\' { require(this.tokenIndex == 0, ""Shebang comment should appear at the first line"", -2, true); } ~[\\r\\n\\uFFFF]* (LineTerminator \'#!\' ~[\\r\\n\\uFFFF]*)* -> skip\r\n```\r\n\r\nFor Antlr2, maybe this?\r\n```\r\nSH_COMMENT\r\noptions {\r\n    paraphrase=""a script header"";\r\n}\r\n    :   {getLine() == 1 && getColumn() == 1}?\r\n        ""#!"" (options { greedy = true; }: ~(\'\\n\'|\'\\r\'|\'\\uffff\'))*\r\n        (ONE_NL[true] ""#!"" (options { greedy = true; }: ~(\'\\n\'|\'\\r\'|\'\\uffff\'))*)*\r\n        { if (!whitespaceIncluded) $setType(Token.SKIP); }\r\n    ;\r\n```', 'commenter': 'eric-milles'}]"
1437,src/main/java/org/codehaus/groovy/runtime/typehandling/NumberMath.java,"@@ -168,11 +168,26 @@ public static boolean isBigInteger(Number number) {
     }
 
     public static BigDecimal toBigDecimal(Number n) {
-        return (n instanceof BigDecimal ? (BigDecimal) n : new BigDecimal(n.toString()));
+        if (n instanceof BigDecimal) {
+            return (BigDecimal) n;
+        }
+        if (n instanceof BigInteger) {
+            return new BigDecimal((BigInteger) n);
+        }
+        if (n instanceof Byte || n instanceof Short || n instanceof Integer || n instanceof Long) {","[{'comment': 'I suggest to put Integer and Long at the beginning to avoid checks as possible as we could, because we use Integer and Long more often in the life 😉', 'commenter': 'daniellansun'}]"
1437,src/main/java/org/codehaus/groovy/runtime/typehandling/NumberMath.java,"@@ -168,11 +168,26 @@ public static boolean isBigInteger(Number number) {
     }
 
     public static BigDecimal toBigDecimal(Number n) {
-        return (n instanceof BigDecimal ? (BigDecimal) n : new BigDecimal(n.toString()));
+        if (n instanceof BigDecimal) {
+            return (BigDecimal) n;
+        }
+        if (n instanceof BigInteger) {
+            return new BigDecimal((BigInteger) n);
+        }
+        if (n instanceof Byte || n instanceof Short || n instanceof Integer || n instanceof Long) {
+            return new BigDecimal(n.longValue());
+        }
+        return new BigDecimal(n.toString());
     }
 
     public static BigInteger toBigInteger(Number n) {
-        return (n instanceof BigInteger ? (BigInteger) n : new BigInteger(n.toString()));
+        if (n instanceof BigInteger) {
+            return (BigInteger) n;
+        }
+        if (n instanceof Byte || n instanceof Short || n instanceof Integer || n instanceof Long) {","[{'comment': 'Ditto', 'commenter': 'daniellansun'}]"
1588,src/test/groovy/bugs/Groovy8678.groovy,"@@ -0,0 +1,40 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  ""License""); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+import groovy.transform.CompileStatic
+import org.junit.Test
+
+import static groovy.test.GroovyAssert.assertScript
+
+@CompileStatic
+final class Groovy8678 {
+
+    @Test
+    void testFloatingPointLiteralWithoutLeadingZero() {
+        assertScript '''
+            package groovy.bugs.groovy8678","[{'comment': ""This line (package declaration) isn't needed for inside such a script."", 'commenter': 'paulk-asert'}]"
1598,src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java,"@@ -941,4 +944,24 @@ public V call(final Object... args) {
         }
     }
 
+    private static final MethodHandle IS_SEALED_METHODHANDLE;
+    static {
+        MethodHandle mh = null;
+        try {
+            mh = MethodHandles.lookup().findVirtual(Class.class, ""isSealed"", MethodType.methodType(boolean.class, new Class[0]));
+        } catch (NoSuchMethodException | IllegalAccessException ignored) {
+        }
+        IS_SEALED_METHODHANDLE = mh;
+    }
+
+    private static boolean isSealed(Class<?> clazz) {
+        if (null == IS_SEALED_METHODHANDLE) return false;
+
+        boolean sealed = false;
+        try {
+            sealed = (boolean) IS_SEALED_METHODHANDLE.bindTo(clazz).invokeExact();
+        } catch (Throwable ignored) {
+        }
+        return sealed;
+    }","[{'comment': ""It might be worth putting this utility method somewhere else. ReflectionUtils? I imagine we will want to change the Groovy compiler so that Groovy classes can't extend from sealed Java classes."", 'commenter': 'paulk-asert'}]"
1598,buildSrc/src/main/groovy/org.apache.groovy-core.gradle,"@@ -50,6 +50,10 @@ sourceSets {
                 exclude '**/v10/*'
                 exclude '**/vm10/*'
             }
+            if (!JavaVersion.current().isJava11Compatible()) {
+                exclude '**/v16/*'
+                exclude '**/vm16/*'
+            }","[{'comment': 'The version check for the JVM version warning in the main `build.gradle` and the `checkCompatibility` version check in `org.apache.groovy-core.gradle` should both be bumped to 11.', 'commenter': 'paulk-asert'}]"
1607,src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java,"@@ -1439,6 +1445,34 @@ public ClassNode visitClassDeclaration(final ClassDeclarationContext ctx) {
         List<ModifierNode> modifierNodeList = ctx.getNodeMetaData(TYPE_DECLARATION_MODIFIERS);
         Objects.requireNonNull(modifierNodeList, ""modifierNodeList should not be null"");
         ModifierManager modifierManager = new ModifierManager(this, modifierNodeList);
+
+        Optional<ModifierNode> finalModifierNodeOptional = modifierManager.get(FINAL);
+        Optional<ModifierNode> sealedModifierNodeOptional = modifierManager.get(SEALED);
+        Optional<ModifierNode> nonSealedModifierNodeOptional = modifierManager.get(NON_SEALED);
+        boolean isFinal = finalModifierNodeOptional.isPresent();
+        boolean isSealed = sealedModifierNodeOptional.isPresent();
+        boolean isNonSealed = nonSealedModifierNodeOptional.isPresent();
+        if (isSealed && isNonSealed) {
+            throw createParsingFailedException(""type cannot be defined with both `sealed` and `non-sealed`"", nonSealedModifierNodeOptional.get());
+        }
+
+        if (isFinal && (isSealed || isNonSealed)) {
+            throw createParsingFailedException(""type cannot be defined with both "" + (isSealed ? ""`sealed`"" : ""`non-sealed`"") + "" and `final`"", finalModifierNodeOptional.get());
+        }
+
+        if ((isAnnotation || isEnum) && (isSealed || isNonSealed)) {
+            ModifierNode mn = isSealed ? sealedModifierNodeOptional.get() : nonSealedModifierNodeOptional.get();
+            throw createParsingFailedException(""modifier `"" + mn.getText() + ""` is not allowed here"", mn);
+        }
+
+        boolean hasPermits = asBoolean(ctx.PERMITS());
+        if (isSealed && !hasPermits) {
+            throw createParsingFailedException(""sealed type declaration should have `permits` clause"", ctx);
+        }","[{'comment': 'This is not actually a required restriction. The `permits` clause can be elided for the case where the sealed class and all subclasses are in the same source file, in which case it is worked out automatically. Later checks should give us the correct behavior if permits is left off and no implicit subclasses are found in the same source file. So, I think we can just remove this check.', 'commenter': 'paulk-asert'}]"
1607,src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java,"@@ -1439,6 +1445,34 @@ public ClassNode visitClassDeclaration(final ClassDeclarationContext ctx) {
         List<ModifierNode> modifierNodeList = ctx.getNodeMetaData(TYPE_DECLARATION_MODIFIERS);
         Objects.requireNonNull(modifierNodeList, ""modifierNodeList should not be null"");
         ModifierManager modifierManager = new ModifierManager(this, modifierNodeList);
+
+        Optional<ModifierNode> finalModifierNodeOptional = modifierManager.get(FINAL);
+        Optional<ModifierNode> sealedModifierNodeOptional = modifierManager.get(SEALED);
+        Optional<ModifierNode> nonSealedModifierNodeOptional = modifierManager.get(NON_SEALED);
+        boolean isFinal = finalModifierNodeOptional.isPresent();
+        boolean isSealed = sealedModifierNodeOptional.isPresent();
+        boolean isNonSealed = nonSealedModifierNodeOptional.isPresent();
+        if (isSealed && isNonSealed) {
+            throw createParsingFailedException(""type cannot be defined with both `sealed` and `non-sealed`"", nonSealedModifierNodeOptional.get());
+        }
+
+        if (isFinal && (isSealed || isNonSealed)) {
+            throw createParsingFailedException(""type cannot be defined with both "" + (isSealed ? ""`sealed`"" : ""`non-sealed`"") + "" and `final`"", finalModifierNodeOptional.get());
+        }
+
+        if ((isAnnotation || isEnum) && (isSealed || isNonSealed)) {
+            ModifierNode mn = isSealed ? sealedModifierNodeOptional.get() : nonSealedModifierNodeOptional.get();
+            throw createParsingFailedException(""modifier `"" + mn.getText() + ""` is not allowed here"", mn);
+        }
+
+        boolean hasPermits = asBoolean(ctx.PERMITS());
+        if (isSealed && !hasPermits) {
+            throw createParsingFailedException(""sealed type declaration should have `permits` clause"", ctx);
+        }
+        if (isNonSealed && hasPermits) {
+            throw createParsingFailedException(""non-sealed type declaration should not have `permits` clause"", ctx);
+        }","[{'comment': ""Actually, we should just check that permits is only ever used with sealed. Currently this is allowed but shouldn't be:\r\n`class Shape permits Circle {}`\r\nNote: no sealed."", 'commenter': 'paulk-asert'}]"
1607,src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java,"@@ -1439,6 +1445,34 @@ public ClassNode visitClassDeclaration(final ClassDeclarationContext ctx) {
         List<ModifierNode> modifierNodeList = ctx.getNodeMetaData(TYPE_DECLARATION_MODIFIERS);
         Objects.requireNonNull(modifierNodeList, ""modifierNodeList should not be null"");
         ModifierManager modifierManager = new ModifierManager(this, modifierNodeList);
+
+        Optional<ModifierNode> finalModifierNodeOptional = modifierManager.get(FINAL);
+        Optional<ModifierNode> sealedModifierNodeOptional = modifierManager.get(SEALED);
+        Optional<ModifierNode> nonSealedModifierNodeOptional = modifierManager.get(NON_SEALED);
+        boolean isFinal = finalModifierNodeOptional.isPresent();
+        boolean isSealed = sealedModifierNodeOptional.isPresent();
+        boolean isNonSealed = nonSealedModifierNodeOptional.isPresent();
+        if (isSealed && isNonSealed) {
+            throw createParsingFailedException(""type cannot be defined with both `sealed` and `non-sealed`"", nonSealedModifierNodeOptional.get());
+        }
+
+        if (isFinal && (isSealed || isNonSealed)) {
+            throw createParsingFailedException(""type cannot be defined with both "" + (isSealed ? ""`sealed`"" : ""`non-sealed`"") + "" and `final`"", finalModifierNodeOptional.get());
+        }
+
+        if ((isAnnotation || isEnum) && (isSealed || isNonSealed)) {
+            ModifierNode mn = isSealed ? sealedModifierNodeOptional.get() : nonSealedModifierNodeOptional.get();
+            throw createParsingFailedException(""modifier `"" + mn.getText() + ""` is not allowed here"", mn);
+        }","[{'comment': 'This matches Java (at least for enum). I changed to be slightly more descriptive when using @Sealed. I have a slight preference to make this also more descriptive unless you can see a good reason to keep like Java?', 'commenter': 'paulk-asert'}]"
1824,src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java,"@@ -855,10 +855,16 @@ private static Map<GenericsType, GenericsType> doMakeDeclaringAndActualGenericsT
             GenericsType[] targetGenericsTypes = parameterizedType.redirect().getGenericsTypes();
             if (targetGenericsTypes != null) {
                 GenericsType[] sourceGenericsTypes = parameterizedType.getGenericsTypes();
-                if (sourceGenericsTypes == null) sourceGenericsTypes = EMPTY_GENERICS_ARRAY;
                 map = new LinkedHashMap<>();
-                for (int i = 0, m = sourceGenericsTypes.length, n = targetGenericsTypes.length; i < n; i += 1) {
-                    map.put(targetGenericsTypes[i], i < m ? sourceGenericsTypes[i] : targetGenericsTypes[i]);
+                if (sourceGenericsTypes == null) {
+                    //We have no sourceGenerics, so we need to return the erasures for the raw types (Groovy-10813)
+                    for (GenericsType targetGenericsType : targetGenericsTypes) {
+                        map.put(targetGenericsType, ClassHelper.OBJECT_TYPE.asGenericsType());","[{'comment': 'The erasure type is not always Object.  Can you create an example where it is another type?', 'commenter': 'eric-milles'}, {'comment': 'I will try to find an example.', 'commenter': 'Shadow-Devil'}, {'comment': ""I've played around with generics in java, but couldn't find an example where the erasure isn't of type Object.\r\nI've also tried something like this:\r\n```java\r\nimport java.util.function.*\r\ninterface T<E> extends Function<String, E>{}\r\nclass TT implements T{\r\n  @Override\r\n  Object apply(Object o) {\r\n    return null\r\n  }\r\n}\r\n```\r\nand it still loses all type information. Maybe I'm just not advanced enough into generics and how they work. Could you perhaps help me here or give me a resource where to learn more about this? I've found some information about the topic [here](https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html) and [here](https://docs.oracle.com/javase/tutorial/java/generics/erasure.html)"", 'commenter': 'Shadow-Devil'}, {'comment': 'Another example where the type parameter has an upper bound: \r\n```java\r\ninterface A<T extends String> extends Function<T, T> {}\r\nclass B implements A{\r\n    @Override\r\n    Object apply(Object input) {\r\n        return null\r\n    }\r\n}\r\n```', 'commenter': 'Shadow-Devil'}, {'comment': 'Uh, now I got an example, that has not Object as its type:\r\n```java\r\ninterface A<T extends String> {\r\n    T apply(T input);\r\n}\r\nclass B implements A{\r\n    @Override\r\n    String apply(String input) {\r\n        return null\r\n    }\r\n}\r\n```', 'commenter': 'Shadow-Devil'}, {'comment': ""I've added some tests that have an upper bound. I was a bit suprised that `T extends String & Object` just selects the first one when you use raw types, so the result is different from `T extends Object & String`"", 'commenter': 'Shadow-Devil'}]"
1824,src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java,"@@ -950,7 +956,7 @@ public static boolean hasUnresolvedGenerics(final ClassNode type) {
     public static Tuple2<ClassNode[], ClassNode> parameterizeSAM(final ClassNode samType) {
         MethodNode abstractMethod = ClassHelper.findSAM(samType);
 
-        Map<GenericsType, GenericsType> generics = makeDeclaringAndActualGenericsTypeMapOfExactType(abstractMethod.getDeclaringClass(), samType);
+        Map<GenericsType, GenericsType> generics = makeDeclaringAndActualGenericsTypeMap(abstractMethod.getDeclaringClass(), samType);","[{'comment': 'We have been moving away from `makeDeclaringAndActualGenericsTypeMap` towards `makeDeclaringAndActualGenericsTypeMapOfExactType`.  Can you explain this change?', 'commenter': 'eric-milles'}, {'comment': 'Is this the stuff that sits under parametwrizeSAM?  That was the key method for fixing lambda param types.', 'commenter': 'eric-milles'}, {'comment': ""I'm sorry, this change was not intended to be commited, it was just for testing. \r\nI will revert it."", 'commenter': 'Shadow-Devil'}, {'comment': ""> Is this the stuff that sits under parametwrizeSAM? That was the key method for fixing lambda param types.\r\n\r\nparameterizeSAM uses this makeDeclaringAndActualGenericsTypeMapOfExactType method to map declaring generics to actual generics. I thought that I needed to adjust this mapping so for unresolved generics it will output Object, but I'm still unsure if that's the right solution (as you mentioned in the other comment). "", 'commenter': 'Shadow-Devil'}]"
