Pull,Path,Diff_hunk,Comment
189,src/test/java/com/yahoo/sketches/tuple/FilterTest.java,"@@ -0,0 +1,66 @@
+package com.yahoo.sketches.tuple;
+
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+import java.util.Random;
+import java.util.function.Predicate;
+
+import static org.testng.Assert.*;
+
+public class FilterTest {
+
+    private final int numberOfElements = 100;
+
+    @Test
+    public void testFilterEmptySketch() {
+        DoubleSummaryFactory factory = new DoubleSummaryFactory(DoubleSummary.Mode.Sum);
+        Sketch<DoubleSummary> sketch = Sketches.createEmptySketch();
+
+        Filter<DoubleSummary> filter = new Filter<>(o -> true, factory);
+
+        Sketch<DoubleSummary> filteredSketch = filter.filter(sketch);
+
+        Assert.assertEquals(filteredSketch.getEstimate(), 0.0d);
+        Assert.assertEquals(filteredSketch.getThetaLong(), sketch.getThetaLong());
+    }","[{'comment': ""I'd expect that if sketch.isEmpty() is true, filteredSketch.isEmpty() is also true"", 'commenter': 'jmalkin'}]"
189,src/main/java/com/yahoo/sketches/tuple/Filter.java,"@@ -0,0 +1,49 @@
+package com.yahoo.sketches.tuple;
+
+import java.util.function.Predicate;
+
+/**
+ * Class for filtering values from a {@link Sketch} given a {@link Summary}
+ *
+ * @param <T> Summary type against to which apply the {@link Predicate}
+ */
+public class Filter<T extends Summary> {
+    private Predicate<T> predicate;
+    private SummaryFactory<T> summaryFactory;
+
+    /**
+     * Filter constructor with a {@link Predicate} and {@link SummaryFactory}
+     *
+     * @param predicate Predicate to use in this filter. If the Predicate returns False, the element is discarded.
+     *                 If the Predicate returns True, then the element is kept in the {@link Sketch}
+     * @param summaryFactory Summary Factory to use to build a new summary
+     */
+    public Filter(Predicate<T> predicate, SummaryFactory<T> summaryFactory) {
+        this.predicate = predicate;
+        this.summaryFactory = summaryFactory;
+    }
+
+    /**
+     * Filters elements on the provided {@link Sketch}
+     * 
+     * @param sketchIn The sketch against to which apply the {@link Predicate}
+     * @return A new Sketch with some of the elements filtered based on the {@link Predicate}
+     */
+    public CompactSketch<T> filter(Sketch<T> sketchIn) {
+        QuickSelectSketch<T> sketch = new QuickSelectSketch<>(sketchIn.getRetainedEntries(), 0, summaryFactory);","[{'comment': 'This will throw an exception if sketchIn == null', 'commenter': 'jmalkin'}]"
189,src/main/java/com/yahoo/sketches/tuple/Filter.java,"@@ -0,0 +1,49 @@
+package com.yahoo.sketches.tuple;
+
+import java.util.function.Predicate;
+
+/**
+ * Class for filtering values from a {@link Sketch} given a {@link Summary}
+ *
+ * @param <T> Summary type against to which apply the {@link Predicate}
+ */
+public class Filter<T extends Summary> {
+    private Predicate<T> predicate;
+    private SummaryFactory<T> summaryFactory;
+
+    /**
+     * Filter constructor with a {@link Predicate} and {@link SummaryFactory}
+     *
+     * @param predicate Predicate to use in this filter. If the Predicate returns False, the element is discarded.
+     *                 If the Predicate returns True, then the element is kept in the {@link Sketch}
+     * @param summaryFactory Summary Factory to use to build a new summary
+     */
+    public Filter(Predicate<T> predicate, SummaryFactory<T> summaryFactory) {
+        this.predicate = predicate;
+        this.summaryFactory = summaryFactory;","[{'comment': 'Why do we need to store summaryFactory? This never creates new Summary objects', 'commenter': 'jmalkin'}]"
400,src/main/java/org/apache/datasketches/Util.java,"@@ -421,41 +421,38 @@ public static boolean isPowerOf2(final int v) {
    * Checks the given parameter to make sure it is positive, an integer-power of 2 and greater than
    * zero.
    *
-   * @param v The input argument.
+   * @param powerOf2 The input argument must be a power of 2 and greater than zero.
    * @param argName Used in the thrown exception.
    */
-  public static void checkIfPowerOf2(final int v, final String argName) {
-    if (v > 0 && (v & v - 1) == 0) {
-      return;
-    }
+  public static void checkIfPowerOf2(final int powerOf2, final String argName) {
+    if (powerOf2 > 0 && (powerOf2 & powerOf2 - 1) == 0) { return; }
     throw new SketchesArgumentException(""The value of the parameter \"""" + argName
-        + ""\"" must be a positive integer-power of 2"" + "" and greater than 0: "" + v);
+        + ""\"" must be a positive integer-power of 2"" + "" and greater than 0: "" + powerOf2);
   }
 
   /**
    * Checks the given value if it is a power of 2. If not, it throws an exception.
    * Otherwise, returns the log-base2 of the given value.
-   * @param value must be a power of 2 and greater than zero.
+   * @param powerOf2 must be a power of 2 and greater than zero.
    * @param argName the argument name used in the exception if thrown.
    * @return the log-base2 of the given value
    */
-  public static int toLog2(final int value, final String argName) {
-    checkIfPowerOf2(value, argName);
-    return Integer.numberOfTrailingZeros(value);
+  public static int exactLog2(final int powerOf2, final String argName) {","[{'comment': 'Should this and the long version have a more consistent naming scheme? e.g. exactLog2OfInt() for this one?', 'commenter': 'jmalkin'}, {'comment': ""I'm following a java convention here that you will find in java internals.  The simpler form is for the method that is used most often.  I considered changing the other method to just exactLog2(long) since they don't collide. But it is used much less often so I figured why not just leave it alone.  If you insist on consistent naming between these two I will change the other one to exactLog2(long).\r\n"", 'commenter': 'leerho'}, {'comment': 'Given the reasoning, I think I support your decision to go with this approach. No change needed.', 'commenter': 'jmalkin'}]"
400,src/main/java/org/apache/datasketches/Util.java,"@@ -421,41 +421,38 @@ public static boolean isPowerOf2(final int v) {
    * Checks the given parameter to make sure it is positive, an integer-power of 2 and greater than
    * zero.
    *
-   * @param v The input argument.
+   * @param powerOf2 The input argument must be a power of 2 and greater than zero.
    * @param argName Used in the thrown exception.
    */
-  public static void checkIfPowerOf2(final int v, final String argName) {
-    if (v > 0 && (v & v - 1) == 0) {
-      return;
-    }
+  public static void checkIfPowerOf2(final int powerOf2, final String argName) {
+    if (powerOf2 > 0 && (powerOf2 & powerOf2 - 1) == 0) { return; }
     throw new SketchesArgumentException(""The value of the parameter \"""" + argName
-        + ""\"" must be a positive integer-power of 2"" + "" and greater than 0: "" + v);
+        + ""\"" must be a positive integer-power of 2"" + "" and greater than 0: "" + powerOf2);
   }
 
   /**
    * Checks the given value if it is a power of 2. If not, it throws an exception.
    * Otherwise, returns the log-base2 of the given value.
-   * @param value must be a power of 2 and greater than zero.
+   * @param powerOf2 must be a power of 2 and greater than zero.
    * @param argName the argument name used in the exception if thrown.
    * @return the log-base2 of the given value
    */
-  public static int toLog2(final int value, final String argName) {
-    checkIfPowerOf2(value, argName);
-    return Integer.numberOfTrailingZeros(value);
+  public static int exactLog2(final int powerOf2, final String argName) {
+    checkIfPowerOf2(powerOf2, argName);
+    return Integer.numberOfTrailingZeros(powerOf2);
   }
 
   /**
    * Gives the log2 of a long that is known to be a power of 2.
    *
-   * @param x number that is greater than zero
+   * @param powerOf2 must be a power of 2 and greater than zero.
    * @return the log2 of a long that is known to be a power of 2.
    */
-  public static int simpleLog2OfLong(final long x) {
-    final int exp = Long.numberOfTrailingZeros(x);
-    if (x != 1L << exp) {
-      throw new SketchesArgumentException(""Argument x must be a positive power of 2."");
+  public static int exactLog2OfLong(final long powerOf2) {","[{'comment': ""Is there a reason we don't take a String argument here?"", 'commenter': 'jmalkin'}, {'comment': 'Yes!  If this is part of a larger math expression there is no string argument to pass.  The other methods with the string argument are used when the user is supplying the argument that must be a power of 2.  ', 'commenter': 'leerho'}, {'comment': ""Ok, as long as there's a principle being followed that's fine."", 'commenter': 'jmalkin'}]"
430,src/main/java/org/apache/datasketches/hll/BaseHllSketch.java,"@@ -118,8 +120,14 @@ public static final int getSerializationVersion(final Memory mem) {
    * <a href=""{@docRoot}/resources/dictionary.html#numStdDev"">Number of Standard Deviations</a>
    * @return the current (approximate) RelativeError
    */
-  public double getRelErr(final boolean upperBound, final boolean unioned,
+  public static double getRelErr(final boolean upperBound, final boolean unioned,
       final int lgConfigK, final int numStdDev) {
+    HllUtil.checkLgK(lgConfigK);
+    if (lgConfigK > 12) {
+      final double rseFactor = unioned ? HLL_NON_HIP_RSE_FACTOR : HLL_HIP_RSE_FACTOR;
+      final int configK = 1 << lgConfigK;
+      return (upperBound ? -1.0 : 1.0) * (numStdDev * rseFactor) / Math.sqrt(configK);","[{'comment': 'If the user calls this method, the returned relative error will be negative for the upper bound, which will be very confusing because Relative Error should never be a negative number! \r\n\r\nIn our internal method HllEstimators.hllUpperBound(...), the relative error is not really negative.  Think of it as a positive value subtracted from 1.0, only for the UB.  The resulting Upper Bound (and Lower Bound) values are always positive. \r\n\r\nThe fact that our internal tables return a negative value is an internal issue that the user should never see.', 'commenter': 'leerho'}, {'comment': ""The fact that this method returned negative values (from the tables) originally was a bug.  Let's fix it now."", 'commenter': 'leerho'}, {'comment': ""If we know that there's a guaranteed direction for an error, it's reasonable and I'd argue correct to reflect that."", 'commenter': 'jmalkin'}, {'comment': ""this method did return negative values for UB before. It did not handle lgK > 12. I fixed that.\r\nI agree that returning negative is confusing, but changing that might break somebody's code. Perhaps it is fine now in Java since we are getting ready for a major release, but I am not sure how to approach this in C++, where we had a major release recently."", 'commenter': 'AlexanderSaydakov'}, {'comment': ""> If we know that there's a guaranteed direction for an error, it's reasonable and I'd argue correct to reflect that.\r\n\r\nPlease restate what you mean.  What we are returning is the RSE (or the normalized RMS error), which is always positive.  I don't know what you mean by a guaranteed direction for an error.  "", 'commenter': 'leerho'}]"
430,src/main/java/org/apache/datasketches/hll/HllEstimators.java,"@@ -50,39 +48,17 @@ static final double hllLowerBound(final AbstractHllArray absHllArr, final int nu
     final int configK = 1 << lgConfigK;
     final double numNonZeros =
         (absHllArr.getCurMin() == 0) ? configK - absHllArr.getNumAtCurMin() : configK;
-    final double estimate;
-    final double rseFactor;
+    final double estimate = absHllArr.getEstimate();
     final boolean oooFlag = absHllArr.isOutOfOrder();
-    if (oooFlag) {
-      estimate = absHllArr.getCompositeEstimate();
-      rseFactor = HLL_NON_HIP_RSE_FACTOR;
-    } else {
-      estimate = absHllArr.getHipAccum();
-      rseFactor = HLL_HIP_RSE_FACTOR;
-    }
-    final double relErr = (lgConfigK > 12)
-        ? (numStdDev * rseFactor) / Math.sqrt(configK)
-        : RelativeErrorTables.getRelErr(false, oooFlag, lgConfigK, numStdDev);
+    final double relErr = BaseHllSketch.getRelErr(false, oooFlag, lgConfigK, numStdDev);
     return Math.max(estimate / (1.0 + relErr), numNonZeros);
   }
 
   static final double hllUpperBound(final AbstractHllArray absHllArr, final int numStdDev) {
     final int lgConfigK = absHllArr.lgConfigK;
-    final int configK = 1 << lgConfigK;
-    final double estimate;
-    final double rseFactor;
+    final double estimate = absHllArr.getEstimate();
     final boolean oooFlag = absHllArr.isOutOfOrder();
-    if (oooFlag) {
-      estimate = absHllArr.getCompositeEstimate();
-      rseFactor = HLL_NON_HIP_RSE_FACTOR;
-    } else {
-      estimate = absHllArr.getHipAccum();
-      rseFactor = HLL_HIP_RSE_FACTOR;
-    }
-
-    final double relErr = (lgConfigK > 12)
-        ? ((-1.0) * (numStdDev * rseFactor)) / Math.sqrt(configK)
-        : RelativeErrorTables.getRelErr(true, oooFlag, lgConfigK, numStdDev);
+    final double relErr = BaseHllSketch.getRelErr(true, oooFlag, lgConfigK, numStdDev);
     return estimate / (1.0 + relErr);
   }","[{'comment': 'The hllUpperBound(...) method needs to be changed to accommodate the fact that the relErr obtained from the BaseHllSketch.getRelErr(...) must always be a positive value.', 'commenter': 'leerho'}]"
470,src/test/java/org/apache/datasketches/kll/KllCrossLanguageTest.java,"@@ -116,4 +102,92 @@
     assertEquals(sk.getMaxItem(), 1.0F);
   }
 
+  @Test(groups = {CHECK_CPP_FILES})
+  public void kllFloat() throws IOException {
+    final int[] nArr = {0, 10, 100, 1000, 10000, 100000, 1000000};
+    for (int n: nArr) {
+      final byte[] bytes = Files.readAllBytes(cppPath.resolve(""kll_float_n"" + n + ""_cpp.sk""));
+      final KllFloatsSketch sketch = KllFloatsSketch.heapify(Memory.wrap(bytes));
+      assertEquals(sketch.getK(), 200);
+      assertTrue(n == 0 ? sketch.isEmpty() : !sketch.isEmpty());
+      assertTrue(n > 100 ? sketch.isEstimationMode() : !sketch.isEstimationMode());
+      assertEquals(sketch.getN(), n);
+      if (n > 0) {
+        assertEquals(sketch.getMinItem(), 1);
+        assertEquals(sketch.getMaxItem(), n);
+        long weight = 0;
+        QuantilesFloatsSketchIterator it = sketch.iterator();
+        while (it.next()) {
+          assertTrue(it.getQuantile() >= sketch.getMinItem());
+          assertTrue(it.getQuantile() <= sketch.getMaxItem());
+          weight += it.getWeight();
+        }
+        assertEquals(weight, n);
+      }
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void kllDouble() throws IOException {
+    final int[] nArr = {0, 10, 100, 1000, 10000, 100000, 1000000};
+    for (int n: nArr) {
+      final byte[] bytes = Files.readAllBytes(cppPath.resolve(""kll_double_n"" + n + ""_cpp.sk""));
+      final KllDoublesSketch sketch = KllDoublesSketch.heapify(Memory.wrap(bytes));
+      assertEquals(sketch.getK(), 200);
+      assertTrue(n == 0 ? sketch.isEmpty() : !sketch.isEmpty());
+      assertTrue(n > 100 ? sketch.isEstimationMode() : !sketch.isEstimationMode());
+      assertEquals(sketch.getN(), n);
+      if (n > 0) {
+        assertEquals(sketch.getMinItem(), 1);
+        assertEquals(sketch.getMaxItem(), n);
+        long weight = 0;
+        QuantilesDoublesSketchIterator it = sketch.iterator();
+        while (it.next()) {
+          assertTrue(it.getQuantile() >= sketch.getMinItem());
+          assertTrue(it.getQuantile() <= sketch.getMaxItem());
+          weight += it.getWeight();
+        }
+        assertEquals(weight, n);
+      }
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void kllString() throws IOException {
+    // sketch contains numbers in strings to make meaningful assertions
+    Comparator<String> numericOrder = new Comparator<String>() {
+      @Override
+      public int compare(final String s1, final String s2) {
+        final Integer i1 = Integer.parseInt(s1);","[{'comment': ""## Boxed variable is never null\n\nThe variable 'i1' is only assigned values of primitive type and is never 'null', but it is declared with the boxed type 'Integer'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/625)"", 'commenter': 'github-advanced-security[bot]'}, {'comment': ""## Missing catch of NumberFormatException\n\nPotential uncaught 'java.lang.NumberFormatException'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/628)"", 'commenter': 'github-advanced-security[bot]'}]"
470,src/test/java/org/apache/datasketches/quantiles/QuantilesSketchCrossLanguageTest.java,"@@ -0,0 +1,139 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.datasketches.quantiles;
+
+import static org.apache.datasketches.common.TestUtil.CHECK_CPP_FILES;
+import static org.apache.datasketches.common.TestUtil.GENERATE_JAVA_FILES;
+import static org.apache.datasketches.common.TestUtil.cppPath;
+import static org.apache.datasketches.common.TestUtil.javaPath;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.util.Comparator;
+
+import org.apache.datasketches.common.ArrayOfStringsSerDe;
+import org.apache.datasketches.memory.Memory;
+import org.apache.datasketches.quantilescommon.QuantilesDoublesSketchIterator;
+import org.apache.datasketches.quantilescommon.QuantilesGenericSketchIterator;
+import org.testng.annotations.Test;
+
+/**
+ * Serialize binary sketches to be tested by C++ code.
+ * Test deserialization of binary sketches serialized by C++ code.
+ */
+public class QuantilesSketchCrossLanguageTest {
+
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateDoublesSketch() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final UpdateDoublesSketch sk = DoublesSketch.builder().build();
+      for (int i = 1; i <= n; i++) sk.update(i);
+      Files.newOutputStream(javaPath.resolve(""quantiles_double_n"" + n + ""_java.sk"")).write(sk.toByteArray());
+    }
+  }
+
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateItemsSketchWithStrings() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final ItemsSketch<String> sk = ItemsSketch.getInstance(String.class, new Comparator<String>() {
+        @Override
+        public int compare(final String s1, final String s2) {
+          final Integer i1 = Integer.parseInt(s1);","[{'comment': ""## Boxed variable is never null\n\nThe variable 'i1' is only assigned values of primitive type and is never 'null', but it is declared with the boxed type 'Integer'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/626)"", 'commenter': 'github-advanced-security[bot]'}, {'comment': ""## Missing catch of NumberFormatException\n\nPotential uncaught 'java.lang.NumberFormatException'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/630)"", 'commenter': 'github-advanced-security[bot]'}]"
470,src/test/java/org/apache/datasketches/quantiles/QuantilesSketchCrossLanguageTest.java,"@@ -0,0 +1,139 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.datasketches.quantiles;
+
+import static org.apache.datasketches.common.TestUtil.CHECK_CPP_FILES;
+import static org.apache.datasketches.common.TestUtil.GENERATE_JAVA_FILES;
+import static org.apache.datasketches.common.TestUtil.cppPath;
+import static org.apache.datasketches.common.TestUtil.javaPath;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.util.Comparator;
+
+import org.apache.datasketches.common.ArrayOfStringsSerDe;
+import org.apache.datasketches.memory.Memory;
+import org.apache.datasketches.quantilescommon.QuantilesDoublesSketchIterator;
+import org.apache.datasketches.quantilescommon.QuantilesGenericSketchIterator;
+import org.testng.annotations.Test;
+
+/**
+ * Serialize binary sketches to be tested by C++ code.
+ * Test deserialization of binary sketches serialized by C++ code.
+ */
+public class QuantilesSketchCrossLanguageTest {
+
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateDoublesSketch() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final UpdateDoublesSketch sk = DoublesSketch.builder().build();
+      for (int i = 1; i <= n; i++) sk.update(i);
+      Files.newOutputStream(javaPath.resolve(""quantiles_double_n"" + n + ""_java.sk"")).write(sk.toByteArray());
+    }
+  }
+
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateItemsSketchWithStrings() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final ItemsSketch<String> sk = ItemsSketch.getInstance(String.class, new Comparator<String>() {
+        @Override
+        public int compare(final String s1, final String s2) {
+          final Integer i1 = Integer.parseInt(s1);
+          final Integer i2 = Integer.parseInt(s2);
+          return i1.compareTo(i2);
+        }
+      });
+      for (int i = 1; i <= n; i++) sk.update(Integer.toString(i));
+      if (n > 0) {
+        assertEquals(sk.getMinItem(), ""1"");
+        assertEquals(sk.getMaxItem(), Integer.toString(n));
+      }
+      Files.newOutputStream(javaPath.resolve(""quantiles_string_n"" + n + ""_java.sk""))
+        .write(sk.toByteArray(new ArrayOfStringsSerDe()));
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void checkDoublesSketch() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10000, 100000, 1000000};
+    for (int n: nArr) {
+      final byte[] byteArr = Files.readAllBytes(cppPath.resolve(""quantiles_double_n"" + n + ""_cpp.sk""));
+      final DoublesSketch sk = DoublesSketch.wrap(Memory.wrap(byteArr));
+      assertTrue(n == 0 ? sk.isEmpty() : !sk.isEmpty());
+      assertTrue(n > 128 ? sk.isEstimationMode() : !sk.isEstimationMode());
+      assertEquals(sk.getN(), n);
+      if (n > 0) {
+        assertEquals(sk.getMinItem(), 1);
+        assertEquals(sk.getMaxItem(), n);
+        QuantilesDoublesSketchIterator it = sk.iterator();
+        long weight = 0;
+        while(it.next()) {
+          assertTrue(it.getQuantile() >= sk.getMinItem());
+          assertTrue(it.getQuantile() <= sk.getMaxItem());
+          weight += it.getWeight();
+        }
+        assertEquals(weight, n);
+      }
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void checkItemsSketchWithStrings() throws IOException {
+    // sketch contains numbers in strings to make meaningful assertions
+    Comparator<String> numericOrder = new Comparator<String>() {
+      @Override
+      public int compare(final String s1, final String s2) {
+        final Integer i1 = Integer.parseInt(s1);","[{'comment': ""## Boxed variable is never null\n\nThe variable 'i1' is only assigned values of primitive type and is never 'null', but it is declared with the boxed type 'Integer'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/627)"", 'commenter': 'github-advanced-security[bot]'}, {'comment': ""## Missing catch of NumberFormatException\n\nPotential uncaught 'java.lang.NumberFormatException'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/632)"", 'commenter': 'github-advanced-security[bot]'}]"
470,src/test/java/org/apache/datasketches/kll/KllCrossLanguageTest.java,"@@ -116,4 +102,92 @@
     assertEquals(sk.getMaxItem(), 1.0F);
   }
 
+  @Test(groups = {CHECK_CPP_FILES})
+  public void kllFloat() throws IOException {
+    final int[] nArr = {0, 10, 100, 1000, 10000, 100000, 1000000};
+    for (int n: nArr) {
+      final byte[] bytes = Files.readAllBytes(cppPath.resolve(""kll_float_n"" + n + ""_cpp.sk""));
+      final KllFloatsSketch sketch = KllFloatsSketch.heapify(Memory.wrap(bytes));
+      assertEquals(sketch.getK(), 200);
+      assertTrue(n == 0 ? sketch.isEmpty() : !sketch.isEmpty());
+      assertTrue(n > 100 ? sketch.isEstimationMode() : !sketch.isEstimationMode());
+      assertEquals(sketch.getN(), n);
+      if (n > 0) {
+        assertEquals(sketch.getMinItem(), 1);
+        assertEquals(sketch.getMaxItem(), n);
+        long weight = 0;
+        QuantilesFloatsSketchIterator it = sketch.iterator();
+        while (it.next()) {
+          assertTrue(it.getQuantile() >= sketch.getMinItem());
+          assertTrue(it.getQuantile() <= sketch.getMaxItem());
+          weight += it.getWeight();
+        }
+        assertEquals(weight, n);
+      }
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void kllDouble() throws IOException {
+    final int[] nArr = {0, 10, 100, 1000, 10000, 100000, 1000000};
+    for (int n: nArr) {
+      final byte[] bytes = Files.readAllBytes(cppPath.resolve(""kll_double_n"" + n + ""_cpp.sk""));
+      final KllDoublesSketch sketch = KllDoublesSketch.heapify(Memory.wrap(bytes));
+      assertEquals(sketch.getK(), 200);
+      assertTrue(n == 0 ? sketch.isEmpty() : !sketch.isEmpty());
+      assertTrue(n > 100 ? sketch.isEstimationMode() : !sketch.isEstimationMode());
+      assertEquals(sketch.getN(), n);
+      if (n > 0) {
+        assertEquals(sketch.getMinItem(), 1);
+        assertEquals(sketch.getMaxItem(), n);
+        long weight = 0;
+        QuantilesDoublesSketchIterator it = sketch.iterator();
+        while (it.next()) {
+          assertTrue(it.getQuantile() >= sketch.getMinItem());
+          assertTrue(it.getQuantile() <= sketch.getMaxItem());
+          weight += it.getWeight();
+        }
+        assertEquals(weight, n);
+      }
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void kllString() throws IOException {
+    // sketch contains numbers in strings to make meaningful assertions
+    Comparator<String> numericOrder = new Comparator<String>() {
+      @Override
+      public int compare(final String s1, final String s2) {
+        final Integer i1 = Integer.parseInt(s1);
+        final Integer i2 = Integer.parseInt(s2);","[{'comment': ""## Missing catch of NumberFormatException\n\nPotential uncaught 'java.lang.NumberFormatException'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/629)"", 'commenter': 'github-advanced-security[bot]'}]"
470,src/test/java/org/apache/datasketches/quantiles/QuantilesSketchCrossLanguageTest.java,"@@ -0,0 +1,139 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.datasketches.quantiles;
+
+import static org.apache.datasketches.common.TestUtil.CHECK_CPP_FILES;
+import static org.apache.datasketches.common.TestUtil.GENERATE_JAVA_FILES;
+import static org.apache.datasketches.common.TestUtil.cppPath;
+import static org.apache.datasketches.common.TestUtil.javaPath;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.util.Comparator;
+
+import org.apache.datasketches.common.ArrayOfStringsSerDe;
+import org.apache.datasketches.memory.Memory;
+import org.apache.datasketches.quantilescommon.QuantilesDoublesSketchIterator;
+import org.apache.datasketches.quantilescommon.QuantilesGenericSketchIterator;
+import org.testng.annotations.Test;
+
+/**
+ * Serialize binary sketches to be tested by C++ code.
+ * Test deserialization of binary sketches serialized by C++ code.
+ */
+public class QuantilesSketchCrossLanguageTest {
+
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateDoublesSketch() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final UpdateDoublesSketch sk = DoublesSketch.builder().build();
+      for (int i = 1; i <= n; i++) sk.update(i);
+      Files.newOutputStream(javaPath.resolve(""quantiles_double_n"" + n + ""_java.sk"")).write(sk.toByteArray());
+    }
+  }
+
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateItemsSketchWithStrings() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final ItemsSketch<String> sk = ItemsSketch.getInstance(String.class, new Comparator<String>() {
+        @Override
+        public int compare(final String s1, final String s2) {
+          final Integer i1 = Integer.parseInt(s1);
+          final Integer i2 = Integer.parseInt(s2);","[{'comment': ""## Missing catch of NumberFormatException\n\nPotential uncaught 'java.lang.NumberFormatException'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/631)"", 'commenter': 'github-advanced-security[bot]'}]"
470,src/test/java/org/apache/datasketches/quantiles/QuantilesSketchCrossLanguageTest.java,"@@ -0,0 +1,139 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.datasketches.quantiles;
+
+import static org.apache.datasketches.common.TestUtil.CHECK_CPP_FILES;
+import static org.apache.datasketches.common.TestUtil.GENERATE_JAVA_FILES;
+import static org.apache.datasketches.common.TestUtil.cppPath;
+import static org.apache.datasketches.common.TestUtil.javaPath;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.util.Comparator;
+
+import org.apache.datasketches.common.ArrayOfStringsSerDe;
+import org.apache.datasketches.memory.Memory;
+import org.apache.datasketches.quantilescommon.QuantilesDoublesSketchIterator;
+import org.apache.datasketches.quantilescommon.QuantilesGenericSketchIterator;
+import org.testng.annotations.Test;
+
+/**
+ * Serialize binary sketches to be tested by C++ code.
+ * Test deserialization of binary sketches serialized by C++ code.
+ */
+public class QuantilesSketchCrossLanguageTest {
+
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateDoublesSketch() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final UpdateDoublesSketch sk = DoublesSketch.builder().build();
+      for (int i = 1; i <= n; i++) sk.update(i);
+      Files.newOutputStream(javaPath.resolve(""quantiles_double_n"" + n + ""_java.sk"")).write(sk.toByteArray());
+    }
+  }
+
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateItemsSketchWithStrings() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final ItemsSketch<String> sk = ItemsSketch.getInstance(String.class, new Comparator<String>() {
+        @Override
+        public int compare(final String s1, final String s2) {
+          final Integer i1 = Integer.parseInt(s1);
+          final Integer i2 = Integer.parseInt(s2);
+          return i1.compareTo(i2);
+        }
+      });
+      for (int i = 1; i <= n; i++) sk.update(Integer.toString(i));
+      if (n > 0) {
+        assertEquals(sk.getMinItem(), ""1"");
+        assertEquals(sk.getMaxItem(), Integer.toString(n));
+      }
+      Files.newOutputStream(javaPath.resolve(""quantiles_string_n"" + n + ""_java.sk""))
+        .write(sk.toByteArray(new ArrayOfStringsSerDe()));
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void checkDoublesSketch() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10000, 100000, 1000000};
+    for (int n: nArr) {
+      final byte[] byteArr = Files.readAllBytes(cppPath.resolve(""quantiles_double_n"" + n + ""_cpp.sk""));
+      final DoublesSketch sk = DoublesSketch.wrap(Memory.wrap(byteArr));
+      assertTrue(n == 0 ? sk.isEmpty() : !sk.isEmpty());
+      assertTrue(n > 128 ? sk.isEstimationMode() : !sk.isEstimationMode());
+      assertEquals(sk.getN(), n);
+      if (n > 0) {
+        assertEquals(sk.getMinItem(), 1);
+        assertEquals(sk.getMaxItem(), n);
+        QuantilesDoublesSketchIterator it = sk.iterator();
+        long weight = 0;
+        while(it.next()) {
+          assertTrue(it.getQuantile() >= sk.getMinItem());
+          assertTrue(it.getQuantile() <= sk.getMaxItem());
+          weight += it.getWeight();
+        }
+        assertEquals(weight, n);
+      }
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void checkItemsSketchWithStrings() throws IOException {
+    // sketch contains numbers in strings to make meaningful assertions
+    Comparator<String> numericOrder = new Comparator<String>() {
+      @Override
+      public int compare(final String s1, final String s2) {
+        final Integer i1 = Integer.parseInt(s1);
+        final Integer i2 = Integer.parseInt(s2);","[{'comment': ""## Missing catch of NumberFormatException\n\nPotential uncaught 'java.lang.NumberFormatException'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/633)"", 'commenter': 'github-advanced-security[bot]'}]"
470,.github/workflows/check_cpp_files.yml,"@@ -0,0 +1,30 @@
+name: Serialization Compatibility Test
+
+on:
+  push:
+    branches:
+      - master
+  workflow_dispatch:
+
+jobs:
+  build:
+    name: SerDe Test
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v3
+      - name: Checkout C++
+        uses: actions/checkout@v3
+        with:
+          repository: apache/datasketches-cpp
+          path: cpp
+      - name: Configure C++ build
+        run: cd cpp/build && cmake .. -DGENERATE=true
+      - name: Build C++ unit tests
+        run: cd cpp && cmake --build build --config Release
+      - name: Run C++ tests
+        run: cd cpp && cmake --build build --config Release --target test
+      - name: Copy files
+        run: cp cpp/build/*/test/*_cpp.sk src/test/resources","[{'comment': 'Just making a note that this needs to be changed to ""target/cpp_generated_files""', 'commenter': 'leerho'}, {'comment': 'And in test::org.apache.datasketches.common.TestUtil.cppPath', 'commenter': 'leerho'}, {'comment': 'The CodeQL warnings need to be fixed', 'commenter': 'leerho'}]"
470,src/test/java/org/apache/datasketches/kll/KllCrossLanguageTest.java,"@@ -116,4 +102,92 @@
     assertEquals(sk.getMaxItem(), 1.0F);
   }
 
+  @Test(groups = {CHECK_CPP_FILES})
+  public void kllFloat() throws IOException {
+    final int[] nArr = {0, 10, 100, 1000, 10000, 100000, 1000000};
+    for (int n: nArr) {
+      final byte[] bytes = Files.readAllBytes(cppPath.resolve(""kll_float_n"" + n + ""_cpp.sk""));
+      final KllFloatsSketch sketch = KllFloatsSketch.heapify(Memory.wrap(bytes));
+      assertEquals(sketch.getK(), 200);
+      assertTrue(n == 0 ? sketch.isEmpty() : !sketch.isEmpty());
+      assertTrue(n > 100 ? sketch.isEstimationMode() : !sketch.isEstimationMode());
+      assertEquals(sketch.getN(), n);
+      if (n > 0) {
+        assertEquals(sketch.getMinItem(), 1);
+        assertEquals(sketch.getMaxItem(), n);
+        long weight = 0;
+        QuantilesFloatsSketchIterator it = sketch.iterator();
+        while (it.next()) {
+          assertTrue(it.getQuantile() >= sketch.getMinItem());
+          assertTrue(it.getQuantile() <= sketch.getMaxItem());
+          weight += it.getWeight();
+        }
+        assertEquals(weight, n);
+      }
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void kllDouble() throws IOException {
+    final int[] nArr = {0, 10, 100, 1000, 10000, 100000, 1000000};
+    for (int n: nArr) {
+      final byte[] bytes = Files.readAllBytes(cppPath.resolve(""kll_double_n"" + n + ""_cpp.sk""));
+      final KllDoublesSketch sketch = KllDoublesSketch.heapify(Memory.wrap(bytes));
+      assertEquals(sketch.getK(), 200);
+      assertTrue(n == 0 ? sketch.isEmpty() : !sketch.isEmpty());
+      assertTrue(n > 100 ? sketch.isEstimationMode() : !sketch.isEstimationMode());
+      assertEquals(sketch.getN(), n);
+      if (n > 0) {
+        assertEquals(sketch.getMinItem(), 1);
+        assertEquals(sketch.getMaxItem(), n);
+        long weight = 0;
+        QuantilesDoublesSketchIterator it = sketch.iterator();
+        while (it.next()) {
+          assertTrue(it.getQuantile() >= sketch.getMinItem());
+          assertTrue(it.getQuantile() <= sketch.getMaxItem());
+          weight += it.getWeight();
+        }
+        assertEquals(weight, n);
+      }
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void kllString() throws IOException, NumberFormatException {
+    // sketch contains numbers in strings to make meaningful assertions
+    Comparator<String> numericOrder = new Comparator<String>() {
+      @Override
+      public int compare(final String s1, final String s2) {
+        final int i1 = Integer.parseInt(s1);","[{'comment': ""## Missing catch of NumberFormatException\n\nPotential uncaught 'java.lang.NumberFormatException'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/634)"", 'commenter': 'github-advanced-security[bot]'}]"
470,src/test/java/org/apache/datasketches/kll/KllCrossLanguageTest.java,"@@ -116,4 +102,92 @@
     assertEquals(sk.getMaxItem(), 1.0F);
   }
 
+  @Test(groups = {CHECK_CPP_FILES})
+  public void kllFloat() throws IOException {
+    final int[] nArr = {0, 10, 100, 1000, 10000, 100000, 1000000};
+    for (int n: nArr) {
+      final byte[] bytes = Files.readAllBytes(cppPath.resolve(""kll_float_n"" + n + ""_cpp.sk""));
+      final KllFloatsSketch sketch = KllFloatsSketch.heapify(Memory.wrap(bytes));
+      assertEquals(sketch.getK(), 200);
+      assertTrue(n == 0 ? sketch.isEmpty() : !sketch.isEmpty());
+      assertTrue(n > 100 ? sketch.isEstimationMode() : !sketch.isEstimationMode());
+      assertEquals(sketch.getN(), n);
+      if (n > 0) {
+        assertEquals(sketch.getMinItem(), 1);
+        assertEquals(sketch.getMaxItem(), n);
+        long weight = 0;
+        QuantilesFloatsSketchIterator it = sketch.iterator();
+        while (it.next()) {
+          assertTrue(it.getQuantile() >= sketch.getMinItem());
+          assertTrue(it.getQuantile() <= sketch.getMaxItem());
+          weight += it.getWeight();
+        }
+        assertEquals(weight, n);
+      }
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void kllDouble() throws IOException {
+    final int[] nArr = {0, 10, 100, 1000, 10000, 100000, 1000000};
+    for (int n: nArr) {
+      final byte[] bytes = Files.readAllBytes(cppPath.resolve(""kll_double_n"" + n + ""_cpp.sk""));
+      final KllDoublesSketch sketch = KllDoublesSketch.heapify(Memory.wrap(bytes));
+      assertEquals(sketch.getK(), 200);
+      assertTrue(n == 0 ? sketch.isEmpty() : !sketch.isEmpty());
+      assertTrue(n > 100 ? sketch.isEstimationMode() : !sketch.isEstimationMode());
+      assertEquals(sketch.getN(), n);
+      if (n > 0) {
+        assertEquals(sketch.getMinItem(), 1);
+        assertEquals(sketch.getMaxItem(), n);
+        long weight = 0;
+        QuantilesDoublesSketchIterator it = sketch.iterator();
+        while (it.next()) {
+          assertTrue(it.getQuantile() >= sketch.getMinItem());
+          assertTrue(it.getQuantile() <= sketch.getMaxItem());
+          weight += it.getWeight();
+        }
+        assertEquals(weight, n);
+      }
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void kllString() throws IOException, NumberFormatException {
+    // sketch contains numbers in strings to make meaningful assertions
+    Comparator<String> numericOrder = new Comparator<String>() {
+      @Override
+      public int compare(final String s1, final String s2) {
+        final int i1 = Integer.parseInt(s1);
+        final int i2 = Integer.parseInt(s2);","[{'comment': ""## Missing catch of NumberFormatException\n\nPotential uncaught 'java.lang.NumberFormatException'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/635)"", 'commenter': 'github-advanced-security[bot]'}]"
470,src/test/java/org/apache/datasketches/quantiles/QuantilesSketchCrossLanguageTest.java,"@@ -19,21 +19,129 @@
 
 package org.apache.datasketches.quantiles;
 
+import static org.apache.datasketches.common.TestUtil.CHECK_CPP_FILES;
 import static org.apache.datasketches.common.TestUtil.CHECK_CPP_HISTORICAL_FILES;
+import static org.apache.datasketches.common.TestUtil.GENERATE_JAVA_FILES;
 import static org.apache.datasketches.common.TestUtil.cppHistPath;
+import static org.apache.datasketches.common.TestUtil.cppPath;
+import static org.apache.datasketches.common.TestUtil.javaPath;
 import static org.apache.datasketches.quantilescommon.QuantileSearchCriteria.EXCLUSIVE;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
 
 import java.io.IOException;
 import java.nio.file.Files;
+import java.util.Comparator;
 
+import org.apache.datasketches.common.ArrayOfStringsSerDe;
 import org.apache.datasketches.common.SketchesArgumentException;
 import org.apache.datasketches.memory.Memory;
+import org.apache.datasketches.quantilescommon.QuantilesDoublesSketchIterator;
+import org.apache.datasketches.quantilescommon.QuantilesGenericSketchIterator;
 import org.testng.Assert;
 import org.testng.annotations.Test;
 
-public class ForwardCompatibilityTest {
+/**
+ * Serialize binary sketches to be tested by C++ code.
+ * Test deserialization of binary sketches serialized by C++ code.
+ */
+public class QuantilesSketchCrossLanguageTest {
   private static final String LS = System.getProperty(""line.separator"");
 
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateDoublesSketch() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final UpdateDoublesSketch sk = DoublesSketch.builder().build();
+      for (int i = 1; i <= n; i++) sk.update(i);
+      Files.newOutputStream(javaPath.resolve(""quantiles_double_n"" + n + ""_java.sk"")).write(sk.toByteArray());
+    }
+  }
+
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateItemsSketchWithStrings() throws IOException, NumberFormatException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final ItemsSketch<String> sk = ItemsSketch.getInstance(String.class, new Comparator<String>() {
+        @Override
+        public int compare(final String s1, final String s2) {
+          final int i1 = Integer.parseInt(s1);","[{'comment': ""## Missing catch of NumberFormatException\n\nPotential uncaught 'java.lang.NumberFormatException'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/636)"", 'commenter': 'github-advanced-security[bot]'}]"
470,src/test/java/org/apache/datasketches/quantiles/QuantilesSketchCrossLanguageTest.java,"@@ -19,21 +19,129 @@
 
 package org.apache.datasketches.quantiles;
 
+import static org.apache.datasketches.common.TestUtil.CHECK_CPP_FILES;
 import static org.apache.datasketches.common.TestUtil.CHECK_CPP_HISTORICAL_FILES;
+import static org.apache.datasketches.common.TestUtil.GENERATE_JAVA_FILES;
 import static org.apache.datasketches.common.TestUtil.cppHistPath;
+import static org.apache.datasketches.common.TestUtil.cppPath;
+import static org.apache.datasketches.common.TestUtil.javaPath;
 import static org.apache.datasketches.quantilescommon.QuantileSearchCriteria.EXCLUSIVE;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
 
 import java.io.IOException;
 import java.nio.file.Files;
+import java.util.Comparator;
 
+import org.apache.datasketches.common.ArrayOfStringsSerDe;
 import org.apache.datasketches.common.SketchesArgumentException;
 import org.apache.datasketches.memory.Memory;
+import org.apache.datasketches.quantilescommon.QuantilesDoublesSketchIterator;
+import org.apache.datasketches.quantilescommon.QuantilesGenericSketchIterator;
 import org.testng.Assert;
 import org.testng.annotations.Test;
 
-public class ForwardCompatibilityTest {
+/**
+ * Serialize binary sketches to be tested by C++ code.
+ * Test deserialization of binary sketches serialized by C++ code.
+ */
+public class QuantilesSketchCrossLanguageTest {
   private static final String LS = System.getProperty(""line.separator"");
 
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateDoublesSketch() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final UpdateDoublesSketch sk = DoublesSketch.builder().build();
+      for (int i = 1; i <= n; i++) sk.update(i);
+      Files.newOutputStream(javaPath.resolve(""quantiles_double_n"" + n + ""_java.sk"")).write(sk.toByteArray());
+    }
+  }
+
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateItemsSketchWithStrings() throws IOException, NumberFormatException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final ItemsSketch<String> sk = ItemsSketch.getInstance(String.class, new Comparator<String>() {
+        @Override
+        public int compare(final String s1, final String s2) {
+          final int i1 = Integer.parseInt(s1);
+          final int i2 = Integer.parseInt(s2);","[{'comment': ""## Missing catch of NumberFormatException\n\nPotential uncaught 'java.lang.NumberFormatException'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/637)"", 'commenter': 'github-advanced-security[bot]'}]"
470,src/test/java/org/apache/datasketches/quantiles/QuantilesSketchCrossLanguageTest.java,"@@ -19,21 +19,129 @@
 
 package org.apache.datasketches.quantiles;
 
+import static org.apache.datasketches.common.TestUtil.CHECK_CPP_FILES;
 import static org.apache.datasketches.common.TestUtil.CHECK_CPP_HISTORICAL_FILES;
+import static org.apache.datasketches.common.TestUtil.GENERATE_JAVA_FILES;
 import static org.apache.datasketches.common.TestUtil.cppHistPath;
+import static org.apache.datasketches.common.TestUtil.cppPath;
+import static org.apache.datasketches.common.TestUtil.javaPath;
 import static org.apache.datasketches.quantilescommon.QuantileSearchCriteria.EXCLUSIVE;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
 
 import java.io.IOException;
 import java.nio.file.Files;
+import java.util.Comparator;
 
+import org.apache.datasketches.common.ArrayOfStringsSerDe;
 import org.apache.datasketches.common.SketchesArgumentException;
 import org.apache.datasketches.memory.Memory;
+import org.apache.datasketches.quantilescommon.QuantilesDoublesSketchIterator;
+import org.apache.datasketches.quantilescommon.QuantilesGenericSketchIterator;
 import org.testng.Assert;
 import org.testng.annotations.Test;
 
-public class ForwardCompatibilityTest {
+/**
+ * Serialize binary sketches to be tested by C++ code.
+ * Test deserialization of binary sketches serialized by C++ code.
+ */
+public class QuantilesSketchCrossLanguageTest {
   private static final String LS = System.getProperty(""line.separator"");
 
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateDoublesSketch() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final UpdateDoublesSketch sk = DoublesSketch.builder().build();
+      for (int i = 1; i <= n; i++) sk.update(i);
+      Files.newOutputStream(javaPath.resolve(""quantiles_double_n"" + n + ""_java.sk"")).write(sk.toByteArray());
+    }
+  }
+
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateItemsSketchWithStrings() throws IOException, NumberFormatException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final ItemsSketch<String> sk = ItemsSketch.getInstance(String.class, new Comparator<String>() {
+        @Override
+        public int compare(final String s1, final String s2) {
+          final int i1 = Integer.parseInt(s1);
+          final int i2 = Integer.parseInt(s2);
+          return Integer.valueOf(i1).compareTo(i2);
+        }
+      });
+      for (int i = 1; i <= n; i++) sk.update(Integer.toString(i));
+      if (n > 0) {
+        assertEquals(sk.getMinItem(), ""1"");
+        assertEquals(sk.getMaxItem(), Integer.toString(n));
+      }
+      Files.newOutputStream(javaPath.resolve(""quantiles_string_n"" + n + ""_java.sk""))
+        .write(sk.toByteArray(new ArrayOfStringsSerDe()));
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void checkDoublesSketch() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10000, 100000, 1000000};
+    for (int n: nArr) {
+      final byte[] byteArr = Files.readAllBytes(cppPath.resolve(""quantiles_double_n"" + n + ""_cpp.sk""));
+      final DoublesSketch sk = DoublesSketch.wrap(Memory.wrap(byteArr));
+      assertTrue(n == 0 ? sk.isEmpty() : !sk.isEmpty());
+      assertTrue(n > 128 ? sk.isEstimationMode() : !sk.isEstimationMode());
+      assertEquals(sk.getN(), n);
+      if (n > 0) {
+        assertEquals(sk.getMinItem(), 1);
+        assertEquals(sk.getMaxItem(), n);
+        QuantilesDoublesSketchIterator it = sk.iterator();
+        long weight = 0;
+        while(it.next()) {
+          assertTrue(it.getQuantile() >= sk.getMinItem());
+          assertTrue(it.getQuantile() <= sk.getMaxItem());
+          weight += it.getWeight();
+        }
+        assertEquals(weight, n);
+      }
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void checkItemsSketchWithStrings() throws IOException, NumberFormatException {
+    // sketch contains numbers in strings to make meaningful assertions
+    Comparator<String> numericOrder = new Comparator<String>() {
+      @Override
+      public int compare(final String s1, final String s2) {
+        final int i1 = Integer.parseInt(s1);","[{'comment': ""## Missing catch of NumberFormatException\n\nPotential uncaught 'java.lang.NumberFormatException'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/638)"", 'commenter': 'github-advanced-security[bot]'}]"
470,src/test/java/org/apache/datasketches/quantiles/QuantilesSketchCrossLanguageTest.java,"@@ -19,21 +19,129 @@
 
 package org.apache.datasketches.quantiles;
 
+import static org.apache.datasketches.common.TestUtil.CHECK_CPP_FILES;
 import static org.apache.datasketches.common.TestUtil.CHECK_CPP_HISTORICAL_FILES;
+import static org.apache.datasketches.common.TestUtil.GENERATE_JAVA_FILES;
 import static org.apache.datasketches.common.TestUtil.cppHistPath;
+import static org.apache.datasketches.common.TestUtil.cppPath;
+import static org.apache.datasketches.common.TestUtil.javaPath;
 import static org.apache.datasketches.quantilescommon.QuantileSearchCriteria.EXCLUSIVE;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
 
 import java.io.IOException;
 import java.nio.file.Files;
+import java.util.Comparator;
 
+import org.apache.datasketches.common.ArrayOfStringsSerDe;
 import org.apache.datasketches.common.SketchesArgumentException;
 import org.apache.datasketches.memory.Memory;
+import org.apache.datasketches.quantilescommon.QuantilesDoublesSketchIterator;
+import org.apache.datasketches.quantilescommon.QuantilesGenericSketchIterator;
 import org.testng.Assert;
 import org.testng.annotations.Test;
 
-public class ForwardCompatibilityTest {
+/**
+ * Serialize binary sketches to be tested by C++ code.
+ * Test deserialization of binary sketches serialized by C++ code.
+ */
+public class QuantilesSketchCrossLanguageTest {
   private static final String LS = System.getProperty(""line.separator"");
 
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateDoublesSketch() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final UpdateDoublesSketch sk = DoublesSketch.builder().build();
+      for (int i = 1; i <= n; i++) sk.update(i);
+      Files.newOutputStream(javaPath.resolve(""quantiles_double_n"" + n + ""_java.sk"")).write(sk.toByteArray());
+    }
+  }
+
+  @Test(groups = {GENERATE_JAVA_FILES})
+  public void generateItemsSketchWithStrings() throws IOException, NumberFormatException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10_000, 100_000, 1_000_000};
+    for (final int n: nArr) {
+      final ItemsSketch<String> sk = ItemsSketch.getInstance(String.class, new Comparator<String>() {
+        @Override
+        public int compare(final String s1, final String s2) {
+          final int i1 = Integer.parseInt(s1);
+          final int i2 = Integer.parseInt(s2);
+          return Integer.valueOf(i1).compareTo(i2);
+        }
+      });
+      for (int i = 1; i <= n; i++) sk.update(Integer.toString(i));
+      if (n > 0) {
+        assertEquals(sk.getMinItem(), ""1"");
+        assertEquals(sk.getMaxItem(), Integer.toString(n));
+      }
+      Files.newOutputStream(javaPath.resolve(""quantiles_string_n"" + n + ""_java.sk""))
+        .write(sk.toByteArray(new ArrayOfStringsSerDe()));
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void checkDoublesSketch() throws IOException {
+    final int[] nArr = {0, 1, 10, 100, 1000, 10000, 100000, 1000000};
+    for (int n: nArr) {
+      final byte[] byteArr = Files.readAllBytes(cppPath.resolve(""quantiles_double_n"" + n + ""_cpp.sk""));
+      final DoublesSketch sk = DoublesSketch.wrap(Memory.wrap(byteArr));
+      assertTrue(n == 0 ? sk.isEmpty() : !sk.isEmpty());
+      assertTrue(n > 128 ? sk.isEstimationMode() : !sk.isEstimationMode());
+      assertEquals(sk.getN(), n);
+      if (n > 0) {
+        assertEquals(sk.getMinItem(), 1);
+        assertEquals(sk.getMaxItem(), n);
+        QuantilesDoublesSketchIterator it = sk.iterator();
+        long weight = 0;
+        while(it.next()) {
+          assertTrue(it.getQuantile() >= sk.getMinItem());
+          assertTrue(it.getQuantile() <= sk.getMaxItem());
+          weight += it.getWeight();
+        }
+        assertEquals(weight, n);
+      }
+    }
+  }
+
+  @Test(groups = {CHECK_CPP_FILES})
+  public void checkItemsSketchWithStrings() throws IOException, NumberFormatException {
+    // sketch contains numbers in strings to make meaningful assertions
+    Comparator<String> numericOrder = new Comparator<String>() {
+      @Override
+      public int compare(final String s1, final String s2) {
+        final int i1 = Integer.parseInt(s1);
+        final int i2 = Integer.parseInt(s2);","[{'comment': ""## Missing catch of NumberFormatException\n\nPotential uncaught 'java.lang.NumberFormatException'.\n\n[Show more details](https://github.com/apache/datasketches-java/security/code-scanning/639)"", 'commenter': 'github-advanced-security[bot]'}]"
