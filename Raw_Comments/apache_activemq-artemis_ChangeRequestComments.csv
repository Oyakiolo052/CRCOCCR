Pull,Path,Diff_hunk,Comment
791,artemis-cli/src/main/java/org/apache/activemq/artemis/cli/commands/tools/XmlDataImporter.java,"@@ -444,33 +444,59 @@ private void processMessageBody(Message message) throws XMLStreamException, IOEx
          }
       }
       reader.next();
+      ActiveMQServerLogger.LOGGER.debug(""XMLStreamReader impl: "" + reader);","[{'comment': 'use  if (log.isDebug()) log.debug(...)\n\nAnd get a logger for this class.\n\nThis is change I have made in all the longer not long ago.\n', 'commenter': 'clebertsuconic'}]"
791,artemis-cli/src/main/java/org/apache/activemq/artemis/cli/commands/tools/XmlDataImporter.java,"@@ -444,33 +444,59 @@ private void processMessageBody(Message message) throws XMLStreamException, IOEx
          }
       }
       reader.next();
+      ActiveMQServerLogger.LOGGER.debug(""XMLStreamReader impl: "" + reader);
       if (isLarge) {
          tempFileName = UUID.randomUUID().toString() + "".tmp"";
          ActiveMQServerLogger.LOGGER.debug(""Creating temp file "" + tempFileName + "" for large message."");
          try (OutputStream out = new FileOutputStream(tempFileName)) {
-            while (reader.hasNext()) {
-               if (reader.getEventType() == XMLStreamConstants.END_ELEMENT) {
-                  break;
-               }
-               else {
-                  String characters = new String(reader.getTextCharacters(), reader.getTextStart(), reader.getTextLength());
-                  String trimmedCharacters = characters.trim();
-                  if (trimmedCharacters.length() > 0) { // this will skip ""indentation"" characters
-                     byte[] data = decode(trimmedCharacters);
-                     out.write(data);
-                  }
-               }
-               reader.next();
-            }
+            getMessageBodyBytes(new MessageBodyBytesProcessor() {
+               @Override
+               public void processBodyBytes(byte[] bytes) throws IOException {
+                  out.write(bytes);
+               }
+            });
          }
          FileInputStream fileInputStream = new FileInputStream(tempFileName);
          BufferedInputStream bufferedInput = new BufferedInputStream(fileInputStream);
          ((ClientMessage) message).setBodyInputStream(bufferedInput);
       }
       else {
-         reader.next(); // step past the ""indentation"" characters to get to the CDATA with the message body
-         String characters = new String(reader.getTextCharacters(), reader.getTextStart(), reader.getTextLength());
-         message.getBodyBuffer().writeBytes(decode(characters.trim()));
+         getMessageBodyBytes(new MessageBodyBytesProcessor() {
+            @Override
+            public void processBodyBytes(byte[] bytes) throws IOException {
+               message.getBodyBuffer().writeBytes(bytes);
+            }
+         });
+      }
+   }
+
+   /**
+    * Message bodies are written to XML as Base64 encoded CDATA elements. Some parser implementations won't read the
+    * entire CDATA element at once (e.g. Woodstox) so it's possible for multiple CDATA events to be combined into a
+    * single Base64 encoded string.  You can't decode bits and pieces of each CDATA.  Each CDATA has to be decoded in
+    * its entirety.
+    *
+    * @param processor used to deal with the decoded CDATA elements
+    * @throws IOException
+    * @throws XMLStreamException
+    */
+   private void getMessageBodyBytes(MessageBodyBytesProcessor processor) throws IOException, XMLStreamException {
+      int currentEventType;
+      StringBuilder cdata = new StringBuilder();
+      while (reader.hasNext()) {
+         currentEventType = reader.getEventType();
+         if (currentEventType == XMLStreamConstants.END_ELEMENT) {
+            break;
+         }
+         // when we hit a CHARACTERS event we know that the entire CDATA is complete so decode and pass back to the processor
+         else if (currentEventType == XMLStreamConstants.CHARACTERS && cdata.length() > 0) {","[{'comment': ""JDK's STAX implementation reports CDATA sections also as XMLStreamConstants.CHARACTERS (instead of XMLStreamConstants.CDATA like Woodstox does) by default. So this condition needs to additionally check that the text contains white spaces only. Probably reader.isWhiteSpace() should do.\n"", 'commenter': 'TomasHofman'}, {'comment': ""Although the problem would only occur if JDK's STAX implementation happened to fragment the the CDATA, which it (probably?) doesn't do. So it may be OK how it is.\n"", 'commenter': 'TomasHofman'}, {'comment': 'I think isWhiteSpace() is better.  Good idea!\n', 'commenter': 'jbertram'}]"
839,artemis-server-osgi/src/main/java/org/apache/activemq/artemis/osgi/OsgiBroker.java,"@@ -1,223 +1,252 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.activemq.artemis.osgi;
-
-import java.io.File;
-import java.lang.management.ManagementFactory;
-import java.util.ArrayList;
-import java.util.Dictionary;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Hashtable;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.activemq.artemis.api.core.Interceptor;
-import org.apache.activemq.artemis.api.core.TransportConfiguration;
-import org.apache.activemq.artemis.core.config.FileDeploymentManager;
-import org.apache.activemq.artemis.core.config.impl.FileConfiguration;
-import org.apache.activemq.artemis.core.remoting.impl.netty.TransportConstants;
-import org.apache.activemq.artemis.core.server.ActiveMQComponent;
-import org.apache.activemq.artemis.core.server.ActiveMQServer;
-import org.apache.activemq.artemis.jms.server.config.impl.FileJMSConfiguration;
-import org.apache.activemq.artemis.spi.core.protocol.ProtocolManagerFactory;
-import org.apache.activemq.artemis.spi.core.security.ActiveMQJAASSecurityManager;
-import org.osgi.framework.BundleContext;
-import org.osgi.framework.ServiceRegistration;
-import org.osgi.service.component.ComponentContext;
-import org.osgi.service.component.annotations.Activate;
-import org.osgi.service.component.annotations.Component;
-import org.osgi.service.component.annotations.ConfigurationPolicy;
-import org.osgi.service.component.annotations.Deactivate;
-import org.osgi.util.tracker.ServiceTracker;
-
-@SuppressWarnings({""unchecked"", ""rawtypes""})
-@Component(configurationPid = ""org.apache.activemq.artemis"", configurationPolicy = ConfigurationPolicy.REQUIRE)
-public class OsgiBroker {
-
-   private String name;
-   private String configurationUrl;
-   private String rolePrincipalClass;
-   private Map<String, ActiveMQComponent> components;
-   private Map<String, ServiceRegistration<?>> registrations;
-   private ServiceTracker tracker;
-
-   @Activate
-   public void activate(ComponentContext cctx) throws Exception {
-      final BundleContext context = cctx.getBundleContext();
-      final Dictionary<String, Object> properties = cctx.getProperties();
-      configurationUrl = getMandatory(properties, ""config"");
-      name = getMandatory(properties, ""name"");
-      rolePrincipalClass = (String) properties.get(""rolePrincipalClass"");
-      String domain = getMandatory(properties, ""domain"");
-      ActiveMQJAASSecurityManager security = new ActiveMQJAASSecurityManager(domain);
-      if (rolePrincipalClass != null) {
-         security.setRolePrincipalClass(rolePrincipalClass);
-      }
-      String brokerInstance = null;
-      String karafDataDir = System.getProperty(""karaf.data"");
-      if (karafDataDir != null) {
-         brokerInstance = karafDataDir + ""/artemis/"" + name;
-      }
-
-      // todo if we start to pullout more configs from the main config then we
-      // should pull out the configuration objects from factories if available
-      FileConfiguration configuration = new FileConfiguration();
-      if (brokerInstance != null) {
-         configuration.setBrokerInstance(new File(brokerInstance));
-      }
-      FileJMSConfiguration jmsConfiguration = new FileJMSConfiguration();
-
-      FileDeploymentManager fileDeploymentManager = new FileDeploymentManager(configurationUrl);
-      fileDeploymentManager.addDeployable(configuration).addDeployable(jmsConfiguration).readConfiguration();
-
-      components = fileDeploymentManager.buildService(security, ManagementFactory.getPlatformMBeanServer());
-
-      final ActiveMQServer server = (ActiveMQServer) components.get(""core"");
-
-      String[] requiredProtocols = getRequiredProtocols(server.getConfiguration().getAcceptorConfigurations());
-      ProtocolTrackerCallBack callback = new ProtocolTrackerCallBack() {
-
-         @Override
-         public void addFactory(ProtocolManagerFactory<Interceptor> pmf) {
-            server.addProtocolManagerFactory(pmf);
-         }
-
-         @Override
-         public void removeFactory(ProtocolManagerFactory<Interceptor> pmf) {
-            server.removeProtocolManagerFactory(pmf);
-         }
-
-         @Override
-         public void stop() throws Exception {
-            ActiveMQComponent[] mqComponents = new ActiveMQComponent[components.size()];
-            components.values().toArray(mqComponents);
-            for (int i = mqComponents.length - 1; i >= 0; i--) {
-               mqComponents[i].stop();
-            }
-            unregister();
-         }
-
-         @Override
-         public void start() throws Exception {
-            List<ActiveMQComponent> componentsByStartOrder = getComponentsByStartOrder(components);
-            for (ActiveMQComponent component : componentsByStartOrder) {
-               component.start();
-            }
-            register(context, properties);
-         }
-
-         @Override
-         public boolean isStarted() {
-            return server.isStarted();
-         }
-      };
-      ProtocolTracker trackerCust = new ProtocolTracker(name, context, requiredProtocols, callback);
-      tracker = new ServiceTracker(context, ProtocolManagerFactory.class, trackerCust);
-      tracker.open();
-   }
-
-   private String getMandatory(Dictionary<String, ?> properties, String key) {
-      String value = (String) properties.get(key);
-      if (value == null) {
-         throw new IllegalStateException(""Property "" + key + "" must be set"");
-      }
-      return value;
-   }
-
-   private String[] getRequiredProtocols(Set<TransportConfiguration> acceptors) {
-      ArrayList<String> protocols = new ArrayList<>();
-      for (TransportConfiguration acceptor : acceptors) {
-         Object protocolsFromAcceptor = acceptor.getParams().get(TransportConstants.PROTOCOLS_PROP_NAME);
-         if (protocolsFromAcceptor != null) {
-            String[] protocolsSplit = protocolsFromAcceptor.toString().split("","");
-            for (String protocol : protocolsSplit) {
-               if (!protocols.contains(protocol)) {
-                  protocols.add(protocol);
-               }
-            }
-         }
-      }
-      return protocols.toArray(new String[protocols.size()]);
-   }
-
-   @Deactivate
-   public void stop() throws Exception {
-      tracker.close();
-   }
-
-   public Map<String, ActiveMQComponent> getComponents() {
-      return components;
-   }
-
-   /*
-    * this makes sure the components are started in the correct order. Its
-    * simple at the mo as e only have core and jms but will need impproving if
-    * we get more.
-    */
-   public ArrayList<ActiveMQComponent> getComponentsByStartOrder(Map<String, ActiveMQComponent> components) {
-      ArrayList<ActiveMQComponent> activeMQComponents = new ArrayList<>();
-      ActiveMQComponent jmsComponent = components.get(""jms"");
-      if (jmsComponent != null) {
-         activeMQComponents.add(jmsComponent);
-      }
-      activeMQComponents.add(components.get(""core""));
-      return activeMQComponents;
-   }
-
-   public void register(BundleContext context, Dictionary<String, ?> properties) {
-      registrations = new HashMap<>();
-      for (Map.Entry<String, ActiveMQComponent> component : getComponents().entrySet()) {
-         String[] classes = getInterfaces(component.getValue());
-         Hashtable<String, Object> props = new Hashtable<>();
-         for (Enumeration<String> keyEnum = properties.keys(); keyEnum.hasMoreElements(); ) {
-            String key = keyEnum.nextElement();
-            Object val = properties.get(key);
-            props.put(key, val);
-         }
-         ServiceRegistration<?> registration = context.registerService(classes, component.getValue(), props);
-         registrations.put(component.getKey(), registration);
-      }
-   }
-
-   private String[] getInterfaces(ActiveMQComponent value) {
-      Set<String> interfaces = new HashSet<>();
-      getInterfaces(value.getClass(), interfaces);
-      return interfaces.toArray(new String[interfaces.size()]);
-   }
-
-   private void getInterfaces(Class<?> clazz, Set<String> interfaces) {
-      for (Class<?> itf : clazz.getInterfaces()) {
-         if (interfaces.add(itf.getName())) {
-            getInterfaces(itf, interfaces);
-         }
-      }
-      if (clazz.getSuperclass() != null) {
-         getInterfaces(clazz.getSuperclass(), interfaces);
-      }
-   }
-
-   public void unregister() {
-      if (registrations != null) {
-         for (ServiceRegistration<?> reg : registrations.values()) {
-            reg.unregister();
-         }
-      }
-   }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.osgi;
+","[{'comment': ""You are mixing reformat changes here. It's hard to know what you changed.\n\nCan you isolate only what was changed and make this a simple patch?\n\nyou can then:\n\n``` sh\ngit commit -a --amend\ngit push origin -f\n```\n"", 'commenter': 'clebertsuconic'}, {'comment': 'Sorry, my fault. Editor has switched to crlf line endling.\n', 'commenter': 'graben'}]"
839,artemis-server-osgi/src/main/java/org/apache/activemq/artemis/osgi/ProtocolTrackerCallBack.java,"@@ -25,4 +25,6 @@
    void addFactory(ProtocolManagerFactory<Interceptor> pmf);
 
    void removeFactory(ProtocolManagerFactory<Interceptor> pmf);
+
+   void setDataSourceDependency(boolean dataSourceDependency);","[{'comment': 'what about renaming this to:\n\n``` java\naddDataSource(WhateverInformationForTheDatasource);\n```\n\nthe callback could then decide what to do.\n\nthe best would be to have a class extending ProtocolTrackerCallback:\n\nServerTrackerCallback extends ProtocolTrackerCallback\n\nAnd at the caller we would check an instanceof.\n\nWould that be possible with OSGI?\n\nBTW: thanks for rebasing... at least I can comment on these changes now.\n', 'commenter': 'clebertsuconic'}]"
839,artemis-server/src/main/java/org/apache/activemq/artemis/core/config/storage/FileStorageConfiguration.java,"@@ -29,7 +29,7 @@
 
    @Override
    public StoreType getStoreType() {
-      return StoreType.DATABASE;
+      return StoreType.FILE;","[{'comment': '@mtaylor this was a bug, right?\n', 'commenter': 'clebertsuconic'}]"
845,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/reload/ReloadManagerImpl.java,"@@ -92,7 +95,17 @@ private ReloadRegistry getRegistry(URL uri) {
       private final List<ReloadCallback> callbacks = new LinkedList<>();
 
       ReloadRegistry(URL uri) {
-         this.file = new File(uri.getPath());
+         String filePath = null;
+         try {
+            filePath = URLDecoder.decode(uri.getPath(), StandardCharsets.UTF_8.name());","[{'comment': 'hmmm.. the issue is on the reload manager only?\n', 'commenter': 'clebertsuconic'}]"
845,artemis-server/src/test/java/org/apache/activemq/artemis/core/security/jaas/GuestLoginModuleTest.java,"@@ -23,22 +23,33 @@
 import javax.security.auth.login.LoginContext;
 import javax.security.auth.login.LoginException;
 import java.io.IOException;
+import java.io.UnsupportedEncodingException;
 import java.net.URL;
+import java.net.URLDecoder;
+import java.nio.charset.StandardCharsets;
 
 import org.apache.activemq.artemis.spi.core.security.jaas.RolePrincipal;
 import org.apache.activemq.artemis.spi.core.security.jaas.UserPrincipal;
+import org.jboss.logging.Logger;
 import org.junit.Assert;
 import org.junit.Test;
 
 public class GuestLoginModuleTest extends Assert {
 
+   private static final Logger logger = Logger.getLogger(GuestLoginModuleTest.class);
+
    static {
       String path = System.getProperty(""java.security.auth.login.config"");
       if (path == null) {
          URL resource = GuestLoginModuleTest.class.getClassLoader().getResource(""login.config"");
          if (resource != null) {
-            path = resource.getFile();
-            System.setProperty(""java.security.auth.login.config"", path);
+            try {
+               path = URLDecoder.decode(resource.getFile(), StandardCharsets.UTF_8.name());","[{'comment': ""I'm just confused why you changed this, if this is just a test.\n"", 'commenter': 'clebertsuconic'}]"
852,tests/artemis-test-support/src/main/java/org/apache/activemq/transport/amqp/client/AmqpClient.java,"@@ -76,6 +77,23 @@ public AmqpConnection connect() throws Exception {
    }
 
    /**
+    * Creates a connection with the broker at the given location, this method initiates a
+    * connect attempt immediately and will fail if the remote peer cannot be reached.
+    *
+    * @param  protocolTracer handler of all the received and sent frames
+    * @throws Exception if an error occurs attempting to connect to the Broker.
+    * @return a new connection object used to interact with the connected peer.
+    */
+   public AmqpConnection connect(final ProtocolTracer protocolTracer) throws Exception {","[{'comment': ""@tabish121  wouldn't this needed to by sync with AMQ5 code?\n"", 'commenter': 'clebertsuconic'}, {'comment': ""Not sure I'd do it this way so I'd prefer not to port this to 5.x, the client already has some support for internal inspectors which probably could be modified to do this without needing this new interface and massive stub in the test\n"", 'commenter': 'tabish121'}, {'comment': ""@tabish121 what is the way you suggest to intercept frames received from the client?I've searched for something similar and I've found only a state validator,but it is not the same.Maybe I've missed something?\n"", 'commenter': 'franz1981'}]"
861,artemis-rest/src/main/java/org/apache/activemq/artemis/rest/Jms.java,"@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.rest;
+
+import javax.jms.BytesMessage;
+import javax.jms.JMSException;
+import javax.jms.Message;
+import javax.jms.ObjectMessage;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.ext.MessageBodyReader;
+import javax.ws.rs.ext.Providers;
+import java.io.ByteArrayInputStream;
+import java.lang.reflect.Type;
+
+import org.apache.activemq.artemis.rest.util.HttpMessageHelper;
+import org.jboss.resteasy.core.Headers;
+import org.jboss.resteasy.spi.ResteasyProviderFactory;
+import org.jboss.resteasy.util.GenericType;
+
+public class Jms {","[{'comment': 'Is this on purpose?\n', 'commenter': 'johnament'}, {'comment': 'it is not part of this PR.. github is acting up.\n', 'commenter': 'clebertsuconic'}]"
861,artemis-rest/src/main/java/org/apache/activemq/artemis/rest/integration/EmbeddedRestActiveMQ.java,"@@ -41,7 +41,7 @@ protected void initEmbeddedActiveMQ() {
       embeddedActiveMQ = new EmbeddedActiveMQ();
    }
 
-   MessageServiceManager getManager() {
+   public MessageServiceManager getManager() {","[{'comment': 'Same...\n', 'commenter': 'johnament'}]"
861,artemis-rest/src/main/java/org/apache/activemq/artemis/rest/integration/EmbeddedRestActiveMQJMS.java,"@@ -20,9 +20,9 @@
 import org.apache.activemq.artemis.jms.server.embedded.EmbeddedJMS;
 import org.apache.activemq.artemis.spi.core.naming.BindingRegistry;
 
-class EmbeddedRestActiveMQJMS extends EmbeddedRestActiveMQ {
+public class EmbeddedRestActiveMQJMS extends EmbeddedRestActiveMQ {","[{'comment': 'Same...\n', 'commenter': 'johnament'}]"
861,artemis-rest/src/test/java/org/apache/activemq/artemis/rest/test/Embedded.java,"@@ -0,0 +1,91 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.rest.test;
+
+import org.apache.activemq.artemis.api.core.TransportConfiguration;
+import org.apache.activemq.artemis.core.config.Configuration;
+import org.apache.activemq.artemis.core.config.impl.ConfigurationImpl;
+import org.apache.activemq.artemis.core.remoting.impl.invm.InVMAcceptorFactory;
+import org.apache.activemq.artemis.core.server.ActiveMQServer;
+import org.apache.activemq.artemis.core.server.ActiveMQServers;
+import org.apache.activemq.artemis.rest.MessageServiceConfiguration;
+import org.apache.activemq.artemis.rest.MessageServiceManager;
+import org.jboss.resteasy.plugins.server.tjws.TJWSEmbeddedJaxrsServer;
+import org.jboss.resteasy.test.TestPortProvider;
+
+public class Embedded {","[{'comment': 'Same...\n', 'commenter': 'johnament'}]"
861,artemis-rest/src/test/java/org/apache/activemq/artemis/rest/test/EmbeddedTest.java,"@@ -0,0 +1,161 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.rest.test;
+
+import javax.jms.Connection;
+import javax.jms.ConnectionFactory;
+import javax.jms.Destination;
+import javax.jms.MessageProducer;
+import javax.jms.ObjectMessage;
+import javax.jms.Session;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.activemq.artemis.api.jms.JMSFactoryType;
+import org.apache.activemq.artemis.core.config.impl.SecurityConfiguration;
+import org.apache.activemq.artemis.rest.HttpHeaderProperty;
+import org.apache.activemq.artemis.rest.integration.EmbeddedRestActiveMQJMS;
+import org.apache.activemq.artemis.spi.core.naming.BindingRegistry;
+import org.apache.activemq.artemis.spi.core.security.ActiveMQJAASSecurityManager;
+import org.apache.activemq.artemis.spi.core.security.jaas.InVMLoginModule;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
+import org.jboss.resteasy.spi.Link;
+import org.jboss.resteasy.test.TestPortProvider;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class EmbeddedTest {","[{'comment': 'Same...\n', 'commenter': 'johnament'}]"
861,artemis-rest/src/test/java/org/apache/activemq/artemis/rest/test/JMSTest.java,"@@ -0,0 +1,270 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.rest.test;
+
+import javax.jms.Connection;
+import javax.jms.ConnectionFactory;
+import javax.jms.Destination;
+import javax.jms.Message;
+import javax.jms.MessageConsumer;
+import javax.jms.MessageListener;
+import javax.jms.MessageProducer;
+import javax.jms.ObjectMessage;
+import javax.jms.Session;
+import javax.xml.bind.annotation.XmlRootElement;
+import java.io.Serializable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.activemq.artemis.jms.client.ActiveMQDestination;
+import org.apache.activemq.artemis.jms.client.ActiveMQJMSConnectionFactory;
+import org.apache.activemq.artemis.rest.HttpHeaderProperty;
+import org.apache.activemq.artemis.rest.Jms;
+import org.apache.activemq.artemis.rest.queue.QueueDeployment;
+import org.jboss.resteasy.client.ClientRequest;
+import org.jboss.resteasy.client.ClientResponse;
+import org.jboss.resteasy.spi.Link;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import static org.jboss.resteasy.test.TestPortProvider.generateURL;
+
+public class JMSTest extends MessageTestBase {","[{'comment': 'SAme...\n', 'commenter': 'johnament'}, {'comment': '@johnament github is acting up... you should look at the commits...  there are not many changes.. basically moving stuff.\n', 'commenter': 'clebertsuconic'}]"
1345,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ActiveMQServerImpl.java,"@@ -2313,6 +2318,53 @@ private void deploySecurityFromConfiguration() {
       }
    }
 
+   private void undeployAddressesAndQueueNotInConfiguration() throws Exception {
+      undeployAddressesAndQueueNotInConfiguration(configuration);
+   }
+
+   private void undeployAddressesAndQueueNotInConfiguration(Configuration configuration) throws Exception {
+      Set<String> addressesInConfig = configuration.getAddressConfigurations().stream()
+                                                   .map(CoreAddressConfiguration::getName)
+                                                   .collect(Collectors.toSet());
+
+      Set<String> queuesInConfig = configuration.getAddressConfigurations().stream()
+                                                .map(CoreAddressConfiguration::getQueueConfigurations)
+                                                .flatMap(List::stream).map(CoreQueueConfiguration::getName)
+                                                .collect(Collectors.toSet());
+
+      for (SimpleString addressName : listAddressNames()) {
+         AddressSettings addressSettings = getAddressSettingsRepository().getMatch(addressName.toString());
+
+         if (!addressesInConfig.contains(addressName.toString()) && addressSettings.getConfigDeleteAddresses() == DeletionPolicy.FORCE) {
+            for (Queue queue : listQueues(addressName)) {
+               ActiveMQServerLogger.LOGGER.undeployQueue(queue.getName());
+               queue.deleteQueue(true);
+            }
+            ActiveMQServerLogger.LOGGER.undeployAddress(addressName);
+            removeAddressInfo(addressName, null);
+         } else if (addressSettings.getConfigDeleteQueues() == DeletionPolicy.FORCE) {
+            for (Queue queue : listConfiguredQueues(addressName)) {
+               if (!queuesInConfig.contains(queue.getName().toString())) {","[{'comment': ""shouldn't this be:\r\n```java\r\n if (!queue.isAutoCreated() && !queuesInConfig.contains(queue.getName().toString())) {\r\n```\r\n\r\n?"", 'commenter': 'clebertsuconic'}, {'comment': ""no not really.\r\n\r\nIn this case where we are saying this address is being managed by config.xml we would need to ensure (FORCE) the address is removed and its queues else we could still be in a situation with address's managed by config.xml still existing.\r\n\r\nIts not quite the same as the queue removal within an active address the section above, where on queue creation / deletion within an address (but the address remains) we validly leave alone auto created queues.\r\n\r\nOn address removal you're essentially saying this address is no longer active and removing the end to end route.\r\n\r\nIf we wanted another option for address removal which wouldn't remove the address no matter what, e.g. would fail on an auto created queue it could be added later very easily with another deletion policy. \r\n\r\nI can add this extra policy now if theres a use case for it and if this is a blocker for the change, but i can't think of a good name to call it."", 'commenter': 'michaelandrepearce'}, {'comment': ""what if you have an address and you created a subscription from a JMS Topic. the queue wouldn't be listed here.. wouldn't it be deleted?"", 'commenter': 'clebertsuconic'}, {'comment': ""If the address is managed by config.xml and had a topic subscriber allowed to auto generate its subscriptions (case of non durable probably more so, as durable we're looking to actually control those queues) then still if we push a change via puppet to remove the address as thats controlling address, we would want to ensure (FORCE) the address is still deleted. \r\n\r\nAs said if you want an option where it would fail and wouldnt delete i can add it and happy to do so, if you can think of a good deletion policy name. But we dont have that use case currently with the puppet/chef control as we have to ensure it (the address) is removed."", 'commenter': 'michaelandrepearce'}, {'comment': ""I was thinking we could add to the address deletion policy options NO_QUEUES where it only deletes the address if all queues are deleted (e.g. it doesn't try delete the queues, it relies on logic before hand to remove the configured ones, and relies on consumers and other logic to remove auto gen'd (similar to auto-delete-addresses but it deletes address if not auto created) . \r\n\r\nSo we then have OFF, NO_QUEUES, FORCE. \r\n\r\nWould this satisfy this concern?"", 'commenter': 'michaelandrepearce'}, {'comment': ""a simplification wouldn't work for you? if auto-created.. it means.. it was meant to be created.. no delete...\r\n\r\n\r\nif you really need the semantic differentiation.. we would need to find a better name.. NO_QUEUES doesn't translate IMO."", 'commenter': 'clebertsuconic'}, {'comment': ""I was trying to satisfy your req that you want an option that deletes the address and only non auto gen queues. \r\n\r\nThe req we have is that if an address is marked to be controlled by config then when it's removed we need it to be removed no matter what (as such need to remove the auto gen queues also)"", 'commenter': 'michaelandrepearce'}, {'comment': ""@michaelandrepearce you could/should disable auto-create queues on your case. that's what you want I think."", 'commenter': 'clebertsuconic'}, {'comment': ""@michaelandrepearce if you want to disable creating queues from the client.. you can disable auto-create.. can't you?"", 'commenter': 'clebertsuconic'}, {'comment': 'We want to allow auto creation of non durable still in our use case, but will be disabling creation of durable yes.\r\n\r\ne.g. this would be a sample security setting (allowing an app with role, com_ig_finance_v0_ledger_history_CONSUME to be able to make non durable subscriptions, but enforcing durable subscriptions to be managed by puppet)\r\n\r\n            <security-setting match=""com_ig_finance_v0_ledger_history"">\r\n                <permission roles=""amq_admin,com_ig_finance_v0_ledger_history_CONSUME"" type=""createNonDurableQueue""/>\r\n                <permission roles=""amq_admin,com_ig_finance_v0_ledger_history_CONSUME"" type=""deleteNonDurableQueue""/>\r\n                <permission roles=""amq_admin,com_ig_finance_v0_ledger_history_CONSUME"" type=""consume""/>\r\n                <permission roles=""amq_admin,com_ig_finance_v0_ledger_history_PUBLISH"" type=""send""/>\r\n                <permission roles=""amq_admin"" type=""createDurableQueue""/>\r\n                <permission roles=""amq_admin"" type=""deleteDurableQueue""/>\r\n                <permission roles=""amq_admin"" type=""createAddress""/>\r\n                <permission roles=""amq_admin"" type=""deleteAddress""/>\r\n                <permission roles=""amq_admin"" type=""browse""/>\r\n                <!-- we need this otherwise ./artemis data imp wouldn\'t work -->\r\n                <permission roles=""amq_admin"" type=""manage""/>\r\n            </security-setting>\r\n            ', 'commenter': 'michaelandrepearce'}, {'comment': ""Eg we want to control durable queues from broker xml. But we don't control non durable. "", 'commenter': 'michaelandrepearce'}, {'comment': '@clebertsuconic Going back to having extra policy, so that both cases can be covered what if we call yours force and we call ours kill', 'commenter': 'michaelandrepearce'}, {'comment': '@michaelandrepearce lets speak over IRC about this? I""m confused what would happen when deleting a queue.. not the address.. what would help to your non durable auto-created queues. it seems to me you would lose them.\r\n\r\nlets talk over IRC.. it would be simpler than going back and forth.. specially at the late time zone you\'re in.. catch me tomorrow your afternoon, my morning? apache-activemq IRC channel? we can put a summary here after we talk.', 'commenter': 'clebertsuconic'}, {'comment': 'Sure sounds like a plan üëç ', 'commenter': 'michaelandrepearce'}, {'comment': 'FORCE mean FORCE.  Brexit means Brexit.  What ever that means.\r\n\r\n@clebertsuconic I think @michaelandrepearce code is correct.  We **do** want to delete subscription queues if an address is removed.  Any auto-created queues should be deleted if the address is removed from the configuration.  This may result in client exceptions and/or lost messages, but these are desired consequences of the behaviour.  We can add other policies later, like @michaelandrepearce we could add a ""SAFE_DELETE"" or ""ON_QUEUES"" policy (what ever we want to call it) that will attempt the deletion of the address, but won\'t if there are queues associated with it.  But, as I already mentioned, we could second guess what users actually want all day long.  Let\'s just implement the two basic policies FORCE (what @michaelandrepearce requires) and OFF (current behaviour).  We can do SAFE_DELETE etc... when requirements crop up.\r\n\r\n@clebertsuconic Unless there\'s something I am missing that isn\'t explained here?\r\n', 'commenter': 'mtaylor'}, {'comment': '@mtaylor yes indeed this is what i was trying to convey, but you manage to express it a lot cleaner than i can. Thanks.', 'commenter': 'michaelandrepearce'}, {'comment': 'I agree with deleting all queues if an address go. \r\n\r\n\r\nWhat I thought I read in the code is that if you remove a queue all auto created queues would go together.  ', 'commenter': 'clebertsuconic'}, {'comment': 'method listConfiguredQueues filters to return only configured queues.\r\n\r\n   private List<Queue> listConfiguredQueues(SimpleString address) throws Exception {\r\n      return listQueues(address).stream().filter(queue -> !queue.isAutoCreated() && !queue.isInternalQueue()).collect(Collectors.toList());\r\n   }', 'commenter': 'michaelandrepearce'}, {'comment': 'On that case this may be good as is to me then... I missed that.. let me read the code again...\r\n\r\n@michaelandrepearce  sorry.. still slow after a Caribiean vacation :)', 'commenter': 'clebertsuconic'}]"
1592,artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTUtil.java,"@@ -149,16 +154,52 @@ public static void logMessage(MQTTSessionState state, MqttMessage message, boole
          if (message.fixedHeader() != null) {
             log.append(message.fixedHeader().messageType().toString());
 
-            if (message.variableHeader() instanceof MqttPublishVariableHeader) {
-               log.append(""("" + ((MqttPublishVariableHeader) message.variableHeader()).messageId() + "") "" + message.fixedHeader().qosLevel());
-            } else if (message.variableHeader() instanceof MqttMessageIdVariableHeader) {
+            if (message.variableHeader() instanceof MqttMessageIdVariableHeader) {
                log.append(""("" + ((MqttMessageIdVariableHeader) message.variableHeader()).messageId() + "")"");
             }
 
-            if (message.fixedHeader().messageType() == MqttMessageType.SUBSCRIBE) {
-               for (MqttTopicSubscription sub : ((MqttSubscribeMessage) message).payload().topicSubscriptions()) {
-                  log.append(""\n\t"" + sub.topicName() + "" : "" + sub.qualityOfService());
-               }
+            switch (message.fixedHeader().messageType()) {
+               case PUBLISH:
+                  MqttPublishVariableHeader publishHeader = (MqttPublishVariableHeader) message.variableHeader();
+                  log.append(""("" + publishHeader.packetId() + "")"")
+                     .append("" topic="" + publishHeader.topicName())
+                     .append("", qos="" + message.fixedHeader().qosLevel())
+                     .append("", retain="" + message.fixedHeader().isRetain())
+                     .append("", dup="" + message.fixedHeader().isDup());
+                     //.append("" payload="" + ((MqttPublishMessage)message).payload().toString(StandardCharsets.UTF_8));
+                  break;
+               case CONNECT:
+                  MqttConnectVariableHeader connectHeader = (MqttConnectVariableHeader) message.variableHeader();
+                  MqttConnectPayload payload = ((MqttConnectMessage)message).payload();
+                  log.append("" name="").append(connectHeader.name())
+                     .append("", version="").append(connectHeader.version())
+                     .append("", hasUserName="").append(connectHeader.hasUserName())
+                     .append("", hasPassword="").append(connectHeader.hasPassword())
+                     .append("", isWillRetain="").append(connectHeader.isWillRetain())
+                     .append("", isWillFlag="").append(connectHeader.isWillFlag())
+                     .append("", isCleanSession="").append(connectHeader.isCleanSession())
+                     .append("", keepAliveTimeSeconds="").append(connectHeader.keepAliveTimeSeconds())
+                     .append("", clientIdentifier="").append(payload.clientIdentifier())
+                     .append("", willTopic="").append(payload.willTopic())
+                     .append("", willMessage="").append(payload.willMessage())
+                     .append("", userName="").append(payload.userName());
+                     //.append("", password="").append(payload.password());","[{'comment': 'rather than commented out should this just be removed.', 'commenter': 'michaelandrepearce'}, {'comment': ""From a security perspective I think that's a fair point."", 'commenter': 'jbertram'}]"
1592,artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTUtil.java,"@@ -149,16 +154,52 @@ public static void logMessage(MQTTSessionState state, MqttMessage message, boole
          if (message.fixedHeader() != null) {
             log.append(message.fixedHeader().messageType().toString());
 
-            if (message.variableHeader() instanceof MqttPublishVariableHeader) {
-               log.append(""("" + ((MqttPublishVariableHeader) message.variableHeader()).messageId() + "") "" + message.fixedHeader().qosLevel());
-            } else if (message.variableHeader() instanceof MqttMessageIdVariableHeader) {
+            if (message.variableHeader() instanceof MqttMessageIdVariableHeader) {
                log.append(""("" + ((MqttMessageIdVariableHeader) message.variableHeader()).messageId() + "")"");
             }
 
-            if (message.fixedHeader().messageType() == MqttMessageType.SUBSCRIBE) {
-               for (MqttTopicSubscription sub : ((MqttSubscribeMessage) message).payload().topicSubscriptions()) {
-                  log.append(""\n\t"" + sub.topicName() + "" : "" + sub.qualityOfService());
-               }
+            switch (message.fixedHeader().messageType()) {
+               case PUBLISH:
+                  MqttPublishVariableHeader publishHeader = (MqttPublishVariableHeader) message.variableHeader();
+                  log.append(""("" + publishHeader.packetId() + "")"")
+                     .append("" topic="" + publishHeader.topicName())
+                     .append("", qos="" + message.fixedHeader().qosLevel())
+                     .append("", retain="" + message.fixedHeader().isRetain())
+                     .append("", dup="" + message.fixedHeader().isDup());
+                     //.append("" payload="" + ((MqttPublishMessage)message).payload().toString(StandardCharsets.UTF_8));","[{'comment': 'ditto as per other comment.\r\n""rather than commented out should this just be removed.""', 'commenter': 'michaelandrepearce'}, {'comment': ""I disagree that this should be removed as it can serve as a really convenient way to look at the payload granted they're UTF-8 encoded strings.  The only reason it's commented out is because the MQTT spec has no rules on the format of the payload.  It's just an array of bytes.  However, if you happen to be working with UTF-8 encoded string then this might prove helpful."", 'commenter': 'jbertram'}, {'comment': 'Yes I agree that is useful if you are using UTF8 encoded string as payload. Is it possible having this logging line as configurable (disabled by default) so that people using Strings can enable it for showing the payload.', 'commenter': 'ppatierno'}, {'comment': ""If that's the case would configuration to turn it on / off be better than requiring a complete rebuild in order to use them once uncommented ? \r\n\r\nSidebar is there a gating mechanism on the logger being used to check if it's even enabled, all those append calls for something that might not actually be turned on seems less than ideal.  "", 'commenter': 'tabish121'}, {'comment': ""The method starts with:\r\n\r\nif (logger.isTraceEnabled())\r\n\r\nSo none of this will be executed if TRACE (or equivalent) isn't turned on in the logging configuration."", 'commenter': 'jbertram'}, {'comment': 'And there is no way for making one of them configurable as well ? For example printing the PUBLISH payload ?', 'commenter': 'ppatierno'}, {'comment': ""My only thought here is to use something really basic like a system property.  I don't think this is worth changing the configuration schema to support a new option in broker.xml.  "", 'commenter': 'jbertram'}]"
1592,artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTUtil.java,"@@ -149,16 +154,52 @@ public static void logMessage(MQTTSessionState state, MqttMessage message, boole
          if (message.fixedHeader() != null) {
             log.append(message.fixedHeader().messageType().toString());
 
-            if (message.variableHeader() instanceof MqttPublishVariableHeader) {
-               log.append(""("" + ((MqttPublishVariableHeader) message.variableHeader()).messageId() + "") "" + message.fixedHeader().qosLevel());
-            } else if (message.variableHeader() instanceof MqttMessageIdVariableHeader) {
+            if (message.variableHeader() instanceof MqttMessageIdVariableHeader) {
                log.append(""("" + ((MqttMessageIdVariableHeader) message.variableHeader()).messageId() + "")"");
             }
 
-            if (message.fixedHeader().messageType() == MqttMessageType.SUBSCRIBE) {
-               for (MqttTopicSubscription sub : ((MqttSubscribeMessage) message).payload().topicSubscriptions()) {
-                  log.append(""\n\t"" + sub.topicName() + "" : "" + sub.qualityOfService());
-               }
+            switch (message.fixedHeader().messageType()) {
+               case PUBLISH:
+                  MqttPublishVariableHeader publishHeader = (MqttPublishVariableHeader) message.variableHeader();
+                  log.append(""("" + publishHeader.packetId() + "")"")
+                     .append("" topic="" + publishHeader.topicName())
+                     .append("", qos="" + message.fixedHeader().qosLevel())
+                     .append("", retain="" + message.fixedHeader().isRetain())
+                     .append("", dup="" + message.fixedHeader().isDup());
+                     //.append("" payload="" + ((MqttPublishMessage)message).payload().toString(StandardCharsets.UTF_8));
+                  break;
+               case CONNECT:
+                  MqttConnectVariableHeader connectHeader = (MqttConnectVariableHeader) message.variableHeader();
+                  MqttConnectPayload payload = ((MqttConnectMessage)message).payload();
+                  log.append("" name="").append(connectHeader.name())
+                     .append("", version="").append(connectHeader.version())
+                     .append("", hasUserName="").append(connectHeader.hasUserName())
+                     .append("", hasPassword="").append(connectHeader.hasPassword())
+                     .append("", isWillRetain="").append(connectHeader.isWillRetain())
+                     .append("", isWillFlag="").append(connectHeader.isWillFlag())
+                     .append("", isCleanSession="").append(connectHeader.isCleanSession())
+                     .append("", keepAliveTimeSeconds="").append(connectHeader.keepAliveTimeSeconds())
+                     .append("", clientIdentifier="").append(payload.clientIdentifier())
+                     .append("", willTopic="").append(payload.willTopic())
+                     .append("", willMessage="").append(payload.willMessage())
+                     .append("", userName="").append(payload.userName());
+                     //.append("", password="").append(payload.password());
+                  break;
+               case SUBSCRIBE:
+                  for (MqttTopicSubscription sub : ((MqttSubscribeMessage) message).payload().topicSubscriptions()) {
+                     log.append(""\n\t"" + sub.topicName() + "" : "" + sub.qualityOfService());","[{'comment': 'It should shows the packet-id as well', 'commenter': 'ppatierno'}, {'comment': 'Packet-ID is already logged above before the switch statement starts.', 'commenter': 'jbertram'}, {'comment': '@jbertram sorry you are right !', 'commenter': 'ppatierno'}]"
1592,artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTUtil.java,"@@ -149,16 +154,52 @@ public static void logMessage(MQTTSessionState state, MqttMessage message, boole
          if (message.fixedHeader() != null) {
             log.append(message.fixedHeader().messageType().toString());
 
-            if (message.variableHeader() instanceof MqttPublishVariableHeader) {
-               log.append(""("" + ((MqttPublishVariableHeader) message.variableHeader()).messageId() + "") "" + message.fixedHeader().qosLevel());
-            } else if (message.variableHeader() instanceof MqttMessageIdVariableHeader) {
+            if (message.variableHeader() instanceof MqttMessageIdVariableHeader) {
                log.append(""("" + ((MqttMessageIdVariableHeader) message.variableHeader()).messageId() + "")"");
             }
 
-            if (message.fixedHeader().messageType() == MqttMessageType.SUBSCRIBE) {
-               for (MqttTopicSubscription sub : ((MqttSubscribeMessage) message).payload().topicSubscriptions()) {
-                  log.append(""\n\t"" + sub.topicName() + "" : "" + sub.qualityOfService());
-               }
+            switch (message.fixedHeader().messageType()) {
+               case PUBLISH:
+                  MqttPublishVariableHeader publishHeader = (MqttPublishVariableHeader) message.variableHeader();
+                  log.append(""("" + publishHeader.packetId() + "")"")
+                     .append("" topic="" + publishHeader.topicName())
+                     .append("", qos="" + message.fixedHeader().qosLevel())
+                     .append("", retain="" + message.fixedHeader().isRetain())
+                     .append("", dup="" + message.fixedHeader().isDup());
+                     //.append("" payload="" + ((MqttPublishMessage)message).payload().toString(StandardCharsets.UTF_8));
+                  break;
+               case CONNECT:
+                  MqttConnectVariableHeader connectHeader = (MqttConnectVariableHeader) message.variableHeader();
+                  MqttConnectPayload payload = ((MqttConnectMessage)message).payload();
+                  log.append("" name="").append(connectHeader.name())
+                     .append("", version="").append(connectHeader.version())
+                     .append("", hasUserName="").append(connectHeader.hasUserName())
+                     .append("", hasPassword="").append(connectHeader.hasPassword())
+                     .append("", isWillRetain="").append(connectHeader.isWillRetain())
+                     .append("", isWillFlag="").append(connectHeader.isWillFlag())
+                     .append("", isCleanSession="").append(connectHeader.isCleanSession())
+                     .append("", keepAliveTimeSeconds="").append(connectHeader.keepAliveTimeSeconds())
+                     .append("", clientIdentifier="").append(payload.clientIdentifier())
+                     .append("", willTopic="").append(payload.willTopic())
+                     .append("", willMessage="").append(payload.willMessage())
+                     .append("", userName="").append(payload.userName());
+                     //.append("", password="").append(payload.password());
+                  break;
+               case SUBSCRIBE:
+                  for (MqttTopicSubscription sub : ((MqttSubscribeMessage) message).payload().topicSubscriptions()) {
+                     log.append(""\n\t"" + sub.topicName() + "" : "" + sub.qualityOfService());
+                  }
+                  break;
+               case SUBACK:
+                  for (Integer qos : ((MqttSubAckMessage) message).payload().grantedQoSLevels()) {
+                     log.append(""\n\t"" + qos);","[{'comment': 'Ditto as above', 'commenter': 'ppatierno'}, {'comment': 'Packet-ID is already logged above before the switch statement starts.', 'commenter': 'jbertram'}, {'comment': 'As above you are right sorry !', 'commenter': 'ppatierno'}]"
1592,artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTUtil.java,"@@ -149,16 +154,52 @@ public static void logMessage(MQTTSessionState state, MqttMessage message, boole
          if (message.fixedHeader() != null) {
             log.append(message.fixedHeader().messageType().toString());
 
-            if (message.variableHeader() instanceof MqttPublishVariableHeader) {
-               log.append(""("" + ((MqttPublishVariableHeader) message.variableHeader()).messageId() + "") "" + message.fixedHeader().qosLevel());
-            } else if (message.variableHeader() instanceof MqttMessageIdVariableHeader) {
+            if (message.variableHeader() instanceof MqttMessageIdVariableHeader) {
                log.append(""("" + ((MqttMessageIdVariableHeader) message.variableHeader()).messageId() + "")"");
             }
 
-            if (message.fixedHeader().messageType() == MqttMessageType.SUBSCRIBE) {
-               for (MqttTopicSubscription sub : ((MqttSubscribeMessage) message).payload().topicSubscriptions()) {
-                  log.append(""\n\t"" + sub.topicName() + "" : "" + sub.qualityOfService());
-               }
+            switch (message.fixedHeader().messageType()) {
+               case PUBLISH:
+                  MqttPublishVariableHeader publishHeader = (MqttPublishVariableHeader) message.variableHeader();
+                  log.append(""("" + publishHeader.packetId() + "")"")
+                     .append("" topic="" + publishHeader.topicName())
+                     .append("", qos="" + message.fixedHeader().qosLevel())
+                     .append("", retain="" + message.fixedHeader().isRetain())
+                     .append("", dup="" + message.fixedHeader().isDup());
+                     //.append("" payload="" + ((MqttPublishMessage)message).payload().toString(StandardCharsets.UTF_8));
+                  break;
+               case CONNECT:
+                  MqttConnectVariableHeader connectHeader = (MqttConnectVariableHeader) message.variableHeader();
+                  MqttConnectPayload payload = ((MqttConnectMessage)message).payload();
+                  log.append("" name="").append(connectHeader.name())
+                     .append("", version="").append(connectHeader.version())
+                     .append("", hasUserName="").append(connectHeader.hasUserName())
+                     .append("", hasPassword="").append(connectHeader.hasPassword())
+                     .append("", isWillRetain="").append(connectHeader.isWillRetain())
+                     .append("", isWillFlag="").append(connectHeader.isWillFlag())
+                     .append("", isCleanSession="").append(connectHeader.isCleanSession())
+                     .append("", keepAliveTimeSeconds="").append(connectHeader.keepAliveTimeSeconds())
+                     .append("", clientIdentifier="").append(payload.clientIdentifier())
+                     .append("", willTopic="").append(payload.willTopic())
+                     .append("", willMessage="").append(payload.willMessage())
+                     .append("", userName="").append(payload.userName());
+                     //.append("", password="").append(payload.password());
+                  break;
+               case SUBSCRIBE:
+                  for (MqttTopicSubscription sub : ((MqttSubscribeMessage) message).payload().topicSubscriptions()) {
+                     log.append(""\n\t"" + sub.topicName() + "" : "" + sub.qualityOfService());
+                  }
+                  break;
+               case SUBACK:
+                  for (Integer qos : ((MqttSubAckMessage) message).payload().grantedQoSLevels()) {
+                     log.append(""\n\t"" + qos);
+                  }
+                  break;
+               case UNSUBSCRIBE:
+                  for (String topic : ((MqttUnsubscribeMessage) message).payload().topics()) {
+                     log.append(""\n\t"" + topic);","[{'comment': 'Ditto as above', 'commenter': 'ppatierno'}, {'comment': 'Packet-ID is already logged above before the switch statement starts.', 'commenter': 'jbertram'}, {'comment': 'As above you are right sorry !', 'commenter': 'ppatierno'}]"
1592,artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTUtil.java,"@@ -149,16 +160,62 @@ public static void logMessage(MQTTSessionState state, MqttMessage message, boole
          if (message.fixedHeader() != null) {
             log.append(message.fixedHeader().messageType().toString());
 
-            if (message.variableHeader() instanceof MqttPublishVariableHeader) {
-               log.append(""("" + ((MqttPublishVariableHeader) message.variableHeader()).messageId() + "") "" + message.fixedHeader().qosLevel());
-            } else if (message.variableHeader() instanceof MqttMessageIdVariableHeader) {
+            if (message.variableHeader() instanceof MqttMessageIdVariableHeader) {
                log.append(""("" + ((MqttMessageIdVariableHeader) message.variableHeader()).messageId() + "")"");
             }
 
-            if (message.fixedHeader().messageType() == MqttMessageType.SUBSCRIBE) {
-               for (MqttTopicSubscription sub : ((MqttSubscribeMessage) message).payload().topicSubscriptions()) {
-                  log.append(""\n\t"" + sub.topicName() + "" : "" + sub.qualityOfService());
-               }
+            switch (message.fixedHeader().messageType()) {
+               case PUBLISH:
+                  MqttPublishVariableHeader publishHeader = (MqttPublishVariableHeader) message.variableHeader();
+                  log.append(""("" + publishHeader.packetId() + "")"")
+                     .append("" topic="" + publishHeader.topicName())
+                     .append("", qos="" + message.fixedHeader().qosLevel())
+                     .append("", retain="" + message.fixedHeader().isRetain())
+                     .append("", dup="" + message.fixedHeader().isDup());
+                  if (logUTF8PublishPayload != null) {
+                     log.append("" payload="" + ((MqttPublishMessage)message).payload().toString(StandardCharsets.UTF_8));
+                  }
+                  break;
+               case CONNECT:
+                  MqttConnectVariableHeader connectHeader = (MqttConnectVariableHeader) message.variableHeader();
+                  MqttConnectPayload payload = ((MqttConnectMessage)message).payload();
+                  log.append("" name="").append(connectHeader.name())
+                     .append("", version="").append(connectHeader.version())","[{'comment': 'name and version are related to the protocol (i.e. ""MQTT"" and protocol level which is 4 for 3.1.1). @jbertram what do you think to log something like, protocol=(name, version) ? without having two distinct fields ?', 'commenter': 'ppatierno'}, {'comment': '@jbertram In order to avoid the JVM to compile `logMessage` with a big method (killing futher optimisations of the caller) I suggest to move the log message composition in a separate method (eg `private static void traceMessage(...)`) and use a pattern of calls like this:\r\n```\r\n    public static void logMessage(MQTTSessionState state, MqttMessage message, boolean inbound) {        \r\n       if (logger.isTraceEnabled()) {\r\n          traceMessage(state, message, inbound);    \r\n       }\r\n    }\r\n```\r\nThis will let the JVM inline the `logMessage` call when is not needed.', 'commenter': 'franz1981'}, {'comment': '@jbertram I would create the logMessage @franz1981 is suggesting, but my concern here is not much about perf (since this method is already only called upon logging).. but out of making the code concise. Just a suggestion though.', 'commenter': 'clebertsuconic'}]"
1592,artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTUtil.java,"@@ -67,6 +76,8 @@
 
    public static final int DEFAULT_KEEP_ALIVE_FREQUENCY = 5000;
 
+   public static final String logUTF8PublishPayload = System.getProperty(""org.apache.activemq.artemis.core.protocol.mqtt.logUTF8PublishPayload"");","[{'comment': ""this is about tracing.. why don't you just always log the UTF?\r\nif you don't need that level of information, just take trace out.\r\n\r\n\r\nof you could do something like.. have this whole thing at debug... and if trace, throw the body on log.trace.\r\n\r\nThe system property is a bit odd here. "", 'commenter': 'clebertsuconic'}, {'comment': ""My 2 cents. The PUBLISH payload has a maximum size of 256 MB. I could have a use case where I need tracing packets but not printing 256 MB of bytes on the console. Use case where could be a problem in the messages flow that is not dependent on the payload. In this moment using just TRACE enabled or not it's just about having or not the logging. Maybe we could use DEBUG for normal packets logging and then TRACE for printing the payload as well."", 'commenter': 'ppatierno'}, {'comment': ""To keep this as simple as possible I'll get rid of the system property and always log the payload as UTF-8, but also always limit the output to a certain number of characters so we don't get hundreds of megs of data (potentially)."", 'commenter': 'jbertram'}, {'comment': 'We do that in 5.x for things like logs on STOMP messages where you don\'t want to dump the full content portion of the frame but a small bit can help, I can\'t recall what the default is but something like 60 chars or the like is used.  You end up with a content string of ""ABCD...XYZ""', 'commenter': 'tabish121'}, {'comment': ""So for people who need to have the entire payload because it's in a reasonable range size, they need to use Wireshark ?"", 'commenter': 'ppatierno'}]"
1592,artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTUtil.java,"@@ -133,37 +142,84 @@ public static Message createPubRelMessage(MQTTSession session, SimpleString addr
 
    public static void logMessage(MQTTSessionState state, MqttMessage message, boolean inbound) {
       if (logger.isTraceEnabled()) {
+         traceMessage(state, message, inbound);","[{'comment': 'nice +1', 'commenter': 'michaelandrepearce'}]"
1743,artemis-server/src/main/resources/schema/artemis-configuration.xsd,"@@ -934,6 +934,26 @@
                               a broker plugin
                            </xsd:documentation>
                         </xsd:annotation>
+                        <xsd:sequence>","[{'comment': 'Is it worth instead of re-defineing / duplicating what a property type is, re-naming and re-using the transformerProperty complex type (line 1457) already defined which this is identical to?\r\n\r\nLike wise could the element be named simply ""property"" that way then the code also in FileConfigurationParser can be generic/re-used also, rather than again repeating code, and also standardise / align it with the others.\r\n\r\nLastly could the same file  /artemis-tools/src/test/resources/artemis-configuration.xsd be updated also.', 'commenter': 'michaelandrepearce'}, {'comment': 'Sure, I was originally hesitant to mess with your transformerProperty but happy to do so if it is ok with you.  I will make the changes you suggested next week,\r\n\r\nThanks.\r\n ', 'commenter': 'pgfox'}]"
1764,artemis-server/src/main/java/org/apache/activemq/artemis/core/protocol/ProtocolHandler.java,"@@ -143,6 +143,8 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
          }
       }
 
+
+      // the innitial communication happens here...","[{'comment': 'hahaha you left this in from the web conf :) ', 'commenter': 'michaelandrepearce'}, {'comment': 'ouch.. I will separate this commit and keep it :)\r\nLive coding!!! ', 'commenter': 'clebertsuconic'}]"
1764,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQConnectionFactory.java,"@@ -95,6 +95,7 @@ public void writeExternal(ObjectOutput out) throws IOException {
       URI uri = toURI();
 
       try {
+         System.out.println(""writing "" + uri.toASCIIString());","[{'comment': 'should be removed', 'commenter': 'jmesnil'}]"
1764,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQConnectionFactory.java,"@@ -188,13 +189,15 @@ public void setDeserializationWhiteList(String whiteList) {
    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
       String url = in.readUTF();
+      System.out.println(""Reading "" + url);","[{'comment': 'should be removed', 'commenter': 'jmesnil'}]"
1764,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQConnectionFactory.java,"@@ -188,13 +189,15 @@ public void setDeserializationWhiteList(String whiteList) {
    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
       String url = in.readUTF();
+      System.out.println(""Reading "" + url);
       ConnectionFactoryParser parser = new ConnectionFactoryParser();
       ServerLocatorParser locatorParser = new ServerLocatorParser();
       try {
          URI uri = new URI(url);
          serverLocator = locatorParser.newObject(uri, null);
          parser.populateObject(uri, this);
       } catch (Exception e) {
+         e.printStackTrace();","[{'comment': 'should be removed', 'commenter': 'jmesnil'}]"
1775,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/protocol/core/impl/wireformat/SessionBindingQueryResponseMessage_V2.java,"@@ -25,16 +25,21 @@
 
    protected boolean autoCreateQueues;
 
+   protected boolean autoCreateQueuesDurable;","[{'comment': 'Why you are adding this if this is not being written anywhere?\r\n\r\nAlso... this change is wrong.. you would need a _V5 with the new field being written...\r\n\r\nBut honestly... there has been so any versions on SessionBindingQueryResponse... can you add a V5 with a hashMap for new fields? in the future we would just add more metadata instead of changing the packet.', 'commenter': 'clebertsuconic'}, {'comment': ""I personally don't see why this is needed at all, if this was meant to be a server side change only. Eg. argument for this was to override what client requests. I don't see the client using this at all."", 'commenter': 'michaelandrepearce'}]"
1775,artemis-core-client/src/main/java/org/apache/activemq/artemis/api/core/client/ClientSession.java,"@@ -66,6 +66,11 @@
        */
       boolean isAutoCreateQueues();
 
+      /**
+       * Returns <code>true</code> if auto-create-queues-durable for this address is set to true, <code>false</code> else.
+       */
+      boolean isAutoCreateQueuesDurable();","[{'comment': 'Can we make this enum please as per comments.', 'commenter': 'michaelandrepearce'}]"
1775,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/server/QueueQueryResult.java,"@@ -55,13 +57,19 @@ public QueueQueryResult(final SimpleString name,
                            final int consumerCount,
                            final long messageCount,
                            final boolean autoCreateQueues,
+                           final boolean autoCreateQueuesDurable,
                            final boolean exists,
                            final boolean autoCreated,
                            final boolean purgeOnNoConsumers,
                            final RoutingType routingType,
                            final int maxConsumers) {
+
       this.durable = durable;
 
+      if (autoCreateQueues) {
+         this.durable = autoCreateQueuesDurable;","[{'comment': 'As noted this should be an enum so that the override can be disabled (default), and then the override should allow either durable or non-durable, and only override, if enum is not null, currently this just overrides the value with no option to not override.', 'commenter': 'michaelandrepearce'}]"
1775,artemis-server/src/main/resources/schema/artemis-configuration.xsd,"@@ -2790,6 +2790,14 @@
                </xsd:annotation>
             </xsd:element>
 
+            <xsd:element name=""auto-create-queues-durable"" type=""xsd:boolean"" default=""true"" maxOccurs=""1"" minOccurs=""0"">","[{'comment': 'please make this an enum so it can be set to null, DURABLE or NON-DURABLE, currently this is just true or false, and overrides the durablitly no matter what in code as whilst in the XML parser it reads Boolean later in code its just operating on boolean. (default behaviour should be existing behaviour) ', 'commenter': 'michaelandrepearce'}, {'comment': ""Please, would you be so patient and explain me, how to do this? I have implemented enum (in latest commit), but I don't think so it is what you intended."", 'commenter': 'sknot-rh'}, {'comment': 'This is so that any override can be switched to OFF. ', 'commenter': 'mtaylor'}]"
1778,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQDestination.java,"@@ -244,22 +249,30 @@ public static ActiveMQTemporaryTopic createTemporaryTopic(String address) {
    protected ActiveMQDestination(final String address,
                                  final TYPE type,
                                  final ActiveMQSession session) {
-      this.simpleAddress = SimpleString.toSimpleString(address);
-
-      this.thetype = type;
-
-      this.session = session;
+      this(SimpleString.toSimpleString(address), type, session);
+   }
 
-      this.temporary = TYPE.isTemporary(type);
+   protected ActiveMQDestination(final SimpleString address,
+                                 final TYPE type,
+                                 final ActiveMQSession session) {
+      this(address, null, type, session);","[{'comment': 'should pass `address` instead of `null` for the name', 'commenter': 'jmesnil'}]"
1778,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQDestination.java,"@@ -273,6 +286,14 @@ public void setAddress(String address) {
       setSimpleAddress(SimpleString.toSimpleString(address));
    }
 
+   public void setName(String name) {","[{'comment': ""What's the use of these setters? \r\nThey should not be used for serialization and I don't see why the name (or address) of an instantiated JMS destination would be changed."", 'commenter': 'jmesnil'}, {'comment': ""The address setter was added as part of an effort to make Artemis JNDI work properly in Tomcat.  I assume it's needed here, but I'll remove it for simplicity's sake and it can be added later if necessary."", 'commenter': 'jbertram'}]"
1778,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQDestination.java,"@@ -309,7 +330,7 @@ public SimpleString getSimpleAddress() {
    }
 
    public String getName() {
-      return simpleAddress.toString();
+      return name == null ? simpleAddress.toString() : name.toString();","[{'comment': 'if we use `address` instead of `null` when creating an ActiveMQDestination, we ensure that the fields are always non-null and this method can just return `name.toString()`', 'commenter': 'jmesnil'}, {'comment': 'Fair enough.', 'commenter': 'jbertram'}]"
1778,tests/compatibility-tests/src/main/resources/serial/serial.groovy,"@@ -24,30 +24,46 @@ import org.apache.activemq.artemis.jms.client.*
 
 file = arg[0]
 method = arg[1]
-System.out.println(""File::"" + file);
+version = arg[2]
+System.out.println(""File::"" + file)
 
 
 if (method.equals(""write"")) {
     cf = new ActiveMQConnectionFactory(""tcp://localhost:61616?confirmationWindowSize=1048576&blockOnDurableSend=false"");
     queue = new ActiveMQQueue(""queue"");
     topic = new ActiveMQTopic(""topic"")
+    if (version.equals(""ARTEMIS-SNAPSHOT"")) {
+        destination = new ActiveMQDestination(""address"", ""name"", ActiveMQDestination.TYPE.DESTINATION, null)
+    } else if (version.equals(""ARTEMIS-155"")) {
+        destination = new ActiveMQDestination(""address"", ""name"", false, true, null)
+    }
 
     ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file));
     objectOutputStream.writeObject(cf);
     objectOutputStream.writeObject(queue)
     objectOutputStream.writeObject(topic)
+    if (version.startsWith(""ARTEMIS"")) {","[{'comment': 'why check the version here? just keep what it was.', 'commenter': 'clebertsuconic'}, {'comment': 'I mean... why not simply doing objectOutputStream.writeObject(destination)\r\n\r\n\r\nversion will always start with ARTEMIS', 'commenter': 'clebertsuconic'}, {'comment': ""The link the between the script and the caller seems kind of fragile so I put those checks in there in case the caller was ever changed it wouldn't blow up immediately."", 'commenter': 'jbertram'}]"
1778,tests/compatibility-tests/src/main/resources/serial/serial.groovy,"@@ -24,30 +24,46 @@ import org.apache.activemq.artemis.jms.client.*
 
 file = arg[0]
 method = arg[1]
-System.out.println(""File::"" + file);
+version = arg[2]
+System.out.println(""File::"" + file)
 
 
 if (method.equals(""write"")) {
     cf = new ActiveMQConnectionFactory(""tcp://localhost:61616?confirmationWindowSize=1048576&blockOnDurableSend=false"");
     queue = new ActiveMQQueue(""queue"");
     topic = new ActiveMQTopic(""topic"")
+    if (version.equals(""ARTEMIS-SNAPSHOT"")) {
+        destination = new ActiveMQDestination(""address"", ""name"", ActiveMQDestination.TYPE.DESTINATION, null)","[{'comment': ""I told you to call another script as sometimes it fails the compilation. Perhaps this constructor won't be checked until you actually called it.\r\n\r\n\r\nA lot of times I had to do this it involved classNames that didn't exist.. so I needed to a call an external script. \r\n\r\n\r\nI will wait the test running to be sure."", 'commenter': 'clebertsuconic'}]"
1778,tests/compatibility-tests/src/main/resources/serial/serial.groovy,"@@ -24,30 +24,46 @@ import org.apache.activemq.artemis.jms.client.*
 
 file = arg[0]
 method = arg[1]
-System.out.println(""File::"" + file);
+version = arg[2]
+System.out.println(""File::"" + file)
 
 
 if (method.equals(""write"")) {
     cf = new ActiveMQConnectionFactory(""tcp://localhost:61616?confirmationWindowSize=1048576&blockOnDurableSend=false"");
     queue = new ActiveMQQueue(""queue"");
     topic = new ActiveMQTopic(""topic"")
+    if (version.equals(""ARTEMIS-SNAPSHOT"")) {
+        destination = new ActiveMQDestination(""address"", ""name"", ActiveMQDestination.TYPE.DESTINATION, null)
+    } else if (version.equals(""ARTEMIS-155"")) {
+        destination = new ActiveMQDestination(""address"", ""name"", false, true, null)
+    }
 
     ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file));
     objectOutputStream.writeObject(cf);
     objectOutputStream.writeObject(queue)
     objectOutputStream.writeObject(topic)
+    if (version.startsWith(""ARTEMIS"")) {
+        objectOutputStream.writeObject(destination)
+    }
     objectOutputStream.close();
 } else {
     ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(file))
 
     cf = inputStream.readObject();
     queue = inputStream.readObject()
     topic = inputStream.readObject()
+    if (version.startsWith(""ARTEMIS"")) {
+        destination = inputStream.readObject()
+    }
     inputStream.close();
 }
 
 GroovyRun.assertTrue(!cf.getServerLocator().isBlockOnDurableSend());
-GroovyRun.assertEquals(1048576, cf.getServerLocator().getConfirmationWindowSize());
+GroovyRun.assertEquals(1048576, cf.getServerLocator().getConfirmationWindowSize())
+if (version.startsWith(""ARTEMIS"")) {","[{'comment': ""you don't need that if ^^^"", 'commenter': 'clebertsuconic'}]"
1778,artemis-jms-server/src/main/java/org/apache/activemq/artemis/jms/server/JMSServerManager.java,"@@ -60,6 +60,24 @@ boolean createQueue(boolean storeConfig,
                        boolean durable,
                        String... bindings) throws Exception;
 
+   /**
+    * Creates a JMS Queue.
+    *
+    * @param queueName      The name of the core queue to create
+    * @param jmsQueueName the name of this JMS queue
+    * @param selectorString
+    * @param durable
+    * @return true if the queue is created or if it existed and was added to
+    * the Binding Registry
+    * @throws Exception if problems were encountered creating the queue.
+    */
+   boolean createQueue(boolean storeConfig,","[{'comment': 'If this is for back compatibility for the ActiveMQDestination, why are we adding new methods to JMSServerManager, if anything ""name"" in ActiveMQDestination should be deprecated, and these methods should be marked deprecated', 'commenter': 'michaelandrepearce'}, {'comment': 'The whole JMSServerManager class is already marked as deprecated.  The reason these additions are here is because the JMSServerManager was never updated to deal with the new address model since it was deprecated at the same time the address model was changed.  However, integrators which previously used the JMSServerManager may need these new methods while they transition away from using the JMSServerManager to using the ActiveMQServer instead.', 'commenter': 'jbertram'}, {'comment': 'Fair enough. Thanks for the explination.', 'commenter': 'michaelandrepearce'}]"
1778,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQDestination.java,"@@ -309,7 +338,7 @@ public SimpleString getSimpleAddress() {
    }
 
    public String getName() {
-      return simpleAddress.toString();
+      return name;","[{'comment': 'name can be null, this is the case should use simpleAddress.toString.', 'commenter': 'michaelandrepearce'}]"
1778,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQDestination.java,"@@ -231,6 +239,16 @@ public static ActiveMQTemporaryTopic createTemporaryTopic(String address) {
     */
    private SimpleString simpleAddress;
 
+   /**
+    * Needed for serialization backwards compatibility.
+    */
+   private String address;
+
+   /**
+    * The ""JMS"" name of the destination. Needed for serialization backwards compatibility.
+    */
+   private String name;","[{'comment': 'Can we mark as deprecated', 'commenter': 'michaelandrepearce'}]"
1778,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQDestination.java,"@@ -231,6 +239,16 @@ public static ActiveMQTemporaryTopic createTemporaryTopic(String address) {
     */
    private SimpleString simpleAddress;
 
+   /**
+    * Needed for serialization backwards compatibility.
+    */
+   private String address;","[{'comment': 'Can we mark as deprecated', 'commenter': 'michaelandrepearce'}]"
1778,artemis-jms-server/src/main/java/org/apache/activemq/artemis/jms/server/impl/JMSServerManagerImpl.java,"@@ -465,11 +467,17 @@ public synchronized boolean createQueue(final boolean storeConfig,
                                            final String selectorString,
                                            final boolean durable,
                                            final String... bindings) throws Exception {
-      return internalCreateJMSQueue(storeConfig, queueName, selectorString, durable, false, bindings);
+      return internalCreateJMSQueue(storeConfig, queueName, queueName, selectorString, durable, false, bindings);
+   }
+
+   @Override
+   public boolean createQueue(boolean storeConfig, String queueName, String jmsQueueName, String selectorString, boolean durable, String... bindings) throws Exception {","[{'comment': 'As per other comment, not sure why adding new methods here. If the reason for this change is just back compatibility of ActiveMQDestination. If really needed can we mark deprecated.', 'commenter': 'michaelandrepearce'}]"
1778,tests/compatibility-tests/src/main/resources/serial/serial.groovy,"@@ -24,30 +24,40 @@ import org.apache.activemq.artemis.jms.client.*
 
 file = arg[0]
 method = arg[1]
-System.out.println(""File::"" + file);
+version = arg[2]
+System.out.println(""File::"" + file)
 
 
 if (method.equals(""write"")) {
     cf = new ActiveMQConnectionFactory(""tcp://localhost:61616?confirmationWindowSize=1048576&blockOnDurableSend=false"");
     queue = new ActiveMQQueue(""queue"");
     topic = new ActiveMQTopic(""topic"")
+    if (version.equals(""ARTEMIS-SNAPSHOT"")) {
+        destination = new ActiveMQDestination(""address"", ""name"", ActiveMQDestination.TYPE.DESTINATION, null)","[{'comment': 'I dont think we should be creating ActiveMQDestination with ""name"" in 2.X this constructor should be deprecated, the ""name"" is only for compatibility with older client version.', 'commenter': 'michaelandrepearce'}, {'comment': ""Verifying compatibility is exactly what this test is for so it's valid for it to be using the deprecated fields."", 'commenter': 'jbertram'}, {'comment': 'Fair enough, you sold me.', 'commenter': 'michaelandrepearce'}]"
1778,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQTopic.java,"@@ -40,8 +40,12 @@ public ActiveMQTopic(final String address) {
       this(address, false);
    }
 
+   public ActiveMQTopic(final String address, final String name) {","[{'comment': 'Please mark as deprecated', 'commenter': 'michaelandrepearce'}]"
1778,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQQueue.java,"@@ -41,6 +41,10 @@ public ActiveMQQueue(final String address) {
       super(address, TYPE.QUEUE, null);
    }
 
+   public ActiveMQQueue(final String address, final String name) {","[{'comment': 'please mark as deprecated.', 'commenter': 'michaelandrepearce'}]"
1778,tests/compatibility-tests/src/main/resources/serial/jbmserial.groovy,"@@ -49,6 +50,11 @@ if (method.equals(""write"")) {
     topic = new ActiveMQTopic(""topic"")
     temporary = ActiveMQDestination.createTemporaryQueue(""whatever"")
     temporaryTopic = ActiveMQDestination.createTemporaryTopic(""whatever"")
+    if (version.equals(""ARTEMIS-SNAPSHOT"")) {
+        destination = new ActiveMQDestination(""address"", ""name"", ActiveMQDestination.TYPE.DESTINATION, null)","[{'comment': 'Same as other comment, for 2.x this really should be using the non ""name"" constructor this constructor should be deprecated.', 'commenter': 'michaelandrepearce'}, {'comment': ""This is for backwards compatibility. We need to use the field to validate the older format. it's good to be here."", 'commenter': 'clebertsuconic'}, {'comment': 'sold.', 'commenter': 'michaelandrepearce'}]"
1778,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQDestination.java,"@@ -244,22 +262,32 @@ public static ActiveMQTemporaryTopic createTemporaryTopic(String address) {
    protected ActiveMQDestination(final String address,
                                  final TYPE type,
                                  final ActiveMQSession session) {
-      this.simpleAddress = SimpleString.toSimpleString(address);
-
-      this.thetype = type;
-
-      this.session = session;
+      this(SimpleString.toSimpleString(address), type, session);
+   }
 
-      this.temporary = TYPE.isTemporary(type);
+   protected ActiveMQDestination(final SimpleString address,
+                                 final TYPE type,
+                                 final ActiveMQSession session) {
+      this(address, address != null ? address.toString() : null, type, session);
+   }
 
-      this.queue = TYPE.isQueue(type);
+   protected ActiveMQDestination(final String address,
+                                 final String name,
+                                 final TYPE type,
+                                 final ActiveMQSession session) {
+      this(SimpleString.toSimpleString(address), name, type, session);
    }
 
    protected ActiveMQDestination(final SimpleString address,","[{'comment': 'Can this please be marked as deprecated and the main or super constructor just care for simple address.', 'commenter': 'michaelandrepearce'}, {'comment': 'e.g.\r\n```\r\n   protected ActiveMQDestination(final String address,\r\n                                 final TYPE type,\r\n                                 final ActiveMQSession session) {\r\n      this(SimpleString.toSimpleString(address), type, session);\r\n   }\r\n\r\n   protected ActiveMQDestination(final SimpleString address,\r\n                                 final TYPE type,\r\n                                 final ActiveMQSession session) {\r\n      setSimpleAddress(address);\r\n\r\n      this.thetype = type;\r\n\r\n      this.session = session;\r\n\r\n      this.temporary = TYPE.isTemporary(type);\r\n\r\n      this.queue = TYPE.isQueue(type);\r\n   }\r\n\r\n   @Deprecated\r\n   protected ActiveMQDestination(final String address,\r\n                                 final String name,\r\n                                 final TYPE type,\r\n                                 final ActiveMQSession session) {\r\n      this(SimpleString.toSimpleString(address), name, type, session);\r\n   }\r\n\r\n   @Deprecated\r\n   protected ActiveMQDestination(final SimpleString address,\r\n                                 final String name,\r\n                                 final TYPE type,\r\n                                 final ActiveMQSession session) {\r\n      this(address, type, session);\r\n      this.name = name;\r\n   }\r\n```', 'commenter': 'michaelandrepearce'}]"
1778,tests/compatibility-tests/src/test/java/org/apache/activemq/artemis/tests/compatibility/SerializationTest.java,"@@ -91,15 +91,15 @@ public void afterTest() {
    @Test
    public void testSerializeFactory() throws Throwable {
       File file = serverFolder.newFile(""objects.ser"");
-      callScript(senderClassloader, ""serial/serial.groovy"", file.getAbsolutePath(), ""write"");
-      callScript(receiverClassloader, ""serial/serial.groovy"", file.getAbsolutePath(), ""read"");
+      callScript(senderClassloader, ""serial/serial.groovy"", file.getAbsolutePath(), ""write"", sender);
+      callScript(receiverClassloader, ""serial/serial.groovy"", file.getAbsolutePath(), ""read"", receiver);
    }
 
    @Test
    public void testJBMSerializeFactory() throws Throwable {
       File file = serverFolder.newFile(""objectsjbm.ser"");
-      callScript(senderClassloader, ""serial/jbmserial.groovy"", file.getAbsolutePath(), ""write"");
-      callScript(receiverClassloader, ""serial/jbmserial.groovy"", file.getAbsolutePath(), ""read"");
+      callScript(senderClassloader, ""serial/jbmserial.groovy"", file.getAbsolutePath(), ""write"", sender);","[{'comment': ""what's the sender/receiver for? "", 'commenter': 'clebertsuconic'}, {'comment': '@jbertram mistake?', 'commenter': 'clebertsuconic'}, {'comment': ""It's the version used by the script to determine which destination constructor to use."", 'commenter': 'jbertram'}]"
1828,artemis-commons/src/main/java/org/apache/activemq/artemis/utils/collections/TypedProperties.java,"@@ -31,6 +31,7 @@
 import org.apache.activemq.artemis.utils.AbstractByteBufPool;
 import org.apache.activemq.artemis.utils.ByteUtil;
 import org.apache.activemq.artemis.utils.DataConstants;
+import org.apache.qpid.proton.amqp.UnsignedInteger;","[{'comment': '-1 AMQP dependencies should only be within the AMQP Protocol module.', 'commenter': 'michaelandrepearce'}]"
1828,artemis-commons/pom.xml,"@@ -79,6 +79,10 @@
          <artifactId>junit</artifactId>
          <scope>test</scope>
       </dependency>
+       <dependency>","[{'comment': '-1 see other comment , AMQP deps must stay within the AMQP module only.', 'commenter': 'michaelandrepearce'}]"
1960,artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompSession.java,"@@ -154,12 +154,16 @@ public int sendMessage(MessageReference ref,
             encoder.encode(buffer, bodySize);
             encoder.close();
          } else {
-            buffer = coreMessage.getReadOnlyBodyBuffer();
+            if (Boolean.TRUE.equals(serverMessage.getBooleanProperty(Message.HDR_LARGE_COMPRESSED))) {
+               buffer = coreMessage.getBodyBuffer();","[{'comment': ""You should always use the readOnlyBodyBuffer...\r\n\r\nWhy did you need the writeable body buffer here? it's dangerous!"", 'commenter': 'clebertsuconic'}, {'comment': ""this is because we need to decompress the content before send to clients. If readonly we can't write into it."", 'commenter': 'gaohoward'}]"
1960,artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/CommandType.java,"@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.core.protocol.stomp;
+
+public enum CommandType {
+
+   CONNECT(Stomp.Commands.CONNECT),
+   SEND(Stomp.Commands.SEND),
+   DISCONNECT(Stomp.Commands.DISCONNECT),
+   SUBSCRIBE(Stomp.Commands.SUBSCRIBE),
+   UNSUBSCRIBE(Stomp.Commands.UNSUBSCRIBE),
+   BEGIN(Stomp.Commands.BEGIN),
+   COMMIT(Stomp.Commands.COMMIT),
+   ABORT(Stomp.Commands.ABORT),
+   ACK(Stomp.Commands.ACK),
+   NACK(Stomp.Commands.NACK),
+   STOMP(Stomp.Commands.STOMP),
+   CONNECTED(Stomp.Responses.CONNECTED),
+   ERROR(Stomp.Responses.ERROR),
+   MESSAGE(Stomp.Responses.MESSAGE),
+   RECEIPT(Stomp.Responses.RECEIPT);
+
+   private String type;
+
+   CommandType(String command) {
+      type = command;
+   }
+
+   @Override
+   public String toString() {
+      return type;
+   }
+
+   public static CommandType getType(String command) {
+      switch (command) {","[{'comment': ""There are serious performance implications on this, right?\r\n\r\nyou're using getType on the hot path... (on Every frame creation). What happened to that code that would inspect just a few bytes of the frame and create the StompFrame fast... this is a major regression here."", 'commenter': 'clebertsuconic'}, {'comment': ""ok fair point. I'll remove this."", 'commenter': 'gaohoward'}]"
1960,artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompTransaction.java,"@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.core.protocol.stomp;
+
+import org.apache.activemq.artemis.api.core.Message;
+import org.apache.activemq.artemis.core.server.ServerSession;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Control's stomp transaction processing
+ * it goes with stomp connections.
+ * it stores acks, sends, nacks
+ * during commit it applies those to core sessions.
+ * because each stomp connection uses only one session
+ * we can't rely on core session to manage multiple
+ * tx's.
+ */
+public class StompTransaction {
+
+   private List<StompAck> acks = new ArrayList<>();","[{'comment': ""Instead of storing these here.. Can't you do like XA is doing? Recover the transaction... and do the proper Transaction object?\r\n\r\n\r\nDo you really need a StompTransaction? can't you reuse the actual Transaction we already have?"", 'commenter': 'clebertsuconic'}, {'comment': 'The StompTransaction is just a data holding acks/sends, the real transaction is delegated to core session. Using XA would be unnecessary as we are not dealing with global transactions.', 'commenter': 'gaohoward'}, {'comment': ""Transactions in Artemis are usually done at the storage. The operation on the journal is stored right away... then a pending commit is in place. when you hit commit, you just call transaction.commit(....); and that will do the journal part.. etc.\r\n\r\nthe thing that if you duplicate Transaction functionality from the session, you won't inherit other features such as timeouts.. etc...\r\n\r\n\r\nIf you need to support this, I would do it properly.. even if it requires some light refactoring on how transactions are stored. (I believe you could use the XID to get the transaction.. as a matter of fact the previous version had some code before such as manager.getTransactionI()).\r\n\r\n\r\nlater on when users complain about a timed out transactions, you will have a better chance of implementing through the ResourceManager that is already in place."", 'commenter': 'clebertsuconic'}]"
1964,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/impl/BridgeImpl.java,"@@ -927,9 +927,7 @@ protected void connect() {
                scheduleRetryConnectFixedTimeout(this.retryInterval);
                return;
             } else {
-               if (logger.isDebugEnabled()) {
-                  logger.debug(""Bridge "" + this + "" is unable to connect to destination. Retrying"", e);
-               }
+               logger.warn(""Bridge "" + this + "" is unable to connect to destination. Retrying..."");","[{'comment': ""Can we use the logger class's for this, as its no longer a debug message, should have proper code etc. etc."", 'commenter': 'michaelandrepearce'}, {'comment': '@michaelandrepearce I have used the same message as in another if-else condition. is it ok?', 'commenter': 'rstancel'}, {'comment': 'Not really it should have its own, it‚Äôs a different issue, and so should have its own dedicated log error code and log output.', 'commenter': 'michaelandrepearce'}]"
2035,artemis-server/src/main/java/org/apache/activemq/artemis/core/management/impl/ActiveMQServerControlImpl.java,"@@ -1830,7 +1830,18 @@ public String listConnectionsAsJSON() throws Exception {
          Set<RemotingConnection> connections = server.getRemotingService().getConnections();
 
          for (RemotingConnection connection : connections) {
-            JsonObjectBuilder obj = JsonLoader.createObjectBuilder().add(""connectionID"", connection.getID().toString()).add(""clientAddress"", connection.getRemoteAddress()).add(""creationTime"", connection.getCreationTime()).add(""implementation"", connection.getClass().getSimpleName()).add(""sessionCount"", server.getSessions(connection.getID().toString()).size());
+            JsonObjectBuilder obj = JsonLoader.createObjectBuilder().add(""connectionID"", connection.getID().toString())
+               .add(""clientAddress"", connection.getRemoteAddress())
+               .add(""creationTime"", connection.getCreationTime())
+               .add(""implementation"", connection.getClass().getSimpleName())","[{'comment': ""Please avoid reformatting like this, there's no code change here "", 'commenter': 'michaelandrepearce'}]"
2035,artemis-server/src/main/java/org/apache/activemq/artemis/core/management/impl/ActiveMQServerControlImpl.java,"@@ -1849,7 +1860,9 @@ public String listSessionsAsJSON(final String connectionID) throws Exception {
       try {
          List<ServerSession> sessions = server.getSessions(connectionID);
          for (ServerSession sess : sessions) {
-            JsonObjectBuilder obj = JsonLoader.createObjectBuilder().add(""sessionID"", sess.getName()).add(""creationTime"", sess.getCreationTime()).add(""consumerCount"", sess.getServerConsumers().size());
+            JsonObjectBuilder obj = JsonLoader.createObjectBuilder().add(""sessionID"", sess.getName())
+               .add(""creationTime"", sess.getCreationTime())","[{'comment': ""Please avoid reformatting like this, there's no code change here "", 'commenter': 'michaelandrepearce'}, {'comment': 'Sorry, but may I ask why? I think increasing legibility is a good thing.', 'commenter': 'iweiss'}, {'comment': 'I don\'t want to speak for @michaelandrepearce, but personally I find it much easier to review PRs when all the changes in the PR are directly related. This PR is about adding missing fields to some management methods not increasing code legibility. In general, increasing code legibility is a good thing, but it can be detrimental in non-obvious ways (e.g. when lots of legibility changes make it difficult to back-port fixes to maintenance branches) and IMO changes which are exclusively for improving legibility should be in their own commits. Finally, ""legibility"" can be subjective. You risk having your functional PR rejected by including non-functional, subjective ""improvements.""', 'commenter': 'jbertram'}]"
2035,artemis-server/src/main/java/org/apache/activemq/artemis/core/management/impl/ActiveMQServerControlImpl.java,"@@ -1873,7 +1886,9 @@ public String listAllSessionsAsJSON() throws Exception {
       try {
          Set<ServerSession> sessions = server.getSessions();
          for (ServerSession sess : sessions) {
-            JsonObjectBuilder obj = JsonLoader.createObjectBuilder().add(""sessionID"", sess.getName()).add(""creationTime"", sess.getCreationTime()).add(""consumerCount"", sess.getServerConsumers().size());
+            JsonObjectBuilder obj = JsonLoader.createObjectBuilder().add(""sessionID"", sess.getName())
+               .add(""creationTime"", sess.getCreationTime())","[{'comment': ""Please avoid reformatting like this, there's no code change here "", 'commenter': 'michaelandrepearce'}]"
2035,artemis-server/src/main/java/org/apache/activemq/artemis/core/management/impl/ActiveMQServerControlImpl.java,"@@ -1943,11 +1958,43 @@ public String listAllConsumersAsJSON() throws Exception {
    }
 
    private JsonObject toJSONObject(ServerConsumer consumer) throws Exception {
-      JsonObjectBuilder obj = JsonLoader.createObjectBuilder().add(""consumerID"", consumer.getID()).add(""connectionID"", consumer.getConnectionID().toString()).add(""sessionID"", consumer.getSessionID()).add(""queueName"", consumer.getQueue().getName().toString()).add(""browseOnly"", consumer.isBrowseOnly()).add(""creationTime"", consumer.getCreationTime()).add(""deliveringCount"", consumer.getDeliveringMessages().size());
+      JsonObjectBuilder obj = JsonLoader.createObjectBuilder().add(""consumerID"", consumer.getID())
+         .add(""connectionID"", consumer.getConnectionID().toString())
+         .add(""sessionID"", consumer.getSessionID())","[{'comment': ""Please avoid reformatting like this, there's no code change here "", 'commenter': 'michaelandrepearce'}]"
2035,artemis-server/src/main/java/org/apache/activemq/artemis/core/management/impl/ActiveMQServerControlImpl.java,"@@ -1943,11 +1958,43 @@ public String listAllConsumersAsJSON() throws Exception {
    }
 
    private JsonObject toJSONObject(ServerConsumer consumer) throws Exception {
-      JsonObjectBuilder obj = JsonLoader.createObjectBuilder().add(""consumerID"", consumer.getID()).add(""connectionID"", consumer.getConnectionID().toString()).add(""sessionID"", consumer.getSessionID()).add(""queueName"", consumer.getQueue().getName().toString()).add(""browseOnly"", consumer.isBrowseOnly()).add(""creationTime"", consumer.getCreationTime()).add(""deliveringCount"", consumer.getDeliveringMessages().size());
+      JsonObjectBuilder obj = JsonLoader.createObjectBuilder().add(""consumerID"", consumer.getID())
+         .add(""connectionID"", consumer.getConnectionID().toString())
+         .add(""sessionID"", consumer.getSessionID())
+         .add(""queueName"", consumer.getQueue().getName().toString())
+         .add(""browseOnly"", consumer.isBrowseOnly())
+         .add(""creationTime"", consumer.getCreationTime())
+         .add(""deliveringCount"", consumer.getDeliveringMessages().size());
       if (consumer.getFilter() != null) {
          obj.add(""filter"", consumer.getFilter().getFilterString().toString());
       }
 
+      String coreAddress = consumer.getQueue().getAddress().toString();
+
+      String[] result = new String[2]; // destination name & type","[{'comment': 'Please remove this is brittle code based on jms prefixes which is bad, broker uses core model. Saying that this is address and queue level information (e.g. Multicast vs Anycast), not consumer ', 'commenter': 'michaelandrepearce'}]"
2035,artemis-server/src/main/java/org/apache/activemq/artemis/core/management/impl/ActiveMQServerControlImpl.java,"@@ -1943,11 +1958,43 @@ public String listAllConsumersAsJSON() throws Exception {
    }
 
    private JsonObject toJSONObject(ServerConsumer consumer) throws Exception {
-      JsonObjectBuilder obj = JsonLoader.createObjectBuilder().add(""consumerID"", consumer.getID()).add(""connectionID"", consumer.getConnectionID().toString()).add(""sessionID"", consumer.getSessionID()).add(""queueName"", consumer.getQueue().getName().toString()).add(""browseOnly"", consumer.isBrowseOnly()).add(""creationTime"", consumer.getCreationTime()).add(""deliveringCount"", consumer.getDeliveringMessages().size());
+      JsonObjectBuilder obj = JsonLoader.createObjectBuilder().add(""consumerID"", consumer.getID())
+         .add(""connectionID"", consumer.getConnectionID().toString())
+         .add(""sessionID"", consumer.getSessionID())
+         .add(""queueName"", consumer.getQueue().getName().toString())
+         .add(""browseOnly"", consumer.isBrowseOnly())
+         .add(""creationTime"", consumer.getCreationTime())
+         .add(""deliveringCount"", consumer.getDeliveringMessages().size());
       if (consumer.getFilter() != null) {
          obj.add(""filter"", consumer.getFilter().getFilterString().toString());
       }
 
+      String coreAddress = consumer.getQueue().getAddress().toString();
+
+      String[] result = new String[2]; // destination name & type
+      if (coreAddress.startsWith(""jms.queue."")) {
+         result[0] = coreAddress.substring(""jms.queue."".length());
+         result[1] = ""queue"";
+      } else if (coreAddress.startsWith(""jms.tempqueue."")) {
+         result[0] = coreAddress.substring(""jms.tempqueue."".length());
+         result[1] = ""tempqueue"";
+      } else if (coreAddress.startsWith(""jms.topic."")) {
+         result[0] = coreAddress.substring(""jms.topic."".length());
+         result[1] = ""topic"";
+      } else if (coreAddress.startsWith(""jms.temptopic."")) {
+         result[0] = coreAddress.substring(""jms.temptopic."".length());
+         result[1] = ""temptopic"";
+      } else {
+         logger.debug(""Unable to determine the JMS destination of "" + coreAddress);
+         // not related to JMS
+         result[0] = """";
+         result[1] = """";
+      }
+
+      obj.add(""destinationName"", result[0])
+         .add(""destinationType"", result[1])
+         .add(""durable"", consumer.getQueue().isDurable());","[{'comment': ""This isn't consumer info, this is on the queue level information, please remove"", 'commenter': 'michaelandrepearce'}]"
2089,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/ha/ReplicaPolicy.java,"@@ -57,6 +57,8 @@
 
    private long voteRetryWait;
 
+   private int quorumVoteWait = ActiveMQDefaultConfiguration.getDefaultQuorumVoteWait();","[{'comment': 'It would be better to just use the one provided by the constructor and declare this `final` if is not meant to be modified anymore', 'commenter': 'franz1981'}]"
2089,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/ha/ReplicaPolicy.java,"@@ -91,6 +94,7 @@ public ReplicaPolicy(String clusterName,
       this.scaleDownPolicy = scaleDownPolicy;
       this.networkHealthCheck = networkHealthCheck;
       this.voteOnReplicationFailure = voteOnReplicationFailure;
+      this.quorumVoteWait = quorumVoteWait;","[{'comment': 'Please perform some basic validation on the new parameter', 'commenter': 'franz1981'}]"
2089,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/ha/ReplicaPolicy.java,"@@ -234,4 +238,12 @@ public int getVoteRetries() {
    public long getVoteRetryWait() {
       return voteRetryWait;
    }
+
+   public int getQuorumVoteWait() {
+      return quorumVoteWait;
+   }
+
+   public void setQuorumVoteWait(int quorumVoteWait) {","[{'comment': '`quorumVoteWait` could be modified while running?', 'commenter': 'franz1981'}]"
2089,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/ha/ReplicatedPolicy.java,"@@ -106,6 +111,7 @@ public ReplicatedPolicy(boolean checkForLiveServer,
       this.networkHealthCheck = networkHealthCheck;
       this.voteOnReplicationFailure = voteOnReplicationFailure;
       this.quorumSize = quorumSize;
+      this.quorumVoteWait = quorumVoteWait;","[{'comment': 'Please perform some basic validation on the new parameter', 'commenter': 'franz1981'}]"
2089,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/ha/ReplicatedPolicy.java,"@@ -84,6 +87,7 @@ public ReplicatedPolicy(boolean checkForLiveServer,
       this.quorumSize = quorumSize;
       this.voteRetries = voteRetries;
       this.voteRetryWait = voteRetryWait;
+      this.quorumVoteWait = quorumVoteWait;","[{'comment': 'Please perform some basic validation on the new parameter', 'commenter': 'franz1981'}]"
2089,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/ha/ReplicatedPolicy.java,"@@ -230,4 +237,12 @@ public int getQuorumSize() {
    public void setQuorumSize(int quorumSize) {
       this.quorumSize = quorumSize;
    }
-}
+
+   public int getQuorumVoteWait() {
+      return quorumVoteWait;
+   }
+
+   public void setQuorumVoteWait(int quorumVoteWait) {","[{'comment': 'quorumVoteWait could be modified while running?', 'commenter': 'franz1981'}]"
2089,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/ha/ReplicatedPolicy.java,"@@ -158,6 +164,7 @@ public ReplicaPolicy getReplicaPolicy() {
          if (groupName != null && groupName.length() > 0) {
             replicaPolicy.setGroupName(groupName);
          }
+         replicaPolicy.setQuorumVoteWait(quorumVoteWait);","[{'comment': 'pass the parameter using the `ReplicePolicy` constructor to not escape the validation that it could perform', 'commenter': 'franz1981'}]"
2089,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/ha/ReplicatedPolicy.java,"@@ -61,6 +61,8 @@
 
    private final NetworkHealthCheck networkHealthCheck;
 
+   private int quorumVoteWait = ActiveMQDefaultConfiguration.getDefaultQuorumVoteWait();","[{'comment': 'It would be better to just use the one provided by the constructor and declare this final if is not meant to be modified anymore', 'commenter': 'franz1981'}, {'comment': 'This the default value that is configured and it is supposed to change hence not kept final.', 'commenter': 'RaiSaurabh'}]"
2089,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/qourum/SharedNothingBackupQuorum.java,"@@ -90,6 +92,7 @@ public SharedNothingBackupQuorum(StorageManager storageManager,
       this.networkHealthCheck = networkHealthCheck;
       this.voteRetries = voteRetries;
       this.voteRetryWait = voteRetryWait;
+      this.quorumVoteWait = quorumVoteWait;","[{'comment': 'Please perform some basic validation on the new parameter', 'commenter': 'franz1981'}, {'comment': 'The parameter is already validated when it is picked form the broker .xml.  You can check class ""FileConfigurationParser"" L1322 and L1352 for validation of number greater than zero.', 'commenter': 'RaiSaurabh'}]"
2089,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/qourum/SharedNothingBackupQuorum.java,"@@ -297,7 +300,7 @@ private boolean isLiveDown() {
             quorumManager.vote(quorumVote);
 
             try {
-               quorumVote.await(LATCH_TIMEOUT, TimeUnit.SECONDS);
+               quorumVote.await(quorumVoteWait, TimeUnit.SECONDS);
             } catch (InterruptedException interruption) {
                // No-op. The best the quorum can do now is to return the latest number it has","[{'comment': 'Please add some trace logs before the `await` and on the catch scope to log that the await has been interrupted', 'commenter': 'franz1981'}, {'comment': 'The await method has already logged on entry. I have added the log in the catch block.', 'commenter': 'RaiSaurabh'}]"
2089,artemis-server/src/main/java/org/apache/activemq/artemis/core/config/ha/ReplicaPolicyConfiguration.java,"@@ -47,7 +47,10 @@
 
    private long voteRetryWait = ActiveMQDefaultConfiguration.getDefaultVoteRetryWait();
 
-   public ReplicaPolicyConfiguration() {
+   private final int quorumVoteWait;","[{'comment': 'This should be set to default as like vote retry above\r\n', 'commenter': 'michaelandrepearce'}]"
2191,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/client/impl/ServerLocatorImpl.java,"@@ -347,7 +347,7 @@ private ServerLocatorImpl(final Topology topology,
 
       minLargeMessageSize = ActiveMQClient.DEFAULT_MIN_LARGE_MESSAGE_SIZE;
 
-      consumerWindowSize = ActiveMQClient.DEFAULT_CONSUMER_WINDOW_SIZE;
+      consumerWindowSize = -1;","[{'comment': 'Should still be defaulted to a constant', 'commenter': 'michaelandrepearce'}, {'comment': 'I can change it back but I was using -1 to figure out whether or not the value was set.  The issue is that if someone manually wants to set the client to the same value as that constant then it will always be overriden by the default from the server.  The idea is if the client sets the value that should be used instead....Not sure how to get around that without adding another flag to indicate the user overrode the value (or set it to null by default)', 'commenter': 'cshannon'}]"
2191,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/protocol/core/impl/ActiveMQSessionContext.java,"@@ -822,6 +833,20 @@ public void resetMetadata(HashMap<String, String> metaDataToSend) {
       }
    }
 
+   @Override
+   public int getDefaultConsumerWindowSize(SimpleString address) throws ActiveMQException {
+      if (defaultConsumerWindowSize != null) {
+         return defaultConsumerWindowSize;
+      } else if (sessionChannel.supports(PacketImpl.SESS_CONS_WINDOW_SIZE_RESP, getServerVersion())) {
+         Packet packet = sessionChannel.sendBlocking(new ConsumerWindowSizeQueryMessage(address), PacketImpl.SESS_CONS_WINDOW_SIZE_RESP);
+         ConsumerWindowSizeQueryResponseMessage response = (ConsumerWindowSizeQueryResponseMessage) packet;","[{'comment': 'Could this not be returned in the create consumer response or address settings lookup, to avoid extra calls. Imagine further defaults etc if everything was an individual request it would bloat fast.', 'commenter': 'michaelandrepearce'}, {'comment': '@michaelandrepearce - yes I could probably just extend the SessionQueueQueryResponseMessage and create a SessionQueueQueryResponseMessage_V4 and add that info to it...I will go ahead and do that and rework this', 'commenter': 'cshannon'}]"
2191,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/protocol/core/impl/wireformat/SessionQueueQueryResponseMessage_V4.java,"@@ -0,0 +1,151 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.core.protocol.core.impl.wireformat;
+
+import org.apache.activemq.artemis.api.core.ActiveMQBuffer;
+import org.apache.activemq.artemis.api.core.RoutingType;
+import org.apache.activemq.artemis.api.core.SimpleString;
+import org.apache.activemq.artemis.api.core.client.ActiveMQClient;
+import org.apache.activemq.artemis.api.core.client.ClientSession;
+import org.apache.activemq.artemis.core.client.impl.QueueQueryImpl;
+import org.apache.activemq.artemis.core.server.QueueQueryResult;
+
+public class SessionQueueQueryResponseMessage_V4 extends SessionQueueQueryResponseMessage_V3 {
+
+   protected int defaultConsumerWindowSize;
+
+   public SessionQueueQueryResponseMessage_V4(final QueueQueryResult result) {
+      this(result.getName(), result.getAddress(), result.isDurable(), result.isTemporary(), result.getFilterString(), result.getConsumerCount(), result.getMessageCount(), result.isExists(), result.isAutoCreateQueues(), result.isAutoCreated(), result.isPurgeOnNoConsumers(), result.getRoutingType(), result.getMaxConsumers(), result.isExclusive(), result.isLastValue(), result.getDefaultConsumerWindowSize());","[{'comment': ""@cshannon just wondering.. wouldn't be worth to invest here to return a hashMap instead? \r\n\r\nWe keep creating V4, V5... if we start using a Map, we wouldn't need to change the wire for this ever again."", 'commenter': 'clebertsuconic'}, {'comment': 'So for V4 just use a hash map for all values? And then have all the getters reference the map? That would be fine with me especially because @michaelandrepearce mentioned maybe adding other settings as well...while we could add some settings now there will always be more changes\r\n\r\nI can make the change tomorrow morning', 'commenter': 'cshannon'}, {'comment': 'Or actually do you just want to keep existing stuff the way it is and only use the Map for new values starting with defaultConsumerWindowSize?', 'commenter': 'cshannon'}, {'comment': ""I would keep existing stuff the way it is... and use the map for new values.\r\n\r\nAnyway.. that's a suggestion... if you don't have time to do it now I will merge it as is... let me know?"", 'commenter': 'clebertsuconic'}, {'comment': 'I would keep it as is. I think a dicussion is needes as currently having the version and typing means there is a strong contract, moving to a map removes the strong versioned contract. Eg if anything should look to a schema protocol like protobuf or avro.', 'commenter': 'michaelandrepearce'}, {'comment': 'By the way there is no need for a new version with this change if the new param is added at the end of the buffer and is nullable (aka Integer) old clients simply wont read it and new ones will, for new clients they just need to check if still readable bytes to keep client compatible to older broker. See last change when we added exclusive how it was done.\r\n\r\nI would request this change before merge btw.', 'commenter': 'michaelandrepearce'}]"
2241,examples/features/standard/spring-boot-integration/pom.xml,"@@ -0,0 +1,94 @@
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+	xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+	xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+	<modelVersion>4.0.0</modelVersion>
+	<parent>
+		<groupId>org.apache.activemq.examples.broker</groupId>
+		<artifactId>jms-examples</artifactId>
+		<version>2.7.0-SNAPSHOT</version>
+	</parent>
+	<artifactId>spring-boot-integration</artifactId>
+	<name>ActiveMQ Artemis JMS Spring Boot Integration Example</name>
+
+	<properties>
+		<activemq.basedir>${project.basedir}/../../../..</activemq.basedir>
+
+		<!-- AMQP Spring Starter -->
+		<amqp-10-jms-spring.version>2.0.1</amqp-10-jms-spring.version>
+		<!-- JMS Pool -->
+		<jms-pool.version>1.0.2</jms-pool.version>
+	</properties>
+
+	<dependencies>
+		<dependency>
+			<groupId>org.apache.activemq</groupId>
+			<artifactId>artemis-amqp-protocol</artifactId>
+			<version>${project.version}</version>
+		</dependency>
+		<dependency>
+			<groupId>org.amqphub.spring</groupId>
+			<artifactId>amqp-10-jms-spring-boot-starter</artifactId>
+			<version>${amqp-10-jms-spring.version}</version>
+		</dependency>
+		<dependency>
+			<groupId>org.messaginghub</groupId>","[{'comment': ""If this is a spring boot example, and example using Spring JMS CachingConnection Factory would be more suitable, or at least as well as this. \r\n\r\nAnd then some more info needed in the docs to describe + and - of using messaginghubs pool cf vs springs caching cf.\r\n\r\nA bit like there is some really good detail in active 5.x around why to use their pool, and the JMSTemplate gotchas.\r\n\r\nhttp://activemq.apache.org/spring-support.html\r\nhttp://activemq.apache.org/jmstemplate-gotchas.html\r\n\r\nAlso i would add, I have a slight issue in why is Pooled CF (seems message hub's is rooted from the active 5.x one) being pulled out apache project to be hosted else where and not being contributed back? Surely this should remain living in the Apache ActiveMQ project (either as a subproject, or if needed on artemis in artemis)"", 'commenter': 'michaelandrepearce'}]"
2254,artemis-commons/src/main/java/org/apache/activemq/artemis/utils/ArtemisSystemProperties.java,"@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.utils;
+
+import java.net.URL;
+import java.util.Properties;
+
+import org.jboss.logging.Logger;
+
+public final class ArtemisSystemProperties {
+","[{'comment': 'This class is a bad idea. Having config setting to statics means if two cfs and want different setting for each eg connection to different clusters, then you cant. ', 'commenter': 'michaelandrepearce'}, {'comment': 'Also this will act as a broken window and encourage further set this way, further causing such issue.', 'commenter': 'michaelandrepearce'}, {'comment': ""This class is about defaults... The default coming from a system property.\r\n\r\nThere's no way around a System property. users coded for older servers will need to be switched without changes.\r\n\r\n\r\nThe idea of this class is to use a file on the classLoader.\r\n\r\nThis is mainly for wildfly. In Wildfly they have set the entire VM to use older properties. ActiveMQJMSClient should be deprecated... as of now I don't see a way we could fix this without System properties."", 'commenter': 'clebertsuconic'}, {'comment': ""BTW: Two CFs can still have different settings.. on the CF this is just altering the default. You can still switch independently on the CF. The default now comes from a system property instead of a constant variable.\r\n\r\n\r\nAs of on the ActiveMQJMSClient, there's no way to alter the semantic without a system property. But users shouldn't be encouraged to use that class anyways. I'm considering to set it as deprecated."", 'commenter': 'clebertsuconic'}, {'comment': ""@michaelandrepearce \r\n>>> Also this will act as a broken window and encourage further set this way, further causing such issue.\r\n\r\n\r\nThe system property should change defaults only. Only exception will be the AtiveMQJMSClient.\r\n\r\nI don't see any difference than getting a System.property on the class itself instead of encapsulating usage here."", 'commenter': 'clebertsuconic'}, {'comment': 'My concern is the broken window here. That further people may start abusing this in future developments. Could this be closer coupled with the defaults class or something so its very clear this is only used to override the default', 'commenter': 'michaelandrepearce'}, {'comment': 'The reason I encapsulated this.. was because of the file load on the classPath. Wildfly (or anyone else) will be able to specify a properties file on the classLoader and alter this as a System property.\r\n\r\nI am also reusing that between the default on CF and the ActiveMQJMSClient (that needs a system property regardless).', 'commenter': 'clebertsuconic'}]"
2254,artemis-commons/src/main/java/org/apache/activemq/artemis/utils/ArtemisSystemProperties.java,"@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.utils;
+
+import java.net.URL;
+import java.util.Properties;
+
+import org.jboss.logging.Logger;
+
+public final class ArtemisSystemProperties {
+
+   private static Logger logger = Logger.getLogger(ArtemisSystemProperties.class);
+
+   static {
+      init();
+   }
+
+   private static ArtemisSystemProperties theInstance;
+
+   private Properties properties;
+   private boolean enable1XPrefixes = false;","[{'comment': ' this be marked static final and the loading done all in static method.', 'commenter': 'michaelandrepearce'}, {'comment': '@michaelandrepearce The class is singleton. \r\n\r\nthe reason I did not make it final was because of testcases where I can call init() to reload properties.', 'commenter': 'clebertsuconic'}, {'comment': 'Though this is being got on hot path later in message buffers, which is not so good. Having it static final will minimise perf impact', 'commenter': 'michaelandrepearce'}, {'comment': 'Actually.. this is not checked on the hot path. \r\nthe one on the ClientSessionImpl is.', 'commenter': 'clebertsuconic'}, {'comment': 'I tried marking the bits that i think are hot paths. Using phone atm so not easiest', 'commenter': 'michaelandrepearce'}]"
2254,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/client/impl/ClientSessionImpl.java,"@@ -241,6 +243,16 @@
    // ClientSession implementation
    // -----------------------------------------------------------------
 
+   @Override
+   public boolean isEnable1xPrefixes() {
+      return enable1XPrefixes;
+   }
+
+   @Override
+   public void setEnable1xPrefixes(boolean value) {","[{'comment': 'Does this need to be changable? Could this not just be set in constructor and field made final. As later the check is on hot path.', 'commenter': 'michaelandrepearce'}, {'comment': '@michaelandrepearce I needed it to be set because of the ResourceAdapter. MDBs.', 'commenter': 'clebertsuconic'}, {'comment': ""@michaelandrepearce Notice I'm improving the previous solution that had one boolean on each message."", 'commenter': 'clebertsuconic'}, {'comment': '@michaelandrepearce also, notice this is only affecting the default on ActiveMQConnectionFactory... with what is regarded on the hot path.\r\n\r\nThere the value is also settable.', 'commenter': 'clebertsuconic'}, {'comment': 'Ive marked where hot paths concern me. On phone so may have missed one. Wont get to computer to properly go ovee till tomorrow ', 'commenter': 'michaelandrepearce'}]"
2254,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQMessage.java,"@@ -371,7 +369,7 @@ public Destination getJMSReplyTo() throws JMSException {
             String name = address.toString();
 
             // swap the old prefixes for the new ones so the proper destination type gets created
-            if (enable1xPrefixes) {
+            if (session.isEnable1xPrefixes()) {","[{'comment': 'Hot path here', 'commenter': 'michaelandrepearce'}, {'comment': ""It's the same.. instead of a boolean per message, I'm using a single property on the session now. \r\n\r\nWe can improve it later to make sure it's static, but I can't do it ATM becuase of RA and caches of connections."", 'commenter': 'clebertsuconic'}, {'comment': 'The more invasive all these changes just for support of 1.x (isnt that the point of the major version change to signal breaking changes)\r\n\r\nWould it maybe better to have a 1x jms client module, that has all these bits in so users on 2.0.x dont get affected and also then keeps it all a bit more clean room', 'commenter': 'michaelandrepearce'}]"
2254,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQMessage.java,"@@ -423,7 +421,7 @@ public Destination getJMSDestination() throws JMSException {
          SimpleString address = message.getAddressSimpleString();
          SimpleString name = address;
 
-         if (address != null & enable1xPrefixes) {
+         if (address != null & session.isEnable1xPrefixes()) {","[{'comment': 'Hot path here', 'commenter': 'michaelandrepearce'}, {'comment': ""I don't see a difference from the previous code. \r\n\r\nThis is getJMSDestination. Not really on the hot path. "", 'commenter': 'clebertsuconic'}, {'comment': 'It can be heavily called in apps doing dynamic re routing. ', 'commenter': 'michaelandrepearce'}, {'comment': 'Why does session it need to be changable? ', 'commenter': 'michaelandrepearce'}, {'comment': 'Session is not changeable. \r\n\r\nthe property on session currently is changeable because of the ResourceAdapter. \r\n\r\nWe can verify if it can be final there even for RA.', 'commenter': 'clebertsuconic'}, {'comment': ""notice the previous version had a boolean per message. I'm improving this by using nly one at the session."", 'commenter': 'clebertsuconic'}, {'comment': 'I got that this is better but tbh the commit that added thay change was merged fairly rapidly too. And once we relesse we get stuck with it. So rather we tidy up as much as possible now.', 'commenter': 'michaelandrepearce'}]"
2254,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQDestination.java,"@@ -219,7 +221,12 @@ public static SimpleString createTopicAddressFromName(final String name) {
    }
 
    public static ActiveMQQueue createQueue(final String address) {
-      return new ActiveMQQueue(address);
+","[{'comment': 'Hot path here (esp for spring users)', 'commenter': 'michaelandrepearce'}, {'comment': 'I did not mean to change this class. accident! \r\nfixing it!', 'commenter': 'clebertsuconic'}, {'comment': 'That one is fixed', 'commenter': 'clebertsuconic'}]"
2258,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/plugin/ActiveMQServerMessagePlugin.java,"@@ -65,6 +65,21 @@ default void afterSend(ServerSession session, Transaction tx, Message message, b
       this.afterSend(tx, message, direct, noAutoCreateQueue, result);
    }
 
+   /**
+    * When there was an exception sending the message
+    *
+    * @param session
+    * @param tx
+    * @param message
+    * @param direct
+    * @param noAutoCreateQueue
+    * @param e the exception that occurred when sending the message
+    * @throws ActiveMQException
+    */
+   default void onSendError(ServerSession session, Transaction tx, Message message, boolean direct, boolean noAutoCreateQueue,","[{'comment': 'Nit: onSendException', 'commenter': 'michaelandrepearce'}]"
2258,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/plugin/ActiveMQServerMessagePlugin.java,"@@ -128,6 +143,21 @@ default void afterMessageRoute(Message message, RoutingContext context, boolean
 
    }
 
+   /**
+    * When there was an error routing the message
+    *
+    * @param message
+    * @param context
+    * @param direct
+    * @param rejectDuplicates
+    * @param e the exception that occurred during message routing
+    * @throws ActiveMQException
+    */
+   default void onMessageRouteError(Message message, RoutingContext context, boolean direct, boolean rejectDuplicates,","[{'comment': 'Nit: onMessageRouteException', 'commenter': 'michaelandrepearce'}]"
2287,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/FileLockNodeManager.java,"@@ -299,36 +301,57 @@ protected FileLock tryLock(final long lockPos) throws IOException {
 
    protected FileLock lock(final long lockPosition) throws Exception {
       long start = System.currentTimeMillis();
+      boolean isRecurringFailure = false;
 
       while (!interrupted) {
-         FileLock lock = tryLock(lockPosition);
-
-         if (lock == null) {
-            try {
-               Thread.sleep(500);
-            } catch (InterruptedException e) {
-               return null;
-            }
-
-            if (lockAcquisitionTimeout != -1 && (System.currentTimeMillis() - start) > lockAcquisitionTimeout) {
-               throw new Exception(""timed out waiting for lock"");
+         try {
+            FileLock lock = tryLock(lockPosition);
+            isRecurringFailure = false;
+
+            if (lock == null) {
+               logger.debug(""lock is null"");
+               try {
+                  Thread.sleep(500);
+               } catch (InterruptedException e) {
+                  return null;
+               }
+
+               if (lockAcquisitionTimeout != -1 && (System.currentTimeMillis() - start) > lockAcquisitionTimeout) {
+                  throw new Exception(""timed out waiting for lock"");
+               }
+            } else {
+               return lock;
             }
-         } else {
-            return lock;
+         } catch (IOException e) {
+            // IOException during trylock() may be a temporary issue, e.g. NFS volume not being accessible
+            logger.log(isRecurringFailure ? Logger.Level.DEBUG : Logger.Level.WARN,
+                    ""Failure when accessing a lock file"", e);
+            isRecurringFailure = true;","[{'comment': 'This would continue to attempt to lock regardless the `lockAcquisitionTimeout` (if any): i suppose it would be more robust if you will check the timeout anyway. There are tests that are using that timeout and I suppose it should be honored', 'commenter': 'franz1981'}, {'comment': ""Modified to exit if timeout already reached, and don't sleep longer then remaining time to timeout."", 'commenter': 'TomasHofman'}]"
2287,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/FileLockNodeManager.java,"@@ -299,36 +301,57 @@ protected FileLock tryLock(final long lockPos) throws IOException {
 
    protected FileLock lock(final long lockPosition) throws Exception {
       long start = System.currentTimeMillis();
+      boolean isRecurringFailure = false;
 
       while (!interrupted) {
-         FileLock lock = tryLock(lockPosition);
-
-         if (lock == null) {
-            try {
-               Thread.sleep(500);
-            } catch (InterruptedException e) {
-               return null;
-            }
-
-            if (lockAcquisitionTimeout != -1 && (System.currentTimeMillis() - start) > lockAcquisitionTimeout) {
-               throw new Exception(""timed out waiting for lock"");
+         try {
+            FileLock lock = tryLock(lockPosition);
+            isRecurringFailure = false;
+
+            if (lock == null) {
+               logger.debug(""lock is null"");
+               try {
+                  Thread.sleep(500);
+               } catch (InterruptedException e) {
+                  return null;
+               }
+
+               if (lockAcquisitionTimeout != -1 && (System.currentTimeMillis() - start) > lockAcquisitionTimeout) {
+                  throw new Exception(""timed out waiting for lock"");
+               }
+            } else {
+               return lock;
             }
-         } else {
-            return lock;
+         } catch (IOException e) {
+            // IOException during trylock() may be a temporary issue, e.g. NFS volume not being accessible
+            logger.log(isRecurringFailure ? Logger.Level.DEBUG : Logger.Level.WARN,
+                    ""Failure when accessing a lock file"", e);
+            isRecurringFailure = true;
+            Thread.sleep(LOCK_ACCESS_FAILURE_WAIT_TIME);
          }
       }
 
       // todo this is here because sometimes channel.lock throws a resource deadlock exception but trylock works,
       // need to investigate further and review
-      FileLock lock;
+      FileLock lock = null;","[{'comment': 'Same thing as the comment above.', 'commenter': 'franz1981'}, {'comment': 'Now when I look at this again, this whole second loop in the _original code_ doesn\'t make sense - the only way execution could get here is when the ```interrupted``` flag was set to true, in which case we should exit immediately. The comment mentions ""deadlock exception"", but any exception in the first loop would terminate the method.\r\n\r\nI\'m gonna remove this second loop altogether.\r\n\r\nUnfortunately history is not preserved...', 'commenter': 'TomasHofman'}]"
2287,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/FileLockNodeManager.java,"@@ -299,44 +303,52 @@ protected FileLock tryLock(final long lockPos) throws IOException {
 
    protected FileLock lock(final long lockPosition) throws Exception {
       long start = System.currentTimeMillis();
+      boolean isRecurringFailure = false;
 
       while (!interrupted) {
-         FileLock lock = tryLock(lockPosition);
-
-         if (lock == null) {
-            try {
-               Thread.sleep(500);
-            } catch (InterruptedException e) {
-               return null;
+         try {
+            FileLock lock = tryLock(lockPosition);
+            isRecurringFailure = false;
+
+            if (lock == null) {
+               try {
+                  Thread.sleep(500);
+               } catch (InterruptedException e) {
+                  return null;
+               }
+
+               if (lockAcquisitionTimeout != -1 && (System.currentTimeMillis() - start) > lockAcquisitionTimeout) {
+                  throw new Exception(""timed out waiting for lock"");
+               }
+            } else {
+               return lock;
             }
-
-            if (lockAcquisitionTimeout != -1 && (System.currentTimeMillis() - start) > lockAcquisitionTimeout) {
-               throw new Exception(""timed out waiting for lock"");
+         } catch (IOException e) {
+            // IOException during trylock() may be a temporary issue, e.g. NFS volume not being accessible
+
+            logger.log(isRecurringFailure ? Logger.Level.DEBUG : Logger.Level.WARN,
+                    ""Failure when accessing a lock file"", e);
+            isRecurringFailure = true;
+
+            long waitTime = LOCK_ACCESS_FAILURE_WAIT_TIME;
+            if (lockAcquisitionTimeout != -1) {
+               final long remainingTime = lockAcquisitionTimeout - (System.currentTimeMillis() - start);
+               if (remainingTime <= 0) {
+                  throw new Exception(""timed out waiting for lock"");
+               }
+               waitTime = Collections.min(Arrays.asList(waitTime, remainingTime));","[{'comment': '`Math.min` will do the same as `Collections.min(Arrays.asList(waitTime, remainingTime));`', 'commenter': 'franz1981'}, {'comment': 'Good point, updated.', 'commenter': 'TomasHofman'}]"
2287,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/FileLockNodeManager.java,"@@ -49,6 +49,8 @@
 
    private static final byte NOT_STARTED = 'N';
 
+   private static final long LOCK_ACCESS_FAILURE_WAIT_TIME = 2000;","[{'comment': ""You are here effectively ignoring the acquire timeout where the user can configure it. I'm not sure this is correct.\r\n\r\nyour test should play with a configured timeout and see if you get the expected behaviour. Adding this you are forcing your own timeout bypassing the configured one."", 'commenter': 'clebertsuconic'}, {'comment': '@clebertsuconic no, the `lockAcquisitionTimeout` is not ignored.\r\n\r\nIf you check the line 337, actual waiting time is either `LOCK_ACCESS_FAILURE_WAIT_TIME` or time remaining until `lockAcquisitionTimeout` runs out, whichever is lower, so acquisition timeout set by user is honored.', 'commenter': 'TomasHofman'}, {'comment': ""I added another test to verify that `lockAcquisitionTimeout` is honored.\r\n\r\nThe only hard waiting time is 500ms on line 313, but that's the original behavior. I can make that honor `lockAcquisitionTimeout` as well if desired."", 'commenter': 'TomasHofman'}]"
2287,tests/extra-tests/src/test/java/org/apache/activemq/artemis/tests/extras/byteman/FileLockNodeManagerTest.java,"@@ -0,0 +1,75 @@
+package org.apache.activemq.artemis.tests.extras.byteman;
+
+import java.io.File;
+import java.io.IOException;
+
+import org.apache.activemq.artemis.core.server.impl.FileLockNodeManager;
+import org.jboss.byteman.contrib.bmunit.BMRule;
+import org.jboss.byteman.contrib.bmunit.BMRules;
+import org.jboss.byteman.contrib.bmunit.BMUnitRunner;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(BMUnitRunner.class)
+public class FileLockNodeManagerTest {
+
+    private static final int TIMEOUT_TOLERANCE = 50;
+
+    private File sharedDir;
+
+    public FileLockNodeManagerTest() throws IOException {
+        sharedDir = File.createTempFile(""shared-dir"", """");
+        sharedDir.delete();
+        Assert.assertTrue(sharedDir.mkdir());
+
+    }
+
+    @Test
+    @BMRules(
+            rules = {@BMRule(
+                    name = ""throw IOException during activation"",
+                    targetClass = ""org.apache.activemq.artemis.core.server.impl.FileLockNodeManager"",
+                    targetMethod = ""tryLock"",
+                    targetLocation = ""AT ENTRY"",
+                    action = ""THROW new IOException(\""IO Error\"");"")
+            })
+    public void test() throws Exception {
+        measureLockAcquisisionTimeout(100); // warm-up
+
+        assertMeasuredTimeoutFor(100);
+        assertMeasuredTimeoutFor(120);
+        assertMeasuredTimeoutFor(200);
+//        assertMeasuredTimeoutFor(1000);","[{'comment': 'commented code, either un-comment or remove.', 'commenter': 'michaelandrepearce'}, {'comment': 'Done.', 'commenter': 'TomasHofman'}]"
2287,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/FileLockNodeManager.java,"@@ -299,44 +301,52 @@ protected FileLock tryLock(final long lockPos) throws IOException {
 
    protected FileLock lock(final long lockPosition) throws Exception {
       long start = System.currentTimeMillis();
+      boolean isRecurringFailure = false;
 
       while (!interrupted) {
-         FileLock lock = tryLock(lockPosition);
-
-         if (lock == null) {
-            try {
-               Thread.sleep(500);
-            } catch (InterruptedException e) {
-               return null;
+         try {
+            FileLock lock = tryLock(lockPosition);
+            isRecurringFailure = false;
+
+            if (lock == null) {
+               try {
+                  Thread.sleep(500);
+               } catch (InterruptedException e) {
+                  return null;
+               }
+
+               if (lockAcquisitionTimeout != -1 && (System.currentTimeMillis() - start) > lockAcquisitionTimeout) {
+                  throw new Exception(""timed out waiting for lock"");","[{'comment': 'Little bit too generic, this exception, should throw something more specific.', 'commenter': 'michaelandrepearce'}]"
2287,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/FileLockNodeManager.java,"@@ -299,44 +301,52 @@ protected FileLock tryLock(final long lockPos) throws IOException {
 
    protected FileLock lock(final long lockPosition) throws Exception {
       long start = System.currentTimeMillis();
+      boolean isRecurringFailure = false;
 
       while (!interrupted) {
-         FileLock lock = tryLock(lockPosition);
-
-         if (lock == null) {
-            try {
-               Thread.sleep(500);
-            } catch (InterruptedException e) {
-               return null;
+         try {
+            FileLock lock = tryLock(lockPosition);
+            isRecurringFailure = false;
+
+            if (lock == null) {
+               try {
+                  Thread.sleep(500);
+               } catch (InterruptedException e) {
+                  return null;
+               }
+
+               if (lockAcquisitionTimeout != -1 && (System.currentTimeMillis() - start) > lockAcquisitionTimeout) {
+                  throw new Exception(""timed out waiting for lock"");
+               }
+            } else {
+               return lock;
             }
-
-            if (lockAcquisitionTimeout != -1 && (System.currentTimeMillis() - start) > lockAcquisitionTimeout) {
-               throw new Exception(""timed out waiting for lock"");
+         } catch (IOException e) {
+            // IOException during trylock() may be a temporary issue, e.g. NFS volume not being accessible
+
+            logger.log(isRecurringFailure ? Logger.Level.DEBUG : Logger.Level.WARN,
+                    ""Failure when accessing a lock file"", e);
+            isRecurringFailure = true;
+
+            long waitTime = LOCK_ACCESS_FAILURE_WAIT_TIME;
+            if (lockAcquisitionTimeout != -1) {
+               final long remainingTime = lockAcquisitionTimeout - (System.currentTimeMillis() - start);
+               if (remainingTime <= 0) {
+                  throw new Exception(""timed out waiting for lock"");","[{'comment': 'Little bit too generic, this exception, should throw something more specific.\r\n\r\n', 'commenter': 'michaelandrepearce'}]"
2295,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ActiveMQServerImpl.java,"@@ -2718,7 +2715,7 @@ private void undeployAddressesAndQueueNotInConfiguration(Configuration configura
             removeAddressInfo(addressName, null);
          } else if (addressSettings.getConfigDeleteQueues() == DeletionPolicy.FORCE) {
             for (Queue queue : listConfiguredQueues(addressName)) {
-               if (!queuesInConfig.contains(queue.getRoutingType().toString() + queue.getName().toString())) {
+               if (!queuesInConfig.contains(CoreQueueConfiguration.getCoreQueueConfiguration(queue).hashCode())) {","[{'comment': 'Hash code is not safe unique. Should use equals against actual object doing comparison. ', 'commenter': 'michaelandrepearce'}]"
2312,artemis-ra/src/main/java/org/apache/activemq/artemis/ra/inflow/ActiveMQActivation.java,"@@ -556,7 +556,7 @@ protected void setupDestination() throws Exception {
                   calculatedDestinationName = spec.getQueuePrefix() + calculatedDestinationName;
                }
 
-               logger.debug(""Unable to retrieve "" + destinationName + "" from JNDI. Creating a new "" + destinationType.getName() + "" named "" + calculatedDestinationName + "" to be used by the MDB."");
+               logger.warn(""Unable to retrieve "" + destinationName + "" from JNDI. Creating a new "" + destinationType.getName() + "" named "" + calculatedDestinationName + "" to be used by the MDB."");","[{'comment': 'As a warn this should use a registered logger with a logger code', 'commenter': 'michaelandrepearce'}]"
2312,artemis-ra/src/main/java/org/apache/activemq/artemis/ra/inflow/ActiveMQActivationSpec.java,"@@ -603,7 +596,11 @@ public void setMaxSession(final Integer value) {
          logger.trace(""setMaxSession("" + value + "")"");
       }
 
-      maxSession = value;
+      if ( value < 1 ) {
+         logger.warn(""Invalid number of session (negative):"" + value + "", defaulting to 1."");","[{'comment': 'this requires a declared  logger in ActiveMQRALogger and logger code', 'commenter': 'michaelandrepearce'}, {'comment': ""Quite sorry about that. I forgot about those. I'll fix it up right away."", 'commenter': 'rpelisse'}]"
2312,artemis-ra/src/main/java/org/apache/activemq/artemis/ra/inflow/ActiveMQActivationValidationUtils.java,"@@ -0,0 +1,80 @@
+package org.apache.activemq.artemis.ra.inflow;","[{'comment': 'RAT failure, requires license headers', 'commenter': 'michaelandrepearce'}, {'comment': ""Same, my bad. I knew I needed to double check the license headers and forgot to do it. I'll update the PR accordingly."", 'commenter': 'rpelisse'}]"
2312,artemis-ra/src/main/java/org/apache/activemq/artemis/ra/inflow/ActiveMQActivationValidationUtils.java,"@@ -0,0 +1,80 @@
+package org.apache.activemq.artemis.ra.inflow;
+
+import java.beans.IntrospectionException;
+import java.beans.PropertyDescriptor;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.jms.Queue;
+import javax.jms.Session;
+import javax.jms.Topic;
+import javax.resource.spi.InvalidPropertyException;
+
+import org.apache.activemq.artemis.ra.ActiveMQRALogger;
+
+/**
+ * A set of validation methods, isolated here to be easily testable.
+ * 
+ * @author rpelisse","[{'comment': 'remove @author tag please', 'commenter': 'michaelandrepearce'}, {'comment': 'Done.', 'commenter': 'rpelisse'}]"
2312,artemis-ra/src/test/java/org/apache/activemq/artemis/ra/inflow/ActiveMQActivationsSpecTest.java,"@@ -0,0 +1,46 @@
+package org.apache.activemq.artemis.ra.inflow;","[{'comment': 'RAT failure, requires license header', 'commenter': 'michaelandrepearce'}]"
2313,artemis-ra/src/main/java/org/apache/activemq/artemis/ra/inflow/ActiveMQActivationSpec.java,"@@ -406,7 +406,9 @@ public void setAcknowledgeMode(final String value) {
       } else if (""AUTO_ACKNOWLEDGE"".equalsIgnoreCase(value) || ""Auto-acknowledge"".equalsIgnoreCase(value)) {
          acknowledgeMode = Session.AUTO_ACKNOWLEDGE;
       } else {
-         throw new IllegalArgumentException(""Unsupported acknowledgement mode "" + value);
+         final String message = ""Unsupported acknowledgement mode "" + value;
+         logger.warn(message);","[{'comment': 'As warn requires a registered logger and logger code', 'commenter': 'michaelandrepearce'}]"
2313,artemis-ra/src/main/java/org/apache/activemq/artemis/ra/inflow/ActiveMQActivationSpec.java,"@@ -603,7 +605,11 @@ public void setMaxSession(final Integer value) {
          logger.trace(""setMaxSession("" + value + "")"");
       }
 
-      maxSession = value;
+      if ( value < 0 ) {
+         logger.warn(""Invalid number of session (negative):"" + value +"", defaulting to 1."");","[{'comment': 'Ditto', 'commenter': 'michaelandrepearce'}]"
2338,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/impl/ClusterConnectionBridge.java,"@@ -350,6 +352,8 @@ private String appendIgnoresToFilter(String filterString) {
       filterString += ""!"" + storeAndForwardPrefix;
       filterString += "",!"" + managementAddress;
       filterString += "",!"" + managementNotificationAddress;
+      //advisory topics shouldn't be clustered
+      filterString += "",!"" + ADVISORY_TOPIC_PREFIX;","[{'comment': 'This is Openwire specific, should avoid pushing protocol specifics into core.\r\n\r\nWhat happens it another protocol needs an address not clustered?\r\n\r\nWould be better to design this in an agnostic way, eg a flag on the address or queue, to not cluster bridge, which the protocol managers can set on creating', 'commenter': 'michaelandrepearce'}, {'comment': 'The best wat I could think is to inject it as a constructor parameter similar to managementNotificationAddress; but advisory topics are just an OpenWire specific feature anyway', 'commenter': 'franz1981'}]"
2338,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireProtocolManager.java,"@@ -154,6 +154,11 @@ public OpenWireProtocolManager(OpenWireProtocolManagerFactory factory, ActiveMQS
       if (cc != null) {
          cc.addClusterTopologyListener(this);
       }
+      if (supportAdvisory) {","[{'comment': ""I wouldn't make it dependent on supportAdvisory.\r\n\r\nSay you have two acceptors.. different IPs.. you will have this called twice.\r\n\r\nI would always add the filter, and check if the filter is not part of the expression before you called it."", 'commenter': 'clebertsuconic'}, {'comment': ""I'm getting a failure with the last changes..."", 'commenter': 'franz1981'}]"
2376,artemis-server/src/main/java/org/apache/activemq/artemis/core/management/impl/view/ConnectionView.java,"@@ -51,10 +51,14 @@ public JsonObjectBuilder toJson(RemotingConnection connection) {
 
       List<ServerSession> sessions = server.getSessions(connection.getID().toString());
       Set<String> users = new HashSet<>();
+      String clientID = null;
 
       for (ServerSession session : sessions) {
          String username = session.getUsername() == null ? """" : session.getUsername();
          users.add(username);
+         if (clientID == null) {
+            clientID = session.getMetaData(""jms-client-id"") == null ? connection.getClientID() : session.getMetaData(""jms-client-id"");","[{'comment': ""should avoid jms specifics such as this. Also it looks like taking data from session, it's possible different sessions could have different values, so would be incorrect to do this, this should be just made visible at a session view level, but in a generic way \r\n\r\n"", 'commenter': 'michaelandrepearce'}]"
2376,artemis-server/src/main/java/org/apache/activemq/artemis/core/management/impl/view/ConnectionView.java,"@@ -91,7 +95,14 @@ public Object getField(RemotingConnection connection, String fieldName) {
          case ""protocol"":
             return connection.getProtocolName();
          case ""clientID"":
-            return connection.getClientID();
+            String clientID = null;
+            for (ServerSession session : sessions) {
+               if (clientID == null) {
+                  clientID = session.getMetaData(""jms-client-id"") == null ? connection.getClientID() : session.getMetaData(""jms-client-id"");","[{'comment': 'jms specifics should not be in core broker. Also this is the connection view, this data is off the session view, so should be visible there, not on the connection. ', 'commenter': 'michaelandrepearce'}]"
2376,artemis-server/src/main/java/org/apache/activemq/artemis/core/management/impl/view/ConsumerView.java,"@@ -82,7 +82,7 @@ public Object getField(ServerConsumer consumer, String fieldName) {
          case ""user"":
             return session.getUsername();
          case ""clientID"":
-            return consumer.getConnectionClientID();
+            return session.getMetaData(""jms-client-id"") == null ? consumer.getConnectionClientID() : session.getMetaData(""jms-client-id"");","[{'comment': 'this should not be needed, if anything the session and consumer models should be re-worked to allow for a client id to be set at session level generically, if you did this then you could make a method in consumer which would return the clientId, where it can delegate to the session to get the client id, where the session can either use its client id if set, or if not delegate to the connection.\r\n\r\ne.g. introduce a method to consumer and session:\r\n\r\nconsumer.getClientId (this would simply call its session.getClientId)\r\n\r\nsession.getClientId (that could return its own if set (if the concept was generically added to the session), and if null, then delegate to remoting connection)', 'commenter': 'michaelandrepearce'}]"
2376,artemis-server/src/main/java/org/apache/activemq/artemis/core/management/impl/view/ProducerView.java,"@@ -79,7 +79,7 @@ public Object getField(ServerProducer producer, String fieldName) {
          case ""user"":
             return session.getUsername();
          case ""clientID"":
-            return session.getRemotingConnection().getClientID();
+            return session.getMetaData(""jms-client-id"") == null ? session.getRemotingConnection().getClientID() : session.getMetaData(""jms-client-id"");","[{'comment': 'this should not be needed, if anything the session and producer models should be re-worked to allow for a client id to be set at session level generically.\r\n\r\nAnd ditto around solution with consumer\r\n\r\n', 'commenter': 'michaelandrepearce'}]"
2384,artemis-server/src/main/java/org/apache/activemq/artemis/core/management/impl/view/ConsumerView.java,"@@ -89,6 +90,8 @@ public Object getField(ServerConsumer consumer, String fieldName) {
             return consumer.getQueueName();
          case ""queueType"":
             return consumer.getQueueType();
+         case ""filter"":
+            return consumer.getFilter() == null ? """" : consumer.getFilter().getFilterString();","[{'comment': 'Rather than the dupe logic here and on line 61, create a method to getFilterString, note youll also need this for the ConsumerFilterPredicate, so might be worth having a static helper method somewhere central like filter itself.\r\n\r\nAlso if null, should return null, not empty string.\r\n         return filter != null ? filter.getFilterString().toString() : null;\r\n\r\ne.g. should be same logic as in QueueControlImpl  \r\n\r\nn.b. if you make a generic method, the code in QueueControlImpl should updated to use the same just to keep code tidy and avoid dupe.\r\n\r\n', 'commenter': 'michaelandrepearce'}]"
2432,artemis-service-extensions/src/main/java/org/apache/activemq/artemis/service/extensions/xa/recovery/XARecoveryConfig.java,"@@ -45,16 +45,41 @@
    private final Map<String, String> properties;
    private final ClientProtocolManagerFactory clientProtocolManager;
 
+   // ServerLocator properties","[{'comment': 'why you had to bring those here?', 'commenter': 'clebertsuconic'}, {'comment': '@spyrkob  ?? ^^^', 'commenter': 'clebertsuconic'}, {'comment': '@clebertsuconic I was trying to make them available in createServerLocator() so that I can apply them to new instances of ServerLocator. Would it be better to hold a reference to original locator/factory instead? Or is there a better way to pass those properties I missed?', 'commenter': 'spyrkob'}, {'comment': '@clebertsuconic does that answer your question?', 'commenter': 'spyrkob'}, {'comment': 'This is really bad duplication, it simply will be a nightmare to keep this in sync as we add more and too brittle. A better solution has to exist, even if it‚Äôs some work to abstract ', 'commenter': 'michaelandrepearce'}]"
2520,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQMessageProducer.java,"@@ -533,6 +496,52 @@ private void doSendx(ActiveMQDestination destination,
       }
    }
 
+   private void checkDestination(ActiveMQDestination destination,
+                                 SimpleString address,
+                                 ClientSession clientSession) throws JMSException {
+      if (!connection.containsKnownDestination(address)) {
+         try {
+            ClientSession.AddressQuery query = clientSession.addressQuery(address);
+
+            if (!query.isExists()) {
+               checkQueue(destination, address, clientSession, query);
+            } else {
+               if (destination.isQueue()) {
+                  ClientSession.QueueQuery queueQuery = clientSession.queueQuery(address);
+                  if (!queueQuery.isExists()) {
+                     checkQueue(destination, address, clientSession, query);
+                  }
+               }
+
+               connection.addKnownDestination(address);
+            }
+         } catch (ActiveMQQueueExistsException e) {
+            // The queue was created by another client/admin between the query check and send create queue packet
+         } catch (ActiveMQException e) {
+            throw JMSExceptionHelper.convertFromActiveMQException(e);
+         }
+      }
+   }
+
+   private void checkQueue(ActiveMQDestination destination,
+                                SimpleString address,
+                                ClientSession clientSession,
+                                ClientSession.AddressQuery query) throws ActiveMQException, InvalidDestinationException {
+      if (destination.isQueue() && query.isAutoCreateQueues()) {","[{'comment': 'should this not also, dare i say check as well: query.isAutoCreateAddresses()', 'commenter': 'michaelandrepearce'}, {'comment': 'e.g. no point calling,          clientSession.createAddress(address, RoutingType.ANYCAST, true); \r\n\r\nif its not allowed....', 'commenter': 'michaelandrepearce'}, {'comment': ""I agree with you. although It wasn't part of my original change.. I was just fixing a bug"", 'commenter': 'clebertsuconic'}, {'comment': 'let me rewrite this', 'commenter': 'clebertsuconic'}, {'comment': '@michaelandrepearce I just wnated to show you an idea... but this is wrong now', 'commenter': 'clebertsuconic'}]"
2520,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQMessageProducer.java,"@@ -533,6 +496,52 @@ private void doSendx(ActiveMQDestination destination,
       }
    }
 
+   private void checkDestination(ActiveMQDestination destination,
+                                 SimpleString address,
+                                 ClientSession clientSession) throws JMSException {
+      if (!connection.containsKnownDestination(address)) {
+         try {
+            ClientSession.AddressQuery query = clientSession.addressQuery(address);
+
+            if (!query.isExists()) {
+               checkQueue(destination, address, clientSession, query);","[{'comment': 'this is missing adding the destination  to known destinations (another bug introduced by the original change)', 'commenter': 'michaelandrepearce'}, {'comment': 'e.g. if we are succesfull, then the address becomes known right?', 'commenter': 'michaelandrepearce'}, {'comment': ""it would always add the end, but I'm rewriting the logic now"", 'commenter': 'clebertsuconic'}]"
2520,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQMessageProducer.java,"@@ -533,6 +496,58 @@ private void doSendx(ActiveMQDestination destination,
       }
    }
 
+   private void checkDestination(ActiveMQDestination destination,
+                                 SimpleString address,
+                                 ClientSession clientSession) throws JMSException {
+
+      // TODO: What to do with FQQN
+      if (!connection.containsKnownDestination(address)) {
+         try {
+            ClientSession.AddressQuery addressQuery = clientSession.addressQuery(address);
+
+            boolean addressExists = addressQuery.isExists();
+            // first we check the address existence, and autoCreate it if allowed in case it does not exists
+
+            if (!addressExists && addressQuery.isAutoCreateAddresses()) {","[{'comment': 'We should only create an address for a JMSQueue if we can create both the Address and Queue, else you could end up creating an address, but not the queue (old code had correct logic here)', 'commenter': 'michaelandrepearce'}, {'comment': ""I don't think it would be an issue.. but I have ammended it...\r\nI will create a test..\r\n\r\n\r\nlet me run tests on it.. please don't merge this."", 'commenter': 'clebertsuconic'}]"
2520,tests/integration-tests/src/test/java/org/apache/activemq/artemis/tests/integration/amqp/QueueAutoCreationTest.java,"@@ -133,6 +133,36 @@ public void testAutoCreateOnTopic() throws Exception {
       Assert.assertTrue(((ActiveMQConnection)connection).containsKnownDestination(addressName));
    }
 
+   @Test //(timeout = 30000)
+   // QueueAutoCreationTest was created to validate auto-creation of queues
+   // and this test was added to validate a regression: https://issues.apache.org/jira/browse/ARTEMIS-2238
+   public void testAutoCreateOnAddressOnly() throws Exception {","[{'comment': 'this is an incomplete test.. I will finish this before merging', 'commenter': 'clebertsuconic'}, {'comment': 'please address my other comments before merging', 'commenter': 'michaelandrepearce'}, {'comment': ""@michaelandrepearce I thought by adding your commit they would be fixed? the only missing point was a test timeout that I'm reverting."", 'commenter': 'clebertsuconic'}, {'comment': 'Indeed they are i wrote this before that.', 'commenter': 'michaelandrepearce'}]"
2520,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQMessageProducer.java,"@@ -533,6 +499,67 @@ private void doSendx(ActiveMQDestination destination,
       }
    }
 
+   private void checkDestination(ActiveMQDestination destination,
+                                 SimpleString address,
+                                 ClientSession clientSession) throws JMSException {
+
+      // TODO: What to do with FQQN
+      if (!connection.containsKnownDestination(address)) {
+         try {
+            ClientSession.AddressQuery addressQuery = clientSession.addressQuery(address);
+
+            boolean addressExists = addressQuery.isExists();
+            // first we check the address existence, and autoCreate it if allowed in case it does not exists
+
+            if (!addressExists && addressQuery.isAutoCreateAddresses()) {
+
+               if (destination.isQueue() && !addressQuery.isAutoCreateQueues()) {
+                  if (logger.isDebugEnabled()) {
+                     logger.debug(""Address "" + address + "" was not created because we would not have permission to create queue"");
+                  }
+                  // if it can't create the internal queue on JMS Queues, why bother creating the address, just mark it false now
+                  addressExists = false;","[{'comment': 'why not simply throw exception here, then on debugging from logs with stack trace it would make it easier. maybe having a cleaner exception message for users, e.g. \r\n\r\n""Queue "" + address + "" does not exist, auto create addresses is enabled, but auto create queues is not.""', 'commenter': 'michaelandrepearce'}, {'comment': 'maybe use generic Destination, instead of Queue, to avoid confusion between JMSQueue and ""core"" Queue.\r\n\r\n""Destination "" + address + "" does not exist, auto create addresses is enabled, but auto create queues is not.""', 'commenter': 'michaelandrepearce'}]"
2520,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQMessageProducer.java,"@@ -533,6 +499,67 @@ private void doSendx(ActiveMQDestination destination,
       }
    }
 
+   private void checkDestination(ActiveMQDestination destination,
+                                 SimpleString address,
+                                 ClientSession clientSession) throws JMSException {
+
+      // TODO: What to do with FQQN
+      if (!connection.containsKnownDestination(address)) {
+         try {
+            ClientSession.AddressQuery addressQuery = clientSession.addressQuery(address);
+
+            boolean addressExists = addressQuery.isExists();
+            // first we check the address existence, and autoCreate it if allowed in case it does not exists
+
+            if (!addressExists && addressQuery.isAutoCreateAddresses()) {
+
+               if (destination.isQueue() && !addressQuery.isAutoCreateQueues()) {
+                  if (logger.isDebugEnabled()) {
+                     logger.debug(""Address "" + address + "" was not created because we would not have permission to create queue"");
+                  }
+                  // if it can't create the internal queue on JMS Queues, why bother creating the address, just mark it false now
+                  addressExists = false;
+               } else {
+                  RoutingType addressType = destination.isQueue() ? RoutingType.ANYCAST : RoutingType.MULTICAST;
+                  clientSession.createAddress(address, addressType, true);
+                  addressExists = true;
+               }
+            }","[{'comment': 'seperate the combined check to nested ifs, addressQuery.isExists() outer if, addressQuery.isAutoCreateAddresses()  inner if with inner if else clause here with throws:\r\n\r\nthen on debugging from logs with stack trace it would make it easier, as would get line where it errored out so could figure out. Also could then allow a better description so end users understand better,  e.g. \r\n\r\ndepending on destination.isQueue()\r\n\r\n""Queue "" + address + "" does not exist, auto create addresses is disabled.""\r\n\r\n""Topic "" + address + "" does not exist, auto create addresses is disabled.""', 'commenter': 'michaelandrepearce'}, {'comment': 'or just simple use generic Destination to describe address as all exceptions were before, with the extra detail.\r\n\r\n""Destination "" + address + "" does not exist, auto create addresses is disabled.""\r\n\r\nalso would avoid confusion between JMSQueue vs ""core"" Queue.\r\n\r\n\r\n\r\n', 'commenter': 'michaelandrepearce'}]"
2520,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQMessageProducer.java,"@@ -533,6 +499,67 @@ private void doSendx(ActiveMQDestination destination,
       }
    }
 
+   private void checkDestination(ActiveMQDestination destination,
+                                 SimpleString address,
+                                 ClientSession clientSession) throws JMSException {
+
+      // TODO: What to do with FQQN
+      if (!connection.containsKnownDestination(address)) {
+         try {
+            ClientSession.AddressQuery addressQuery = clientSession.addressQuery(address);
+
+            boolean addressExists = addressQuery.isExists();
+            // first we check the address existence, and autoCreate it if allowed in case it does not exists
+
+            if (!addressExists && addressQuery.isAutoCreateAddresses()) {
+
+               if (destination.isQueue() && !addressQuery.isAutoCreateQueues()) {
+                  if (logger.isDebugEnabled()) {
+                     logger.debug(""Address "" + address + "" was not created because we would not have permission to create queue"");
+                  }
+                  // if it can't create the internal queue on JMS Queues, why bother creating the address, just mark it false now
+                  addressExists = false;
+               } else {
+                  RoutingType addressType = destination.isQueue() ? RoutingType.ANYCAST : RoutingType.MULTICAST;
+                  clientSession.createAddress(address, addressType, true);
+                  addressExists = true;
+               }
+            }
+
+
+            // Second we create the queue, but we only do it if the address was created
+            if (destination.isQueue() && addressExists) {
+               ClientSession.QueueQuery queueQuery = clientSession.queueQuery(address);
+               if (!queueQuery.isExists()) {
+                  if (addressQuery.isAutoCreateQueues()) {
+                     try {
+                        if (destination.isTemporary()) {
+                           session.createTemporaryQueue(destination, RoutingType.ANYCAST, address, null, addressQuery);
+                        } else {
+                           session.createQueue(destination, RoutingType.ANYCAST, address, null, true, true, addressQuery);
+                        }
+                     } catch (ActiveMQQueueExistsException thatsOK) {
+                        // nothing to be done
+                     }
+                  } else {
+                     throw new InvalidDestinationException(""Queue "" + address + "" does not exist"");","[{'comment': 'make this more descriptive: ""Queue "" + address + "" does not exist, address exists, but auto create queues is disabled.""', 'commenter': 'michaelandrepearce'}, {'comment': 'maybe use generic Destination, instead of Queue, to avoid confusion between JMSQueue and ""core"" Queue.\r\n\r\n""Destination "" + address + "" does not exist, address exists, but auto create queues is disabled.""\r\n\r\n', 'commenter': 'michaelandrepearce'}]"
2520,tests/integration-tests/src/test/java/org/apache/activemq/artemis/tests/integration/amqp/QueueAutoCreationTest.java,"@@ -114,7 +114,7 @@ public void testHugeString() throws Exception {
    }
 
 
-   @Test(timeout = 30000)
+   @Test //(timeout = 30000)","[{'comment': '? is this now broken', 'commenter': 'michaelandrepearce'}, {'comment': 'this is debug.. I will revert it.', 'commenter': 'clebertsuconic'}]"
2520,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQMessageProducer.java,"@@ -533,6 +499,67 @@ private void doSendx(ActiveMQDestination destination,
       }
    }
 
+   private void checkDestination(ActiveMQDestination destination,
+                                 SimpleString address,
+                                 ClientSession clientSession) throws JMSException {
+
+      // TODO: What to do with FQQN
+      if (!connection.containsKnownDestination(address)) {
+         try {
+            ClientSession.AddressQuery addressQuery = clientSession.addressQuery(address);
+
+            boolean addressExists = addressQuery.isExists();
+            // first we check the address existence, and autoCreate it if allowed in case it does not exists
+
+            if (!addressExists && addressQuery.isAutoCreateAddresses()) {
+
+               if (destination.isQueue() && !addressQuery.isAutoCreateQueues()) {
+                  if (logger.isDebugEnabled()) {
+                     logger.debug(""Address "" + address + "" was not created because we would not have permission to create queue"");
+                  }
+                  // if it can't create the internal queue on JMS Queues, why bother creating the address, just mark it false now
+                  addressExists = false;
+               } else {
+                  RoutingType addressType = destination.isQueue() ? RoutingType.ANYCAST : RoutingType.MULTICAST;
+                  clientSession.createAddress(address, addressType, true);
+                  addressExists = true;
+               }
+            }
+
+
+            // Second we create the queue, but we only do it if the address was created
+            if (destination.isQueue() && addressExists) {
+               ClientSession.QueueQuery queueQuery = clientSession.queueQuery(address);
+               if (!queueQuery.isExists()) {
+                  if (addressQuery.isAutoCreateQueues()) {
+                     try {
+                        if (destination.isTemporary()) {
+                           session.createTemporaryQueue(destination, RoutingType.ANYCAST, address, null, addressQuery);
+                        } else {
+                           session.createQueue(destination, RoutingType.ANYCAST, address, null, true, true, addressQuery);
+                        }
+                     } catch (ActiveMQQueueExistsException thatsOK) {
+                        // nothing to be done
+                     }
+                  } else {
+                     throw new InvalidDestinationException(""Queue "" + address + "" does not exist"");
+                  }
+               }
+            }
+
+            if (!addressExists) {","[{'comment': 'lets keep that exceptions are thrown from explicit points where checks are done and fail, so can be more explicit and also we can debug where the check fail occured by stack trace lines.\r\n\r\n', 'commenter': 'michaelandrepearce'}]"
2520,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQSession.java,"@@ -397,6 +380,55 @@ public MessageProducer createProducer(final Destination destination) throws JMSE
       }
    }
 
+   void checkDestination(ActiveMQDestination destination) throws JMSException {","[{'comment': ""make it final to avoid overriding it (it shouldn't happen eh)"", 'commenter': 'franz1981'}, {'comment': 'TBH I hate final methods...\r\n\r\nI have needed quite a few times to override them on test cases... so I only reserve the word final where there is a strong ""business"" case to not let it be overwritten.  but that\'s jut my opinion.', 'commenter': 'clebertsuconic'}, {'comment': '+1 same here not the biggest fan of them either, i remember having on another project starting with the name K ;), such issue, and getting people to agree to make it non final was a nightmare.', 'commenter': 'michaelandrepearce'}]"
2520,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQSession.java,"@@ -397,6 +380,55 @@ public MessageProducer createProducer(final Destination destination) throws JMSE
       }
    }
 
+   void checkDestination(ActiveMQDestination destination) throws JMSException {
+      SimpleString address = destination.getSimpleAddress();
+      // TODO: What to do with FQQN
+      if (!connection.containsKnownDestination(address)) {
+         try {","[{'comment': 'i will pack this slow path in a separate method to make the code more readable (perf are helped as well, but is not relevant)!', 'commenter': 'franz1981'}]"
2520,artemis-jms-client/src/main/java/org/apache/activemq/artemis/jms/client/ActiveMQMessageProducer.java,"@@ -393,57 +395,18 @@ private void doSendx(ActiveMQDestination destination,
          if (defaultDestination == null) {
             throw new UnsupportedOperationException(""Destination must be specified on send with an anonymous producer"");
          }
-
          destination = defaultDestination;
-      } else {
-         if (defaultDestination != null) {
-            if (!destination.equals(defaultDestination)) {
-               throw new UnsupportedOperationException(""Where a default destination is specified "" + ""for the sender and a destination is "" + ""specified in the arguments to the send, "" + ""these destinations must be equal"");
-            }
+      } else if (defaultDestination != null) {
+         if (!destination.equals(defaultDestination)) {
+            throw new UnsupportedOperationException(""Where a default destination is specified "" + ""for the sender and a destination is "" + ""specified in the arguments to the send, "" + ""these destinations must be equal"");
          }
+      } else {
+         session.checkDestination(destination);
 
          address = destination.getSimpleAddress();","[{'comment': 'I just spotted i think this should be outside the if else block otherwise address will be null for default', 'commenter': 'michaelandrepearce'}, {'comment': ""Those lines are the reason why I wanted to run a full testsuite before merging this.\r\n\r\nAnd I think you're right...\r\n\r\n\r\n\r\nI'm adding a commit to be squashed into yours. I will squash it before merging it, but if you could review it please"", 'commenter': 'clebertsuconic'}, {'comment': ""back on a proper pc,\r\n\r\ni was meaning only:\r\n         address = destination.getSimpleAddress();\r\n \r\nif defaultdestination != null, then don't need to do session.checkDestination(destination), as we checked the destination already when we created the message producer\r\n\r\n\r\ndoesn't matter too much as connection.containsKnownDestination(address) should return true anyhow, meaning it avoids the expensive bit. \r\n\r\n**Im still happy with PR to merge, just a comment**\r\n"", 'commenter': 'michaelandrepearce'}]"
2528,artemis-server/src/main/java/org/apache/activemq/artemis/core/postoffice/impl/PostOfficeImpl.java,"@@ -343,6 +347,18 @@ public void onNotification(final Notification notification) {
                   if (binding != null) {
                      // We have a local queue
                      Queue queue = (Queue) binding.getBindable();
+                     //If the client ID represents a client already connected to the server then the server MUST disconnect the existing client.
+                     //Avoid consumers with the same client ID in the cluster appearing at different nodes at the same time
+                     SimpleString protocolName = props.getSimpleStringProperty(ManagementHelper.HDR_PROTOCOL_Name);","[{'comment': ""I'm not that familiar with the MQTT protocol, but I can give you an idea: instead of using a SimpleString property, that is costly to be compared/transferred/encoded/decoded why not define a single byte (or short to be more future-proof) property? \r\nIt would be less human-readable, but more cheaper for a machine: in addition, a Short/Byte tends to be pooled on the ranges of -127<->128 AFAIK or something similar, so only the property name + HashMap entry will produce some garbage."", 'commenter': 'franz1981'}, {'comment': 'Thanks, very nice advice. i will done', 'commenter': 'onlyMIT'}]"
2528,artemis-server/src/main/java/org/apache/activemq/artemis/core/postoffice/impl/PostOfficeImpl.java,"@@ -343,6 +347,18 @@ public void onNotification(final Notification notification) {
                   if (binding != null) {
                      // We have a local queue
                      Queue queue = (Queue) binding.getBindable();
+                     //If the client ID represents a client already connected to the server then the server MUST disconnect the existing client.
+                     //Avoid consumers with the same client ID in the cluster appearing at different nodes at the same time
+                     SimpleString protocolName = props.getSimpleStringProperty(ManagementHelper.HDR_PROTOCOL_Name);
+                     if (protocolName != null && protocolName.equals(ProtocolName.MQTT_PROTOCOL_NAME.getProtocolName())) {
+                        String clientId = props.getSimpleStringProperty(ManagementHelper.HDR_CLIENT_ID).toString();","[{'comment': 'This is protocol specific logic. It is not suitable to have this in the core modules.Any mqtt logic MUST be in the protocol module only.', 'commenter': 'michaelandrepearce'}]"
2528,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java,"@@ -540,6 +541,12 @@ public ServerConsumer createConsumer(final long consumerID,
             props.putSimpleStringProperty(ManagementHelper.HDR_FILTERSTRING, filterString);
          }
 
+         String protocolName = remotingConnection.getProtocolName();
+         if (protocolName != null && protocolName.equals(ProtocolName.MQTT_PROTOCOL_NAME.getProtocolName().toString())) {","[{'comment': 'This is protocol specific logic. This MUST not ever live in core modules. Protocol specific logic can ONLY reside in its protocol module', 'commenter': 'michaelandrepearce'}]"
2528,artemis-core-client/src/main/java/org/apache/activemq/artemis/api/core/management/ManagementHelper.java,"@@ -84,6 +84,10 @@
 
    public static final SimpleString HDR_MESSAGE_ID = new SimpleString(""_AMQ_Message_ID"");
 
+   public static final SimpleString HDR_PROTOCOL_Name = new SimpleString(""_AMQ_ProtocolName"");","[{'comment': ""static final field should be all upper case. HDR_PROTOCOL_NAME\r\nkey should be '_' separated _AMQ_Protocol_Name\r\n"", 'commenter': 'michaelandrepearce'}]"
2528,artemis-server/src/main/java/org/apache/activemq/artemis/core/protocol/ProtocolName.java,"@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.core.protocol;
+
+import org.apache.activemq.artemis.api.core.SimpleString;
+
+public enum ProtocolName {
+
+   MQTT_PROTOCOL_NAME(SimpleString.toSimpleString(""MQTT"")),","[{'comment': '-1, Core should not know about specific protocols. ', 'commenter': 'michaelandrepearce'}, {'comment': 'Got it thanks.  Since the processing of cluster-notification is in the Core, and the Core does not depend on the specific protocol code. I will think about how to adjust the code structure and then submit a version. Maybe need a listener or a callback', 'commenter': 'onlyMIT'}]"
2528,artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTProtocolManager.java,"@@ -62,11 +73,44 @@
                        List<BaseInterceptor> outgoingInterceptors) {
       this.server = server;
       this.updateInterceptors(incomingInterceptors, outgoingInterceptors);
+      server.getManagementService().addNotificationListener(this);
    }
 
    @Override
    public void onNotification(Notification notification) {
-      // TODO handle notifications
+      if (!(notification.getType() instanceof CoreNotificationType))
+         return;
+
+      CoreNotificationType type = (CoreNotificationType) notification.getType();
+      if (type != CONSUMER_CREATED)
+         return;
+
+      TypedProperties props = notification.getProperties();
+
+      SimpleString protocolName = props.getSimpleStringProperty(ManagementHelper.HDR_PROTOCOL_NAME);
+
+      if (protocolName == null || !protocolName.toString().equals(MQTTProtocolManagerFactory.MQTT_PROTOCOL_NAME))
+         return;
+
+      int distance = props.getIntProperty(ManagementHelper.HDR_DISTANCE);
+
+      if (distance > 0) {
+         SimpleString queueName = props.getSimpleStringProperty(ManagementHelper.HDR_ROUTING_NAME);
+
+         Binding binding = server.getPostOffice().getBinding(queueName);
+         if (binding != null) {
+            Queue queue = (Queue) binding.getBindable();
+            String clientId = props.getSimpleStringProperty(ManagementHelper.HDR_CLIENT_ID).toString();
+            //If the client ID represents a client already connected to the server then the server MUST disconnect the existing client.
+            //Avoid consumers with the same client ID in the cluster appearing at different nodes at the same time
+            Collection<Consumer> consumersSet = queue.getConsumers();
+            for (Consumer consumer : consumersSet) {
+               ServerConsumerImpl serverConsumer = (ServerConsumerImpl) consumer;","[{'comment': 'Cast to interface ServerConsumer, not concrete class.', 'commenter': 'michaelandrepearce'}, {'comment': ""Also should check instanceof, as by contract, it may not be a ServerConsumer, e.g. it could be a bridge, we know it shouldn't in most logical use cases, but a check just to protect, theres always some interesting setups out there..."", 'commenter': 'michaelandrepearce'}, {'comment': 'I also disagree with putting this method into the `ServerConsumer` interface. Using instanceof is a good suggestion.', 'commenter': 'onlyMIT'}, {'comment': 'what method? if youre talking re remoting connection that shouldnt be needed, as you simply want to close previous consumers, you therefor should be calling close method on the serverconsumer, which is in interface', 'commenter': 'michaelandrepearce'}, {'comment': 'I answered in another comment, I still think that closing the connection is a better choice.', 'commenter': 'onlyMIT'}]"
2528,artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTProtocolManager.java,"@@ -62,11 +73,44 @@
                        List<BaseInterceptor> outgoingInterceptors) {
       this.server = server;
       this.updateInterceptors(incomingInterceptors, outgoingInterceptors);
+      server.getManagementService().addNotificationListener(this);
    }
 
    @Override
    public void onNotification(Notification notification) {
-      // TODO handle notifications
+      if (!(notification.getType() instanceof CoreNotificationType))
+         return;
+
+      CoreNotificationType type = (CoreNotificationType) notification.getType();
+      if (type != CONSUMER_CREATED)
+         return;
+
+      TypedProperties props = notification.getProperties();
+
+      SimpleString protocolName = props.getSimpleStringProperty(ManagementHelper.HDR_PROTOCOL_NAME);
+
+      if (protocolName == null || !protocolName.toString().equals(MQTTProtocolManagerFactory.MQTT_PROTOCOL_NAME))
+         return;
+
+      int distance = props.getIntProperty(ManagementHelper.HDR_DISTANCE);
+
+      if (distance > 0) {
+         SimpleString queueName = props.getSimpleStringProperty(ManagementHelper.HDR_ROUTING_NAME);
+
+         Binding binding = server.getPostOffice().getBinding(queueName);
+         if (binding != null) {
+            Queue queue = (Queue) binding.getBindable();
+            String clientId = props.getSimpleStringProperty(ManagementHelper.HDR_CLIENT_ID).toString();
+            //If the client ID represents a client already connected to the server then the server MUST disconnect the existing client.
+            //Avoid consumers with the same client ID in the cluster appearing at different nodes at the same time
+            Collection<Consumer> consumersSet = queue.getConsumers();
+            for (Consumer consumer : consumersSet) {
+               ServerConsumerImpl serverConsumer = (ServerConsumerImpl) consumer;
+               if (clientId.equals(serverConsumer.getConnectionClientID()))
+                  serverConsumer.getRemotingConnection().destroy();","[{'comment': ""The new getRemotingConnection isn't needed.\r\nAs you are simply wanting to ensure a old consumers are closed, you should simply be closing the consumer, not destroying the connection beneath it. Closing the consumer, will also mean all bits around closing a consumer are safely done (e.g. transaction safely rolledback), and also other notifications sent, broker plugins invoked, removing itself from the queue, etc etc"", 'commenter': 'michaelandrepearce'}, {'comment': 'Our goal is to avoid simultaneous occurrence of multiple MQTT connections with the same clientId, not to prevent MQTT consumers with the same clientId to subscribe the same topic.\r\n\r\ndescribed in the [two solutions](https://github.com/apache/activemq-artemis/pull/2528#issue-248449219) .  Adding a new cluster notification when the client‚Äôs connections connect to Artemis,\r\nit is the best way to address the MQTT agreement, but the cost is too great. So it put the logic in CREATE_CONSUMER cluster-notification.\r\n\r\nThe following code description, before each processing of the mqtt connection request in artemis, check whether there is a connection with the same clientId in the node, and if so, close it.\r\nSimilarly, in the cluster, we also want to avoid the connection of the same clientId. Executing this logic only in CREATE_CONSUMER is just that I think it can reduce resource consumption and avoid problems, although this is not the best way to address the MQTT specification.\r\n```\r\nprivate String validateClientId(String clientId, boolean cleanSession) {\r\n      if (clientId == null || clientId.isEmpty()) {\r\n         // [MQTT-3.1.3-7] [MQTT-3.1.3-6] If client does not specify a client ID and clean session is set to 1 create it.\r\n         if (cleanSession) {\r\n            clientId = UUID.randomUUID().toString();\r\n         } else {\r\n            // [MQTT-3.1.3-8] Return ID rejected and disconnect if clean session = false and client id is null\r\n            return null;\r\n         }\r\n      } else {\r\n         MQTTConnection connection = session.getProtocolManager().addConnectedClient(clientId, session.getConnection());\r\n\r\n         if (connection != null) {\r\n            // [MQTT-3.1.4-2] If the client ID represents a client already connected to the server then the server MUST disconnect the existing client\r\n            connection.disconnect(false);\r\n         }\r\n      }\r\n      return clientId;\r\n   }\r\n```\r\n', 'commenter': 'onlyMIT'}, {'comment': 'But your current logic in this PR is simply find all consumers with matching clientId and kill beneath it, their connection. You may as well simply close down the consumer', 'commenter': 'michaelandrepearce'}, {'comment': 'Why is:\r\n\r\nAdding a new cluster notification when the client‚Äôs connections connect to Artemis,\r\nit is the best way to address the MQTT agreement, but the cost is too great\r\n\r\nWhats the cost? To me if you want the behaviour on connection behaviour this truely would be better, rather than working on consumer ', 'commenter': 'michaelandrepearce'}, {'comment': 'we already have a connection notification, just need to add the generic extra data as you were going to on the consumer\r\n\r\n\r\n```\r\n   private void sendConnectionNotification(final RemotingConnection connection, final CoreNotificationType type) {\r\n      final ManagementService managementService = getManagementService();\r\n\r\n      if (managementService != null && sendConnectionNotifications) {\r\n         try {\r\n            final TypedProperties props = new TypedProperties();\r\n            props.putSimpleStringProperty(ManagementHelper.HDR_CONNECTION_NAME, SimpleString.toSimpleString(connection.getID().toString()));\r\n            props.putSimpleStringProperty(ManagementHelper.HDR_REMOTE_ADDRESS, SimpleString.toSimpleString(connection.getRemoteAddress()));\r\n            props.putSimpleStringProperty(ManagementHelper.HDR_CLIENT_ID, SimpleString.toSimpleString(connection.getClientID()));\r\n            props.putSimpleStringProperty(ManagementHelper.HDR_PROTOCOL_NAME, SimpleString.toSimpleString(connection.getProtocolName()));\r\n\r\n            managementService.sendNotification(new Notification(null, type, props));\r\n         } catch (Exception e) {\r\n            logger.warn(""Error sending notification: "" + type, e.getMessage(), e);\r\n         }\r\n      }\r\n   }\r\n```\r\n\r\nand then act just at the connection level.\r\n\r\nMQTTProtocolManager already is keeping track of MQTT connections also.', 'commenter': 'michaelandrepearce'}, {'comment': 'This code seems to be easily misunderstood, I am trying to find out if there is a better way to handle this logic.', 'commenter': 'onlyMIT'}, {'comment': 'Thanks for your answerÔºåi not find the connection notificationÔºåif we had we can use it.', 'commenter': 'onlyMIT'}]"
2528,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerConsumerImpl.java,"@@ -1544,4 +1545,8 @@ public String getConnectionLocalAddress() {
    public String getConnectionRemoteAddress() {
       return this.session.getRemotingConnection().getTransportConnection().getRemoteAddress();
    }
+
+   public RemotingConnection getRemotingConnection() {","[{'comment': 'Shouldnt be needed, you should just be acting on the consumer, closing the consumer via its close methods if needed.', 'commenter': 'michaelandrepearce'}]"
2528,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java,"@@ -540,6 +540,14 @@ public ServerConsumer createConsumer(final long consumerID,
             props.putSimpleStringProperty(ManagementHelper.HDR_FILTERSTRING, filterString);
          }
 
+         String protocolName = remotingConnection.getProtocolName();
+         if (protocolName != null)
+            props.putSimpleStringProperty(ManagementHelper.HDR_PROTOCOL_NAME, SimpleString.toSimpleString(protocolName));
+
+         String clientId = remotingConnection.getClientID();
+         if (clientId != null)","[{'comment': 'curlys on the if please', 'commenter': 'michaelandrepearce'}]"
2528,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java,"@@ -540,6 +540,14 @@ public ServerConsumer createConsumer(final long consumerID,
             props.putSimpleStringProperty(ManagementHelper.HDR_FILTERSTRING, filterString);
          }
 
+         String protocolName = remotingConnection.getProtocolName();
+         if (protocolName != null)","[{'comment': 'curlys on the if please', 'commenter': 'michaelandrepearce'}]"
2528,artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTProtocolManager.java,"@@ -62,11 +73,44 @@
                        List<BaseInterceptor> outgoingInterceptors) {
       this.server = server;
       this.updateInterceptors(incomingInterceptors, outgoingInterceptors);
+      server.getManagementService().addNotificationListener(this);
    }
 
    @Override
    public void onNotification(Notification notification) {
-      // TODO handle notifications
+      if (!(notification.getType() instanceof CoreNotificationType))
+         return;
+
+      CoreNotificationType type = (CoreNotificationType) notification.getType();
+      if (type != CONSUMER_CREATED)
+         return;
+
+      TypedProperties props = notification.getProperties();
+
+      SimpleString protocolName = props.getSimpleStringProperty(ManagementHelper.HDR_PROTOCOL_NAME);
+
+      if (protocolName == null || !protocolName.toString().equals(MQTTProtocolManagerFactory.MQTT_PROTOCOL_NAME))
+         return;
+
+      int distance = props.getIntProperty(ManagementHelper.HDR_DISTANCE);
+
+      if (distance > 0) {
+         SimpleString queueName = props.getSimpleStringProperty(ManagementHelper.HDR_ROUTING_NAME);
+
+         Binding binding = server.getPostOffice().getBinding(queueName);
+         if (binding != null) {
+            Queue queue = (Queue) binding.getBindable();
+            String clientId = props.getSimpleStringProperty(ManagementHelper.HDR_CLIENT_ID).toString();
+            //If the client ID represents a client already connected to the server then the server MUST disconnect the existing client.
+            //Avoid consumers with the same client ID in the cluster appearing at different nodes at the same time
+            Collection<Consumer> consumersSet = queue.getConsumers();","[{'comment': 'Will be worth adding a new method on queue that takes an additional predicate parameter, this way can pass in a predicate of \r\nclientId.equals(serverConsumer.getConnectionClientID()\r\nand return only the consumers matching, this will avoid expensive copying of all consumers if the queue has high consumer count, and repetitive iterating over those not matching.\r\n\r\n', 'commenter': 'michaelandrepearce'}, {'comment': 'e.g. adding something like into QueueImpl (and adding method to interface)\r\n\r\n```\r\n   @Override\r\n   public Set<Consumer> getConsumers(Predicate<Consumer> consumerPredicate) {\r\n      Set<Consumer> consumersSet = new HashSet<>();\r\n      for (ConsumerHolder<? extends Consumer> consumerHolder : consumers) {\r\n         if (consumerPredicate.test(consumerHolder.consumer)) {\r\n            consumersSet.add(consumerHolder.consumer);\r\n         }\r\n      }\r\n      return consumersSet;\r\n   }\r\n```', 'commenter': 'michaelandrepearce'}, {'comment': 'got it', 'commenter': 'onlyMIT'}, {'comment': 'i sent this in pr to your branch', 'commenter': 'michaelandrepearce'}]"
2528,artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTSession.java,"@@ -30,10 +30,12 @@
 
 public class MQTTSession {
 
-   static Map<String, MQTTSessionState> SESSIONS = new ConcurrentHashMap<>();
+   private static Map<String, MQTTSessionState> SESSIONS = new ConcurrentHashMap<>();","[{'comment': 'Looking at this im bit worried that this is a static in first place, e.g. its possible to have multiple embedded brokers, in that case each broker shouldnt share any state, by being static means they would.\r\n\r\nreally should be held as a non static at some common level above where would just be one per acceptor such as MQTTProtocolHandler', 'commenter': 'michaelandrepearce'}, {'comment': 'You are right, it does not seem to fit properly in the MQTTSession', 'commenter': 'onlyMIT'}, {'comment': 'i sent a possible solution to address this, in a pr to your branch.', 'commenter': 'michaelandrepearce'}]"
2528,artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTSession.java,"@@ -204,4 +208,35 @@ public CoreMessageObjectPools getCoreMessageObjectPools() {
    public static Map<String, MQTTSessionState> getSessions() {
       return new HashMap<>(SESSIONS);
    }
+
+   public MQTTSessionState getSessionStateFromSessionMap(String clientId) {
+      return SESSIONS.get(generateSessionStateKey(clientId));
+   }
+
+   public void putSessionStateIntoSessionMap(String clientId, MQTTSessionState state) {
+      SESSIONS.put(generateSessionStateKey(clientId), state);
+   }
+
+   public void removeSessionStateFromSessionMap(String clientId) {
+      SESSIONS.remove(generateSessionStateKey(clientId));
+   }
+
+   /**
+    * When performing cluster testing, different nodes of the cluster are actually started in the same JVM process,","[{'comment': 'This is because we have state in a static, that is really bad, and simply needs to be addressed, see other comment.', 'commenter': 'michaelandrepearce'}]"
2579,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java,"@@ -1516,6 +1541,9 @@ public synchronized RoutingStatus send(Transaction tx,
                                           final boolean direct,
                                           boolean noAutoCreateQueue,
                                           RoutingContext routingContext) throws Exception {
+      if (AuditLogger.isEnabled()) {
+         AuditLogger.sendMessage(this, getUsername(), tx, messageParameter, direct, noAutoCreateQueue, routingContext);","[{'comment': ""Shouldn't this be done on PostOfficeImpl::send?\r\n\r\nThen the same would apply to all the protocols.\r\n\r\n\r\nCurrently your implementation would ignore anything coming from Federation, MQTT AMQP or Stomp, since those will call PostOfficeImpl::send directly."", 'commenter': 'clebertsuconic'}, {'comment': 'If there is audit on this. I think there needs to be some audit level seperation. E.g. users may want to audit management actions but not want to audit log every message going through the broker this would be very expensive on the hot path', 'commenter': 'michaelandrepearce'}, {'comment': 'I am -1 it for this reason to avoid this just being merged without this being addressed.', 'commenter': 'michaelandrepearce'}, {'comment': 'Just to add i like the idea, just think there needs to be finer control on what to audit especially hot paths like send message and other bits.\r\n\r\nAlso is this a chance to extend the plugin interfaces and implement this as a plugin. I actually thought we had some logger plugin thinking about it', 'commenter': 'michaelandrepearce'}, {'comment': 'Please see:  org.apache.activemq.artemis.core.server.plugin.impl.LoggingActiveMQServerPlugin\r\n\r\nIt be good to extend this (also it has the finer control already started), rather than another implementation to avoid competing solutions to the same problems and maintenance in two places.', 'commenter': 'michaelandrepearce'}, {'comment': ""> Shouldn't this be done on PostOfficeImpl::send?\r\n> \r\n> Then the same would apply to all the protocols.\r\n> \r\n> Currently your implementation would ignore anything coming from Federation, MQTT AMQP or Stomp, since those will call PostOfficeImpl::send directly.\r\n\r\nThe send() is auditing the message coming into the broker. So I think it can cover other protocols. right? (currently the audit doesn't record the messages going out but it logs the consumer creations)."", 'commenter': 'gaohoward'}, {'comment': ""Hi @michaelandrepearce Just had a look at the plugin class my impression is it's a big too complicated for audit log. But let me think about it more. Also I agree the idea to fine control the logging on 'hot' paths so to give user a choice to turn off them particularly.\r\nThanks\r\n"", 'commenter': 'gaohoward'}, {'comment': 'Whats complicated about it? You define plugin in broker xml and voila... \r\n\r\nThe point being this is exactly the use case for plugins', 'commenter': 'michaelandrepearce'}, {'comment': ""the log format is different. and the logging plugin serves a different purpose that auditing. (actually in amq5 they are totally different impls). and it brings in extra config.\r\nfor hot path (actually so far there is only one sending message) I can use log level to easily control it.\r\nSo I'd for the moment don't touch the logging plugin. \r\nwdyt?"", 'commenter': 'gaohoward'}]"
2666,artemis-server/src/main/java/org/apache/activemq/artemis/core/protocol/core/impl/wireformat/ReplicationSyncFileMessage.java,"@@ -197,6 +232,15 @@ public void decodeRest(final ActiveMQBuffer buffer) {
       }
    }
 
+   private void readFile(ByteBuffer buffer) {","[{'comment': 'You can create directly the FileChannel without using FileInputStream ', 'commenter': 'franz1981'}, {'comment': 'Could you elaborate this? I thought FileChannel can only be created by FileInputStream/FileOutputStream/RandomAccessFile.', 'commenter': 'wy96f'}, {'comment': 'FileChannel::open could be used to avoid FileInputStream to be created', 'commenter': 'franz1981'}]"
2666,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnection.java,"@@ -345,21 +351,41 @@ private boolean canWrite(final int requiredCapacity) {
       return canWrite;
    }
 
+   private Object getFileObject(FileDelegatedChannelBufferWrapper fileBuffer) {
+      if (channel.pipeline().get(SslHandler.class) == null) {
+         return new DefaultFileRegion(fileBuffer.getFile(), fileBuffer.getOffset(), fileBuffer.getDataSize());
+      } else {
+         try {
+            RandomAccessFile raf = new RandomAccessFile(fileBuffer.getFile(), ""r"");
+            return new ChunkedFile(raf, fileBuffer.getOffset(), fileBuffer.getDataSize(), 8192);
+         } catch (IOException e) {
+            throw new RuntimeException(e);
+         }
+      }
+   }
+
    @Override
    public final void write(ActiveMQBuffer buffer,
                            final boolean flush,
                            final boolean batched,
                            final ChannelFutureListener futureListener) {
-      final int readableBytes = buffer.readableBytes();
+      //no need to lock because the Netty's channel is thread-safe
+      //and the order of write is ensured by the order of the write calls
+      final Channel channel = this.channel;
+
+      int readableBytes = buffer.readableBytes();
+      Object fileObject = null;
+      if (buffer instanceof FileDelegatedChannelBufferWrapper) {
+         readableBytes += ((FileDelegatedChannelBufferWrapper)buffer).getDataSize();
+         fileObject = getFileObject((FileDelegatedChannelBufferWrapper)buffer);","[{'comment': 'on each NettyConnection::write it is supposed to open a different RandomAccessFile (with SSL)  or a new FileChannel?\r\nIt will happen just once for each File or several times?', 'commenter': 'franz1981'}, {'comment': ""Good point. I'll work on it:)"", 'commenter': 'wy96f'}, {'comment': 'I would rather create a new method to be called from ReplicationManager.sendLargeFile instead of adding an instanceof here.\r\n\r\nThat is the caller should decide the semantic here, and a proper method to be created.\r\n\r\nI would really try to avoid breaking encapsulation here. Not much for a nit-pick, but because this is hot code, meaning everything goes through here. I would rather create a new method for the optimization than to make everything else go through this for an exceptional case.\r\n\r\n\r\n\r\na question I have is: Was this really an issue for you during a production env? this was using a PooledBuffer, and it was only happening during catch up or large message transfer.', 'commenter': 'clebertsuconic'}]"
2666,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnection.java,"@@ -395,19 +425,18 @@ private static void flushAndWait(final Channel channel, final ChannelPromise pro
       }
    }
 
-   private ChannelFuture writeBatch(final ByteBuf bytes, final int readableBytes, final ChannelPromise promise) {
+   private ChannelFuture writeBatch(final ByteBuf bytes, Object fileObject, final int readableBytes, final ChannelPromise promise) {
       final int batchBufferSize = batchBufferSize(channel, this.writeBufferHighWaterMark);
       final int nextBatchSize = batchBufferSize + readableBytes;
       if (nextBatchSize > batchLimit) {
          //request to flush before writing, to create the chance to make the channel writable again
          channel.flush();
-         //let netty use its write batching ability
-         return channel.write(bytes, promise);
-      } else if (nextBatchSize == batchLimit) {
-         return channel.writeAndFlush(bytes, promise);
+      }
+      if (fileObject == null) {
+         return nextBatchSize == batchLimit ? channel.writeAndFlush(bytes, promise) : channel.write(bytes, promise);
       } else {
-         //let netty use its write batching ability
-         return channel.write(bytes, promise);
+         channel.write(bytes);","[{'comment': 'The ChannelFuture of this write is lost here', 'commenter': 'franz1981'}, {'comment': 'Emm, i think we just need ChannelFuture of the last write(i.e. the file transfer here)?', 'commenter': 'wy96f'}, {'comment': 'No idea, depends..if the first one will fail and the second one succeed is not good...Take a look if is possible to create a composed future or (even better)  a single object that encapsulate both the things we want to write in sequence as a whole', 'commenter': 'franz1981'}]"
2666,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnection.java,"@@ -395,19 +425,18 @@ private static void flushAndWait(final Channel channel, final ChannelPromise pro
       }
    }
 
-   private ChannelFuture writeBatch(final ByteBuf bytes, final int readableBytes, final ChannelPromise promise) {
+   private ChannelFuture writeBatch(final ByteBuf bytes, Object fileObject, final int readableBytes, final ChannelPromise promise) {
       final int batchBufferSize = batchBufferSize(channel, this.writeBufferHighWaterMark);
       final int nextBatchSize = batchBufferSize + readableBytes;
       if (nextBatchSize > batchLimit) {
          //request to flush before writing, to create the chance to make the channel writable again
          channel.flush();
-         //let netty use its write batching ability
-         return channel.write(bytes, promise);
-      } else if (nextBatchSize == batchLimit) {
-         return channel.writeAndFlush(bytes, promise);
+      }
+      if (fileObject == null) {
+         return nextBatchSize == batchLimit ? channel.writeAndFlush(bytes, promise) : channel.write(bytes, promise);
       } else {
-         //let netty use its write batching ability
-         return channel.write(bytes, promise);
+         channel.write(bytes);
+         return nextBatchSize == batchLimit ? channel.writeAndFlush(fileObject, promise) : channel.write(fileObject, promise);","[{'comment': 'Try to check if it makes sense to batch writes if we are using ChunkedFile/DefaultFileRegion', 'commenter': 'franz1981'}]"
2666,artemis-server/src/main/java/org/apache/activemq/artemis/core/protocol/core/impl/wireformat/ReplicationSyncFileMessage.java,"@@ -150,30 +161,54 @@ public void encodeRest(final ActiveMQBuffer buffer) {
          default:
             // no-op
       }
-
       buffer.writeInt(dataSize);
-      /*
-       * sending -1 will close the file in case of a journal, but not in case of a largeMessage
-       * (which might receive appends)
-       */
-      if (dataSize > 0) {
-         buffer.writeBytes(byteBuffer, 0, byteBuffer.writerIndex());
-      }
 
       release();
    }
 
    @Override
-   public void release() {
-      if (byteBuffer != null) {
-         byteBuffer.release();
-         byteBuffer = null;
+   public ActiveMQBuffer encode(CoreRemotingConnection connection) {
+      if (connection != null && connection.getTransportConnection() instanceof NettyConnection) {
+         ActiveMQBuffer buffer;
+         int bufferSize = expectedEncodeSize();
+         if (fileId != -1 && dataSize > 0) {
+            bufferSize -= dataSize;
+         }
+         buffer = createPacket(connection, bufferSize);
+
+         encodeHeader(buffer);
+
+         encodeRest(buffer, connection);
+
+         encodeSize(buffer, expectedEncodeSize());
+
+         return fileId != -1 && dataSize > 0 ? new FileDelegatedChannelBufferWrapper(file, offset, dataSize, buffer) : buffer;","[{'comment': ""It implies that the file is being read lazily by Netty to apply the zero-copy transfert, but it means also that we need to be sure that the file won't be moved or deleted util the zero-copy transfert will finish"", 'commenter': 'franz1981'}, {'comment': ""The file is opened before sending and closed after finished. Transfer won't be affected if the file is removed or deleted bcs it's referenced? "", 'commenter': 'wy96f'}, {'comment': ""When we ask NettyConnection to write, the write happens asynchronously so the reading of the file/file region, while in the original version the reading of file was performed in the caller thread: my concern is...\r\nwhat happen to an in-flight write request (using the file) if Artemis will mark the file for deletion/or to be moved and will do it?\r\nMaybe Artemis won't do it, I'm not aware of this: I'm saying that is something to be taken into account..."", 'commenter': 'franz1981'}]"
2666,artemis-server/src/main/java/org/apache/activemq/artemis/core/protocol/core/impl/wireformat/ReplicationSyncFileMessage.java,"@@ -197,6 +232,15 @@ public void decodeRest(final ActiveMQBuffer buffer) {
       }
    }
 
+   private void readFile(ByteBuffer buffer) {
+      try (FileInputStream fis = new FileInputStream(file); FileChannel channel = fis.getChannel()) {
+         channel.position(offset);
+         channel.read(buffer);","[{'comment': 'For this purpose https://docs.oracle.com/javase/6/docs/api/java/nio/channels/FileChannel.html#read(java.nio.ByteBuffer, long) it more efficient. But is ok to open/close every time the FileChannel just to read a chunk of it?', 'commenter': 'franz1981'}, {'comment': ""We only get here for the InVM connection where we use in our test, so it doesn't matter with the performance? If needed, we can pass another parameter into constructor like fileChannel?"", 'commenter': 'wy96f'}, {'comment': ""> We only get here for the InVM connection where we use in our test, so it doesn't matter with the performance\r\n\r\nNot sure about it, EAP and other products based on Artemis use InVM connections...\r\nmaybe not with replication @jbertram @clebertsuconic any ideas?"", 'commenter': 'franz1981'}, {'comment': 'InVM is very important for performance. There is a use case at a company i know heavily reliant on InVM perf. It doesnt need to speed up, but it cant regress. Please ensure theres no perf regression.', 'commenter': 'michaelandrepearce'}]"
2666,artemis-server/src/main/java/org/apache/activemq/artemis/core/protocol/core/impl/wireformat/ReplicationSyncFileMessage.java,"@@ -150,30 +182,49 @@ public void encodeRest(final ActiveMQBuffer buffer) {
          default:
             // no-op
       }
-
       buffer.writeInt(dataSize);
-      /*
-       * sending -1 will close the file in case of a journal, but not in case of a largeMessage
-       * (which might receive appends)
-       */
-      if (dataSize > 0) {
-         buffer.writeBytes(byteBuffer, 0, byteBuffer.writerIndex());
-      }
+   }
 
-      release();
+   @Override
+   public ActiveMQBuffer encode(CoreRemotingConnection connection) {
+      if (fileId != -1 && dataSize > 0) {
+         ActiveMQBuffer buffer;
+         int bufferSize = expectedEncodeSize();
+         int encodedSize = bufferSize;
+         boolean isNetty = false;
+         if (connection != null && connection.getTransportConnection() instanceof NettyConnection) {
+            bufferSize -= dataSize;
+            isNetty = true;
+         }
+         buffer = createPacket(connection, bufferSize);
+         encodeHeader(buffer);
+         encodeRest(buffer, connection);
+         if (!isNetty) {
+            readFile(buffer.toByteBuffer(buffer.writerIndex(), buffer.writableBytes()));","[{'comment': 'You could check if buffer contains just 1 internalNIOBuffer and use it directly, avoiding to create a new one on each call', 'commenter': 'franz1981'}]"
2666,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/protocol/core/impl/ChannelImpl.java,"@@ -274,67 +276,103 @@ private void waitForFailOver(String timeoutMsg) {
       }
    }
 
-   // This must never called by more than one thread concurrently
-   private boolean send(final Packet packet, final int reconnectID, final boolean flush, final boolean batch) {
-      if (invokeInterceptors(packet, interceptors, connection) != null) {
-         return false;
+   private ActiveMQBuffer beforeSend(final Packet packet, final int reconnectID) {
+      packet.setChannelID(id);
+
+      if (responseAsyncCache != null && packet.isRequiresResponse() && packet.isResponseAsync()) {
+         packet.setCorrelationID(responseAsyncCache.nextCorrelationID());
       }
 
-      synchronized (sendLock) {
-         packet.setChannelID(id);
+      if (logger.isTraceEnabled()) {
+         logger.trace(""RemotingConnectionID="" + (connection == null ? ""NULL"" : connection.getID()) + "" Sending packet nonblocking "" + packet + "" on channelID="" + id);
+      }
 
-         if (responseAsyncCache != null && packet.isRequiresResponse() && packet.isResponseAsync()) {
-            packet.setCorrelationID(responseAsyncCache.nextCorrelationID());
+      ActiveMQBuffer buffer = packet.encode(connection);
+
+      lock.lock();
+
+      try {
+         if (failingOver) {
+            waitForFailOver(""RemotingConnectionID="" + (connection == null ? ""NULL"" : connection.getID()) + "" timed-out waiting for fail-over condition on non-blocking send"");
          }
 
-         if (logger.isTraceEnabled()) {
-            logger.trace(""RemotingConnectionID="" + (connection == null ? ""NULL"" : connection.getID()) + "" Sending packet nonblocking "" + packet + "" on channelID="" + id);
+         // Sanity check
+         if (transferring) {
+            throw ActiveMQClientMessageBundle.BUNDLE.cannotSendPacketDuringFailover();
          }
 
-         ActiveMQBuffer buffer = packet.encode(connection);
+         if (resendCache != null && packet.isRequiresConfirmations()) {
+            addResendPacket(packet);
+         }
 
-         lock.lock();
+      } finally {
+         lock.unlock();
+      }
 
-         try {
-            if (failingOver) {
-               waitForFailOver(""RemotingConnectionID="" + (connection == null ? ""NULL"" : connection.getID()) + "" timed-out waiting for fail-over condition on non-blocking send"");
-            }
+      if (logger.isTraceEnabled()) {
+         logger.trace(""RemotingConnectionID="" + (connection == null ? ""NULL"" : connection.getID()) + "" Writing buffer for channelID="" + id);
+      }
 
-            // Sanity check
-            if (transferring) {
-               throw ActiveMQClientMessageBundle.BUNDLE.cannotSendPacketDuringFailover();
-            }
+      checkReconnectID(reconnectID);
 
-            if (resendCache != null && packet.isRequiresConfirmations()) {
-               addResendPacket(packet);
+      //We do this outside the lock as ResponseCache is threadsafe and allows responses to come in,
+      //As the send could block if the response cache cannot add, preventing responses to be handled.
+      if (responseAsyncCache != null && packet.isRequiresResponse() && packet.isResponseAsync()) {
+         while (!responseAsyncCache.add(packet)) {
+            try {
+               Thread.sleep(1);
+            } catch (Exception e) {
+               // Ignore","[{'comment': ""If an Thread interrupt will happen, it should start spinning.\r\nI would add a time check that on each N seconds will warn that the loop hasn't finished yet "", 'commenter': 'franz1981'}, {'comment': "" It seems responseAsyncCache::add always returns true, so the sleep code doesn't make sense?"", 'commenter': 'wy96f'}]"
2666,artemis-server/src/main/java/org/apache/activemq/artemis/core/protocol/core/impl/wireformat/ReplicationSyncFileMessage.java,"@@ -150,30 +182,49 @@ public void encodeRest(final ActiveMQBuffer buffer) {
          default:
             // no-op
       }
-
       buffer.writeInt(dataSize);
-      /*
-       * sending -1 will close the file in case of a journal, but not in case of a largeMessage
-       * (which might receive appends)
-       */
-      if (dataSize > 0) {
-         buffer.writeBytes(byteBuffer, 0, byteBuffer.writerIndex());
-      }
+   }
 
-      release();
+   @Override
+   public ActiveMQBuffer encode(CoreRemotingConnection connection) {
+      if (fileId != -1 && dataSize > 0) {
+         ActiveMQBuffer buffer;
+         int bufferSize = expectedEncodeSize();
+         int encodedSize = bufferSize;
+         boolean isNetty = false;
+         if (connection != null && connection.getTransportConnection() instanceof NettyConnection) {
+            bufferSize -= dataSize;
+            isNetty = true;
+         }
+         buffer = createPacket(connection, bufferSize);
+         encodeHeader(buffer);
+         encodeRest(buffer, connection);
+         if (!isNetty) {
+            readFile(buffer.toByteBuffer(buffer.writerIndex(), buffer.writableBytes()));
+            buffer.writerIndex(buffer.capacity());
+         }
+         encodeSize(buffer, encodedSize);
+         return buffer;
+      } else {
+         return super.encode(connection);
+      }
    }
 
    @Override
    public void release() {
-      if (byteBuffer != null) {
-         byteBuffer.release();
-         byteBuffer = null;
+      if (fileChannel != null) {
+         try {
+            fileChannel.close();
+         } catch (IOException e) {
+            e.printStackTrace();","[{'comment': 'Better use a proper logger here', 'commenter': 'franz1981'}]"
2666,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnection.java,"@@ -385,6 +402,34 @@ public final void write(ActiveMQBuffer buffer,
       }
    }
 
+   @Override
+   public void write(ActiveMQBuffer buffer,","[{'comment': ""You don't need the buffer parameter here: we already have an API to write just buffers: just create a specific API for the file case"", 'commenter': 'franz1981'}, {'comment': 'Do you mean we call write twice, first write buffer api, second new write file api in channel::send()? This way we will call netty channel::writeAndFlush twice, right?', 'commenter': 'wy96f'}, {'comment': 'Depends if we are using batching or not: it depends on the writeable bytes on the channel', 'commenter': 'franz1981'}]"
2666,artemis-server/src/main/java/org/apache/activemq/artemis/core/remoting/impl/invm/InVMConnection.java,"@@ -237,6 +240,22 @@ public void run() {
 
    }
 
+   @Override
+   public void write(ActiveMQBuffer buffer,
+                     RandomAccessFile raf,
+                     FileChannel fileChannel,
+                     long offset,
+                     int dataSize,
+                     boolean closeChannel) {
+      try {
+         if (closeChannel)","[{'comment': ""This method is correct that's empty?\r\nAnyway please use a proper logger here"", 'commenter': 'franz1981'}, {'comment': 'In ReplicationSyncFileMessage::encode, the file is read into buffer for non netty connection, so we just need to send buffer.', 'commenter': 'wy96f'}]"
2666,artemis-server/src/main/java/org/apache/activemq/artemis/core/replication/ReplicationManager.java,"@@ -551,49 +580,52 @@ private void sendLargeFile(AbstractJournalStorageManager.JournalContent content,
       if (!file.isOpen()) {
          file.open();
       }
-      int size = 32 * 1024;
+      final int size = 1024 * 1024;
+      long fileSize = file.size();
 
       int flowControlSize = 10;
 
       int packetsSent = 0;
       FlushAction action = new FlushAction();
 
+      long offset = 0;
+      RandomAccessFile raf;
+      FileChannel fileChannel = null;
       try {
-         try (FileInputStream fis = new FileInputStream(file.getJavaFile()); FileChannel channel = fis.getChannel()) {
-
-            // We can afford having a single buffer here for this entire loop
-            // because sendReplicatePacket will encode the packet as a NettyBuffer
-            // through ActiveMQBuffer class leaving this buffer free to be reused on the next copy
-            while (true) {
-               final ByteBuf buffer = PooledByteBufAllocator.DEFAULT.directBuffer(size, size);
-               buffer.clear();
-               ByteBuffer byteBuffer = buffer.writerIndex(size).readerIndex(0).nioBuffer();
-               final int bytesRead = channel.read(byteBuffer);
-               int toSend = bytesRead;
-               if (bytesRead > 0) {
-                  if (bytesRead >= maxBytesToSend) {
-                     toSend = (int) maxBytesToSend;
-                     maxBytesToSend = 0;
-                  } else {
-                     maxBytesToSend = maxBytesToSend - bytesRead;
-                  }
-               }
-               logger.debug(""sending "" + buffer.writerIndex() + "" bytes on file "" + file.getFileName());
-               // sending -1 or 0 bytes will close the file at the backup
-               // We cannot simply send everything of a file through the executor,
-               // otherwise we would run out of memory.
-               // so we don't use the executor here
-               sendReplicatePacket(new ReplicationSyncFileMessage(content, pageStore, id, toSend, buffer), true);
-               packetsSent++;
-
-               if (packetsSent % flowControlSize == 0) {
-                  flushReplicationStream(action);
+         raf = new RandomAccessFile(file.getJavaFile(), ""r"");
+         fileChannel = raf.getChannel();
+         while (true) {
+            long chunkSize = Math.min(size, fileSize - offset);
+            int toSend = (int) chunkSize;
+            if (chunkSize > 0) {
+               if (chunkSize >= maxBytesToSend) {
+                  toSend = (int) maxBytesToSend;
+                  maxBytesToSend = 0;
+               } else {
+                  maxBytesToSend = maxBytesToSend - chunkSize;
                }
-               if (bytesRead == -1 || bytesRead == 0 || maxBytesToSend == 0)
-                  break;
             }
+            logger.debug(""sending "" + toSend + "" bytes on file "" + file.getFileName());
+            // sending -1 or 0 bytes will close the file at the backup
+            // We cannot simply send everything of a file through the executor,
+            // otherwise we would run out of memory.
+            // so we don't use the executor here
+            sendSyncFileMessage(new ReplicationSyncFileMessage(content, pageStore, id, raf, fileChannel, offset, toSend), offset + toSend == fileSize);
+            packetsSent++;
+            offset += toSend;
+
+            if (packetsSent % flowControlSize == 0) {
+               flushReplicationStream(action);
+            }
+            if (toSend == 0 || maxBytesToSend == 0)
+               break;
          }
          flushReplicationStream(action);
+
+      } catch (Exception e) {
+         if (fileChannel != null)
+            fileChannel.close();","[{'comment': 'And raf? \r\nMaybe would be better to mark the expected last packet and make netty able to register a listener and let it close it on deallocate (after a successful/failed write)? ', 'commenter': 'franz1981'}, {'comment': 'You mean on caller side we add a callback where is called in netty channelFutureListener after write?', 'commenter': 'wy96f'}, {'comment': 'Yes, but just the supposed last packet need that listener, while the other writes can just use a void promise instead', 'commenter': 'franz1981'}]"
2666,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnection.java,"@@ -385,6 +402,34 @@ public final void write(ActiveMQBuffer buffer,
       }
    }
 
+   @Override
+   public void write(ActiveMQBuffer buffer,
+                     RandomAccessFile raf,
+                     FileChannel fileChannel,
+                     long offset,
+                     int dataSize,
+                     boolean closeChannel) {
+      final int readableBytes = buffer.readableBytes() + dataSize;
+      if (logger.isDebugEnabled()) {
+         final int remainingBytes = this.writeBufferHighWaterMark - readableBytes;
+         if (remainingBytes < 0) {
+            logger.debug(""a write request is exceeding by "" + (-remainingBytes) + "" bytes the writeBufferHighWaterMark size [ "" + this.writeBufferHighWaterMark + "" ] : consider to set it at least of "" + readableBytes + "" bytes"");
+         }
+      }
+
+      //no need to lock because the Netty's channel is thread-safe
+      //and the order of write is ensured by the order of the write calls
+      final Channel channel = this.channel;
+      final ByteBuf bytes = buffer.byteBuf();
+      assert readableBytes >= 0;
+      channel.write(bytes);
+      channel.writeAndFlush(getFileObject(raf, fileChannel, offset, dataSize)).addListener(future -> {
+         if ((closeChannel || !future.isSuccess()) && fileChannel.isOpen()) {","[{'comment': ""I've proposed a different solution on caller side to make this more efficient and effective"", 'commenter': 'franz1981'}]"
2684,docs/user-manual/en/security.md,"@@ -19,6 +19,12 @@ certificate this name is the name to which their certificate's DN maps. If
 server will simply use whatever user name (if any) the client provides. This
 option is `false` by default.
 
+## Rejecting messages without a Validated user","[{'comment': ""This doesn't seem related to this PR"", 'commenter': 'franz1981'}]"
2684,examples/features/sub-modules/inter-broker-bridge/artemis-jms-bridge/readme.md,"@@ -73,7 +73,7 @@ This approach might be preferred if for example you only have access to the 5.x
 ```xml
    <bean id=""5xConnectionFactory"" class=""org.apache.activemq.ActiveMQConnectionFactory"">
       <property name=""brokerURL"" value=""tcp://localhost:61616""/>
-      <property name=""userName"" value=""admin""/>
+      <property name=""user"" value=""admin""/>","[{'comment': ""This doesn't seem related to this PR (as above)"", 'commenter': 'franz1981'}]"
2684,tests/activemq5-unit-tests/src/test/java/org/apache/activemq/usecases/receiver-secured.xml,"@@ -25,7 +25,7 @@
   <broker brokerName=""receiver"" persistent=""false"" useJmx=""true"" allowTempAutoCreationOnSend=""true"" xmlns=""http://activemq.apache.org/schema/core"">
 
     <networkConnectors>
-      <networkConnector uri=""static:(tcp://localhost:62001)"" userName=""system"" password=""manager""/>
+      <networkConnector uri=""static:(tcp://localhost:62001)"" user=""system"" password=""manager""/>","[{'comment': ""This doesn't seem related to this PR"", 'commenter': 'franz1981'}]"
2684,tests/activemq5-unit-tests/src/test/java/org/apache/activemq/usecases/sender-secured.xml,"@@ -25,7 +25,7 @@
   <broker brokerName=""sender"" persistent=""false"" useJmx=""true"" xmlns=""http://activemq.apache.org/schema/core"">
 
     <networkConnectors>
-      <networkConnector uri=""static:(tcp://localhost:62002)"" userName=""system"" password=""manager"">
+      <networkConnector uri=""static:(tcp://localhost:62002)"" user=""system"" password=""manager"">","[{'comment': ""This doesn't seem related to this PR"", 'commenter': 'franz1981'}]"
2707,artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/AMQPConnectionContext.java,"@@ -183,6 +188,11 @@ public void flush() {
    }
 
    public void close(ErrorCondition errorCondition) {
+      if (scheduledPool != null && scheduledPool instanceof ThreadPoolExecutor &&","[{'comment': 'You can call cancel on the future to let the pool remove it and it would be better (just for likelihood with other similar declarations) to use the wildcard typed version of it or ScheduledFuture<?>', 'commenter': 'franz1981'}, {'comment': ""The scheduledPool RemoveOnCancelPolicy is false so If I cancel the task it won't be removed from the queue and the garbage collector can't delete it."", 'commenter': 'brusdev'}]"
2707,artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/AMQPConnectionContext.java,"@@ -183,6 +191,17 @@ public void flush() {
    }
 
    public void close(ErrorCondition errorCondition) {
+      synchronized (schedulingLock) {
+         isSchedulingCancelled = true;
+
+         if (scheduledPool != null && scheduledPool instanceof ThreadPoolExecutor &&
+            scheduledFuture != null && scheduledFuture instanceof Runnable) {
+            if (!((ThreadPoolExecutor) scheduledPool).remove((Runnable) scheduledFuture)) {","[{'comment': ""I suggest another approach that doesn't require a specific type of Runnable and ThreadPoolExecutor to work"", 'commenter': 'franz1981'}, {'comment': ""The other issue is perf-wise: if the work queue used on the `ScheduledExecutorService` is a `LinkedBlockingQueue` it requires a full lock on the queue to perform the remove, that's bad from a scalability point of view, given that the `ScheduledExecutorService` is shared between several components, see https://github.com/jdk-mirror/openjdk8/blob/master/java/util/concurrent/LinkedBlockingQueue.java#L548"", 'commenter': 'franz1981'}, {'comment': ""I see your point about performance but I think that sooner or later that remove will be done.\r\nI also think it's important free all resource related an object before finish close for two matters:\r\n1) free resource for the broker\r\n2) avoid unpredictable behavior"", 'commenter': 'brusdev'}, {'comment': 'Yep, but the resources that can actually lead to OOM are not the Runnable, but the context that the Runnable(s) contains: If such context is referenced in an explicit, but `WeakReference` it would allow it to be collected when deferenced elsewhere. \r\nThen the leaking `Runnable`s will be removed on the next (supposed) fire, without affecting scalability.\r\nThe memory consumption of a Runnable without any context is ~64 bytes so it is very unlikely to be the cause of OOM per se.', 'commenter': 'franz1981'}, {'comment': 'Currently scheduledPool is used by:\r\n1) AMQPConnectionContext more time but one task at once for instance\r\n2) ActiveMQServerImpl one time and one task\r\n3) SharedNothingBackupQuorum one time and one task\r\n4) MessagePullHandler each time AMQConsumer.handleDeliver is called if prefetchSize = 0\r\n\r\nScheduledPool is mostly used by AMQPConnectionContext (one for each amqp connection) and remove is called only on connection close, so the effort for the remove should not impact on the entire system scalability.\r\nMoreover GC should manage that unused objects until they are not removed from the scheduledPool.\r\nFinally WeakReference require deeper source change for ScheduleRunnable and TickerRunnable to avoid unpredictable behavior when GC delete AMQPConnectionContext before their execution.\r\n\r\nMy concern is that to introduce unpredictable behavior to avoid paying a small computational cost.', 'commenter': 'brusdev'}, {'comment': ""I won't guess which effects a remove would have globally: I just think is not a good idea to do it if not necessary, given that the scheduled pool usage span outside the context of this PR change.\r\n\r\n> Finally WeakReference require deeper source change for ScheduleRunnable and TickerRunnable to avoid unpredictable behavior when GC delete AMQPConnectionContext before their execution.\r\n\r\nTotally agree, but it would allow a more robust behaviour if a cancel won't get rid of the task instance. Anyway this last one (a missing cancel) is an additional issue and I agree it doesn't need to be addressed here.\r\n\r\nMy whole point is that having such casting cascade just to use the remove API makes me believe that worth investigating if this same PR could be addressed in a cleaner way (ie less hacky, not with less code changes) and evaluate if it is more portable/effective too.\r\n\r\nFeel free to try addressing in another way and provide your branch to @k-wall to try it before merging it too :+1: \r\n\r\n\r\n"", 'commenter': 'franz1981'}]"
2707,artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/AMQPConnectionContext.java,"@@ -389,13 +408,15 @@ public void onRemoteOpen(Connection connection) throws Exception {
       initialise();
 
       /*
-      * This can be null which is in effect an empty map, also we really don't need to check this for in bound connections
-      * but its here in case we add support for outbound connections.
-      * */
+       * This can be null which is in effect an empty map, also we really don't need to check this for in bound connections
+       * but its here in case we add support for outbound connections.
+       * */
       if (connection.getRemoteProperties() == null || !connection.getRemoteProperties().containsKey(CONNECTION_OPEN_FAILED)) {
          long nextKeepAliveTime = handler.tick(true);
-         if (nextKeepAliveTime != 0 && scheduledPool != null) {
-            scheduledPool.schedule(new ScheduleRunnable(), (nextKeepAliveTime - TimeUnit.NANOSECONDS.toMillis(System.nanoTime())), TimeUnit.MILLISECONDS);
+         synchronized (schedulingLock) {
+            if (nextKeepAliveTime != 0 && scheduledPool != null && !isSchedulingCancelled) {
+               scheduledFuture = scheduledPool.schedule(new ScheduleRunnable(), (nextKeepAliveTime - TimeUnit.NANOSECONDS.toMillis(System.nanoTime())), TimeUnit.MILLISECONDS);","[{'comment': ""Why not declaring `scheduledFuture` an `AtomicReference<ScheduledFuture<?>>` instead and avoid locks here?\r\nAny other lock-free container (concurrent map or concurrent linked queue) would be fine if we don't know how many of them will be accumulated"", 'commenter': 'franz1981'}, {'comment': 'It is important not to schedule another task after close, so I add isSchedulingCancelled and It needs a critical section to be synchronized with scheduledFuture.', 'commenter': 'brusdev'}, {'comment': 'It depends if the calling thread is not the same: need to ask @clebertsuconic if the scheduling happens always in a single-threaded fashion ie single thread but not the *same* thread each time.\r\nIn that case the whole lock part could be simplified, saving unecessary locks.', 'commenter': 'franz1981'}]"
2707,artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/AMQPConnectionContext.java,"@@ -389,13 +408,15 @@ public void onRemoteOpen(Connection connection) throws Exception {
       initialise();
 
       /*
-      * This can be null which is in effect an empty map, also we really don't need to check this for in bound connections
-      * but its here in case we add support for outbound connections.
-      * */
+       * This can be null which is in effect an empty map, also we really don't need to check this for in bound connections
+       * but its here in case we add support for outbound connections.
+       * */
       if (connection.getRemoteProperties() == null || !connection.getRemoteProperties().containsKey(CONNECTION_OPEN_FAILED)) {
          long nextKeepAliveTime = handler.tick(true);
-         if (nextKeepAliveTime != 0 && scheduledPool != null) {
-            scheduledPool.schedule(new ScheduleRunnable(), (nextKeepAliveTime - TimeUnit.NANOSECONDS.toMillis(System.nanoTime())), TimeUnit.MILLISECONDS);
+         synchronized (schedulingLock) {","[{'comment': 'I have a very big concern here. Locks in connection stuff, artemis was built on the premise of being nonblocking. As time goes on more and more blocking locks are being added to core code paths. That then take months unravellling later. Can we please spend the time upfront now to find a solution to avoid adding sync locks.', 'commenter': 'michaelandrepearce'}, {'comment': 'I am looking for a solution without sync locks but using AtomicBoolean and AtomicReference. Have you any suggestion?', 'commenter': 'brusdev'}, {'comment': 'I created the PR #2727 to remove the synchronized blocks using an AtomicReference.', 'commenter': 'brusdev'}]"
2726,artemis-server/src/test/java/org/apache/activemq/artemis/core/server/impl/ActiveMQServerImplTest.java,"@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.core.server.impl;
+
+import java.lang.ref.WeakReference;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.activemq.artemis.core.server.ActiveMQServer;
+import org.apache.activemq.artemis.utils.ThreadLeakCheckRule;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class ActiveMQServerImplTest {
+
+   @Test
+   public void testScheduledPoolGC() throws Exception {
+      ActiveMQServer server = new ActiveMQServerImpl();
+
+      server.start();
+
+      WeakReference<Runnable> scheduledRunnableRef;
+      {
+         Runnable scheduledRunnable = new Runnable() { @Override public void run() { } };
+         scheduledRunnableRef = new WeakReference<>(scheduledRunnable);
+
+         ScheduledFuture scheduledFuture = server.getScheduledPool().schedule(scheduledRunnable, 5000, TimeUnit.MILLISECONDS);
+
+         scheduledFuture.cancel(true);
+      }
+
+      Assert.assertNotEquals(null, scheduledRunnableRef.get());","[{'comment': 'GC is not precise (when things got out of scope/not referenced they got collected immediately) and depend on the type of GC chosen: probably you need to issue (full) GC and right after check the weak reference, but it is not reliable enough. We have other tests that do something similar using an ad-hoc call to GC, will point you them on Monday', 'commenter': 'franz1981'}]"
2726,artemis-server/src/test/java/org/apache/activemq/artemis/core/server/impl/ActiveMQServerImplTest.java,"@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.core.server.impl;
+
+import java.lang.ref.WeakReference;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.activemq.artemis.core.server.ActiveMQServer;
+import org.apache.activemq.artemis.tests.util.ActiveMQTestBase;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class ActiveMQServerImplTest extends ActiveMQTestBase {
+
+   @Test
+   public void testScheduledPoolGC() throws Exception {
+      ActiveMQServer server = createServer(false);
+
+      server.start();
+
+      WeakReference<Runnable> scheduledRunnableRef;
+      {
+         Runnable scheduledRunnable = new Runnable() {
+            @Override
+            public void run() {
+               Assert.fail();
+            }
+         };
+         scheduledRunnableRef = new WeakReference<>(scheduledRunnable);
+
+         ScheduledExecutorService scheduledPool = server.getScheduledPool();
+         ScheduledFuture scheduledFuture = scheduledPool.schedule(scheduledRunnable, 5000, TimeUnit.MILLISECONDS);
+
+         Assert.assertFalse(scheduledFuture.isCancelled());
+         Assert.assertTrue(scheduledFuture.cancel(true));
+         Assert.assertTrue(scheduledFuture.isCancelled());
+
+         Assert.assertNotEquals(null, scheduledRunnableRef.get());
+      }
+
+      long timeout = System.currentTimeMillis() + 5000;
+
+      while (timeout > System.currentTimeMillis() && scheduledRunnableRef.get() != null) {
+         System.gc();","[{'comment': 'We have a call on the ActiveMQTestBAse:: forceGC', 'commenter': 'clebertsuconic'}]"
2726,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ActiveMQServerImpl.java,"@@ -2667,10 +2667,18 @@ public ThreadFactory run() {
                return new ActiveMQThreadFactory(""ActiveMQ-scheduled-threads"", false, ClientSessionFactoryImpl.class.getClassLoader());
             }
          });
-         scheduledPool = new ScheduledThreadPoolExecutor(configuration.getScheduledThreadPoolMaxSize(), tFactory);
+
+         ScheduledThreadPoolExecutor scheduledPoolExecutor = new ScheduledThreadPoolExecutor(configuration.getScheduledThreadPoolMaxSize(), tFactory);
+         scheduledPoolExecutor.setRemoveOnCancelPolicy(true);
+         scheduledPool = scheduledPoolExecutor;
       } else {
          this.scheduledPoolSupplied = true;
          this.scheduledPool = serviceRegistry.getScheduledExecutorService();
+
+         if (!(scheduledPool instanceof ScheduledThreadPoolExecutor) ||","[{'comment': ""Shouldn't this be `if (scheduledPool instanceof ScheduledThreadPoolExecutor && !((ScheduledThreadPoolExecutor) scheduledPool).getRemoveOnCancelPolicy()) {`?\r\n\r\nScheduledExecutorService used by broker might remove task after cancel, E.g. kinds of executors in Netty."", 'commenter': 'wy96f'}]"
2726,artemis-server/src/test/java/org/apache/activemq/artemis/core/server/impl/ActiveMQServerImplTest.java,"@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.core.server.impl;
+
+import java.lang.ref.WeakReference;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.activemq.artemis.core.server.ActiveMQServer;
+import org.apache.activemq.artemis.tests.util.ActiveMQTestBase;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class ActiveMQServerImplTest extends ActiveMQTestBase {
+
+   @Test
+   public void testScheduledPoolGC() throws Exception {
+      ActiveMQServer server = createServer(false);
+
+      server.start();
+
+      Runnable scheduledRunnable = new Runnable() {
+         @Override
+         public void run() {
+            Assert.fail();
+         }
+      };
+      WeakReference<Runnable> scheduledRunnableRef = new WeakReference<>(scheduledRunnable);
+
+      ScheduledExecutorService scheduledPool = server.getScheduledPool();
+      ScheduledFuture scheduledFuture = scheduledPool.schedule(scheduledRunnable, 5000, TimeUnit.MILLISECONDS);
+
+      Assert.assertFalse(scheduledFuture.isCancelled());
+      Assert.assertTrue(scheduledFuture.cancel(true));
+      Assert.assertTrue(scheduledFuture.isCancelled());
+
+      Assert.assertNotEquals(null, scheduledRunnableRef.get());","[{'comment': '`Assert.assertNotEquals(null, scheduledRunnableRef.get());` should be put before \r\n `Assert.assertTrue(scheduledFuture.cancel(true));`. GC might occur right at this moment and cause reference object cleared, resulting in test failure.', 'commenter': 'wy96f'}, {'comment': ""The scheduledRunnableRef referent shouldn't be cleared until the local variable scheduledRunnable won't be set null."", 'commenter': 'brusdev'}, {'comment': 'you are right, i missed that :)', 'commenter': 'wy96f'}]"
2741,artemis-server/src/main/java/org/apache/activemq/artemis/core/persistence/impl/journal/JournalStorageManager.java,"@@ -86,6 +87,8 @@
 
    protected ReplicationManager replicator;
 
+   protected final AtomicInteger deletingLargeMessageTasks = new AtomicInteger(0);","[{'comment': 'I would put this logic just into `JDBCJournalStorageManager` while exposing here these callbacks:\r\n```java\r\nprotected void beforeSubmitDeleteLargeMessageRequest() {\r\n}\r\n\r\nprotected void afterDeleteLargeMessageCompleted() {\r\n}\r\n\r\nprotected void afterDeleteLargeMessageError(int code, String errorMessage) {\r\n}\r\n```\r\nThe names could be improved, but the idea would be to let just JDBC part to care about this (unless we know that the storage manager need to handle this too), wdyt?', 'commenter': 'franz1981'}, {'comment': ""TBH, I can't reproduce the issue on JournalStorageManager/JournalImpl but in theory they should have the same issue of JDBCJournalStorageManager/JDBCJournalImpl. I think the issue on JournalStorageManager/JournalImpl is hidden by better performances."", 'commenter': 'brusdev'}, {'comment': '@brusdev You can try with mockito to inject slow large messages deletes and see what happen...good point!', 'commenter': 'franz1981'}, {'comment': ""Take a look on ReusableLatch...\r\n\r\nI created ReusableLatch for situations like this.\r\n\r\nyou make it a final... and you away(0) until it gets to 0.\r\n\r\nit's the same overhead as an AtomicINteger\r\nsame usability as a CountDownLatch."", 'commenter': 'clebertsuconic'}, {'comment': 'I replaced AtomicInteger with ReusableLatch.', 'commenter': 'brusdev'}]"
2741,artemis-server/src/test/java/org/apache/activemq/artemis/core/persistence/impl/journal/JournalStorageManagerTest.java,"@@ -212,4 +212,36 @@ public void testAddBytesToLargeMessageNotLeakingByteBuffer() throws Exception {
       }
    }
 
+   @Test
+   public void testDeletingLargeMessagePendingTasksOnShutdown() throws Exception {
+      if (journalType == JournalType.ASYNCIO) {
+         assumeTrue(""AIO is not supported on this platform"", AIOSequentialFileFactory.isSupported());
+      }
+      final Configuration configuration = createDefaultInVMConfig().setJournalType(journalType);
+      final ExecutorFactory executorFactory = new OrderedExecutorFactory(executor);
+      final ExecutorFactory ioExecutorFactory = new OrderedExecutorFactory(ioExecutor);
+      final JournalStorageManager manager = new JournalStorageManager(configuration, null, executorFactory, null, ioExecutorFactory);
+      manager.start();
+      manager.loadBindingJournal(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());
+      final PostOffice postOffice = mock(PostOffice.class);
+      final JournalLoader journalLoader = mock(JournalLoader.class);
+      manager.loadMessageJournal(postOffice, null, null, null, null, null, null, journalLoader);
+      final LargeServerMessage largeMessage = manager.createLargeMessage(manager.generateID() + 1, new CoreMessage().setDurable(true));
+      final SequentialFile file = largeMessage.getFile();
+      manager.getContext(true).storeLineUp();
+      manager.deleteLargeMessageFile(largeMessage);
+      final CountDownLatch latch = new CountDownLatch(1);
+      Executors.newSingleThreadExecutor().execute(() -> {
+         try {
+            manager.stop();
+            latch.countDown();
+         } catch (Exception ignore) {
+         }
+      });
+      Thread.sleep(500);","[{'comment': ""Why you need a sleep? I have been beaten pretty badly by Thread.sleep() on the testsuite many many times. Can't we avoid it with a latch, a Wait.. anything else?\r\n\r\nUnless this is testing timeouts, I wouldn't use a wait."", 'commenter': 'clebertsuconic'}, {'comment': 'I replaced the sleep with a latch and a wait. ', 'commenter': 'brusdev'}, {'comment': '-1 we should have no blocking see other comment', 'commenter': 'michaelpearce-gain'}]"
2741,artemis-server/src/main/java/org/apache/activemq/artemis/core/persistence/impl/journal/JournalStorageManager.java,"@@ -268,6 +271,8 @@ private boolean internalStop(boolean ioCriticalError, boolean sendFailover) thro
             idGenerator.persistCurrentID();
       }
 
+      deletingLargeMessageTasks.await(30, TimeUnit.SECONDS);","[{'comment': '-1 This isnt a good idea. On case of split brain with network pinger and network is detected split we need the isolated to shutdown to occur immediately without any blocking. ', 'commenter': 'michaelpearce-gain'}, {'comment': 'I see your point but it normally should not block and 10 lines forward I see the same code:\r\n\r\n> latch.await(30, TimeUnit.SECONDS);', 'commenter': 'brusdev'}, {'comment': 'that doesnt mean its something we would want to proliferate. Just because a window is broken already, doesnt mean its ok to just go inside... avoid the broken glass... be a good citizen tidy up the glass, report it to the police, fix the window.', 'commenter': 'michaelpearce-gain'}]"
2769,artemis-journal/src/main/java/org/apache/activemq/artemis/core/io/SequentialFile.java,"@@ -53,7 +52,7 @@
 
    void fill(int size) throws Exception;
 
-   void delete() throws IOException, InterruptedException, ActiveMQException;
+   void delete() throws Exception;","[{'comment': 'Can you revert this and keep the explicit exceptions.', 'commenter': 'michaelpearce-gain'}]"
2769,artemis-journal/src/main/java/org/apache/activemq/artemis/core/io/mapped/TimedSequentialFile.java,"@@ -94,7 +93,7 @@ public void fill(int size) throws Exception {
    }
 
    @Override
-   public void delete() throws IOException, InterruptedException, ActiveMQException {
+   public void delete() throws Exception {","[{'comment': 'Revert this and keep explicit ', 'commenter': 'michaelpearce-gain'}]"
2769,artemis-server/src/main/java/org/apache/activemq/artemis/core/persistence/impl/journal/LargeServerMessageImpl.java,"@@ -298,7 +298,7 @@ public int getBodyBufferSize() {
       } finally {
          if (closeFile) {
             try {
-               file.close();
+               file.close(false);","[{'comment': ""these will cause the channel to not flush, correct?\r\n\r\nWhy you making this change?\r\n\r\n\r\nThe thing is, I;ve run the testsuite after these changes and there are files leaking.\r\n\r\nI'm running it one more time but this is the only commit after it started to fail. And I'm a bit confused about this after I merged and looking at the tests."", 'commenter': 'clebertsuconic'}, {'comment': '@wy96f  ^^^', 'commenter': 'clebertsuconic'}, {'comment': 'The getBodyBufferSize only retrieves the fileSize after opening file, and I assume this is only for reading. For this reason, I close it without flushing. I want to ask how you found files leaking? Are the leaking files large message ones?', 'commenter': 'wy96f'}, {'comment': 'when I run the whole testsuite, the NoProcessFilesBehind is reporting too many files open.', 'commenter': 'clebertsuconic'}]"
2791,artemis-server/src/main/java/org/apache/activemq/artemis/core/settings/impl/AddressSettings.java,"@@ -505,6 +505,9 @@ public long getPageSizeBytes() {
    }
 
    public AddressSettings setPageSizeBytes(final long pageSize) {
+      if (pageSize > Integer.MAX_VALUE) {
+         throw new IllegalArgumentException(""pageSize must be < "" + Integer.MAX_VALUE);","[{'comment': 'Why not change long to int, this would then be cleaner from anyone trying to use the method', 'commenter': 'michaelandrepearce'}, {'comment': 'The AddressSettings maybe persisted in disk, and if we change long to int, we would incorrectly decode it. Does it make sense?', 'commenter': 'wy96f'}, {'comment': 'Not really. If you now decode something thats larger than int it will blow up with the exception youve added. No different. Except we are actually making the method take the correct primitive number', 'commenter': 'michaelandrepearce'}, {'comment': 'Also should update the schema to int so then when people do parse configs via xsd validators it would fail', 'commenter': 'michaelandrepearce'}]"
2791,artemis-server/src/test/java/org/apache/activemq/artemis/core/config/impl/FileConfigurationParserTest.java,"@@ -257,6 +257,26 @@ public void testParsingDefaultServerConfigWithENCMaskedPwd() throws Exception {
       assertEquals(""helloworld"", bconfig.getPassword());
    }
 
+   @Test
+   public void testParsingOverflowPageSize() throws Exception {
+      FileConfigurationParser parser = new FileConfigurationParser();","[{'comment': 'This test, test the new change, but doesnt test for what we are protecting from. E.g whats the underlying issue being fixed', 'commenter': 'michaelandrepearce'}, {'comment': 'E.g. other sizes are quite happily long currently also. Why is this special', 'commenter': 'michaelandrepearce'}, {'comment': ""> E.g. other sizes are quite happily long currently also. Why is this special\r\n\r\nI see in Page::write()/Page::read() all operations are limited to int range, such as PagingStoreImpl::currentPageSize, Page::size, and local variables like fileSize, processedBytes in Page::readFromSequentialFile(), etc.\r\n\r\n> This test, test the new change, but doesnt test for what we are protecting from. E.g whats the underlying issue being fixed\r\n\r\nI'm not sure what you mean. We're protecting page-size-bytes from being greater than Integer.MAX_VALUE(2147483647). So if we set page-size-bytes to 2147483648, the broker is expected to fail fast to throw exception , correct?\r\n\r\n\r\n\r\n\r\n"", 'commenter': 'wy96f'}, {'comment': 'Point more so was i assume the same issue may lay in other persistence such as journal etc. As alot of it started from a common base.', 'commenter': 'michaelandrepearce'}]"
2791,artemis-server/src/main/java/org/apache/activemq/artemis/core/config/impl/Validators.java,"@@ -122,6 +122,30 @@ public void validate(final String name, final Object value) {
       }
    };
 
+   public static final Validator POSITIVE_INT = new Validator() {","[{'comment': 'This isnt needed, simply change the xsd defination to int and it would fail', 'commenter': 'michaelpearce-gain'}, {'comment': 'ignore i spotted, why finally, its because GB etc can be used in the string type, and then converted as such cannot limit this in xsd.', 'commenter': 'michaelpearce-gain'}]"
2791,artemis-server/src/main/java/org/apache/activemq/artemis/core/config/impl/Validators.java,"@@ -122,6 +122,30 @@ public void validate(final String name, final Object value) {
       }
    };
 
+   public static final Validator POSITIVE_INT = new Validator() {
+      @Override
+      public void validate(final String name, final Object value) {
+         Number val = (Number) value;
+         if (val.longValue() > 0 && val.longValue() <= Integer.MAX_VALUE) {
+            // OK
+         } else {
+            throw ActiveMQMessageBundle.BUNDLE.inRangeOfPositiveInt(name, val);
+         }
+      }
+   };
+
+   public static final Validator MINUS_ONE_OR_POSITIVE_INT = new Validator() {","[{'comment': 'again not needed, if the xsd is corrected to correct type, as it would ensure type size bound. also ensruing xsd is correct, allows end users to use the xsd to pre validate.', 'commenter': 'michaelpearce-gain'}, {'comment': 'ignore i spotted, why finally, its because GB etc can be used in the string type, and then converted as such cannot limit this in xsd.', 'commenter': 'michaelpearce-gain'}]"
2791,artemis-server/src/main/java/org/apache/activemq/artemis/core/deployers/impl/FileConfigurationParser.java,"@@ -1756,17 +1758,17 @@ private void parseClusterConnectionConfiguration(final Element e, final Configur
 
       double retryIntervalMultiplier = getDouble(e, ""retry-interval-multiplier"", ActiveMQDefaultConfiguration.getDefaultClusterRetryIntervalMultiplier(), Validators.GT_ZERO);
 
-      int minLargeMessageSize = getTextBytesAsIntBytes(e, ""min-large-message-size"", ActiveMQClient.DEFAULT_MIN_LARGE_MESSAGE_SIZE, Validators.GT_ZERO);
+      int minLargeMessageSize = getTextBytesAsIntBytes(e, ""min-large-message-size"", ActiveMQClient.DEFAULT_MIN_LARGE_MESSAGE_SIZE, Validators.POSITIVE_INT);","[{'comment': 'revert, not needed', 'commenter': 'michaelpearce-gain'}, {'comment': 'ignore i was wrong, i see the issue.', 'commenter': 'michaelpearce-gain'}]"
2791,artemis-server/src/main/java/org/apache/activemq/artemis/core/deployers/impl/FileConfigurationParser.java,"@@ -597,11 +597,11 @@ public void parseMainConfig(final Element e, final Configuration config) throws
 
       config.setJournalSyncNonTransactional(getBoolean(e, ""journal-sync-non-transactional"", config.isJournalSyncNonTransactional()));
 
-      config.setJournalFileSize(getTextBytesAsIntBytes(e, ""journal-file-size"", config.getJournalFileSize(), Validators.GT_ZERO));
+      config.setJournalFileSize(getTextBytesAsIntBytes(e, ""journal-file-size"", config.getJournalFileSize(), Validators.POSITIVE_INT));","[{'comment': 'change was not needed here, int range should all be validated by xsd type.', 'commenter': 'michaelpearce-gain'}, {'comment': 'ignore i spotted why you need.', 'commenter': 'michaelpearce-gain'}]"
2912,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -129,9 +129,9 @@
    protected static final int CRITICAL_CHECK_DEPAGE = 4;
 
    private static final Logger logger = Logger.getLogger(QueueImpl.class);
-   private static final AtomicIntegerFieldUpdater dispatchingUpdater = AtomicIntegerFieldUpdater.newUpdater(QueueImpl.class, ""dispatching"");
-   private static final AtomicLongFieldUpdater dispatchStartTimeUpdater = AtomicLongFieldUpdater.newUpdater(QueueImpl.class, ""dispatchStartTime"");
-   private static final AtomicLongFieldUpdater consumerRemovedTimestampUpdater = AtomicLongFieldUpdater.newUpdater(QueueImpl.class, ""consumerRemovedTimestamp"");
+   private static final AtomicIntegerFieldUpdater<QueueImpl> dispatchingUpdater = AtomicIntegerFieldUpdater.newUpdater(QueueImpl.class, ""dispatching"");","[{'comment': ""What's the difference here? what's the advantage?"", 'commenter': 'clebertsuconic'}, {'comment': 'This just solves a lot of (16) compiler warnings. When declared: ""AtomicIntegerFieldUpdater is a raw type. References to generic type AtomicIntegerFieldUpdater<T> should be parameterized""\r\nWhen referenced: ""Type safety: The method get(Object) belongs to the raw type AtomicIntegerFieldUpdater. References to generic type AtomicIntegerFieldUpdater<T> should be parameterized""', 'commenter': 'sebthom'}]"
2912,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -1604,9 +1602,11 @@ public long getDurableScheduledSize() {
 
       for (String lingerSessionId : lingerSessionIds) {
          ServerSession serverSession = server.getSessionByID(lingerSessionId);
-         List<MessageReference> refs = serverSession == null ? null : serverSession.getInTxLingerMessages();
-         if (refs != null && !refs.isEmpty()) {
-            mapReturn.put(serverSession.toManagementString(), refs);
+         if (serverSession != null) {
+            List<MessageReference> refs = serverSession.getInTxLingerMessages();","[{'comment': ""I believe there's one semantic change on your change here.\r\n\r\nI think it's possible that getInTxLingerMessages() may return null,\r\nso, you changed serverSession != null, but you stopped verifying the actual result. this may cause NPE and tests breaks."", 'commenter': 'clebertsuconic'}, {'comment': 'your code change may get more complex here than the intended cleanup. I would leave this one, unless you have a creative choise.', 'commenter': 'clebertsuconic'}]"
2913,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ActiveMQServerImpl.java,"@@ -294,7 +294,7 @@
 
    private FileStoreMonitor fileStoreMonitor;
 
-   private final Map<String, ServerSession> sessions = new ConcurrentHashMap<>();
+   private final ConcurrentMap<String, ServerSession> sessions = new ConcurrentHashMap<>();","[{'comment': 'Can a perf test or some other benefit for this change be provided. This is core parts of the broker where historically concurrent issues introduced by such small changes have had tragic effects. Comment is about whole pr with removal of method level syncs', 'commenter': 'michaelandrepearce'}, {'comment': '@michaelandrepearce I tried to explain the reasoning for the change as part of the Jira issue, have you read that already?', 'commenter': 'sebthom'}, {'comment': 'So our concerns are this is in core. Its an un-proven optimization, that without any proven hot path benefit brings alot of risk, as small changes like this have previously introduced unexpected issues at first not obvious. As such the perf benefit needs to be proven by provided perf testing to be worth even that risk.', 'commenter': 'michaelandrepearce'}, {'comment': ""ATM I am not really sure how I can provide a perf test for the effect in the webconsole.\r\n\r\nThe getSessions() methods are only used by the ActiveMQServerControlImpl and the ConnectionView class to list session attributes or to close a session manually, so I can't see how removing the synchronized keyword from these methods can affect the performance of the hot path negatively.\r\n\r\nAlso if this synchronization really is required than something else must already be broken here since ActiveMQServerImpl.removeSession(), ActiveMQServerImpl.createSession() and ActiveMQServerImpl.getSessionByID() access/modify the sessions map without synchronizing on `this`.\r\n\r\nSo even without a perf test I would argue something should be changed, either createSession/getSessionByID/removeSession also need to synchronize on `this` or the `synchronized` keyword on `getSessions()` methods is useless.\r\n"", 'commenter': 'sebthom'}, {'comment': '@michaelandrepearce I attached a testcase to the JIRA issue where I try to highlight the impact of this PR. I hope this satisfies your request.', 'commenter': 'sebthom'}, {'comment': 'So idea is to include test cases etc in PRs so they live in the repo', 'commenter': 'michaelpearce-gain'}]"
2950,artemis-commons/src/main/java/org/apache/activemq/artemis/utils/collections/TypedProperties.java,"@@ -372,6 +372,79 @@ private synchronized void forEachInternal(BiConsumer<SimpleString, PropertyValue
       }
    }
 
+   /**
+    * Performs a search among the valid key properties contained in {@code buffer}, starting from {@code from}
+    * assuming it to be a valid encoded {@link TypedProperties} content.
+    *
+    * @throws IllegalStateException if any not-valid property is found while searching the {@code key} property
+    */
+   public static boolean searchProperty(SimpleString key, ByteBuf buffer, int startIndex) {","[{'comment': ""wouldn't be less costly to just lookup for the sequence of bytes?\r\n\r\nYou're still parsing the key at its exact position.\r\n\r\nif just looking for the sequence , say _HDR_SQUEDULED_TIME anywhere in the buffer would be enough.\r\n\r\nnow if the search is more costly than the partial parsing, then it's fine.\r\n\r\nAt least you're not reading the string to verify the equal object.\r\n\r\n\r\nif this was C, you would control to reuse the same integer every time, but in Java every time you do buffer.getInt(index) you will create a few bytes in memory."", 'commenter': 'clebertsuconic'}, {'comment': 'I have added a comment about this and the risk is to find a value that matches the property we are searching for. The other reason is that we know how many bytes to skip by using the decoded info and would help to reach quicker what we need without comparing every single byte (including values)', 'commenter': 'franz1981'}, {'comment': 'if you could name this as hasProperty(SimpleString key).\r\n\r\nsince you use the parsed property if the buffer is not parsed already.', 'commenter': 'clebertsuconic'}, {'comment': 'I will change it for sure :+1', 'commenter': 'franz1981'}, {'comment': '>> ""the risk is to find a value that matches the property we are searching for""\r\n\r\nSo what? if someone uses the key as the value, all it will incur is for us to do the older semantic, which is to parse the whole buffer. and we would incur in the old semantic.\r\n\r\n\r\nAdd a test with the value as the key, just to make sure.. although I doubt someone will use the property _HDR_SCHEDULED_TIME anywhere in the values :) and if they did it would still be fine.', 'commenter': 'clebertsuconic'}, {'comment': ""what I mean is.. if searching the whole buffer  like a string chain is faster.. just go for it.. don't worry about values as keys."", 'commenter': 'clebertsuconic'}, {'comment': 'But is not faster according my tests...in one case we perform more comparisons... ', 'commenter': 'franz1981'}, {'comment': ""Re your comments\r\n\r\n> You're still parsing the key at its exact position.\r\n\r\nIt's comparing, but it's not parsing (there is no decoding involved). \r\nIn additon, to compare `SimpleString` and `ByteBuf` is using another optimized method I've implemented some time ago that allow to compare them very quickly directly ie https://github.com/apache/activemq-artemis/blob/0293d8057441e6bfeb9e6533774862ffc86d74eb/artemis-commons/src/main/java/org/apache/activemq/artemis/utils/ByteUtil.java#L346-L360\r\n\r\n> in Java every time you do buffer.getInt(index) you will create a few bytes in memory.\r\n\r\nThat's the signature of the Netty method: https://netty.io/4.0/api/io/netty/buffer/ByteBuf.html#getInt-int-\r\n\r\nit would return a primitive `int`: it's not allocating anything. I've taken care to design that method to be garbage-free :+1: "", 'commenter': 'franz1981'}]"
2954,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireMessageConverter.java,"@@ -610,7 +613,7 @@ private static ActiveMQMessage toAMQMessage(MessageReference reference,
          amqMsg.setCorrelationId(corrId.toString());
       }
 
-      final byte[] dsBytes = (byte[]) coreMessage.getObjectProperty(AMQ_MSG_DATASTRUCTURE);
+      final byte[] dsBytes = getBytesPropertyOrNull(coreMessage, AMQ_MSG_DATASTRUCTURE);","[{'comment': ""This would been either a mistake from the user, or someone maliciously trying to break things. \r\n\r\nshouldn't you log such condition instead of silently failing?\r\n\r\nor perhaps I would prefer rejecting the message and sending an error to the client, meaning the previous semantic was probably ok?"", 'commenter': 'clebertsuconic'}, {'comment': 'I thought about this, but this actually came out from a legitimate use case as described in the Jira:\r\n1. Send a message to the broker using OpenWire client\r\n2. Consume that message using AMQP client\r\n3. Send that message back to the broker using AMQP client\r\n\r\nConsidering the previous use case, at which level you would log?\r\n ', 'commenter': 'fvaleri'}, {'comment': 'Definitely log.warn', 'commenter': 'clebertsuconic'}, {'comment': '>>Send a message to the broker using OpenWire client\r\n\r\nPerhaps we could fix whatever conversion made that happen?', 'commenter': 'clebertsuconic'}, {'comment': '> > > Send a message to the broker using OpenWire client\r\n> \r\n> Perhaps we could fix whatever conversion made that happen?\r\n\r\nAgree. I think the problem is located in the AMQP module but it needs more investigation. Can we create another Jira for that and release this fix?', 'commenter': 'fvaleri'}]"
2954,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireMessageConverter.java,"@@ -963,4 +966,13 @@ private static void setAMQMsgObjectProperties(final ActiveMQMessage amqMsg,
          }
       }
    }
+
+   private static byte[] getBytesPropertyOrNull(ICoreMessage coreMessage, SimpleString property) {
+      try {
+         return coreMessage.getBytesProperty(property);
+      } catch (ActiveMQPropertyConversionException e) {
+         LOG.warnf(""%s"", e.getMessage());","[{'comment': 'should be a explicit and coded log entry.', 'commenter': 'michaelandrepearce'}]"
2954,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireMessageConverter.java,"@@ -963,4 +966,13 @@ private static void setAMQMsgObjectProperties(final ActiveMQMessage amqMsg,
          }
       }
    }
+
+   private static byte[] getBytesPropertyOrNull(ICoreMessage coreMessage, SimpleString property) {
+      try {
+         return coreMessage.getBytesProperty(property);","[{'comment': ""this shouldn't be catching property conversion exception, instead it should check if coremessage has property and return null, should still be allowing ActiveMQPropertyConversionException to propagate up if there's an actual conversion issue."", 'commenter': 'michaelandrepearce'}]"
2954,artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/converter/AmqpCoreConverter.java,"@@ -308,9 +308,7 @@ private static ServerJMSMessage processApplicationProperties(ServerJMSMessage jm
    private static ServerJMSMessage processExtraProperties(ServerJMSMessage jms, TypedProperties properties) {
       if (properties != null) {
          properties.forEach((k, v) -> {
-            if (!k.equals(AMQPMessage.ADDRESS_PROPERTY)) {","[{'comment': 'why?', 'commenter': 'clebertsuconic'}, {'comment': 'my fault, let me fix this', 'commenter': 'fvaleri'}]"
2954,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenwireMessage.java,"@@ -30,8 +30,7 @@
 
 import io.netty.buffer.ByteBuf;
 
-// TODO: Implement this
-public class OpenwireMessage implements Message {
+public class OpenWireMessage implements Message {","[{'comment': ""you didn't need to change this.. I would keep your changes to a minimal.. only what you really need."", 'commenter': 'clebertsuconic'}, {'comment': 'ok', 'commenter': 'fvaleri'}]"
2954,artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/converter/AmqpCoreConverter.java,"@@ -477,7 +477,7 @@ private static void setProperty(javax.jms.Message msg, String key, Object value)
       } else if (value instanceof Decimal32) {
          msg.setFloatProperty(key, ((Decimal32) value).floatValue());
       } else if (value instanceof Binary) {
-         msg.setStringProperty(key, value.toString());
+         msg.setObjectProperty(key, ((Binary) value).getArray());","[{'comment': ""This isn't a complete fix as the Binary value may contain a subsequence of some other array value possibly a slice from another buffer owned by someone else so you need to copy this if the Binary has an array offset or relative length value that doesn't match the underlying array otherwise you end up with a value on the other side that doesn't match the original scoped array contents.  "", 'commenter': 'tabish121'}, {'comment': ""Hi @tabish121 , thank you for this note. I fixed this, please let me know if it's fine now."", 'commenter': 'fvaleri'}]"
2954,tests/integration-tests/src/test/java/org/apache/activemq/artemis/tests/integration/crossprotocol/AMQPResenderToOpenwireTest.java,"@@ -0,0 +1,158 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.tests.integration.crossprotocol;
+
+import javax.jms.Connection;
+import javax.jms.Message;
+import javax.jms.MessageConsumer;
+import javax.jms.MessageProducer;
+import javax.jms.Queue;
+import javax.jms.Session;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.activemq.ActiveMQConnectionFactory;
+import org.apache.activemq.artemis.api.core.RoutingType;
+import org.apache.activemq.artemis.api.core.SimpleString;
+import org.apache.activemq.artemis.core.config.Configuration;
+import org.apache.activemq.artemis.core.server.ActiveMQServer;
+import org.apache.activemq.artemis.core.settings.impl.AddressSettings;
+import org.apache.activemq.artemis.tests.util.ActiveMQTestBase;
+import org.apache.qpid.jms.JmsConnectionFactory;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+public class AMQPResenderToOpenwireTest extends ActiveMQTestBase {
+
+   private static final String OPENWIRE_URL = ""tcp://localhost:61616"";
+   private static final String AMQP_URL = ""amqp://localhost:61616"";
+
+   private ActiveMQServer server;
+   private ActiveMQConnectionFactory factory;
+   private JmsConnectionFactory qpidFactory;
+
+   private String queueZeroName = ""queue.zero"";
+   private String queueOneName = ""queue.one"";
+
+   @Override
+   @Before
+   public void setUp() throws Exception {
+      super.setUp();
+      server = createServer(true, true);
+
+      factory = new ActiveMQConnectionFactory(OPENWIRE_URL);
+      qpidFactory = new JmsConnectionFactory(AMQP_URL);
+
+      Configuration serverConfig = server.getConfiguration();
+      serverConfig.getAddressesSettings().put(""#"", new AddressSettings().setAutoCreateQueues(true)
+            .setAutoCreateAddresses(true).setDeadLetterAddress(new SimpleString(""ActiveMQ.DLQ"")));
+      serverConfig.setSecurityEnabled(false);
+      server.start();
+
+      SimpleString coreQueueZero = new SimpleString(queueZeroName);
+      server.createQueue(coreQueueZero, RoutingType.ANYCAST, coreQueueZero, null, false, false);
+
+      SimpleString coreQueueOne = new SimpleString(queueOneName);
+      server.createQueue(coreQueueOne, RoutingType.ANYCAST, coreQueueOne, null, false, false);
+   }
+
+   @Override
+   @After
+   public void tearDown() throws Exception {
+      if (server != null) {
+         server.stop();
+         server = null;
+      }
+   }
+
+   @Test(timeout = 60_000)
+   public void openwireInternalBinaryPropertiesShouldBeResentAsByteArrays() throws Exception {","[{'comment': ""it wouldn't been more deterministic and simpler to make it single threaded? I know that's not reproducing a client behaviour (that should span different machines anyway), but it would make the timing lot more deterministic"", 'commenter': 'franz1981'}, {'comment': 'good point, let me explore this suggestion', 'commenter': 'fvaleri'}, {'comment': '@franz1981 is correct here, there is simply no need to make this a multi threaded test that requires more overhead and time vs just creating two methods that take a connection factory one the sends and one that receives and then test that messages sent from one protocol are received by another they contain the expected message body data types.  There are plenty of existing test cases in the AMQP integrations tests that do this sort of thing already ', 'commenter': 'tabish121'}]"
2954,tests/integration-tests/src/test/java/org/apache/activemq/artemis/tests/integration/crossprotocol/AMQPResenderToOpenwireTest.java,"@@ -0,0 +1,158 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.tests.integration.crossprotocol;
+
+import javax.jms.Connection;
+import javax.jms.Message;
+import javax.jms.MessageConsumer;
+import javax.jms.MessageProducer;
+import javax.jms.Queue;
+import javax.jms.Session;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.activemq.ActiveMQConnectionFactory;
+import org.apache.activemq.artemis.api.core.RoutingType;
+import org.apache.activemq.artemis.api.core.SimpleString;
+import org.apache.activemq.artemis.core.config.Configuration;
+import org.apache.activemq.artemis.core.server.ActiveMQServer;
+import org.apache.activemq.artemis.core.settings.impl.AddressSettings;
+import org.apache.activemq.artemis.tests.util.ActiveMQTestBase;
+import org.apache.qpid.jms.JmsConnectionFactory;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+public class AMQPResenderToOpenwireTest extends ActiveMQTestBase {
+
+   private static final String OPENWIRE_URL = ""tcp://localhost:61616"";
+   private static final String AMQP_URL = ""amqp://localhost:61616"";
+
+   private ActiveMQServer server;
+   private ActiveMQConnectionFactory factory;
+   private JmsConnectionFactory qpidFactory;
+
+   private String queueZeroName = ""queue.zero"";
+   private String queueOneName = ""queue.one"";
+
+   @Override
+   @Before
+   public void setUp() throws Exception {
+      super.setUp();
+      server = createServer(true, true);
+
+      factory = new ActiveMQConnectionFactory(OPENWIRE_URL);
+      qpidFactory = new JmsConnectionFactory(AMQP_URL);
+
+      Configuration serverConfig = server.getConfiguration();
+      serverConfig.getAddressesSettings().put(""#"", new AddressSettings().setAutoCreateQueues(true)
+            .setAutoCreateAddresses(true).setDeadLetterAddress(new SimpleString(""ActiveMQ.DLQ"")));
+      serverConfig.setSecurityEnabled(false);
+      server.start();
+
+      SimpleString coreQueueZero = new SimpleString(queueZeroName);
+      server.createQueue(coreQueueZero, RoutingType.ANYCAST, coreQueueZero, null, false, false);
+
+      SimpleString coreQueueOne = new SimpleString(queueOneName);
+      server.createQueue(coreQueueOne, RoutingType.ANYCAST, coreQueueOne, null, false, false);
+   }
+
+   @Override
+   @After
+   public void tearDown() throws Exception {
+      if (server != null) {
+         server.stop();
+         server = null;
+      }
+   }
+
+   @Test(timeout = 60_000)
+   public void openwireInternalBinaryPropertiesShouldBeResentAsByteArrays() throws Exception {
+      final List<Throwable> errors = new LinkedList<>();
+      final ExecutorService executor = Executors.newFixedThreadPool(2);
+      final CountDownLatch resenderReady = new CountDownLatch(1);
+
+      // AMQP resender
+      executor.execute(new Runnable() {
+         @Override
+         public void run() {
+            try {
+
+               Connection connection = qpidFactory.createConnection();
+               Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+
+               Queue queueZero = session.createQueue(queueZeroName);
+               Queue queueOne = session.createQueue(queueOneName);
+
+               MessageConsumer consumer = session.createConsumer(queueZero);
+               connection.start();
+               resenderReady.countDown();
+               Message message = consumer.receive();
+               assertNotNull(message);
+
+               MessageProducer producer = session.createProducer(queueOne);
+               producer.send(message);
+
+               connection.close();
+
+            } catch (Exception e) {
+               errors.add(e);
+            }
+         }
+      });
+
+      // OpenWire client
+      executor.execute(new Runnable() {
+         @Override
+         public void run() {
+            try {
+
+               Connection connection = factory.createConnection();
+               Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+
+               Queue queueZero = session.createQueue(queueZeroName);
+               Queue queueOne = session.createQueue(queueOneName);
+
+               MessageProducer producer = session.createProducer(queueZero);
+               Message testMessage = session.createTextMessage(""test"");
+               resenderReady.await(20, TimeUnit.SECONDS);","[{'comment': 'Why do you need to wait for resenderReady?', 'commenter': 'brusdev'}, {'comment': 'yes, I think it can be avoided, let me do some tests before removing it', 'commenter': 'fvaleri'}]"
2954,tests/integration-tests/src/test/java/org/apache/activemq/artemis/tests/integration/crossprotocol/AMQPResenderToOpenwireTest.java,"@@ -0,0 +1,158 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.tests.integration.crossprotocol;
+
+import javax.jms.Connection;
+import javax.jms.Message;
+import javax.jms.MessageConsumer;
+import javax.jms.MessageProducer;
+import javax.jms.Queue;
+import javax.jms.Session;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.activemq.ActiveMQConnectionFactory;
+import org.apache.activemq.artemis.api.core.RoutingType;
+import org.apache.activemq.artemis.api.core.SimpleString;
+import org.apache.activemq.artemis.core.config.Configuration;
+import org.apache.activemq.artemis.core.server.ActiveMQServer;
+import org.apache.activemq.artemis.core.settings.impl.AddressSettings;
+import org.apache.activemq.artemis.tests.util.ActiveMQTestBase;
+import org.apache.qpid.jms.JmsConnectionFactory;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+public class AMQPResenderToOpenwireTest extends ActiveMQTestBase {
+
+   private static final String OPENWIRE_URL = ""tcp://localhost:61616"";
+   private static final String AMQP_URL = ""amqp://localhost:61616"";
+
+   private ActiveMQServer server;
+   private ActiveMQConnectionFactory factory;
+   private JmsConnectionFactory qpidFactory;
+
+   private String queueZeroName = ""queue.zero"";
+   private String queueOneName = ""queue.one"";
+
+   @Override
+   @Before
+   public void setUp() throws Exception {
+      super.setUp();
+      server = createServer(true, true);
+
+      factory = new ActiveMQConnectionFactory(OPENWIRE_URL);
+      qpidFactory = new JmsConnectionFactory(AMQP_URL);
+
+      Configuration serverConfig = server.getConfiguration();
+      serverConfig.getAddressesSettings().put(""#"", new AddressSettings().setAutoCreateQueues(true)
+            .setAutoCreateAddresses(true).setDeadLetterAddress(new SimpleString(""ActiveMQ.DLQ"")));
+      serverConfig.setSecurityEnabled(false);
+      server.start();
+
+      SimpleString coreQueueZero = new SimpleString(queueZeroName);
+      server.createQueue(coreQueueZero, RoutingType.ANYCAST, coreQueueZero, null, false, false);
+
+      SimpleString coreQueueOne = new SimpleString(queueOneName);
+      server.createQueue(coreQueueOne, RoutingType.ANYCAST, coreQueueOne, null, false, false);
+   }
+
+   @Override
+   @After
+   public void tearDown() throws Exception {
+      if (server != null) {
+         server.stop();
+         server = null;
+      }
+   }
+
+   @Test(timeout = 60_000)
+   public void openwireInternalBinaryPropertiesShouldBeResentAsByteArrays() throws Exception {
+      final List<Throwable> errors = new LinkedList<>();
+      final ExecutorService executor = Executors.newFixedThreadPool(2);
+      final CountDownLatch resenderReady = new CountDownLatch(1);
+
+      // AMQP resender
+      executor.execute(new Runnable() {
+         @Override
+         public void run() {
+            try {
+
+               Connection connection = qpidFactory.createConnection();
+               Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+
+               Queue queueZero = session.createQueue(queueZeroName);
+               Queue queueOne = session.createQueue(queueOneName);
+
+               MessageConsumer consumer = session.createConsumer(queueZero);
+               connection.start();
+               resenderReady.countDown();
+               Message message = consumer.receive();
+               assertNotNull(message);
+
+               MessageProducer producer = session.createProducer(queueOne);
+               producer.send(message);
+
+               connection.close();
+
+            } catch (Exception e) {
+               errors.add(e);
+            }
+         }
+      });
+
+      // OpenWire client
+      executor.execute(new Runnable() {
+         @Override
+         public void run() {
+            try {
+
+               Connection connection = factory.createConnection();
+               Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+
+               Queue queueZero = session.createQueue(queueZeroName);
+               Queue queueOne = session.createQueue(queueOneName);
+
+               MessageProducer producer = session.createProducer(queueZero);
+               Message testMessage = session.createTextMessage(""test"");
+               resenderReady.await(20, TimeUnit.SECONDS);
+               producer.send(testMessage);
+
+               MessageConsumer consumer = session.createConsumer(queueOne);
+               connection.start();
+               Message receivedMessage = consumer.receive();
+               assertNotNull(receivedMessage);
+
+               connection.close();
+
+            } catch (Exception e) {
+               errors.add(e);
+            }
+         }
+      });
+
+      executor.shutdown();
+      executor.awaitTermination(20, TimeUnit.SECONDS);","[{'comment': 'Can you reduce this timeout?', 'commenter': 'brusdev'}, {'comment': 'I guess it can be reduced, will do after some testing', 'commenter': 'fvaleri'}]"
3021,tests/integration-tests/src/test/java/org/apache/activemq/artemis/tests/integration/amqp/paging/AmqpPageReaderTest.java,"@@ -0,0 +1,83 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.tests.integration.amqp.paging;
+
+import org.apache.activemq.artemis.api.core.ActiveMQBuffer;
+import org.apache.activemq.artemis.api.core.ActiveMQBuffers;
+import org.apache.activemq.artemis.api.core.Message;
+import org.apache.activemq.artemis.api.core.SimpleString;
+import org.apache.activemq.artemis.core.paging.cursor.impl.PageReaderTest;
+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPStandardMessage;
+import org.apache.activemq.artemis.spi.core.protocol.MessagePersister;
+import org.apache.activemq.artemis.tests.integration.amqp.AmqpTestSupport;
+import org.apache.activemq.transport.amqp.client.AmqpMessage;
+import org.apache.qpid.proton.message.impl.MessageImpl;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class AmqpPageReaderTest extends PageReaderTest {
+
+   public MessageImpl createProtonMessage(String address) {
+      AmqpMessage message = new AmqpMessage();
+      final StringBuilder builder = new StringBuilder();
+      for (int i = 0; i < 1000; i++) {
+         builder.append('0');
+      }
+      final String data = builder.toString();
+      message.setText(data);
+      message.setAddress(address);
+      message.setDurable(true);
+
+      MessageImpl protonMessage = (MessageImpl) message.getWrappedMessage();
+
+      return protonMessage;
+   }
+
+   @Override
+   protected Message createMessage(SimpleString address, int msgId, byte[] content) {
+      MessageImpl protonMessage = createProtonMessage(address.toString());
+      AMQPStandardMessage amqpStandardMessage =  AmqpTestSupport.encodeAndDecodeMessage(0, protonMessage, 2 * 1024);
+      amqpStandardMessage.setMessageID(msgId);
+
+      return amqpStandardMessage;
+   }
+
+
+   @Test
+   public void testEncodeSize() throws Exception {
+
+      Message message = createMessage(SimpleString.toSimpleString(""Test""), 1, new byte[10]);
+
+      MessagePersister persister = (MessagePersister)message.getPersister();
+
+      ActiveMQBuffer buffer = ActiveMQBuffers.dynamicBuffer(1024);
+      persister.encode(buffer, message);
+
+      Assert.assertEquals(persister.getEncodeSize(message), buffer.writerIndex());
+
+      // the very first byte is the persisterID, we skip that since we are calling the Persister directly
+      buffer.readerIndex(1);
+      Message messageRead = persister.decode(buffer, null, null);
+
+      // The current persister does not guarantee the same encode size after loading
+      // and it does not need to
+      // Assert.assertEquals(persister.getEncodeSize(message), persister.getEncodeSize(messageRead));","[{'comment': 'This test class should be cleaned up a bit ', 'commenter': 'franz1981'}, {'comment': 'I intended to keep it commented out, as it would fail if commented out.. nothing to be cleaned.', 'commenter': 'clebertsuconic'}]"
3021,artemis-server/src/main/java/org/apache/activemq/artemis/core/paging/cursor/impl/PageSubscriptionImpl.java,"@@ -1357,7 +1357,7 @@ private PagedReference moveNext() {
                   break;
                }
 
-               int nextFileOffset = message.getPosition().getFileOffset() == -1 ? -1 : message.getPosition().getFileOffset() + message.getPagedMessage().getEncodeSize() + Page.SIZE_RECORD;
+               int nextFileOffset = message.getPosition().getFileOffset() == -1 ? -1 : message.getPosition().getFileOffset() + message.getPagedMessage().getStoredSize() + Page.SIZE_RECORD;","[{'comment': 'I would encapsulate this computation as part of `PagedMessage` or `PagePosition` , possibly adding a test', 'commenter': 'franz1981'}, {'comment': 'I agree, and I raised that with you. but this is not part of my change here though. this could be a different PR.', 'commenter': 'clebertsuconic'}]"
3021,artemis-server/src/main/java/org/apache/activemq/artemis/core/paging/impl/PagedMessageImpl.java,"@@ -59,8 +61,19 @@ public PagedMessageImpl(final Message message, final long[] queueIDs) {
       this.message = message;
    }
 
-   public PagedMessageImpl(StorageManager storageManager) {
+   public PagedMessageImpl(int storedSize, StorageManager storageManager) {
       this.storageManager = storageManager;
+      this.storedSize = storedSize;
+   }
+
+
+   @Override
+   public int getStoredSize() {
+      if (storedSize <= 0) {","[{'comment': ""Instead of using this logic, woudn't simpler to correctly initialize `storedSize` for both protocols: for core `== encodeSize`, for AMQP, using a different value?"", 'commenter': 'franz1981'}, {'comment': ""I am not sure it's safe to do that in case the encodeSize changed between the contruction and when getStoredSize is used.\r\n\r\nWe can change this If you're sure it's safe. I wasn't bold enough."", 'commenter': 'clebertsuconic'}, {'comment': ""> We can change this If you're sure it's safe. I wasn't bold enough.\r\n\r\nAgree, I'm not sure of it as well (let me check around on the code) "", 'commenter': 'franz1981'}]"
3021,artemis-server/src/main/java/org/apache/activemq/artemis/core/paging/impl/PagedMessageImpl.java,"@@ -47,6 +47,8 @@
 
    private long transactionID = 0;
 
+   private int storedSize = 0;","[{'comment': 'If it cannot change anymore, I would make it `final` instead', 'commenter': 'franz1981'}, {'comment': ""I didn't think it was final.. I thought I was going to have a setter when I wrote this.. changing it."", 'commenter': 'clebertsuconic'}]"
3021,artemis-server/src/test/java/org/apache/activemq/artemis/core/paging/cursor/impl/PageReaderTest.java,"@@ -58,7 +58,7 @@ public void testPageReadMessage() throws Exception {
             PagePosition pagePosition = new PagePositionImpl(10, i);
             pagedMessage = pageReader.getMessage(pagePosition);
          } else {
-            int nextFileOffset = pagedMessage == null ? -1 : offsets[i - 1] + pagedMessage.getEncodeSize() + Page.SIZE_RECORD;
+            int nextFileOffset = pagedMessage == null ? -1 : offsets[i - 1] + pagedMessage.getStoredSize() + Page.SIZE_RECORD;","[{'comment': ""I don't know why, but my IDEA isn't happy with this test, see\r\n![image](https://user-images.githubusercontent.com/13125299/76842129-1486ec80-683a-11ea-8c10-3d48418c9bdf.png)\r\nAlthough I can run it and it compiles correctly...:("", 'commenter': 'franz1981'}, {'comment': 'PageReaderTest is from a different testsuite. IDEA may not like it.', 'commenter': 'clebertsuconic'}, {'comment': ""It's not that simple to move this test. it uses a lot of package private methods.. moving would need to make them public or a bigger refactoring.\r\n\r\nI had a version where I did this at some point. I would go for the simpler version now in case we ever need to cherry-pick to a point release."", 'commenter': 'clebertsuconic'}, {'comment': ""> PageReaderTest is from a different testsuite. IDEA may not like it.\r\n\r\nWhat's strange is that I rememeber while doing it the same (basically same code) IDEA wasn't complaining that much, but is really a minor eh, can be ignored"", 'commenter': 'franz1981'}]"
3041,artemis-commons/src/main/java/org/apache/activemq/artemis/utils/actors/ProcessorBase.java,"@@ -99,45 +98,23 @@ public void shutdown(long timeout, TimeUnit unit) {
       }
    }
 
-   /**
-    * It will wait the current execution (if there is one) to finish
-    * but will not complete any further executions
-    */
+   /** It will shutdown the executor however it will not wait for finishing tasks*/
    public int shutdownNow(Consumer<? super T> onPendingItem) {
       //alert anyone that has been requested (at least) an immediate shutdown
       requestedForcedShutdown = true;
       requestedShutdown = true;
 
-      if (inHandler()) {
-         stateUpdater.set(this, STATE_FORCED_SHUTDOWN);
-      } else {
-         //it could take a very long time depending on the current executing task
-         do {
-            //alert the ExecutorTask (if is running) to just drain the current backlog of tasks
-            final int startState = stateUpdater.get(this);
-            if (startState == STATE_FORCED_SHUTDOWN) {
-               //another thread has completed a forced shutdown: let it to manage the tasks cleanup
-               break;
-            }
-            if (startState == STATE_RUNNING) {
-               //wait 100 ms to avoid burning CPU while waiting and
-               //give other threads a chance to make progress
-               LockSupport.parkNanos(100_000_000L);
-            }
-         }
-         while (!stateUpdater.compareAndSet(this, STATE_NOT_RUNNING, STATE_FORCED_SHUTDOWN));
-         //this could happen just one time: the forced shutdown state is the last one and
-         //can be set by just one caller.
-         //As noted on the execute method there is a small chance that some tasks would be enqueued
+      if (!inHandler()) {
+         flush(1, TimeUnit.SECONDS);","[{'comment': 'I would use some named const somewhere to help understand why is 1 second', 'commenter': 'franz1981'}, {'comment': 'I was afraid of failures on the testsuite. In a production system the component would be going down anyways.\r\n\r\n\r\nI will try to remove the condition for good.', 'commenter': 'clebertsuconic'}]"
3041,artemis-commons/src/main/java/org/apache/activemq/artemis/utils/actors/ProcessorBase.java,"@@ -99,45 +98,23 @@ public void shutdown(long timeout, TimeUnit unit) {
       }
    }
 
-   /**
-    * It will wait the current execution (if there is one) to finish
-    * but will not complete any further executions
-    */
+   /** It will shutdown the executor however it will not wait for finishing tasks*/
    public int shutdownNow(Consumer<? super T> onPendingItem) {
       //alert anyone that has been requested (at least) an immediate shutdown
       requestedForcedShutdown = true;
       requestedShutdown = true;
 
-      if (inHandler()) {
-         stateUpdater.set(this, STATE_FORCED_SHUTDOWN);
-      } else {
-         //it could take a very long time depending on the current executing task
-         do {
-            //alert the ExecutorTask (if is running) to just drain the current backlog of tasks
-            final int startState = stateUpdater.get(this);
-            if (startState == STATE_FORCED_SHUTDOWN) {
-               //another thread has completed a forced shutdown: let it to manage the tasks cleanup
-               break;
-            }
-            if (startState == STATE_RUNNING) {
-               //wait 100 ms to avoid burning CPU while waiting and
-               //give other threads a chance to make progress
-               LockSupport.parkNanos(100_000_000L);
-            }
-         }
-         while (!stateUpdater.compareAndSet(this, STATE_NOT_RUNNING, STATE_FORCED_SHUTDOWN));
-         //this could happen just one time: the forced shutdown state is the last one and
-         //can be set by just one caller.
-         //As noted on the execute method there is a small chance that some tasks would be enqueued
+      if (!inHandler()) {
+         flush(1, TimeUnit.SECONDS);
       }
+
+      stateUpdater.set(this, STATE_FORCED_SHUTDOWN);
       int pendingItems = 0;
-      //there is a small chance that execute() could race with this cleanup: the lock allow an all-or-nothing behaviour between them
-      synchronized (tasks) {
-         T item;
-         while ((item = tasks.poll()) != null) {
-            onPendingItem.accept(item);
-            pendingItems++;
-         }
+
+      T item;
+      while ((item = tasks.poll()) != null) {","[{'comment': 'the synchronize was there for 2 reasons: \r\n\r\n1. if we would have started using some multi-producer single-consume queue (the ones on JCTools for example...) \r\n2. onAddedTaskIfNotRunning is using a synchronize to allow all-or-nothing behaviour', 'commenter': 'franz1981'}, {'comment': 'I am removing the clear on onAddedTaskifNotRunning', 'commenter': 'clebertsuconic'}]"
3041,artemis-protocols/artemis-amqp-protocol/src/test/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerReceiverContextTest.java,"@@ -154,6 +160,8 @@ private void doOnMessageWithDeliveryException(List<Symbol> sourceSymbols,
 
       rc.onMessage(mockDelivery);
 
+      Thread.sleep(1000);","[{'comment': ""that's safe in any env?"", 'commenter': 'franz1981'}, {'comment': 'I forgot to remove this sleep', 'commenter': 'clebertsuconic'}]"
3041,artemis-server/src/main/java/org/apache/activemq/artemis/core/persistence/impl/journal/OperationContextImpl.java,"@@ -43,6 +44,8 @@
  */
 public class OperationContextImpl implements OperationContext {
 
+   private static final Logger logger = Logger.getLogger(OperationContextImpl.class);","[{'comment': 'is this logger used?', 'commenter': 'brusdev'}]"
3167,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/qourum/QuorumVoteServerConnect.java,"@@ -141,7 +141,11 @@ public synchronized Boolean getDecision() {
       return votesNeeded == 0;
    }
 
-   public void await(int latchTimeout, TimeUnit unit) throws InterruptedException {
+   public void await(int latchTimeout, TimeUnit unit, int maxClusterSize) throws InterruptedException {","[{'comment': ""IMO this check should be moved into `QuorumManager`, given that:\r\n- `maxClusterSize` is already owned and managed by it\r\n- QuorumVoteServerConnect isn't aware of how many cluster members could perform the vote, just the expected number to unblock the quorum\r\n\r\n"", 'commenter': 'franz1981'}]"
3198,artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/handler/ProtonHandler.java,"@@ -276,12 +276,17 @@ private void actualFlush() {
                break;
             }
 
-            // We allocated a Pooled Direct Buffer, that will be sent down the stream
             ByteBuf buffer = PooledByteBufAllocator.DEFAULT.directBuffer(pending);
-            buffer.writeBytes(head);
+            try {
+               // We allocated a Pooled Direct Buffer, that will be sent down the stream
+               buffer.writeBytes(head);
 
-            for (EventHandler handler : handlers) {
-               handler.pushBytes(buffer);
+               for (EventHandler handler : handlers) {
+                  handler.pushBytes(buffer);
+               }
+            } finally {
+               // We need to release the buffer when it has been sent downstream
+               buffer.release();","[{'comment': ""I'm not sure about this: if this release would happen before the `ByteBuf` is being handled by some of the handler they will get a failure because the ByteBuf is released..."", 'commenter': 'franz1981'}, {'comment': 'actually, the tests are failing pretty badly with this change. look at the PR tests.', 'commenter': 'clebertsuconic'}, {'comment': 'Indeed test results do not look good, is the ci/cd harder on the tests for the ci/cd? I did a local build on the combined PRs we did today and they succeeded. Is the ci/cd heavier then when you ""mvn clean install"" it?', 'commenter': 'emagiz'}, {'comment': ""@emagiz I'm not sure about the CI/CD.. if you're talking about redhat's CI.. they are harder then the PR checks here actually."", 'commenter': 'clebertsuconic'}, {'comment': 'Ok, I tried with the mvn command from the automated build with the additional testing profiles and it fails on my laptop as well now. But I might just need to do a restart because it complains on CLI testcases where it complains about a process already using some file. That does not seem related to the patch.\r\n\r\nBut is the fix correct in the sense there is a release missing on this buffer which needs to be added somewhere (maybe not here, but somewhere?\r\n\r\nWe have been running this fix on an environment for a week and we have had no netty LEAK reports anymore (they started from version 2.11) and have noticed no issues related to data quality. But maybe we have a narrow case with very little coverage. If we remove this patch we get netty LEAK reports and the server crashed in around 6 hours because of no pooled direct buffer memory left to be used.\r\n\r\nSo if the assumption of the release call is correct, we can maybe change it. Something like: give all the handlers their own view and let them release it themselves. Would something like that be an option?', 'commenter': 'emagiz'}, {'comment': 'Hi @emagiz I think the PR https://github.com/apache/activemq-artemis/pull/3252 fix the issue you are seeing. it shoud be release as part of 2.16.0', 'commenter': 'ldebello'}]"
3204,artemis-jdbc-store/pom.xml,"@@ -81,6 +81,13 @@
          <version>${project.version}</version>
       </dependency>
 
+      <!-- Default DataSource for database -->
+      <dependency>
+         <groupId>org.apache.commons</groupId>
+         <artifactId>commons-dbcp2</artifactId>
+         <version>2.1.1</version>","[{'comment': 'please use a property based token here, like other dependencies', 'commenter': 'franz1981'}]"
3204,artemis-jdbc-store/src/main/java/org/apache/activemq/artemis/jdbc/store/file/Db2SequentialFileDriver.java,"@@ -30,33 +31,30 @@ public Db2SequentialFileDriver() {
       super();
    }
 
-   public Db2SequentialFileDriver(DataSource dataSource, SQLProvider provider) {
-      super(dataSource, provider);
-   }
-
-   public Db2SequentialFileDriver(Connection connection, SQLProvider provider) {
-      super(connection, provider);
+   public Db2SequentialFileDriver(JDBCConnectionProvider connectionProvider, SQLProvider provider) {
+      super(connectionProvider, provider);
    }
 
    @Override
-   protected void prepareStatements() throws SQLException {
-      this.deleteFile = connection.prepareStatement(sqlProvider.getDeleteFileSQL());
-      this.createFile = connection.prepareStatement(sqlProvider.getInsertFileSQL(), new String[]{""ID""});
-      this.selectFileByFileName = connection.prepareStatement(sqlProvider.getSelectFileByFileName());
-      this.copyFileRecord = connection.prepareStatement(sqlProvider.getCopyFileRecordByIdSQL());
-      this.renameFile = connection.prepareStatement(sqlProvider.getUpdateFileNameByIdSQL());
-      this.readLargeObject = connection.prepareStatement(sqlProvider.getReadLargeObjectSQL());
-      this.appendToLargeObject = connection.prepareStatement(sqlProvider.getAppendToLargeObjectSQL());
-      this.selectFileNamesByExtension = connection.prepareStatement(sqlProvider.getSelectFileNamesByExtensionSQL());
+   protected void prepareStatements() {
+      this.deleteFile = sqlProvider.getDeleteFileSQL();
+      this.createFile = sqlProvider.getInsertFileSQL();
+      this.createFileColumnNames = new String[]{""ID""};
+      this.selectFileByFileName = sqlProvider.getSelectFileByFileName();
+      this.copyFileRecord = sqlProvider.getCopyFileRecordByIdSQL();
+      this.renameFile = sqlProvider.getUpdateFileNameByIdSQL();
+      this.readLargeObject = sqlProvider.getReadLargeObjectSQL();
+      this.appendToLargeObject = sqlProvider.getAppendToLargeObjectSQL();
+      this.selectFileNamesByExtension = sqlProvider.getSelectFileNamesByExtensionSQL();
    }
 
    @Override
    public int writeToFile(JDBCSequentialFile file, byte[] data) throws SQLException {
       if (data == null || data.length == 0) {
          return 0;
       }
-      synchronized (connection) {
-         try {","[{'comment': 'One thought on this change, to have the same semantic, the connectionPool *must* have a max pool size of 1. That needs to be enforced.\r\nWith the original code, the entire jdbc operation is serialised on the connection, and that will only still hold if the connection pool blocks when it single entry is in use. ie: if it has a max pool size of 1.', 'commenter': 'gtully'}, {'comment': ""I've done this through the broker.xml config and completely forgot to enforce the max size in code if not configured. Will try to find a proper solution for this"", 'commenter': 'uomik'}, {'comment': ""@gtully \r\nI'm searching trough the `master` code base and although it seems that it's using a single database connection I'm not 100% sure of it: I will verify it tomorrow with a running broker tomorrow.\r\nProbably we've many JDBC connections opened (see `AbstractJDBCDriver` childrens -> journal(s), node manager and sequential file fatories)\r\nProbably there is no need to hard code such limit "", 'commenter': 'franz1981'}, {'comment': 'I did a quick check by just starting ""stock"" Artemis and it at least opens several connections to the database on startup. After a while it seems to settle down to two active connections. And I have to correct myself, I forgot that I actually decided to drop the setting form the configs as well as I came to conclusion that removing it has no negative effect. But correct me if I\'m wrong.', 'commenter': 'uomik'}]"
3204,artemis-jdbc-store/src/main/java/org/apache/activemq/artemis/jdbc/store/sql/PropertySQLProvider.java,"@@ -362,8 +363,12 @@ public Factory(SQLDialect dialect) {
          }
       }
 
-      public Factory(DataSource dataSource) {","[{'comment': ""Can't we keep this method and call this(new JDBCConnectionProvider(ds));"", 'commenter': 'ehsavoie'}, {'comment': '@uomik this is still missing in your latest changes', 'commenter': 'ehsavoie'}, {'comment': '@ehsavoie Fixed now. For some reason the commit did not make it to my last push.', 'commenter': 'uomik'}]"
3204,artemis-server/src/main/java/org/apache/activemq/artemis/core/paging/impl/PagingStoreFactoryDatabase.java,"@@ -106,8 +105,8 @@ public PagingStoreFactoryDatabase(final DatabaseStorageConfiguration dbConf,
                                      final ScheduledExecutorService scheduledExecutor,","[{'comment': 'I see that `JDBCSequentialFile directoryList` and `JDBCSequentialFileFactoryDriver dbDriver`  are not used as data members: can be removed', 'commenter': 'franz1981'}]"
3204,artemis-jdbc-store/src/main/java/org/apache/activemq/artemis/jdbc/store/file/PostgresLargeObjectManager.java,"@@ -56,31 +56,31 @@ public PostgresLargeObjectManager(Connection connection) throws SQLException {
       }
    }
 
-   public final Long createLO() throws SQLException {
+   public final Long createLO(Connection connection) throws SQLException {
       if (shouldUseReflection) {
-         Object largeObjectManager = getLargeObjectManager();
+         Object largeObjectManager = getLargeObjectManager(connection);
          try {
-            Method method = largeObjectManager.getClass().getMethod(""createLO"");
-            return (Long) method.invoke(largeObjectManager);
+            Method method = largeObjectManager.getClass().getMethod(""createLO"", Connection.class);
+            return (Long) method.invoke(largeObjectManager, connection);","[{'comment': 'connection is not a parameter of this method', 'commenter': 'ehsavoie'}]"
3204,artemis-jdbc-store/src/main/java/org/apache/activemq/artemis/jdbc/store/file/PostgresLargeObjectManager.java,"@@ -56,31 +56,31 @@ public PostgresLargeObjectManager(Connection connection) throws SQLException {
       }
    }
 
-   public final Long createLO() throws SQLException {
+   public final Long createLO(Connection connection) throws SQLException {
       if (shouldUseReflection) {
-         Object largeObjectManager = getLargeObjectManager();
+         Object largeObjectManager = getLargeObjectManager(connection);
          try {
-            Method method = largeObjectManager.getClass().getMethod(""createLO"");
-            return (Long) method.invoke(largeObjectManager);
+            Method method = largeObjectManager.getClass().getMethod(""createLO"", Connection.class);
+            return (Long) method.invoke(largeObjectManager, connection);
          } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
             throw new SQLException(""Couldn't access org.postgresql.largeobject.LargeObjectManager"", ex);
          }
       } else {
-         return ((PGConnection) realConnection).getLargeObjectAPI().createLO();
+         return ((PGConnection) unwrap(connection)).getLargeObjectAPI().createLO();
       }
    }
 
-   public Object open(long oid, int mode) throws SQLException {
+   public Object open(Connection connection, long oid, int mode) throws SQLException {
       if (shouldUseReflection) {
-         Object largeObjectManager = getLargeObjectManager();
+         Object largeObjectManager = getLargeObjectManager(connection);
          try {
-            Method method = largeObjectManager.getClass().getMethod(""open"", long.class, int.class);
-            return method.invoke(largeObjectManager, oid, mode);
+            Method method = largeObjectManager.getClass().getMethod(""open"", Connection.class, long.class, int.class);
+            return method.invoke(largeObjectManager, connection, oid, mode);","[{'comment': 'connection is not a parameter of this method', 'commenter': 'ehsavoie'}]"
3204,artemis-jdbc-store/src/main/java/org/apache/activemq/artemis/jdbc/store/file/PostgresSequentialSequentialFileDriver.java,"@@ -36,37 +36,32 @@ public PostgresSequentialSequentialFileDriver() throws SQLException {
       super();
    }
 
-   public PostgresSequentialSequentialFileDriver(DataSource dataSource, SQLProvider provider) {
+   public PostgresSequentialSequentialFileDriver(JDBCConnectionProvider connectionProvider, SQLProvider provider) {
       super();
-      this.setDataSource(dataSource);
-      this.setSqlProvider(provider);
-   }
-
-   public PostgresSequentialSequentialFileDriver(Connection connection, SQLProvider provider) {
-      super();
-      this.setConnection(connection);
+      this.setJdbcConnectionProvider(connectionProvider);
       this.setSqlProvider(provider);
    }
 
    @Override
-   protected void prepareStatements() throws SQLException {
-      this.largeObjectManager = new PostgresLargeObjectManager(connection);
-      this.deleteFile = connection.prepareStatement(sqlProvider.getDeleteFileSQL());
-      this.createFile = connection.prepareStatement(sqlProvider.getInsertFileSQL(), Statement.RETURN_GENERATED_KEYS);
-      this.selectFileByFileName = connection.prepareStatement(sqlProvider.getSelectFileByFileName());
-      this.copyFileRecord = connection.prepareStatement(sqlProvider.getCopyFileRecordByIdSQL());
-      this.renameFile = connection.prepareStatement(sqlProvider.getUpdateFileNameByIdSQL());
-      this.readLargeObject = connection.prepareStatement(sqlProvider.getReadLargeObjectSQL());
-      this.appendToLargeObject = connection.prepareStatement(sqlProvider.getAppendToLargeObjectSQL());
-      this.selectFileNamesByExtension = connection.prepareStatement(sqlProvider.getSelectFileNamesByExtensionSQL());
+   protected void prepareStatements() {
+      this.largeObjectManager = new PostgresLargeObjectManager();
+      this.deleteFile = sqlProvider.getDeleteFileSQL();
+      this.createFile = sqlProvider.getInsertFileSQL();
+      this.createFileAutogeneratedKeys = Statement.RETURN_GENERATED_KEYS;
+      this.selectFileByFileName = sqlProvider.getSelectFileByFileName();
+      this.copyFileRecord = sqlProvider.getCopyFileRecordByIdSQL();
+      this.renameFile = sqlProvider.getUpdateFileNameByIdSQL();
+      this.readLargeObject = sqlProvider.getReadLargeObjectSQL();
+      this.appendToLargeObject = sqlProvider.getAppendToLargeObjectSQL();
+      this.selectFileNamesByExtension = sqlProvider.getSelectFileNamesByExtensionSQL();
    }
 
    @Override
    public void createFile(JDBCSequentialFile file) throws SQLException {
-      synchronized (connection) {
-         try {
+      try (Connection connection = connectionProvider.getConnection()) {
+         try (PreparedStatement createFile = connection.prepareStatement(this.createFile)) {","[{'comment': 'you need to pass Statement.RETURN_GENERATED_KEYS as second argument (check line 55 on previous code)', 'commenter': 'ehsavoie'}]"
3204,artemis-jdbc-store/src/main/java/org/apache/activemq/artemis/jdbc/store/file/PostgresSequentialSequentialFileDriver.java,"@@ -132,10 +129,10 @@ public int writeToFile(JDBCSequentialFile file, byte[] data, boolean append) thr
    public int readFromFile(JDBCSequentialFile file, ByteBuffer bytes) throws SQLException {
       Object largeObject = null;
       long oid = getOID(file);
-      synchronized (connection) {
+      try (Connection connection = connectionProvider.getConnection()) {
          try {
             connection.setAutoCommit(false);
-            largeObject = largeObjectManager.open(oid, PostgresLargeObjectManager.READ);
+            largeObject = largeObjectManager.open(connection, oid, PostgresLargeObjectManager.READ);","[{'comment': 'We should declare the largeObject here instead of 4 lines before (even if that was how it was done before)', 'commenter': 'ehsavoie'}]"
3204,artemis-jdbc-store/src/main/java/org/apache/activemq/artemis/jdbc/store/file/PostgresSequentialSequentialFileDriver.java,"@@ -87,31 +82,33 @@ public void createFile(JDBCSequentialFile file) throws SQLException {
 
    @Override
    public void loadFile(JDBCSequentialFile file) throws SQLException {
-      synchronized (connection) {
-         connection.setAutoCommit(false);
-         readLargeObject.setLong(1, file.getId());
+      try (Connection connection = connectionProvider.getConnection()) {
+         try (PreparedStatement readLargeObject = connection.prepareStatement(this.readLargeObject)) {
+            connection.setAutoCommit(false);
+            readLargeObject.setLong(1, file.getId());
 
-         try (ResultSet rs = readLargeObject.executeQuery()) {
-            if (rs.next()) {
-               file.setWritePosition(getPostGresLargeObjectSize(file));
+            try (ResultSet rs = readLargeObject.executeQuery()) {
+               if (rs.next()) {
+                  file.setWritePosition(getPostGresLargeObjectSize(file));
+               }
+               connection.commit();
+            } catch (SQLException e) {
+               connection.rollback();
+               throw e;
             }
-            connection.commit();
-         } catch (SQLException e) {
-            connection.rollback();
-            throw e;
          }
       }
    }
 
    @Override
    public int writeToFile(JDBCSequentialFile file, byte[] data, boolean append) throws SQLException {
-      synchronized (connection) {
+      try (Connection connection = connectionProvider.getConnection()) {
          Object largeObject = null;
 
          Long oid = getOID(file);
          try {
             connection.setAutoCommit(false);
-            largeObject = largeObjectManager.open(oid, PostgresLargeObjectManager.WRITE);
+            largeObject = largeObjectManager.open(connection, oid, PostgresLargeObjectManager.WRITE);","[{'comment': 'We should declare the largeObject here instead of 4 lines before (even if that was how it was done before)', 'commenter': 'ehsavoie'}]"
3278,artemis-core-client/src/main/java/org/apache/activemq/artemis/utils/BufferHelper.java,"@@ -16,8 +16,10 @@
  */
 package org.apache.activemq.artemis.utils;
 
+import io.netty.buffer.ByteBufUtil;
 import org.apache.activemq.artemis.api.core.ActiveMQBuffer;","[{'comment': ""This import doesn't look used."", 'commenter': 'brusdev'}, {'comment': 'fixed', 'commenter': 'andytaylor'}]"
3278,artemis-core-client/src/main/java/org/apache/activemq/artemis/utils/BufferHelper.java,"@@ -155,5 +157,38 @@ public static Double readNullableDouble(ActiveMQBuffer buffer) {
       }
    }
 
+   public static int sizeOfNullableString(String s) {
+      if (s == null) {
+         return DataConstants.SIZE_BOOLEAN;
+      }
+      return DataConstants.SIZE_BOOLEAN + sizeOfString(s);
+   }
+
+   public static int sizeOfeString(String s) {","[{'comment': ""This one doesn't look used (nor correct)"", 'commenter': 'franz1981'}]"
3577,artemis-server/src/main/java/org/apache/activemq/artemis/core/management/impl/openmbean/OpenTypeSupport.java,"@@ -293,7 +293,7 @@ protected void init() throws OpenDataException {
             if (m.containsProperty(Message.HDR_LARGE_COMPRESSED)) {
                rc.put(CompositeDataConstants.TEXT_BODY, ""[compressed]"");
             } else {
-               final String text = m.getReadOnlyBodyBuffer().readString();
+               final String text = m.getReadOnlyBodyBuffer().readNullableSimpleString().toString();","[{'comment': ""This shouldn't be\r\n```java\r\nfinal SimpleString nullableText = m.getReadOnlyBodyBuffer().readNullableSimpleString();\r\nfinal String text = nullableText == null? null : nullableText.toString();\r\n// ...\r\n```\r\nbecause of\r\n```java\r\n   public static SimpleString readNullableSimpleString(ByteBuf buffer) {\r\n      int b = buffer.readByte();\r\n      if (b == DataConstants.NULL) {\r\n         return null;\r\n      }\r\n      return readSimpleString(buffer);\r\n   }\r\n```"", 'commenter': 'franz1981'}, {'comment': '@franz1981 thanks, just fixed', 'commenter': 'brusdev'}]"
3605,artemis-journal/src/main/java/org/apache/activemq/artemis/core/journal/impl/JournalImpl.java,"@@ -1075,14 +1067,27 @@ private void internalAppendUpdateRecord(long id,
                                            Persister persister,
                                            Object record,
                                            boolean sync,
+                                           BiConsumer<Long, Boolean> updateCallback,
                                            IOCompletion callback) throws InterruptedException, java.util.concurrent.ExecutionException {
-      final SimpleFuture<Boolean> result = newSyncAndCallbackResult(sync, callback);
       appendExecutor.execute(new Runnable() {
          @Override
          public void run() {
             journalLock.readLock().lock();
             try {
                JournalRecord jrnRecord = records.get(id);
+               if (jrnRecord == null) {
+                  if (compactor == null || (!compactor.containsRecord(id))) {","[{'comment': 'Save the compactor in a local final variable to save it load it each time', 'commenter': 'franz1981'}, {'comment': 'the compactor is only changed on writeLock. it is safe to just use the compactor directly here.', 'commenter': 'clebertsuconic'}]"
3605,artemis-journal/src/main/java/org/apache/activemq/artemis/core/journal/impl/JournalImpl.java,"@@ -1075,14 +1067,27 @@ private void internalAppendUpdateRecord(long id,
                                            Persister persister,
                                            Object record,
                                            boolean sync,
+                                           BiConsumer<Long, Boolean> updateCallback,
                                            IOCompletion callback) throws InterruptedException, java.util.concurrent.ExecutionException {
-      final SimpleFuture<Boolean> result = newSyncAndCallbackResult(sync, callback);
       appendExecutor.execute(new Runnable() {
          @Override
          public void run() {
             journalLock.readLock().lock();
             try {
                JournalRecord jrnRecord = records.get(id);
+               if (jrnRecord == null) {
+                  if (compactor == null || (!compactor.containsRecord(id))) {
+                     if (updateCallback != null) {
+                        updateCallback.accept(id, false);
+                     }
+                     logger.debug(""Record "" + id + "" had not been found"");
+","[{'comment': 'Debug if is debug level to save string creation ', 'commenter': 'franz1981'}]"
3605,artemis-journal/src/main/java/org/apache/activemq/artemis/core/journal/impl/JournalImpl.java,"@@ -1075,14 +1067,27 @@ private void internalAppendUpdateRecord(long id,
                                            Persister persister,
                                            Object record,
                                            boolean sync,
+                                           BiConsumer<Long, Boolean> updateCallback,
                                            IOCompletion callback) throws InterruptedException, java.util.concurrent.ExecutionException {
-      final SimpleFuture<Boolean> result = newSyncAndCallbackResult(sync, callback);
       appendExecutor.execute(new Runnable() {
          @Override
          public void run() {
             journalLock.readLock().lock();
             try {
                JournalRecord jrnRecord = records.get(id);
+               if (jrnRecord == null) {
+                  if (compactor == null || (!compactor.containsRecord(id))) {
+                     if (updateCallback != null) {
+                        updateCallback.accept(id, false);","[{'comment': ""Michael P spent some time to save boxed Long instances to be allocated and I think we should continue here: let's create a specific interface that can use primitive long and boolean "", 'commenter': 'franz1981'}, {'comment': 'done', 'commenter': 'clebertsuconic'}]"
3605,artemis-journal/src/main/java/org/apache/activemq/artemis/core/journal/impl/JournalImpl.java,"@@ -1097,26 +1102,32 @@ public void run() {
                // record==null here could only mean there is a compactor
                // computing the delete should be done after compacting is done
                if (jrnRecord == null) {
-                  compactor.addCommandUpdate(id, usedFile, updateRecord.getEncodeSize());
+                  if (compactor != null) {","[{'comment': 'Save compactor in a local variable to save it to be loaded more then one time', 'commenter': 'franz1981'}, {'comment': 'compactor is only changed on writeLock(). it is safe to use it here.', 'commenter': 'clebertsuconic'}, {'comment': 'Yes but it still an unnecessary cost: each time we use it, the jit will load it and null check it implicitly', 'commenter': 'franz1981'}, {'comment': ""I don't think that's a big deal but I will do it"", 'commenter': 'clebertsuconic'}]"
3605,artemis-journal/src/main/java/org/apache/activemq/artemis/core/journal/impl/JournalImpl.java,"@@ -1129,15 +1140,17 @@ public void appendDeleteRecord(final long id, final boolean sync, final IOComple
 
       checkJournalIsLoaded();
       lineUpContext(callback);
-      checkKnownRecordID(id, true);
-
-      internalAppendDeleteRecord(id, sync, callback);
+      SimpleFuture<Boolean> future = new SimpleFutureImpl<>();","[{'comment': 'I would create a specific future that can act as a callback too here: it would save the lambda allocation', 'commenter': 'franz1981'}, {'comment': ""this is not used at all.. it is just for tests.\r\n\r\nBesides there's no change here.. the previous version was doing exactly the same."", 'commenter': 'clebertsuconic'}]"
3610,artemis-journal/src/main/java/org/apache/activemq/artemis/core/journal/impl/JournalImpl.java,"@@ -323,20 +325,26 @@ public JournalImpl setHistoryFolder(File historyFolder, long maxBytes, long peri
    private final ReadWriteLock journalLock = new ReentrantReadWriteLock();
    private final ReadWriteLock compactorLock = new ReentrantReadWriteLock();
 
-   HashSet<Integer> replaceableRecords;
+   ByteObjectHashMap<Byte> replaceableRecords;","[{'comment': 'I would use a BitSet: it would save tons of memory while being faster too.\r\nAs an alternative, if we know upfront all the record types I would enum them, using the enum as parameter instead of byte and using an EnumSet too.\r\nIMO the solution with the BitSet is the best one in term of footprint/performance: it always need just a single long[] of capacity 1 if record type is >=0 and the max record type value is < 64', 'commenter': 'franz1981'}, {'comment': 'Iteration could be performed with \r\n```java\r\nfor (int recordType = bitSet.nextSetBit(0); recordType != -1; recordType = bitSet.nextSetBit(recordType + 1)) {\r\n    // do something with record type\r\n}\r\n```', 'commenter': 'franz1981'}, {'comment': ""Given that I don't know if it's an hot path I am already happy with the PR as it is: this one is just an improvement, given that we are already changing collection."", 'commenter': 'franz1981'}]"
3635,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -3066,7 +3073,7 @@ private boolean deliver() {
             } else if (!consumers.hasNext()) {
                // Round robin'd all
 
-               if (noDelivery == this.consumers.size()) {
+               if (noDelivery == consumerCount) {","[{'comment': 'This seems like a potentially significant change in behaviour. I wonder about its safety a bit.\r\n\r\nThe previous version would see any updates to the consumer list size that happened while this method was running, whereas the new version takes a snapshot of the count before starting the loop and retains it for the rest of the time. It retrieves the value outside the synchronized block which the loop goes in and out of as it operates. So it feels like it could be wrong to begin with, and then not reflect changes which the iterator itself can get (from e.g. the various resets it does), and which it does so while under synchronization.', 'commenter': 'gemmellr'}, {'comment': 'I had the same worries because my motivation was just to avoid a second related call to size() b/c the logic of seeing noDelivery every where is what I need, it depends on consumers not changing. I can peek some more to get a better answer.\r\nthanks for the shared concern :-)', 'commenter': 'gtully'}, {'comment': 'I would leave this with call to size() its a int held number internally of the collection so should have no perf concerns. Is safer than having count being got outside the sync and then consumer added or removed and then its wrong and then theres an introduced concurrency issue', 'commenter': 'michaelandrepearce'}, {'comment': 'leaving the call to size in place', 'commenter': 'gtully'}]"
3635,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -3055,6 +3058,10 @@ private boolean deliver() {
                } else if (status == HandleStatus.NO_MATCH) {
                   // nothing to be done on this case, the iterators will just jump next
                   consumers.reset();
+                  numNoMatch++;
+                  if (numNoMatch == consumerCount) {","[{'comment': ""The JIRA and code seem like it would be trying for 'no consumers matched message', but since the consumers iterator is reset just before this, aren't many/most of the attempts leading to this count incrementing going to be performed against the same consumer(s, but mostly first one), rather than checking all the consumers?"", 'commenter': 'gemmellr'}, {'comment': 'that is exactly what I want to achieve, I will get back to you.', 'commenter': 'gtully'}, {'comment': 'I needed to add a second counter to track attempts such that I can track a bounded linear sequence of noMatch attempts that match the size of the consumers list.', 'commenter': 'gtully'}]"
3635,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -2920,6 +2922,10 @@ private boolean deliver() {
       // Either the iterator is empty or the consumer is busy
       int noDelivery = 0;
 
+      // track filters not matching, used to track when all consumers can't match, redistribution is then an option
+      int numNoMatch = 0;
+      final int consumerCount = this.consumers.size();","[{'comment': 'Between here and the sync block a consumer could be added or removed and thus the count and logic within sync block would be broke. This probably should be in the sync block to avoid this', 'commenter': 'michaelandrepearce'}, {'comment': 'Or just call consumers.size when needed to be safe. Rather than causing race issues', 'commenter': 'michaelandrepearce'}]"
3635,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -1512,11 +1514,6 @@ private boolean checkConsumerDirectDeliver() {
             supports = false;
          }
       }
-      if (redistributor != null) {","[{'comment': 'Why is this being removed? New feature shouldnt be needing to remove this.', 'commenter': 'michaelandrepearce'}]"
3635,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -3007,23 +3009,25 @@ private boolean deliver() {
                   logger.trace(""Queue "" + this.getName() + "" is delivering reference "" + ref);
                }
 
-               existingMemoryEstimate = ref.getMessageMemoryEstimate();","[{'comment': 'Wheres this gone', 'commenter': 'michaelandrepearce'}, {'comment': 'that is just dead code removal, value is not used', 'commenter': 'gtully'}]"
3635,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -1567,7 +1565,16 @@ protected void finalize() throws Throwable {
 
    @Override
    public int getConsumerCount() {
-      return consumers.size();
+      int size = consumers.size();
+      // we don't want to count the redistributor, it is an internal transient entry in the consumer list
+      if (size > 0) {
+         synchronized (this) {","[{'comment': '-1 this method is hit alot on metric scraping it shouldnt be taking the lock else will cause perf issue, as metrics will be stealing the delivery lock. ', 'commenter': 'michaelandrepearce'}, {'comment': 'Maybe make the redistributor volatile and use a static atomic field updater to update and get its value.', 'commenter': 'michaelandrepearce'}, {'comment': 'fair enough... will sort', 'commenter': 'gtully'}, {'comment': 'implemented with the updater. thanks for the feedback :-)', 'commenter': 'gtully'}]"
3635,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -140,6 +139,7 @@
    private static final AtomicLongFieldUpdater<QueueImpl> dispatchStartTimeUpdater = AtomicLongFieldUpdater.newUpdater(QueueImpl.class, ""dispatchStartTime"");
    private static final AtomicLongFieldUpdater<QueueImpl> consumerRemovedTimestampUpdater = AtomicLongFieldUpdater.newUpdater(QueueImpl.class, ""consumerRemovedTimestamp"");
    private static final AtomicReferenceFieldUpdater<QueueImpl, Filter> filterUpdater = AtomicReferenceFieldUpdater.newUpdater(QueueImpl.class, Filter.class, ""filter"");
+   private static final AtomicReferenceFieldUpdater<QueueImpl, ConsumerHolder> redistributorUpdater = AtomicReferenceFieldUpdater.newUpdater(QueueImpl.class, ConsumerHolder.class, ""redistributor"");","[{'comment': 'Is this needed? Seems like there are no CAS etc operations done on it, just straight sets, and all actual uses of the redistributor field except one are done under synchronized methods/blocks, except the use in getConsumerCount where it just does a get with this updater vs using the volatile-anyway field. (The subsequent usage there is perhaps not so safe as it isnt under lock)', 'commenter': 'gemmellr'}, {'comment': 'it was really just for consistency, but this could be internal to the custom consumers structure as you suggested below, which would be simpler', 'commenter': 'gtully'}, {'comment': 'I have reverted to just accessing the volatile and doing the logic inside a sync if necessary. The updater is no more.', 'commenter': 'gtully'}]"
3635,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -1567,7 +1566,14 @@ protected void finalize() throws Throwable {
 
    @Override
    public int getConsumerCount() {
-      return consumers.size();
+      // we don't want to count the redistributor, it is an internal transient entry in the consumer list
+      // check for presence before checking consumers to align with use of set()
+      final boolean compensateForPresenceOfRedistributor = redistributorUpdater.get(this) != null;
+      int size = consumers.size();
+      if (size > 0 && compensateForPresenceOfRedistributor) {
+         size--;
+      }
+      return size;","[{'comment': ""Sine this isnt done under lock and both the redistributor and consumers list could be changing independently, it seems quite racey? Seems to be used in some important places so I'd wonder if that is a problem.\r\n\r\nGiven that 'consumers' is actually a custom structure, and updates to its underlying structure are done under lock, it coudl perhaps be made to handle this internally (and e.g add a specific compensating size method)?"", 'commenter': 'gemmellr'}, {'comment': '@gemmellr I like that suggestion. Thanks! I will peek at doing the compensation in size() and have consumers track the redistributor that it contains, it should be a lot cleaner.', 'commenter': 'gtully'}, {'comment': 'Just to be clear, I was suggesting adding another method than size. I would expect size to continue to report it as being there (like it does just now) and only things that care about the distinction to call the new one.', 'commenter': 'gemmellr'}, {'comment': 'I think that is all users, the redistributor is managed by the broker, to an observer it does not exist.', 'commenter': 'gtully'}, {'comment': 'but I see your point, it may be better in a different method', 'commenter': 'gtully'}, {'comment': ""with the latest update, the distinction is now between use of consumers.size when we don't care and getConsumerCount when we only want user consumers."", 'commenter': 'gtully'}]"
3635,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -1573,6 +1572,17 @@ public synchronized void cancelRedistributor() throws Exception {
 
    @Override
    public int getConsumerCount() {
+      // we don't want to count the redistributor, it is an internal transient entry in the consumer list
+      if (redistributor != null) {","[{'comment': 'With this new code, we are adding still a perf penalty, as now with volatile reads we are going to main memory not cpu cache, this affects not just here, but where redistributor is used in many code places on read paths. could we do away with the volatile change on the variable?', 'commenter': 'michaelpearce-gain'}, {'comment': '@franz1981 can you review this pr?', 'commenter': 'michaelpearce-gain'}, {'comment': ""i guess it is needed, else it wouldnt be visible to other thread... problem is that's a perf change as all the reads will now be from main memory for it rather than just local cpu cache"", 'commenter': 'michaelpearce-gain'}, {'comment': 'im shutting up, i dont think its that bad.....looks fine.', 'commenter': 'michaelpearce-gain'}, {'comment': 'yes im typing as im thinking apologies....', 'commenter': 'michaelpearce-gain'}]"
3646,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ReplicationBackupActivation.java,"@@ -0,0 +1,692 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.core.server.impl;
+
+import javax.annotation.concurrent.GuardedBy;
+
+import java.util.Objects;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
+
+import org.apache.activemq.artemis.api.core.ActiveMQException;
+import org.apache.activemq.artemis.api.core.ActiveMQIllegalStateException;
+import org.apache.activemq.artemis.api.core.Pair;
+import org.apache.activemq.artemis.api.core.SimpleString;
+import org.apache.activemq.artemis.api.core.TransportConfiguration;
+import org.apache.activemq.artemis.core.protocol.core.Channel;
+import org.apache.activemq.artemis.core.replication.ReplicationEndpoint;
+import org.apache.activemq.artemis.core.server.ActiveMQServer;
+import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
+import org.apache.activemq.artemis.core.server.LiveNodeLocator;
+import org.apache.activemq.artemis.core.server.NodeManager;
+import org.apache.activemq.artemis.core.server.cluster.ClusterControl;
+import org.apache.activemq.artemis.core.server.cluster.ClusterController;
+import org.apache.activemq.artemis.core.server.cluster.ha.ReplicationBackupPolicy;
+import org.apache.activemq.artemis.quorum.DistributedLock;
+import org.apache.activemq.artemis.quorum.DistributedPrimitiveManager;
+import org.apache.activemq.artemis.quorum.MutableLong;
+import org.apache.activemq.artemis.quorum.UnavailableStateException;
+import org.jboss.logging.Logger;
+
+import static org.apache.activemq.artemis.core.server.impl.ReplicationObserver.ReplicationFailure;
+
+/**
+ * This activation can be used by a primary while trying to fail-back ie {@code failback == true} or
+ * by a natural-born backup ie {@code failback == false}.<br>
+ */
+public final class ReplicationBackupActivation extends Activation implements DistributedPrimitiveManager.UnavailableManagerListener {
+
+   private static final Logger LOGGER = Logger.getLogger(ReplicationBackupActivation.class);
+
+   private final boolean wasLive;
+   private final ReplicationBackupPolicy policy;
+   private final ActiveMQServerImpl activeMQServer;
+   // This field is != null iff this node is a primary during a fail-back ie acting as a backup in order to become live again.
+   private final String expectedNodeID;
+   @GuardedBy(""this"")
+   private boolean closed;
+   private final DistributedPrimitiveManager distributedManager;
+   // Used for monitoring purposes
+   private volatile ReplicationObserver replicationObserver;
+   // Used for testing purposes
+   private volatile ReplicationEndpoint replicationEndpoint;
+   // Used for testing purposes
+   private Consumer<ReplicationEndpoint> onReplicationEndpointCreation;
+   // Used to arbiter one-shot server stop/restart
+   private final AtomicBoolean stopping;
+
+   public ReplicationBackupActivation(final ActiveMQServerImpl activeMQServer,
+                                      final boolean wasLive,
+                                      final DistributedPrimitiveManager distributedManager,
+                                      final ReplicationBackupPolicy policy) {
+      this.wasLive = wasLive;
+      this.activeMQServer = activeMQServer;
+      if (policy.isTryFailback()) {
+         final SimpleString serverNodeID = activeMQServer.getNodeID();
+         if (serverNodeID == null || serverNodeID.isEmpty()) {
+            throw new IllegalStateException(""A failback activation must be biased around a specific NodeID"");
+         }
+         this.expectedNodeID = serverNodeID.toString();
+      } else {
+         this.expectedNodeID = null;
+      }
+      this.distributedManager = distributedManager;
+      this.policy = policy;
+      this.replicationObserver = null;
+      this.replicationEndpoint = null;
+      this.stopping = new AtomicBoolean(false);
+   }
+
+   /**
+    * used for testing purposes.
+    */
+   public DistributedPrimitiveManager getDistributedManager() {
+      return distributedManager;
+   }
+
+   @Override
+   public void onUnavailableManagerEvent() {
+      synchronized (this) {
+         if (closed) {
+            return;
+         }
+      }
+      LOGGER.info(""Unavailable quorum service detected: try restart server"");
+      asyncRestartServer(activeMQServer, true);
+   }
+
+   /**
+    * This util class exists because {@link LiveNodeLocator} need a {@link LiveNodeLocator.BackupRegistrationListener}
+    * to forward backup registration failure events: this is used to switch on/off backup registration event listening
+    * on an existing locator.
+    */
+   private static final class RegistrationFailureForwarder implements LiveNodeLocator.BackupRegistrationListener, AutoCloseable {
+
+      private static final LiveNodeLocator.BackupRegistrationListener NOOP_LISTENER = ignore -> {
+      };
+      private volatile LiveNodeLocator.BackupRegistrationListener listener = NOOP_LISTENER;
+
+      public RegistrationFailureForwarder to(LiveNodeLocator.BackupRegistrationListener listener) {
+         this.listener = listener;
+         return this;
+      }
+
+      @Override
+      public void onBackupRegistrationFailed(boolean alreadyReplicating) {
+         listener.onBackupRegistrationFailed(alreadyReplicating);
+      }
+
+      @Override
+      public void close() {
+         listener = NOOP_LISTENER;
+      }
+   }
+
+   @Override
+   public void run() {
+      synchronized (this) {
+         if (closed) {
+            return;
+         }
+      }
+      try {
+         LOGGER.infof(""Trying to reach the majority of quorum nodes"");
+         distributedManager.start();
+         LOGGER.debug(""Quorum service available"");
+
+         if (policy.isTryFailback()) {
+            // we are replicating to overwrite our data, transient backup state while trying to be the primary
+         } else {
+            // we may be a valid insync_replica (backup) if our activation sequence is largest for a nodeId
+            // verify that before removing data..
+            final DistributedLock liveLockWithInSyncReplica = checkForInSyncReplica();
+            if (liveLockWithInSyncReplica != null) {
+               // retain state and start as live
+               if (!activeMQServer.initialisePart1(false)) {
+                  return;
+               }
+               activeMQServer.setState(ActiveMQServerImpl.SERVER_STATE.STARTED);
+               startAsLive(liveLockWithInSyncReplica);
+               return;
+            }
+         }
+         distributedManager.addUnavailableManagerListener(this);
+         // Stop the previous node manager and create a new one with NodeManager::replicatedBackup == true:
+         // NodeManager::start skip setup lock file with NodeID, until NodeManager::stopBackup is called.
+         activeMQServer.resetNodeManager();
+         // A primary need to preserve NodeID across runs
+         activeMQServer.moveServerData(policy.getMaxSavedReplicatedJournalsSize(), policy.isTryFailback());
+         activeMQServer.getNodeManager().start();
+         if (!activeMQServer.initialisePart1(false)) {
+            return;
+         }
+         synchronized (this) {
+            if (closed)
+               return;
+         }
+
+
+         final ClusterController clusterController = activeMQServer.getClusterManager().getClusterController();
+
+         LOGGER.infof(""Apache ActiveMQ Artemis Backup Server version %s [%s] started, awaiting connection to a live cluster member to start replication"", activeMQServer.getVersion().getFullVersion(),
+                      activeMQServer.toString());
+
+         clusterController.awaitConnectionToReplicationCluster();
+         activeMQServer.getBackupManager().start();
+         activeMQServer.setState(ActiveMQServerImpl.SERVER_STATE.STARTED);
+         final DistributedLock liveLock = replicateAndFailover(clusterController);
+         if (liveLock == null) {
+            return;
+         }
+         startAsLive(liveLock);
+      } catch (Exception e) {
+         if ((e instanceof InterruptedException || e instanceof IllegalStateException) && !activeMQServer.isStarted()) {
+            // do not log these errors if the server is being stopped.
+            return;
+         }
+         ActiveMQServerLogger.LOGGER.initializationError(e);
+      }
+   }
+
+   private DistributedLock checkForInSyncReplica() throws InterruptedException, ExecutionException, TimeoutException, UnavailableStateException {
+      final long nodeActivationSequence = activeMQServer.getNodeManager().readNodeActivationSequence();
+      if (nodeActivationSequence > 0) {
+         // not an empty backup (first start), let see if we can get the lock and verify our data activation sequence
+         final String lockAndLongId = activeMQServer.getNodeManager().getNodeId().toString();
+         final DistributedLock activationLock = distributedManager.getDistributedLock(lockAndLongId);
+         try (MutableLong coordinatedNodeSequence = distributedManager.getMutableLong(lockAndLongId)) {
+            while (true) {
+               // dirty read is sufficient to know if we are *not* an in sync replica
+               // typically the lock owner will increment to signal our data is stale and we are happy without any
+               // further coordination at this point
+               final long currentCoordinatedNodeSequence = coordinatedNodeSequence.get();
+               if (nodeActivationSequence != currentCoordinatedNodeSequence) {
+                  LOGGER.infof(""Not a candidate for NodeID = %s activation, local activation sequence %d does not match coordinated activation sequence %d"", lockAndLongId, nodeActivationSequence, currentCoordinatedNodeSequence);
+                  activationLock.close();
+                  return null;
+               }
+               // our data may be current, start coordinating to verify
+               if (!activationLock.tryLock(policy.getVoteRetryWait(), TimeUnit.MILLISECONDS)) {
+                  LOGGER.debugf(""Candidate for Node ID = %s, with local activation sequence: %d, cannot acquire live lock within %dms; retrying"", lockAndLongId, nodeActivationSequence, policy.getVoteRetryWait());
+                  continue;
+               }
+               final long lockedCoordinatedNodeSequence = coordinatedNodeSequence.get();
+               if (nodeActivationSequence != lockedCoordinatedNodeSequence) {
+                  LOGGER.infof(""Not a candidate for NodeID = %s activation, local activation sequence %d does not match current coordinated activation sequence %d"", lockAndLongId, nodeActivationSequence, lockedCoordinatedNodeSequence);
+                  activationLock.close();
+                  return null;
+               }
+               // we are an in_sync_replica, good to go live as UNREPLICATED
+               LOGGER.infof(""Assuming live role for NodeID = %s, local activation sequence %d matches current coordinated activation sequence %d"", lockAndLongId, nodeActivationSequence, lockedCoordinatedNodeSequence);
+               return activationLock;
+            }
+         }
+      } else {
+         LOGGER.debugf(""Activation sequence is 0"");
+         return null;
+      }
+   }
+
+   static void ensureSequentialAccessToNodeData(ActiveMQServer activeMQServer,
+                                                DistributedPrimitiveManager distributedPrimitiveManager, final Logger logger) throws ActiveMQException, InterruptedException, UnavailableStateException, ExecutionException, TimeoutException {
+
+      final NodeManager nodeManager = activeMQServer.getNodeManager();
+      final String lockAndLongId = nodeManager.getNodeId().toString();
+      final long nodeActivationSequence = nodeManager.readNodeActivationSequence();
+
+      final DistributedLock liveLock = distributedPrimitiveManager.getDistributedLock(lockAndLongId);
+      if (liveLock.isHeldByCaller()) {
+         MutableLong coordinatedNodeActivationSequence = distributedPrimitiveManager.getMutableLong(lockAndLongId);
+         if (nodeActivationSequence != coordinatedNodeActivationSequence.get()) {
+            final String message = String.format(""Server [%s], cannot assume live role for NodeID = %s, local activation sequence %d does not match current coordinated sequence %d"", activeMQServer, lockAndLongId, nodeActivationSequence, coordinatedNodeActivationSequence.get());
+            logger.info(message);
+            throw new ActiveMQException(message);
+         }
+
+         // UN_REPLICATED STATE ENTER
+         if (coordinatedNodeActivationSequence.compareAndSet(nodeActivationSequence, nodeActivationSequence + 1)) {
+            nodeManager.writeNodeActivationSequence(nodeActivationSequence + 1);
+            logger.infof(""Server [%s], incremented coordinated activation sequence to: %d for NodeId = %s"", activeMQServer, nodeActivationSequence + 1, lockAndLongId);
+         } else {
+            final String message = String.format(""Server [%s], cannot assume live role for NodeID = %s, compareAndSet failed, local activation sequence %d no longer matches current coordinated sequence %d"", activeMQServer, lockAndLongId, nodeActivationSequence, coordinatedNodeActivationSequence.get());
+            logger.info(message);
+            throw new ActiveMQException(message);
+         }
+      } else {
+         final String message = String.format(""Server [%s], live lock for NodeID = %s, not held, activation sequence cannot be safely incremented to %d"", activeMQServer, lockAndLongId, nodeActivationSequence);
+         logger.info(message);
+         throw new UnavailableStateException(message);
+      }
+   }
+
+   private void startAsLive(final DistributedLock liveLock) throws Exception {
+      activeMQServer.setHAPolicy(policy.getLivePolicy());
+
+      synchronized (activeMQServer) {
+         if (!activeMQServer.isStarted()) {
+            liveLock.close();
+            return;
+         }
+         ensureSequentialAccessToNodeData(activeMQServer, distributedManager, LOGGER);
+
+         ActiveMQServerLogger.LOGGER.becomingLive(activeMQServer);
+         // stopBackup is going to write the NodeID previously set on the NodeManager,
+         // because activeMQServer.resetNodeManager() has created a NodeManager with replicatedBackup == true.
+         activeMQServer.getNodeManager().stopBackup();
+         activeMQServer.getStorageManager().start();
+         activeMQServer.getBackupManager().activated();
+         // IMPORTANT:
+         // we're setting this activation JUST because it would allow the server to use its
+         // getActivationChannelHandler to handle replication
+         final ReplicationPrimaryActivation primaryActivation = new ReplicationPrimaryActivation(activeMQServer, distributedManager, policy.getLivePolicy());
+         liveLock.addListener(primaryActivation);
+         activeMQServer.setActivation(primaryActivation);
+         activeMQServer.initialisePart2(false);
+         // calling primaryActivation.stateChanged !isHelByCaller is necessary in case the lock was unavailable
+         // before liveLock.addListener: just throwing an exception won't stop the broker.
+         final boolean stillLive;
+         try {
+            stillLive = liveLock.isHeldByCaller();
+         } catch (UnavailableStateException e) {
+            LOGGER.warn(e);
+            primaryActivation.onUnavailableLockEvent();
+            throw new ActiveMQIllegalStateException(""This server cannot check its role as a live: activation is failed"");
+         }
+         if (!stillLive) {
+            primaryActivation.onUnavailableLockEvent();
+            throw new ActiveMQIllegalStateException(""This server is not live anymore: activation is failed"");
+         }
+         if (activeMQServer.getIdentity() != null) {
+            ActiveMQServerLogger.LOGGER.serverIsLive(activeMQServer.getIdentity());
+         } else {
+            ActiveMQServerLogger.LOGGER.serverIsLive();
+         }
+         activeMQServer.completeActivation(true);
+      }
+   }
+
+   private LiveNodeLocator createLiveNodeLocator(final LiveNodeLocator.BackupRegistrationListener registrationListener) {
+      if (expectedNodeID != null) {
+         assert policy.isTryFailback();
+         return new NamedLiveNodeIdLocatorForReplication(expectedNodeID, registrationListener, policy.getRetryReplicationWait());
+      }
+      return policy.getGroupName() == null ?
+         new AnyLiveNodeLocatorForReplication(registrationListener, activeMQServer, policy.getRetryReplicationWait()) :
+         new NamedLiveNodeLocatorForReplication(policy.getGroupName(), registrationListener, policy.getRetryReplicationWait());
+   }
+
+   private DistributedLock replicateAndFailover(final ClusterController clusterController) throws ActiveMQException, InterruptedException {
+      final RegistrationFailureForwarder registrationFailureForwarder = new RegistrationFailureForwarder();
+      // node locator isn't stateless and contains a live-list of candidate nodes to connect too, hence
+      // it MUST be reused for each replicateLive attempt
+      final LiveNodeLocator nodeLocator = createLiveNodeLocator(registrationFailureForwarder);
+      clusterController.addClusterTopologyListenerForReplication(nodeLocator);
+      try {
+         while (true) {
+            synchronized (this) {
+               if (closed) {
+                  return null;
+               }
+            }
+            final ReplicationFailure failure = replicateLive(clusterController, nodeLocator, registrationFailureForwarder);
+            if (failure == null) {
+               Thread.sleep(clusterController.getRetryIntervalForReplicatedCluster());
+               continue;
+            }
+            if (!activeMQServer.isStarted()) {
+               return null;
+            }
+            LOGGER.debugf(""ReplicationFailure = %s"", failure);
+            boolean voluntaryFailOver = false;
+            switch (failure) {
+               case VoluntaryFailOver:
+                  voluntaryFailOver = true;
+               case NonVoluntaryFailover:
+                  final DistributedLock liveLock = tryAcquireLiveLock();","[{'comment': ' `tryAcquireLiveLock`, similarly to `checkForInSyncReplica`, should return null if the activation sequence is not a match (and can perform a dirty read to fail fast): `startAsLive` is going to throw an exception if the activation sequence change before activating, but this would prevent it to restart as an empty backup and replicate a live again.\r\n\r\nThis can happen if:\r\n1. primary start and become live\r\n2. backup become an in-sync replica\r\n3. connection glitch between pair\r\n4. primary increase sequence activation\r\n5. backup try acquire live lock for *some* time ie > ZK session expiration timeout\r\n6. primary serve some clients and die due to OOM/whatever\r\n7. backup succeed acquiring live lock, but sequence has changed, then throws exception without becoming live\r\n8. primary is restarted and is able to become live again\r\n9. backup CANNOT won\'t become an in-sync replica because is in a limbo\r\n\r\nFixing this has the nice effect to make `tryAcquireLiveLock` and `checkForInSyncReplica` to do exactly the same thing, with both trying hard to not give up if the failing-over replica got ""good"" data and trying activate (without bumping up yet version). This would make some of the existing timeout config and doc to just disappear (!!, that\'s nice!): during failing-over, if data are good, there\'s no point to give up while trying to activate *if* the data are good; if there\'s another candidate live server ready to become live, the activation sequence would change at some point, stopping the attempt to activate, as expected.', 'commenter': 'franz1981'}]"
3646,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ReplicationBackupActivation.java,"@@ -0,0 +1,692 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.core.server.impl;
+
+import javax.annotation.concurrent.GuardedBy;
+
+import java.util.Objects;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
+
+import org.apache.activemq.artemis.api.core.ActiveMQException;
+import org.apache.activemq.artemis.api.core.ActiveMQIllegalStateException;
+import org.apache.activemq.artemis.api.core.Pair;
+import org.apache.activemq.artemis.api.core.SimpleString;
+import org.apache.activemq.artemis.api.core.TransportConfiguration;
+import org.apache.activemq.artemis.core.protocol.core.Channel;
+import org.apache.activemq.artemis.core.replication.ReplicationEndpoint;
+import org.apache.activemq.artemis.core.server.ActiveMQServer;
+import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
+import org.apache.activemq.artemis.core.server.LiveNodeLocator;
+import org.apache.activemq.artemis.core.server.NodeManager;
+import org.apache.activemq.artemis.core.server.cluster.ClusterControl;
+import org.apache.activemq.artemis.core.server.cluster.ClusterController;
+import org.apache.activemq.artemis.core.server.cluster.ha.ReplicationBackupPolicy;
+import org.apache.activemq.artemis.quorum.DistributedLock;
+import org.apache.activemq.artemis.quorum.DistributedPrimitiveManager;
+import org.apache.activemq.artemis.quorum.MutableLong;
+import org.apache.activemq.artemis.quorum.UnavailableStateException;
+import org.jboss.logging.Logger;
+
+import static org.apache.activemq.artemis.core.server.impl.ReplicationObserver.ReplicationFailure;
+
+/**
+ * This activation can be used by a primary while trying to fail-back ie {@code failback == true} or
+ * by a natural-born backup ie {@code failback == false}.<br>
+ */
+public final class ReplicationBackupActivation extends Activation implements DistributedPrimitiveManager.UnavailableManagerListener {
+
+   private static final Logger LOGGER = Logger.getLogger(ReplicationBackupActivation.class);
+
+   private final boolean wasLive;
+   private final ReplicationBackupPolicy policy;
+   private final ActiveMQServerImpl activeMQServer;
+   // This field is != null iff this node is a primary during a fail-back ie acting as a backup in order to become live again.
+   private final String expectedNodeID;
+   @GuardedBy(""this"")
+   private boolean closed;
+   private final DistributedPrimitiveManager distributedManager;
+   // Used for monitoring purposes
+   private volatile ReplicationObserver replicationObserver;
+   // Used for testing purposes
+   private volatile ReplicationEndpoint replicationEndpoint;
+   // Used for testing purposes
+   private Consumer<ReplicationEndpoint> onReplicationEndpointCreation;
+   // Used to arbiter one-shot server stop/restart
+   private final AtomicBoolean stopping;
+
+   public ReplicationBackupActivation(final ActiveMQServerImpl activeMQServer,
+                                      final boolean wasLive,
+                                      final DistributedPrimitiveManager distributedManager,
+                                      final ReplicationBackupPolicy policy) {
+      this.wasLive = wasLive;
+      this.activeMQServer = activeMQServer;
+      if (policy.isTryFailback()) {
+         final SimpleString serverNodeID = activeMQServer.getNodeID();
+         if (serverNodeID == null || serverNodeID.isEmpty()) {
+            throw new IllegalStateException(""A failback activation must be biased around a specific NodeID"");
+         }
+         this.expectedNodeID = serverNodeID.toString();
+      } else {
+         this.expectedNodeID = null;
+      }
+      this.distributedManager = distributedManager;
+      this.policy = policy;
+      this.replicationObserver = null;
+      this.replicationEndpoint = null;
+      this.stopping = new AtomicBoolean(false);
+   }
+
+   /**
+    * used for testing purposes.
+    */
+   public DistributedPrimitiveManager getDistributedManager() {
+      return distributedManager;
+   }
+
+   @Override
+   public void onUnavailableManagerEvent() {
+      synchronized (this) {
+         if (closed) {
+            return;
+         }
+      }
+      LOGGER.info(""Unavailable quorum service detected: try restart server"");
+      asyncRestartServer(activeMQServer, true);
+   }
+
+   /**
+    * This util class exists because {@link LiveNodeLocator} need a {@link LiveNodeLocator.BackupRegistrationListener}
+    * to forward backup registration failure events: this is used to switch on/off backup registration event listening
+    * on an existing locator.
+    */
+   private static final class RegistrationFailureForwarder implements LiveNodeLocator.BackupRegistrationListener, AutoCloseable {
+
+      private static final LiveNodeLocator.BackupRegistrationListener NOOP_LISTENER = ignore -> {
+      };
+      private volatile LiveNodeLocator.BackupRegistrationListener listener = NOOP_LISTENER;
+
+      public RegistrationFailureForwarder to(LiveNodeLocator.BackupRegistrationListener listener) {
+         this.listener = listener;
+         return this;
+      }
+
+      @Override
+      public void onBackupRegistrationFailed(boolean alreadyReplicating) {
+         listener.onBackupRegistrationFailed(alreadyReplicating);
+      }
+
+      @Override
+      public void close() {
+         listener = NOOP_LISTENER;
+      }
+   }
+
+   @Override
+   public void run() {
+      synchronized (this) {
+         if (closed) {
+            return;
+         }
+      }
+      try {
+         LOGGER.infof(""Trying to reach the majority of quorum nodes"");
+         distributedManager.start();
+         LOGGER.debug(""Quorum service available"");
+
+         if (policy.isTryFailback()) {
+            // we are replicating to overwrite our data, transient backup state while trying to be the primary
+         } else {
+            // we may be a valid insync_replica (backup) if our activation sequence is largest for a nodeId
+            // verify that before removing data..
+            final DistributedLock liveLockWithInSyncReplica = checkForInSyncReplica();
+            if (liveLockWithInSyncReplica != null) {
+               // retain state and start as live
+               if (!activeMQServer.initialisePart1(false)) {
+                  return;
+               }
+               activeMQServer.setState(ActiveMQServerImpl.SERVER_STATE.STARTED);
+               startAsLive(liveLockWithInSyncReplica);
+               return;
+            }
+         }
+         distributedManager.addUnavailableManagerListener(this);
+         // Stop the previous node manager and create a new one with NodeManager::replicatedBackup == true:
+         // NodeManager::start skip setup lock file with NodeID, until NodeManager::stopBackup is called.
+         activeMQServer.resetNodeManager();
+         // A primary need to preserve NodeID across runs
+         activeMQServer.moveServerData(policy.getMaxSavedReplicatedJournalsSize(), policy.isTryFailback());
+         activeMQServer.getNodeManager().start();
+         if (!activeMQServer.initialisePart1(false)) {
+            return;
+         }
+         synchronized (this) {
+            if (closed)
+               return;
+         }
+
+
+         final ClusterController clusterController = activeMQServer.getClusterManager().getClusterController();
+
+         LOGGER.infof(""Apache ActiveMQ Artemis Backup Server version %s [%s] started, awaiting connection to a live cluster member to start replication"", activeMQServer.getVersion().getFullVersion(),
+                      activeMQServer.toString());
+
+         clusterController.awaitConnectionToReplicationCluster();
+         activeMQServer.getBackupManager().start();
+         activeMQServer.setState(ActiveMQServerImpl.SERVER_STATE.STARTED);
+         final DistributedLock liveLock = replicateAndFailover(clusterController);
+         if (liveLock == null) {
+            return;
+         }
+         startAsLive(liveLock);
+      } catch (Exception e) {
+         if ((e instanceof InterruptedException || e instanceof IllegalStateException) && !activeMQServer.isStarted()) {
+            // do not log these errors if the server is being stopped.
+            return;
+         }
+         ActiveMQServerLogger.LOGGER.initializationError(e);
+      }
+   }
+
+   private DistributedLock checkForInSyncReplica() throws InterruptedException, ExecutionException, TimeoutException, UnavailableStateException {","[{'comment': '```suggestion\r\n   private DistributedLock tryActivate() throws InterruptedException, ExecutionException, TimeoutException, UnavailableStateException {\r\n```', 'commenter': 'franz1981'}]"
3646,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ReplicationBackupActivation.java,"@@ -0,0 +1,692 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.core.server.impl;
+
+import javax.annotation.concurrent.GuardedBy;
+
+import java.util.Objects;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
+
+import org.apache.activemq.artemis.api.core.ActiveMQException;
+import org.apache.activemq.artemis.api.core.ActiveMQIllegalStateException;
+import org.apache.activemq.artemis.api.core.Pair;
+import org.apache.activemq.artemis.api.core.SimpleString;
+import org.apache.activemq.artemis.api.core.TransportConfiguration;
+import org.apache.activemq.artemis.core.protocol.core.Channel;
+import org.apache.activemq.artemis.core.replication.ReplicationEndpoint;
+import org.apache.activemq.artemis.core.server.ActiveMQServer;
+import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
+import org.apache.activemq.artemis.core.server.LiveNodeLocator;
+import org.apache.activemq.artemis.core.server.NodeManager;
+import org.apache.activemq.artemis.core.server.cluster.ClusterControl;
+import org.apache.activemq.artemis.core.server.cluster.ClusterController;
+import org.apache.activemq.artemis.core.server.cluster.ha.ReplicationBackupPolicy;
+import org.apache.activemq.artemis.quorum.DistributedLock;
+import org.apache.activemq.artemis.quorum.DistributedPrimitiveManager;
+import org.apache.activemq.artemis.quorum.MutableLong;
+import org.apache.activemq.artemis.quorum.UnavailableStateException;
+import org.jboss.logging.Logger;
+
+import static org.apache.activemq.artemis.core.server.impl.ReplicationObserver.ReplicationFailure;
+
+/**
+ * This activation can be used by a primary while trying to fail-back ie {@code failback == true} or
+ * by a natural-born backup ie {@code failback == false}.<br>
+ */
+public final class ReplicationBackupActivation extends Activation implements DistributedPrimitiveManager.UnavailableManagerListener {
+
+   private static final Logger LOGGER = Logger.getLogger(ReplicationBackupActivation.class);
+
+   private final boolean wasLive;
+   private final ReplicationBackupPolicy policy;
+   private final ActiveMQServerImpl activeMQServer;
+   // This field is != null iff this node is a primary during a fail-back ie acting as a backup in order to become live again.
+   private final String expectedNodeID;
+   @GuardedBy(""this"")
+   private boolean closed;
+   private final DistributedPrimitiveManager distributedManager;
+   // Used for monitoring purposes
+   private volatile ReplicationObserver replicationObserver;
+   // Used for testing purposes
+   private volatile ReplicationEndpoint replicationEndpoint;
+   // Used for testing purposes
+   private Consumer<ReplicationEndpoint> onReplicationEndpointCreation;
+   // Used to arbiter one-shot server stop/restart
+   private final AtomicBoolean stopping;
+
+   public ReplicationBackupActivation(final ActiveMQServerImpl activeMQServer,
+                                      final boolean wasLive,
+                                      final DistributedPrimitiveManager distributedManager,
+                                      final ReplicationBackupPolicy policy) {
+      this.wasLive = wasLive;
+      this.activeMQServer = activeMQServer;
+      if (policy.isTryFailback()) {
+         final SimpleString serverNodeID = activeMQServer.getNodeID();
+         if (serverNodeID == null || serverNodeID.isEmpty()) {
+            throw new IllegalStateException(""A failback activation must be biased around a specific NodeID"");
+         }
+         this.expectedNodeID = serverNodeID.toString();
+      } else {
+         this.expectedNodeID = null;
+      }
+      this.distributedManager = distributedManager;
+      this.policy = policy;
+      this.replicationObserver = null;
+      this.replicationEndpoint = null;
+      this.stopping = new AtomicBoolean(false);
+   }
+
+   /**
+    * used for testing purposes.
+    */
+   public DistributedPrimitiveManager getDistributedManager() {
+      return distributedManager;
+   }
+
+   @Override
+   public void onUnavailableManagerEvent() {
+      synchronized (this) {
+         if (closed) {
+            return;
+         }
+      }
+      LOGGER.info(""Unavailable quorum service detected: try restart server"");
+      asyncRestartServer(activeMQServer, true);
+   }
+
+   /**
+    * This util class exists because {@link LiveNodeLocator} need a {@link LiveNodeLocator.BackupRegistrationListener}
+    * to forward backup registration failure events: this is used to switch on/off backup registration event listening
+    * on an existing locator.
+    */
+   private static final class RegistrationFailureForwarder implements LiveNodeLocator.BackupRegistrationListener, AutoCloseable {
+
+      private static final LiveNodeLocator.BackupRegistrationListener NOOP_LISTENER = ignore -> {
+      };
+      private volatile LiveNodeLocator.BackupRegistrationListener listener = NOOP_LISTENER;
+
+      public RegistrationFailureForwarder to(LiveNodeLocator.BackupRegistrationListener listener) {
+         this.listener = listener;
+         return this;
+      }
+
+      @Override
+      public void onBackupRegistrationFailed(boolean alreadyReplicating) {
+         listener.onBackupRegistrationFailed(alreadyReplicating);
+      }
+
+      @Override
+      public void close() {
+         listener = NOOP_LISTENER;
+      }
+   }
+
+   @Override
+   public void run() {
+      synchronized (this) {
+         if (closed) {
+            return;
+         }
+      }
+      try {
+         LOGGER.infof(""Trying to reach the majority of quorum nodes"");
+         distributedManager.start();
+         LOGGER.debug(""Quorum service available"");
+
+         if (policy.isTryFailback()) {
+            // we are replicating to overwrite our data, transient backup state while trying to be the primary
+         } else {
+            // we may be a valid insync_replica (backup) if our activation sequence is largest for a nodeId
+            // verify that before removing data..
+            final DistributedLock liveLockWithInSyncReplica = checkForInSyncReplica();","[{'comment': '```suggestion\r\n            final DistributedLock liveLockWithInSyncReplica = tryActivate();\r\n```', 'commenter': 'franz1981'}]"
3646,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ReplicationBackupActivation.java,"@@ -0,0 +1,692 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.core.server.impl;
+
+import javax.annotation.concurrent.GuardedBy;
+
+import java.util.Objects;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
+
+import org.apache.activemq.artemis.api.core.ActiveMQException;
+import org.apache.activemq.artemis.api.core.ActiveMQIllegalStateException;
+import org.apache.activemq.artemis.api.core.Pair;
+import org.apache.activemq.artemis.api.core.SimpleString;
+import org.apache.activemq.artemis.api.core.TransportConfiguration;
+import org.apache.activemq.artemis.core.protocol.core.Channel;
+import org.apache.activemq.artemis.core.replication.ReplicationEndpoint;
+import org.apache.activemq.artemis.core.server.ActiveMQServer;
+import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
+import org.apache.activemq.artemis.core.server.LiveNodeLocator;
+import org.apache.activemq.artemis.core.server.NodeManager;
+import org.apache.activemq.artemis.core.server.cluster.ClusterControl;
+import org.apache.activemq.artemis.core.server.cluster.ClusterController;
+import org.apache.activemq.artemis.core.server.cluster.ha.ReplicationBackupPolicy;
+import org.apache.activemq.artemis.quorum.DistributedLock;
+import org.apache.activemq.artemis.quorum.DistributedPrimitiveManager;
+import org.apache.activemq.artemis.quorum.MutableLong;
+import org.apache.activemq.artemis.quorum.UnavailableStateException;
+import org.jboss.logging.Logger;
+
+import static org.apache.activemq.artemis.core.server.impl.ReplicationObserver.ReplicationFailure;
+
+/**
+ * This activation can be used by a primary while trying to fail-back ie {@code failback == true} or
+ * by a natural-born backup ie {@code failback == false}.<br>
+ */
+public final class ReplicationBackupActivation extends Activation implements DistributedPrimitiveManager.UnavailableManagerListener {
+
+   private static final Logger LOGGER = Logger.getLogger(ReplicationBackupActivation.class);
+
+   private final boolean wasLive;
+   private final ReplicationBackupPolicy policy;
+   private final ActiveMQServerImpl activeMQServer;
+   // This field is != null iff this node is a primary during a fail-back ie acting as a backup in order to become live again.
+   private final String expectedNodeID;
+   @GuardedBy(""this"")
+   private boolean closed;
+   private final DistributedPrimitiveManager distributedManager;
+   // Used for monitoring purposes
+   private volatile ReplicationObserver replicationObserver;
+   // Used for testing purposes
+   private volatile ReplicationEndpoint replicationEndpoint;
+   // Used for testing purposes
+   private Consumer<ReplicationEndpoint> onReplicationEndpointCreation;
+   // Used to arbiter one-shot server stop/restart
+   private final AtomicBoolean stopping;
+
+   public ReplicationBackupActivation(final ActiveMQServerImpl activeMQServer,
+                                      final boolean wasLive,
+                                      final DistributedPrimitiveManager distributedManager,
+                                      final ReplicationBackupPolicy policy) {
+      this.wasLive = wasLive;
+      this.activeMQServer = activeMQServer;
+      if (policy.isTryFailback()) {
+         final SimpleString serverNodeID = activeMQServer.getNodeID();
+         if (serverNodeID == null || serverNodeID.isEmpty()) {
+            throw new IllegalStateException(""A failback activation must be biased around a specific NodeID"");
+         }
+         this.expectedNodeID = serverNodeID.toString();
+      } else {
+         this.expectedNodeID = null;
+      }
+      this.distributedManager = distributedManager;
+      this.policy = policy;
+      this.replicationObserver = null;
+      this.replicationEndpoint = null;
+      this.stopping = new AtomicBoolean(false);
+   }
+
+   /**
+    * used for testing purposes.
+    */
+   public DistributedPrimitiveManager getDistributedManager() {
+      return distributedManager;
+   }
+
+   @Override
+   public void onUnavailableManagerEvent() {
+      synchronized (this) {
+         if (closed) {
+            return;
+         }
+      }
+      LOGGER.info(""Unavailable quorum service detected: try restart server"");
+      asyncRestartServer(activeMQServer, true);
+   }
+
+   /**
+    * This util class exists because {@link LiveNodeLocator} need a {@link LiveNodeLocator.BackupRegistrationListener}
+    * to forward backup registration failure events: this is used to switch on/off backup registration event listening
+    * on an existing locator.
+    */
+   private static final class RegistrationFailureForwarder implements LiveNodeLocator.BackupRegistrationListener, AutoCloseable {
+
+      private static final LiveNodeLocator.BackupRegistrationListener NOOP_LISTENER = ignore -> {
+      };
+      private volatile LiveNodeLocator.BackupRegistrationListener listener = NOOP_LISTENER;
+
+      public RegistrationFailureForwarder to(LiveNodeLocator.BackupRegistrationListener listener) {
+         this.listener = listener;
+         return this;
+      }
+
+      @Override
+      public void onBackupRegistrationFailed(boolean alreadyReplicating) {
+         listener.onBackupRegistrationFailed(alreadyReplicating);
+      }
+
+      @Override
+      public void close() {
+         listener = NOOP_LISTENER;
+      }
+   }
+
+   @Override
+   public void run() {
+      synchronized (this) {
+         if (closed) {
+            return;
+         }
+      }
+      try {
+         LOGGER.infof(""Trying to reach the majority of quorum nodes"");
+         distributedManager.start();
+         LOGGER.debug(""Quorum service available"");
+
+         if (policy.isTryFailback()) {
+            // we are replicating to overwrite our data, transient backup state while trying to be the primary
+         } else {
+            // we may be a valid insync_replica (backup) if our activation sequence is largest for a nodeId
+            // verify that before removing data..
+            final DistributedLock liveLockWithInSyncReplica = checkForInSyncReplica();
+            if (liveLockWithInSyncReplica != null) {
+               // retain state and start as live
+               if (!activeMQServer.initialisePart1(false)) {
+                  return;
+               }
+               activeMQServer.setState(ActiveMQServerImpl.SERVER_STATE.STARTED);
+               startAsLive(liveLockWithInSyncReplica);
+               return;
+            }
+         }
+         distributedManager.addUnavailableManagerListener(this);
+         // Stop the previous node manager and create a new one with NodeManager::replicatedBackup == true:
+         // NodeManager::start skip setup lock file with NodeID, until NodeManager::stopBackup is called.
+         activeMQServer.resetNodeManager();
+         // A primary need to preserve NodeID across runs
+         activeMQServer.moveServerData(policy.getMaxSavedReplicatedJournalsSize(), policy.isTryFailback());
+         activeMQServer.getNodeManager().start();
+         if (!activeMQServer.initialisePart1(false)) {
+            return;
+         }
+         synchronized (this) {
+            if (closed)
+               return;
+         }
+
+
+         final ClusterController clusterController = activeMQServer.getClusterManager().getClusterController();
+
+         LOGGER.infof(""Apache ActiveMQ Artemis Backup Server version %s [%s] started, awaiting connection to a live cluster member to start replication"", activeMQServer.getVersion().getFullVersion(),
+                      activeMQServer.toString());
+
+         clusterController.awaitConnectionToReplicationCluster();
+         activeMQServer.getBackupManager().start();
+         activeMQServer.setState(ActiveMQServerImpl.SERVER_STATE.STARTED);
+         final DistributedLock liveLock = replicateAndFailover(clusterController);
+         if (liveLock == null) {
+            return;
+         }
+         startAsLive(liveLock);
+      } catch (Exception e) {
+         if ((e instanceof InterruptedException || e instanceof IllegalStateException) && !activeMQServer.isStarted()) {
+            // do not log these errors if the server is being stopped.
+            return;
+         }
+         ActiveMQServerLogger.LOGGER.initializationError(e);
+      }
+   }
+
+   private DistributedLock checkForInSyncReplica() throws InterruptedException, ExecutionException, TimeoutException, UnavailableStateException {
+      final long nodeActivationSequence = activeMQServer.getNodeManager().readNodeActivationSequence();
+      if (nodeActivationSequence > 0) {
+         // not an empty backup (first start), let see if we can get the lock and verify our data activation sequence
+         final String lockAndLongId = activeMQServer.getNodeManager().getNodeId().toString();
+         final DistributedLock activationLock = distributedManager.getDistributedLock(lockAndLongId);
+         try (MutableLong coordinatedNodeSequence = distributedManager.getMutableLong(lockAndLongId)) {
+            while (true) {
+               // dirty read is sufficient to know if we are *not* an in sync replica
+               // typically the lock owner will increment to signal our data is stale and we are happy without any
+               // further coordination at this point
+               final long currentCoordinatedNodeSequence = coordinatedNodeSequence.get();
+               if (nodeActivationSequence != currentCoordinatedNodeSequence) {
+                  LOGGER.infof(""Not a candidate for NodeID = %s activation, local activation sequence %d does not match coordinated activation sequence %d"", lockAndLongId, nodeActivationSequence, currentCoordinatedNodeSequence);
+                  activationLock.close();
+                  return null;
+               }
+               // our data may be current, start coordinating to verify
+               if (!activationLock.tryLock(policy.getVoteRetryWait(), TimeUnit.MILLISECONDS)) {
+                  LOGGER.debugf(""Candidate for Node ID = %s, with local activation sequence: %d, cannot acquire live lock within %dms; retrying"", lockAndLongId, nodeActivationSequence, policy.getVoteRetryWait());
+                  continue;
+               }
+               final long lockedCoordinatedNodeSequence = coordinatedNodeSequence.get();
+               if (nodeActivationSequence != lockedCoordinatedNodeSequence) {
+                  LOGGER.infof(""Not a candidate for NodeID = %s activation, local activation sequence %d does not match current coordinated activation sequence %d"", lockAndLongId, nodeActivationSequence, lockedCoordinatedNodeSequence);
+                  activationLock.close();
+                  return null;
+               }
+               // we are an in_sync_replica, good to go live as UNREPLICATED
+               LOGGER.infof(""Assuming live role for NodeID = %s, local activation sequence %d matches current coordinated activation sequence %d"", lockAndLongId, nodeActivationSequence, lockedCoordinatedNodeSequence);
+               return activationLock;
+            }
+         }
+      } else {
+         LOGGER.debugf(""Activation sequence is 0"");
+         return null;
+      }
+   }
+
+   static void ensureSequentialAccessToNodeData(ActiveMQServer activeMQServer,
+                                                DistributedPrimitiveManager distributedPrimitiveManager, final Logger logger) throws ActiveMQException, InterruptedException, UnavailableStateException, ExecutionException, TimeoutException {
+
+      final NodeManager nodeManager = activeMQServer.getNodeManager();
+      final String lockAndLongId = nodeManager.getNodeId().toString();
+      final long nodeActivationSequence = nodeManager.readNodeActivationSequence();
+
+      final DistributedLock liveLock = distributedPrimitiveManager.getDistributedLock(lockAndLongId);
+      if (liveLock.isHeldByCaller()) {
+         MutableLong coordinatedNodeActivationSequence = distributedPrimitiveManager.getMutableLong(lockAndLongId);
+         if (nodeActivationSequence != coordinatedNodeActivationSequence.get()) {
+            final String message = String.format(""Server [%s], cannot assume live role for NodeID = %s, local activation sequence %d does not match current coordinated sequence %d"", activeMQServer, lockAndLongId, nodeActivationSequence, coordinatedNodeActivationSequence.get());
+            logger.info(message);
+            throw new ActiveMQException(message);
+         }
+
+         // UN_REPLICATED STATE ENTER
+         if (coordinatedNodeActivationSequence.compareAndSet(nodeActivationSequence, nodeActivationSequence + 1)) {
+            nodeManager.writeNodeActivationSequence(nodeActivationSequence + 1);
+            logger.infof(""Server [%s], incremented coordinated activation sequence to: %d for NodeId = %s"", activeMQServer, nodeActivationSequence + 1, lockAndLongId);
+         } else {
+            final String message = String.format(""Server [%s], cannot assume live role for NodeID = %s, compareAndSet failed, local activation sequence %d no longer matches current coordinated sequence %d"", activeMQServer, lockAndLongId, nodeActivationSequence, coordinatedNodeActivationSequence.get());
+            logger.info(message);
+            throw new ActiveMQException(message);
+         }
+      } else {
+         final String message = String.format(""Server [%s], live lock for NodeID = %s, not held, activation sequence cannot be safely incremented to %d"", activeMQServer, lockAndLongId, nodeActivationSequence);
+         logger.info(message);
+         throw new UnavailableStateException(message);
+      }
+   }
+
+   private void startAsLive(final DistributedLock liveLock) throws Exception {
+      activeMQServer.setHAPolicy(policy.getLivePolicy());
+
+      synchronized (activeMQServer) {
+         if (!activeMQServer.isStarted()) {
+            liveLock.close();
+            return;
+         }
+         ensureSequentialAccessToNodeData(activeMQServer, distributedManager, LOGGER);
+
+         ActiveMQServerLogger.LOGGER.becomingLive(activeMQServer);
+         // stopBackup is going to write the NodeID previously set on the NodeManager,
+         // because activeMQServer.resetNodeManager() has created a NodeManager with replicatedBackup == true.
+         activeMQServer.getNodeManager().stopBackup();
+         activeMQServer.getStorageManager().start();
+         activeMQServer.getBackupManager().activated();
+         // IMPORTANT:
+         // we're setting this activation JUST because it would allow the server to use its
+         // getActivationChannelHandler to handle replication
+         final ReplicationPrimaryActivation primaryActivation = new ReplicationPrimaryActivation(activeMQServer, distributedManager, policy.getLivePolicy());
+         liveLock.addListener(primaryActivation);
+         activeMQServer.setActivation(primaryActivation);
+         activeMQServer.initialisePart2(false);
+         // calling primaryActivation.stateChanged !isHelByCaller is necessary in case the lock was unavailable
+         // before liveLock.addListener: just throwing an exception won't stop the broker.
+         final boolean stillLive;
+         try {
+            stillLive = liveLock.isHeldByCaller();
+         } catch (UnavailableStateException e) {
+            LOGGER.warn(e);
+            primaryActivation.onUnavailableLockEvent();
+            throw new ActiveMQIllegalStateException(""This server cannot check its role as a live: activation is failed"");
+         }
+         if (!stillLive) {
+            primaryActivation.onUnavailableLockEvent();
+            throw new ActiveMQIllegalStateException(""This server is not live anymore: activation is failed"");
+         }
+         if (activeMQServer.getIdentity() != null) {
+            ActiveMQServerLogger.LOGGER.serverIsLive(activeMQServer.getIdentity());
+         } else {
+            ActiveMQServerLogger.LOGGER.serverIsLive();
+         }
+         activeMQServer.completeActivation(true);
+      }
+   }
+
+   private LiveNodeLocator createLiveNodeLocator(final LiveNodeLocator.BackupRegistrationListener registrationListener) {
+      if (expectedNodeID != null) {
+         assert policy.isTryFailback();
+         return new NamedLiveNodeIdLocatorForReplication(expectedNodeID, registrationListener, policy.getRetryReplicationWait());
+      }
+      return policy.getGroupName() == null ?
+         new AnyLiveNodeLocatorForReplication(registrationListener, activeMQServer, policy.getRetryReplicationWait()) :
+         new NamedLiveNodeLocatorForReplication(policy.getGroupName(), registrationListener, policy.getRetryReplicationWait());
+   }
+
+   private DistributedLock replicateAndFailover(final ClusterController clusterController) throws ActiveMQException, InterruptedException {
+      final RegistrationFailureForwarder registrationFailureForwarder = new RegistrationFailureForwarder();
+      // node locator isn't stateless and contains a live-list of candidate nodes to connect too, hence
+      // it MUST be reused for each replicateLive attempt
+      final LiveNodeLocator nodeLocator = createLiveNodeLocator(registrationFailureForwarder);
+      clusterController.addClusterTopologyListenerForReplication(nodeLocator);
+      try {
+         while (true) {
+            synchronized (this) {
+               if (closed) {
+                  return null;
+               }
+            }
+            final ReplicationFailure failure = replicateLive(clusterController, nodeLocator, registrationFailureForwarder);
+            if (failure == null) {
+               Thread.sleep(clusterController.getRetryIntervalForReplicatedCluster());
+               continue;
+            }
+            if (!activeMQServer.isStarted()) {
+               return null;
+            }
+            LOGGER.debugf(""ReplicationFailure = %s"", failure);
+            boolean voluntaryFailOver = false;
+            switch (failure) {
+               case VoluntaryFailOver:
+                  voluntaryFailOver = true;
+               case NonVoluntaryFailover:
+                  final DistributedLock liveLock = tryAcquireLiveLock();
+                  // from now on we're meant to stop:
+                  // - due to failover
+                  // - due to restart/stop
+                  assert stopping.get();
+                  if (liveLock != null) {
+                     return liveLock;
+                  }
+                  boolean restart = true;
+                  if (voluntaryFailOver && isFirstFailbackAttempt()) {
+                     restart = false;
+                     LOGGER.error(""Failed to fail-back: stopping broker based on quorum results"");
+                  } else {
+                     ActiveMQServerLogger.LOGGER.restartingAsBackupBasedOnQuorumVoteResults();
+                  }
+                  // let's ignore the stopping flag here, we're in control of it
+                  asyncRestartServer(activeMQServer, restart, false);","[{'comment': '```suggestion\r\n                  // disable quorum service unavailability handling and just treat this imperatively\r\n                  if (!stopping.compareAndSet(false, true)) {\r\n                     return null;\r\n                  }\r\n                  // from now on we\'re meant to stop:\r\n                  // - due to failover\r\n                  // - due to restart/stop\r\n                  DistributedLock liveLockWithInSyncReplica;\r\n                  try {\r\n                     liveLockWithInSyncReplica = tryActivate();\r\n                  } catch (Throwable error) {\r\n                     LOGGER.debug(""Errored while attempting activation"", error);\r\n                     liveLockWithInSyncReplica = null;\r\n                  }\r\n                  assert stopping.get();\r\n                  if (liveLockWithInSyncReplica != null) {\r\n                     return liveLockWithInSyncReplica;\r\n                  }\r\n                  boolean restart = true;\r\n                  if (voluntaryFailOver && isFirstFailbackAttempt()) {\r\n                     restart = false;\r\n                     LOGGER.error(""Failed to fail-back: stopping broker based on quorum results"");\r\n                  } else {\r\n                     ActiveMQServerLogger.LOGGER.restartingAsBackupBasedOnQuorumVoteResults();\r\n                  }\r\n                  // let\'s ignore the stopping flag here, we\'re already in control of it\r\n                  asyncRestartServer(activeMQServer, restart, false);\r\n```', 'commenter': 'franz1981'}]"
3646,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ReplicationBackupActivation.java,"@@ -0,0 +1,692 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.activemq.artemis.core.server.impl;
+
+import javax.annotation.concurrent.GuardedBy;
+
+import java.util.Objects;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
+
+import org.apache.activemq.artemis.api.core.ActiveMQException;
+import org.apache.activemq.artemis.api.core.ActiveMQIllegalStateException;
+import org.apache.activemq.artemis.api.core.Pair;
+import org.apache.activemq.artemis.api.core.SimpleString;
+import org.apache.activemq.artemis.api.core.TransportConfiguration;
+import org.apache.activemq.artemis.core.protocol.core.Channel;
+import org.apache.activemq.artemis.core.replication.ReplicationEndpoint;
+import org.apache.activemq.artemis.core.server.ActiveMQServer;
+import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
+import org.apache.activemq.artemis.core.server.LiveNodeLocator;
+import org.apache.activemq.artemis.core.server.NodeManager;
+import org.apache.activemq.artemis.core.server.cluster.ClusterControl;
+import org.apache.activemq.artemis.core.server.cluster.ClusterController;
+import org.apache.activemq.artemis.core.server.cluster.ha.ReplicationBackupPolicy;
+import org.apache.activemq.artemis.quorum.DistributedLock;
+import org.apache.activemq.artemis.quorum.DistributedPrimitiveManager;
+import org.apache.activemq.artemis.quorum.MutableLong;
+import org.apache.activemq.artemis.quorum.UnavailableStateException;
+import org.jboss.logging.Logger;
+
+import static org.apache.activemq.artemis.core.server.impl.ReplicationObserver.ReplicationFailure;
+
+/**
+ * This activation can be used by a primary while trying to fail-back ie {@code failback == true} or
+ * by a natural-born backup ie {@code failback == false}.<br>
+ */
+public final class ReplicationBackupActivation extends Activation implements DistributedPrimitiveManager.UnavailableManagerListener {
+
+   private static final Logger LOGGER = Logger.getLogger(ReplicationBackupActivation.class);
+
+   private final boolean wasLive;
+   private final ReplicationBackupPolicy policy;
+   private final ActiveMQServerImpl activeMQServer;
+   // This field is != null iff this node is a primary during a fail-back ie acting as a backup in order to become live again.
+   private final String expectedNodeID;
+   @GuardedBy(""this"")
+   private boolean closed;
+   private final DistributedPrimitiveManager distributedManager;
+   // Used for monitoring purposes
+   private volatile ReplicationObserver replicationObserver;
+   // Used for testing purposes
+   private volatile ReplicationEndpoint replicationEndpoint;
+   // Used for testing purposes
+   private Consumer<ReplicationEndpoint> onReplicationEndpointCreation;
+   // Used to arbiter one-shot server stop/restart
+   private final AtomicBoolean stopping;
+
+   public ReplicationBackupActivation(final ActiveMQServerImpl activeMQServer,
+                                      final boolean wasLive,
+                                      final DistributedPrimitiveManager distributedManager,
+                                      final ReplicationBackupPolicy policy) {
+      this.wasLive = wasLive;
+      this.activeMQServer = activeMQServer;
+      if (policy.isTryFailback()) {
+         final SimpleString serverNodeID = activeMQServer.getNodeID();
+         if (serverNodeID == null || serverNodeID.isEmpty()) {
+            throw new IllegalStateException(""A failback activation must be biased around a specific NodeID"");
+         }
+         this.expectedNodeID = serverNodeID.toString();
+      } else {
+         this.expectedNodeID = null;
+      }
+      this.distributedManager = distributedManager;
+      this.policy = policy;
+      this.replicationObserver = null;
+      this.replicationEndpoint = null;
+      this.stopping = new AtomicBoolean(false);
+   }
+
+   /**
+    * used for testing purposes.
+    */
+   public DistributedPrimitiveManager getDistributedManager() {
+      return distributedManager;
+   }
+
+   @Override
+   public void onUnavailableManagerEvent() {
+      synchronized (this) {
+         if (closed) {
+            return;
+         }
+      }
+      LOGGER.info(""Unavailable quorum service detected: try restart server"");
+      asyncRestartServer(activeMQServer, true);
+   }
+
+   /**
+    * This util class exists because {@link LiveNodeLocator} need a {@link LiveNodeLocator.BackupRegistrationListener}
+    * to forward backup registration failure events: this is used to switch on/off backup registration event listening
+    * on an existing locator.
+    */
+   private static final class RegistrationFailureForwarder implements LiveNodeLocator.BackupRegistrationListener, AutoCloseable {
+
+      private static final LiveNodeLocator.BackupRegistrationListener NOOP_LISTENER = ignore -> {
+      };
+      private volatile LiveNodeLocator.BackupRegistrationListener listener = NOOP_LISTENER;
+
+      public RegistrationFailureForwarder to(LiveNodeLocator.BackupRegistrationListener listener) {
+         this.listener = listener;
+         return this;
+      }
+
+      @Override
+      public void onBackupRegistrationFailed(boolean alreadyReplicating) {
+         listener.onBackupRegistrationFailed(alreadyReplicating);
+      }
+
+      @Override
+      public void close() {
+         listener = NOOP_LISTENER;
+      }
+   }
+
+   @Override
+   public void run() {
+      synchronized (this) {
+         if (closed) {
+            return;
+         }
+      }
+      try {
+         LOGGER.infof(""Trying to reach the majority of quorum nodes"");
+         distributedManager.start();
+         LOGGER.debug(""Quorum service available"");
+
+         if (policy.isTryFailback()) {
+            // we are replicating to overwrite our data, transient backup state while trying to be the primary
+         } else {
+            // we may be a valid insync_replica (backup) if our activation sequence is largest for a nodeId
+            // verify that before removing data..
+            final DistributedLock liveLockWithInSyncReplica = checkForInSyncReplica();
+            if (liveLockWithInSyncReplica != null) {
+               // retain state and start as live
+               if (!activeMQServer.initialisePart1(false)) {
+                  return;
+               }
+               activeMQServer.setState(ActiveMQServerImpl.SERVER_STATE.STARTED);
+               startAsLive(liveLockWithInSyncReplica);
+               return;
+            }
+         }
+         distributedManager.addUnavailableManagerListener(this);
+         // Stop the previous node manager and create a new one with NodeManager::replicatedBackup == true:
+         // NodeManager::start skip setup lock file with NodeID, until NodeManager::stopBackup is called.
+         activeMQServer.resetNodeManager();
+         // A primary need to preserve NodeID across runs
+         activeMQServer.moveServerData(policy.getMaxSavedReplicatedJournalsSize(), policy.isTryFailback());
+         activeMQServer.getNodeManager().start();
+         if (!activeMQServer.initialisePart1(false)) {
+            return;
+         }
+         synchronized (this) {
+            if (closed)
+               return;
+         }
+
+
+         final ClusterController clusterController = activeMQServer.getClusterManager().getClusterController();
+
+         LOGGER.infof(""Apache ActiveMQ Artemis Backup Server version %s [%s] started, awaiting connection to a live cluster member to start replication"", activeMQServer.getVersion().getFullVersion(),
+                      activeMQServer.toString());
+
+         clusterController.awaitConnectionToReplicationCluster();
+         activeMQServer.getBackupManager().start();
+         activeMQServer.setState(ActiveMQServerImpl.SERVER_STATE.STARTED);
+         final DistributedLock liveLock = replicateAndFailover(clusterController);
+         if (liveLock == null) {
+            return;
+         }
+         startAsLive(liveLock);
+      } catch (Exception e) {
+         if ((e instanceof InterruptedException || e instanceof IllegalStateException) && !activeMQServer.isStarted()) {
+            // do not log these errors if the server is being stopped.
+            return;
+         }
+         ActiveMQServerLogger.LOGGER.initializationError(e);
+      }
+   }
+
+   private DistributedLock checkForInSyncReplica() throws InterruptedException, ExecutionException, TimeoutException, UnavailableStateException {
+      final long nodeActivationSequence = activeMQServer.getNodeManager().readNodeActivationSequence();
+      if (nodeActivationSequence > 0) {
+         // not an empty backup (first start), let see if we can get the lock and verify our data activation sequence
+         final String lockAndLongId = activeMQServer.getNodeManager().getNodeId().toString();
+         final DistributedLock activationLock = distributedManager.getDistributedLock(lockAndLongId);
+         try (MutableLong coordinatedNodeSequence = distributedManager.getMutableLong(lockAndLongId)) {
+            while (true) {
+               // dirty read is sufficient to know if we are *not* an in sync replica
+               // typically the lock owner will increment to signal our data is stale and we are happy without any
+               // further coordination at this point
+               final long currentCoordinatedNodeSequence = coordinatedNodeSequence.get();
+               if (nodeActivationSequence != currentCoordinatedNodeSequence) {
+                  LOGGER.infof(""Not a candidate for NodeID = %s activation, local activation sequence %d does not match coordinated activation sequence %d"", lockAndLongId, nodeActivationSequence, currentCoordinatedNodeSequence);
+                  activationLock.close();
+                  return null;
+               }
+               // our data may be current, start coordinating to verify
+               if (!activationLock.tryLock(policy.getVoteRetryWait(), TimeUnit.MILLISECONDS)) {
+                  LOGGER.debugf(""Candidate for Node ID = %s, with local activation sequence: %d, cannot acquire live lock within %dms; retrying"", lockAndLongId, nodeActivationSequence, policy.getVoteRetryWait());
+                  continue;
+               }
+               final long lockedCoordinatedNodeSequence = coordinatedNodeSequence.get();
+               if (nodeActivationSequence != lockedCoordinatedNodeSequence) {
+                  LOGGER.infof(""Not a candidate for NodeID = %s activation, local activation sequence %d does not match current coordinated activation sequence %d"", lockAndLongId, nodeActivationSequence, lockedCoordinatedNodeSequence);
+                  activationLock.close();
+                  return null;
+               }
+               // we are an in_sync_replica, good to go live as UNREPLICATED
+               LOGGER.infof(""Assuming live role for NodeID = %s, local activation sequence %d matches current coordinated activation sequence %d"", lockAndLongId, nodeActivationSequence, lockedCoordinatedNodeSequence);
+               return activationLock;
+            }
+         }
+      } else {
+         LOGGER.debugf(""Activation sequence is 0"");
+         return null;
+      }
+   }
+
+   static void ensureSequentialAccessToNodeData(ActiveMQServer activeMQServer,
+                                                DistributedPrimitiveManager distributedPrimitiveManager, final Logger logger) throws ActiveMQException, InterruptedException, UnavailableStateException, ExecutionException, TimeoutException {
+
+      final NodeManager nodeManager = activeMQServer.getNodeManager();
+      final String lockAndLongId = nodeManager.getNodeId().toString();
+      final long nodeActivationSequence = nodeManager.readNodeActivationSequence();
+
+      final DistributedLock liveLock = distributedPrimitiveManager.getDistributedLock(lockAndLongId);
+      if (liveLock.isHeldByCaller()) {
+         MutableLong coordinatedNodeActivationSequence = distributedPrimitiveManager.getMutableLong(lockAndLongId);
+         if (nodeActivationSequence != coordinatedNodeActivationSequence.get()) {
+            final String message = String.format(""Server [%s], cannot assume live role for NodeID = %s, local activation sequence %d does not match current coordinated sequence %d"", activeMQServer, lockAndLongId, nodeActivationSequence, coordinatedNodeActivationSequence.get());
+            logger.info(message);
+            throw new ActiveMQException(message);
+         }
+
+         // UN_REPLICATED STATE ENTER
+         if (coordinatedNodeActivationSequence.compareAndSet(nodeActivationSequence, nodeActivationSequence + 1)) {
+            nodeManager.writeNodeActivationSequence(nodeActivationSequence + 1);
+            logger.infof(""Server [%s], incremented coordinated activation sequence to: %d for NodeId = %s"", activeMQServer, nodeActivationSequence + 1, lockAndLongId);
+         } else {
+            final String message = String.format(""Server [%s], cannot assume live role for NodeID = %s, compareAndSet failed, local activation sequence %d no longer matches current coordinated sequence %d"", activeMQServer, lockAndLongId, nodeActivationSequence, coordinatedNodeActivationSequence.get());
+            logger.info(message);
+            throw new ActiveMQException(message);
+         }
+      } else {
+         final String message = String.format(""Server [%s], live lock for NodeID = %s, not held, activation sequence cannot be safely incremented to %d"", activeMQServer, lockAndLongId, nodeActivationSequence);
+         logger.info(message);
+         throw new UnavailableStateException(message);
+      }
+   }
+
+   private void startAsLive(final DistributedLock liveLock) throws Exception {
+      activeMQServer.setHAPolicy(policy.getLivePolicy());
+
+      synchronized (activeMQServer) {
+         if (!activeMQServer.isStarted()) {
+            liveLock.close();
+            return;
+         }
+         ensureSequentialAccessToNodeData(activeMQServer, distributedManager, LOGGER);
+
+         ActiveMQServerLogger.LOGGER.becomingLive(activeMQServer);
+         // stopBackup is going to write the NodeID previously set on the NodeManager,
+         // because activeMQServer.resetNodeManager() has created a NodeManager with replicatedBackup == true.
+         activeMQServer.getNodeManager().stopBackup();
+         activeMQServer.getStorageManager().start();
+         activeMQServer.getBackupManager().activated();
+         // IMPORTANT:
+         // we're setting this activation JUST because it would allow the server to use its
+         // getActivationChannelHandler to handle replication
+         final ReplicationPrimaryActivation primaryActivation = new ReplicationPrimaryActivation(activeMQServer, distributedManager, policy.getLivePolicy());
+         liveLock.addListener(primaryActivation);
+         activeMQServer.setActivation(primaryActivation);
+         activeMQServer.initialisePart2(false);
+         // calling primaryActivation.stateChanged !isHelByCaller is necessary in case the lock was unavailable
+         // before liveLock.addListener: just throwing an exception won't stop the broker.
+         final boolean stillLive;
+         try {
+            stillLive = liveLock.isHeldByCaller();
+         } catch (UnavailableStateException e) {
+            LOGGER.warn(e);
+            primaryActivation.onUnavailableLockEvent();
+            throw new ActiveMQIllegalStateException(""This server cannot check its role as a live: activation is failed"");
+         }
+         if (!stillLive) {
+            primaryActivation.onUnavailableLockEvent();
+            throw new ActiveMQIllegalStateException(""This server is not live anymore: activation is failed"");
+         }
+         if (activeMQServer.getIdentity() != null) {
+            ActiveMQServerLogger.LOGGER.serverIsLive(activeMQServer.getIdentity());
+         } else {
+            ActiveMQServerLogger.LOGGER.serverIsLive();
+         }
+         activeMQServer.completeActivation(true);
+      }
+   }
+
+   private LiveNodeLocator createLiveNodeLocator(final LiveNodeLocator.BackupRegistrationListener registrationListener) {
+      if (expectedNodeID != null) {
+         assert policy.isTryFailback();
+         return new NamedLiveNodeIdLocatorForReplication(expectedNodeID, registrationListener, policy.getRetryReplicationWait());
+      }
+      return policy.getGroupName() == null ?
+         new AnyLiveNodeLocatorForReplication(registrationListener, activeMQServer, policy.getRetryReplicationWait()) :
+         new NamedLiveNodeLocatorForReplication(policy.getGroupName(), registrationListener, policy.getRetryReplicationWait());
+   }
+
+   private DistributedLock replicateAndFailover(final ClusterController clusterController) throws ActiveMQException, InterruptedException {
+      final RegistrationFailureForwarder registrationFailureForwarder = new RegistrationFailureForwarder();
+      // node locator isn't stateless and contains a live-list of candidate nodes to connect too, hence
+      // it MUST be reused for each replicateLive attempt
+      final LiveNodeLocator nodeLocator = createLiveNodeLocator(registrationFailureForwarder);
+      clusterController.addClusterTopologyListenerForReplication(nodeLocator);
+      try {
+         while (true) {
+            synchronized (this) {
+               if (closed) {
+                  return null;
+               }
+            }
+            final ReplicationFailure failure = replicateLive(clusterController, nodeLocator, registrationFailureForwarder);
+            if (failure == null) {
+               Thread.sleep(clusterController.getRetryIntervalForReplicatedCluster());
+               continue;
+            }
+            if (!activeMQServer.isStarted()) {
+               return null;
+            }
+            LOGGER.debugf(""ReplicationFailure = %s"", failure);
+            boolean voluntaryFailOver = false;
+            switch (failure) {
+               case VoluntaryFailOver:
+                  voluntaryFailOver = true;
+               case NonVoluntaryFailover:
+                  final DistributedLock liveLock = tryAcquireLiveLock();
+                  // from now on we're meant to stop:
+                  // - due to failover
+                  // - due to restart/stop
+                  assert stopping.get();
+                  if (liveLock != null) {
+                     return liveLock;
+                  }
+                  boolean restart = true;
+                  if (voluntaryFailOver && isFirstFailbackAttempt()) {
+                     restart = false;
+                     LOGGER.error(""Failed to fail-back: stopping broker based on quorum results"");
+                  } else {
+                     ActiveMQServerLogger.LOGGER.restartingAsBackupBasedOnQuorumVoteResults();
+                  }
+                  // let's ignore the stopping flag here, we're in control of it
+                  asyncRestartServer(activeMQServer, restart, false);
+                  return null;
+               case RegistrationError:
+                  LOGGER.error(""Stopping broker because of critical registration error"");
+                  asyncRestartServer(activeMQServer, false);
+                  return null;
+               case AlreadyReplicating:
+                  // can just retry here, data should be clean and nodeLocator
+                  // should remove the live node that has answered this
+                  LOGGER.info(""Live broker was already replicating: retry sync with another live"");
+                  continue;
+               case ClosedObserver:
+                  return null;
+               case BackupNotInSync:
+                  LOGGER.info(""Replication failure while initial sync not yet completed: restart as backup"");
+                  asyncRestartServer(activeMQServer, true);
+                  return null;
+               case WrongNodeId:
+                  LOGGER.error(""Stopping broker because of wrong node ID communication from live: maybe a misbehaving live?"");
+                  asyncRestartServer(activeMQServer, false);
+                  return null;
+               default:
+                  throw new AssertionError(""Unsupported failure "" + failure);
+            }
+         }
+      } finally {
+         silentExecution(""Error on cluster topology listener for replication cleanup"", () -> clusterController.removeClusterTopologyListenerForReplication(nodeLocator));
+      }
+   }
+
+   /**
+    * {@code wasLive} is {code true} only while transitioning from primary to backup.<br>
+    * If a natural born backup become live and allows failback, while transitioning to back again
+    * {@code wasLive} is still {@code false}.<br>
+    * The check on {@link ReplicationBackupPolicy#isTryFailback()} is redundant but still useful for correctness.
+    * <p>
+    * In case of fail-back, any event that's going to restart this broker as backup (eg quorum service unavailable
+    * or some replication failures) will cause {@code wasLive} to be {@code false}, because the HA policy set isn't
+    * a primary anymore.
+    */
+   private boolean isFirstFailbackAttempt() {
+      return wasLive && policy.isTryFailback();
+   }
+
+   private DistributedLock tryAcquireLiveLock() throws InterruptedException {
+      // disable quorum service unavailability handling and just treat this imperatively
+      if (!stopping.compareAndSet(false, true)) {
+         // already unavailable quorum service: fail fast
+         return null;
+      }
+      distributedManager.removeUnavailableManagerListener(this);
+      assert activeMQServer.getNodeManager().getNodeId() != null;
+      final String liveID = activeMQServer.getNodeManager().getNodeId().toString();
+      final int voteRetries = policy.getVoteRetries();
+      final long maxAttempts = voteRetries >= 0 ? (voteRetries + 1) : -1;
+      if (maxAttempts == -1) {
+         LOGGER.error(""It's not safe to retry an infinite amount of time to acquire a live lock: please consider setting a vote-retries value"");
+      }
+      final long voteRetryWait = policy.getVoteRetryWait();
+      final DistributedLock liveLock = getLock(distributedManager, liveID);
+      if (liveLock == null) {
+         return null;
+      }
+      for (long attempt = 0; maxAttempts < 0 || (attempt < maxAttempts); attempt++) {
+         try {
+            if (liveLock.tryLock(voteRetryWait, TimeUnit.MILLISECONDS)) {
+               LOGGER.debugf(""%s live lock acquired after %d attempt(s)."", liveID, (attempt + 1));
+               return liveLock;
+            }
+         } catch (UnavailableStateException e) {
+            LOGGER.warnf(e, ""Failed to acquire live lock %s because of unavailable quorum service: stop trying"", liveID);
+            distributedManager.stop();
+            return null;
+         }
+      }
+      LOGGER.warnf(""Failed to acquire live lock %s after %d tries"", liveID, maxAttempts);
+      distributedManager.stop();
+      return null;
+   }","[{'comment': '```suggestion\r\n```', 'commenter': 'franz1981'}]"
3673,artemis-server/src/main/java/org/apache/activemq/artemis/core/postoffice/impl/PostOfficeImpl.java,"@@ -1289,29 +1289,13 @@ public MessageReference reload(final Message message, final Queue queue, final T
    public Pair<RoutingContext, Message> redistribute(final Message message,
                                                      final Queue originatingQueue,
                                                      final Transaction tx) throws Exception {
-      Bindings bindings = addressManager.getBindingsForRoutingAddress(originatingQueue.getAddress());
+      Bindings bindings = addressManager.getBindingsForRoutingAddress(SimpleString.toSimpleString(message.getAddress()));
 
       if (bindings != null && bindings.allowRedistribute()) {
          // We have to copy the message and store it separately, otherwise we may lose remote bindings in case of restart before the message
          // arrived the target node
          // as described on https://issues.jboss.org/browse/JBPAPP-6130
          Message copyRedistribute = message.copy(storageManager.generateID());
-         copyRedistribute.setAddress(originatingQueue.getAddress());
-
-         if (tx != null) {","[{'comment': 'Isnt this re-introducing an old bug that left large messages hanging around when transactional.', 'commenter': 'michaelandrepearce'}, {'comment': 'no. that is dead code.', 'commenter': 'gtully'}]"
3673,artemis-server/src/main/java/org/apache/activemq/artemis/core/postoffice/impl/PostOfficeImpl.java,"@@ -1289,29 +1289,13 @@ public MessageReference reload(final Message message, final Queue queue, final T
    public Pair<RoutingContext, Message> redistribute(final Message message,
                                                      final Queue originatingQueue,
                                                      final Transaction tx) throws Exception {
-      Bindings bindings = addressManager.getBindingsForRoutingAddress(originatingQueue.getAddress());
+      Bindings bindings = addressManager.getBindingsForRoutingAddress(SimpleString.toSimpleString(message.getAddress()));","[{'comment': 'Why creating simple string of the address why not call - getAddressSimpleString', 'commenter': 'michaelandrepearce'}, {'comment': 'good call, will fix', 'commenter': 'gtully'}]"
3673,artemis-server/src/main/java/org/apache/activemq/artemis/core/postoffice/impl/PostOfficeImpl.java,"@@ -1289,29 +1289,13 @@ public MessageReference reload(final Message message, final Queue queue, final T
    public Pair<RoutingContext, Message> redistribute(final Message message,
                                                      final Queue originatingQueue,
                                                      final Transaction tx) throws Exception {
-      Bindings bindings = addressManager.getBindingsForRoutingAddress(originatingQueue.getAddress());","[{'comment': 'Is this not breaking change for use case where a message is moved from its original address (which may have redistribute set to OFF)  to another address/queue and address (which has different settings e.g. redistribute ON_DEMAND), from which it then needs to re-distribute..... e.g. where manually re-routed, or diverts, or auto dlq/expiries are used.... and they have redistribution on them.', 'commenter': 'michaelandrepearce'}, {'comment': ""I don't think so, redistribution (when enabled via a redistribution-delay != -1 is redistributing the message. Where it was stuck is just an artefact of where it is stuck. The message is still the message.\r\nthe wrangling of the address seems to come from a bad fix for a problem with prefixes left in messages."", 'commenter': 'gtully'}, {'comment': 'But the point is the address could be different if the message has been diverted or moved within the broker. Redistribution should use the queue its being Redistributed from not the messages set value. As Redistribution is at the queue level.', 'commenter': 'michaelandrepearce'}, {'comment': 'the divert case is ok, a divert copies and sets the target address on the copy. What is the move case?\r\nThe scenario where it breaks is where the queue is a wildcard queue, not a routable address. I am really reverting a change from 3years ago that looks like it was done for the wrong reason, prefixes being left on a message.\r\nsee: https://github.com/apache/activemq-artemis/commit/f09bde07dfa56e2c65ccf04adf8e158003fd673b', 'commenter': 'gtully'}, {'comment': 'as far as I know, the redistribution will send to a specific queue.. not a reroute, so Divert should not be in play.', 'commenter': 'clebertsuconic'}, {'comment': 'the crux of the problem here is that the queue address contains wildcards and those are not valid in for finding matching bindings or as the message address. you cannot send to a.#, you can only consume a.b from a.#', 'commenter': 'gtully'}, {'comment': 'move case is where you move a message using admin function. Or in case of DLQ or Expiry Queues, where message is auto moved into corresponding defined dlq or expiry queue.', 'commenter': 'michaelandrepearce'}, {'comment': 'would better solution here be then to look up binding by queue name from the queue itself? not by address. As redistribution is at queue level anyhow?', 'commenter': 'michaelandrepearce'}, {'comment': 'i didnt see any comment on this....', 'commenter': 'michaelpearce-gain'}, {'comment': ""I don't think that will work with wildcards, b/c the queue can be bound multiple times, depending on what addresses it matches. Also a remote a/+ is a match for a local a/#, both match a message published to address a.b\r\n"", 'commenter': 'gtully'}, {'comment': 'I just peeked at queueImpl.move (used by dlq and expiry), it will reset the message address. so a DLQ address can be redistributed ok. Is that your concern?', 'commenter': 'gtully'}]"
3676,tests/integration-tests/src/test/java/org/apache/activemq/artemis/tests/integration/cluster/distribution/MessageRedistributionTest.java,"@@ -730,6 +730,40 @@ public void testRedistributionWhenRemoteConsumerIsAdded() throws Exception {
       verifyNotReceive(1);
    }
 
+   @Test
+   public void testRedistributionWhenRemoteConsumerIsAddedLbOff() throws Exception {
+      setupCluster(MessageLoadBalancingType.OFF);","[{'comment': ""This test is actually proving we're introducing a breaking change... for message balancing is off, redistribution should NOT occur."", 'commenter': 'michaelandrepearce'}, {'comment': ""there are two features in play, the initial load balancing on routing, and redistribution. The fact that they are currently intertwined is a bug, they do different things, this is clear in the code and in the existing doc.\r\n\r\nThis change separates them further, and what breaks was already broken.\r\nThis is my read of what breaks:\r\nenabling redistribution with redistribution-delay != -1 and then using LoadBalanceType.OFF to disable redistribution!.\r\n\r\nclearly, to disable redistribution, leave  redistribution-delay at the default of -1. ie: don't configure it in the first place.\r\n\r\nThe 'broken' case, which is just wrong, can be called out in the release note.\r\n\r\nthis is a new test that captures the 'now' more clear separation of the features, they are independent and useful when combined.\r\n\r\n"", 'commenter': 'gtully'}, {'comment': 'Can we simply just introduce a new setting it is far far safer and better. I see no need to have this as a release note and have users to have breaks when it can be sooo easily avoided with a different setting value', 'commenter': 'michaelandrepearce'}]"
3742,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -218,17 +218,17 @@ private void checkIDSupplier(NodeStore<MessageReference> nodeStore) {
 
    protected final ScheduledDeliveryHandler scheduledDeliveryHandler;
 
-   private AtomicLong messagesAdded = new AtomicLong(0);
+   private final AtomicLong messagesAdded = new AtomicLong(0);","[{'comment': 'Sometime we use AtomicLongFieldUpdater and sometime we use AtomicLong. This could be the chance to unify the way we treat counters like these, chosing a single tool for the job...\r\n\r\nIMO if these counters are not used for logic, but for telemetry, probably a `LongAdder` (or some of the JCTools counters) would work much better then `AtomicLong/AtomicLongFieldUpdater`. because `LongAdder` scales way better and cost must less for the thread that increment it, especially if is happening in the hot path', 'commenter': 'franz1981'}, {'comment': 'QueueImpl is a heavy object.. I agree the FieldUPdater would be better on this case. it would help make it lighter.', 'commenter': 'clebertsuconic'}, {'comment': 'am going to leave that to a separate PR and investigate AtomicLongFieldUpdater', 'commenter': 'gtully'}]"
3742,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -218,17 +218,17 @@ private void checkIDSupplier(NodeStore<MessageReference> nodeStore) {
 
    protected final ScheduledDeliveryHandler scheduledDeliveryHandler;
 
-   private AtomicLong messagesAdded = new AtomicLong(0);
+   private final AtomicLong messagesAdded = new AtomicLong(0);
 
-   private AtomicLong messagesAcknowledged = new AtomicLong(0);
+   private final AtomicLong messagesAcknowledged = new AtomicLong(0);
 
-   private AtomicLong ackAttempts = new AtomicLong(0);
+   private final AtomicLong ackAttempts = new AtomicLong(0);","[{'comment': 'hmmm... not part of your change.. but if you could improve it with the FieldUpdater :)', 'commenter': 'clebertsuconic'}, {'comment': 'the FieldUpdater thing I asked is a wish... not mandatory for your PR... if you can do it.. great... otherwise we can make it another PR for that.', 'commenter': 'clebertsuconic'}, {'comment': ""It should certainly be in a separate commit if it is done, it has nothing to do with this 'refactoring' (arguably neither do the finals)."", 'commenter': 'gemmellr'}, {'comment': 'in hindsight I should not have touched the finals! but for sure that can be another PR', 'commenter': 'gtully'}]"
3742,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -1572,18 +1556,7 @@ public synchronized void cancelRedistributor() {
 
    @Override
    public int getConsumerCount() {
-      // we don't want to count the redistributor, it is an internal transient entry in the consumer list
-      if (redistributor != null) {
-         synchronized (this) {
-            final int size = consumers.size();
-            if (size > 0 && redistributor != null) {
-               return size - 1;
-            } else {
-               return size;
-            }
-         }
-      }
-      return consumers.size();
+      return refCountForConsumers.getCount();","[{'comment': 'I dont like this tbh, you have a collection with is consumers, should just use its value, else we end up having issues of one size thing being different from another.', 'commenter': 'michaelandrepearce'}, {'comment': 'e.g. what happens if someone adds new code to add something into consumer collection, but doesnt remember to update this other ref counter thing.', 'commenter': 'michaelandrepearce'}, {'comment': 'the point is there are two different counts, now that consumers has a redistributor that is internal. The need to keep then in sync is not new and it is confined to add/remove consumers', 'commenter': 'gtully'}]"
3742,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -179,7 +179,7 @@
 
    protected final PageSubscription pageSubscription;
 
-   private ReferenceCounter refCountForConsumers;
+   protected final ReferenceCounter refCountForConsumers;","[{'comment': ""Why 'protected'? It was private before and doesnt seem to be used elsewhere now, and there was/is still a getter if it is."", 'commenter': 'gemmellr'}, {'comment': 'true, that is not necessary. will fix. thanks! ', 'commenter': 'gtully'}]"
3742,artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/QueueImpl.java,"@@ -3082,9 +3055,7 @@ private boolean deliver() {
                   numNoMatch = 0;
                   numAttempts = 0;
 
-                  if (consumer != redistributor) {
-                     ref = handleMessageGroup(ref, consumer, groupConsumer, groupID);
-                  }
+                  ref = handleMessageGroup(ref, consumer, groupConsumer, groupID);","[{'comment': 'If the redistributor now handles groups and didnt before, does it need to do anything extra when it is cancelled that it wasnt doing before (since it didnt need to) that e.g other consumers currently do when removed?', 'commenter': 'gemmellr'}, {'comment': 'that != was always false, it was comparing different types in error. has been that way seems since the beginning. the redistributor has logic to reply busy when a message has groups, so it will never handle a group message.  the handle returns the ref if there are no group bits in play so it is safe to always call it.', 'commenter': 'gtully'}, {'comment': 'it did handle groups before!', 'commenter': 'gtully'}, {'comment': ""Seems the incorrect typed check went in with the previous commit in place of a null check looking to similarly protect it: \r\nhttps://github.com/apache/activemq-artemis/commit/224b89810d023e3ee73b014a48585da8f6048237#diff-fc4a9a0dc01f79ecc1435246dc85446fa57d6d04e1dffed53c522d8c145623fdR3085\r\n\r\nBut yep, didnt know that the redistributor handle check returns NO_MATCH (it only returns 'busy' if not active), so it never got to either of those old checks anyway (though by returning 'NO_MATCH' it will reset the consumers iterator, meaning any consumer after it in the list isnt getting tried until it goes away...)."", 'commenter': 'gemmellr'}, {'comment': 'the reset on NO_MATCH I am not understanding. Does that make sense to you?', 'commenter': 'gtully'}, {'comment': ""Not particularly no. Neither does the one for 'HANDLED' entirely. Both seem to suggest it will always prefer earlier consumers until they arent 'busy enough' to let it try others. Though it wont then try the others if there is a 'NO_MATCH', it will try the earlier ones again even if still busy.\r\n\r\nLooking over it several times now, there is at least the fact that adding a consumer always cancels the redistributor during the process, removing it before adding the new consumer to the consumer list, so the redistributor shouldnt ever end up in the middle of the list...so the reset in the redistributor case shouldn't really be different than hitting the end of the list.\r\n\r\nThe only other thing I do see for the non-distributor case is that you apparently need to call reset to see updates to the consumer list (such as the above new consumer), which can change as the loop is processing due to the fact it goes in and out of the synchronization. Kind of feels like the obvious point for that is at the end of the existing entries though rather on the first no-match."", 'commenter': 'gemmellr'}, {'comment': 'ok, the reset() is necessary to have any consumer get a second message or try the next message in its iterator. If there are 6 messages pending and the first does not match, unless we reset, that consumer does not get to check the other 5 till the next delivery attempt. With the reset, it is a candidate for another immediate loop.', 'commenter': 'gtully'}, {'comment': 'of note: the reset() does not put the cursor back to the start, rather it moves the end such that the current element gets another go. The iterator is circular if reset is called. In this way, reset does not skip the next element.', 'commenter': 'gtully'}, {'comment': 'Javadoc could probably do with an update to describe the actual behaviour then if thats the case:  reset() ""Resets the iterator so you can re-iterate over all elements."" \r\n\r\nLast I looked at it it seemed to me like it would reset the cursor (especially if there was a new consumer added before, since it replaced the underlying iterator entirely with a new one), which is what I would expect a \'reset\' method to do. There is a separate \'repeat()\' I think that I would expect to do what you just described.\r\n\r\n', 'commenter': 'gemmellr'}, {'comment': 'I have updated the javadoc.  the reset - will pick up changes, but will continue iteration with a restart from the current point, essentially making the collection circular.\r\nThe repeat, just replays the last element.', 'commenter': 'gtully'}, {'comment': 'It didnt seem like it would continue from the current point (especially if there were changes, when it replaces the underlying iterator) since it implements the reset() with a ""moveTo(-1)"".\r\n\r\nBut, on closer inspection, it seems to do a mixture of things - it apparently _does_ reset the cursor to the start as I thought due to the above, but that cursor is only in terms of \'the highest priority\' sub-iterator. However it _does not_ reset the cursor within that particular sub-iterator to the start (except perhaps when it has changed, when I guess it will thanks to replacing the iterators). The stuff going on here so far isnt hitting the priority variation, so it isnt seeing the distinction, so only seems to behave like you described so far.\r\n\r\nIn short, I dont think it works exactly like either of us think it does, and I\'m thinking that QueueConsumersImplTest is lacking some tests to verify whatever its actually meant to be doing overall.', 'commenter': 'gemmellr'}]"
3841,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/message/openmbean/MessageOpenTypeFactory.java,"@@ -123,6 +124,7 @@ protected void init() throws OpenDataException {
    public Map<String, Object> getFields(M m, int valueSizeLimit, int deliveryCount) throws OpenDataException {
       Map<String, Object> rc = new HashMap<>();
       rc.put(CompositeDataConstants.MESSAGE_ID, """" + m.getMessageID());
+      rc.put(CompositeDataConstants.PROTOCOL, m.getClass().getSimpleName());","[{'comment': 'This is a bit dangerous as it exposes class name to api, can we make this something more explicit e.g. add interface to message api such as (getProtocol) and then for the protocol implementation classes to implement that returning a constant value.', 'commenter': 'michaelandrepearce'}, {'comment': ""That was my original thought, until I saw how self-descriptive the class-names were.\r\nI'll follow the original thought and your suggestion.\r\nStill, I'll make the default implementation getClass().getSimpleName() because there are internal classes and client classes for which the name is never shown."", 'commenter': 'erwindon'}, {'comment': 'please ignore the remark about getClass().getSimpleName(). there are only very few internal classes that are not a sub of CoreMessage. so that problem is negligable.', 'commenter': 'erwindon'}, {'comment': 'we could add a method on Message to return a more user friendly word? \r\n\r\non Message:\r\n   public String getProtocol();\r\n   \r\n   \r\n   then on core you return ""CORE"" and AMQP you return ""AMQP""\r\n   \r\n   ?\r\n', 'commenter': 'clebertsuconic'}, {'comment': 'I already made that change exactly as you and Michael suggest. that code is in the next commit.', 'commenter': 'erwindon'}, {'comment': 'maybe I should squash to prevent confusion?', 'commenter': 'erwindon'}]"
3862,artemis-core-client/src/main/java/org/apache/activemq/artemis/utils/XidPayloadException.java,"@@ -0,0 +1,29 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.utils;
+
+/**
+ * Special type of exception with stacktrace removed which is thrown when binary payload representing
+ * [{@link javax.transaction.xa.Xid}] is invalid.
+ */
+public class XidPayloadException extends RuntimeException {
+
+   public XidPayloadException(String message) {","[{'comment': 'Iirc it should overload fill stack trace and do nothing on it in order to be stackless', 'commenter': 'franz1981'}, {'comment': 'There are few ways to achieve the same effect.\r\nI am creating parent `RuntimeException` with `writableStackTrace = false`, see line below which also ensures stacktrace is not populated.\r\n\r\nI have extended the unit test to illustrate my point.', 'commenter': 'vkolomeyko'}]"
3862,artemis-core-client/src/main/java/org/apache/activemq/artemis/utils/XidCodecSupport.java,"@@ -33,15 +33,20 @@ public static void encodeXid(final Xid xid, final ActiveMQBuffer out) {
    }
 
    private static byte[] safeReadBytes(final ActiveMQBuffer in) {
-      int claimedSize = in.readInt();
-      int bufferCapacity = in.capacity();
+      final int claimedSize = in.readInt();
+
+      if (claimedSize < 0) {
+         throw new XidPayloadException(""Payload size cannot be negative"");
+      }
+
+      final int readableBytes = in.readableBytes();
       // We have to be defensive here and not try to allocate byte buffer straight from information available in the
       // stream. Or else, an adversary may handcraft the packet causing OOM situation for a running JVM.
-      if (claimedSize > bufferCapacity) {
-         throw new IllegalStateException(""Buffer size: "" + claimedSize +
-                 "" exceeds overall buffer size of: "" + bufferCapacity);
+      if (claimedSize > readableBytes) {
+         throw new XidPayloadException(""Attempted to read: "" + claimedSize +","[{'comment': 'Why do you actually need a Custom Exception here?', 'commenter': 'clebertsuconic'}, {'comment': 'This was to address input from @franz1981 : https://github.com/apache/activemq-artemis/pull/3862#issuecomment-974047110\r\nTo create a custom exception that does not have stacktrace populated.\r\n\r\n@clebertsuconic - I note your remark on `ActiveMQAMQPIllegalStateException` and I am flexible to use either approach. ', 'commenter': 'vkolomeyko'}]"
3876,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireConnection.java,"@@ -213,6 +239,7 @@ public OpenWireConnection(Connection connection,
       this.useKeepAlive = openWireProtocolManager.isUseKeepAlive();
       this.maxInactivityDuration = openWireProtocolManager.getMaxInactivityDuration();
       this.transportConnection.setProtocolConnection(this);
+      this.maxActorSize = openWireProtocolManager.getMaxActorSize();","[{'comment': 'I would use an actor which queue is bounded (we have many in JCtools) adding a method boolean tryAct\r\nthat return false if the queue has reached maximum capacity.\r\nThis would be more performant and easy to manage, given that could be used by other part of code to limit the size of tasks on the actor.\r\n', 'commenter': 'franz1981'}, {'comment': ' the thing is, I may have to go beyond the limit some times.. because the parse on the packet already happened. and the messages were already read from the network. I have to read them all.', 'commenter': 'clebertsuconic'}]"
3876,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireProtocolManager.java,"@@ -97,6 +100,8 @@
 
    private boolean prefixPacketSize = true;
 
+   private int maxActorSize = 20;","[{'comment': 'the actor is in units of commands, I wonder if it would be possible to limit by bytes size and match to the configured serverSocketBuffer size. I guess that raw bytes are already unmarshalled when we are dealing with commands.\r\nIt is just that it seems natural to map the pending data on in the broker to what can be pending on the tcp layer. So from a client perspective there is max 2*socketBufferSize bytes pending. Or maybe it is 3x, with one being on the client side of the tcp buffer.', 'commenter': 'gtully'}, {'comment': ""I wouldn't know how to do that TBH"", 'commenter': 'clebertsuconic'}, {'comment': 'I was going with 1000, but my computer is slow to sync due to some crypto thing...\r\n\r\n\r\nI have not decided on the default yet.. but this is mostly about syncs...\r\n\r\n\r\nthe other thing is I will probably make those writes to the journal to not sync if the client is not waiting for a response.', 'commenter': 'clebertsuconic'}]"
3876,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireConnection.java,"@@ -285,21 +333,41 @@ public void bufferReceived(Object connectionID, ActiveMQBuffer buffer) {
             traceBufferReceived(connectionID, command);
          }
 
-         final Actor<Command> localVisibleActor = openWireActor;
-         if (localVisibleActor != null) {
-            openWireActor.act(command);
-         } else {
-            act(command);
-         }
+         runOnActor(command);
       } catch (Exception e) {
          ActiveMQServerLogger.LOGGER.debug(e);
          sendException(e);
       }
 
    }
 
+   public void restoreAutoRead() {
+      if (!autoRead) {
+         autoRead = true;
+         openWireActor.act(flushWrite);
+      }
+   }
+
+   public void disableAutoRead() {
+      autoRead = false;
+      getTransportConnection().setAutoRead(false);
+   }
+
+   protected void actualEnableAutoReadAndTtl() {
+      getTransportConnection().setAutoRead(autoRead);","[{'comment': ""should this no go through checkMemory - to sync up with the page store blocking. If the page store is still blocked we don't want to enable auto read till there is some space.\r\n\r\nI am thinking, we don't have to be careful about disabling auto read, b/c we will aways get to do it again... but with enabling, having an empty work queue is not sufficient, there also has to be space. so we need to coordinate the enabling."", 'commenter': 'gtully'}, {'comment': '@gtully when blocked, autoRead will be false.\r\n\r\nWe are still calling the flush o this case though.. \r\n\r\nwe will need the paging to send an event to set this call.', 'commenter': 'clebertsuconic'}]"
3876,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireConnection.java,"@@ -765,11 +810,19 @@ public AMQConnectionContext initContext(ConnectionInfo info) throws Exception {
       createInternalSession(info);
 
       // the actor can only be used after the WireFormat has been initialized with versioning
-      this.openWireActor = new Actor<>(executor, this::act);
+      this.openWireActor = new BoundActor<>(executor, this::act, maxActorSize, this::getSize, this::disableAutoRead, this::flushedActor);
 
       return context;
    }
 
+   private int getSize(Command command) {","[{'comment': '```suggestion\r\n   private static int getSize(Command command) {\r\n```', 'commenter': 'franz1981'}]"
3876,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireConnection.java,"@@ -765,11 +810,19 @@ public AMQConnectionContext initContext(ConnectionInfo info) throws Exception {
       createInternalSession(info);
 
       // the actor can only be used after the WireFormat has been initialized with versioning
-      this.openWireActor = new Actor<>(executor, this::act);
+      this.openWireActor = new BoundActor<>(executor, this::act, maxActorSize, this::getSize, this::disableAutoRead, this::flushedActor);
 
       return context;
    }
 
+   private int getSize(Command command) {
+      if (command instanceof ActiveMQMessage) {
+         return ((ActiveMQMessage) command).getSize();
+      } else {
+         return 1024; // we return 1k for anything else","[{'comment': 'Pack it into some static final constant with a meaningful name', 'commenter': 'franz1981'}]"
3876,artemis-commons/src/main/java/org/apache/activemq/artemis/utils/actors/BoundActor.java,"@@ -0,0 +1,79 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.utils.actors;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+import java.util.function.ToIntFunction;
+
+public class BoundActor<T> extends ProcessorBase<Object> {
+
+   private static final AtomicIntegerFieldUpdater<BoundActor> SIZE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(BoundActor.class, ""size"");
+   private volatile int size = 0;
+
+   private static final AtomicIntegerFieldUpdater<BoundActor> SCHEDULED_FUSH_UPDATER = AtomicIntegerFieldUpdater.newUpdater(BoundActor.class, ""scheduledFlush"");","[{'comment': 'Typo in name, FUSH', 'commenter': 'gemmellr'}]"
3876,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireProtocolManager.java,"@@ -236,6 +238,18 @@ public void removeConnection(ConnectionInfo info, Throwable error) throws Invali
       }
    }
 
+   /*** if set, the OpenWire connection will bypass the tcpReadBuferSize and use this value instead.
+    *   This is by default -1, and it should not be used unless in extreme situations like on a slow storage. */
+   public int getMaxActorSize() {","[{'comment': ""this does not make sense to me, a config that should not be used. The intent is to bound the queue and it is matched to the receive buffer size. if it needs to be lower or higher then modify the acceptor receive buffer size. The bounding of the actor stops reading, so at a max the receive buffer size will be pending on the socket and in the broker. Then the client will block on a tcp write. When will it make sense to have more than send buffer pending on the broker? I don't know how to reason about setting a maxActorSize on the protocol manager!\r\nin terms of a name, it could be actorPendingQueueMaxSizeBytes but that is an aside. Only add that if we know when it should be set."", 'commenter': 'gtully'}]"
3876,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireConnection.java,"@@ -213,6 +230,15 @@ public OpenWireConnection(Connection connection,
       this.useKeepAlive = openWireProtocolManager.isUseKeepAlive();
       this.maxInactivityDuration = openWireProtocolManager.getMaxInactivityDuration();
       this.transportConnection.setProtocolConnection(this);
+      if (openWireProtocolManager.getMaxActorSize() > 0) {
+         this.maxActorSize = openWireProtocolManager.getMaxActorSize();
+      } else {
+         if (acceptorUsed == null) {
+            this.maxActorSize = TransportConstants.DEFAULT_TCP_RECEIVEBUFFER_SIZE;
+         } else {
+            this.maxActorSize = ((NettyAcceptor) acceptorUsed).getTcpReceiveBufferSize();","[{'comment': 'this seems the only right option to me, if the actor can be used without an acceptor, then maybe pass in the maxPendingSize rather than the acceptorUsed.', 'commenter': 'gtully'}, {'comment': 'this will be null on tests only...', 'commenter': 'clebertsuconic'}]"
3876,artemis-commons/src/main/java/org/apache/activemq/artemis/utils/actors/BoundActor.java,"@@ -0,0 +1,79 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.utils.actors;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+import java.util.function.ToIntFunction;
+
+public class BoundActor<T> extends ProcessorBase<Object> {
+
+   private static final AtomicIntegerFieldUpdater<BoundActor> SIZE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(BoundActor.class, ""size"");
+   private volatile int size = 0;
+
+   private static final AtomicIntegerFieldUpdater<BoundActor> SCHEDULED_FUSH_UPDATER = AtomicIntegerFieldUpdater.newUpdater(BoundActor.class, ""scheduledFlush"");
+   private volatile int scheduledFlush = 0;
+
+   private static final Object FLUSH = new Object();
+
+
+   final int maxSize;
+   final ToIntFunction<T> sizeGetter;
+   ActorListener<T> listener;
+
+   Runnable overLimit;
+   Runnable clearLimit;
+
+   public BoundActor(Executor parent, ActorListener<T> listener, int maxSize, ToIntFunction<T> sizeGetter, Runnable overLimit, Runnable clearLimit) {
+      super(parent);
+      this.listener = listener;
+      this.maxSize = maxSize;
+      this.sizeGetter = sizeGetter;
+      this.overLimit = overLimit;
+      this.clearLimit = clearLimit;
+   }
+
+   @Override
+   protected final void doTask(Object task) {
+      if (task == FLUSH) {
+         this.scheduledFlush = 0;","[{'comment': 'Direct use of the variable can be confusing later when there is a FieldUpdater for it too, might be good to use that consistently.', 'commenter': 'gemmellr'}, {'comment': '`scheduledFlush` must be set to `0` after `clearLimit::run` or a racy `act` after this would call `overLimit::run` before it', 'commenter': 'franz1981'}]"
3876,artemis-commons/src/main/java/org/apache/activemq/artemis/utils/actors/BoundActor.java,"@@ -0,0 +1,79 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.utils.actors;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+import java.util.function.ToIntFunction;
+
+public class BoundActor<T> extends ProcessorBase<Object> {
+
+   private static final AtomicIntegerFieldUpdater<BoundActor> SIZE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(BoundActor.class, ""size"");
+   private volatile int size = 0;
+
+   private static final AtomicIntegerFieldUpdater<BoundActor> SCHEDULED_FUSH_UPDATER = AtomicIntegerFieldUpdater.newUpdater(BoundActor.class, ""scheduledFlush"");
+   private volatile int scheduledFlush = 0;
+
+   private static final Object FLUSH = new Object();
+
+
+   final int maxSize;
+   final ToIntFunction<T> sizeGetter;
+   ActorListener<T> listener;
+
+   Runnable overLimit;
+   Runnable clearLimit;
+
+   public BoundActor(Executor parent, ActorListener<T> listener, int maxSize, ToIntFunction<T> sizeGetter, Runnable overLimit, Runnable clearLimit) {
+      super(parent);
+      this.listener = listener;
+      this.maxSize = maxSize;
+      this.sizeGetter = sizeGetter;
+      this.overLimit = overLimit;
+      this.clearLimit = clearLimit;
+   }
+
+   @Override
+   protected final void doTask(Object task) {
+      if (task == FLUSH) {
+         this.scheduledFlush = 0;
+         clearLimit.run();
+         return;
+      }
+      try {
+         listener.onMessage((T)task);
+      } finally {
+         SIZE_UPDATER.getAndAdd(this, -sizeGetter.applyAsInt((T)task));
+      }
+   }
+
+   public void act(T message) {
+      int size = SIZE_UPDATER.addAndGet(this, (sizeGetter.applyAsInt((T)message)));","[{'comment': 'Are the (...) around the sizeGetter needed? Seems inconsistent with not having them in the method above.', 'commenter': 'gemmellr'}, {'comment': '`sizeGetter.applyAsInt((T)message)` should check if the estimated size is > 0', 'commenter': 'franz1981'}, {'comment': 'why?', 'commenter': 'clebertsuconic'}]"
3876,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireConnection.java,"@@ -765,11 +810,19 @@ public AMQConnectionContext initContext(ConnectionInfo info) throws Exception {
       createInternalSession(info);
 
       // the actor can only be used after the WireFormat has been initialized with versioning
-      this.openWireActor = new Actor<>(executor, this::act);
+      this.openWireActor = new BoundActor<>(executor, this::act, maxActorSize, this::getSize, this::disableAutoRead, this::flushedActor);
 
       return context;
    }
 
+   private int getSize(Command command) {
+      if (command instanceof ActiveMQMessage) {
+         return ((ActiveMQMessage) command).getSize();","[{'comment': ""did a quick check, the only way getSize would return a different value after act is if org.apache.activemq.command.ActiveMQMessage#clearProperties was called and from what I can see we don't do that so this is a reasonable estimate. \r\nThe 1k for other commands may be a little heavy, but I guess it is better to error on the side of caution. \r\nnice!"", 'commenter': 'gtully'}]"
3876,artemis-commons/src/main/java/org/apache/activemq/artemis/utils/actors/BoundActor.java,"@@ -0,0 +1,79 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.utils.actors;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+import java.util.function.ToIntFunction;
+
+public class BoundActor<T> extends ProcessorBase<Object> {
+
+   private static final AtomicIntegerFieldUpdater<BoundActor> SIZE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(BoundActor.class, ""size"");
+   private volatile int size = 0;
+
+   private static final AtomicIntegerFieldUpdater<BoundActor> SCHEDULED_FUSH_UPDATER = AtomicIntegerFieldUpdater.newUpdater(BoundActor.class, ""scheduledFlush"");
+   private volatile int scheduledFlush = 0;
+
+   private static final Object FLUSH = new Object();
+
+
+   final int maxSize;
+   final ToIntFunction<T> sizeGetter;","[{'comment': '`private final` on the members\r\n', 'commenter': 'franz1981'}]"
3876,artemis-commons/src/test/java/org/apache/activemq/artemis/utils/actors/BoundActorTest.java,"@@ -0,0 +1,94 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.utils.actors;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.activemq.artemis.utils.Wait;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class BoundActorTest {
+
+   Semaphore semaphore = new Semaphore(1);
+   AtomicInteger result = new AtomicInteger(0);
+   AtomicInteger lastProcessed = new AtomicInteger(0);
+
+   @Test
+   public void limitedSize() throws Exception {
+      final ExecutorService executorService = Executors.newSingleThreadExecutor();
+      AtomicInteger timesOpen = new AtomicInteger(0);
+      AtomicInteger timesClose = new AtomicInteger(0);
+      AtomicBoolean open = new AtomicBoolean(true);
+      try {
+         semaphore.acquire();
+         BoundActor<Integer> actor = new BoundActor<>(executorService, this::process, 10, (s) -> 1, () -> {
+            timesClose.incrementAndGet();
+            open.set(false);
+         }, () -> {
+            timesOpen.incrementAndGet();
+            open.set(true);
+         });
+
+         for (int i = 0; i < 10; i++) {
+            actor.act(i);
+         }
+         Assert.assertTrue(open.get());
+         Assert.assertEquals(0, timesClose.get());
+         actor.act(99);
+         Assert.assertEquals(1, timesClose.get());","[{'comment': 'Newlines separating blocks of activity and related checks can be quite nice for readability.', 'commenter': 'gemmellr'}]"
3876,artemis-commons/src/main/java/org/apache/activemq/artemis/utils/actors/BoundActor.java,"@@ -0,0 +1,79 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.utils.actors;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+import java.util.function.ToIntFunction;
+
+public class BoundActor<T> extends ProcessorBase<Object> {","[{'comment': 'Using Bound in the name feels awkward when it isnt actually bound in the way most might expect the word to suggest. Though I dont necessarily have a great alternative to suggest. NotifyingActor? :)', 'commenter': 'gemmellr'}]"
3876,tests/smoke-tests/src/test/java/org/apache/activemq/artemis/tests/smoke/paging/FloodServerWithAsyncSendTest.java,"@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.tests.smoke.paging;
+
+import javax.jms.Connection;
+import javax.jms.ConnectionFactory;
+import javax.jms.MessageConsumer;
+import javax.jms.MessageProducer;
+import javax.jms.Queue;
+import javax.jms.Session;
+import javax.jms.TextMessage;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.activemq.artemis.tests.smoke.common.SmokeTestBase;
+import org.apache.activemq.artemis.tests.util.CFUtil;
+import org.apache.activemq.artemis.utils.RandomUtil;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class FloodServerWithAsyncSendTest extends SmokeTestBase {
+
+   public static final String SERVER_NAME_0 = ""paging"";
+
+   volatile boolean running = true;
+
+   AtomicInteger errors = new AtomicInteger(0);
+
+   @Before
+   public void before() throws Exception {
+      cleanupData(SERVER_NAME_0);
+      startServer(SERVER_NAME_0, 0, 30000);
+   }
+
+   @Test
+   public void testAsyncPagingOpenWire() throws Exception {
+      String protocol = ""OPENWIRE"";
+      internalTest(protocol);
+
+   }
+
+   ConnectionFactory newCF(String protocol) {
+      if (protocol.equalsIgnoreCase(""OPENWIRE"")) {
+         return CFUtil.createConnectionFactory(protocol, ""tcp://localhost:61616?jms.useAsyncSend=true"");
+      } else {
+         Assert.fail(""unsuported protocol"");
+         return null;
+      }
+   }
+
+   private void internalTest(String protocol) throws Exception {
+
+      Thread consume1 = new Thread(() -> consume(protocol, ""queue1""), ""ProducerQueue1"");
+      consume1.start();
+      Thread consume2 = new Thread(() -> consume(protocol, ""queue2""), ""ProducerQueue2"");
+      consume2.start();
+
+      Thread produce1 = new Thread(() -> produce(protocol, ""queue1""), ""ConsumerQueue1"");
+      produce1.start();
+      Thread produce2 = new Thread(() -> produce(protocol, ""queue2""), ""ConsumerQueue2"");
+      produce2.start();","[{'comment': 'Names look inverted, consumer using ""ProducerQueue1"", producer using ""ConsumerQueue1"" etc.\r\n\r\nUsing an executor might be nicer in terms of readability and cleanup etc.', 'commenter': 'gemmellr'}]"
3876,tests/smoke-tests/src/test/java/org/apache/activemq/artemis/tests/smoke/paging/FloodServerWithAsyncSendTest.java,"@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.tests.smoke.paging;
+
+import javax.jms.Connection;
+import javax.jms.ConnectionFactory;
+import javax.jms.MessageConsumer;
+import javax.jms.MessageProducer;
+import javax.jms.Queue;
+import javax.jms.Session;
+import javax.jms.TextMessage;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.activemq.artemis.tests.smoke.common.SmokeTestBase;
+import org.apache.activemq.artemis.tests.util.CFUtil;
+import org.apache.activemq.artemis.utils.RandomUtil;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class FloodServerWithAsyncSendTest extends SmokeTestBase {
+
+   public static final String SERVER_NAME_0 = ""paging"";
+
+   volatile boolean running = true;
+
+   AtomicInteger errors = new AtomicInteger(0);
+
+   @Before
+   public void before() throws Exception {
+      cleanupData(SERVER_NAME_0);
+      startServer(SERVER_NAME_0, 0, 30000);
+   }
+
+   @Test
+   public void testAsyncPagingOpenWire() throws Exception {
+      String protocol = ""OPENWIRE"";
+      internalTest(protocol);
+
+   }
+
+   ConnectionFactory newCF(String protocol) {
+      if (protocol.equalsIgnoreCase(""OPENWIRE"")) {
+         return CFUtil.createConnectionFactory(protocol, ""tcp://localhost:61616?jms.useAsyncSend=true"");
+      } else {
+         Assert.fail(""unsuported protocol"");
+         return null;
+      }
+   }
+
+   private void internalTest(String protocol) throws Exception {
+
+      Thread consume1 = new Thread(() -> consume(protocol, ""queue1""), ""ProducerQueue1"");
+      consume1.start();
+      Thread consume2 = new Thread(() -> consume(protocol, ""queue2""), ""ProducerQueue2"");
+      consume2.start();
+
+      Thread produce1 = new Thread(() -> produce(protocol, ""queue1""), ""ConsumerQueue1"");
+      produce1.start();
+      Thread produce2 = new Thread(() -> produce(protocol, ""queue2""), ""ConsumerQueue2"");
+      produce2.start();
+
+      Thread.sleep(10_000);
+
+      running = false;
+
+      consume1.join();
+      consume2.join();
+      produce1.join();
+      produce2.join();
+
+      ConnectionFactory factory = newCF(""openwire"");
+      Connection connection = factory.createConnection();
+      connection.start();
+      Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+      Queue queue = session.createQueue(""queue3"");
+      MessageConsumer consumer = session.createConsumer(queue);
+
+      MessageProducer producer = session.createProducer(queue);
+
+      String random = RandomUtil.randomString();
+
+      producer.send(session.createTextMessage(random));
+      TextMessage message = (TextMessage) consumer.receive(1000);
+      Assert.assertNotNull(message);
+      Assert.assertEquals(random, message.getText());
+      connection.close();
+
+      Assert.assertEquals(0, errors.get());
+
+   }
+
+   protected void consume(String protocol, String queueName) {
+      ConnectionFactory factory = newCF(protocol);
+      Connection connection = null;
+      try {
+         connection = factory.createConnection();
+         connection.start();
+         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+         Queue queue = session.createQueue(queueName);
+         MessageConsumer consumer = session.createConsumer(queue);
+         int rec = 0;
+         while (running) {
+            consumer.receive(5000);","[{'comment': 'If should probably check it actually gets something expected before counting it.\r\n\r\nThis test could even pass without the threaded producers/consumers actually doing anything so long as they dont throw, only the third producer/consumers single message affects the result otherwise.', 'commenter': 'gemmellr'}]"
3876,tests/smoke-tests/src/test/java/org/apache/activemq/artemis/tests/smoke/paging/FloodServerWithAsyncSendTest.java,"@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.tests.smoke.paging;
+
+import javax.jms.Connection;
+import javax.jms.ConnectionFactory;
+import javax.jms.MessageConsumer;
+import javax.jms.MessageProducer;
+import javax.jms.Queue;
+import javax.jms.Session;
+import javax.jms.TextMessage;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.activemq.artemis.tests.smoke.common.SmokeTestBase;
+import org.apache.activemq.artemis.tests.util.CFUtil;
+import org.apache.activemq.artemis.utils.RandomUtil;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class FloodServerWithAsyncSendTest extends SmokeTestBase {
+
+   public static final String SERVER_NAME_0 = ""paging"";
+
+   volatile boolean running = true;
+
+   AtomicInteger errors = new AtomicInteger(0);
+
+   @Before
+   public void before() throws Exception {
+      cleanupData(SERVER_NAME_0);
+      startServer(SERVER_NAME_0, 0, 30000);
+   }
+
+   @Test
+   public void testAsyncPagingOpenWire() throws Exception {
+      String protocol = ""OPENWIRE"";
+      internalTest(protocol);
+
+   }
+
+   ConnectionFactory newCF(String protocol) {
+      if (protocol.equalsIgnoreCase(""OPENWIRE"")) {
+         return CFUtil.createConnectionFactory(protocol, ""tcp://localhost:61616?jms.useAsyncSend=true"");
+      } else {
+         Assert.fail(""unsuported protocol"");
+         return null;
+      }
+   }
+
+   private void internalTest(String protocol) throws Exception {
+
+      Thread consume1 = new Thread(() -> consume(protocol, ""queue1""), ""ProducerQueue1"");
+      consume1.start();
+      Thread consume2 = new Thread(() -> consume(protocol, ""queue2""), ""ProducerQueue2"");
+      consume2.start();
+
+      Thread produce1 = new Thread(() -> produce(protocol, ""queue1""), ""ConsumerQueue1"");
+      produce1.start();
+      Thread produce2 = new Thread(() -> produce(protocol, ""queue2""), ""ConsumerQueue2"");
+      produce2.start();
+
+      Thread.sleep(10_000);
+
+      running = false;
+
+      consume1.join();
+      consume2.join();
+      produce1.join();
+      produce2.join();
+
+      ConnectionFactory factory = newCF(""openwire"");
+      Connection connection = factory.createConnection();
+      connection.start();
+      Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+      Queue queue = session.createQueue(""queue3"");
+      MessageConsumer consumer = session.createConsumer(queue);
+
+      MessageProducer producer = session.createProducer(queue);
+
+      String random = RandomUtil.randomString();
+
+      producer.send(session.createTextMessage(random));
+      TextMessage message = (TextMessage) consumer.receive(1000);
+      Assert.assertNotNull(message);
+      Assert.assertEquals(random, message.getText());
+      connection.close();
+
+      Assert.assertEquals(0, errors.get());
+
+   }
+
+   protected void consume(String protocol, String queueName) {
+      ConnectionFactory factory = newCF(protocol);
+      Connection connection = null;
+      try {
+         connection = factory.createConnection();
+         connection.start();
+         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+         Queue queue = session.createQueue(queueName);
+         MessageConsumer consumer = session.createConsumer(queue);
+         int rec = 0;
+         while (running) {
+            consumer.receive(5000);
+            rec++;
+            if (rec % 10 == 0) {","[{'comment': 'Every 10 seems like it could be quite spammy, given the test length. Something larger, plus a log of the final total as it exits the loop (and perhaps when it throws), might seem nicer.', 'commenter': 'gemmellr'}]"
3876,tests/smoke-tests/src/test/java/org/apache/activemq/artemis/tests/smoke/paging/FloodServerWithAsyncSendTest.java,"@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.tests.smoke.paging;
+
+import javax.jms.Connection;
+import javax.jms.ConnectionFactory;
+import javax.jms.MessageConsumer;
+import javax.jms.MessageProducer;
+import javax.jms.Queue;
+import javax.jms.Session;
+import javax.jms.TextMessage;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.activemq.artemis.tests.smoke.common.SmokeTestBase;
+import org.apache.activemq.artemis.tests.util.CFUtil;
+import org.apache.activemq.artemis.utils.RandomUtil;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class FloodServerWithAsyncSendTest extends SmokeTestBase {
+
+   public static final String SERVER_NAME_0 = ""paging"";
+
+   volatile boolean running = true;
+
+   AtomicInteger errors = new AtomicInteger(0);
+
+   @Before
+   public void before() throws Exception {
+      cleanupData(SERVER_NAME_0);
+      startServer(SERVER_NAME_0, 0, 30000);
+   }
+
+   @Test
+   public void testAsyncPagingOpenWire() throws Exception {
+      String protocol = ""OPENWIRE"";
+      internalTest(protocol);
+
+   }
+
+   ConnectionFactory newCF(String protocol) {
+      if (protocol.equalsIgnoreCase(""OPENWIRE"")) {
+         return CFUtil.createConnectionFactory(protocol, ""tcp://localhost:61616?jms.useAsyncSend=true"");
+      } else {
+         Assert.fail(""unsuported protocol"");
+         return null;
+      }
+   }
+
+   private void internalTest(String protocol) throws Exception {
+
+      Thread consume1 = new Thread(() -> consume(protocol, ""queue1""), ""ProducerQueue1"");
+      consume1.start();
+      Thread consume2 = new Thread(() -> consume(protocol, ""queue2""), ""ProducerQueue2"");
+      consume2.start();
+
+      Thread produce1 = new Thread(() -> produce(protocol, ""queue1""), ""ConsumerQueue1"");
+      produce1.start();
+      Thread produce2 = new Thread(() -> produce(protocol, ""queue2""), ""ConsumerQueue2"");
+      produce2.start();
+
+      Thread.sleep(10_000);
+
+      running = false;
+
+      consume1.join();
+      consume2.join();
+      produce1.join();
+      produce2.join();
+
+      ConnectionFactory factory = newCF(""openwire"");
+      Connection connection = factory.createConnection();
+      connection.start();
+      Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+      Queue queue = session.createQueue(""queue3"");
+      MessageConsumer consumer = session.createConsumer(queue);
+
+      MessageProducer producer = session.createProducer(queue);
+
+      String random = RandomUtil.randomString();
+
+      producer.send(session.createTextMessage(random));
+      TextMessage message = (TextMessage) consumer.receive(1000);
+      Assert.assertNotNull(message);
+      Assert.assertEquals(random, message.getText());
+      connection.close();
+
+      Assert.assertEquals(0, errors.get());
+
+   }
+
+   protected void consume(String protocol, String queueName) {
+      ConnectionFactory factory = newCF(protocol);
+      Connection connection = null;
+      try {
+         connection = factory.createConnection();
+         connection.start();
+         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+         Queue queue = session.createQueue(queueName);
+         MessageConsumer consumer = session.createConsumer(queue);
+         int rec = 0;
+         while (running) {
+            consumer.receive(5000);
+            rec++;
+            if (rec % 10 == 0) {
+               System.out.println(queueName + "" receive "" + rec);
+            }
+         }
+      } catch (Throwable e) {
+         e.printStackTrace();
+         errors.incrementAndGet();
+      } finally {
+         try {
+            connection.close();
+         } catch (Exception ignored) {
+         }
+      }
+   }
+
+   protected void produce(String protocol, String queueName) {
+
+      int produced = 0;
+      ConnectionFactory factory = newCF(protocol);
+      Connection connection = null;
+      try {
+
+         connection = factory.createConnection();
+         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+         Queue queue = session.createQueue(queueName);
+         MessageProducer producer = session.createProducer(queue);
+         String randomString;
+         {
+            StringBuffer buffer = new StringBuffer();
+            while (buffer.length() < 10000) {
+               buffer.append(RandomUtil.randomString());
+            }
+            randomString = buffer.toString();
+         }
+
+         while (running) {
+            if (++produced % 10 == 0) {","[{'comment': 'Same as previous comment', 'commenter': 'gemmellr'}]"
3876,tests/smoke-tests/src/test/java/org/apache/activemq/artemis/tests/smoke/paging/FloodServerWithAsyncSendTest.java,"@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.artemis.tests.smoke.paging;
+
+import javax.jms.Connection;
+import javax.jms.ConnectionFactory;
+import javax.jms.MessageConsumer;
+import javax.jms.MessageProducer;
+import javax.jms.Queue;
+import javax.jms.Session;
+import javax.jms.TextMessage;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.activemq.artemis.tests.smoke.common.SmokeTestBase;
+import org.apache.activemq.artemis.tests.util.CFUtil;
+import org.apache.activemq.artemis.utils.RandomUtil;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class FloodServerWithAsyncSendTest extends SmokeTestBase {
+
+   public static final String SERVER_NAME_0 = ""paging"";
+
+   volatile boolean running = true;
+
+   AtomicInteger errors = new AtomicInteger(0);
+
+   @Before
+   public void before() throws Exception {
+      cleanupData(SERVER_NAME_0);
+      startServer(SERVER_NAME_0, 0, 30000);
+   }
+
+   @Test
+   public void testAsyncPagingOpenWire() throws Exception {
+      String protocol = ""OPENWIRE"";
+      internalTest(protocol);
+
+   }
+
+   ConnectionFactory newCF(String protocol) {
+      if (protocol.equalsIgnoreCase(""OPENWIRE"")) {
+         return CFUtil.createConnectionFactory(protocol, ""tcp://localhost:61616?jms.useAsyncSend=true"");
+      } else {
+         Assert.fail(""unsuported protocol"");
+         return null;
+      }
+   }
+
+   private void internalTest(String protocol) throws Exception {
+
+      Thread consume1 = new Thread(() -> consume(protocol, ""queue1""), ""ProducerQueue1"");
+      consume1.start();
+      Thread consume2 = new Thread(() -> consume(protocol, ""queue2""), ""ProducerQueue2"");
+      consume2.start();
+
+      Thread produce1 = new Thread(() -> produce(protocol, ""queue1""), ""ConsumerQueue1"");
+      produce1.start();
+      Thread produce2 = new Thread(() -> produce(protocol, ""queue2""), ""ConsumerQueue2"");
+      produce2.start();
+
+      Thread.sleep(10_000);","[{'comment': 'This perhaps feels like it would be better as a soak test (even taking a good bit longer than this) rather than a smoke test needing to burn >10sec on every run.', 'commenter': 'gemmellr'}]"
3876,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireProtocolManager.java,"@@ -236,6 +238,18 @@ public void removeConnection(ConnectionInfo info, Throwable error) throws Invali
       }
    }
 
+   /*** if set, the OpenWire connection will bypass the tcpReadBuferSize and use this value instead.
+    *   This is by default -1, and it should not be used unless in extreme situations like on a slow storage. */
+   public int getMaxActorSize() {
+      return maxActorSize;
+   }
+
+   public OpenWireProtocolManager setMaxActorSize(int maxActorSize) {
+      System.out.println(""max actor size "" + maxActorSize);","[{'comment': 'Leftover System.out.println ? / Use a logger.', 'commenter': 'gemmellr'}]"
3876,artemis-server/src/main/java/org/apache/activemq/artemis/core/paging/impl/PagingStoreImpl.java,"@@ -713,6 +713,9 @@ public boolean checkMemory(boolean runOnFailure, final Runnable runWhenAvailable
          }
       } else if (pagingManager.isDiskFull() || addressFullMessagePolicy == AddressFullMessagePolicy.BLOCK && (maxSize != -1 || usingGlobalMaxSize)) {
          if (pagingManager.isDiskFull() || maxSize > 0 && sizeInBytes.get() >= maxSize || pagingManager.isGlobalFull()) {
+            if (runWhenBlocking != null) {
+               runWhenBlocking.run();","[{'comment': 'Might be worth addressing https://issues.apache.org/jira/browse/ARTEMIS-3591 here too if this overall change raises the importance of when and how often the callbacks are being run.', 'commenter': 'gemmellr'}]"
3876,artemis-server/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyAcceptor.java,"@@ -396,6 +396,12 @@ private Object loadSSLContext() {
       }
    }
 
+
+   public int getTcpReceiveBufferSize() {
+      return tcpReceiveBufferSize;
+   }
+","[{'comment': 'Superfluous newlines before+after.', 'commenter': 'gemmellr'}]"
3927,tests/integration-tests/src/test/java/org/apache/activemq/artemis/tests/integration/openwire/amq/RedeliveryPolicyTest.java,"@@ -355,6 +359,53 @@ public void testMaximumRedeliveryDelay() throws Exception {
       assertTrue(policy.getNextRedeliveryDelay(Long.MAX_VALUE) == 1000);
    }
 
+   /**
+    * @throws Exception
+    */
+   @Test
+   public void testRedeliveryRefCleanup() throws Exception {
+
+      // Receive a message with the JMS API
+      RedeliveryPolicy policy = connection.getRedeliveryPolicy();
+      policy.setUseExponentialBackOff(false);
+      policy.setMaximumRedeliveries(-1);
+      policy.setRedeliveryDelay(50);
+
+      connection.start();
+      Session pSession = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
+      Session cSession = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
+      ActiveMQQueue destination = new ActiveMQQueue(""TEST"");
+      this.makeSureCoreQueueExist(""TEST"");
+      MessageProducer producer = pSession.createProducer(destination);
+      MessageConsumer consumer = cSession.createConsumer(destination);
+
+      TextMessage m;
+
+      for (int i = 0; i < 5; ++i) {
+         producer.send(pSession.createTextMessage(""MessageText""));
+         pSession.commit();
+         m = (TextMessage) consumer.receive(2000);
+         assertNotNull(m);
+         cSession.rollback();
+         m = (TextMessage) consumer.receive(2000);
+         assertNotNull(m);
+         cSession.commit();
+      }
+      ServerConsumer serverConsumer = null;
+      for (ServerSession session : server.getSessions()) {
+         for (ServerConsumer sessionConsumer : session.getServerConsumers()) {
+            if (sessionConsumer.getQueue().getName().toString() == ""TEST"") {
+               serverConsumer = sessionConsumer;
+            }
+         }
+      }
+      AMQConsumer amqConsumer = (AMQConsumer) serverConsumer.getProtocolData();","[{'comment': 'At this point it would be better to be able to query `AMQConsumer` re rolledbackMessageRefs directly, exposing an ad-hoc method used just for testing purposes ', 'commenter': 'franz1981'}, {'comment': ""Okay, I'll see what I can do about that. Thanks!"", 'commenter': 'AntonRoskvist'}, {'comment': '@franz1981 Is this looking better?', 'commenter': 'AntonRoskvist'}, {'comment': ""TBH I'm not a great fan as well to expose public members, but probably there's no easier way to do it"", 'commenter': 'franz1981'}, {'comment': ""That's actually why I went with the first option to begin with... I've spent 10 times more time on the test than on the actual fix haha.\r\n\r\nI'm open to changing it to whatever is most appropriate though so just let me know."", 'commenter': 'AntonRoskvist'}, {'comment': ""What's wrong with the accessor? It's easy enough, right?\r\n\r\nOr am I missing something?"", 'commenter': 'clebertsuconic'}, {'comment': 'This is an older comment, discussion moved to another one, and an accessor class was added already.', 'commenter': 'gemmellr'}]"
3927,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/amq/AMQSession.java,"@@ -306,8 +306,6 @@ public int sendMessage(MessageReference reference,
                           ServerConsumer consumer,
                           int deliveryCount) {
       AMQConsumer theConsumer = (AMQConsumer) consumer.getProtocolData();
-      //clear up possible rolledback ids.
-      theConsumer.removeRolledback(reference);","[{'comment': ""I'm not 100% certain why this was added in the first place, but I think it would be safer to leave it here. As far as I can tell it's not hurting anything."", 'commenter': 'jbertram'}]"
3927,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/amq/AMQConsumer.java,"@@ -493,4 +495,10 @@ private boolean isRolledBack(MessageReference messageReference) {
       }
       return rollbackedMessageRefs.contains(messageReference);
    }
+
+   /** For tests only */
+   public Set<MessageReference> listRolledbackMessageRefs() {","[{'comment': 'Why not just make the existing `org.apache.activemq.artemis.core.protocol.openwire.amq.AMQConsumer#getRolledbackMessageRefs` public? The methods are exactly the same except for the access level.', 'commenter': 'jbertram'}, {'comment': 'Also perhaps rather than make it public at all, make it package-private or protected and add a test-tree class in the same package as it to act as an accessor, e.g Clebert uses this approach, for an example (which just changes such a class) see https://github.com/apache/activemq-artemis/commit/2383aa0125320713b9a753668b203a878c24b2e0#diff-7426cf013ea833e8f1c3cd71cd26e9b584755e13d1fc4ccb4bc95025598795f6', 'commenter': 'gemmellr'}, {'comment': 'Nice method!', 'commenter': 'franz1981'}, {'comment': ""Robbie's idea is even better."", 'commenter': 'jbertram'}, {'comment': ""Okay... I will try to get that working. Do I have to do anything in particular to be able to run the test classes from the integration-tests-suite? Might be an issue with my setup but I can't import: `org.apache.activemq.artemis.core.protocol.openwire.amq.AMQConsumerTest `\r\nstraight up?"", 'commenter': 'AntonRoskvist'}, {'comment': '@jbertram @gemmellr @franz1981 Is this looking better? Have not seen or done that kind of access before but it seems to be working like you described...', 'commenter': 'AntonRoskvist'}, {'comment': ""Not entirely no. I'll admit I hadnt noticed the test was in a different module when I gave that example where they are in the same one, but I still wouldnt approach it in this way.\r\n\r\nAdd the new test 'accessor' method in its own new class in the same package, not to the actual test class such as AMQConsumerTest, and place the new class near to the test that needs to use it, i.e in the integration tests module in this case. That will obviously be a split-package, but the integration-tests are not published and arent moduled so that shouldnt cause any issue currently, and theres then no need to add the far uglier test-jar usage."", 'commenter': 'gemmellr'}, {'comment': '@gemmellr Like this?', 'commenter': 'AntonRoskvist'}, {'comment': 'Yep, thats better', 'commenter': 'gemmellr'}]"
3927,tests/integration-tests/src/test/java/org/apache/activemq/artemis/tests/integration/openwire/amq/RedeliveryPolicyTest.java,"@@ -479,6 +483,54 @@ public void testCountersAreCorrectAfterSendToDLQ() throws Exception {
 
    }
 
+   /**
+    * @throws Exception
+    */
+   @Test
+   public void testRedeliveryRefCleanup() throws Exception {
+
+      // Receive a message with the JMS API
+      RedeliveryPolicy policy = connection.getRedeliveryPolicy();
+      policy.setUseExponentialBackOff(false);
+      policy.setMaximumRedeliveries(-1);
+      policy.setRedeliveryDelay(50);
+
+      connection.start();
+      Session pSession = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
+      Session cSession = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
+      ActiveMQQueue destination = new ActiveMQQueue(""TEST"");
+      this.makeSureCoreQueueExist(""TEST"");
+      MessageProducer producer = pSession.createProducer(destination);
+      MessageConsumer consumer = cSession.createConsumer(destination);
+
+      TextMessage m;
+
+      for (int i = 0; i < 5; ++i) {
+         producer.send(pSession.createTextMessage(""MessageText""));
+         pSession.commit();
+         m = (TextMessage) consumer.receive(2000);
+         assertNotNull(m);
+         cSession.rollback();
+         m = (TextMessage) consumer.receive(2000);
+         assertNotNull(m);
+         cSession.commit();
+      }
+
+      ServerConsumer serverConsumer = null;
+      for (ServerSession session : server.getSessions()) {
+         for (ServerConsumer sessionConsumer : session.getServerConsumers()) {
+            if (sessionConsumer.getQueue().getName().toString() == ""TEST"") {
+               serverConsumer = sessionConsumer;
+            }
+         }
+      }
+
+      AMQConsumer amqConsumer = (AMQConsumer) serverConsumer.getProtocolData();
+      assertTrue(AMQConsumerTest.getRolledbackMessageRefs(amqConsumer).isEmpty());
+      //assertTrue(amqConsumer.getRolledbackMessageRefs().isEmpty());","[{'comment': 'Leftover should be removed.', 'commenter': 'gemmellr'}]"
4023,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/amq/AMQSession.java,"@@ -91,7 +91,7 @@
 
    private final CoreMessageObjectPools coreMessageObjectPools;
 
-   private String[] existingQueuesCache;
+   static String[] existingQueuesCache;","[{'comment': 'This is quite dangerous, making the cache to leak and outlive a broker restart (thinking about activation/deactivation on HA)', 'commenter': 'franz1981'}, {'comment': 'I did consider placing this in the OpenWireProtocolManager instead but opted for this... Would you prefer I place it there and use setter/getter instead?', 'commenter': 'AntonRoskvist'}]"
4023,artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/amq/AMQSession.java,"@@ -196,26 +195,22 @@ public boolean updateDeliveryCountAfterCancel(ServerConsumer consumer, MessageRe
    private boolean checkCachedExistingQueues(final SimpleString address,
                                              final String physicalName,
                                              final boolean isTemporary) throws Exception {
-      String[] existingQueuesCache = this.existingQueuesCache;
       //lazy allocation of the cache
       if (existingQueuesCache == null) {
-         //16 means 64 bytes with 32 bit references or 128 bytes with 64 bit references -> 1 or 2 cache lines with common archs
          existingQueuesCache = new String[protocolManager.getOpenWireDestinationCacheSize()];
-         assert (Integer.bitCount(existingQueuesCache.length) == 1) : ""openWireDestinationCacheSize must be a power of 2"";
-         this.existingQueuesCache = existingQueuesCache;
       }
-      final int hashCode = physicalName.hashCode();
-      //this.existingQueuesCache.length must be power of 2
-      final int mask = existingQueuesCache.length - 1;
-      final int index = hashCode & mask;
+
+      final int index = Math.floorMod(physicalName.hashCode(), existingQueuesCache.length);","[{'comment': 'Modulus is a quite heavyweight operation, that\'s why the original code was using the mask trick using a power of two size: this would save impacting for the ""common"" use cases ie not many queues', 'commenter': 'franz1981'}, {'comment': 'Yes, but since now there will only be one such calculation per new queue, (plus new ones if the cache is full) I figure that might be cheaper overall anyway? I changed it because this method has a lower risk of creating identical hashes for different values (from my testing at least)...', 'commenter': 'AntonRoskvist'}]"
4098,artemis-server/src/main/java/org/apache/activemq/artemis/core/persistence/impl/journal/AbstractJournalStorageManager.java,"@@ -174,12 +174,20 @@ public static JournalContent getType(byte type) {
 
    protected final ScheduledExecutorService scheduledExecutorService;
 
-   protected final ReentrantReadWriteLock storageManagerLock = new ReentrantReadWriteLock(true);
+   protected final ReentrantReadWriteLock storageManagerLock = new ReentrantReadWriteLock(false);","[{'comment': 'Good catch!', 'commenter': 'franz1981'}]"
4098,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnection.java,"@@ -138,51 +137,47 @@ public boolean isOpen() {
 
    @Override
    public final void fireReady(final boolean ready) {
-      ArrayList<ReadyListener> readyToCall = localListenersPool.get();
-      if (readyToCall != null) {
-         localListenersPool.set(null);
+
+      // We are reusing a previously created ArrayList for this localArray
+      ArrayList<ReadyListener> localArrayList = readyListenersPool.get();","[{'comment': ""@franz1981 I'm changing this code you wrote here. This was also introducing many entires on the ThreadLocal."", 'commenter': 'clebertsuconic'}]"
4098,artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnection.java,"@@ -62,7 +61,7 @@ public class NettyConnection implements Connection {
     * here for when the connection (or Netty Channel) becomes available again.
     */
    private final List<ReadyListener> readyListeners = new ArrayList<>();
-   private final FastThreadLocal<ArrayList<ReadyListener>> localListenersPool = new FastThreadLocal<>();
+   private static final ThreadLocal<ArrayList<ReadyListener>> readyListenersPool = new ThreadLocal<>();","[{'comment': ""since we are now fixing whatever was broken with ThreadLocals before. I don't think we need the FastThreadLocal any more."", 'commenter': 'clebertsuconic'}, {'comment': 'Seems like it was unrelated, thats about Netty threads using an optimised form of ThreadLocal, and I guess expectation was it would be a Netty thread calling.', 'commenter': 'gemmellr'}, {'comment': ""Not really... in previous versions this was just using ThreadLocal. (2.16.0 is using a regular ThreadLocal).\r\n\r\nin more recent versions we started using the FastThreadLocal, that's just a ThreadLocal with its own Map away. (there will be a single HashMap entry on the Thread.threadLocals.\r\n\r\nthis is still an issue.. it should be static.\r\n\r\n\r\nI could still use the FastThreadlocal here. but I don't see a reason for."", 'commenter': 'clebertsuconic'}, {'comment': '@gemmellr even if I used FastThreadLocal here, it should still be a static declaration.', 'commenter': 'clebertsuconic'}, {'comment': 'I was commenting on your comment around FastThreadLocal...not anything about the separate change to static. I expect the change to use FastThreadLocal (in https://github.com/apache/activemq-artemis/commit/6126d926ddcdf34b740603e506878059ea663680) had nothing to do with ""whatever was broken with ThreadLocals before"" but was simply because its optimised for use by Netty threads and the expectation was a Netty thread will likely be calling it.', 'commenter': 'gemmellr'}, {'comment': ""@gemmellr I don't see a real advantage really... I will just make it static though."", 'commenter': 'clebertsuconic'}]"
4098,artemis-server/src/main/java/org/apache/activemq/artemis/core/persistence/impl/journal/AbstractJournalStorageManager.java,"@@ -2160,7 +2160,9 @@ public boolean addToPage(PagingStore store, Message msg, Transaction tx, RouteCo
        * <p>
        * The reasoning is that exposing the lock is more explicit and therefore `less bad`.
        */
-      return store.page(msg, tx, listCtx, storageManagerLock.readLock());
+      try (ArtemisCloseable closeable = closeableReadLock()) {
+         return store.page(msg, tx, listCtx);
+      }","[{'comment': 'The large comment above seems like it needs adjusting/removed as the lock is no longer passed/exposed.', 'commenter': 'gemmellr'}]"
4098,artemis-server/src/main/java/org/apache/activemq/artemis/core/persistence/impl/nullpm/NullStorageManager.java,"@@ -653,7 +653,7 @@ public boolean addToPage(PagingStore store,
        * The reasoning is that exposing the lock is more explicit and therefore `less bad`.
        */
       if (store != null) {
-         return store.page(msg, tx, listCtx, null);
+         return store.page(msg, tx, listCtx);","[{'comment': 'Needs adjusted similar to other comment (arguably made no sense to begin with as it didnt pass a lock..)', 'commenter': 'gemmellr'}]"
4098,pom.xml,"@@ -1131,7 +1131,7 @@
                               <arg>--add-exports=jdk.unsupported/sun.misc=ALL-UNNAMED</arg>
                               <arg>--add-exports=java.base/jdk.internal.misc=ALL-UNNAMED</arg>
                               <arg>-XDcompilePolicy=simple</arg>
-                              <arg>-Xplugin:ErrorProne -Xep:MissingOverride:ERROR -Xep:NonAtomicVolatileUpdate:ERROR -Xep:SynchronizeOnNonFinalField:ERROR -Xep:StaticQualifiedUsingExpression:ERROR -Xep:WaitNotInLoop:ERROR -XepExcludedPaths:.*/generated-sources/.*</arg>
+                              <arg>-Xplugin:ErrorProne -Xep:ThreadLocalUsage:ERROR -Xep:MissingOverride:ERROR -Xep:NonAtomicVolatileUpdate:ERROR -Xep:SynchronizeOnNonFinalField:ERROR -Xep:StaticQualifiedUsingExpression:ERROR -Xep:WaitNotInLoop:ERROR -XepExcludedPaths:.*/generated-sources/.*</arg>","[{'comment': 'You missed updating the similar-but-different config in the other profile below', 'commenter': 'gemmellr'}]"
4587,artemis-server/src/main/java/org/apache/activemq/artemis/core/config/impl/ConfigurationImpl.java,"@@ -773,6 +774,17 @@ public <T> T convert(Class<T> type, Object value) {
          }
       }, TransformerConfiguration.class);
 
+      beanUtils.getConvertUtils().register(new Converter() {
+         @Override
+         public <T> T convert(Class<T> type, Object value) {
+            //we only care about DATABASE type as it is the only one used
+            if (StoreConfiguration.StoreType.DATABASE.toString().equals(value)) {
+               return (T) new DatabaseStorageConfiguration();
+            }
+            return (T) null;","[{'comment': 'I think throw some runtimeexception here - value must be DATABASE, otherwise the error on the next set will be hard to debug', 'commenter': 'gtully'}, {'comment': 'Ive changed this', 'commenter': 'andytaylor'}]"
4587,artemis-server/src/main/java/org/apache/activemq/artemis/core/config/impl/ConfigurationImpl.java,"@@ -80,6 +80,7 @@
 import org.apache.activemq.artemis.core.config.ha.ReplicatedPolicyConfiguration;
 import org.apache.activemq.artemis.core.config.routing.NamedPropertyConfiguration;
 import org.apache.activemq.artemis.core.config.storage.DatabaseStorageConfiguration;
+import org.apache.activemq.artemis.core.config.storage.FileStorageConfiguration;","[{'comment': 'that looks unused', 'commenter': 'gtully'}]"
4587,artemis-server/src/test/java/org/apache/activemq/artemis/core/config/impl/ConfigurationImplTest.java,"@@ -1554,6 +1555,48 @@ public void testSystemPropKeyReplacement() throws Exception {
       }
    }
 
+   @Test
+   public void testDatabaseStoreConfigurationProps() throws Exception {
+      ConfigurationImpl configuration = new ConfigurationImpl();
+      Properties insertionOrderedProperties = new ConfigurationImpl.InsertionOrderedProperties();
+      insertionOrderedProperties.put(""storeConfiguration"", ""DATABASE"");
+      insertionOrderedProperties.put(""storeConfiguration.largeMessageTableName"", ""lmtn"");
+      insertionOrderedProperties.put(""storeConfiguration.messageTableName"", ""mtn"");
+      insertionOrderedProperties.put(""storeConfiguration.bindingsTableName"", ""btn"");
+      insertionOrderedProperties.put(""storeConfiguration.dataSourceClassName"", ""dscn"");
+      insertionOrderedProperties.put(""storeConfiguration.nodeManagerStoreTableName"", ""nmtn"");
+      insertionOrderedProperties.put(""storeConfiguration.pageStoreTableName"", ""pstn"");
+      insertionOrderedProperties.put(""storeConfiguration.jdbcAllowedTimeDiff"", 123);
+      insertionOrderedProperties.put(""storeConfiguration.jdbcConnectionUrl"", ""url"");
+      insertionOrderedProperties.put(""storeConfiguration.jdbcDriverClassName"", ""dcn"");
+      insertionOrderedProperties.put(""storeConfiguration.jdbcJournalSyncPeriodMillis"", 456);
+      insertionOrderedProperties.put(""storeConfiguration.jdbcLockAcquisitionTimeoutMillis"", 789);
+      insertionOrderedProperties.put(""storeConfiguration.jdbcLockExpirationMillis"", 321);
+      insertionOrderedProperties.put(""storeConfiguration.jdbcLockRenewPeriodMillis"", 654);
+      insertionOrderedProperties.put(""storeConfiguration.jdbcNetworkTimeout"", 987);
+      insertionOrderedProperties.put(""storeConfiguration.jdbcPassword"", ""pass"");
+      insertionOrderedProperties.put(""storeConfiguration.jdbcUser"", ""user"");
+      configuration.parsePrefixedProperties(insertionOrderedProperties, null);
+      Assert.assertTrue(configuration.getStoreConfiguration() instanceof DatabaseStorageConfiguration);
+      DatabaseStorageConfiguration dsc = (DatabaseStorageConfiguration) configuration.getStoreConfiguration();
+      Assert.assertEquals(dsc.getLargeMessageTableName(), ""lmtn"");
+      Assert.assertEquals(dsc.getMessageTableName(), ""mtn"");
+      Assert.assertEquals(dsc.getBindingsTableName(), ""btn"");
+      Assert.assertEquals(dsc.getDataSourceClassName(), ""dscn"");
+      Assert.assertEquals(dsc.getJdbcAllowedTimeDiff(), 123);
+      Assert.assertEquals(dsc.getJdbcConnectionUrl(), ""url"");
+      Assert.assertEquals(dsc.getJdbcDriverClassName(), ""dcn"");
+      Assert.assertEquals(dsc.getJdbcJournalSyncPeriodMillis(), 456);
+      Assert.assertEquals(dsc.getJdbcLockAcquisitionTimeoutMillis(), 789);
+      Assert.assertEquals(dsc.getJdbcLockExpirationMillis(), 321);
+      Assert.assertEquals(dsc.getJdbcLockRenewPeriodMillis(), 654);
+      Assert.assertEquals(dsc.getJdbcNetworkTimeout(), 987);
+      Assert.assertEquals(dsc.getJdbcPassword(), ""pass"");
+      Assert.assertEquals(dsc.getJdbcUser(), ""user"");
+      Assert.assertEquals(dsc.getNodeManagerStoreTableName(), ""nmtn"");
+      Assert.assertEquals(dsc.getPageStoreTableName(), ""pstn"");
+   }
+
    @Test","[{'comment': 'a negative test where the value is wrong would be great. to see what error comes out. the error should be in the Status.', 'commenter': 'gtully'}, {'comment': 'Negative test added as well', 'commenter': 'andytaylor'}]"
